
line 20: # define SQLITE_CORE 1 
line 21: # define SQLITE_AMALGAMATION 1 
line 22: # ifndef SQLITE_PRIVATE 
line 23: # define SQLITE_PRIVATE static 
line 24: # endif 
line 25: # ifndef SQLITE_API 
line 26: # define SQLITE_API 
line 27: # endif 
line 43: # ifndef _SQLITEINT_H_ 
line 44: # define _SQLITEINT_H_ 
line 65: # ifndef SQLITE_DISABLE_LFS 
line 66: # define _LARGE_FILE 1 
line 67: # ifndef _FILE_OFFSET_BITS 
line 68: # define _FILE_OFFSET_BITS 64 
line 69: # endif 
line 70: # define _LARGEFILE_SOURCE 1 
line 71: # endif 
line 77: # ifdef _HAVE_SQLITE_CONFIG_H 
line 78: # include "config.h" 
line 79: # endif 
line 105: # ifndef SQLITE_MAX_LENGTH 
line 106: # define SQLITE_MAX_LENGTH 1000000000 
line 107: # endif 
line 126: # ifndef SQLITE_MAX_COLUMN 
line 127: # define SQLITE_MAX_COLUMN 2000 
line 128: # endif 
line 137: # ifndef SQLITE_MAX_SQL_LENGTH 
line 138: # define SQLITE_MAX_SQL_LENGTH 1000000000 
line 139: # endif 
line 151: # ifndef SQLITE_MAX_EXPR_DEPTH 
line 152: # define SQLITE_MAX_EXPR_DEPTH 1000 
line 153: # endif 
line 163: # ifndef SQLITE_MAX_COMPOUND_SELECT 
line 164: # define SQLITE_MAX_COMPOUND_SELECT 500 
line 165: # endif 
line 171: # ifndef SQLITE_MAX_VDBE_OP 
line 172: # define SQLITE_MAX_VDBE_OP 25000 
line 173: # endif 
line 178: # ifndef SQLITE_MAX_FUNCTION_ARG 
line 179: # define SQLITE_MAX_FUNCTION_ARG 127 
line 180: # endif 
line 186: # ifndef SQLITE_DEFAULT_CACHE_SIZE 
line 187: # define SQLITE_DEFAULT_CACHE_SIZE 2000 
line 188: # endif 
line 189: # ifndef SQLITE_DEFAULT_TEMP_CACHE_SIZE 
line 190: # define SQLITE_DEFAULT_TEMP_CACHE_SIZE 500 
line 191: # endif 
line 198: # ifndef SQLITE_MAX_ATTACHED 
line 199: # define SQLITE_MAX_ATTACHED 10 
line 200: # endif 
line 206: # ifndef SQLITE_MAX_VARIABLE_NUMBER 
line 207: # define SQLITE_MAX_VARIABLE_NUMBER 999 
line 208: # endif 
line 221: # ifndef SQLITE_MAX_PAGE_SIZE 
line 222: # define SQLITE_MAX_PAGE_SIZE 32768 
line 223: # endif 
line 229: # ifndef SQLITE_DEFAULT_PAGE_SIZE 
line 230: # define SQLITE_DEFAULT_PAGE_SIZE 1024 
line 231: # endif 
line 232: # if SQLITE_DEFAULT_PAGE_SIZE > SQLITE_MAX_PAGE_SIZE 
line 233: # undef SQLITE_DEFAULT_PAGE_SIZE 
line 234: # define SQLITE_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE 
line 235: # endif 
line 244: # ifndef SQLITE_MAX_DEFAULT_PAGE_SIZE 
line 245: # define SQLITE_MAX_DEFAULT_PAGE_SIZE 8192 
line 246: # endif 
line 247: # if SQLITE_MAX_DEFAULT_PAGE_SIZE > SQLITE_MAX_PAGE_SIZE 
line 248: # undef SQLITE_MAX_DEFAULT_PAGE_SIZE 
line 249: # define SQLITE_MAX_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE 
line 250: # endif 
line 260: # ifndef SQLITE_MAX_PAGE_COUNT 
line 261: # define SQLITE_MAX_PAGE_COUNT 1073741823 
line 262: # endif 
line 268: # ifndef SQLITE_MAX_LIKE_PATTERN_LENGTH 
line 269: # define SQLITE_MAX_LIKE_PATTERN_LENGTH 50000 
line 270: # endif 
line 279: # ifndef SQLITE_MAX_TRIGGER_DEPTH 
line 280: # define SQLITE_MAX_TRIGGER_DEPTH 1000 
line 281: # endif 
line 287: # if defined ( __BORLANDC__ ) 
line 288: # pragma warn - rch 
line 289: # pragma warn - ccc 
line 290: # pragma warn - aus 
line 291: # pragma warn - csu 
line 292: # pragma warn - spa 
line 293: # endif 
line 296: # ifndef _GNU_SOURCE 
line 297: # define _GNU_SOURCE 
line 298: # endif 
line 303: # ifdef HAVE_STDINT_H 
line 304: # include < stdint . h > 
line 305: # endif 
line 306: # ifdef HAVE_INTTYPES_H 
line 307: # include < inttypes . h > 
line 308: # endif 
line 310: # define SQLITE_INDEX_SAMPLES 10 
line 331: # if defined ( __GNUC__ ) 
line 332: # if defined ( HAVE_STDINT_H ) 
line 333: # define SQLITE_INT_TO_PTR ( X ) ( ( void * ) ( intptr_t ) ( X ) ) 
line 334: # define SQLITE_PTR_TO_INT ( X ) ( ( int ) ( intptr_t ) ( X ) ) 
line 335: # else 
line 336: # define SQLITE_INT_TO_PTR ( X ) ( ( void * ) ( X ) ) 
line 337: # define SQLITE_PTR_TO_INT ( X ) ( ( int ) ( X ) ) 
line 338: # endif 
line 339: # else 
line 340: # define SQLITE_INT_TO_PTR ( X ) ( ( void * ) & ( ( char * ) 0 ) [ X ] ) 
line 341: # define SQLITE_PTR_TO_INT ( X ) ( ( int ) ( ( ( char * ) X ) - ( char * ) 0 ) ) 
line 342: # endif 
line 350: # if ! defined ( SQLITE_THREADSAFE ) 
line 351: # if defined ( THREADSAFE ) 
line 352: # define SQLITE_THREADSAFE THREADSAFE 
line 353: # else 
line 354: # define SQLITE_THREADSAFE 1 
line 355: # endif 
line 356: # endif 
line 364: # if ! defined ( SQLITE_DEFAULT_MEMSTATUS ) 
line 365: # define SQLITE_DEFAULT_MEMSTATUS 1 
line 366: # endif 
line 381: # if defined ( SQLITE_SYSTEM_MALLOC ) + defined ( SQLITE_MEMDEBUG ) 
line 382: + defined ( SQLITE_MEMORY_SIZE ) + defined ( SQLITE_MMAP_HEAP_SIZE ) 
line 383: + defined ( SQLITE_POW2_MEMORY_SIZE ) > 1 
line 384: # error 
line 385: "At most one of the following compile-time configuration options\
 is allows : SQLITE_SYSTEM_MALLOC , SQLITE_MEMDEBUG , SQLITE_MEMORY_SIZE 
line 386: , SQLITE_MMAP_HEAP_SIZE , SQLITE_POW2_MEMORY_SIZE 
line 387: "
 # endif 
line 388: # if defined ( SQLITE_SYSTEM_MALLOC ) + defined ( SQLITE_MEMDEBUG ) 
line 389: + defined ( SQLITE_MEMORY_SIZE ) + defined ( SQLITE_MMAP_HEAP_SIZE ) 
line 390: + defined ( SQLITE_POW2_MEMORY_SIZE ) == 0 
line 391: # define SQLITE_SYSTEM_MALLOC 1 
line 392: # endif 
line 398: # if ! defined ( SQLITE_MALLOC_SOFT_LIMIT ) 
line 399: # define SQLITE_MALLOC_SOFT_LIMIT 1024 
line 400: # endif 
line 415: # if ! defined ( _XOPEN_SOURCE ) && ! defined ( __DARWIN__ ) && ! defined ( __APPLE__ ) && SQLITE_THREADSAFE 
line 416: # define _XOPEN_SOURCE 500 
line 417: # endif 
line 422: # if defined ( SQLITE_TCL ) || defined ( TCLSH ) 
line 423: # include < tcl . h > 
line 424: # endif 
line 433: # if ! defined ( NDEBUG ) && ! defined ( SQLITE_DEBUG ) 
line 434: # define NDEBUG 1 
line 435: # endif 
line 451: # ifdef SQLITE_COVERAGE_TEST 
line 452: SQLITE_PRIVATE void sqlite3Coverage ( int ) ; 
line 453: # define testcase ( X ) if ( X ) { sqlite3Coverage ( __LINE__ ) ; } 
line 454: # else 
line 455: # define testcase ( X ) 
line 456: # endif 
line 463: # if ! defined ( NDEBUG ) || defined ( SQLITE_COVERAGE_TEST ) 
line 464: # define TESTONLY ( X ) X 
line 465: # else 
line 466: # define TESTONLY ( X ) 
line 467: # endif 
line 477: # ifndef NDEBUG 
line 478: # define VVA_ONLY ( X ) X 
line 479: # else 
line 480: # define VVA_ONLY ( X ) 
line 481: # endif 
line 498: # if defined ( SQLITE_COVERAGE_TEST ) 
line 499: # define ALWAYS ( X ) ( 1 ) 
line 500: # define NEVER ( X ) ( 0 ) 
line 501: # elif ! defined ( NDEBUG ) 
line 502: # define ALWAYS ( X ) ( ( X ) ? 1 : ( assert ( 0 ) , 0 ) ) 
line 503: # define NEVER ( X ) ( ( X ) ? ( assert ( 0 ) , 1 ) : 0 ) 
line 504: # else 
line 505: # define ALWAYS ( X ) ( X ) 
line 506: # define NEVER ( X ) ( X ) 
line 507: # endif 
line 515: # if defined ( __GNUC__ ) && 0 
line 516: # define likely ( X ) __builtin_expect ( ( X ) , 1 ) 
line 517: # define unlikely ( X ) __builtin_expect ( ( X ) , 0 ) 
line 518: # else 
line 519: # define likely ( X ) !! ( X ) 
line 520: # define unlikely ( X ) !! ( X ) 
line 521: # endif 
line 557: # ifndef _SQLITE3_H_ 
line 558: # define _SQLITE3_H_ 
line 559: # include < stdarg . h > 
line 564: # if 0 
line 565: extern "C" { 
line 566: # endif 
line 572: # ifndef SQLITE_EXTERN 
line 573: # define SQLITE_EXTERN extern 
line 574: # endif 
line 576: # ifndef SQLITE_API 
line 577: # define SQLITE_API 
line 578: # endif 
line 594: # define SQLITE_DEPRECATED 
line 595: # define SQLITE_EXPERIMENTAL 
line 600: # ifdef SQLITE_VERSION 
line 601: # undef SQLITE_VERSION 
line 602: # endif 
line 603: # ifdef SQLITE_VERSION_NUMBER 
line 604: # undef SQLITE_VERSION_NUMBER 
line 605: # endif 
line 634: # define SQLITE_VERSION "3.6.22" 
line 635: # define SQLITE_VERSION_NUMBER 3006022 
line 636: # define SQLITE_SOURCE_ID "2010-01-05 15:30:36 28d0d7710761114a44a1a3a425a6883c661f06e7" 
line 668: SQLITE_API const char sqlite3_version [ ] = SQLITE_VERSION ; 
line 669: SQLITE_API const char * sqlite3_libversion ( void ) ; 
line 670: SQLITE_API const char * sqlite3_sourceid ( void ) ; 
line 671: SQLITE_API int sqlite3_libversion_number ( void ) ; 
line 709: SQLITE_API int sqlite3_threadsafe ( void ) ; 
line 724: typedef struct sqlite3 sqlite3 ; 
line 742: # ifdef SQLITE_INT64_TYPE 
line 743: typedef SQLITE_INT64_TYPE sqlite_int64 ; 
line 744: typedef unsigned SQLITE_INT64_TYPE sqlite_uint64 ; 
line 745: # elif defined ( _MSC_VER ) || defined ( __BORLANDC__ ) 
line 746: typedef __int64 sqlite_int64 ; 
line 747: typedef unsigned __int64 sqlite_uint64 ; 
line 748: # else 
line 749: typedef long long int sqlite_int64 ; 
line 750: typedef unsigned long long int sqlite_uint64 ; 
line 751: # endif 
line 752: typedef sqlite_int64 sqlite3_int64 ; 
line 753: typedef sqlite_uint64 sqlite3_uint64 ; 
line 759: # ifdef SQLITE_OMIT_FLOATING_POINT 
line 760: # define double sqlite3_int64 
line 761: # endif 
line 787: SQLITE_API int sqlite3_close ( sqlite3 * ) ; 
line 794: typedef int ( * sqlite3_callback ) ( void * , int , char * * , char * * ) ; 
line 857: SQLITE_API int sqlite3_exec ( 
line 858: sqlite3 * , 
line 859: const char * sql , 
line 860: int ( * callback ) ( void * , int , char * * , char * * ) , 
line 861: void * , 
line 862: char * * errmsg 
line 863: ) ; 
line 877: # define SQLITE_OK 0 
line 879: # define SQLITE_ERROR 1 
line 880: # define SQLITE_INTERNAL 2 
line 881: # define SQLITE_PERM 3 
line 882: # define SQLITE_ABORT 4 
line 883: # define SQLITE_BUSY 5 
line 884: # define SQLITE_LOCKED 6 
line 885: # define SQLITE_NOMEM 7 
line 886: # define SQLITE_READONLY 8 
line 887: # define SQLITE_INTERRUPT 9 
line 888: # define SQLITE_IOERR 10 
line 889: # define SQLITE_CORRUPT 11 
line 890: # define SQLITE_NOTFOUND 12 
line 891: # define SQLITE_FULL 13 
line 892: # define SQLITE_CANTOPEN 14 
line 893: # define SQLITE_PROTOCOL 15 
line 894: # define SQLITE_EMPTY 16 
line 895: # define SQLITE_SCHEMA 17 
line 896: # define SQLITE_TOOBIG 18 
line 897: # define SQLITE_CONSTRAINT 19 
line 898: # define SQLITE_MISMATCH 20 
line 899: # define SQLITE_MISUSE 21 
line 900: # define SQLITE_NOLFS 22 
line 901: # define SQLITE_AUTH 23 
line 902: # define SQLITE_FORMAT 24 
line 903: # define SQLITE_RANGE 25 
line 904: # define SQLITE_NOTADB 26 
line 905: # define SQLITE_ROW 100 
line 906: # define SQLITE_DONE 101 
line 932: # define SQLITE_IOERR_READ ( SQLITE_IOERR | ( 1 << 8 ) ) 
line 933: # define SQLITE_IOERR_SHORT_READ ( SQLITE_IOERR | ( 2 << 8 ) ) 
line 934: # define SQLITE_IOERR_WRITE ( SQLITE_IOERR | ( 3 << 8 ) ) 
line 935: # define SQLITE_IOERR_FSYNC ( SQLITE_IOERR | ( 4 << 8 ) ) 
line 936: # define SQLITE_IOERR_DIR_FSYNC ( SQLITE_IOERR | ( 5 << 8 ) ) 
line 937: # define SQLITE_IOERR_TRUNCATE ( SQLITE_IOERR | ( 6 << 8 ) ) 
line 938: # define SQLITE_IOERR_FSTAT ( SQLITE_IOERR | ( 7 << 8 ) ) 
line 939: # define SQLITE_IOERR_UNLOCK ( SQLITE_IOERR | ( 8 << 8 ) ) 
line 940: # define SQLITE_IOERR_RDLOCK ( SQLITE_IOERR | ( 9 << 8 ) ) 
line 941: # define SQLITE_IOERR_DELETE ( SQLITE_IOERR | ( 10 << 8 ) ) 
line 942: # define SQLITE_IOERR_BLOCKED ( SQLITE_IOERR | ( 11 << 8 ) ) 
line 943: # define SQLITE_IOERR_NOMEM ( SQLITE_IOERR | ( 12 << 8 ) ) 
line 944: # define SQLITE_IOERR_ACCESS ( SQLITE_IOERR | ( 13 << 8 ) ) 
line 945: # define SQLITE_IOERR_CHECKRESERVEDLOCK ( SQLITE_IOERR | ( 14 << 8 ) ) 
line 946: # define SQLITE_IOERR_LOCK ( SQLITE_IOERR | ( 15 << 8 ) ) 
line 947: # define SQLITE_IOERR_CLOSE ( SQLITE_IOERR | ( 16 << 8 ) ) 
line 948: # define SQLITE_IOERR_DIR_CLOSE ( SQLITE_IOERR | ( 17 << 8 ) ) 
line 949: # define SQLITE_LOCKED_SHAREDCACHE ( SQLITE_LOCKED | ( 1 << 8 ) ) 
line 959: # define SQLITE_OPEN_READONLY 0x00000001 
line 960: # define SQLITE_OPEN_READWRITE 0x00000002 
line 961: # define SQLITE_OPEN_CREATE 0x00000004 
line 962: # define SQLITE_OPEN_DELETEONCLOSE 0x00000008 
line 963: # define SQLITE_OPEN_EXCLUSIVE 0x00000010 
line 964: # define SQLITE_OPEN_MAIN_DB 0x00000100 
line 965: # define SQLITE_OPEN_TEMP_DB 0x00000200 
line 966: # define SQLITE_OPEN_TRANSIENT_DB 0x00000400 
line 967: # define SQLITE_OPEN_MAIN_JOURNAL 0x00000800 
line 968: # define SQLITE_OPEN_TEMP_JOURNAL 0x00001000 
line 969: # define SQLITE_OPEN_SUBJOURNAL 0x00002000 
line 970: # define SQLITE_OPEN_MASTER_JOURNAL 0x00004000 
line 971: # define SQLITE_OPEN_NOMUTEX 0x00008000 
line 972: # define SQLITE_OPEN_FULLMUTEX 0x00010000 
line 973: # define SQLITE_OPEN_SHAREDCACHE 0x00020000 
line 974: # define SQLITE_OPEN_PRIVATECACHE 0x00040000 
line 996: # define SQLITE_IOCAP_ATOMIC 0x00000001 
line 997: # define SQLITE_IOCAP_ATOMIC512 0x00000002 
line 998: # define SQLITE_IOCAP_ATOMIC1K 0x00000004 
line 999: # define SQLITE_IOCAP_ATOMIC2K 0x00000008 
line 1000: # define SQLITE_IOCAP_ATOMIC4K 0x00000010 
line 1001: # define SQLITE_IOCAP_ATOMIC8K 0x00000020 
line 1002: # define SQLITE_IOCAP_ATOMIC16K 0x00000040 
line 1003: # define SQLITE_IOCAP_ATOMIC32K 0x00000080 
line 1004: # define SQLITE_IOCAP_ATOMIC64K 0x00000100 
line 1005: # define SQLITE_IOCAP_SAFE_APPEND 0x00000200 
line 1006: # define SQLITE_IOCAP_SEQUENTIAL 0x00000400 
line 1015: # define SQLITE_LOCK_NONE 0 
line 1016: # define SQLITE_LOCK_SHARED 1 
line 1017: # define SQLITE_LOCK_RESERVED 2 
line 1018: # define SQLITE_LOCK_PENDING 3 
line 1019: # define SQLITE_LOCK_EXCLUSIVE 4 
line 1035: # define SQLITE_SYNC_NORMAL 0x00002 
line 1036: # define SQLITE_SYNC_FULL 0x00003 
line 1037: # define SQLITE_SYNC_DATAONLY 0x00010 
line 1050: typedef struct sqlite3_file sqlite3_file ; 
line 1051: struct sqlite3_file { 
line 1052: const struct sqlite3_io_methods * pMethods ; 
line 1053: } ; 
line 1142: typedef struct sqlite3_io_methods sqlite3_io_methods ; 
line 1143: struct sqlite3_io_methods { 
line 1144: int iVersion ; 
line 1145: int ( * xClose ) ( sqlite3_file * ) ; 
line 1146: int ( * xRead ) ( sqlite3_file * , void * , int iAmt , sqlite3_int64 iOfst ) ; 
line 1147: int ( * xWrite ) ( sqlite3_file * , const void * , int iAmt , sqlite3_int64 iOfst ) ; 
line 1148: int ( * xTruncate ) ( sqlite3_file * , sqlite3_int64 size ) ; 
line 1149: int ( * xSync ) ( sqlite3_file * , int flags ) ; 
line 1150: int ( * xFileSize ) ( sqlite3_file * , sqlite3_int64 * pSize ) ; 
line 1151: int ( * xLock ) ( sqlite3_file * , int ) ; 
line 1152: int ( * xUnlock ) ( sqlite3_file * , int ) ; 
line 1153: int ( * xCheckReservedLock ) ( sqlite3_file * , int * pResOut ) ; 
line 1154: int ( * xFileControl ) ( sqlite3_file * , int op , void * pArg ) ; 
line 1155: int ( * xSectorSize ) ( sqlite3_file * ) ; 
line 1156: int ( * xDeviceCharacteristics ) ( sqlite3_file * ) ; 
line 1158: } ; 
line 1175: # define SQLITE_FCNTL_LOCKSTATE 1 
line 1176: # define SQLITE_GET_LOCKPROXYFILE 2 
line 1177: # define SQLITE_SET_LOCKPROXYFILE 3 
line 1178: # define SQLITE_LAST_ERRNO 4 
line 1190: typedef struct sqlite3_mutex sqlite3_mutex ; 
line 1321: typedef struct sqlite3_vfs sqlite3_vfs ; 
line 1322: struct sqlite3_vfs { 
line 1323: int iVersion ; 
line 1324: int szOsFile ; 
line 1325: int mxPathname ; 
line 1326: sqlite3_vfs * pNext ; 
line 1327: const char * zName ; 
line 1328: void * pAppData ; 
line 1329: int ( * xOpen ) ( sqlite3_vfs * , const char * zName , sqlite3_file * , 
line 1330: int flags , int * pOutFlags ) ; 
line 1331: int ( * xDelete ) ( sqlite3_vfs * , const char * zName , int syncDir ) ; 
line 1332: int ( * xAccess ) ( sqlite3_vfs * , const char * zName , int flags , int * pResOut ) ; 
line 1333: int ( * xFullPathname ) ( sqlite3_vfs * , const char * zName , int nOut , char * zOut ) ; 
line 1334: void * ( * xDlOpen ) ( sqlite3_vfs * , const char * zFilename ) ; 
line 1335: void ( * xDlError ) ( sqlite3_vfs * , int nByte , char * zErrMsg ) ; 
line 1336: void ( * ( * xDlSym ) ( sqlite3_vfs * , void * , const char * zSymbol ) ) ( void ) ; 
line 1337: void ( * xDlClose ) ( sqlite3_vfs * , void * ) ; 
line 1338: int ( * xRandomness ) ( sqlite3_vfs * , int nByte , char * zOut ) ; 
line 1339: int ( * xSleep ) ( sqlite3_vfs * , int microseconds ) ; 
line 1340: int ( * xCurrentTime ) ( sqlite3_vfs * , double * ) ; 
line 1341: int ( * xGetLastError ) ( sqlite3_vfs * , int , char * ) ; 
line 1344: } ; 
line 1359: # define SQLITE_ACCESS_EXISTS 0 
line 1360: # define SQLITE_ACCESS_READWRITE 1 
line 1361: # define SQLITE_ACCESS_READ 2 
line 1438: SQLITE_API int sqlite3_initialize ( void ) ; 
line 1439: SQLITE_API int sqlite3_shutdown ( void ) ; 
line 1440: SQLITE_API int sqlite3_os_init ( void ) ; 
line 1441: SQLITE_API int sqlite3_os_end ( void ) ; 
line 1473: SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_config ( int , ... ) ; 
line 1497: SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_db_config ( sqlite3 * , int op , ... ) ; 
line 1569: typedef struct sqlite3_mem_methods sqlite3_mem_methods ; 
line 1570: struct sqlite3_mem_methods { 
line 1571: void * ( * xMalloc ) ( int ) ; 
line 1572: void ( * xFree ) ( void * ) ; 
line 1573: void * ( * xRealloc ) ( void * , int ) ; 
line 1574: int ( * xSize ) ( void * ) ; 
line 1575: int ( * xRoundup ) ( int ) ; 
line 1576: int ( * xInit ) ( void * ) ; 
line 1577: void ( * xShutdown ) ( void * ) ; 
line 1578: void * pAppData ; 
line 1579: } ; 
line 1771: # define SQLITE_CONFIG_SINGLETHREAD 1 
line 1772: # define SQLITE_CONFIG_MULTITHREAD 2 
line 1773: # define SQLITE_CONFIG_SERIALIZED 3 
line 1774: # define SQLITE_CONFIG_MALLOC 4 
line 1775: # define SQLITE_CONFIG_GETMALLOC 5 
line 1776: # define SQLITE_CONFIG_SCRATCH 6 
line 1777: # define SQLITE_CONFIG_PAGECACHE 7 
line 1778: # define SQLITE_CONFIG_HEAP 8 
line 1779: # define SQLITE_CONFIG_MEMSTATUS 9 
line 1780: # define SQLITE_CONFIG_MUTEX 10 
line 1781: # define SQLITE_CONFIG_GETMUTEX 11 
line 1783: # define SQLITE_CONFIG_LOOKASIDE 13 
line 1784: # define SQLITE_CONFIG_PCACHE 14 
line 1785: # define SQLITE_CONFIG_GETPCACHE 15 
line 1820: # define SQLITE_DBCONFIG_LOOKASIDE 1001 
line 1830: SQLITE_API int sqlite3_extended_result_codes ( sqlite3 * , int onoff ) ; 
line 1875: SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid ( sqlite3 * ) ; 
line 1929: SQLITE_API int sqlite3_changes ( sqlite3 * ) ; 
line 1955: SQLITE_API int sqlite3_total_changes ( sqlite3 * ) ; 
line 1994: SQLITE_API void sqlite3_interrupt ( sqlite3 * ) ; 
line 2029: SQLITE_API int sqlite3_complete ( const char * sql ) ; 
line 2030: SQLITE_API int sqlite3_complete16 ( const void * sql ) ; 
line 2096: SQLITE_API int sqlite3_busy_handler ( sqlite3 * , int ( * ) ( void * , int ) , void * ) ; 
line 2116: SQLITE_API int sqlite3_busy_timeout ( sqlite3 * , int ms ) ; 
line 2187: SQLITE_API int sqlite3_get_table ( 
line 2188: sqlite3 * db , 
line 2189: const char * zSql , 
line 2190: char * * * pazResult , 
line 2191: int * pnRow , 
line 2192: int * pnColumn , 
line 2193: char * * pzErrmsg 
line 2194: ) ; 
line 2195: SQLITE_API void sqlite3_free_table ( char * * result ) ; 
line 2289: SQLITE_API char * sqlite3_mprintf ( const char * , ... ) ; 
line 2290: SQLITE_API char * sqlite3_vmprintf ( const char * , va_list ) ; 
line 2291: SQLITE_API char * sqlite3_snprintf ( int , char * , const char * , ... ) ; 
line 2361: SQLITE_API void * sqlite3_malloc ( int ) ; 
line 2362: SQLITE_API void * sqlite3_realloc ( void * , int ) ; 
line 2363: SQLITE_API void sqlite3_free ( void * ) ; 
line 2388: SQLITE_API sqlite3_int64 sqlite3_memory_used ( void ) ; 
line 2389: SQLITE_API sqlite3_int64 sqlite3_memory_highwater ( int resetFlag ) ; 
line 2409: SQLITE_API void sqlite3_randomness ( int N , void * P ) ; 
line 2491: SQLITE_API int sqlite3_set_authorizer ( 
line 2492: sqlite3 * , 
line 2493: int ( * xAuth ) ( void * , int , const char * , const char * , const char * , const char * ) , 
line 2494: void * pUserData 
line 2495: ) ; 
line 2506: # define SQLITE_DENY 1 
line 2507: # define SQLITE_IGNORE 2 
line 2529: # define SQLITE_CREATE_INDEX 1 
line 2530: # define SQLITE_CREATE_TABLE 2 
line 2531: # define SQLITE_CREATE_TEMP_INDEX 3 
line 2532: # define SQLITE_CREATE_TEMP_TABLE 4 
line 2533: # define SQLITE_CREATE_TEMP_TRIGGER 5 
line 2534: # define SQLITE_CREATE_TEMP_VIEW 6 
line 2535: # define SQLITE_CREATE_TRIGGER 7 
line 2536: # define SQLITE_CREATE_VIEW 8 
line 2537: # define SQLITE_DELETE 9 
line 2538: # define SQLITE_DROP_INDEX 10 
line 2539: # define SQLITE_DROP_TABLE 11 
line 2540: # define SQLITE_DROP_TEMP_INDEX 12 
line 2541: # define SQLITE_DROP_TEMP_TABLE 13 
line 2542: # define SQLITE_DROP_TEMP_TRIGGER 14 
line 2543: # define SQLITE_DROP_TEMP_VIEW 15 
line 2544: # define SQLITE_DROP_TRIGGER 16 
line 2545: # define SQLITE_DROP_VIEW 17 
line 2546: # define SQLITE_INSERT 18 
line 2547: # define SQLITE_PRAGMA 19 
line 2548: # define SQLITE_READ 20 
line 2549: # define SQLITE_SELECT 21 
line 2550: # define SQLITE_TRANSACTION 22 
line 2551: # define SQLITE_UPDATE 23 
line 2552: # define SQLITE_ATTACH 24 
line 2553: # define SQLITE_DETACH 25 
line 2554: # define SQLITE_ALTER_TABLE 26 
line 2555: # define SQLITE_REINDEX 27 
line 2556: # define SQLITE_ANALYZE 28 
line 2557: # define SQLITE_CREATE_VTABLE 29 
line 2558: # define SQLITE_DROP_VTABLE 30 
line 2559: # define SQLITE_FUNCTION 31 
line 2560: # define SQLITE_SAVEPOINT 32 
line 2561: # define SQLITE_COPY 0 
line 2583: SQLITE_API SQLITE_EXPERIMENTAL void * sqlite3_trace ( sqlite3 * , void ( * xTrace ) ( void * , const char * ) , void * ) ; 
line 2584: SQLITE_API SQLITE_EXPERIMENTAL void * sqlite3_profile ( sqlite3 * , 
line 2585: void ( * xProfile ) ( void * , const char * , sqlite3_uint64 ) , void * ) ; 
line 2606: SQLITE_API void sqlite3_progress_handler ( sqlite3 * , int , int ( * ) ( void * ) , void * ) ; 
line 2697: SQLITE_API int sqlite3_open ( 
line 2698: const char * filename , 
line 2699: sqlite3 * * ppDb 
line 2700: ) ; 
line 2701: SQLITE_API int sqlite3_open16 ( 
line 2702: const void * filename , 
line 2703: sqlite3 * * ppDb 
line 2704: ) ; 
line 2705: SQLITE_API int sqlite3_open_v2 ( 
line 2706: const char * filename , 
line 2707: sqlite3 * * ppDb , 
line 2708: int flags , 
line 2709: const char * zVfs 
line 2710: ) ; 
line 2745: SQLITE_API int sqlite3_errcode ( sqlite3 * db ) ; 
line 2746: SQLITE_API int sqlite3_extended_errcode ( sqlite3 * db ) ; 
line 2747: SQLITE_API const char * sqlite3_errmsg ( sqlite3 * ) ; 
line 2748: SQLITE_API const void * sqlite3_errmsg16 ( sqlite3 * ) ; 
line 2774: typedef struct sqlite3_stmt sqlite3_stmt ; 
line 2810: SQLITE_API int sqlite3_limit ( sqlite3 * , int id , int newVal ) ; 
line 2861: # define SQLITE_LIMIT_LENGTH 0 
line 2862: # define SQLITE_LIMIT_SQL_LENGTH 1 
line 2863: # define SQLITE_LIMIT_COLUMN 2 
line 2864: # define SQLITE_LIMIT_EXPR_DEPTH 3 
line 2865: # define SQLITE_LIMIT_COMPOUND_SELECT 4 
line 2866: # define SQLITE_LIMIT_VDBE_OP 5 
line 2867: # define SQLITE_LIMIT_FUNCTION_ARG 6 
line 2868: # define SQLITE_LIMIT_ATTACHED 7 
line 2869: # define SQLITE_LIMIT_LIKE_PATTERN_LENGTH 8 
line 2870: # define SQLITE_LIMIT_VARIABLE_NUMBER 9 
line 2871: # define SQLITE_LIMIT_TRIGGER_DEPTH 10 
line 2953: SQLITE_API int sqlite3_prepare ( 
line 2954: sqlite3 * db , 
line 2955: const char * zSql , 
line 2956: int nByte , 
line 2957: sqlite3_stmt * * ppStmt , 
line 2958: const char * * pzTail 
line 2959: ) ; 
line 2960: SQLITE_API int sqlite3_prepare_v2 ( 
line 2961: sqlite3 * db , 
line 2962: const char * zSql , 
line 2963: int nByte , 
line 2964: sqlite3_stmt * * ppStmt , 
line 2965: const char * * pzTail 
line 2966: ) ; 
line 2967: SQLITE_API int sqlite3_prepare16 ( 
line 2968: sqlite3 * db , 
line 2969: const void * zSql , 
line 2970: int nByte , 
line 2971: sqlite3_stmt * * ppStmt , 
line 2972: const void * * pzTail 
line 2973: ) ; 
line 2974: SQLITE_API int sqlite3_prepare16_v2 ( 
line 2975: sqlite3 * db , 
line 2976: const void * zSql , 
line 2977: int nByte , 
line 2978: sqlite3_stmt * * ppStmt , 
line 2979: const void * * pzTail 
line 2980: ) ; 
line 2989: SQLITE_API const char * sqlite3_sql ( sqlite3_stmt * pStmt ) ; 
line 3028: typedef struct Mem sqlite3_value ; 
line 3042: typedef struct sqlite3_context sqlite3_context ; 
line 3123: SQLITE_API int sqlite3_bind_blob ( sqlite3_stmt * , int , const void * , int n , void ( * ) ( void * ) ) ; 
line 3124: SQLITE_API int sqlite3_bind_double ( sqlite3_stmt * , int , double ) ; 
line 3125: SQLITE_API int sqlite3_bind_int ( sqlite3_stmt * , int , int ) ; 
line 3126: SQLITE_API int sqlite3_bind_int64 ( sqlite3_stmt * , int , sqlite3_int64 ) ; 
line 3127: SQLITE_API int sqlite3_bind_null ( sqlite3_stmt * , int ) ; 
line 3128: SQLITE_API int sqlite3_bind_text ( sqlite3_stmt * , int , const char * , int n , void ( * ) ( void * ) ) ; 
line 3129: SQLITE_API int sqlite3_bind_text16 ( sqlite3_stmt * , int , const void * , int , void ( * ) ( void * ) ) ; 
line 3130: SQLITE_API int sqlite3_bind_value ( sqlite3_stmt * , int , const sqlite3_value * ) ; 
line 3131: SQLITE_API int sqlite3_bind_zeroblob ( sqlite3_stmt * , int , int n ) ; 
line 3151: SQLITE_API int sqlite3_bind_parameter_count ( sqlite3_stmt * ) ; 
line 3178: SQLITE_API const char * sqlite3_bind_parameter_name ( sqlite3_stmt * , int ) ; 
line 3194: SQLITE_API int sqlite3_bind_parameter_index ( sqlite3_stmt * , const char * zName ) ; 
line 3203: SQLITE_API int sqlite3_clear_bindings ( sqlite3_stmt * ) ; 
line 3212: SQLITE_API int sqlite3_column_count ( sqlite3_stmt * pStmt ) ; 
line 3238: SQLITE_API const char * sqlite3_column_name ( sqlite3_stmt * , int N ) ; 
line 3239: SQLITE_API const void * sqlite3_column_name16 ( sqlite3_stmt * , int N ) ; 
line 3284: SQLITE_API const char * sqlite3_column_database_name ( sqlite3_stmt * , int ) ; 
line 3285: SQLITE_API const void * sqlite3_column_database_name16 ( sqlite3_stmt * , int ) ; 
line 3286: SQLITE_API const char * sqlite3_column_table_name ( sqlite3_stmt * , int ) ; 
line 3287: SQLITE_API const void * sqlite3_column_table_name16 ( sqlite3_stmt * , int ) ; 
line 3288: SQLITE_API const char * sqlite3_column_origin_name ( sqlite3_stmt * , int ) ; 
line 3289: SQLITE_API const void * sqlite3_column_origin_name16 ( sqlite3_stmt * , int ) ; 
line 3320: SQLITE_API const char * sqlite3_column_decltype ( sqlite3_stmt * , int ) ; 
line 3321: SQLITE_API const void * sqlite3_column_decltype16 ( sqlite3_stmt * , int ) ; 
line 3388: SQLITE_API int sqlite3_step ( sqlite3_stmt * ) ; 
line 3396: SQLITE_API int sqlite3_data_count ( sqlite3_stmt * pStmt ) ; 
line 3419: # define SQLITE_INTEGER 1 
line 3420: # define SQLITE_FLOAT 2 
line 3421: # define SQLITE_BLOB 4 
line 3422: # define SQLITE_NULL 5 
line 3423: # ifdef SQLITE_TEXT 
line 3424: # undef SQLITE_TEXT 
line 3425: # else 
line 3426: # define SQLITE_TEXT 3 
line 3427: # endif 
line 3428: # define SQLITE3_TEXT 3 
line 3584: SQLITE_API const void * sqlite3_column_blob ( sqlite3_stmt * , int iCol ) ; 
line 3585: SQLITE_API int sqlite3_column_bytes ( sqlite3_stmt * , int iCol ) ; 
line 3586: SQLITE_API int sqlite3_column_bytes16 ( sqlite3_stmt * , int iCol ) ; 
line 3587: SQLITE_API double sqlite3_column_double ( sqlite3_stmt * , int iCol ) ; 
line 3588: SQLITE_API int sqlite3_column_int ( sqlite3_stmt * , int iCol ) ; 
line 3589: SQLITE_API sqlite3_int64 sqlite3_column_int64 ( sqlite3_stmt * , int iCol ) ; 
line 3590: SQLITE_API const unsigned char * sqlite3_column_text ( sqlite3_stmt * , int iCol ) ; 
line 3591: SQLITE_API const void * sqlite3_column_text16 ( sqlite3_stmt * , int iCol ) ; 
line 3592: SQLITE_API int sqlite3_column_type ( sqlite3_stmt * , int iCol ) ; 
line 3593: SQLITE_API sqlite3_value * sqlite3_column_value ( sqlite3_stmt * , int iCol ) ; 
line 3611: SQLITE_API int sqlite3_finalize ( sqlite3_stmt * pStmt ) ; 
line 3637: SQLITE_API int sqlite3_reset ( sqlite3_stmt * pStmt ) ; 
line 3719: SQLITE_API int sqlite3_create_function ( 
line 3720: sqlite3 * db , 
line 3721: const char * zFunctionName , 
line 3722: int nArg , 
line 3723: int eTextRep , 
line 3724: void * pApp , 
line 3725: void ( * xFunc ) ( sqlite3_context * , int , sqlite3_value * * ) , 
line 3726: void ( * xStep ) ( sqlite3_context * , int , sqlite3_value * * ) , 
line 3727: void ( * xFinal ) ( sqlite3_context * ) 
line 3728: ) ; 
line 3729: SQLITE_API int sqlite3_create_function16 ( 
line 3730: sqlite3 * db , 
line 3731: const void * zFunctionName , 
line 3732: int nArg , 
line 3733: int eTextRep , 
line 3734: void * pApp , 
line 3735: void ( * xFunc ) ( sqlite3_context * , int , sqlite3_value * * ) , 
line 3736: void ( * xStep ) ( sqlite3_context * , int , sqlite3_value * * ) , 
line 3737: void ( * xFinal ) ( sqlite3_context * ) 
line 3738: ) ; 
line 3746: # define SQLITE_UTF8 1 
line 3747: # define SQLITE_UTF16LE 2 
line 3748: # define SQLITE_UTF16BE 3 
line 3749: # define SQLITE_UTF16 4 
line 3750: # define SQLITE_ANY 5 
line 3751: # define SQLITE_UTF16_ALIGNED 8 
line 3763: # ifndef SQLITE_OMIT_DEPRECATED 
line 3764: SQLITE_API SQLITE_DEPRECATED int sqlite3_aggregate_count ( sqlite3_context * ) ; 
line 3765: SQLITE_API SQLITE_DEPRECATED int sqlite3_expired ( sqlite3_stmt * ) ; 
line 3766: SQLITE_API SQLITE_DEPRECATED int sqlite3_transfer_bindings ( sqlite3_stmt * , sqlite3_stmt * ) ; 
line 3767: SQLITE_API SQLITE_DEPRECATED int sqlite3_global_recover ( void ) ; 
line 3768: SQLITE_API SQLITE_DEPRECATED void sqlite3_thread_cleanup ( void ) ; 
line 3769: SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm ( void ( * ) ( void * , sqlite3_int64 , int ) , void * , sqlite3_int64 ) ; 
line 3770: # endif 
line 3817: SQLITE_API const void * sqlite3_value_blob ( sqlite3_value * ) ; 
line 3818: SQLITE_API int sqlite3_value_bytes ( sqlite3_value * ) ; 
line 3819: SQLITE_API int sqlite3_value_bytes16 ( sqlite3_value * ) ; 
line 3820: SQLITE_API double sqlite3_value_double ( sqlite3_value * ) ; 
line 3821: SQLITE_API int sqlite3_value_int ( sqlite3_value * ) ; 
line 3822: SQLITE_API sqlite3_int64 sqlite3_value_int64 ( sqlite3_value * ) ; 
line 3823: SQLITE_API const unsigned char * sqlite3_value_text ( sqlite3_value * ) ; 
line 3824: SQLITE_API const void * sqlite3_value_text16 ( sqlite3_value * ) ; 
line 3825: SQLITE_API const void * sqlite3_value_text16le ( sqlite3_value * ) ; 
line 3826: SQLITE_API const void * sqlite3_value_text16be ( sqlite3_value * ) ; 
line 3827: SQLITE_API int sqlite3_value_type ( sqlite3_value * ) ; 
line 3828: SQLITE_API int sqlite3_value_numeric_type ( sqlite3_value * ) ; 
line 3869: SQLITE_API void * sqlite3_aggregate_context ( sqlite3_context * , int nBytes ) ; 
line 3883: SQLITE_API void * sqlite3_user_data ( sqlite3_context * ) ; 
line 3894: SQLITE_API sqlite3 * sqlite3_context_db_handle ( sqlite3_context * ) ; 
line 3938: SQLITE_API void * sqlite3_get_auxdata ( sqlite3_context * , int N ) ; 
line 3939: SQLITE_API void sqlite3_set_auxdata ( sqlite3_context * , int N , void * , void ( * ) ( void * ) ) ; 
line 3956: typedef void ( * sqlite3_destructor_type ) ( void * ) ; 
line 3957: # define SQLITE_STATIC ( ( sqlite3_destructor_type ) 0 ) 
line 3958: # define SQLITE_TRANSIENT ( ( sqlite3_destructor_type ) - 1 ) 
line 4065: SQLITE_API void sqlite3_result_blob ( sqlite3_context * , const void * , int , void ( * ) ( void * ) ) ; 
line 4066: SQLITE_API void sqlite3_result_double ( sqlite3_context * , double ) ; 
line 4067: SQLITE_API void sqlite3_result_error ( sqlite3_context * , const char * , int ) ; 
line 4068: SQLITE_API void sqlite3_result_error16 ( sqlite3_context * , const void * , int ) ; 
line 4069: SQLITE_API void sqlite3_result_error_toobig ( sqlite3_context * ) ; 
line 4070: SQLITE_API void sqlite3_result_error_nomem ( sqlite3_context * ) ; 
line 4071: SQLITE_API void sqlite3_result_error_code ( sqlite3_context * , int ) ; 
line 4072: SQLITE_API void sqlite3_result_int ( sqlite3_context * , int ) ; 
line 4073: SQLITE_API void sqlite3_result_int64 ( sqlite3_context * , sqlite3_int64 ) ; 
line 4074: SQLITE_API void sqlite3_result_null ( sqlite3_context * ) ; 
line 4075: SQLITE_API void sqlite3_result_text ( sqlite3_context * , const char * , int , void ( * ) ( void * ) ) ; 
line 4076: SQLITE_API void sqlite3_result_text16 ( sqlite3_context * , const void * , int , void ( * ) ( void * ) ) ; 
line 4077: SQLITE_API void sqlite3_result_text16le ( sqlite3_context * , const void * , int , void ( * ) ( void * ) ) ; 
line 4078: SQLITE_API void sqlite3_result_text16be ( sqlite3_context * , const void * , int , void ( * ) ( void * ) ) ; 
line 4079: SQLITE_API void sqlite3_result_value ( sqlite3_context * , sqlite3_value * ) ; 
line 4080: SQLITE_API void sqlite3_result_zeroblob ( sqlite3_context * , int n ) ; 
line 4128: SQLITE_API int sqlite3_create_collation ( 
line 4129: sqlite3 * , 
line 4130: const char * zName , 
line 4131: int eTextRep , 
line 4132: void * , 
line 4133: int ( * xCompare ) ( void * , int , const void * , int , const void * ) 
line 4134: ) ; 
line 4135: SQLITE_API int sqlite3_create_collation_v2 ( 
line 4136: sqlite3 * , 
line 4137: const char * zName , 
line 4138: int eTextRep , 
line 4139: void * , 
line 4140: int ( * xCompare ) ( void * , int , const void * , int , const void * ) , 
line 4141: void ( * xDestroy ) ( void * ) 
line 4142: ) ; 
line 4143: SQLITE_API int sqlite3_create_collation16 ( 
line 4144: sqlite3 * , 
line 4145: const void * zName , 
line 4146: int eTextRep , 
line 4147: void * , 
line 4148: int ( * xCompare ) ( void * , int , const void * , int , const void * ) 
line 4149: ) ; 
line 4177: SQLITE_API int sqlite3_collation_needed ( 
line 4178: sqlite3 * , 
line 4179: void * , 
line 4180: void ( * ) ( void * , sqlite3 * , int eTextRep , const char * ) 
line 4181: ) ; 
line 4182: SQLITE_API int sqlite3_collation_needed16 ( 
line 4183: sqlite3 * , 
line 4184: void * , 
line 4185: void ( * ) ( void * , sqlite3 * , int eTextRep , const void * ) 
line 4186: ) ; 
line 4195: SQLITE_API int sqlite3_key ( 
line 4196: sqlite3 * db , 
line 4197: const void * pKey , int nKey 
line 4198: ) ; 
line 4208: SQLITE_API int sqlite3_rekey ( 
line 4209: sqlite3 * db , 
line 4210: const void * pKey , int nKey 
line 4211: ) ; 
line 4227: SQLITE_API int sqlite3_sleep ( int ) ; 
line 4258: SQLITE_API char * sqlite3_temp_directory ; 
line 4281: SQLITE_API int sqlite3_get_autocommit ( sqlite3 * ) ; 
line 4293: SQLITE_API sqlite3 * sqlite3_db_handle ( sqlite3_stmt * ) ; 
line 4308: SQLITE_API sqlite3_stmt * sqlite3_next_stmt ( sqlite3 * pDb , sqlite3_stmt * pStmt ) ; 
line 4356: SQLITE_API void * sqlite3_commit_hook ( sqlite3 * , int ( * ) ( void * ) , void * ) ; 
line 4357: SQLITE_API void * sqlite3_rollback_hook ( sqlite3 * , void ( * ) ( void * ) , void * ) ; 
line 4405: SQLITE_API void * sqlite3_update_hook ( 
line 4406: sqlite3 * , 
line 4407: void ( * ) ( void * , int , char const * , char const * , sqlite3_int64 ) , 
line 4408: void * 
line 4409: ) ; 
line 4438: SQLITE_API int sqlite3_enable_shared_cache ( int ) ; 
line 4450: SQLITE_API int sqlite3_release_memory ( int ) ; 
line 4482: SQLITE_API void sqlite3_soft_heap_limit ( int ) ; 
line 4546: SQLITE_API int sqlite3_table_column_metadata ( 
line 4547: sqlite3 * db , 
line 4548: const char * zDbName , 
line 4549: const char * zTableName , 
line 4550: const char * zColumnName , 
line 4551: char const * * pzDataType , 
line 4552: char const * * pzCollSeq , 
line 4553: int * pNotNull , 
line 4554: int * pPrimaryKey , 
line 4555: int * pAutoinc 
line 4556: ) ; 
line 4583: SQLITE_API int sqlite3_load_extension ( 
line 4584: sqlite3 * db , 
line 4585: const char * zFile , 
line 4586: const char * zProc , 
line 4587: char * * pzErrMsg 
line 4588: ) ; 
line 4603: SQLITE_API int sqlite3_enable_load_extension ( sqlite3 * db , int onoff ) ; 
line 4624: SQLITE_API int sqlite3_auto_extension ( void ( * xEntryPoint ) ( void ) ) ; 
line 4635: SQLITE_API void sqlite3_reset_auto_extension ( void ) ; 
line 4651: typedef struct sqlite3_vtab sqlite3_vtab ; 
line 4652: typedef struct sqlite3_index_info sqlite3_index_info ; 
line 4653: typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor ; 
line 4654: typedef struct sqlite3_module sqlite3_module ; 
line 4673: struct sqlite3_module { 
line 4674: int iVersion ; 
line 4675: int ( * xCreate ) ( sqlite3 * , void * pAux , 
line 4676: int argc , const char * const * argv , 
line 4677: sqlite3_vtab * * ppVTab , char * * ) ; 
line 4678: int ( * xConnect ) ( sqlite3 * , void * pAux , 
line 4679: int argc , const char * const * argv , 
line 4680: sqlite3_vtab * * ppVTab , char * * ) ; 
line 4681: int ( * xBestIndex ) ( sqlite3_vtab * pVTab , sqlite3_index_info * ) ; 
line 4682: int ( * xDisconnect ) ( sqlite3_vtab * pVTab ) ; 
line 4683: int ( * xDestroy ) ( sqlite3_vtab * pVTab ) ; 
line 4684: int ( * xOpen ) ( sqlite3_vtab * pVTab , sqlite3_vtab_cursor * * ppCursor ) ; 
line 4685: int ( * xClose ) ( sqlite3_vtab_cursor * ) ; 
line 4686: int ( * xFilter ) ( sqlite3_vtab_cursor * , int idxNum , const char * idxStr , 
line 4687: int argc , sqlite3_value * * argv ) ; 
line 4688: int ( * xNext ) ( sqlite3_vtab_cursor * ) ; 
line 4689: int ( * xEof ) ( sqlite3_vtab_cursor * ) ; 
line 4690: int ( * xColumn ) ( sqlite3_vtab_cursor * , sqlite3_context * , int ) ; 
line 4691: int ( * xRowid ) ( sqlite3_vtab_cursor * , sqlite3_int64 * pRowid ) ; 
line 4692: int ( * xUpdate ) ( sqlite3_vtab * , int , sqlite3_value * * , sqlite3_int64 * ) ; 
line 4693: int ( * xBegin ) ( sqlite3_vtab * pVTab ) ; 
line 4694: int ( * xSync ) ( sqlite3_vtab * pVTab ) ; 
line 4695: int ( * xCommit ) ( sqlite3_vtab * pVTab ) ; 
line 4696: int ( * xRollback ) ( sqlite3_vtab * pVTab ) ; 
line 4697: int ( * xFindFunction ) ( sqlite3_vtab * pVtab , int nArg , const char * zName , 
line 4698: void ( * * pxFunc ) ( sqlite3_context * , int , sqlite3_value * * ) , 
line 4699: void * * ppArg ) ; 
line 4700: int ( * xRename ) ( sqlite3_vtab * pVtab , const char * zNew ) ; 
line 4701: } ; 
line 4754: struct sqlite3_index_info { 
line 4756: int nConstraint ; 
line 4757: struct sqlite3_index_constraint { 
line 4758: int iColumn ; 
line 4759: unsigned char op ; 
line 4760: unsigned char usable ; 
line 4761: int iTermOffset ; 
line 4762: } * aConstraint ; 
line 4763: int nOrderBy ; 
line 4764: struct sqlite3_index_orderby { 
line 4765: int iColumn ; 
line 4766: unsigned char desc ; 
line 4767: } * aOrderBy ; 
line 4769: struct sqlite3_index_constraint_usage { 
line 4770: int argvIndex ; 
line 4771: unsigned char omit ; 
line 4772: } * aConstraintUsage ; 
line 4773: int idxNum ; 
line 4774: char * idxStr ; 
line 4775: int needToFreeIdxStr ; 
line 4776: int orderByConsumed ; 
line 4777: double estimatedCost ; 
line 4778: } ; 
line 4779: # define SQLITE_INDEX_CONSTRAINT_EQ 2 
line 4780: # define SQLITE_INDEX_CONSTRAINT_GT 4 
line 4781: # define SQLITE_INDEX_CONSTRAINT_LE 8 
line 4782: # define SQLITE_INDEX_CONSTRAINT_LT 16 
line 4783: # define SQLITE_INDEX_CONSTRAINT_GE 32 
line 4784: # define SQLITE_INDEX_CONSTRAINT_MATCH 64 
line 4810: SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_create_module ( 
line 4811: sqlite3 * db , 
line 4812: const char * zName , 
line 4813: const sqlite3_module * p , 
line 4814: void * pClientData 
line 4815: ) ; 
line 4816: SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_create_module_v2 ( 
line 4817: sqlite3 * db , 
line 4818: const char * zName , 
line 4819: const sqlite3_module * p , 
line 4820: void * pClientData , 
line 4821: void ( * xDestroy ) ( void * ) 
line 4822: ) ; 
line 4843: struct sqlite3_vtab { 
line 4844: const sqlite3_module * pModule ; 
line 4845: int nRef ; 
line 4846: char * zErrMsg ; 
line 4848: } ; 
line 4868: struct sqlite3_vtab_cursor { 
line 4869: sqlite3_vtab * pVtab ; 
line 4871: } ; 
line 4882: SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_declare_vtab ( sqlite3 * , const char * zSQL ) ; 
line 4901: SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_overload_function ( sqlite3 * , const char * zFuncName , int nArg ) ; 
line 4927: typedef struct sqlite3_blob sqlite3_blob ; 
line 4985: SQLITE_API int sqlite3_blob_open ( 
line 4986: sqlite3 * , 
line 4987: const char * zDb , 
line 4988: const char * zTable , 
line 4989: const char * zColumn , 
line 4990: sqlite3_int64 iRow , 
line 4991: int flags , 
line 4992: sqlite3_blob * * ppBlob 
line 4993: ) ; 
line 5017: SQLITE_API int sqlite3_blob_close ( sqlite3_blob * ) ; 
line 5032: SQLITE_API int sqlite3_blob_bytes ( sqlite3_blob * ) ; 
line 5060: SQLITE_API int sqlite3_blob_read ( sqlite3_blob * , void * Z , int N , int iOffset ) ; 
line 5098: SQLITE_API int sqlite3_blob_write ( sqlite3_blob * , const void * z , int n , int iOffset ) ; 
line 5129: SQLITE_API sqlite3_vfs * sqlite3_vfs_find ( const char * zVfsName ) ; 
line 5130: SQLITE_API int sqlite3_vfs_register ( sqlite3_vfs * , int makeDflt ) ; 
line 5131: SQLITE_API int sqlite3_vfs_unregister ( sqlite3_vfs * ) ; 
line 5247: SQLITE_API sqlite3_mutex * sqlite3_mutex_alloc ( int ) ; 
line 5248: SQLITE_API void sqlite3_mutex_free ( sqlite3_mutex * ) ; 
line 5249: SQLITE_API void sqlite3_mutex_enter ( sqlite3_mutex * ) ; 
line 5250: SQLITE_API int sqlite3_mutex_try ( sqlite3_mutex * ) ; 
line 5251: SQLITE_API void sqlite3_mutex_leave ( sqlite3_mutex * ) ; 
line 5319: typedef struct sqlite3_mutex_methods sqlite3_mutex_methods ; 
line 5320: struct sqlite3_mutex_methods { 
line 5321: int ( * xMutexInit ) ( void ) ; 
line 5322: int ( * xMutexEnd ) ( void ) ; 
line 5323: sqlite3_mutex * ( * xMutexAlloc ) ( int ) ; 
line 5324: void ( * xMutexFree ) ( sqlite3_mutex * ) ; 
line 5325: void ( * xMutexEnter ) ( sqlite3_mutex * ) ; 
line 5326: int ( * xMutexTry ) ( sqlite3_mutex * ) ; 
line 5327: void ( * xMutexLeave ) ( sqlite3_mutex * ) ; 
line 5328: int ( * xMutexHeld ) ( sqlite3_mutex * ) ; 
line 5329: int ( * xMutexNotheld ) ( sqlite3_mutex * ) ; 
line 5330: } ; 
line 5361: # ifndef NDEBUG 
line 5362: SQLITE_API int sqlite3_mutex_held ( sqlite3_mutex * ) ; 
line 5363: SQLITE_API int sqlite3_mutex_notheld ( sqlite3_mutex * ) ; 
line 5364: # endif 
line 5376: # define SQLITE_MUTEX_FAST 0 
line 5377: # define SQLITE_MUTEX_RECURSIVE 1 
line 5378: # define SQLITE_MUTEX_STATIC_MASTER 2 
line 5379: # define SQLITE_MUTEX_STATIC_MEM 3 
line 5380: # define SQLITE_MUTEX_STATIC_MEM2 4 
line 5381: # define SQLITE_MUTEX_STATIC_OPEN 4 
line 5382: # define SQLITE_MUTEX_STATIC_PRNG 5 
line 5383: # define SQLITE_MUTEX_STATIC_LRU 6 
line 5384: # define SQLITE_MUTEX_STATIC_LRU2 7 
line 5395: SQLITE_API sqlite3_mutex * sqlite3_db_mutex ( sqlite3 * ) ; 
line 5423: SQLITE_API int sqlite3_file_control ( sqlite3 * , const char * zDbName , int op , void * ) ; 
line 5442: SQLITE_API int sqlite3_test_control ( int op , ... ) ; 
line 5455: # define SQLITE_TESTCTRL_FIRST 5 
line 5456: # define SQLITE_TESTCTRL_PRNG_SAVE 5 
line 5457: # define SQLITE_TESTCTRL_PRNG_RESTORE 6 
line 5458: # define SQLITE_TESTCTRL_PRNG_RESET 7 
line 5459: # define SQLITE_TESTCTRL_BITVEC_TEST 8 
line 5460: # define SQLITE_TESTCTRL_FAULT_INSTALL 9 
line 5461: # define SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS 10 
line 5462: # define SQLITE_TESTCTRL_PENDING_BYTE 11 
line 5463: # define SQLITE_TESTCTRL_ASSERT 12 
line 5464: # define SQLITE_TESTCTRL_ALWAYS 13 
line 5465: # define SQLITE_TESTCTRL_RESERVE 14 
line 5466: # define SQLITE_TESTCTRL_OPTIMIZATIONS 15 
line 5467: # define SQLITE_TESTCTRL_ISKEYWORD 16 
line 5468: # define SQLITE_TESTCTRL_LAST 16 
line 5500: SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_status ( int op , int * pCurrent , int * pHighwater , int resetFlag ) ; 
line 5580: # define SQLITE_STATUS_MEMORY_USED 0 
line 5581: # define SQLITE_STATUS_PAGECACHE_USED 1 
line 5582: # define SQLITE_STATUS_PAGECACHE_OVERFLOW 2 
line 5583: # define SQLITE_STATUS_SCRATCH_USED 3 
line 5584: # define SQLITE_STATUS_SCRATCH_OVERFLOW 4 
line 5585: # define SQLITE_STATUS_MALLOC_SIZE 5 
line 5586: # define SQLITE_STATUS_PARSER_STACK 6 
line 5587: # define SQLITE_STATUS_PAGECACHE_SIZE 7 
line 5588: # define SQLITE_STATUS_SCRATCH_SIZE 8 
line 5608: SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_db_status ( sqlite3 * , int op , int * pCur , int * pHiwtr , int resetFlg ) ; 
line 5629: # define SQLITE_DBSTATUS_LOOKASIDE_USED 0 
line 5656: SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_stmt_status ( sqlite3_stmt * , int op , int resetFlg ) ; 
line 5680: # define SQLITE_STMTSTATUS_FULLSCAN_STEP 1 
line 5681: # define SQLITE_STMTSTATUS_SORT 2 
line 5695: typedef struct sqlite3_pcache sqlite3_pcache ; 
line 5825: typedef struct sqlite3_pcache_methods sqlite3_pcache_methods ; 
line 5826: struct sqlite3_pcache_methods { 
line 5827: void * pArg ; 
line 5828: int ( * xInit ) ( void * ) ; 
line 5829: void ( * xShutdown ) ( void * ) ; 
line 5830: sqlite3_pcache * ( * xCreate ) ( int szPage , int bPurgeable ) ; 
line 5831: void ( * xCachesize ) ( sqlite3_pcache * , int nCachesize ) ; 
line 5832: int ( * xPagecount ) ( sqlite3_pcache * ) ; 
line 5833: void * ( * xFetch ) ( sqlite3_pcache * , unsigned key , int createFlag ) ; 
line 5834: void ( * xUnpin ) ( sqlite3_pcache * , void * , int discard ) ; 
line 5835: void ( * xRekey ) ( sqlite3_pcache * , void * , unsigned oldKey , unsigned newKey ) ; 
line 5836: void ( * xTruncate ) ( sqlite3_pcache * , unsigned iLimit ) ; 
line 5837: void ( * xDestroy ) ( sqlite3_pcache * ) ; 
line 5838: } ; 
line 5851: typedef struct sqlite3_backup sqlite3_backup ; 
line 6030: SQLITE_API sqlite3_backup * sqlite3_backup_init ( 
line 6031: sqlite3 * pDest , 
line 6032: const char * zDestName , 
line 6033: sqlite3 * pSource , 
line 6034: const char * zSourceName 
line 6035: ) ; 
line 6036: SQLITE_API int sqlite3_backup_step ( sqlite3_backup * p , int nPage ) ; 
line 6037: SQLITE_API int sqlite3_backup_finish ( sqlite3_backup * p ) ; 
line 6038: SQLITE_API int sqlite3_backup_remaining ( sqlite3_backup * p ) ; 
line 6039: SQLITE_API int sqlite3_backup_pagecount ( sqlite3_backup * p ) ; 
line 6156: SQLITE_API int sqlite3_unlock_notify ( 
line 6157: sqlite3 * pBlocked , 
line 6158: void ( * xNotify ) ( void * * apArg , int nArg ) , 
line 6159: void * pNotifyArg 
line 6160: ) ; 
line 6172: SQLITE_API int sqlite3_strnicmp ( const char * , const char * , int ) ; 
line 6178: # ifdef SQLITE_OMIT_FLOATING_POINT 
line 6179: # undef double 
line 6180: # endif 
line 6182: # if 0 
line 6183: } 
line 6184: # endif 
line 6185: # endif 
line 6206: # ifndef _SQLITE_HASH_H_ 
line 6207: # define _SQLITE_HASH_H_ 
line 6210: typedef struct Hash Hash ; 
line 6211: typedef struct HashElem HashElem ; 
line 6234: struct Hash { 
line 6235: unsigned int htsize ; 
line 6236: unsigned int count ; 
line 6237: HashElem * first ; 
line 6238: struct _ht { 
line 6239: int count ; 
line 6240: HashElem * chain ; 
line 6241: } * ht ; 
line 6242: } ; 
line 6250: struct HashElem { 
line 6251: HashElem * next , * prev ; 
line 6252: void * data ; 
line 6253: const char * pKey ; int nKey ; 
line 6254: } ; 
line 6259: SQLITE_PRIVATE void sqlite3HashInit ( Hash * ) ; 
line 6260: SQLITE_PRIVATE void * sqlite3HashInsert ( Hash * , const char * pKey , int nKey , void * pData ) ; 
line 6261: SQLITE_PRIVATE void * sqlite3HashFind ( const Hash * , const char * pKey , int nKey ) ; 
line 6262: SQLITE_PRIVATE void sqlite3HashClear ( Hash * ) ; 
line 6276: # define sqliteHashFirst ( H ) ( ( H ) -> first ) 
line 6277: # define sqliteHashNext ( E ) ( ( E ) -> next ) 
line 6278: # define sqliteHashData ( E ) ( ( E ) -> data ) 
line 6287: # endif 
line 6293: # define TK_SEMI 1 
line 6294: # define TK_EXPLAIN 2 
line 6295: # define TK_QUERY 3 
line 6296: # define TK_PLAN 4 
line 6297: # define TK_BEGIN 5 
line 6298: # define TK_TRANSACTION 6 
line 6299: # define TK_DEFERRED 7 
line 6300: # define TK_IMMEDIATE 8 
line 6301: # define TK_EXCLUSIVE 9 
line 6302: # define TK_COMMIT 10 
line 6303: # define TK_END 11 
line 6304: # define TK_ROLLBACK 12 
line 6305: # define TK_SAVEPOINT 13 
line 6306: # define TK_RELEASE 14 
line 6307: # define TK_TO 15 
line 6308: # define TK_TABLE 16 
line 6309: # define TK_CREATE 17 
line 6310: # define TK_IF 18 
line 6311: # define TK_NOT 19 
line 6312: # define TK_EXISTS 20 
line 6313: # define TK_TEMP 21 
line 6314: # define TK_LP 22 
line 6315: # define TK_RP 23 
line 6316: # define TK_AS 24 
line 6317: # define TK_COMMA 25 
line 6318: # define TK_ID 26 
line 6319: # define TK_INDEXED 27 
line 6320: # define TK_ABORT 28 
line 6321: # define TK_ACTION 29 
line 6322: # define TK_AFTER 30 
line 6323: # define TK_ANALYZE 31 
line 6324: # define TK_ASC 32 
line 6325: # define TK_ATTACH 33 
line 6326: # define TK_BEFORE 34 
line 6327: # define TK_BY 35 
line 6328: # define TK_CASCADE 36 
line 6329: # define TK_CAST 37 
line 6330: # define TK_COLUMNKW 38 
line 6331: # define TK_CONFLICT 39 
line 6332: # define TK_DATABASE 40 
line 6333: # define TK_DESC 41 
line 6334: # define TK_DETACH 42 
line 6335: # define TK_EACH 43 
line 6336: # define TK_FAIL 44 
line 6337: # define TK_FOR 45 
line 6338: # define TK_IGNORE 46 
line 6339: # define TK_INITIALLY 47 
line 6340: # define TK_INSTEAD 48 
line 6341: # define TK_LIKE_KW 49 
line 6342: # define TK_MATCH 50 
line 6343: # define TK_NO 51 
line 6344: # define TK_KEY 52 
line 6345: # define TK_OF 53 
line 6346: # define TK_OFFSET 54 
line 6347: # define TK_PRAGMA 55 
line 6348: # define TK_RAISE 56 
line 6349: # define TK_REPLACE 57 
line 6350: # define TK_RESTRICT 58 
line 6351: # define TK_ROW 59 
line 6352: # define TK_TRIGGER 60 
line 6353: # define TK_VACUUM 61 
line 6354: # define TK_VIEW 62 
line 6355: # define TK_VIRTUAL 63 
line 6356: # define TK_REINDEX 64 
line 6357: # define TK_RENAME 65 
line 6358: # define TK_CTIME_KW 66 
line 6359: # define TK_ANY 67 
line 6360: # define TK_OR 68 
line 6361: # define TK_AND 69 
line 6362: # define TK_IS 70 
line 6363: # define TK_BETWEEN 71 
line 6364: # define TK_IN 72 
line 6365: # define TK_ISNULL 73 
line 6366: # define TK_NOTNULL 74 
line 6367: # define TK_NE 75 
line 6368: # define TK_EQ 76 
line 6369: # define TK_GT 77 
line 6370: # define TK_LE 78 
line 6371: # define TK_LT 79 
line 6372: # define TK_GE 80 
line 6373: # define TK_ESCAPE 81 
line 6374: # define TK_BITAND 82 
line 6375: # define TK_BITOR 83 
line 6376: # define TK_LSHIFT 84 
line 6377: # define TK_RSHIFT 85 
line 6378: # define TK_PLUS 86 
line 6379: # define TK_MINUS 87 
line 6380: # define TK_STAR 88 
line 6381: # define TK_SLASH 89 
line 6382: # define TK_REM 90 
line 6383: # define TK_CONCAT 91 
line 6384: # define TK_COLLATE 92 
line 6385: # define TK_BITNOT 93 
line 6386: # define TK_STRING 94 
line 6387: # define TK_JOIN_KW 95 
line 6388: # define TK_CONSTRAINT 96 
line 6389: # define TK_DEFAULT 97 
line 6390: # define TK_NULL 98 
line 6391: # define TK_PRIMARY 99 
line 6392: # define TK_UNIQUE 100 
line 6393: # define TK_CHECK 101 
line 6394: # define TK_REFERENCES 102 
line 6395: # define TK_AUTOINCR 103 
line 6396: # define TK_ON 104 
line 6397: # define TK_INSERT 105 
line 6398: # define TK_DELETE 106 
line 6399: # define TK_UPDATE 107 
line 6400: # define TK_SET 108 
line 6401: # define TK_DEFERRABLE 109 
line 6402: # define TK_FOREIGN 110 
line 6403: # define TK_DROP 111 
line 6404: # define TK_UNION 112 
line 6405: # define TK_ALL 113 
line 6406: # define TK_EXCEPT 114 
line 6407: # define TK_INTERSECT 115 
line 6408: # define TK_SELECT 116 
line 6409: # define TK_DISTINCT 117 
line 6410: # define TK_DOT 118 
line 6411: # define TK_FROM 119 
line 6412: # define TK_JOIN 120 
line 6413: # define TK_USING 121 
line 6414: # define TK_ORDER 122 
line 6415: # define TK_GROUP 123 
line 6416: # define TK_HAVING 124 
line 6417: # define TK_LIMIT 125 
line 6418: # define TK_WHERE 126 
line 6419: # define TK_INTO 127 
line 6420: # define TK_VALUES 128 
line 6421: # define TK_INTEGER 129 
line 6422: # define TK_FLOAT 130 
line 6423: # define TK_BLOB 131 
line 6424: # define TK_REGISTER 132 
line 6425: # define TK_VARIABLE 133 
line 6426: # define TK_CASE 134 
line 6427: # define TK_WHEN 135 
line 6428: # define TK_THEN 136 
line 6429: # define TK_ELSE 137 
line 6430: # define TK_INDEX 138 
line 6431: # define TK_ALTER 139 
line 6432: # define TK_ADD 140 
line 6433: # define TK_TO_TEXT 141 
line 6434: # define TK_TO_BLOB 142 
line 6435: # define TK_TO_NUMERIC 143 
line 6436: # define TK_TO_INT 144 
line 6437: # define TK_TO_REAL 145 
line 6438: # define TK_ISNOT 146 
line 6439: # define TK_END_OF_FILE 147 
line 6440: # define TK_ILLEGAL 148 
line 6441: # define TK_SPACE 149 
line 6442: # define TK_UNCLOSED_STRING 150 
line 6443: # define TK_FUNCTION 151 
line 6444: # define TK_COLUMN 152 
line 6445: # define TK_AGG_FUNCTION 153 
line 6446: # define TK_AGG_COLUMN 154 
line 6447: # define TK_CONST_FUNC 155 
line 6448: # define TK_UMINUS 156 
line 6449: # define TK_UPLUS 157 
line 6453: # include < stdio . h > 
line 6454: # include < stdlib . h > 
line 6455: # include < string . h > 
line 6456: # include < assert . h > 
line 6457: # include < stddef . h > 
line 6463: # ifdef SQLITE_OMIT_FLOATING_POINT 
line 6464: # define double sqlite_int64 
line 6465: # define LONGDOUBLE_TYPE sqlite_int64 
line 6466: # ifndef SQLITE_BIG_DBL 
line 6467: # define SQLITE_BIG_DBL ( ( ( sqlite3_int64 ) 1 ) << 50 ) 
line 6468: # endif 
line 6469: # define SQLITE_OMIT_DATETIME_FUNCS 1 
line 6470: # define SQLITE_OMIT_TRACE 1 
line 6471: # undef SQLITE_MIXED_ENDIAN_64BIT_FLOAT 
line 6472: # undef SQLITE_HAVE_ISNAN 
line 6473: # endif 
line 6474: # ifndef SQLITE_BIG_DBL 
line 6475: # define SQLITE_BIG_DBL ( 1e 99 ) 
line 6476: # endif 
line 6483: # ifdef SQLITE_OMIT_TEMPDB 
line 6484: # define OMIT_TEMPDB 1 
line 6485: # else 
line 6486: # define OMIT_TEMPDB 0 
line 6487: # endif 
line 6501: # define NULL_DISTINCT_FOR_UNIQUE 1 
line 6509: # define SQLITE_MAX_FILE_FORMAT 4 
line 6510: # ifndef SQLITE_DEFAULT_FILE_FORMAT 
line 6511: # define SQLITE_DEFAULT_FILE_FORMAT 1 
line 6512: # endif 
line 6514: # ifndef SQLITE_DEFAULT_RECURSIVE_TRIGGERS 
line 6515: # define SQLITE_DEFAULT_RECURSIVE_TRIGGERS 0 
line 6516: # endif 
line 6522: # ifndef SQLITE_TEMP_STORE 
line 6523: # define SQLITE_TEMP_STORE 1 
line 6524: # endif 
line 6530: # ifndef offsetof 
line 6531: # define offsetof ( STRUCTURE , FIELD ) ( ( int ) ( ( char * ) & ( ( STRUCTURE * ) 0 ) -> FIELD ) ) 
line 6532: # endif 
line 6538: # if 'A' == '\301' 
line 6539: # define SQLITE_EBCDIC 1 
line 6540: # else 
line 6541: # define SQLITE_ASCII 1 
line 6542: # endif 
line 6551: # ifndef UINT32_TYPE 
line 6552: # ifdef HAVE_UINT32_T 
line 6553: # define UINT32_TYPE uint32_t 
line 6554: # else 
line 6555: # define UINT32_TYPE unsigned int 
line 6556: # endif 
line 6557: # endif 
line 6558: # ifndef UINT16_TYPE 
line 6559: # ifdef HAVE_UINT16_T 
line 6560: # define UINT16_TYPE uint16_t 
line 6561: # else 
line 6562: # define UINT16_TYPE unsigned short int 
line 6563: # endif 
line 6564: # endif 
line 6565: # ifndef INT16_TYPE 
line 6566: # ifdef HAVE_INT16_T 
line 6567: # define INT16_TYPE int16_t 
line 6568: # else 
line 6569: # define INT16_TYPE short int 
line 6570: # endif 
line 6571: # endif 
line 6572: # ifndef UINT8_TYPE 
line 6573: # ifdef HAVE_UINT8_T 
line 6574: # define UINT8_TYPE uint8_t 
line 6575: # else 
line 6576: # define UINT8_TYPE unsigned char 
line 6577: # endif 
line 6578: # endif 
line 6579: # ifndef INT8_TYPE 
line 6580: # ifdef HAVE_INT8_T 
line 6581: # define INT8_TYPE int8_t 
line 6582: # else 
line 6583: # define INT8_TYPE signed char 
line 6584: # endif 
line 6585: # endif 
line 6586: # ifndef LONGDOUBLE_TYPE 
line 6587: # define LONGDOUBLE_TYPE long double 
line 6588: # endif 
line 6589: typedef sqlite_int64 i64 ; 
line 6590: typedef sqlite_uint64 u64 ; 
line 6591: typedef UINT32_TYPE u32 ; 
line 6592: typedef UINT16_TYPE u16 ; 
line 6593: typedef INT16_TYPE i16 ; 
line 6594: typedef UINT8_TYPE u8 ; 
line 6595: typedef INT8_TYPE i8 ; 
line 6603: # define SQLITE_MAX_U32 ( ( ( ( u64 ) 1 ) << 32 ) - 1 ) 
line 6609: # ifdef SQLITE_AMALGAMATION 
line 6610: SQLITE_PRIVATE const int sqlite3one = 1 ; 
line 6611: # else 
line 6612: SQLITE_PRIVATE const int sqlite3one ; 
line 6613: # endif 
line 6614: # if defined ( i386 ) || defined ( __i386__ ) || defined ( _M_IX86 
line 6615: ) || defined ( __x86_64 ) || defined ( __x86_64__ ) 
line 6616: # define SQLITE_BIGENDIAN 0 
line 6617: # define SQLITE_LITTLEENDIAN 1 
line 6618: # define SQLITE_UTF16NATIVE SQLITE_UTF16LE 
line 6619: # else 
line 6620: # define SQLITE_BIGENDIAN ( * ( char * ) ( & sqlite3one ) == 0 ) 
line 6621: # define SQLITE_LITTLEENDIAN ( * ( char * ) ( & sqlite3one ) == 1 ) 
line 6622: # define SQLITE_UTF16NATIVE ( SQLITE_BIGENDIAN ? SQLITE_UTF16BE : SQLITE_UTF16LE ) 
line 6623: # endif 
line 6630: # define LARGEST_INT64 ( 0xffffffff | ( ( ( i64 ) 0x7fffffff ) << 32 ) ) 
line 6631: # define SMALLEST_INT64 ( ( ( i64 ) - 1 ) - LARGEST_INT64 ) 
line 6637: # define ROUND8 ( x ) ( ( ( x ) + 7 ) & ~ 7 ) 
line 6642: # define ROUNDDOWN8 ( x ) ( ( x ) & ~ 7 ) 
line 6653: # ifdef SQLITE_4_BYTE_ALIGNED_MALLOC 
line 6654: # define EIGHT_BYTE_ALIGNMENT ( X ) ( ( ( ( char * ) ( X ) - ( char * ) 0 ) & 3 ) == 0 ) 
line 6655: # else 
line 6656: # define EIGHT_BYTE_ALIGNMENT ( X ) ( ( ( ( char * ) ( X ) - ( char * ) 0 ) & 7 ) == 0 ) 
line 6657: # endif 
line 6669: typedef struct BusyHandler BusyHandler ; 
line 6670: struct BusyHandler { 
line 6671: int ( * xFunc ) ( void * , int ) ; 
line 6672: void * pArg ; 
line 6673: int nBusy ; 
line 6674: } ; 
line 6681: # define MASTER_NAME "sqlite_master" 
line 6682: # define TEMP_MASTER_NAME "sqlite_temp_master" 
line 6687: # define MASTER_ROOT 1 
line 6692: # define SCHEMA_TABLE ( x ) ( ( ! OMIT_TEMPDB ) && ( x == 1 ) ? TEMP_MASTER_NAME : MASTER_NAME ) 
line 6698: # define ArraySize ( X ) ( ( int ) ( sizeof ( X ) / sizeof ( X [ 0 ] ) ) ) 
line 6704: # define SQLITE_DYNAMIC ( ( sqlite3_destructor_type ) sqlite3DbFree ) 
line 6720: # ifdef SQLITE_OMIT_WSD 
line 6721: # define SQLITE_WSD const 
line 6722: # define GLOBAL ( t , v ) ( * ( t * ) sqlite3_wsd_find ( ( void * ) & ( v ) , sizeof ( v ) ) ) 
line 6723: # define sqlite3GlobalConfig GLOBAL ( struct Sqlite3Config , sqlite3Config ) 
line 6724: SQLITE_API int sqlite3_wsd_init ( int N , int J ) ; 
line 6725: SQLITE_API void * sqlite3_wsd_find ( void * K , int L ) ; 
line 6726: # else 
line 6727: # define SQLITE_WSD 
line 6728: # define GLOBAL ( t , v ) v 
line 6729: # define sqlite3GlobalConfig sqlite3Config 
line 6730: # endif 
line 6748: # define UNUSED_PARAMETER ( x ) ( void ) ( x ) 
line 6749: # define UNUSED_PARAMETER2 ( x , y ) UNUSED_PARAMETER ( x ) , UNUSED_PARAMETER ( y ) 
line 6754: typedef struct AggInfo AggInfo ; 
line 6755: typedef struct AuthContext AuthContext ; 
line 6756: typedef struct AutoincInfo AutoincInfo ; 
line 6757: typedef struct Bitvec Bitvec ; 
line 6758: typedef struct RowSet RowSet ; 
line 6759: typedef struct CollSeq CollSeq ; 
line 6760: typedef struct Column Column ; 
line 6761: typedef struct Db Db ; 
line 6762: typedef struct Schema Schema ; 
line 6763: typedef struct Expr Expr ; 
line 6764: typedef struct ExprList ExprList ; 
line 6765: typedef struct ExprSpan ExprSpan ; 
line 6766: typedef struct FKey FKey ; 
line 6767: typedef struct FuncDef FuncDef ; 
line 6768: typedef struct FuncDefHash FuncDefHash ; 
line 6769: typedef struct IdList IdList ; 
line 6770: typedef struct Index Index ; 
line 6771: typedef struct IndexSample IndexSample ; 
line 6772: typedef struct KeyClass KeyClass ; 
line 6773: typedef struct KeyInfo KeyInfo ; 
line 6774: typedef struct Lookaside Lookaside ; 
line 6775: typedef struct LookasideSlot LookasideSlot ; 
line 6776: typedef struct Module Module ; 
line 6777: typedef struct NameContext NameContext ; 
line 6778: typedef struct Parse Parse ; 
line 6779: typedef struct Savepoint Savepoint ; 
line 6780: typedef struct Select Select ; 
line 6781: typedef struct SrcList SrcList ; 
line 6782: typedef struct StrAccum StrAccum ; 
line 6783: typedef struct Table Table ; 
line 6784: typedef struct TableLock TableLock ; 
line 6785: typedef struct Token Token ; 
line 6786: typedef struct TriggerPrg TriggerPrg ; 
line 6787: typedef struct TriggerStep TriggerStep ; 
line 6788: typedef struct Trigger Trigger ; 
line 6789: typedef struct UnpackedRecord UnpackedRecord ; 
line 6790: typedef struct VTable VTable ; 
line 6791: typedef struct Walker Walker ; 
line 6792: typedef struct WherePlan WherePlan ; 
line 6793: typedef struct WhereInfo WhereInfo ; 
line 6794: typedef struct WhereLevel WhereLevel ; 
line 6818: # ifndef _BTREE_H_ 
line 6819: # define _BTREE_H_ 
line 6824: # define SQLITE_N_BTREE_META 10 
line 6830: # ifndef SQLITE_DEFAULT_AUTOVACUUM 
line 6831: # define SQLITE_DEFAULT_AUTOVACUUM 0 
line 6832: # endif 
line 6834: # define BTREE_AUTOVACUUM_NONE 0 
line 6835: # define BTREE_AUTOVACUUM_FULL 1 
line 6836: # define BTREE_AUTOVACUUM_INCR 2 
line 6841: typedef struct Btree Btree ; 
line 6842: typedef struct BtCursor BtCursor ; 
line 6843: typedef struct BtShared BtShared ; 
line 6844: typedef struct BtreeMutexArray BtreeMutexArray ; 
line 6852: struct BtreeMutexArray { 
line 6853: int nMutex ; 
line 6854: Btree * aBtree [ SQLITE_MAX_ATTACHED + 1 ] ; 
line 6855: } ; 
line 6858: SQLITE_PRIVATE int sqlite3BtreeOpen ( 
line 6859: const char * zFilename , 
line 6860: sqlite3 * db , 
line 6861: Btree * * ppBtree , 
line 6862: int flags , 
line 6863: int vfsFlags 
line 6864: ) ; 
line 6872: # define BTREE_OMIT_JOURNAL 1 
line 6873: # define BTREE_NO_READLOCK 2 
line 6874: # define BTREE_MEMORY 4 
line 6875: # define BTREE_READONLY 8 
line 6876: # define BTREE_READWRITE 16 
line 6877: # define BTREE_CREATE 32 
line 6879: SQLITE_PRIVATE int sqlite3BtreeClose ( Btree * ) ; 
line 6880: SQLITE_PRIVATE int sqlite3BtreeSetCacheSize ( Btree * , int ) ; 
line 6881: SQLITE_PRIVATE int sqlite3BtreeSetSafetyLevel ( Btree * , int , int ) ; 
line 6882: SQLITE_PRIVATE int sqlite3BtreeSyncDisabled ( Btree * ) ; 
line 6883: SQLITE_PRIVATE int sqlite3BtreeSetPageSize ( Btree * p , int nPagesize , int nReserve , int eFix ) ; 
line 6884: SQLITE_PRIVATE int sqlite3BtreeGetPageSize ( Btree * ) ; 
line 6885: SQLITE_PRIVATE int sqlite3BtreeMaxPageCount ( Btree * , int ) ; 
line 6886: SQLITE_PRIVATE int sqlite3BtreeGetReserve ( Btree * ) ; 
line 6887: SQLITE_PRIVATE int sqlite3BtreeSetAutoVacuum ( Btree * , int ) ; 
line 6888: SQLITE_PRIVATE int sqlite3BtreeGetAutoVacuum ( Btree * ) ; 
line 6889: SQLITE_PRIVATE int sqlite3BtreeBeginTrans ( Btree * , int ) ; 
line 6890: SQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne ( Btree * , const char * zMaster ) ; 
line 6891: SQLITE_PRIVATE int sqlite3BtreeCommitPhaseTwo ( Btree * ) ; 
line 6892: SQLITE_PRIVATE int sqlite3BtreeCommit ( Btree * ) ; 
line 6893: SQLITE_PRIVATE int sqlite3BtreeRollback ( Btree * ) ; 
line 6894: SQLITE_PRIVATE int sqlite3BtreeBeginStmt ( Btree * , int ) ; 
line 6895: SQLITE_PRIVATE int sqlite3BtreeCreateTable ( Btree * , int * , int flags ) ; 
line 6896: SQLITE_PRIVATE int sqlite3BtreeIsInTrans ( Btree * ) ; 
line 6897: SQLITE_PRIVATE int sqlite3BtreeIsInReadTrans ( Btree * ) ; 
line 6898: SQLITE_PRIVATE int sqlite3BtreeIsInBackup ( Btree * ) ; 
line 6899: SQLITE_PRIVATE void * sqlite3BtreeSchema ( Btree * , int , void ( * ) ( void * ) ) ; 
line 6900: SQLITE_PRIVATE int sqlite3BtreeSchemaLocked ( Btree * pBtree ) ; 
line 6901: SQLITE_PRIVATE int sqlite3BtreeLockTable ( Btree * pBtree , int iTab , u8 isWriteLock ) ; 
line 6902: SQLITE_PRIVATE int sqlite3BtreeSavepoint ( Btree * , int , int ) ; 
line 6904: SQLITE_PRIVATE const char * sqlite3BtreeGetFilename ( Btree * ) ; 
line 6905: SQLITE_PRIVATE const char * sqlite3BtreeGetJournalname ( Btree * ) ; 
line 6906: SQLITE_PRIVATE int sqlite3BtreeCopyFile ( Btree * , Btree * ) ; 
line 6908: SQLITE_PRIVATE int sqlite3BtreeIncrVacuum ( Btree * ) ; 
line 6913: # define BTREE_INTKEY 1 
line 6914: # define BTREE_ZERODATA 2 
line 6915: # define BTREE_LEAFDATA 4 
line 6917: SQLITE_PRIVATE int sqlite3BtreeDropTable ( Btree * , int , int * ) ; 
line 6918: SQLITE_PRIVATE int sqlite3BtreeClearTable ( Btree * , int , int * ) ; 
line 6919: SQLITE_PRIVATE void sqlite3BtreeTripAllCursors ( Btree * , int ) ; 
line 6921: SQLITE_PRIVATE void sqlite3BtreeGetMeta ( Btree * pBtree , int idx , u32 * pValue ) ; 
line 6922: SQLITE_PRIVATE int sqlite3BtreeUpdateMeta ( Btree * , int idx , u32 value ) ; 
line 6936: # define BTREE_FREE_PAGE_COUNT 0 
line 6937: # define BTREE_SCHEMA_VERSION 1 
line 6938: # define BTREE_FILE_FORMAT 2 
line 6939: # define BTREE_DEFAULT_CACHE_SIZE 3 
line 6940: # define BTREE_LARGEST_ROOT_PAGE 4 
line 6941: # define BTREE_TEXT_ENCODING 5 
line 6942: # define BTREE_USER_VERSION 6 
line 6943: # define BTREE_INCR_VACUUM 7 
line 6945: SQLITE_PRIVATE int sqlite3BtreeCursor ( 
line 6946: Btree * , 
line 6947: int iTable , 
line 6948: int wrFlag , 
line 6949: struct KeyInfo * , 
line 6950: BtCursor * pCursor 
line 6951: ) ; 
line 6952: SQLITE_PRIVATE int sqlite3BtreeCursorSize ( void ) ; 
line 6953: SQLITE_PRIVATE void sqlite3BtreeCursorZero ( BtCursor * ) ; 
line 6955: SQLITE_PRIVATE int sqlite3BtreeCloseCursor ( BtCursor * ) ; 
line 6956: SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked ( 
line 6957: BtCursor * , 
line 6958: UnpackedRecord * pUnKey , 
line 6959: i64 intKey , 
line 6960: int bias , 
line 6961: int * pRes 
line 6962: ) ; 
line 6963: SQLITE_PRIVATE int sqlite3BtreeCursorHasMoved ( BtCursor * , int * ) ; 
line 6964: SQLITE_PRIVATE int sqlite3BtreeDelete ( BtCursor * ) ; 
line 6965: SQLITE_PRIVATE int sqlite3BtreeInsert ( BtCursor * , const void * pKey , i64 nKey , 
line 6966: const void * pData , int nData , 
line 6967: int nZero , int bias , int seekResult ) ; 
line 6968: SQLITE_PRIVATE int sqlite3BtreeFirst ( BtCursor * , int * pRes ) ; 
line 6969: SQLITE_PRIVATE int sqlite3BtreeLast ( BtCursor * , int * pRes ) ; 
line 6970: SQLITE_PRIVATE int sqlite3BtreeNext ( BtCursor * , int * pRes ) ; 
line 6971: SQLITE_PRIVATE int sqlite3BtreeEof ( BtCursor * ) ; 
line 6972: SQLITE_PRIVATE int sqlite3BtreePrevious ( BtCursor * , int * pRes ) ; 
line 6973: SQLITE_PRIVATE int sqlite3BtreeKeySize ( BtCursor * , i64 * pSize ) ; 
line 6974: SQLITE_PRIVATE int sqlite3BtreeKey ( BtCursor * , u32 offset , u32 amt , void * ) ; 
line 6975: SQLITE_PRIVATE const void * sqlite3BtreeKeyFetch ( BtCursor * , int * pAmt ) ; 
line 6976: SQLITE_PRIVATE const void * sqlite3BtreeDataFetch ( BtCursor * , int * pAmt ) ; 
line 6977: SQLITE_PRIVATE int sqlite3BtreeDataSize ( BtCursor * , u32 * pSize ) ; 
line 6978: SQLITE_PRIVATE int sqlite3BtreeData ( BtCursor * , u32 offset , u32 amt , void * ) ; 
line 6979: SQLITE_PRIVATE void sqlite3BtreeSetCachedRowid ( BtCursor * , sqlite3_int64 ) ; 
line 6980: SQLITE_PRIVATE sqlite3_int64 sqlite3BtreeGetCachedRowid ( BtCursor * ) ; 
line 6982: SQLITE_PRIVATE char * sqlite3BtreeIntegrityCheck ( Btree * , int * aRoot , int nRoot , int , int * ) ; 
line 6983: SQLITE_PRIVATE struct Pager * sqlite3BtreePager ( Btree * ) ; 
line 6985: SQLITE_PRIVATE int sqlite3BtreePutData ( BtCursor * , u32 offset , u32 amt , void * ) ; 
line 6986: SQLITE_PRIVATE void sqlite3BtreeCacheOverflow ( BtCursor * ) ; 
line 6987: SQLITE_PRIVATE void sqlite3BtreeClearCursor ( BtCursor * ) ; 
line 6989: # ifndef NDEBUG 
line 6990: SQLITE_PRIVATE int sqlite3BtreeCursorIsValid ( BtCursor * ) ; 
line 6991: # endif 
line 6993: # ifndef SQLITE_OMIT_BTREECOUNT 
line 6994: SQLITE_PRIVATE int sqlite3BtreeCount ( BtCursor * , i64 * ) ; 
line 6995: # endif 
line 6997: # ifdef SQLITE_TEST 
line 6998: SQLITE_PRIVATE int sqlite3BtreeCursorInfo ( BtCursor * , int * , int ) ; 
line 6999: SQLITE_PRIVATE void sqlite3BtreeCursorList ( Btree * ) ; 
line 7000: # endif 
line 7007: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 7008: SQLITE_PRIVATE void sqlite3BtreeEnter ( Btree * ) ; 
line 7009: SQLITE_PRIVATE void sqlite3BtreeEnterAll ( sqlite3 * ) ; 
line 7010: # else 
line 7011: # define sqlite3BtreeEnter ( X ) 
line 7012: # define sqlite3BtreeEnterAll ( X ) 
line 7013: # endif 
line 7015: # if ! defined ( SQLITE_OMIT_SHARED_CACHE ) && SQLITE_THREADSAFE 
line 7016: SQLITE_PRIVATE void sqlite3BtreeLeave ( Btree * ) ; 
line 7017: SQLITE_PRIVATE void sqlite3BtreeEnterCursor ( BtCursor * ) ; 
line 7018: SQLITE_PRIVATE void sqlite3BtreeLeaveCursor ( BtCursor * ) ; 
line 7019: SQLITE_PRIVATE void sqlite3BtreeLeaveAll ( sqlite3 * ) ; 
line 7020: SQLITE_PRIVATE void sqlite3BtreeMutexArrayEnter ( BtreeMutexArray * ) ; 
line 7021: SQLITE_PRIVATE void sqlite3BtreeMutexArrayLeave ( BtreeMutexArray * ) ; 
line 7022: SQLITE_PRIVATE void sqlite3BtreeMutexArrayInsert ( BtreeMutexArray * , Btree * ) ; 
line 7023: # ifndef NDEBUG 
line 7025: SQLITE_PRIVATE int sqlite3BtreeHoldsMutex ( Btree * ) ; 
line 7026: SQLITE_PRIVATE int sqlite3BtreeHoldsAllMutexes ( sqlite3 * ) ; 
line 7027: # endif 
line 7028: # else 
line 7030: # define sqlite3BtreeLeave ( X ) 
line 7031: # define sqlite3BtreeEnterCursor ( X ) 
line 7032: # define sqlite3BtreeLeaveCursor ( X ) 
line 7033: # define sqlite3BtreeLeaveAll ( X ) 
line 7034: # define sqlite3BtreeMutexArrayEnter ( X ) 
line 7035: # define sqlite3BtreeMutexArrayLeave ( X ) 
line 7036: # define sqlite3BtreeMutexArrayInsert ( X , Y ) 
line 7038: # define sqlite3BtreeHoldsMutex ( X ) 1 
line 7039: # define sqlite3BtreeHoldsAllMutexes ( X ) 1 
line 7040: # endif 
line 7043: # endif 
line 7066: # ifndef _SQLITE_VDBE_H_ 
line 7067: # define _SQLITE_VDBE_H_ 
line 7074: typedef struct Vdbe Vdbe ; 
line 7080: typedef struct VdbeFunc VdbeFunc ; 
line 7081: typedef struct Mem Mem ; 
line 7082: typedef struct SubProgram SubProgram ; 
line 7089: struct VdbeOp { 
line 7090: u8 opcode ; 
line 7091: signed char p4type ; 
line 7092: u8 opflags ; 
line 7093: u8 p5 ; 
line 7094: int p1 ; 
line 7095: int p2 ; 
line 7096: int p3 ; 
line 7097: union { 
line 7098: int i ; 
line 7099: void * p ; 
line 7100: char * z ; 
line 7101: i64 * pI64 ; 
line 7102: double * pReal ; 
line 7103: FuncDef * pFunc ; 
line 7104: VdbeFunc * pVdbeFunc ; 
line 7105: CollSeq * pColl ; 
line 7106: Mem * pMem ; 
line 7107: VTable * pVtab ; 
line 7108: KeyInfo * pKeyInfo ; 
line 7109: int * ai ; 
line 7110: SubProgram * pProgram ; 
line 7111: } p4 ; 
line 7112: # ifdef SQLITE_DEBUG 
line 7113: char * zComment ; 
line 7114: # endif 
line 7115: # ifdef VDBE_PROFILE 
line 7116: int cnt ; 
line 7117: u64 cycles ; 
line 7118: # endif 
line 7119: } ; 
line 7120: typedef struct VdbeOp VdbeOp ; 
line 7126: struct SubProgram { 
line 7127: VdbeOp * aOp ; 
line 7128: int nOp ; 
line 7129: int nMem ; 
line 7130: int nCsr ; 
line 7131: int nRef ; 
line 7132: void * token ; 
line 7133: } ; 
line 7139: struct VdbeOpList { 
line 7140: u8 opcode ; 
line 7141: signed char p1 ; 
line 7142: signed char p2 ; 
line 7143: signed char p3 ; 
line 7144: } ; 
line 7145: typedef struct VdbeOpList VdbeOpList ; 
line 7150: # define P4_NOTUSED 0 
line 7151: # define P4_DYNAMIC ( - 1 ) 
line 7152: # define P4_STATIC ( - 2 ) 
line 7153: # define P4_COLLSEQ ( - 4 ) 
line 7154: # define P4_FUNCDEF ( - 5 ) 
line 7155: # define P4_KEYINFO ( - 6 ) 
line 7156: # define P4_VDBEFUNC ( - 7 ) 
line 7157: # define P4_MEM ( - 8 ) 
line 7158: # define P4_TRANSIENT ( - 9 ) 
line 7159: # define P4_VTAB ( - 10 ) 
line 7160: # define P4_MPRINTF ( - 11 ) 
line 7161: # define P4_REAL ( - 12 ) 
line 7162: # define P4_INT64 ( - 13 ) 
line 7163: # define P4_INT32 ( - 14 ) 
line 7164: # define P4_INTARRAY ( - 15 ) 
line 7165: # define P4_SUBPROGRAM ( - 18 ) 
line 7174: # define P4_KEYINFO_HANDOFF ( - 16 ) 
line 7175: # define P4_KEYINFO_STATIC ( - 17 ) 
line 7181: # define COLNAME_NAME 0 
line 7182: # define COLNAME_DECLTYPE 1 
line 7183: # define COLNAME_DATABASE 2 
line 7184: # define COLNAME_TABLE 3 
line 7185: # define COLNAME_COLUMN 4 
line 7186: # ifdef SQLITE_ENABLE_COLUMN_METADATA 
line 7187: # define COLNAME_N 5 
line 7188: # else 
line 7189: # ifdef SQLITE_OMIT_DECLTYPE 
line 7190: # define COLNAME_N 1 
line 7191: # else 
line 7192: # define COLNAME_N 2 
line 7193: # endif 
line 7194: # endif 
line 7202: # define ADDR ( X ) ( - 1 - ( X ) ) 
line 7212: # define OP_Goto 1 
line 7213: # define OP_Gosub 2 
line 7214: # define OP_Return 3 
line 7215: # define OP_Yield 4 
line 7216: # define OP_HaltIfNull 5 
line 7217: # define OP_Halt 6 
line 7218: # define OP_Integer 7 
line 7219: # define OP_Int64 8 
line 7220: # define OP_Real 130 
line 7221: # define OP_String8 94 
line 7222: # define OP_String 9 
line 7223: # define OP_Null 10 
line 7224: # define OP_Blob 11 
line 7225: # define OP_Variable 12 
line 7226: # define OP_Move 13 
line 7227: # define OP_Copy 14 
line 7228: # define OP_SCopy 15 
line 7229: # define OP_ResultRow 16 
line 7230: # define OP_Concat 91 
line 7231: # define OP_Add 86 
line 7232: # define OP_Subtract 87 
line 7233: # define OP_Multiply 88 
line 7234: # define OP_Divide 89 
line 7235: # define OP_Remainder 90 
line 7236: # define OP_CollSeq 17 
line 7237: # define OP_Function 18 
line 7238: # define OP_BitAnd 82 
line 7239: # define OP_BitOr 83 
line 7240: # define OP_ShiftLeft 84 
line 7241: # define OP_ShiftRight 85 
line 7242: # define OP_AddImm 20 
line 7243: # define OP_MustBeInt 21 
line 7244: # define OP_RealAffinity 22 
line 7245: # define OP_ToText 141 
line 7246: # define OP_ToBlob 142 
line 7247: # define OP_ToNumeric 143 
line 7248: # define OP_ToInt 144 
line 7249: # define OP_ToReal 145 
line 7250: # define OP_Eq 76 
line 7251: # define OP_Ne 75 
line 7252: # define OP_Lt 79 
line 7253: # define OP_Le 78 
line 7254: # define OP_Gt 77 
line 7255: # define OP_Ge 80 
line 7256: # define OP_Permutation 23 
line 7257: # define OP_Compare 24 
line 7258: # define OP_Jump 25 
line 7259: # define OP_And 69 
line 7260: # define OP_Or 68 
line 7261: # define OP_Not 19 
line 7262: # define OP_BitNot 93 
line 7263: # define OP_If 26 
line 7264: # define OP_IfNot 27 
line 7265: # define OP_IsNull 73 
line 7266: # define OP_NotNull 74 
line 7267: # define OP_Column 28 
line 7268: # define OP_Affinity 29 
line 7269: # define OP_MakeRecord 30 
line 7270: # define OP_Count 31 
line 7271: # define OP_Savepoint 32 
line 7272: # define OP_AutoCommit 33 
line 7273: # define OP_Transaction 34 
line 7274: # define OP_ReadCookie 35 
line 7275: # define OP_SetCookie 36 
line 7276: # define OP_VerifyCookie 37 
line 7277: # define OP_OpenRead 38 
line 7278: # define OP_OpenWrite 39 
line 7279: # define OP_OpenEphemeral 40 
line 7280: # define OP_OpenPseudo 41 
line 7281: # define OP_Close 42 
line 7282: # define OP_SeekLt 43 
line 7283: # define OP_SeekLe 44 
line 7284: # define OP_SeekGe 45 
line 7285: # define OP_SeekGt 46 
line 7286: # define OP_Seek 47 
line 7287: # define OP_NotFound 48 
line 7288: # define OP_Found 49 
line 7289: # define OP_IsUnique 50 
line 7290: # define OP_NotExists 51 
line 7291: # define OP_Sequence 52 
line 7292: # define OP_NewRowid 53 
line 7293: # define OP_Insert 54 
line 7294: # define OP_InsertInt 55 
line 7295: # define OP_Delete 56 
line 7296: # define OP_ResetCount 57 
line 7297: # define OP_RowKey 58 
line 7298: # define OP_RowData 59 
line 7299: # define OP_Rowid 60 
line 7300: # define OP_NullRow 61 
line 7301: # define OP_Last 62 
line 7302: # define OP_Sort 63 
line 7303: # define OP_Rewind 64 
line 7304: # define OP_Prev 65 
line 7305: # define OP_Next 66 
line 7306: # define OP_IdxInsert 67 
line 7307: # define OP_IdxDelete 70 
line 7308: # define OP_IdxRowid 71 
line 7309: # define OP_IdxLT 72 
line 7310: # define OP_IdxGE 81 
line 7311: # define OP_Destroy 92 
line 7312: # define OP_Clear 95 
line 7313: # define OP_CreateIndex 96 
line 7314: # define OP_CreateTable 97 
line 7315: # define OP_ParseSchema 98 
line 7316: # define OP_LoadAnalysis 99 
line 7317: # define OP_DropTable 100 
line 7318: # define OP_DropIndex 101 
line 7319: # define OP_DropTrigger 102 
line 7320: # define OP_IntegrityCk 103 
line 7321: # define OP_RowSetAdd 104 
line 7322: # define OP_RowSetRead 105 
line 7323: # define OP_RowSetTest 106 
line 7324: # define OP_Program 107 
line 7325: # define OP_Param 108 
line 7326: # define OP_FkCounter 109 
line 7327: # define OP_FkIfZero 110 
line 7328: # define OP_MemMax 111 
line 7329: # define OP_IfPos 112 
line 7330: # define OP_IfNeg 113 
line 7331: # define OP_IfZero 114 
line 7332: # define OP_AggStep 115 
line 7333: # define OP_AggFinal 116 
line 7334: # define OP_Vacuum 117 
line 7335: # define OP_IncrVacuum 118 
line 7336: # define OP_Expire 119 
line 7337: # define OP_TableLock 120 
line 7338: # define OP_VBegin 121 
line 7339: # define OP_VCreate 122 
line 7340: # define OP_VDestroy 123 
line 7341: # define OP_VOpen 124 
line 7342: # define OP_VFilter 125 
line 7343: # define OP_VColumn 126 
line 7344: # define OP_VNext 127 
line 7345: # define OP_VRename 128 
line 7346: # define OP_VUpdate 129 
line 7347: # define OP_Pagecount 131 
line 7348: # define OP_Trace 132 
line 7349: # define OP_Noop 133 
line 7350: # define OP_Explain 134 
line 7353: # define OP_NotUsed_135 135 
line 7354: # define OP_NotUsed_136 136 
line 7355: # define OP_NotUsed_137 137 
line 7356: # define OP_NotUsed_138 138 
line 7357: # define OP_NotUsed_139 139 
line 7358: # define OP_NotUsed_140 140 
line 7365: # define OPFLG_JUMP 0x0001 
line 7366: # define OPFLG_OUT2_PRERELEASE 0x0002 
line 7367: # define OPFLG_IN1 0x0004 
line 7368: # define OPFLG_IN2 0x0008 
line 7369: # define OPFLG_IN3 0x0010 
line 7370: # define OPFLG_OUT2 0x0020 
line 7371: # define OPFLG_OUT3 0x0040 
line 7372: # define OPFLG_INITIALIZER 
line 7373: { 0x00 , 0x01 , 0x05 , 0x04 , 0x04 , 0x10 , 0x00 , 0x02 
line 7374: , 0x02 , 0x02 , 0x02 , 0x02 , 0x00 , 0x00 , 0x24 , 0x24 
line 7375: , 0x00 , 0x00 , 0x00 , 0x24 , 0x04 , 0x05 , 0x04 , 0x00 
line 7376: , 0x00 , 0x01 , 0x05 , 0x05 , 0x00 , 0x00 , 0x00 , 0x02 
line 7377: , 0x00 , 0x00 , 0x00 , 0x02 , 0x10 , 0x00 , 0x00 , 0x00 
line 7378: , 0x00 , 0x00 , 0x00 , 0x11 , 0x11 , 0x11 , 0x11 , 0x08 
line 7379: , 0x11 , 0x11 , 0x11 , 0x11 , 0x02 , 0x02 , 0x00 , 0x00 
line 7380: , 0x00 , 0x00 , 0x00 , 0x00 , 0x02 , 0x00 , 0x01 , 0x01 
line 7381: , 0x01 , 0x01 , 0x01 , 0x08 , 0x4c , 0x4c , 0x00 , 0x02 
line 7382: , 0x01 , 0x05 , 0x05 , 0x15 , 0x15 , 0x15 , 0x15 , 0x15 
line 7383: , 0x15 , 0x01 , 0x4c , 0x4c , 0x4c , 0x4c , 0x4c , 0x4c 
line 7384: , 0x4c , 0x4c , 0x4c , 0x4c , 0x02 , 0x24 , 0x02 , 0x00 
line 7385: , 0x02 , 0x02 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 
line 7386: , 0x0c , 0x45 , 0x15 , 0x01 , 0x02 , 0x00 , 0x01 , 0x08 
line 7387: , 0x05 , 0x05 , 0x05 , 0x00 , 0x00 , 0x00 , 0x01 , 0x00 
line 7388: , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x01 , 0x00 , 0x01 
line 7389: , 0x00 , 0x00 , 0x02 , 0x02 , 0x00 , 0x00 , 0x00 , 0x00 
line 7390: , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x04 , 0x04 , 0x04 
line 7391: , 0x04 , 0x04 , } 
line 7400: SQLITE_PRIVATE Vdbe * sqlite3VdbeCreate ( sqlite3 * ) ; 
line 7401: SQLITE_PRIVATE int sqlite3VdbeAddOp0 ( Vdbe * , int ) ; 
line 7402: SQLITE_PRIVATE int sqlite3VdbeAddOp1 ( Vdbe * , int , int ) ; 
line 7403: SQLITE_PRIVATE int sqlite3VdbeAddOp2 ( Vdbe * , int , int , int ) ; 
line 7404: SQLITE_PRIVATE int sqlite3VdbeAddOp3 ( Vdbe * , int , int , int , int ) ; 
line 7405: SQLITE_PRIVATE int sqlite3VdbeAddOp4 ( Vdbe * , int , int , int , int , const char * zP4 , int ) ; 
line 7406: SQLITE_PRIVATE int sqlite3VdbeAddOp4Int ( Vdbe * , int , int , int , int , int ) ; 
line 7407: SQLITE_PRIVATE int sqlite3VdbeAddOpList ( Vdbe * , int nOp , VdbeOpList const * aOp ) ; 
line 7408: SQLITE_PRIVATE void sqlite3VdbeChangeP1 ( Vdbe * , int addr , int P1 ) ; 
line 7409: SQLITE_PRIVATE void sqlite3VdbeChangeP2 ( Vdbe * , int addr , int P2 ) ; 
line 7410: SQLITE_PRIVATE void sqlite3VdbeChangeP3 ( Vdbe * , int addr , int P3 ) ; 
line 7411: SQLITE_PRIVATE void sqlite3VdbeChangeP5 ( Vdbe * , u8 P5 ) ; 
line 7412: SQLITE_PRIVATE void sqlite3VdbeJumpHere ( Vdbe * , int addr ) ; 
line 7413: SQLITE_PRIVATE void sqlite3VdbeChangeToNoop ( Vdbe * , int addr , int N ) ; 
line 7414: SQLITE_PRIVATE void sqlite3VdbeChangeP4 ( Vdbe * , int addr , const char * zP4 , int N ) ; 
line 7415: SQLITE_PRIVATE void sqlite3VdbeUsesBtree ( Vdbe * , int ) ; 
line 7416: SQLITE_PRIVATE VdbeOp * sqlite3VdbeGetOp ( Vdbe * , int ) ; 
line 7417: SQLITE_PRIVATE int sqlite3VdbeMakeLabel ( Vdbe * ) ; 
line 7418: SQLITE_PRIVATE void sqlite3VdbeDelete ( Vdbe * ) ; 
line 7419: SQLITE_PRIVATE void sqlite3VdbeMakeReady ( Vdbe * , int , int , int , int , int , int ) ; 
line 7420: SQLITE_PRIVATE int sqlite3VdbeFinalize ( Vdbe * ) ; 
line 7421: SQLITE_PRIVATE void sqlite3VdbeResolveLabel ( Vdbe * , int ) ; 
line 7422: SQLITE_PRIVATE int sqlite3VdbeCurrentAddr ( Vdbe * ) ; 
line 7423: # ifdef SQLITE_DEBUG 
line 7424: SQLITE_PRIVATE int sqlite3VdbeAssertMayAbort ( Vdbe * , int ) ; 
line 7425: SQLITE_PRIVATE void sqlite3VdbeTrace ( Vdbe * , FILE * ) ; 
line 7426: # endif 
line 7427: SQLITE_PRIVATE void sqlite3VdbeResetStepResult ( Vdbe * ) ; 
line 7428: SQLITE_PRIVATE int sqlite3VdbeReset ( Vdbe * ) ; 
line 7429: SQLITE_PRIVATE void sqlite3VdbeSetNumCols ( Vdbe * , int ) ; 
line 7430: SQLITE_PRIVATE int sqlite3VdbeSetColName ( Vdbe * , int , int , const char * , void ( * ) ( void * ) ) ; 
line 7431: SQLITE_PRIVATE void sqlite3VdbeCountChanges ( Vdbe * ) ; 
line 7432: SQLITE_PRIVATE sqlite3 * sqlite3VdbeDb ( Vdbe * ) ; 
line 7433: SQLITE_PRIVATE void sqlite3VdbeSetSql ( Vdbe * , const char * z , int n , int ) ; 
line 7434: SQLITE_PRIVATE void sqlite3VdbeSwap ( Vdbe * , Vdbe * ) ; 
line 7435: SQLITE_PRIVATE VdbeOp * sqlite3VdbeTakeOpArray ( Vdbe * , int * , int * ) ; 
line 7436: SQLITE_PRIVATE void sqlite3VdbeProgramDelete ( sqlite3 * , SubProgram * , int ) ; 
line 7437: SQLITE_PRIVATE sqlite3_value * sqlite3VdbeGetValue ( Vdbe * , int , u8 ) ; 
line 7438: SQLITE_PRIVATE void sqlite3VdbeSetVarmask ( Vdbe * , int ) ; 
line 7439: # ifndef SQLITE_OMIT_TRACE 
line 7440: SQLITE_PRIVATE char * sqlite3VdbeExpandSql ( Vdbe * , const char * ) ; 
line 7441: # endif 
line 7443: SQLITE_PRIVATE UnpackedRecord * sqlite3VdbeRecordUnpack ( KeyInfo * , int , const void * , char * , int ) ; 
line 7444: SQLITE_PRIVATE void sqlite3VdbeDeleteUnpackedRecord ( UnpackedRecord * ) ; 
line 7445: SQLITE_PRIVATE int sqlite3VdbeRecordCompare ( int , const void * , UnpackedRecord * ) ; 
line 7448: # ifndef NDEBUG 
line 7449: SQLITE_PRIVATE void sqlite3VdbeComment ( Vdbe * , const char * , ... ) ; 
line 7450: # define VdbeComment ( X ) sqlite3VdbeComment X 
line 7451: SQLITE_PRIVATE void sqlite3VdbeNoopComment ( Vdbe * , const char * , ... ) ; 
line 7452: # define VdbeNoopComment ( X ) sqlite3VdbeNoopComment X 
line 7453: # else 
line 7454: # define VdbeComment ( X ) 
line 7455: # define VdbeNoopComment ( X ) 
line 7456: # endif 
line 7458: # endif 
line 7480: # ifndef _PAGER_H_ 
line 7481: # define _PAGER_H_ 
line 7488: # ifndef SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT 
line 7489: # define SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT - 1 
line 7490: # endif 
line 7496: typedef u32 Pgno ; 
line 7501: typedef struct Pager Pager ; 
line 7506: typedef struct PgHdr DbPage ; 
line 7516: # define PAGER_MJ_PGNO ( x ) ( ( Pgno ) ( ( PENDING_BYTE / ( ( x ) -> pageSize ) ) + 1 ) ) 
line 7523: # define PAGER_OMIT_JOURNAL 0x0001 
line 7524: # define PAGER_NO_READLOCK 0x0002 
line 7529: # define PAGER_LOCKINGMODE_QUERY - 1 
line 7530: # define PAGER_LOCKINGMODE_NORMAL 0 
line 7531: # define PAGER_LOCKINGMODE_EXCLUSIVE 1 
line 7536: # define PAGER_JOURNALMODE_QUERY - 1 
line 7537: # define PAGER_JOURNALMODE_DELETE 0 
line 7538: # define PAGER_JOURNALMODE_PERSIST 1 
line 7539: # define PAGER_JOURNALMODE_OFF 2 
line 7540: # define PAGER_JOURNALMODE_TRUNCATE 3 
line 7541: # define PAGER_JOURNALMODE_MEMORY 4 
line 7550: SQLITE_PRIVATE int sqlite3PagerOpen ( 
line 7551: sqlite3_vfs * , 
line 7552: Pager * * ppPager , 
line 7553: const char * , 
line 7554: int , 
line 7555: int , 
line 7556: int , 
line 7557: void ( * ) ( DbPage * ) 
line 7558: ) ; 
line 7559: SQLITE_PRIVATE int sqlite3PagerClose ( Pager * pPager ) ; 
line 7560: SQLITE_PRIVATE int sqlite3PagerReadFileheader ( Pager * , int , unsigned char * ) ; 
line 7563: SQLITE_PRIVATE void sqlite3PagerSetBusyhandler ( Pager * , int ( * ) ( void * ) , void * ) ; 
line 7564: SQLITE_PRIVATE int sqlite3PagerSetPagesize ( Pager * , u16 * , int ) ; 
line 7565: SQLITE_PRIVATE int sqlite3PagerMaxPageCount ( Pager * , int ) ; 
line 7566: SQLITE_PRIVATE void sqlite3PagerSetCachesize ( Pager * , int ) ; 
line 7567: SQLITE_PRIVATE void sqlite3PagerSetSafetyLevel ( Pager * , int , int ) ; 
line 7568: SQLITE_PRIVATE int sqlite3PagerLockingMode ( Pager * , int ) ; 
line 7569: SQLITE_PRIVATE int sqlite3PagerJournalMode ( Pager * , int ) ; 
line 7570: SQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit ( Pager * , i64 ) ; 
line 7571: SQLITE_PRIVATE sqlite3_backup * * sqlite3PagerBackupPtr ( Pager * ) ; 
line 7574: SQLITE_PRIVATE int sqlite3PagerAcquire ( Pager * pPager , Pgno pgno , DbPage * * ppPage , int clrFlag ) ; 
line 7575: # define sqlite3PagerGet ( A , B , C ) sqlite3PagerAcquire ( A , B , C , 0 ) 
line 7576: SQLITE_PRIVATE DbPage * sqlite3PagerLookup ( Pager * pPager , Pgno pgno ) ; 
line 7577: SQLITE_PRIVATE void sqlite3PagerRef ( DbPage * ) ; 
line 7578: SQLITE_PRIVATE void sqlite3PagerUnref ( DbPage * ) ; 
line 7581: SQLITE_PRIVATE int sqlite3PagerWrite ( DbPage * ) ; 
line 7582: SQLITE_PRIVATE void sqlite3PagerDontWrite ( DbPage * ) ; 
line 7583: SQLITE_PRIVATE int sqlite3PagerMovepage ( Pager * , DbPage * , Pgno , int ) ; 
line 7584: SQLITE_PRIVATE int sqlite3PagerPageRefcount ( DbPage * ) ; 
line 7585: SQLITE_PRIVATE void * sqlite3PagerGetData ( DbPage * ) ; 
line 7586: SQLITE_PRIVATE void * sqlite3PagerGetExtra ( DbPage * ) ; 
line 7589: SQLITE_PRIVATE int sqlite3PagerPagecount ( Pager * , int * ) ; 
line 7590: SQLITE_PRIVATE int sqlite3PagerBegin ( Pager * , int exFlag , int ) ; 
line 7591: SQLITE_PRIVATE int sqlite3PagerCommitPhaseOne ( Pager * , const char * zMaster , int ) ; 
line 7592: SQLITE_PRIVATE int sqlite3PagerSync ( Pager * pPager ) ; 
line 7593: SQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo ( Pager * ) ; 
line 7594: SQLITE_PRIVATE int sqlite3PagerRollback ( Pager * ) ; 
line 7595: SQLITE_PRIVATE int sqlite3PagerOpenSavepoint ( Pager * pPager , int n ) ; 
line 7596: SQLITE_PRIVATE int sqlite3PagerSavepoint ( Pager * pPager , int op , int iSavepoint ) ; 
line 7597: SQLITE_PRIVATE int sqlite3PagerSharedLock ( Pager * pPager ) ; 
line 7600: SQLITE_PRIVATE u8 sqlite3PagerIsreadonly ( Pager * ) ; 
line 7601: SQLITE_PRIVATE int sqlite3PagerRefcount ( Pager * ) ; 
line 7602: SQLITE_PRIVATE const char * sqlite3PagerFilename ( Pager * ) ; 
line 7603: SQLITE_PRIVATE const sqlite3_vfs * sqlite3PagerVfs ( Pager * ) ; 
line 7604: SQLITE_PRIVATE sqlite3_file * sqlite3PagerFile ( Pager * ) ; 
line 7605: SQLITE_PRIVATE const char * sqlite3PagerJournalname ( Pager * ) ; 
line 7606: SQLITE_PRIVATE int sqlite3PagerNosync ( Pager * ) ; 
line 7607: SQLITE_PRIVATE void * sqlite3PagerTempSpace ( Pager * ) ; 
line 7608: SQLITE_PRIVATE int sqlite3PagerIsMemdb ( Pager * ) ; 
line 7611: SQLITE_PRIVATE void sqlite3PagerTruncateImage ( Pager * , Pgno ) ; 
line 7614: # if ! defined ( NDEBUG ) || defined ( SQLITE_TEST ) 
line 7615: SQLITE_PRIVATE Pgno sqlite3PagerPagenumber ( DbPage * ) ; 
line 7616: SQLITE_PRIVATE int sqlite3PagerIswriteable ( DbPage * ) ; 
line 7617: # endif 
line 7618: # ifdef SQLITE_TEST 
line 7619: SQLITE_PRIVATE int * sqlite3PagerStats ( Pager * ) ; 
line 7620: SQLITE_PRIVATE void sqlite3PagerRefdump ( Pager * ) ; 
line 7621: void disable_simulated_io_errors ( void ) ; 
line 7622: void enable_simulated_io_errors ( void ) ; 
line 7623: # else 
line 7624: # define disable_simulated_io_errors ( ) 
line 7625: # define enable_simulated_io_errors ( ) 
line 7626: # endif 
line 7628: # endif 
line 7649: # ifndef _PCACHE_H_ 
line 7651: typedef struct PgHdr PgHdr ; 
line 7652: typedef struct PCache PCache ; 
line 7658: struct PgHdr { 
line 7659: void * pData ; 
line 7660: void * pExtra ; 
line 7661: PgHdr * pDirty ; 
line 7662: Pgno pgno ; 
line 7663: Pager * pPager ; 
line 7664: # ifdef SQLITE_CHECK_PAGES 
line 7665: u32 pageHash ; 
line 7666: # endif 
line 7667: u16 flags ; 
line 7673: i16 nRef ; 
line 7674: PCache * pCache ; 
line 7676: PgHdr * pDirtyNext ; 
line 7677: PgHdr * pDirtyPrev ; 
line 7678: } ; 
line 7681: # define PGHDR_DIRTY 0x002 
line 7682: # define PGHDR_NEED_SYNC 0x004 
line 7684: # define PGHDR_NEED_READ 0x008 
line 7685: # define PGHDR_REUSE_UNLIKELY 0x010 
line 7686: # define PGHDR_DONT_WRITE 0x020 
line 7689: SQLITE_PRIVATE int sqlite3PcacheInitialize ( void ) ; 
line 7690: SQLITE_PRIVATE void sqlite3PcacheShutdown ( void ) ; 
line 7695: SQLITE_PRIVATE void sqlite3PCacheBufferSetup ( void * , int sz , int n ) ; 
line 7701: SQLITE_PRIVATE void sqlite3PcacheOpen ( 
line 7702: int szPage , 
line 7703: int szExtra , 
line 7704: int bPurgeable , 
line 7705: int ( * xStress ) ( void * , PgHdr * ) , 
line 7706: void * pStress , 
line 7707: PCache * pToInit 
line 7708: ) ; 
line 7711: SQLITE_PRIVATE void sqlite3PcacheSetPageSize ( PCache * , int ) ; 
line 7716: SQLITE_PRIVATE int sqlite3PcacheSize ( void ) ; 
line 7721: SQLITE_PRIVATE int sqlite3PcacheFetch ( PCache * , Pgno , int createFlag , PgHdr * * ) ; 
line 7722: SQLITE_PRIVATE void sqlite3PcacheRelease ( PgHdr * ) ; 
line 7724: SQLITE_PRIVATE void sqlite3PcacheDrop ( PgHdr * ) ; 
line 7725: SQLITE_PRIVATE void sqlite3PcacheMakeDirty ( PgHdr * ) ; 
line 7726: SQLITE_PRIVATE void sqlite3PcacheMakeClean ( PgHdr * ) ; 
line 7727: SQLITE_PRIVATE void sqlite3PcacheCleanAll ( PCache * ) ; 
line 7730: SQLITE_PRIVATE void sqlite3PcacheMove ( PgHdr * , Pgno ) ; 
line 7733: SQLITE_PRIVATE void sqlite3PcacheTruncate ( PCache * , Pgno x ) ; 
line 7736: SQLITE_PRIVATE PgHdr * sqlite3PcacheDirtyList ( PCache * ) ; 
line 7739: SQLITE_PRIVATE void sqlite3PcacheClose ( PCache * ) ; 
line 7742: SQLITE_PRIVATE void sqlite3PcacheClearSyncFlags ( PCache * ) ; 
line 7745: SQLITE_PRIVATE void sqlite3PcacheClear ( PCache * ) ; 
line 7748: SQLITE_PRIVATE int sqlite3PcacheRefCount ( PCache * ) ; 
line 7751: SQLITE_PRIVATE void sqlite3PcacheRef ( PgHdr * ) ; 
line 7753: SQLITE_PRIVATE int sqlite3PcachePageRefcount ( PgHdr * ) ; 
line 7756: SQLITE_PRIVATE int sqlite3PcachePagecount ( PCache * ) ; 
line 7758: # if defined ( SQLITE_CHECK_PAGES ) || defined ( SQLITE_DEBUG ) 
line 7763: SQLITE_PRIVATE void sqlite3PcacheIterateDirty ( PCache * pCache , void ( * xIter ) ( PgHdr * ) ) ; 
line 7764: # endif 
line 7772: SQLITE_PRIVATE void sqlite3PcacheSetCachesize ( PCache * , int ) ; 
line 7773: # ifdef SQLITE_TEST 
line 7774: SQLITE_PRIVATE int sqlite3PcacheGetCachesize ( PCache * ) ; 
line 7775: # endif 
line 7777: # ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT 
line 7779: SQLITE_PRIVATE int sqlite3PcacheReleaseMemory ( int ) ; 
line 7780: # endif 
line 7782: # ifdef SQLITE_TEST 
line 7783: SQLITE_PRIVATE void sqlite3PcacheStats ( int * , int * , int * , int * ) ; 
line 7784: # endif 
line 7786: SQLITE_PRIVATE void sqlite3PCacheSetDefault ( void ) ; 
line 7788: # endif 
line 7814: # ifndef _SQLITE_OS_H_ 
line 7815: # define _SQLITE_OS_H_ 
line 7824: # if defined ( SQLITE_OS_OTHER ) 
line 7825: # if SQLITE_OS_OTHER == 1 
line 7826: # undef SQLITE_OS_UNIX 
line 7827: # define SQLITE_OS_UNIX 0 
line 7828: # undef SQLITE_OS_WIN 
line 7829: # define SQLITE_OS_WIN 0 
line 7830: # undef SQLITE_OS_OS2 
line 7831: # define SQLITE_OS_OS2 0 
line 7832: # else 
line 7833: # undef SQLITE_OS_OTHER 
line 7834: # endif 
line 7835: # endif 
line 7836: # if ! defined ( SQLITE_OS_UNIX ) && ! defined ( SQLITE_OS_OTHER ) 
line 7837: # define SQLITE_OS_OTHER 0 
line 7838: # ifndef SQLITE_OS_WIN 
line 7839: # if defined ( _WIN32 ) || defined ( WIN32 ) || defined ( __CYGWIN__ ) || defined ( __MINGW32__ ) || defined ( __BORLANDC__ ) 
line 7840: # define SQLITE_OS_WIN 1 
line 7841: # define SQLITE_OS_UNIX 0 
line 7842: # define SQLITE_OS_OS2 0 
line 7843: # elif defined ( __EMX__ ) || defined ( _OS2 ) || defined ( OS2 ) || defined ( _OS2_ ) || defined ( __OS2__ ) 
line 7844: # define SQLITE_OS_WIN 0 
line 7845: # define SQLITE_OS_UNIX 0 
line 7846: # define SQLITE_OS_OS2 1 
line 7847: # else 
line 7848: # define SQLITE_OS_WIN 0 
line 7849: # define SQLITE_OS_UNIX 1 
line 7850: # define SQLITE_OS_OS2 0 
line 7851: # endif 
line 7852: # else 
line 7853: # define SQLITE_OS_UNIX 0 
line 7854: # define SQLITE_OS_OS2 0 
line 7855: # endif 
line 7856: # else 
line 7857: # ifndef SQLITE_OS_WIN 
line 7858: # define SQLITE_OS_WIN 0 
line 7859: # endif 
line 7860: # endif 
line 7866: # if defined ( _WIN32_WCE ) 
line 7867: # define SQLITE_OS_WINCE 1 
line 7868: # else 
line 7869: # define SQLITE_OS_WINCE 0 
line 7870: # endif 
line 7876: # if SQLITE_OS_WIN 
line 7877: # include < windows . h > 
line 7878: # define SQLITE_TEMPNAME_SIZE ( MAX_PATH + 50 ) 
line 7879: # elif SQLITE_OS_OS2 
line 7880: # if ( __GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 3 ) && defined ( OS2_HIGH_MEMORY ) 
line 7881: # include < os2safe . h > 
line 7882: # endif 
line 7883: # define INCL_DOSDATETIME 
line 7884: # define INCL_DOSFILEMGR 
line 7885: # define INCL_DOSERRORS 
line 7886: # define INCL_DOSMISC 
line 7887: # define INCL_DOSPROCESS 
line 7888: # define INCL_DOSMODULEMGR 
line 7889: # define INCL_DOSSEMAPHORES 
line 7890: # include < os2 . h > 
line 7891: # include < uconv . h > 
line 7892: # define SQLITE_TEMPNAME_SIZE ( CCHMAXPATHCOMP ) 
line 7893: # else 
line 7894: # define SQLITE_TEMPNAME_SIZE 200 
line 7895: # endif 
line 7900: # ifndef SET_FULLSYNC 
line 7901: # define SET_FULLSYNC ( x , y ) 
line 7902: # endif 
line 7907: # ifndef SQLITE_DEFAULT_SECTOR_SIZE 
line 7908: # define SQLITE_DEFAULT_SECTOR_SIZE 512 
line 7909: # endif 
line 7932: # ifndef SQLITE_TEMP_FILE_PREFIX 
line 7933: # define SQLITE_TEMP_FILE_PREFIX "etilqs_" 
line 7934: # endif 
line 7953: # define NO_LOCK 0 
line 7954: # define SHARED_LOCK 1 
line 7955: # define RESERVED_LOCK 2 
line 7956: # define PENDING_LOCK 3 
line 7957: # define EXCLUSIVE_LOCK 4 
line 8014: # define PENDING_BYTE sqlite3PendingByte 
line 8015: # define RESERVED_BYTE ( PENDING_BYTE + 1 ) 
line 8016: # define SHARED_FIRST ( PENDING_BYTE + 2 ) 
line 8017: # define SHARED_SIZE 510 
line 8022: SQLITE_PRIVATE int sqlite3OsInit ( void ) ; 
line 8027: SQLITE_PRIVATE int sqlite3OsClose ( sqlite3_file * ) ; 
line 8028: SQLITE_PRIVATE int sqlite3OsRead ( sqlite3_file * , void * , int amt , i64 offset ) ; 
line 8029: SQLITE_PRIVATE int sqlite3OsWrite ( sqlite3_file * , const void * , int amt , i64 offset ) ; 
line 8030: SQLITE_PRIVATE int sqlite3OsTruncate ( sqlite3_file * , i64 size ) ; 
line 8031: SQLITE_PRIVATE int sqlite3OsSync ( sqlite3_file * , int ) ; 
line 8032: SQLITE_PRIVATE int sqlite3OsFileSize ( sqlite3_file * , i64 * pSize ) ; 
line 8033: SQLITE_PRIVATE int sqlite3OsLock ( sqlite3_file * , int ) ; 
line 8034: SQLITE_PRIVATE int sqlite3OsUnlock ( sqlite3_file * , int ) ; 
line 8035: SQLITE_PRIVATE int sqlite3OsCheckReservedLock ( sqlite3_file * id , int * pResOut ) ; 
line 8036: SQLITE_PRIVATE int sqlite3OsFileControl ( sqlite3_file * , int , void * ) ; 
line 8037: # define SQLITE_FCNTL_DB_UNCHANGED 0xca093fa0 
line 8038: SQLITE_PRIVATE int sqlite3OsSectorSize ( sqlite3_file * id ) ; 
line 8039: SQLITE_PRIVATE int sqlite3OsDeviceCharacteristics ( sqlite3_file * id ) ; 
line 8044: SQLITE_PRIVATE int sqlite3OsOpen ( sqlite3_vfs * , const char * , sqlite3_file * , int , int * ) ; 
line 8045: SQLITE_PRIVATE int sqlite3OsDelete ( sqlite3_vfs * , const char * , int ) ; 
line 8046: SQLITE_PRIVATE int sqlite3OsAccess ( sqlite3_vfs * , const char * , int , int * pResOut ) ; 
line 8047: SQLITE_PRIVATE int sqlite3OsFullPathname ( sqlite3_vfs * , const char * , int , char * ) ; 
line 8048: # ifndef SQLITE_OMIT_LOAD_EXTENSION 
line 8049: SQLITE_PRIVATE void * sqlite3OsDlOpen ( sqlite3_vfs * , const char * ) ; 
line 8050: SQLITE_PRIVATE void sqlite3OsDlError ( sqlite3_vfs * , int , char * ) ; 
line 8051: SQLITE_PRIVATE void ( * sqlite3OsDlSym ( sqlite3_vfs * , void * , const char * ) ) ( void ) ; 
line 8052: SQLITE_PRIVATE void sqlite3OsDlClose ( sqlite3_vfs * , void * ) ; 
line 8053: # endif 
line 8054: SQLITE_PRIVATE int sqlite3OsRandomness ( sqlite3_vfs * , int , char * ) ; 
line 8055: SQLITE_PRIVATE int sqlite3OsSleep ( sqlite3_vfs * , int ) ; 
line 8056: SQLITE_PRIVATE int sqlite3OsCurrentTime ( sqlite3_vfs * , double * ) ; 
line 8062: SQLITE_PRIVATE int sqlite3OsOpenMalloc ( sqlite3_vfs * , const char * , sqlite3_file * * , int , int * ) ; 
line 8063: SQLITE_PRIVATE int sqlite3OsCloseFree ( sqlite3_file * ) ; 
line 8065: # endif 
line 8112: # if ! SQLITE_THREADSAFE 
line 8113: # define SQLITE_MUTEX_OMIT 
line 8114: # endif 
line 8115: # if SQLITE_THREADSAFE && ! defined ( SQLITE_MUTEX_NOOP ) 
line 8116: # if SQLITE_OS_UNIX 
line 8117: # define SQLITE_MUTEX_PTHREADS 
line 8118: # elif SQLITE_OS_WIN 
line 8119: # define SQLITE_MUTEX_W32 
line 8120: # elif SQLITE_OS_OS2 
line 8121: # define SQLITE_MUTEX_OS2 
line 8122: # else 
line 8123: # define SQLITE_MUTEX_NOOP 
line 8124: # endif 
line 8125: # endif 
line 8127: # ifdef SQLITE_MUTEX_OMIT 
line 8131: # define sqlite3_mutex_alloc ( X ) ( ( sqlite3_mutex * ) 8 ) 
line 8132: # define sqlite3_mutex_free ( X ) 
line 8133: # define sqlite3_mutex_enter ( X ) 
line 8134: # define sqlite3_mutex_try ( X ) SQLITE_OK 
line 8135: # define sqlite3_mutex_leave ( X ) 
line 8136: # define sqlite3_mutex_held ( X ) 1 
line 8137: # define sqlite3_mutex_notheld ( X ) 1 
line 8138: # define sqlite3MutexAlloc ( X ) ( ( sqlite3_mutex * ) 8 ) 
line 8139: # define sqlite3MutexInit ( ) SQLITE_OK 
line 8140: # define sqlite3MutexEnd ( ) 
line 8141: # endif 
line 8154: struct Db { 
line 8155: char * zName ; 
line 8156: Btree * pBt ; 
line 8157: u8 inTrans ; 
line 8158: u8 safety_level ; 
line 8159: Schema * pSchema ; 
line 8160: } ; 
line 8173: struct Schema { 
line 8174: int schema_cookie ; 
line 8175: Hash tblHash ; 
line 8176: Hash idxHash ; 
line 8177: Hash trigHash ; 
line 8178: Hash fkeyHash ; 
line 8179: Table * pSeqTab ; 
line 8180: u8 file_format ; 
line 8181: u8 enc ; 
line 8182: u16 flags ; 
line 8183: int cache_size ; 
line 8184: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 8185: sqlite3 * db ; 
line 8186: # endif 
line 8187: } ; 
line 8193: # define DbHasProperty ( D , I , P ) ( ( ( D ) -> aDb [ I ] . pSchema -> flags & ( P ) ) == ( P ) ) 
line 8194: # define DbHasAnyProperty ( D , I , P ) ( ( ( D ) -> aDb [ I ] . pSchema -> flags & ( P ) ) != 0 ) 
line 8195: # define DbSetProperty ( D , I , P ) ( D ) -> aDb [ I ] . pSchema -> flags |= ( P ) 
line 8196: # define DbClearProperty ( D , I , P ) ( D ) -> aDb [ I ] . pSchema -> flags &= ~ ( P ) 
line 8208: # define DB_SchemaLoaded 0x0001 
line 8209: # define DB_UnresetViews 0x0002 
line 8210: # define DB_Empty 0x0004 
line 8216: # define SQLITE_N_LIMIT ( SQLITE_LIMIT_TRIGGER_DEPTH + 1 ) 
line 8238: struct Lookaside { 
line 8239: u16 sz ; 
line 8240: u8 bEnabled ; 
line 8241: u8 bMalloced ; 
line 8242: int nOut ; 
line 8243: int mxOut ; 
line 8244: LookasideSlot * pFree ; 
line 8245: void * pStart ; 
line 8246: void * pEnd ; 
line 8247: } ; 
line 8248: struct LookasideSlot { 
line 8249: LookasideSlot * pNext ; 
line 8250: } ; 
line 8258: struct FuncDefHash { 
line 8259: FuncDef * a [ 23 ] ; 
line 8260: } ; 
line 8288: struct sqlite3 { 
line 8289: sqlite3_vfs * pVfs ; 
line 8290: int nDb ; 
line 8291: Db * aDb ; 
line 8292: int flags ; 
line 8293: int openFlags ; 
line 8294: int errCode ; 
line 8295: int errMask ; 
line 8296: u8 autoCommit ; 
line 8297: u8 temp_store ; 
line 8298: u8 mallocFailed ; 
line 8299: u8 dfltLockMode ; 
line 8300: u8 dfltJournalMode ; 
line 8301: signed char nextAutovac ; 
line 8302: int nextPagesize ; 
line 8303: int nTable ; 
line 8304: CollSeq * pDfltColl ; 
line 8305: i64 lastRowid ; 
line 8306: u32 magic ; 
line 8307: int nChange ; 
line 8308: int nTotalChange ; 
line 8309: sqlite3_mutex * mutex ; 
line 8310: int aLimit [ SQLITE_N_LIMIT ] ; 
line 8311: struct sqlite3InitInfo { 
line 8312: int iDb ; 
line 8313: int newTnum ; 
line 8314: u8 busy ; 
line 8315: u8 orphanTrigger ; 
line 8316: } init ; 
line 8317: int nExtension ; 
line 8318: void * * aExtension ; 
line 8319: struct Vdbe * pVdbe ; 
line 8320: int activeVdbeCnt ; 
line 8321: int writeVdbeCnt ; 
line 8322: void ( * xTrace ) ( void * , const char * ) ; 
line 8323: void * pTraceArg ; 
line 8324: void ( * xProfile ) ( void * , const char * , u64 ) ; 
line 8325: void * pProfileArg ; 
line 8326: void * pCommitArg ; 
line 8327: int ( * xCommitCallback ) ( void * ) ; 
line 8328: void * pRollbackArg ; 
line 8329: void ( * xRollbackCallback ) ( void * ) ; 
line 8330: void * pUpdateArg ; 
line 8331: void ( * xUpdateCallback ) ( void * , int , const char * , const char * , sqlite_int64 ) ; 
line 8332: void ( * xCollNeeded ) ( void * , sqlite3 * , int eTextRep , const char * ) ; 
line 8333: void ( * xCollNeeded16 ) ( void * , sqlite3 * , int eTextRep , const void * ) ; 
line 8334: void * pCollNeededArg ; 
line 8335: sqlite3_value * pErr ; 
line 8336: char * zErrMsg ; 
line 8337: char * zErrMsg16 ; 
line 8338: union { 
line 8339: volatile int isInterrupted ; 
line 8340: double notUsed1 ; 
line 8341: } u1 ; 
line 8342: Lookaside lookaside ; 
line 8343: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 8344: int ( * xAuth ) ( void * , int , const char * , const char * , const char * , const char * ) ; 
line 8346: void * pAuthArg ; 
line 8347: # endif 
line 8348: # ifndef SQLITE_OMIT_PROGRESS_CALLBACK 
line 8349: int ( * xProgress ) ( void * ) ; 
line 8350: void * pProgressArg ; 
line 8351: int nProgressOps ; 
line 8352: # endif 
line 8353: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 8354: Hash aModule ; 
line 8355: Table * pVTab ; 
line 8356: VTable * * aVTrans ; 
line 8357: int nVTrans ; 
line 8358: VTable * pDisconnect ; 
line 8359: # endif 
line 8360: FuncDefHash aFunc ; 
line 8361: Hash aCollSeq ; 
line 8362: BusyHandler busyHandler ; 
line 8363: int busyTimeout ; 
line 8364: Db aDbStatic [ 2 ] ; 
line 8365: Savepoint * pSavepoint ; 
line 8366: int nSavepoint ; 
line 8367: int nStatement ; 
line 8368: u8 isTransactionSavepoint ; 
line 8369: i64 nDeferredCons ; 
line 8371: # ifdef SQLITE_ENABLE_UNLOCK_NOTIFY 
line 8382: sqlite3 * pBlockingConnection ; 
line 8383: sqlite3 * pUnlockConnection ; 
line 8384: void * pUnlockArg ; 
line 8385: void ( * xUnlockNotify ) ( void * * , int ) ; 
line 8386: sqlite3 * pNextBlocked ; 
line 8387: # endif 
line 8388: } ; 
line 8393: # define ENC ( db ) ( ( db ) -> aDb [ 0 ] . pSchema -> enc ) 
line 8398: # define SQLITE_VdbeTrace 0x00000100 
line 8399: # define SQLITE_InternChanges 0x00000200 
line 8400: # define SQLITE_FullColNames 0x00000400 
line 8401: # define SQLITE_ShortColNames 0x00000800 
line 8402: # define SQLITE_CountRows 0x00001000 
line 8405: # define SQLITE_NullCallback 0x00002000 
line 8407: # define SQLITE_SqlTrace 0x00004000 
line 8408: # define SQLITE_VdbeListing 0x00008000 
line 8409: # define SQLITE_WriteSchema 0x00010000 
line 8410: # define SQLITE_NoReadlock 0x00020000 
line 8412: # define SQLITE_IgnoreChecks 0x00040000 
line 8413: # define SQLITE_ReadUncommitted 0x0080000 
line 8414: # define SQLITE_LegacyFileFmt 0x00100000 
line 8415: # define SQLITE_FullFSync 0x00200000 
line 8416: # define SQLITE_LoadExtension 0x00400000 
line 8417: # define SQLITE_RecoveryMode 0x00800000 
line 8418: # define SQLITE_ReverseOrder 0x01000000 
line 8419: # define SQLITE_RecTriggers 0x02000000 
line 8420: # define SQLITE_ForeignKeys 0x04000000 
line 8427: # define SQLITE_QueryFlattener 0x01 
line 8428: # define SQLITE_ColumnCache 0x02 
line 8429: # define SQLITE_IndexSort 0x04 
line 8430: # define SQLITE_IndexSearch 0x08 
line 8431: # define SQLITE_IndexCover 0x10 
line 8432: # define SQLITE_OptMask 0x1f 
line 8439: # define SQLITE_MAGIC_OPEN 0xa029a697 
line 8440: # define SQLITE_MAGIC_CLOSED 0x9f3c2d33 
line 8441: # define SQLITE_MAGIC_SICK 0x4b771290 
line 8442: # define SQLITE_MAGIC_BUSY 0xf03b7906 
line 8443: # define SQLITE_MAGIC_ERROR 0xb5357930 
line 8451: struct FuncDef { 
line 8452: i16 nArg ; 
line 8453: u8 iPrefEnc ; 
line 8454: u8 flags ; 
line 8455: void * pUserData ; 
line 8456: FuncDef * pNext ; 
line 8457: void ( * xFunc ) ( sqlite3_context * , int , sqlite3_value * * ) ; 
line 8458: void ( * xStep ) ( sqlite3_context * , int , sqlite3_value * * ) ; 
line 8459: void ( * xFinalize ) ( sqlite3_context * ) ; 
line 8460: char * zName ; 
line 8461: FuncDef * pHash ; 
line 8462: } ; 
line 8467: # define SQLITE_FUNC_LIKE 0x01 
line 8468: # define SQLITE_FUNC_CASE 0x02 
line 8469: # define SQLITE_FUNC_EPHEM 0x04 
line 8470: # define SQLITE_FUNC_NEEDCOLL 0x08 
line 8471: # define SQLITE_FUNC_PRIVATE 0x10 
line 8472: # define SQLITE_FUNC_COUNT 0x20 
line 8473: # define SQLITE_FUNC_COALESCE 0x40 
line 8500: # define FUNCTION ( zName , nArg , iArg , bNC , xFunc ) 
line 8501: { nArg , SQLITE_UTF8 , bNC * SQLITE_FUNC_NEEDCOLL , 
line 8502: SQLITE_INT_TO_PTR ( iArg ) , 0 , xFunc , 0 , 0 , # zName , 0 } 
line 8503: # define STR_FUNCTION ( zName , nArg , pArg , bNC , xFunc ) 
line 8504: { nArg , SQLITE_UTF8 , bNC * SQLITE_FUNC_NEEDCOLL , 
line 8505: pArg , 0 , xFunc , 0 , 0 , # zName , 0 } 
line 8506: # define LIKEFUNC ( zName , nArg , arg , flags ) 
line 8507: { nArg , SQLITE_UTF8 , flags , ( void * ) arg , 0 , likeFunc , 0 , 0 , # zName , 0 } 
line 8508: # define AGGREGATE ( zName , nArg , arg , nc , xStep , xFinal ) 
line 8509: { nArg , SQLITE_UTF8 , nc * SQLITE_FUNC_NEEDCOLL , 
line 8510: SQLITE_INT_TO_PTR ( arg ) , 0 , 0 , xStep , xFinal , # zName , 0 } 
line 8518: struct Savepoint { 
line 8519: char * zName ; 
line 8520: i64 nDeferredCons ; 
line 8521: Savepoint * pNext ; 
line 8522: } ; 
line 8528: # define SAVEPOINT_BEGIN 0 
line 8529: # define SAVEPOINT_RELEASE 1 
line 8530: # define SAVEPOINT_ROLLBACK 2 
line 8538: struct Module { 
line 8539: const sqlite3_module * pModule ; 
line 8540: const char * zName ; 
line 8541: void * pAux ; 
line 8542: void ( * xDestroy ) ( void * ) ; 
line 8543: } ; 
line 8549: struct Column { 
line 8550: char * zName ; 
line 8551: Expr * pDflt ; 
line 8552: char * zDflt ; 
line 8553: char * zType ; 
line 8554: char * zColl ; 
line 8555: u8 notNull ; 
line 8556: u8 isPrimKey ; 
line 8557: char affinity ; 
line 8558: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 8559: u8 isHidden ; 
line 8560: # endif 
line 8561: } ; 
line 8584: struct CollSeq { 
line 8585: char * zName ; 
line 8586: u8 enc ; 
line 8587: u8 type ; 
line 8588: void * pUser ; 
line 8589: int ( * xCmp ) ( void * , int , const void * , int , const void * ) ; 
line 8590: void ( * xDel ) ( void * ) ; 
line 8591: } ; 
line 8596: # define SQLITE_COLL_BINARY 1 
line 8597: # define SQLITE_COLL_NOCASE 2 
line 8598: # define SQLITE_COLL_REVERSE 3 
line 8599: # define SQLITE_COLL_USER 0 
line 8604: # define SQLITE_SO_ASC 0 
line 8605: # define SQLITE_SO_DESC 1 
line 8621: # define SQLITE_AFF_TEXT 'a' 
line 8622: # define SQLITE_AFF_NONE 'b' 
line 8623: # define SQLITE_AFF_NUMERIC 'c' 
line 8624: # define SQLITE_AFF_INTEGER 'd' 
line 8625: # define SQLITE_AFF_REAL 'e' 
line 8627: # define sqlite3IsNumericAffinity ( X ) ( ( X ) >= SQLITE_AFF_NUMERIC ) 
line 8633: # define SQLITE_AFF_MASK 0x67 
line 8639: # define SQLITE_JUMPIFNULL 0x08 
line 8640: # define SQLITE_STOREP2 0x10 
line 8641: # define SQLITE_NULLEQ 0x80 
line 8685: struct VTable { 
line 8686: sqlite3 * db ; 
line 8687: Module * pMod ; 
line 8688: sqlite3_vtab * pVtab ; 
line 8689: int nRef ; 
line 8690: VTable * pNext ; 
line 8691: } ; 
line 8723: struct Table { 
line 8724: sqlite3 * dbMem ; 
line 8725: char * zName ; 
line 8726: int iPKey ; 
line 8727: int nCol ; 
line 8728: Column * aCol ; 
line 8729: Index * pIndex ; 
line 8730: int tnum ; 
line 8731: Select * pSelect ; 
line 8732: u16 nRef ; 
line 8733: u8 tabFlags ; 
line 8734: u8 keyConf ; 
line 8735: FKey * pFKey ; 
line 8736: char * zColAff ; 
line 8737: # ifndef SQLITE_OMIT_CHECK 
line 8738: Expr * pCheck ; 
line 8739: # endif 
line 8740: # ifndef SQLITE_OMIT_ALTERTABLE 
line 8741: int addColOffset ; 
line 8742: # endif 
line 8743: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 8744: VTable * pVTable ; 
line 8745: int nModuleArg ; 
line 8746: char * * azModuleArg ; 
line 8747: # endif 
line 8748: Trigger * pTrigger ; 
line 8749: Schema * pSchema ; 
line 8750: Table * pNextZombie ; 
line 8751: } ; 
line 8756: # define TF_Readonly 0x01 
line 8757: # define TF_Ephemeral 0x02 
line 8758: # define TF_HasPrimaryKey 0x04 
line 8759: # define TF_Autoincrement 0x08 
line 8760: # define TF_Virtual 0x10 
line 8761: # define TF_NeedMetadata 0x20 
line 8770: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 8771: # define IsVirtual ( X ) ( ( ( X ) -> tabFlags & TF_Virtual ) != 0 ) 
line 8772: # define IsHiddenColumn ( X ) ( ( X ) -> isHidden ) 
line 8773: # else 
line 8774: # define IsVirtual ( X ) 0 
line 8775: # define IsHiddenColumn ( X ) 0 
line 8776: # endif 
line 8797: struct FKey { 
line 8798: Table * pFrom ; 
line 8799: FKey * pNextFrom ; 
line 8800: char * zTo ; 
line 8801: FKey * pNextTo ; 
line 8802: FKey * pPrevTo ; 
line 8803: int nCol ; 
line 8805: u8 isDeferred ; 
line 8806: u8 aAction [ 2 ] ; 
line 8807: Trigger * apTrigger [ 2 ] ; 
line 8808: struct sColMap { 
line 8809: int iFrom ; 
line 8810: char * zCol ; 
line 8811: } aCol [ 1 ] ; 
line 8812: } ; 
line 8839: # define OE_None 0 
line 8840: # define OE_Rollback 1 
line 8841: # define OE_Abort 2 
line 8842: # define OE_Fail 3 
line 8843: # define OE_Ignore 4 
line 8844: # define OE_Replace 5 
line 8846: # define OE_Restrict 6 
line 8847: # define OE_SetNull 7 
line 8848: # define OE_SetDflt 8 
line 8849: # define OE_Cascade 9 
line 8851: # define OE_Default 99 
line 8859: struct KeyInfo { 
line 8860: sqlite3 * db ; 
line 8861: u8 enc ; 
line 8862: u16 nField ; 
line 8863: u8 * aSortOrder ; 
line 8864: CollSeq * aColl [ 1 ] ; 
line 8865: } ; 
line 8881: struct UnpackedRecord { 
line 8882: KeyInfo * pKeyInfo ; 
line 8883: u16 nField ; 
line 8884: u16 flags ; 
line 8885: i64 rowid ; 
line 8886: Mem * aMem ; 
line 8887: } ; 
line 8892: # define UNPACKED_NEED_FREE 0x0001 
line 8893: # define UNPACKED_NEED_DESTROY 0x0002 
line 8894: # define UNPACKED_IGNORE_ROWID 0x0004 
line 8895: # define UNPACKED_INCRKEY 0x0008 
line 8896: # define UNPACKED_PREFIX_MATCH 0x0010 
line 8897: # define UNPACKED_PREFIX_SEARCH 0x0020 
line 8925: struct Index { 
line 8926: char * zName ; 
line 8927: int nColumn ; 
line 8928: int * aiColumn ; 
line 8929: unsigned * aiRowEst ; 
line 8930: Table * pTable ; 
line 8931: int tnum ; 
line 8932: u8 onError ; 
line 8933: u8 autoIndex ; 
line 8934: char * zColAff ; 
line 8935: Index * pNext ; 
line 8936: Schema * pSchema ; 
line 8937: u8 * aSortOrder ; 
line 8938: char * * azColl ; 
line 8939: IndexSample * aSample ; 
line 8940: } ; 
line 8946: struct IndexSample { 
line 8947: union { 
line 8948: char * z ; 
line 8949: double r ; 
line 8950: } u ; 
line 8951: u8 eType ; 
line 8952: u8 nByte ; 
line 8953: } ; 
line 8963: struct Token { 
line 8964: const char * z ; 
line 8965: unsigned int n ; 
line 8966: } ; 
line 8981: struct AggInfo { 
line 8982: u8 directMode ; 
line 8984: u8 useSortingIdx ; 
line 8986: int sortingIdx ; 
line 8987: ExprList * pGroupBy ; 
line 8988: int nSortingColumn ; 
line 8989: struct AggInfo_col { 
line 8990: Table * pTab ; 
line 8991: int iTable ; 
line 8992: int iColumn ; 
line 8993: int iSorterColumn ; 
line 8994: int iMem ; 
line 8995: Expr * pExpr ; 
line 8996: } * aCol ; 
line 8997: int nColumn ; 
line 8998: int nColumnAlloc ; 
line 8999: int nAccumulator ; 
line 9002: struct AggInfo_func { 
line 9003: Expr * pExpr ; 
line 9004: FuncDef * pFunc ; 
line 9005: int iMem ; 
line 9006: int iDistinct ; 
line 9007: } * aFunc ; 
line 9008: int nFunc ; 
line 9009: int nFuncAlloc ; 
line 9010: } ; 
line 9022: # if SQLITE_MAX_VARIABLE_NUMBER <= 32767 
line 9023: typedef i16 ynVar ; 
line 9024: # else 
line 9025: typedef int ynVar ; 
line 9026: # endif 
line 9091: struct Expr { 
line 9092: u8 op ; 
line 9093: char affinity ; 
line 9094: u16 flags ; 
line 9095: union { 
line 9096: char * zToken ; 
line 9097: int iValue ; 
line 9098: } u ; 
line 9105: Expr * pLeft ; 
line 9106: Expr * pRight ; 
line 9107: union { 
line 9108: ExprList * pList ; 
line 9109: Select * pSelect ; 
line 9110: } x ; 
line 9111: CollSeq * pColl ; 
line 9118: int iTable ; 
line 9121: ynVar iColumn ; 
line 9123: i16 iAgg ; 
line 9124: i16 iRightJoinTable ; 
line 9125: u8 flags2 ; 
line 9126: u8 op2 ; 
line 9127: AggInfo * pAggInfo ; 
line 9128: Table * pTab ; 
line 9129: # if SQLITE_MAX_EXPR_DEPTH > 0 
line 9130: int nHeight ; 
line 9131: # endif 
line 9132: } ; 
line 9137: # define EP_FromJoin 0x0001 
line 9138: # define EP_Agg 0x0002 
line 9139: # define EP_Resolved 0x0004 
line 9140: # define EP_Error 0x0008 
line 9141: # define EP_Distinct 0x0010 
line 9142: # define EP_VarSelect 0x0020 
line 9143: # define EP_DblQuoted 0x0040 
line 9144: # define EP_InfixFunc 0x0080 
line 9145: # define EP_ExpCollate 0x0100 
line 9146: # define EP_FixedDest 0x0200 
line 9147: # define EP_IntValue 0x0400 
line 9148: # define EP_xIsSelect 0x0800 
line 9150: # define EP_Reduced 0x1000 
line 9151: # define EP_TokenOnly 0x2000 
line 9152: # define EP_Static 0x4000 
line 9157: # define EP2_MallocedToken 0x0001 
line 9158: # define EP2_Irreducible 0x0002 
line 9166: # ifdef SQLITE_DEBUG 
line 9167: # define ExprSetIrreducible ( X ) ( X ) -> flags2 |= EP2_Irreducible 
line 9168: # else 
line 9169: # define ExprSetIrreducible ( X ) 
line 9170: # endif 
line 9176: # define ExprHasProperty ( E , P ) ( ( ( E ) -> flags & ( P ) ) == ( P ) ) 
line 9177: # define ExprHasAnyProperty ( E , P ) ( ( ( E ) -> flags & ( P ) ) != 0 ) 
line 9178: # define ExprSetProperty ( E , P ) ( E ) -> flags |= ( P ) 
line 9179: # define ExprClearProperty ( E , P ) ( E ) -> flags &= ~ ( P ) 
line 9186: # define EXPR_FULLSIZE sizeof ( Expr ) 
line 9187: # define EXPR_REDUCEDSIZE offsetof ( Expr , iTable ) 
line 9188: # define EXPR_TOKENONLYSIZE offsetof ( Expr , pLeft ) 
line 9194: # define EXPRDUP_REDUCE 0x0001 
line 9204: struct ExprList { 
line 9205: int nExpr ; 
line 9206: int nAlloc ; 
line 9207: int iECursor ; 
line 9208: struct ExprList_item { 
line 9209: Expr * pExpr ; 
line 9210: char * zName ; 
line 9211: char * zSpan ; 
line 9212: u8 sortOrder ; 
line 9213: u8 done ; 
line 9214: u16 iCol ; 
line 9215: u16 iAlias ; 
line 9216: } * a ; 
line 9217: } ; 
line 9224: struct ExprSpan { 
line 9225: Expr * pExpr ; 
line 9226: const char * zStart ; 
line 9227: const char * zEnd ; 
line 9228: } ; 
line 9245: struct IdList { 
line 9246: struct IdList_item { 
line 9247: char * zName ; 
line 9248: int idx ; 
line 9249: } * a ; 
line 9250: int nId ; 
line 9251: int nAlloc ; 
line 9252: } ; 
line 9261: typedef u64 Bitmask ; 
line 9266: # define BMS ( ( int ) ( sizeof ( Bitmask ) * 8 ) ) 
line 9284: struct SrcList { 
line 9285: i16 nSrc ; 
line 9286: i16 nAlloc ; 
line 9287: struct SrcList_item { 
line 9288: char * zDatabase ; 
line 9289: char * zName ; 
line 9290: char * zAlias ; 
line 9291: Table * pTab ; 
line 9292: Select * pSelect ; 
line 9293: u8 isPopulated ; 
line 9294: u8 jointype ; 
line 9295: u8 notIndexed ; 
line 9296: int iCursor ; 
line 9297: Expr * pOn ; 
line 9298: IdList * pUsing ; 
line 9299: Bitmask colUsed ; 
line 9300: char * zIndex ; 
line 9301: Index * pIndex ; 
line 9302: } a [ 1 ] ; 
line 9303: } ; 
line 9308: # define JT_INNER 0x0001 
line 9309: # define JT_CROSS 0x0002 
line 9310: # define JT_NATURAL 0x0004 
line 9311: # define JT_LEFT 0x0008 
line 9312: # define JT_RIGHT 0x0010 
line 9313: # define JT_OUTER 0x0020 
line 9314: # define JT_ERROR 0x0040 
line 9331: struct WherePlan { 
line 9332: u32 wsFlags ; 
line 9333: u32 nEq ; 
line 9334: union { 
line 9335: Index * pIdx ; 
line 9336: struct WhereTerm * pTerm ; 
line 9337: sqlite3_index_info * pVtabIdx ; 
line 9338: } u ; 
line 9339: } ; 
line 9354: struct WhereLevel { 
line 9355: WherePlan plan ; 
line 9356: int iLeftJoin ; 
line 9357: int iTabCur ; 
line 9358: int iIdxCur ; 
line 9359: int addrBrk ; 
line 9360: int addrNxt ; 
line 9361: int addrCont ; 
line 9362: int addrFirst ; 
line 9363: u8 iFrom ; 
line 9364: u8 op , p5 ; 
line 9365: int p1 , p2 ; 
line 9366: union { 
line 9367: struct { 
line 9368: int nIn ; 
line 9369: struct InLoop { 
line 9370: int iCur ; 
line 9371: int addrInTop ; 
line 9372: } * aInLoop ; 
line 9373: } in ; 
line 9374: } u ; 
line 9382: sqlite3_index_info * pIdxInfo ; 
line 9383: } ; 
line 9389: # define WHERE_ORDERBY_NORMAL 0x0000 
line 9390: # define WHERE_ORDERBY_MIN 0x0001 
line 9391: # define WHERE_ORDERBY_MAX 0x0002 
line 9392: # define WHERE_ONEPASS_DESIRED 0x0004 
line 9393: # define WHERE_DUPLICATES_OK 0x0008 
line 9394: # define WHERE_OMIT_OPEN 0x0010 
line 9395: # define WHERE_OMIT_CLOSE 0x0020 
line 9396: # define WHERE_FORCE_TABLE 0x0040 
line 9397: # define WHERE_ONETABLE_ONLY 0x0080 
line 9406: struct WhereInfo { 
line 9407: Parse * pParse ; 
line 9408: u16 wctrlFlags ; 
line 9409: u8 okOnePass ; 
line 9410: u8 untestedTerms ; 
line 9411: SrcList * pTabList ; 
line 9412: int iTop ; 
line 9413: int iContinue ; 
line 9414: int iBreak ; 
line 9415: int nLevel ; 
line 9416: struct WhereClause * pWC ; 
line 9417: WhereLevel a [ 1 ] ; 
line 9418: } ; 
line 9441: struct NameContext { 
line 9442: Parse * pParse ; 
line 9443: SrcList * pSrcList ; 
line 9444: ExprList * pEList ; 
line 9445: int nRef ; 
line 9446: int nErr ; 
line 9447: u8 allowAgg ; 
line 9448: u8 hasAgg ; 
line 9449: u8 isCheck ; 
line 9450: int nDepth ; 
line 9451: AggInfo * pAggInfo ; 
line 9452: NameContext * pNext ; 
line 9453: } ; 
line 9475: struct Select { 
line 9476: ExprList * pEList ; 
line 9477: u8 op ; 
line 9478: char affinity ; 
line 9479: u16 selFlags ; 
line 9480: SrcList * pSrc ; 
line 9481: Expr * pWhere ; 
line 9482: ExprList * pGroupBy ; 
line 9483: Expr * pHaving ; 
line 9484: ExprList * pOrderBy ; 
line 9485: Select * pPrior ; 
line 9486: Select * pNext ; 
line 9487: Select * pRightmost ; 
line 9488: Expr * pLimit ; 
line 9489: Expr * pOffset ; 
line 9490: int iLimit , iOffset ; 
line 9491: int addrOpenEphm [ 3 ] ; 
line 9492: } ; 
line 9498: # define SF_Distinct 0x0001 
line 9499: # define SF_Resolved 0x0002 
line 9500: # define SF_Aggregate 0x0004 
line 9501: # define SF_UsesEphemeral 0x0008 
line 9502: # define SF_Expanded 0x0010 
line 9503: # define SF_HasTypeInfo 0x0020 
line 9510: # define SRT_Union 1 
line 9511: # define SRT_Except 2 
line 9512: # define SRT_Exists 3 
line 9513: # define SRT_Discard 4 
line 9516: # define IgnorableOrderby ( X ) ( ( X -> eDest ) <= SRT_Discard ) 
line 9518: # define SRT_Output 5 
line 9519: # define SRT_Mem 6 
line 9520: # define SRT_Set 7 
line 9521: # define SRT_Table 8 
line 9522: # define SRT_EphemTab 9 
line 9523: # define SRT_Coroutine 10 
line 9529: typedef struct SelectDest SelectDest ; 
line 9530: struct SelectDest { 
line 9531: u8 eDest ; 
line 9532: u8 affinity ; 
line 9533: int iParm ; 
line 9534: int iMem ; 
line 9535: int nMem ; 
line 9536: } ; 
line 9547: struct AutoincInfo { 
line 9548: AutoincInfo * pNext ; 
line 9549: Table * pTab ; 
line 9550: int iDb ; 
line 9551: int regCtr ; 
line 9552: } ; 
line 9557: # ifndef SQLITE_N_COLCACHE 
line 9558: # define SQLITE_N_COLCACHE 10 
line 9559: # endif 
line 9579: struct TriggerPrg { 
line 9580: Trigger * pTrigger ; 
line 9581: int orconf ; 
line 9582: SubProgram * pProgram ; 
line 9583: u32 aColmask [ 2 ] ; 
line 9584: TriggerPrg * pNext ; 
line 9585: } ; 
line 9603: struct Parse { 
line 9604: sqlite3 * db ; 
line 9605: int rc ; 
line 9606: char * zErrMsg ; 
line 9607: Vdbe * pVdbe ; 
line 9608: u8 colNamesSet ; 
line 9609: u8 nameClash ; 
line 9610: u8 checkSchema ; 
line 9611: u8 nested ; 
line 9612: u8 parseError ; 
line 9613: u8 nTempReg ; 
line 9614: u8 nTempInUse ; 
line 9615: int aTempReg [ 8 ] ; 
line 9616: int nRangeReg ; 
line 9617: int iRangeReg ; 
line 9618: int nErr ; 
line 9619: int nTab ; 
line 9620: int nMem ; 
line 9621: int nSet ; 
line 9622: int ckBase ; 
line 9623: int iCacheLevel ; 
line 9624: int iCacheCnt ; 
line 9625: u8 nColCache ; 
line 9626: u8 iColCache ; 
line 9627: struct yColCache { 
line 9628: int iTable ; 
line 9629: int iColumn ; 
line 9630: u8 tempReg ; 
line 9631: int iLevel ; 
line 9632: int iReg ; 
line 9633: int lru ; 
line 9634: } aColCache [ SQLITE_N_COLCACHE ] ; 
line 9635: u32 writeMask ; 
line 9636: u32 cookieMask ; 
line 9637: u8 isMultiWrite ; 
line 9638: u8 mayAbort ; 
line 9639: int cookieGoto ; 
line 9640: int cookieValue [ SQLITE_MAX_ATTACHED + 2 ] ; 
line 9641: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 9642: int nTableLock ; 
line 9643: TableLock * aTableLock ; 
line 9644: # endif 
line 9645: int regRowid ; 
line 9646: int regRoot ; 
line 9647: AutoincInfo * pAinc ; 
line 9648: int nMaxArg ; 
line 9651: Parse * pToplevel ; 
line 9652: Table * pTriggerTab ; 
line 9653: u32 oldmask ; 
line 9654: u32 newmask ; 
line 9655: u8 eTriggerOp ; 
line 9656: u8 eOrconf ; 
line 9657: u8 disableTriggers ; 
line 9662: int nVar ; 
line 9663: int nVarExpr ; 
line 9664: int nVarExprAlloc ; 
line 9665: Expr * * apVarExpr ; 
line 9666: Vdbe * pReprepare ; 
line 9667: int nAlias ; 
line 9668: int nAliasAlloc ; 
line 9669: int * aAlias ; 
line 9670: u8 explain ; 
line 9671: Token sNameToken ; 
line 9672: Token sLastToken ; 
line 9673: const char * zTail ; 
line 9674: Table * pNewTable ; 
line 9675: Trigger * pNewTrigger ; 
line 9676: const char * zAuthContext ; 
line 9677: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 9678: Token sArg ; 
line 9679: u8 declareVtab ; 
line 9680: int nVtabLock ; 
line 9681: Table * * apVtabLock ; 
line 9682: # endif 
line 9683: int nHeight ; 
line 9684: Table * pZombieTab ; 
line 9685: TriggerPrg * pTriggerPrg ; 
line 9686: } ; 
line 9688: # ifdef SQLITE_OMIT_VIRTUALTABLE 
line 9689: # define IN_DECLARE_VTAB 0 
line 9690: # else 
line 9691: # define IN_DECLARE_VTAB ( pParse -> declareVtab ) 
line 9692: # endif 
line 9698: struct AuthContext { 
line 9699: const char * zAuthContext ; 
line 9700: Parse * pParse ; 
line 9701: } ; 
line 9706: # define OPFLAG_NCHANGE 0x01 
line 9707: # define OPFLAG_LASTROWID 0x02 
line 9708: # define OPFLAG_ISUPDATE 0x04 
line 9709: # define OPFLAG_APPEND 0x08 
line 9710: # define OPFLAG_USESEEKRESULT 0x10 
line 9711: # define OPFLAG_CLEARCACHE 0x20 
line 9728: struct Trigger { 
line 9729: char * zName ; 
line 9730: char * table ; 
line 9731: u8 op ; 
line 9732: u8 tr_tm ; 
line 9733: Expr * pWhen ; 
line 9734: IdList * pColumns ; 
line 9736: Schema * pSchema ; 
line 9737: Schema * pTabSchema ; 
line 9738: TriggerStep * step_list ; 
line 9739: Trigger * pNext ; 
line 9740: } ; 
line 9749: # define TRIGGER_BEFORE 1 
line 9750: # define TRIGGER_AFTER 2 
line 9790: struct TriggerStep { 
line 9791: u8 op ; 
line 9792: u8 orconf ; 
line 9793: Trigger * pTrig ; 
line 9794: Select * pSelect ; 
line 9795: Token target ; 
line 9796: Expr * pWhere ; 
line 9797: ExprList * pExprList ; 
line 9798: IdList * pIdList ; 
line 9799: TriggerStep * pNext ; 
line 9800: TriggerStep * pLast ; 
line 9801: } ; 
line 9808: typedef struct DbFixer DbFixer ; 
line 9809: struct DbFixer { 
line 9810: Parse * pParse ; 
line 9811: const char * zDb ; 
line 9812: const char * zType ; 
line 9813: const Token * pName ; 
line 9814: } ; 
line 9820: struct StrAccum { 
line 9821: sqlite3 * db ; 
line 9822: char * zBase ; 
line 9823: char * zText ; 
line 9824: int nChar ; 
line 9825: int nAlloc ; 
line 9826: int mxAlloc ; 
line 9827: u8 mallocFailed ; 
line 9828: u8 useMalloc ; 
line 9829: u8 tooBig ; 
line 9830: } ; 
line 9836: typedef struct { 
line 9837: sqlite3 * db ; 
line 9838: int iDb ; 
line 9839: char * * pzErrMsg ; 
line 9840: int rc ; 
line 9841: } InitData ; 
line 9848: struct Sqlite3Config { 
line 9849: int bMemstat ; 
line 9850: int bCoreMutex ; 
line 9851: int bFullMutex ; 
line 9852: int mxStrlen ; 
line 9853: int szLookaside ; 
line 9854: int nLookaside ; 
line 9855: sqlite3_mem_methods m ; 
line 9856: sqlite3_mutex_methods mutex ; 
line 9857: sqlite3_pcache_methods pcache ; 
line 9858: void * pHeap ; 
line 9859: int nHeap ; 
line 9860: int mnReq , mxReq ; 
line 9861: void * pScratch ; 
line 9862: int szScratch ; 
line 9863: int nScratch ; 
line 9864: void * pPage ; 
line 9865: int szPage ; 
line 9866: int nPage ; 
line 9867: int mxParserStack ; 
line 9868: int sharedCacheEnabled ; 
line 9871: int isInit ; 
line 9872: int inProgress ; 
line 9873: int isMutexInit ; 
line 9874: int isMallocInit ; 
line 9875: int isPCacheInit ; 
line 9876: sqlite3_mutex * pInitMutex ; 
line 9877: int nRefInitMutex ; 
line 9878: } ; 
line 9883: struct Walker { 
line 9884: int ( * xExprCallback ) ( Walker * , Expr * ) ; 
line 9885: int ( * xSelectCallback ) ( Walker * , Select * ) ; 
line 9886: Parse * pParse ; 
line 9887: union { 
line 9888: NameContext * pNC ; 
line 9889: int i ; 
line 9890: } u ; 
line 9891: } ; 
line 9894: SQLITE_PRIVATE int sqlite3WalkExpr ( Walker * , Expr * ) ; 
line 9895: SQLITE_PRIVATE int sqlite3WalkExprList ( Walker * , ExprList * ) ; 
line 9896: SQLITE_PRIVATE int sqlite3WalkSelect ( Walker * , Select * ) ; 
line 9897: SQLITE_PRIVATE int sqlite3WalkSelectExpr ( Walker * , Select * ) ; 
line 9898: SQLITE_PRIVATE int sqlite3WalkSelectFrom ( Walker * , Select * ) ; 
line 9904: # define WRC_Continue 0 
line 9905: # define WRC_Prune 1 
line 9906: # define WRC_Abort 2 
line 9912: # define SQLITE_SKIP_UTF8 ( zIn ) { 
line 9913: if ( ( * ( zIn ++ ) ) >= 0xc0 ) { 
line 9914: while ( ( * zIn & 0xc0 ) == 0x80 ) { zIn ++ ; } 
line 9915: } 
line 9916: } 
line 9924: # ifdef SQLITE_DEBUG 
line 9925: SQLITE_PRIVATE int sqlite3Corrupt ( void ) ; 
line 9926: # define SQLITE_CORRUPT_BKPT sqlite3Corrupt ( ) 
line 9927: # else 
line 9928: # define SQLITE_CORRUPT_BKPT SQLITE_CORRUPT 
line 9929: # endif 
line 9935: # if ! defined ( SQLITE_ASCII ) || 
line 9936: ( defined ( SQLITE_ENABLE_FTS3 ) && defined ( SQLITE_AMALGAMATION ) ) 
line 9937: # include < ctype . h > 
line 9938: # endif 
line 9945: # ifdef SQLITE_ASCII 
line 9946: # define sqlite3Toupper ( x ) ( ( x ) & ~ ( sqlite3CtypeMap [ ( unsigned char ) ( x ) ] & 0x20 ) ) 
line 9947: # define sqlite3Isspace ( x ) ( sqlite3CtypeMap [ ( unsigned char ) ( x ) ] & 0x01 ) 
line 9948: # define sqlite3Isalnum ( x ) ( sqlite3CtypeMap [ ( unsigned char ) ( x ) ] & 0x06 ) 
line 9949: # define sqlite3Isalpha ( x ) ( sqlite3CtypeMap [ ( unsigned char ) ( x ) ] & 0x02 ) 
line 9950: # define sqlite3Isdigit ( x ) ( sqlite3CtypeMap [ ( unsigned char ) ( x ) ] & 0x04 ) 
line 9951: # define sqlite3Isxdigit ( x ) ( sqlite3CtypeMap [ ( unsigned char ) ( x ) ] & 0x08 ) 
line 9952: # define sqlite3Tolower ( x ) ( sqlite3UpperToLower [ ( unsigned char ) ( x ) ] ) 
line 9953: # else 
line 9954: # define sqlite3Toupper ( x ) toupper ( ( unsigned char ) ( x ) ) 
line 9955: # define sqlite3Isspace ( x ) isspace ( ( unsigned char ) ( x ) ) 
line 9956: # define sqlite3Isalnum ( x ) isalnum ( ( unsigned char ) ( x ) ) 
line 9957: # define sqlite3Isalpha ( x ) isalpha ( ( unsigned char ) ( x ) ) 
line 9958: # define sqlite3Isdigit ( x ) isdigit ( ( unsigned char ) ( x ) ) 
line 9959: # define sqlite3Isxdigit ( x ) isxdigit ( ( unsigned char ) ( x ) ) 
line 9960: # define sqlite3Tolower ( x ) tolower ( ( unsigned char ) ( x ) ) 
line 9961: # endif 
line 9966: SQLITE_PRIVATE int sqlite3StrICmp ( const char * , const char * ) ; 
line 9967: SQLITE_PRIVATE int sqlite3IsNumber ( const char * , int * , u8 ) ; 
line 9968: SQLITE_PRIVATE int sqlite3Strlen30 ( const char * ) ; 
line 9969: # define sqlite3StrNICmp sqlite3_strnicmp 
line 9971: SQLITE_PRIVATE int sqlite3MallocInit ( void ) ; 
line 9972: SQLITE_PRIVATE void sqlite3MallocEnd ( void ) ; 
line 9973: SQLITE_PRIVATE void * sqlite3Malloc ( int ) ; 
line 9974: SQLITE_PRIVATE void * sqlite3MallocZero ( int ) ; 
line 9975: SQLITE_PRIVATE void * sqlite3DbMallocZero ( sqlite3 * , int ) ; 
line 9976: SQLITE_PRIVATE void * sqlite3DbMallocRaw ( sqlite3 * , int ) ; 
line 9977: SQLITE_PRIVATE char * sqlite3DbStrDup ( sqlite3 * , const char * ) ; 
line 9978: SQLITE_PRIVATE char * sqlite3DbStrNDup ( sqlite3 * , const char * , int ) ; 
line 9979: SQLITE_PRIVATE void * sqlite3Realloc ( void * , int ) ; 
line 9980: SQLITE_PRIVATE void * sqlite3DbReallocOrFree ( sqlite3 * , void * , int ) ; 
line 9981: SQLITE_PRIVATE void * sqlite3DbRealloc ( sqlite3 * , void * , int ) ; 
line 9982: SQLITE_PRIVATE void sqlite3DbFree ( sqlite3 * , void * ) ; 
line 9983: SQLITE_PRIVATE int sqlite3MallocSize ( void * ) ; 
line 9984: SQLITE_PRIVATE int sqlite3DbMallocSize ( sqlite3 * , void * ) ; 
line 9985: SQLITE_PRIVATE void * sqlite3ScratchMalloc ( int ) ; 
line 9986: SQLITE_PRIVATE void sqlite3ScratchFree ( void * ) ; 
line 9987: SQLITE_PRIVATE void * sqlite3PageMalloc ( int ) ; 
line 9988: SQLITE_PRIVATE void sqlite3PageFree ( void * ) ; 
line 9989: SQLITE_PRIVATE void sqlite3MemSetDefault ( void ) ; 
line 9990: SQLITE_PRIVATE void sqlite3BenignMallocHooks ( void ( * ) ( void ) , void ( * ) ( void ) ) ; 
line 9991: SQLITE_PRIVATE int sqlite3MemoryAlarm ( void ( * ) ( void * , sqlite3_int64 , int ) , void * , sqlite3_int64 ) ; 
line 10001: # ifdef SQLITE_USE_ALLOCA 
line 10002: # define sqlite3StackAllocRaw ( D , N ) alloca ( N ) 
line 10003: # define sqlite3StackAllocZero ( D , N ) memset ( alloca ( N ) , 0 , N ) 
line 10004: # define sqlite3StackFree ( D , P ) 
line 10005: # else 
line 10006: # define sqlite3StackAllocRaw ( D , N ) sqlite3DbMallocRaw ( D , N ) 
line 10007: # define sqlite3StackAllocZero ( D , N ) sqlite3DbMallocZero ( D , N ) 
line 10008: # define sqlite3StackFree ( D , P ) sqlite3DbFree ( D , P ) 
line 10009: # endif 
line 10011: # ifdef SQLITE_ENABLE_MEMSYS3 
line 10012: SQLITE_PRIVATE const sqlite3_mem_methods * sqlite3MemGetMemsys3 ( void ) ; 
line 10013: # endif 
line 10014: # ifdef SQLITE_ENABLE_MEMSYS5 
line 10015: SQLITE_PRIVATE const sqlite3_mem_methods * sqlite3MemGetMemsys5 ( void ) ; 
line 10016: # endif 
line 10019: # ifndef SQLITE_MUTEX_OMIT 
line 10020: SQLITE_PRIVATE sqlite3_mutex_methods * sqlite3DefaultMutex ( void ) ; 
line 10021: SQLITE_PRIVATE sqlite3_mutex * sqlite3MutexAlloc ( int ) ; 
line 10022: SQLITE_PRIVATE int sqlite3MutexInit ( void ) ; 
line 10023: SQLITE_PRIVATE int sqlite3MutexEnd ( void ) ; 
line 10024: # endif 
line 10026: SQLITE_PRIVATE int sqlite3StatusValue ( int ) ; 
line 10027: SQLITE_PRIVATE void sqlite3StatusAdd ( int , int ) ; 
line 10028: SQLITE_PRIVATE void sqlite3StatusSet ( int , int ) ; 
line 10030: SQLITE_PRIVATE int sqlite3IsNaN ( double ) ; 
line 10032: SQLITE_PRIVATE void sqlite3VXPrintf ( StrAccum * , int , const char * , va_list ) ; 
line 10033: # ifndef SQLITE_OMIT_TRACE 
line 10034: SQLITE_PRIVATE void sqlite3XPrintf ( StrAccum * , const char * , ... ) ; 
line 10035: # endif 
line 10036: SQLITE_PRIVATE char * sqlite3MPrintf ( sqlite3 * , const char * , ... ) ; 
line 10037: SQLITE_PRIVATE char * sqlite3VMPrintf ( sqlite3 * , const char * , va_list ) ; 
line 10038: SQLITE_PRIVATE char * sqlite3MAppendf ( sqlite3 * , char * , const char * , ... ) ; 
line 10039: # if defined ( SQLITE_TEST ) || defined ( SQLITE_DEBUG ) 
line 10040: SQLITE_PRIVATE void sqlite3DebugPrintf ( const char * , ... ) ; 
line 10041: # endif 
line 10042: # if defined ( SQLITE_TEST ) 
line 10043: SQLITE_PRIVATE void * sqlite3TestTextToPtr ( const char * ) ; 
line 10044: # endif 
line 10045: SQLITE_PRIVATE void sqlite3SetString ( char * * , sqlite3 * , const char * , ... ) ; 
line 10046: SQLITE_PRIVATE void sqlite3ErrorMsg ( Parse * , const char * , ... ) ; 
line 10047: SQLITE_PRIVATE void sqlite3ErrorClear ( Parse * ) ; 
line 10048: SQLITE_PRIVATE int sqlite3Dequote ( char * ) ; 
line 10049: SQLITE_PRIVATE int sqlite3KeywordCode ( const unsigned char * , int ) ; 
line 10050: SQLITE_PRIVATE int sqlite3RunParser ( Parse * , const char * , char * * ) ; 
line 10051: SQLITE_PRIVATE void sqlite3FinishCoding ( Parse * ) ; 
line 10052: SQLITE_PRIVATE int sqlite3GetTempReg ( Parse * ) ; 
line 10053: SQLITE_PRIVATE void sqlite3ReleaseTempReg ( Parse * , int ) ; 
line 10054: SQLITE_PRIVATE int sqlite3GetTempRange ( Parse * , int ) ; 
line 10055: SQLITE_PRIVATE void sqlite3ReleaseTempRange ( Parse * , int , int ) ; 
line 10056: SQLITE_PRIVATE Expr * sqlite3ExprAlloc ( sqlite3 * , int , const Token * , int ) ; 
line 10057: SQLITE_PRIVATE Expr * sqlite3Expr ( sqlite3 * , int , const char * ) ; 
line 10058: SQLITE_PRIVATE void sqlite3ExprAttachSubtrees ( sqlite3 * , Expr * , Expr * , Expr * ) ; 
line 10059: SQLITE_PRIVATE Expr * sqlite3PExpr ( Parse * , int , Expr * , Expr * , const Token * ) ; 
line 10060: SQLITE_PRIVATE Expr * sqlite3ExprAnd ( sqlite3 * , Expr * , Expr * ) ; 
line 10061: SQLITE_PRIVATE Expr * sqlite3ExprFunction ( Parse * , ExprList * , Token * ) ; 
line 10062: SQLITE_PRIVATE void sqlite3ExprAssignVarNumber ( Parse * , Expr * ) ; 
line 10063: SQLITE_PRIVATE void sqlite3ExprDelete ( sqlite3 * , Expr * ) ; 
line 10064: SQLITE_PRIVATE ExprList * sqlite3ExprListAppend ( Parse * , ExprList * , Expr * ) ; 
line 10065: SQLITE_PRIVATE void sqlite3ExprListSetName ( Parse * , ExprList * , Token * , int ) ; 
line 10066: SQLITE_PRIVATE void sqlite3ExprListSetSpan ( Parse * , ExprList * , ExprSpan * ) ; 
line 10067: SQLITE_PRIVATE void sqlite3ExprListDelete ( sqlite3 * , ExprList * ) ; 
line 10068: SQLITE_PRIVATE int sqlite3Init ( sqlite3 * , char * * ) ; 
line 10069: SQLITE_PRIVATE int sqlite3InitCallback ( void * , int , char * * , char * * ) ; 
line 10070: SQLITE_PRIVATE void sqlite3Pragma ( Parse * , Token * , Token * , Token * , int ) ; 
line 10071: SQLITE_PRIVATE void sqlite3ResetInternalSchema ( sqlite3 * , int ) ; 
line 10072: SQLITE_PRIVATE void sqlite3BeginParse ( Parse * , int ) ; 
line 10073: SQLITE_PRIVATE void sqlite3CommitInternalChanges ( sqlite3 * ) ; 
line 10074: SQLITE_PRIVATE Table * sqlite3ResultSetOfSelect ( Parse * , Select * ) ; 
line 10075: SQLITE_PRIVATE void sqlite3OpenMasterTable ( Parse * , int ) ; 
line 10076: SQLITE_PRIVATE void sqlite3StartTable ( Parse * , Token * , Token * , int , int , int , int ) ; 
line 10077: SQLITE_PRIVATE void sqlite3AddColumn ( Parse * , Token * ) ; 
line 10078: SQLITE_PRIVATE void sqlite3AddNotNull ( Parse * , int ) ; 
line 10079: SQLITE_PRIVATE void sqlite3AddPrimaryKey ( Parse * , ExprList * , int , int , int ) ; 
line 10080: SQLITE_PRIVATE void sqlite3AddCheckConstraint ( Parse * , Expr * ) ; 
line 10081: SQLITE_PRIVATE void sqlite3AddColumnType ( Parse * , Token * ) ; 
line 10082: SQLITE_PRIVATE void sqlite3AddDefaultValue ( Parse * , ExprSpan * ) ; 
line 10083: SQLITE_PRIVATE void sqlite3AddCollateType ( Parse * , Token * ) ; 
line 10084: SQLITE_PRIVATE void sqlite3EndTable ( Parse * , Token * , Token * , Select * ) ; 
line 10086: SQLITE_PRIVATE Bitvec * sqlite3BitvecCreate ( u32 ) ; 
line 10087: SQLITE_PRIVATE int sqlite3BitvecTest ( Bitvec * , u32 ) ; 
line 10088: SQLITE_PRIVATE int sqlite3BitvecSet ( Bitvec * , u32 ) ; 
line 10089: SQLITE_PRIVATE void sqlite3BitvecClear ( Bitvec * , u32 , void * ) ; 
line 10090: SQLITE_PRIVATE void sqlite3BitvecDestroy ( Bitvec * ) ; 
line 10091: SQLITE_PRIVATE u32 sqlite3BitvecSize ( Bitvec * ) ; 
line 10092: SQLITE_PRIVATE int sqlite3BitvecBuiltinTest ( int , int * ) ; 
line 10094: SQLITE_PRIVATE RowSet * sqlite3RowSetInit ( sqlite3 * , void * , unsigned int ) ; 
line 10095: SQLITE_PRIVATE void sqlite3RowSetClear ( RowSet * ) ; 
line 10096: SQLITE_PRIVATE void sqlite3RowSetInsert ( RowSet * , i64 ) ; 
line 10097: SQLITE_PRIVATE int sqlite3RowSetTest ( RowSet * , u8 iBatch , i64 ) ; 
line 10098: SQLITE_PRIVATE int sqlite3RowSetNext ( RowSet * , i64 * ) ; 
line 10100: SQLITE_PRIVATE void sqlite3CreateView ( Parse * , Token * , Token * , Token * , Select * , int , int ) ; 
line 10102: # if ! defined ( SQLITE_OMIT_VIEW ) || ! defined ( SQLITE_OMIT_VIRTUALTABLE ) 
line 10103: SQLITE_PRIVATE int sqlite3ViewGetColumnNames ( Parse * , Table * ) ; 
line 10104: # else 
line 10105: # define sqlite3ViewGetColumnNames ( A , B ) 0 
line 10106: # endif 
line 10108: SQLITE_PRIVATE void sqlite3DropTable ( Parse * , SrcList * , int , int ) ; 
line 10109: SQLITE_PRIVATE void sqlite3DeleteTable ( Table * ) ; 
line 10110: # ifndef SQLITE_OMIT_AUTOINCREMENT 
line 10111: SQLITE_PRIVATE void sqlite3AutoincrementBegin ( Parse * pParse ) ; 
line 10112: SQLITE_PRIVATE void sqlite3AutoincrementEnd ( Parse * pParse ) ; 
line 10113: # else 
line 10114: # define sqlite3AutoincrementBegin ( X ) 
line 10115: # define sqlite3AutoincrementEnd ( X ) 
line 10116: # endif 
line 10117: SQLITE_PRIVATE void sqlite3Insert ( Parse * , SrcList * , ExprList * , Select * , IdList * , int ) ; 
line 10118: SQLITE_PRIVATE void * sqlite3ArrayAllocate ( sqlite3 * , void * , int , int , int * , int * , int * ) ; 
line 10119: SQLITE_PRIVATE IdList * sqlite3IdListAppend ( sqlite3 * , IdList * , Token * ) ; 
line 10120: SQLITE_PRIVATE int sqlite3IdListIndex ( IdList * , const char * ) ; 
line 10121: SQLITE_PRIVATE SrcList * sqlite3SrcListEnlarge ( sqlite3 * , SrcList * , int , int ) ; 
line 10122: SQLITE_PRIVATE SrcList * sqlite3SrcListAppend ( sqlite3 * , SrcList * , Token * , Token * ) ; 
line 10123: SQLITE_PRIVATE SrcList * sqlite3SrcListAppendFromTerm ( Parse * , SrcList * , Token * , Token * , 
line 10124: Token * , Select * , Expr * , IdList * ) ; 
line 10125: SQLITE_PRIVATE void sqlite3SrcListIndexedBy ( Parse * , SrcList * , Token * ) ; 
line 10126: SQLITE_PRIVATE int sqlite3IndexedByLookup ( Parse * , struct SrcList_item * ) ; 
line 10127: SQLITE_PRIVATE void sqlite3SrcListShiftJoinType ( SrcList * ) ; 
line 10128: SQLITE_PRIVATE void sqlite3SrcListAssignCursors ( Parse * , SrcList * ) ; 
line 10129: SQLITE_PRIVATE void sqlite3IdListDelete ( sqlite3 * , IdList * ) ; 
line 10130: SQLITE_PRIVATE void sqlite3SrcListDelete ( sqlite3 * , SrcList * ) ; 
line 10131: SQLITE_PRIVATE Index * sqlite3CreateIndex ( Parse * , Token * , Token * , SrcList * , ExprList * , int , Token * , 
line 10132: Token * , int , int ) ; 
line 10133: SQLITE_PRIVATE void sqlite3DropIndex ( Parse * , SrcList * , int ) ; 
line 10134: SQLITE_PRIVATE int sqlite3Select ( Parse * , Select * , SelectDest * ) ; 
line 10135: SQLITE_PRIVATE Select * sqlite3SelectNew ( Parse * , ExprList * , SrcList * , Expr * , ExprList * , 
line 10136: Expr * , ExprList * , int , Expr * , Expr * ) ; 
line 10137: SQLITE_PRIVATE void sqlite3SelectDelete ( sqlite3 * , Select * ) ; 
line 10138: SQLITE_PRIVATE Table * sqlite3SrcListLookup ( Parse * , SrcList * ) ; 
line 10139: SQLITE_PRIVATE int sqlite3IsReadOnly ( Parse * , Table * , int ) ; 
line 10140: SQLITE_PRIVATE void sqlite3OpenTable ( Parse * , int iCur , int iDb , Table * , int ) ; 
line 10141: # if defined ( SQLITE_ENABLE_UPDATE_DELETE_LIMIT ) && ! defined ( SQLITE_OMIT_SUBQUERY ) 
line 10142: SQLITE_PRIVATE Expr * sqlite3LimitWhere ( Parse * , SrcList * , Expr * , ExprList * , Expr * , Expr * , char * ) ; 
line 10143: # endif 
line 10144: SQLITE_PRIVATE void sqlite3DeleteFrom ( Parse * , SrcList * , Expr * ) ; 
line 10145: SQLITE_PRIVATE void sqlite3Update ( Parse * , SrcList * , ExprList * , Expr * , int ) ; 
line 10146: SQLITE_PRIVATE WhereInfo * sqlite3WhereBegin ( Parse * , SrcList * , Expr * , ExprList * * , u16 ) ; 
line 10147: SQLITE_PRIVATE void sqlite3WhereEnd ( WhereInfo * ) ; 
line 10148: SQLITE_PRIVATE int sqlite3ExprCodeGetColumn ( Parse * , Table * , int , int , int ) ; 
line 10149: SQLITE_PRIVATE void sqlite3ExprCodeMove ( Parse * , int , int , int ) ; 
line 10150: SQLITE_PRIVATE void sqlite3ExprCodeCopy ( Parse * , int , int , int ) ; 
line 10151: SQLITE_PRIVATE void sqlite3ExprCacheStore ( Parse * , int , int , int ) ; 
line 10152: SQLITE_PRIVATE void sqlite3ExprCachePush ( Parse * ) ; 
line 10153: SQLITE_PRIVATE void sqlite3ExprCachePop ( Parse * , int ) ; 
line 10154: SQLITE_PRIVATE void sqlite3ExprCacheRemove ( Parse * , int , int ) ; 
line 10155: SQLITE_PRIVATE void sqlite3ExprCacheClear ( Parse * ) ; 
line 10156: SQLITE_PRIVATE void sqlite3ExprCacheAffinityChange ( Parse * , int , int ) ; 
line 10157: SQLITE_PRIVATE void sqlite3ExprHardCopy ( Parse * , int , int ) ; 
line 10158: SQLITE_PRIVATE int sqlite3ExprCode ( Parse * , Expr * , int ) ; 
line 10159: SQLITE_PRIVATE int sqlite3ExprCodeTemp ( Parse * , Expr * , int * ) ; 
line 10160: SQLITE_PRIVATE int sqlite3ExprCodeTarget ( Parse * , Expr * , int ) ; 
line 10161: SQLITE_PRIVATE int sqlite3ExprCodeAndCache ( Parse * , Expr * , int ) ; 
line 10162: SQLITE_PRIVATE void sqlite3ExprCodeConstants ( Parse * , Expr * ) ; 
line 10163: SQLITE_PRIVATE int sqlite3ExprCodeExprList ( Parse * , ExprList * , int , int ) ; 
line 10164: SQLITE_PRIVATE void sqlite3ExprIfTrue ( Parse * , Expr * , int , int ) ; 
line 10165: SQLITE_PRIVATE void sqlite3ExprIfFalse ( Parse * , Expr * , int , int ) ; 
line 10166: SQLITE_PRIVATE Table * sqlite3FindTable ( sqlite3 * , const char * , const char * ) ; 
line 10167: SQLITE_PRIVATE Table * sqlite3LocateTable ( Parse * , int isView , const char * , const char * ) ; 
line 10168: SQLITE_PRIVATE Index * sqlite3FindIndex ( sqlite3 * , const char * , const char * ) ; 
line 10169: SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTable ( sqlite3 * , int , const char * ) ; 
line 10170: SQLITE_PRIVATE void sqlite3UnlinkAndDeleteIndex ( sqlite3 * , int , const char * ) ; 
line 10171: SQLITE_PRIVATE void sqlite3Vacuum ( Parse * ) ; 
line 10172: SQLITE_PRIVATE int sqlite3RunVacuum ( char * * , sqlite3 * ) ; 
line 10173: SQLITE_PRIVATE char * sqlite3NameFromToken ( sqlite3 * , Token * ) ; 
line 10174: SQLITE_PRIVATE int sqlite3ExprCompare ( Expr * , Expr * ) ; 
line 10175: SQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates ( NameContext * , Expr * ) ; 
line 10176: SQLITE_PRIVATE void sqlite3ExprAnalyzeAggList ( NameContext * , ExprList * ) ; 
line 10177: SQLITE_PRIVATE Vdbe * sqlite3GetVdbe ( Parse * ) ; 
line 10178: SQLITE_PRIVATE void sqlite3PrngSaveState ( void ) ; 
line 10179: SQLITE_PRIVATE void sqlite3PrngRestoreState ( void ) ; 
line 10180: SQLITE_PRIVATE void sqlite3PrngResetState ( void ) ; 
line 10181: SQLITE_PRIVATE void sqlite3RollbackAll ( sqlite3 * ) ; 
line 10182: SQLITE_PRIVATE void sqlite3CodeVerifySchema ( Parse * , int ) ; 
line 10183: SQLITE_PRIVATE void sqlite3BeginTransaction ( Parse * , int ) ; 
line 10184: SQLITE_PRIVATE void sqlite3CommitTransaction ( Parse * ) ; 
line 10185: SQLITE_PRIVATE void sqlite3RollbackTransaction ( Parse * ) ; 
line 10186: SQLITE_PRIVATE void sqlite3Savepoint ( Parse * , int , Token * ) ; 
line 10187: SQLITE_PRIVATE void sqlite3CloseSavepoints ( sqlite3 * ) ; 
line 10188: SQLITE_PRIVATE int sqlite3ExprIsConstant ( Expr * ) ; 
line 10189: SQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin ( Expr * ) ; 
line 10190: SQLITE_PRIVATE int sqlite3ExprIsConstantOrFunction ( Expr * ) ; 
line 10191: SQLITE_PRIVATE int sqlite3ExprIsInteger ( Expr * , int * ) ; 
line 10192: SQLITE_PRIVATE int sqlite3ExprCanBeNull ( const Expr * ) ; 
line 10193: SQLITE_PRIVATE void sqlite3ExprCodeIsNullJump ( Vdbe * , const Expr * , int , int ) ; 
line 10194: SQLITE_PRIVATE int sqlite3ExprNeedsNoAffinityChange ( const Expr * , char ) ; 
line 10195: SQLITE_PRIVATE int sqlite3IsRowid ( const char * ) ; 
line 10196: SQLITE_PRIVATE void sqlite3GenerateRowDelete ( Parse * , Table * , int , int , int , Trigger * , int ) ; 
line 10197: SQLITE_PRIVATE void sqlite3GenerateRowIndexDelete ( Parse * , Table * , int , int * ) ; 
line 10198: SQLITE_PRIVATE int sqlite3GenerateIndexKey ( Parse * , Index * , int , int , int ) ; 
line 10199: SQLITE_PRIVATE void sqlite3GenerateConstraintChecks ( Parse * , Table * , int , int , 
line 10200: int * , int , int , int , int , int * ) ; 
line 10201: SQLITE_PRIVATE void sqlite3CompleteInsertion ( Parse * , Table * , int , int , int * , int , int , int ) ; 
line 10202: SQLITE_PRIVATE int sqlite3OpenTableAndIndices ( Parse * , Table * , int , int ) ; 
line 10203: SQLITE_PRIVATE void sqlite3BeginWriteOperation ( Parse * , int , int ) ; 
line 10204: SQLITE_PRIVATE void sqlite3MultiWrite ( Parse * ) ; 
line 10205: SQLITE_PRIVATE void sqlite3MayAbort ( Parse * ) ; 
line 10206: SQLITE_PRIVATE void sqlite3HaltConstraint ( Parse * , int , char * , int ) ; 
line 10207: SQLITE_PRIVATE Expr * sqlite3ExprDup ( sqlite3 * , Expr * , int ) ; 
line 10208: SQLITE_PRIVATE ExprList * sqlite3ExprListDup ( sqlite3 * , ExprList * , int ) ; 
line 10209: SQLITE_PRIVATE SrcList * sqlite3SrcListDup ( sqlite3 * , SrcList * , int ) ; 
line 10210: SQLITE_PRIVATE IdList * sqlite3IdListDup ( sqlite3 * , IdList * ) ; 
line 10211: SQLITE_PRIVATE Select * sqlite3SelectDup ( sqlite3 * , Select * , int ) ; 
line 10212: SQLITE_PRIVATE void sqlite3FuncDefInsert ( FuncDefHash * , FuncDef * ) ; 
line 10213: SQLITE_PRIVATE FuncDef * sqlite3FindFunction ( sqlite3 * , const char * , int , int , u8 , int ) ; 
line 10214: SQLITE_PRIVATE void sqlite3RegisterBuiltinFunctions ( sqlite3 * ) ; 
line 10215: SQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions ( void ) ; 
line 10216: SQLITE_PRIVATE void sqlite3RegisterGlobalFunctions ( void ) ; 
line 10217: # ifdef SQLITE_DEBUG 
line 10218: SQLITE_PRIVATE int sqlite3SafetyOn ( sqlite3 * ) ; 
line 10219: SQLITE_PRIVATE int sqlite3SafetyOff ( sqlite3 * ) ; 
line 10220: # else 
line 10221: # define sqlite3SafetyOn ( A ) 0 
line 10222: # define sqlite3SafetyOff ( A ) 0 
line 10223: # endif 
line 10224: SQLITE_PRIVATE int sqlite3SafetyCheckOk ( sqlite3 * ) ; 
line 10225: SQLITE_PRIVATE int sqlite3SafetyCheckSickOrOk ( sqlite3 * ) ; 
line 10226: SQLITE_PRIVATE void sqlite3ChangeCookie ( Parse * , int ) ; 
line 10228: # if ! defined ( SQLITE_OMIT_VIEW ) && ! defined ( SQLITE_OMIT_TRIGGER ) 
line 10229: SQLITE_PRIVATE void sqlite3MaterializeView ( Parse * , Table * , Expr * , int ) ; 
line 10230: # endif 
line 10232: # ifndef SQLITE_OMIT_TRIGGER 
line 10233: SQLITE_PRIVATE void sqlite3BeginTrigger ( Parse * , Token * , Token * , int , int , IdList * , SrcList * , 
line 10234: Expr * , int , int ) ; 
line 10235: SQLITE_PRIVATE void sqlite3FinishTrigger ( Parse * , TriggerStep * , Token * ) ; 
line 10236: SQLITE_PRIVATE void sqlite3DropTrigger ( Parse * , SrcList * , int ) ; 
line 10237: SQLITE_PRIVATE void sqlite3DropTriggerPtr ( Parse * , Trigger * ) ; 
line 10238: SQLITE_PRIVATE Trigger * sqlite3TriggersExist ( Parse * , Table * , int , ExprList * , int * pMask ) ; 
line 10239: SQLITE_PRIVATE Trigger * sqlite3TriggerList ( Parse * , Table * ) ; 
line 10240: SQLITE_PRIVATE void sqlite3CodeRowTrigger ( Parse * , Trigger * , int , ExprList * , int , Table * , 
line 10241: int , int , int ) ; 
line 10242: SQLITE_PRIVATE void sqlite3CodeRowTriggerDirect ( Parse * , Trigger * , Table * , int , int , int ) ; 
line 10243: void sqliteViewTriggers ( Parse * , Table * , Expr * , int , ExprList * ) ; 
line 10244: SQLITE_PRIVATE void sqlite3DeleteTriggerStep ( sqlite3 * , TriggerStep * ) ; 
line 10245: SQLITE_PRIVATE TriggerStep * sqlite3TriggerSelectStep ( sqlite3 * , Select * ) ; 
line 10246: SQLITE_PRIVATE TriggerStep * sqlite3TriggerInsertStep ( sqlite3 * , Token * , IdList * , 
line 10247: ExprList * , Select * , u8 ) ; 
line 10248: SQLITE_PRIVATE TriggerStep * sqlite3TriggerUpdateStep ( sqlite3 * , Token * , ExprList * , Expr * , u8 ) ; 
line 10249: SQLITE_PRIVATE TriggerStep * sqlite3TriggerDeleteStep ( sqlite3 * , Token * , Expr * ) ; 
line 10250: SQLITE_PRIVATE void sqlite3DeleteTrigger ( sqlite3 * , Trigger * ) ; 
line 10251: SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTrigger ( sqlite3 * , int , const char * ) ; 
line 10252: SQLITE_PRIVATE u32 sqlite3TriggerColmask ( Parse * , Trigger * , ExprList * , int , int , Table * , int ) ; 
line 10253: # define sqlite3ParseToplevel ( p ) ( ( p ) -> pToplevel ? ( p ) -> pToplevel : ( p ) ) 
line 10254: # else 
line 10255: # define sqlite3TriggersExist ( B , C , D , E , F ) 0 
line 10256: # define sqlite3DeleteTrigger ( A , B ) 
line 10257: # define sqlite3DropTriggerPtr ( A , B ) 
line 10258: # define sqlite3UnlinkAndDeleteTrigger ( A , B , C ) 
line 10259: # define sqlite3CodeRowTrigger ( A , B , C , D , E , F , G , H , I ) 
line 10260: # define sqlite3CodeRowTriggerDirect ( A , B , C , D , E , F ) 
line 10261: # define sqlite3TriggerList ( X , Y ) 0 
line 10262: # define sqlite3ParseToplevel ( p ) p 
line 10263: # define sqlite3TriggerColmask ( A , B , C , D , E , F , G ) 0 
line 10264: # endif 
line 10266: SQLITE_PRIVATE int sqlite3JoinType ( Parse * , Token * , Token * , Token * ) ; 
line 10267: SQLITE_PRIVATE void sqlite3CreateForeignKey ( Parse * , ExprList * , Token * , ExprList * , int ) ; 
line 10268: SQLITE_PRIVATE void sqlite3DeferForeignKey ( Parse * , int ) ; 
line 10269: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 10270: SQLITE_PRIVATE void sqlite3AuthRead ( Parse * , Expr * , Schema * , SrcList * ) ; 
line 10271: SQLITE_PRIVATE int sqlite3AuthCheck ( Parse * , int , const char * , const char * , const char * ) ; 
line 10272: SQLITE_PRIVATE void sqlite3AuthContextPush ( Parse * , AuthContext * , const char * ) ; 
line 10273: SQLITE_PRIVATE void sqlite3AuthContextPop ( AuthContext * ) ; 
line 10274: SQLITE_PRIVATE int sqlite3AuthReadCol ( Parse * , const char * , const char * , int ) ; 
line 10275: # else 
line 10276: # define sqlite3AuthRead ( a , b , c , d ) 
line 10277: # define sqlite3AuthCheck ( a , b , c , d , e ) SQLITE_OK 
line 10278: # define sqlite3AuthContextPush ( a , b , c ) 
line 10279: # define sqlite3AuthContextPop ( a ) ( ( void ) ( a ) ) 
line 10280: # endif 
line 10281: SQLITE_PRIVATE void sqlite3Attach ( Parse * , Expr * , Expr * , Expr * ) ; 
line 10282: SQLITE_PRIVATE void sqlite3Detach ( Parse * , Expr * ) ; 
line 10283: SQLITE_PRIVATE int sqlite3BtreeFactory ( sqlite3 * db , const char * zFilename , 
line 10284: int omitJournal , int nCache , int flags , Btree * * ppBtree ) ; 
line 10285: SQLITE_PRIVATE int sqlite3FixInit ( DbFixer * , Parse * , int , const char * , const Token * ) ; 
line 10286: SQLITE_PRIVATE int sqlite3FixSrcList ( DbFixer * , SrcList * ) ; 
line 10287: SQLITE_PRIVATE int sqlite3FixSelect ( DbFixer * , Select * ) ; 
line 10288: SQLITE_PRIVATE int sqlite3FixExpr ( DbFixer * , Expr * ) ; 
line 10289: SQLITE_PRIVATE int sqlite3FixExprList ( DbFixer * , ExprList * ) ; 
line 10290: SQLITE_PRIVATE int sqlite3FixTriggerStep ( DbFixer * , TriggerStep * ) ; 
line 10291: SQLITE_PRIVATE int sqlite3AtoF ( const char * z , double * ) ; 
line 10292: SQLITE_PRIVATE int sqlite3GetInt32 ( const char * , int * ) ; 
line 10293: SQLITE_PRIVATE int sqlite3FitsIn64Bits ( const char * , int ) ; 
line 10294: SQLITE_PRIVATE int sqlite3Utf16ByteLen ( const void * pData , int nChar ) ; 
line 10295: SQLITE_PRIVATE int sqlite3Utf8CharLen ( const char * pData , int nByte ) ; 
line 10296: SQLITE_PRIVATE int sqlite3Utf8Read ( const u8 * , const u8 * * ) ; 
line 10305: SQLITE_PRIVATE int sqlite3PutVarint ( unsigned char * , u64 ) ; 
line 10306: SQLITE_PRIVATE int sqlite3PutVarint32 ( unsigned char * , u32 ) ; 
line 10307: SQLITE_PRIVATE u8 sqlite3GetVarint ( const unsigned char * , u64 * ) ; 
line 10308: SQLITE_PRIVATE u8 sqlite3GetVarint32 ( const unsigned char * , u32 * ) ; 
line 10309: SQLITE_PRIVATE int sqlite3VarintLen ( u64 v ) ; 
line 10328: # define getVarint32 ( A , B ) ( u8 ) ( ( * ( A ) < ( u8 ) 0x80 ) ? ( ( B ) = ( u32 ) * ( A ) ) , 1 : sqlite3GetVarint32 ( ( A ) , ( u32 * ) & ( B ) ) ) 
line 10329: # define putVarint32 ( A , B ) ( u8 ) ( ( ( u32 ) ( B ) < ( u32 ) 0x80 ) ? ( * ( A ) = ( unsigned char ) ( B ) ) , 1 : sqlite3PutVarint32 ( ( A ) , ( B ) ) ) 
line 10330: # define getVarint sqlite3GetVarint 
line 10331: # define putVarint sqlite3PutVarint 
line 10334: SQLITE_PRIVATE const char * sqlite3IndexAffinityStr ( Vdbe * , Index * ) ; 
line 10335: SQLITE_PRIVATE void sqlite3TableAffinityStr ( Vdbe * , Table * ) ; 
line 10336: SQLITE_PRIVATE char sqlite3CompareAffinity ( Expr * pExpr , char aff2 ) ; 
line 10337: SQLITE_PRIVATE int sqlite3IndexAffinityOk ( Expr * pExpr , char idx_affinity ) ; 
line 10338: SQLITE_PRIVATE char sqlite3ExprAffinity ( Expr * pExpr ) ; 
line 10339: SQLITE_PRIVATE int sqlite3Atoi64 ( const char * , i64 * ) ; 
line 10340: SQLITE_PRIVATE void sqlite3Error ( sqlite3 * , int , const char * , ... ) ; 
line 10341: SQLITE_PRIVATE void * sqlite3HexToBlob ( sqlite3 * , const char * z , int n ) ; 
line 10342: SQLITE_PRIVATE int sqlite3TwoPartName ( Parse * , Token * , Token * , Token * * ) ; 
line 10343: SQLITE_PRIVATE const char * sqlite3ErrStr ( int ) ; 
line 10344: SQLITE_PRIVATE int sqlite3ReadSchema ( Parse * pParse ) ; 
line 10345: SQLITE_PRIVATE CollSeq * sqlite3FindCollSeq ( sqlite3 * , u8 enc , const char * , int ) ; 
line 10346: SQLITE_PRIVATE CollSeq * sqlite3LocateCollSeq ( Parse * pParse , const char * zName ) ; 
line 10347: SQLITE_PRIVATE CollSeq * sqlite3ExprCollSeq ( Parse * pParse , Expr * pExpr ) ; 
line 10348: SQLITE_PRIVATE Expr * sqlite3ExprSetColl ( Parse * pParse , Expr * , Token * ) ; 
line 10349: SQLITE_PRIVATE int sqlite3CheckCollSeq ( Parse * , CollSeq * ) ; 
line 10350: SQLITE_PRIVATE int sqlite3CheckObjectName ( Parse * , const char * ) ; 
line 10351: SQLITE_PRIVATE void sqlite3VdbeSetChanges ( sqlite3 * , int ) ; 
line 10353: SQLITE_PRIVATE const void * sqlite3ValueText ( sqlite3_value * , u8 ) ; 
line 10354: SQLITE_PRIVATE int sqlite3ValueBytes ( sqlite3_value * , u8 ) ; 
line 10355: SQLITE_PRIVATE void sqlite3ValueSetStr ( sqlite3_value * , int , const void * , u8 , 
line 10356: void ( * ) ( void * ) ) ; 
line 10357: SQLITE_PRIVATE void sqlite3ValueFree ( sqlite3_value * ) ; 
line 10358: SQLITE_PRIVATE sqlite3_value * sqlite3ValueNew ( sqlite3 * ) ; 
line 10359: SQLITE_PRIVATE char * sqlite3Utf16to8 ( sqlite3 * , const void * , int ) ; 
line 10360: # ifdef SQLITE_ENABLE_STAT2 
line 10361: SQLITE_PRIVATE char * sqlite3Utf8to16 ( sqlite3 * , u8 , char * , int , int * ) ; 
line 10362: # endif 
line 10363: SQLITE_PRIVATE int sqlite3ValueFromExpr ( sqlite3 * , Expr * , u8 , u8 , sqlite3_value * * ) ; 
line 10364: SQLITE_PRIVATE void sqlite3ValueApplyAffinity ( sqlite3_value * , u8 , u8 ) ; 
line 10365: # ifndef SQLITE_AMALGAMATION 
line 10366: SQLITE_PRIVATE const unsigned char sqlite3OpcodeProperty [ ] ; 
line 10367: SQLITE_PRIVATE const unsigned char sqlite3UpperToLower [ ] ; 
line 10368: SQLITE_PRIVATE const unsigned char sqlite3CtypeMap [ ] ; 
line 10369: SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config ; 
line 10370: SQLITE_PRIVATE SQLITE_WSD FuncDefHash sqlite3GlobalFunctions ; 
line 10371: SQLITE_PRIVATE int sqlite3PendingByte ; 
line 10372: # endif 
line 10373: SQLITE_PRIVATE void sqlite3RootPageMoved ( Db * , int , int ) ; 
line 10374: SQLITE_PRIVATE void sqlite3Reindex ( Parse * , Token * , Token * ) ; 
line 10375: SQLITE_PRIVATE void sqlite3AlterFunctions ( sqlite3 * ) ; 
line 10376: SQLITE_PRIVATE void sqlite3AlterRenameTable ( Parse * , SrcList * , Token * ) ; 
line 10377: SQLITE_PRIVATE int sqlite3GetToken ( const unsigned char * , int * ) ; 
line 10378: SQLITE_PRIVATE void sqlite3NestedParse ( Parse * , const char * , ... ) ; 
line 10379: SQLITE_PRIVATE void sqlite3ExpirePreparedStatements ( sqlite3 * ) ; 
line 10380: SQLITE_PRIVATE int sqlite3CodeSubselect ( Parse * , Expr * , int , int ) ; 
line 10381: SQLITE_PRIVATE void sqlite3SelectPrep ( Parse * , Select * , NameContext * ) ; 
line 10382: SQLITE_PRIVATE int sqlite3ResolveExprNames ( NameContext * , Expr * ) ; 
line 10383: SQLITE_PRIVATE void sqlite3ResolveSelectNames ( Parse * , Select * , NameContext * ) ; 
line 10384: SQLITE_PRIVATE int sqlite3ResolveOrderGroupBy ( Parse * , Select * , ExprList * , const char * ) ; 
line 10385: SQLITE_PRIVATE void sqlite3ColumnDefault ( Vdbe * , Table * , int , int ) ; 
line 10386: SQLITE_PRIVATE void sqlite3AlterFinishAddColumn ( Parse * , Token * ) ; 
line 10387: SQLITE_PRIVATE void sqlite3AlterBeginAddColumn ( Parse * , SrcList * ) ; 
line 10388: SQLITE_PRIVATE CollSeq * sqlite3GetCollSeq ( sqlite3 * , u8 , CollSeq * , const char * ) ; 
line 10389: SQLITE_PRIVATE char sqlite3AffinityType ( const char * ) ; 
line 10390: SQLITE_PRIVATE void sqlite3Analyze ( Parse * , Token * , Token * ) ; 
line 10391: SQLITE_PRIVATE int sqlite3InvokeBusyHandler ( BusyHandler * ) ; 
line 10392: SQLITE_PRIVATE int sqlite3FindDb ( sqlite3 * , Token * ) ; 
line 10393: SQLITE_PRIVATE int sqlite3FindDbName ( sqlite3 * , const char * ) ; 
line 10394: SQLITE_PRIVATE int sqlite3AnalysisLoad ( sqlite3 * , int iDB ) ; 
line 10395: SQLITE_PRIVATE void sqlite3DeleteIndexSamples ( Index * ) ; 
line 10396: SQLITE_PRIVATE void sqlite3DefaultRowEst ( Index * ) ; 
line 10397: SQLITE_PRIVATE void sqlite3RegisterLikeFunctions ( sqlite3 * , int ) ; 
line 10398: SQLITE_PRIVATE int sqlite3IsLikeFunction ( sqlite3 * , Expr * , int * , char * ) ; 
line 10399: SQLITE_PRIVATE void sqlite3MinimumFileFormat ( Parse * , int , int ) ; 
line 10400: SQLITE_PRIVATE void sqlite3SchemaFree ( void * ) ; 
line 10401: SQLITE_PRIVATE Schema * sqlite3SchemaGet ( sqlite3 * , Btree * ) ; 
line 10402: SQLITE_PRIVATE int sqlite3SchemaToIndex ( sqlite3 * db , Schema * ) ; 
line 10403: SQLITE_PRIVATE KeyInfo * sqlite3IndexKeyinfo ( Parse * , Index * ) ; 
line 10404: SQLITE_PRIVATE int sqlite3CreateFunc ( sqlite3 * , const char * , int , int , void * , 
line 10405: void ( * ) ( sqlite3_context * , int , sqlite3_value * * ) , 
line 10406: void ( * ) ( sqlite3_context * , int , sqlite3_value * * ) , void ( * ) ( sqlite3_context * ) ) ; 
line 10407: SQLITE_PRIVATE int sqlite3ApiExit ( sqlite3 * db , int ) ; 
line 10408: SQLITE_PRIVATE int sqlite3OpenTempDatabase ( Parse * ) ; 
line 10410: SQLITE_PRIVATE void sqlite3StrAccumInit ( StrAccum * , char * , int , int ) ; 
line 10411: SQLITE_PRIVATE void sqlite3StrAccumAppend ( StrAccum * , const char * , int ) ; 
line 10412: SQLITE_PRIVATE char * sqlite3StrAccumFinish ( StrAccum * ) ; 
line 10413: SQLITE_PRIVATE void sqlite3StrAccumReset ( StrAccum * ) ; 
line 10414: SQLITE_PRIVATE void sqlite3SelectDestInit ( SelectDest * , int , int ) ; 
line 10415: SQLITE_PRIVATE Expr * sqlite3CreateColumnExpr ( sqlite3 * , SrcList * , int , int ) ; 
line 10417: SQLITE_PRIVATE void sqlite3BackupRestart ( sqlite3_backup * ) ; 
line 10418: SQLITE_PRIVATE void sqlite3BackupUpdate ( sqlite3_backup * , Pgno , const u8 * ) ; 
line 10423: SQLITE_PRIVATE void * sqlite3ParserAlloc ( void * ( * ) ( size_t ) ) ; 
line 10424: SQLITE_PRIVATE void sqlite3ParserFree ( void * , void ( * ) ( void * ) ) ; 
line 10425: SQLITE_PRIVATE void sqlite3Parser ( void * , int , Token , Parse * ) ; 
line 10426: # ifdef YYTRACKMAXSTACKDEPTH 
line 10427: SQLITE_PRIVATE int sqlite3ParserStackPeak ( void * ) ; 
line 10428: # endif 
line 10430: SQLITE_PRIVATE void sqlite3AutoLoadExtensions ( sqlite3 * ) ; 
line 10431: # ifndef SQLITE_OMIT_LOAD_EXTENSION 
line 10432: SQLITE_PRIVATE void sqlite3CloseExtensions ( sqlite3 * ) ; 
line 10433: # else 
line 10434: # define sqlite3CloseExtensions ( X ) 
line 10435: # endif 
line 10437: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 10438: SQLITE_PRIVATE void sqlite3TableLock ( Parse * , int , int , u8 , const char * ) ; 
line 10439: # else 
line 10440: # define sqlite3TableLock ( v , w , x , y , z ) 
line 10441: # endif 
line 10443: # ifdef SQLITE_TEST 
line 10444: SQLITE_PRIVATE int sqlite3Utf8To8 ( unsigned char * ) ; 
line 10445: # endif 
line 10447: # ifdef SQLITE_OMIT_VIRTUALTABLE 
line 10448: # define sqlite3VtabClear ( Y ) 
line 10449: # define sqlite3VtabSync ( X , Y ) SQLITE_OK 
line 10450: # define sqlite3VtabRollback ( X ) 
line 10451: # define sqlite3VtabCommit ( X ) 
line 10452: # define sqlite3VtabInSync ( db ) 0 
line 10453: # define sqlite3VtabLock ( X ) 
line 10454: # define sqlite3VtabUnlock ( X ) 
line 10455: # define sqlite3VtabUnlockList ( X ) 
line 10456: # else 
line 10457: SQLITE_PRIVATE void sqlite3VtabClear ( Table * ) ; 
line 10458: SQLITE_PRIVATE int sqlite3VtabSync ( sqlite3 * db , char * * ) ; 
line 10459: SQLITE_PRIVATE int sqlite3VtabRollback ( sqlite3 * db ) ; 
line 10460: SQLITE_PRIVATE int sqlite3VtabCommit ( sqlite3 * db ) ; 
line 10461: SQLITE_PRIVATE void sqlite3VtabLock ( VTable * ) ; 
line 10462: SQLITE_PRIVATE void sqlite3VtabUnlock ( VTable * ) ; 
line 10463: SQLITE_PRIVATE void sqlite3VtabUnlockList ( sqlite3 * ) ; 
line 10464: # define sqlite3VtabInSync ( db ) ( ( db ) -> nVTrans > 0 && ( db ) -> aVTrans == 0 ) 
line 10465: # endif 
line 10466: SQLITE_PRIVATE void sqlite3VtabMakeWritable ( Parse * , Table * ) ; 
line 10467: SQLITE_PRIVATE void sqlite3VtabBeginParse ( Parse * , Token * , Token * , Token * ) ; 
line 10468: SQLITE_PRIVATE void sqlite3VtabFinishParse ( Parse * , Token * ) ; 
line 10469: SQLITE_PRIVATE void sqlite3VtabArgInit ( Parse * ) ; 
line 10470: SQLITE_PRIVATE void sqlite3VtabArgExtend ( Parse * , Token * ) ; 
line 10471: SQLITE_PRIVATE int sqlite3VtabCallCreate ( sqlite3 * , int , const char * , char * * ) ; 
line 10472: SQLITE_PRIVATE int sqlite3VtabCallConnect ( Parse * , Table * ) ; 
line 10473: SQLITE_PRIVATE int sqlite3VtabCallDestroy ( sqlite3 * , int , const char * ) ; 
line 10474: SQLITE_PRIVATE int sqlite3VtabBegin ( sqlite3 * , VTable * ) ; 
line 10475: SQLITE_PRIVATE FuncDef * sqlite3VtabOverloadFunction ( sqlite3 * , FuncDef * , int nArg , Expr * ) ; 
line 10476: SQLITE_PRIVATE void sqlite3InvalidFunction ( sqlite3_context * , int , sqlite3_value * * ) ; 
line 10477: SQLITE_PRIVATE int sqlite3VdbeParameterIndex ( Vdbe * , const char * , int ) ; 
line 10478: SQLITE_PRIVATE int sqlite3TransferBindings ( sqlite3_stmt * , sqlite3_stmt * ) ; 
line 10479: SQLITE_PRIVATE int sqlite3Reprepare ( Vdbe * ) ; 
line 10480: SQLITE_PRIVATE void sqlite3ExprListCheckLength ( Parse * , ExprList * , const char * ) ; 
line 10481: SQLITE_PRIVATE CollSeq * sqlite3BinaryCompareCollSeq ( Parse * , Expr * , Expr * ) ; 
line 10482: SQLITE_PRIVATE int sqlite3TempInMemory ( const sqlite3 * ) ; 
line 10483: SQLITE_PRIVATE VTable * sqlite3GetVTable ( sqlite3 * , Table * ) ; 
line 10492: # if ! defined ( SQLITE_OMIT_FOREIGN_KEY ) && ! defined ( SQLITE_OMIT_TRIGGER ) 
line 10493: SQLITE_PRIVATE void sqlite3FkCheck ( Parse * , Table * , int , int ) ; 
line 10494: SQLITE_PRIVATE void sqlite3FkDropTable ( Parse * , SrcList * , Table * ) ; 
line 10495: SQLITE_PRIVATE void sqlite3FkActions ( Parse * , Table * , ExprList * , int ) ; 
line 10496: SQLITE_PRIVATE int sqlite3FkRequired ( Parse * , Table * , int * , int ) ; 
line 10497: SQLITE_PRIVATE u32 sqlite3FkOldmask ( Parse * , Table * ) ; 
line 10498: SQLITE_PRIVATE FKey * sqlite3FkReferences ( Table * ) ; 
line 10499: # else 
line 10500: # define sqlite3FkActions ( a , b , c , d ) 
line 10501: # define sqlite3FkCheck ( a , b , c , d ) 
line 10502: # define sqlite3FkDropTable ( a , b , c ) 
line 10503: # define sqlite3FkOldmask ( a , b ) 0 
line 10504: # define sqlite3FkRequired ( a , b , c , d ) 0 
line 10505: # endif 
line 10506: # ifndef SQLITE_OMIT_FOREIGN_KEY 
line 10507: SQLITE_PRIVATE void sqlite3FkDelete ( Table * ) ; 
line 10508: # else 
line 10509: # define sqlite3FkDelete ( a ) 
line 10510: # endif 
line 10516: # define SQLITE_FAULTINJECTOR_MALLOC 0 
line 10517: # define SQLITE_FAULTINJECTOR_COUNT 1 
line 10524: # ifndef SQLITE_OMIT_BUILTIN_TEST 
line 10525: SQLITE_PRIVATE void sqlite3BeginBenignMalloc ( void ) ; 
line 10526: SQLITE_PRIVATE void sqlite3EndBenignMalloc ( void ) ; 
line 10527: # else 
line 10528: # define sqlite3BeginBenignMalloc ( ) 
line 10529: # define sqlite3EndBenignMalloc ( ) 
line 10530: # endif 
line 10532: # define IN_INDEX_ROWID 1 
line 10533: # define IN_INDEX_EPH 2 
line 10534: # define IN_INDEX_INDEX 3 
line 10535: SQLITE_PRIVATE int sqlite3FindInIndex ( Parse * , Expr * , int * ) ; 
line 10537: # ifdef SQLITE_ENABLE_ATOMIC_WRITE 
line 10538: SQLITE_PRIVATE int sqlite3JournalOpen ( sqlite3_vfs * , const char * , sqlite3_file * , int , int ) ; 
line 10539: SQLITE_PRIVATE int sqlite3JournalSize ( sqlite3_vfs * ) ; 
line 10540: SQLITE_PRIVATE int sqlite3JournalCreate ( sqlite3_file * ) ; 
line 10541: # else 
line 10542: # define sqlite3JournalSize ( pVfs ) ( ( pVfs ) -> szOsFile ) 
line 10543: # endif 
line 10545: SQLITE_PRIVATE void sqlite3MemJournalOpen ( sqlite3_file * ) ; 
line 10546: SQLITE_PRIVATE int sqlite3MemJournalSize ( void ) ; 
line 10547: SQLITE_PRIVATE int sqlite3IsMemJournal ( sqlite3_file * ) ; 
line 10549: # if SQLITE_MAX_EXPR_DEPTH > 0 
line 10550: SQLITE_PRIVATE void sqlite3ExprSetHeight ( Parse * pParse , Expr * p ) ; 
line 10551: SQLITE_PRIVATE int sqlite3SelectExprHeight ( Select * ) ; 
line 10552: SQLITE_PRIVATE int sqlite3ExprCheckHeight ( Parse * , int ) ; 
line 10553: # else 
line 10554: # define sqlite3ExprSetHeight ( x , y ) 
line 10555: # define sqlite3SelectExprHeight ( x ) 0 
line 10556: # define sqlite3ExprCheckHeight ( x , y ) 
line 10557: # endif 
line 10559: SQLITE_PRIVATE u32 sqlite3Get4byte ( const u8 * ) ; 
line 10560: SQLITE_PRIVATE void sqlite3Put4byte ( u8 * , u32 ) ; 
line 10562: # ifdef SQLITE_ENABLE_UNLOCK_NOTIFY 
line 10563: SQLITE_PRIVATE void sqlite3ConnectionBlocked ( sqlite3 * , sqlite3 * ) ; 
line 10564: SQLITE_PRIVATE void sqlite3ConnectionUnlocked ( sqlite3 * db ) ; 
line 10565: SQLITE_PRIVATE void sqlite3ConnectionClosed ( sqlite3 * db ) ; 
line 10566: # else 
line 10567: # define sqlite3ConnectionBlocked ( x , y ) 
line 10568: # define sqlite3ConnectionUnlocked ( x ) 
line 10569: # define sqlite3ConnectionClosed ( x ) 
line 10570: # endif 
line 10572: # ifdef SQLITE_DEBUG 
line 10573: SQLITE_PRIVATE void sqlite3ParserTrace ( FILE * , char * ) ; 
line 10574: # endif 
line 10581: # ifdef SQLITE_ENABLE_IOTRACE 
line 10582: # define IOTRACE ( A ) if ( sqlite3IoTrace ) { sqlite3IoTrace A ; } 
line 10583: SQLITE_PRIVATE void sqlite3VdbeIOTraceSql ( Vdbe * ) ; 
line 10584: SQLITE_PRIVATE void ( * sqlite3IoTrace ) ( const char * , ... ) ; 
line 10585: # else 
line 10586: # define IOTRACE ( A ) 
line 10587: # define sqlite3VdbeIOTraceSql ( X ) 
line 10588: # endif 
line 10590: # endif 
line 10616: SQLITE_PRIVATE const unsigned char sqlite3UpperToLower [ ] = { 
line 10617: # ifdef SQLITE_ASCII 
line 10618: 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 
line 10619: 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 
line 10620: 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 
line 10621: 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 
line 10622: 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 
line 10623: 122 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 
line 10624: 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 123 , 124 , 125 , 
line 10625: 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 136 , 137 , 138 , 139 , 140 , 141 , 142 , 143 , 
line 10626: 144 , 145 , 146 , 147 , 148 , 149 , 150 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 158 , 159 , 160 , 161 , 
line 10627: 162 , 163 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , 175 , 176 , 177 , 178 , 179 , 
line 10628: 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , 188 , 189 , 190 , 191 , 192 , 193 , 194 , 195 , 196 , 197 , 
line 10629: 198 , 199 , 200 , 201 , 202 , 203 , 204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , 214 , 215 , 
line 10630: 216 , 217 , 218 , 219 , 220 , 221 , 222 , 223 , 224 , 225 , 226 , 227 , 228 , 229 , 230 , 231 , 232 , 233 , 
line 10631: 234 , 235 , 236 , 237 , 238 , 239 , 240 , 241 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 , 
line 10632: 252 , 253 , 254 , 255 
line 10633: # endif 
line 10634: # ifdef SQLITE_EBCDIC 
line 10635: 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 
line 10636: 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 
line 10637: 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 
line 10638: 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 
line 10639: 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 
line 10640: 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 
line 10641: 96 , 97 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 106 , 107 , 108 , 109 , 110 , 111 , 
line 10642: 112 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 122 , 123 , 124 , 125 , 126 , 127 , 
line 10643: 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 136 , 137 , 138 , 139 , 140 , 141 , 142 , 143 , 
line 10644: 144 , 145 , 146 , 147 , 148 , 149 , 150 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 156 , 159 , 
line 10645: 160 , 161 , 162 , 163 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 140 , 141 , 142 , 175 , 
line 10646: 176 , 177 , 178 , 179 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , 188 , 189 , 190 , 191 , 
line 10647: 192 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 136 , 137 , 202 , 203 , 204 , 205 , 206 , 207 , 
line 10648: 208 , 145 , 146 , 147 , 148 , 149 , 150 , 151 , 152 , 153 , 218 , 219 , 220 , 221 , 222 , 223 , 
line 10649: 224 , 225 , 162 , 163 , 164 , 165 , 166 , 167 , 168 , 169 , 232 , 203 , 204 , 205 , 206 , 207 , 
line 10650: 239 , 240 , 241 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 219 , 220 , 221 , 222 , 255 , 
line 10651: # endif 
line 10652: } ; 
line 10684: # ifdef SQLITE_ASCII 
line 10685: SQLITE_PRIVATE const unsigned char sqlite3CtypeMap [ 256 ] = { 
line 10686: 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 
line 10687: 0x00 , 0x01 , 0x01 , 0x01 , 0x01 , 0x01 , 0x00 , 0x00 , 
line 10688: 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 
line 10689: 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 
line 10690: 0x01 , 0x00 , 0x00 , 0x00 , 0x40 , 0x00 , 0x00 , 0x00 , 
line 10691: 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 
line 10692: 0x0c , 0x0c , 0x0c , 0x0c , 0x0c , 0x0c , 0x0c , 0x0c , 
line 10693: 0x0c , 0x0c , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 
line 10695: 0x00 , 0x0a , 0x0a , 0x0a , 0x0a , 0x0a , 0x0a , 0x02 , 
line 10696: 0x02 , 0x02 , 0x02 , 0x02 , 0x02 , 0x02 , 0x02 , 0x02 , 
line 10697: 0x02 , 0x02 , 0x02 , 0x02 , 0x02 , 0x02 , 0x02 , 0x02 , 
line 10698: 0x02 , 0x02 , 0x02 , 0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 
line 10699: 0x00 , 0x2a , 0x2a , 0x2a , 0x2a , 0x2a , 0x2a , 0x22 , 
line 10700: 0x22 , 0x22 , 0x22 , 0x22 , 0x22 , 0x22 , 0x22 , 0x22 , 
line 10701: 0x22 , 0x22 , 0x22 , 0x22 , 0x22 , 0x22 , 0x22 , 0x22 , 
line 10702: 0x22 , 0x22 , 0x22 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 
line 10704: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 
line 10705: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 
line 10706: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 
line 10707: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 
line 10708: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 
line 10709: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 
line 10710: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 
line 10711: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 
line 10713: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 
line 10714: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 
line 10715: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 
line 10716: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 
line 10717: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 
line 10718: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 
line 10719: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 
line 10720: 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x40 
line 10721: } ; 
line 10722: # endif 
line 10730: SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config = { 
line 10731: SQLITE_DEFAULT_MEMSTATUS , 
line 10732: 1 , 
line 10733: SQLITE_THREADSAFE == 1 , 
line 10734: 0x7ffffffe , 
line 10735: 100 , 
line 10736: 500 , 
line 10737: { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , 
line 10738: { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , 
line 10739: { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , 
line 10740: ( void * ) 0 , 
line 10741: 0 , 
line 10742: 0 , 0 , 
line 10743: ( void * ) 0 , 
line 10744: 0 , 
line 10745: 0 , 
line 10746: ( void * ) 0 , 
line 10747: 0 , 
line 10748: 0 , 
line 10749: 0 , 
line 10750: 0 , 
line 10752: 0 , 
line 10753: 0 , 
line 10754: 0 , 
line 10755: 0 , 
line 10756: 0 , 
line 10757: 0 , 
line 10758: 0 , 
line 10759: } ; 
line 10767: SQLITE_PRIVATE SQLITE_WSD FuncDefHash sqlite3GlobalFunctions ; 
line 10787: SQLITE_PRIVATE int sqlite3PendingByte = 0x40000000 ; 
line 10795: SQLITE_PRIVATE const unsigned char sqlite3OpcodeProperty [ ] = OPFLG_INITIALIZER ; 
line 10818: typedef struct sqlite3StatType sqlite3StatType ; 
line 10819: static SQLITE_WSD struct sqlite3StatType { 
line 10820: int nowValue [ 9 ] ; 
line 10821: int mxValue [ 9 ] ; 
line 10822: } sqlite3Stat = { { 0 , } , { 0 , } } ; 
line 10831: # ifdef SQLITE_OMIT_WSD 
line 10832: # define wsdStatInit sqlite3StatType * x = & GLOBAL ( sqlite3StatType , sqlite3Stat ) 
line 10833: # define wsdStat x [ 0 ] 
line 10834: # else 
line 10835: # define wsdStatInit 
line 10836: # define wsdStat sqlite3Stat 
line 10837: # endif 
line 10842: SQLITE_PRIVATE int sqlite3StatusValue ( int op ) { 
line 10843: wsdStatInit ; 
line 10844: assert ( op >= 0 && op < ArraySize ( wsdStat . nowValue ) ) ; 
line 10845: return wsdStat . nowValue [ op ] ; 
line 10846: } 
line 10852: SQLITE_PRIVATE void sqlite3StatusAdd ( int op , int N ) { 
line 10853: wsdStatInit ; 
line 10854: assert ( op >= 0 && op < ArraySize ( wsdStat . nowValue ) ) ; 
line 10855: wsdStat . nowValue [ op ] += N ; 
line 10856: if ( wsdStat . nowValue [ op ] > wsdStat . mxValue [ op ] ) { 
line 10857: wsdStat . mxValue [ op ] = wsdStat . nowValue [ op ] ; 
line 10858: } 
line 10859: } 
line 10864: SQLITE_PRIVATE void sqlite3StatusSet ( int op , int X ) { 
line 10865: wsdStatInit ; 
line 10866: assert ( op >= 0 && op < ArraySize ( wsdStat . nowValue ) ) ; 
line 10867: wsdStat . nowValue [ op ] = X ; 
line 10868: if ( wsdStat . nowValue [ op ] > wsdStat . mxValue [ op ] ) { 
line 10869: wsdStat . mxValue [ op ] = wsdStat . nowValue [ op ] ; 
line 10870: } 
line 10871: } 
line 10880: SQLITE_API int sqlite3_status ( int op , int * pCurrent , int * pHighwater , int resetFlag ) { 
line 10881: wsdStatInit ; 
line 10882: if ( op < 0 || op >= ArraySize ( wsdStat . nowValue ) ) { 
line 10883: return SQLITE_MISUSE ; 
line 10884: } 
line 10885: * pCurrent = wsdStat . nowValue [ op ] ; 
line 10886: * pHighwater = wsdStat . mxValue [ op ] ; 
line 10887: if ( resetFlag ) { 
line 10888: wsdStat . mxValue [ op ] = wsdStat . nowValue [ op ] ; 
line 10889: } 
line 10890: return SQLITE_OK ; 
line 10891: } 
line 10896: SQLITE_API int sqlite3_db_status ( 
line 10897: sqlite3 * db , 
line 10898: int op , 
line 10899: int * pCurrent , 
line 10900: int * pHighwater , 
line 10901: int resetFlag 
line 10902: ) { 
line 10903: switch ( op ) { 
line 10904: case SQLITE_DBSTATUS_LOOKASIDE_USED : { 
line 10905: * pCurrent = db -> lookaside . nOut ; 
line 10906: * pHighwater = db -> lookaside . mxOut ; 
line 10907: if ( resetFlag ) { 
line 10908: db -> lookaside . mxOut = db -> lookaside . nOut ; 
line 10909: } 
line 10910: break ; 
line 10911: } 
line 10912: default : { 
line 10913: return SQLITE_ERROR ; 
line 10914: } 
line 10915: } 
line 10916: return SQLITE_OK ; 
line 10917: } 
line 10966: # include < time . h > 
line 10968: # ifndef SQLITE_OMIT_DATETIME_FUNCS 
line 10982: # if ! defined ( HAVE_LOCALTIME_R ) && ! defined ( HAVE_LOCALTIME_S ) && 
line 10983: defined ( _MSC_VER ) && defined ( _CRT_INSECURE_DEPRECATE ) 
line 10984: # define HAVE_LOCALTIME_S 1 
line 10985: # endif 
line 10990: typedef struct DateTime DateTime ; 
line 10991: struct DateTime { 
line 10992: sqlite3_int64 iJD ; 
line 10993: int Y , M , D ; 
line 10994: int h , m ; 
line 10995: int tz ; 
line 10996: double s ; 
line 10997: char validYMD ; 
line 10998: char validHMS ; 
line 10999: char validJD ; 
line 11000: char validTZ ; 
line 11001: } ; 
line 11017: static int getDigits ( const char * zDate , ... ) { 
line 11018: va_list ap ; 
line 11019: int val ; 
line 11020: int N ; 
line 11021: int min ; 
line 11022: int max ; 
line 11023: int nextC ; 
line 11024: int * pVal ; 
line 11025: int cnt = 0 ; 
line 11026: va_start ( ap , zDate ) ; 
line 11027: do { 
line 11028: N = va_arg ( ap , int ) ; 
line 11029: min = va_arg ( ap , int ) ; 
line 11030: max = va_arg ( ap , int ) ; 
line 11031: nextC = va_arg ( ap , int ) ; 
line 11032: pVal = va_arg ( ap , int * ) ; 
line 11033: val = 0 ; 
line 11034: while ( N -- ) { 
line 11035: if ( ! sqlite3Isdigit ( * zDate ) ) { 
line 11036: goto end_getDigits ; 
line 11037: } 
line 11038: val = val * 10 + * zDate - '0' ; 
line 11039: zDate ++ ; 
line 11040: } 
line 11041: if ( val < min || val > max || ( nextC != 0 && nextC != * zDate ) ) { 
line 11042: goto end_getDigits ; 
line 11043: } 
line 11044: * pVal = val ; 
line 11045: zDate ++ ; 
line 11046: cnt ++ ; 
line 11047: } while ( nextC ) ; 
line 11048: end_getDigits : 
line 11049: va_end ( ap ) ; 
line 11050: return cnt ; 
line 11051: } 
line 11057: # define getValue sqlite3AtoF 
line 11075: static int parseTimezone ( const char * zDate , DateTime * p ) { 
line 11076: int sgn = 0 ; 
line 11077: int nHr , nMn ; 
line 11078: int c ; 
line 11079: while ( sqlite3Isspace ( * zDate ) ) { zDate ++ ; } 
line 11080: p -> tz = 0 ; 
line 11081: c = * zDate ; 
line 11082: if ( c == '-' ) { 
line 11083: sgn = - 1 ; 
line 11084: } else if ( c == '+' ) { 
line 11085: sgn = + 1 ; 
line 11086: } else if ( c == 'Z' || c == 'z' ) { 
line 11087: zDate ++ ; 
line 11088: goto zulu_time ; 
line 11089: } else { 
line 11090: return c != 0 ; 
line 11091: } 
line 11092: zDate ++ ; 
line 11093: if ( getDigits ( zDate , 2 , 0 , 14 , ':' , & nHr , 2 , 0 , 59 , 0 , & nMn ) != 2 ) { 
line 11094: return 1 ; 
line 11095: } 
line 11096: zDate += 5 ; 
line 11097: p -> tz = sgn * ( nMn + nHr * 60 ) ; 
line 11098: zulu_time : 
line 11099: while ( sqlite3Isspace ( * zDate ) ) { zDate ++ ; } 
line 11100: return * zDate != 0 ; 
line 11101: } 
line 11110: static int parseHhMmSs ( const char * zDate , DateTime * p ) { 
line 11111: int h , m , s ; 
line 11112: double ms = 0.0 ; 
line 11113: if ( getDigits ( zDate , 2 , 0 , 24 , ':' , & h , 2 , 0 , 59 , 0 , & m ) != 2 ) { 
line 11114: return 1 ; 
line 11115: } 
line 11116: zDate += 5 ; 
line 11117: if ( * zDate == ':' ) { 
line 11118: zDate ++ ; 
line 11119: if ( getDigits ( zDate , 2 , 0 , 59 , 0 , & s ) != 1 ) { 
line 11120: return 1 ; 
line 11121: } 
line 11122: zDate += 2 ; 
line 11123: if ( * zDate == '.' && sqlite3Isdigit ( zDate [ 1 ] ) ) { 
line 11124: double rScale = 1.0 ; 
line 11125: zDate ++ ; 
line 11126: while ( sqlite3Isdigit ( * zDate ) ) { 
line 11127: ms = ms * 10.0 + * zDate - '0' ; 
line 11128: rScale *= 10.0 ; 
line 11129: zDate ++ ; 
line 11130: } 
line 11131: ms /= rScale ; 
line 11132: } 
line 11133: } else { 
line 11134: s = 0 ; 
line 11135: } 
line 11136: p -> validJD = 0 ; 
line 11137: p -> validHMS = 1 ; 
line 11138: p -> h = h ; 
line 11139: p -> m = m ; 
line 11140: p -> s = s + ms ; 
line 11141: if ( parseTimezone ( zDate , p ) ) return 1 ; 
line 11142: p -> validTZ = ( p -> tz != 0 ) ? 1 : 0 ; 
line 11143: return 0 ; 
line 11144: } 
line 11152: static void computeJD ( DateTime * p ) { 
line 11153: int Y , M , D , A , B , X1 , X2 ; 
line 11155: if ( p -> validJD ) return ; 
line 11156: if ( p -> validYMD ) { 
line 11157: Y = p -> Y ; 
line 11158: M = p -> M ; 
line 11159: D = p -> D ; 
line 11160: } else { 
line 11161: Y = 2000 ; 
line 11162: M = 1 ; 
line 11163: D = 1 ; 
line 11164: } 
line 11165: if ( M <= 2 ) { 
line 11166: Y -- ; 
line 11167: M += 12 ; 
line 11168: } 
line 11169: A = Y / 100 ; 
line 11170: B = 2 - A + ( A / 4 ) ; 
line 11171: X1 = 36525 * ( Y + 4716 ) / 100 ; 
line 11172: X2 = 306001 * ( M + 1 ) / 10000 ; 
line 11173: p -> iJD = ( sqlite3_int64 ) ( ( X1 + X2 + D + B - 1524.5 ) * 86400000 ) ; 
line 11174: p -> validJD = 1 ; 
line 11175: if ( p -> validHMS ) { 
line 11176: p -> iJD += p -> h * 3600000 + p -> m * 60000 + ( sqlite3_int64 ) ( p -> s * 1000 ) ; 
line 11177: if ( p -> validTZ ) { 
line 11178: p -> iJD -= p -> tz * 60000 ; 
line 11179: p -> validYMD = 0 ; 
line 11180: p -> validHMS = 0 ; 
line 11181: p -> validTZ = 0 ; 
line 11182: } 
line 11183: } 
line 11184: } 
line 11198: static int parseYyyyMmDd ( const char * zDate , DateTime * p ) { 
line 11199: int Y , M , D , neg ; 
line 11201: if ( zDate [ 0 ] == '-' ) { 
line 11202: zDate ++ ; 
line 11203: neg = 1 ; 
line 11204: } else { 
line 11205: neg = 0 ; 
line 11206: } 
line 11207: if ( getDigits ( zDate , 4 , 0 , 9999 , '-' , & Y , 2 , 1 , 12 , '-' , & M , 2 , 1 , 31 , 0 , & D ) != 3 ) { 
line 11208: return 1 ; 
line 11209: } 
line 11210: zDate += 10 ; 
line 11211: while ( sqlite3Isspace ( * zDate ) || 'T' == * ( u8 * ) zDate ) { zDate ++ ; } 
line 11212: if ( parseHhMmSs ( zDate , p ) == 0 ) { 
line 11214: } else if ( * zDate == 0 ) { 
line 11215: p -> validHMS = 0 ; 
line 11216: } else { 
line 11217: return 1 ; 
line 11218: } 
line 11219: p -> validJD = 0 ; 
line 11220: p -> validYMD = 1 ; 
line 11221: p -> Y = neg ? - Y : Y ; 
line 11222: p -> M = M ; 
line 11223: p -> D = D ; 
line 11224: if ( p -> validTZ ) { 
line 11225: computeJD ( p ) ; 
line 11226: } 
line 11227: return 0 ; 
line 11228: } 
line 11233: static void setDateTimeToCurrent ( sqlite3_context * context , DateTime * p ) { 
line 11234: double r ; 
line 11235: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 11236: sqlite3OsCurrentTime ( db -> pVfs , & r ) ; 
line 11237: p -> iJD = ( sqlite3_int64 ) ( r * 86400000.0 + 0.5 ) ; 
line 11238: p -> validJD = 1 ; 
line 11239: } 
line 11257: static int parseDateOrTime ( 
line 11258: sqlite3_context * context , 
line 11259: const char * zDate , 
line 11260: DateTime * p 
line 11261: ) { 
line 11262: int isRealNum ; 
line 11263: if ( parseYyyyMmDd ( zDate , p ) == 0 ) { 
line 11264: return 0 ; 
line 11265: } else if ( parseHhMmSs ( zDate , p ) == 0 ) { 
line 11266: return 0 ; 
line 11267: } else if ( sqlite3StrICmp ( zDate , "now" ) == 0 ) { 
line 11268: setDateTimeToCurrent ( context , p ) ; 
line 11269: return 0 ; 
line 11270: } else if ( sqlite3IsNumber ( zDate , & isRealNum , SQLITE_UTF8 ) ) { 
line 11271: double r ; 
line 11272: getValue ( zDate , & r ) ; 
line 11273: p -> iJD = ( sqlite3_int64 ) ( r * 86400000.0 + 0.5 ) ; 
line 11274: p -> validJD = 1 ; 
line 11275: return 0 ; 
line 11276: } 
line 11277: return 1 ; 
line 11278: } 
line 11283: static void computeYMD ( DateTime * p ) { 
line 11284: int Z , A , B , C , D , E , X1 ; 
line 11285: if ( p -> validYMD ) return ; 
line 11286: if ( ! p -> validJD ) { 
line 11287: p -> Y = 2000 ; 
line 11288: p -> M = 1 ; 
line 11289: p -> D = 1 ; 
line 11290: } else { 
line 11291: Z = ( int ) ( ( p -> iJD + 43200000 ) / 86400000 ) ; 
line 11292: A = ( int ) ( ( Z - 1867216.25 ) / 36524.25 ) ; 
line 11293: A = Z + 1 + A - ( A / 4 ) ; 
line 11294: B = A + 1524 ; 
line 11295: C = ( int ) ( ( B - 122.1 ) / 365.25 ) ; 
line 11296: D = ( 36525 * C ) / 100 ; 
line 11297: E = ( int ) ( ( B - D ) / 30.6001 ) ; 
line 11298: X1 = ( int ) ( 30.6001 * E ) ; 
line 11299: p -> D = B - D - X1 ; 
line 11300: p -> M = E < 14 ? E - 1 : E - 13 ; 
line 11301: p -> Y = p -> M > 2 ? C - 4716 : C - 4715 ; 
line 11302: } 
line 11303: p -> validYMD = 1 ; 
line 11304: } 
line 11309: static void computeHMS ( DateTime * p ) { 
line 11310: int s ; 
line 11311: if ( p -> validHMS ) return ; 
line 11312: computeJD ( p ) ; 
line 11313: s = ( int ) ( ( p -> iJD + 43200000 ) % 86400000 ) ; 
line 11314: p -> s = s / 1000.0 ; 
line 11315: s = ( int ) p -> s ; 
line 11316: p -> s -= s ; 
line 11317: p -> h = s / 3600 ; 
line 11318: s -= p -> h * 3600 ; 
line 11319: p -> m = s / 60 ; 
line 11320: p -> s += s - p -> m * 60 ; 
line 11321: p -> validHMS = 1 ; 
line 11322: } 
line 11327: static void computeYMD_HMS ( DateTime * p ) { 
line 11328: computeYMD ( p ) ; 
line 11329: computeHMS ( p ) ; 
line 11330: } 
line 11335: static void clearYMD_HMS_TZ ( DateTime * p ) { 
line 11336: p -> validYMD = 0 ; 
line 11337: p -> validHMS = 0 ; 
line 11338: p -> validTZ = 0 ; 
line 11339: } 
line 11341: # ifndef SQLITE_OMIT_LOCALTIME 
line 11347: static sqlite3_int64 localtimeOffset ( DateTime * p ) { 
line 11348: DateTime x , y ; 
line 11349: time_t t ; 
line 11350: x = * p ; 
line 11351: computeYMD_HMS ( & x ) ; 
line 11352: if ( x . Y < 1971 || x . Y >= 2038 ) { 
line 11353: x . Y = 2000 ; 
line 11354: x . M = 1 ; 
line 11355: x . D = 1 ; 
line 11356: x . h = 0 ; 
line 11357: x . m = 0 ; 
line 11358: x . s = 0.0 ; 
line 11359: } else { 
line 11360: int s = ( int ) ( x . s + 0.5 ) ; 
line 11361: x . s = s ; 
line 11362: } 
line 11363: x . tz = 0 ; 
line 11364: x . validJD = 0 ; 
line 11365: computeJD ( & x ) ; 
line 11366: t = ( time_t ) ( x . iJD / 1000 - 21086676 * ( i64 ) 10000 ) ; 
line 11367: # ifdef HAVE_LOCALTIME_R 
line 11368: { 
line 11369: struct tm sLocal ; 
line 11370: localtime_r ( & t , & sLocal ) ; 
line 11371: y . Y = sLocal . tm_year + 1900 ; 
line 11372: y . M = sLocal . tm_mon + 1 ; 
line 11373: y . D = sLocal . tm_mday ; 
line 11374: y . h = sLocal . tm_hour ; 
line 11375: y . m = sLocal . tm_min ; 
line 11376: y . s = sLocal . tm_sec ; 
line 11377: } 
line 11378: # elif defined ( HAVE_LOCALTIME_S ) && HAVE_LOCALTIME_S 
line 11379: { 
line 11380: struct tm sLocal ; 
line 11381: localtime_s ( & sLocal , & t ) ; 
line 11382: y . Y = sLocal . tm_year + 1900 ; 
line 11383: y . M = sLocal . tm_mon + 1 ; 
line 11384: y . D = sLocal . tm_mday ; 
line 11385: y . h = sLocal . tm_hour ; 
line 11386: y . m = sLocal . tm_min ; 
line 11387: y . s = sLocal . tm_sec ; 
line 11388: } 
line 11389: # else 
line 11390: { 
line 11391: struct tm * pTm ; 
line 11392: sqlite3_mutex_enter ( sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ) ; 
line 11393: pTm = localtime ( & t ) ; 
line 11394: y . Y = pTm -> tm_year + 1900 ; 
line 11395: y . M = pTm -> tm_mon + 1 ; 
line 11396: y . D = pTm -> tm_mday ; 
line 11397: y . h = pTm -> tm_hour ; 
line 11398: y . m = pTm -> tm_min ; 
line 11399: y . s = pTm -> tm_sec ; 
line 11400: sqlite3_mutex_leave ( sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ) ; 
line 11401: } 
line 11402: # endif 
line 11403: y . validYMD = 1 ; 
line 11404: y . validHMS = 1 ; 
line 11405: y . validJD = 0 ; 
line 11406: y . validTZ = 0 ; 
line 11407: computeJD ( & y ) ; 
line 11408: return y . iJD - x . iJD ; 
line 11409: } 
line 11410: # endif 
line 11433: static int parseModifier ( const char * zMod , DateTime * p ) { 
line 11434: int rc = 1 ; 
line 11435: int n ; 
line 11436: double r ; 
line 11437: char * z , zBuf [ 30 ] ; 
line 11438: z = zBuf ; 
line 11439: for ( n = 0 ; n < ArraySize ( zBuf ) - 1 && zMod [ n ] ; n ++ ) { 
line 11440: z [ n ] = ( char ) sqlite3UpperToLower [ ( u8 ) zMod [ n ] ] ; 
line 11441: } 
line 11442: z [ n ] = 0 ; 
line 11443: switch ( z [ 0 ] ) { 
line 11444: # ifndef SQLITE_OMIT_LOCALTIME 
line 11445: case 'l' : { 
line 11451: if ( strcmp ( z , "localtime" ) == 0 ) { 
line 11452: computeJD ( p ) ; 
line 11453: p -> iJD += localtimeOffset ( p ) ; 
line 11454: clearYMD_HMS_TZ ( p ) ; 
line 11455: rc = 0 ; 
line 11456: } 
line 11457: break ; 
line 11458: } 
line 11459: # endif 
line 11460: case 'u' : { 
line 11467: if ( strcmp ( z , "unixepoch" ) == 0 && p -> validJD ) { 
line 11468: p -> iJD = ( p -> iJD + 43200 ) / 86400 + 21086676 * ( i64 ) 10000000 ; 
line 11469: clearYMD_HMS_TZ ( p ) ; 
line 11470: rc = 0 ; 
line 11471: } 
line 11472: # ifndef SQLITE_OMIT_LOCALTIME 
line 11473: else if ( strcmp ( z , "utc" ) == 0 ) { 
line 11474: sqlite3_int64 c1 ; 
line 11475: computeJD ( p ) ; 
line 11476: c1 = localtimeOffset ( p ) ; 
line 11477: p -> iJD -= c1 ; 
line 11478: clearYMD_HMS_TZ ( p ) ; 
line 11479: p -> iJD += c1 - localtimeOffset ( p ) ; 
line 11480: rc = 0 ; 
line 11481: } 
line 11482: # endif 
line 11483: break ; 
line 11484: } 
line 11485: case 'w' : { 
line 11493: if ( strncmp ( z , "weekday " , 8 ) == 0 && getValue ( & z [ 8 ] , & r ) > 0 
line 11494: && ( n = ( int ) r ) == r && n >= 0 && r < 7 ) { 
line 11495: sqlite3_int64 Z ; 
line 11496: computeYMD_HMS ( p ) ; 
line 11497: p -> validTZ = 0 ; 
line 11498: p -> validJD = 0 ; 
line 11499: computeJD ( p ) ; 
line 11500: Z = ( ( p -> iJD + 129600000 ) / 86400000 ) % 7 ; 
line 11501: if ( Z > n ) Z -= 7 ; 
line 11502: p -> iJD += ( n - Z ) * 86400000 ; 
line 11503: clearYMD_HMS_TZ ( p ) ; 
line 11504: rc = 0 ; 
line 11505: } 
line 11506: break ; 
line 11507: } 
line 11508: case 's' : { 
line 11515: if ( strncmp ( z , "start of " , 9 ) != 0 ) break ; 
line 11516: z += 9 ; 
line 11517: computeYMD ( p ) ; 
line 11518: p -> validHMS = 1 ; 
line 11519: p -> h = p -> m = 0 ; 
line 11520: p -> s = 0.0 ; 
line 11521: p -> validTZ = 0 ; 
line 11522: p -> validJD = 0 ; 
line 11523: if ( strcmp ( z , "month" ) == 0 ) { 
line 11524: p -> D = 1 ; 
line 11525: rc = 0 ; 
line 11526: } else if ( strcmp ( z , "year" ) == 0 ) { 
line 11527: computeYMD ( p ) ; 
line 11528: p -> M = 1 ; 
line 11529: p -> D = 1 ; 
line 11530: rc = 0 ; 
line 11531: } else if ( strcmp ( z , "day" ) == 0 ) { 
line 11532: rc = 0 ; 
line 11533: } 
line 11534: break ; 
line 11535: } 
line 11536: case '+' : 
line 11537: case '-' : 
line 11538: case '0' : 
line 11539: case '1' : 
line 11540: case '2' : 
line 11541: case '3' : 
line 11542: case '4' : 
line 11543: case '5' : 
line 11544: case '6' : 
line 11545: case '7' : 
line 11546: case '8' : 
line 11547: case '9' : { 
line 11548: double rRounder ; 
line 11549: n = getValue ( z , & r ) ; 
line 11550: assert ( n >= 1 ) ; 
line 11551: if ( z [ n ] == ':' ) { 
line 11557: const char * z2 = z ; 
line 11558: DateTime tx ; 
line 11559: sqlite3_int64 day ; 
line 11560: if ( ! sqlite3Isdigit ( * z2 ) ) z2 ++ ; 
line 11561: memset ( & tx , 0 , sizeof ( tx ) ) ; 
line 11562: if ( parseHhMmSs ( z2 , & tx ) ) break ; 
line 11563: computeJD ( & tx ) ; 
line 11564: tx . iJD -= 43200000 ; 
line 11565: day = tx . iJD / 86400000 ; 
line 11566: tx . iJD -= day * 86400000 ; 
line 11567: if ( z [ 0 ] == '-' ) tx . iJD = - tx . iJD ; 
line 11568: computeJD ( p ) ; 
line 11569: clearYMD_HMS_TZ ( p ) ; 
line 11570: p -> iJD += tx . iJD ; 
line 11571: rc = 0 ; 
line 11572: break ; 
line 11573: } 
line 11574: z += n ; 
line 11575: while ( sqlite3Isspace ( * z ) ) z ++ ; 
line 11576: n = sqlite3Strlen30 ( z ) ; 
line 11577: if ( n > 10 || n < 3 ) break ; 
line 11578: if ( z [ n - 1 ] == 's' ) { z [ n - 1 ] = 0 ; n -- ; } 
line 11579: computeJD ( p ) ; 
line 11580: rc = 0 ; 
line 11581: rRounder = r < 0 ? - 0.5 : + 0.5 ; 
line 11582: if ( n == 3 && strcmp ( z , "day" ) == 0 ) { 
line 11583: p -> iJD += ( sqlite3_int64 ) ( r * 86400000.0 + rRounder ) ; 
line 11584: } else if ( n == 4 && strcmp ( z , "hour" ) == 0 ) { 
line 11585: p -> iJD += ( sqlite3_int64 ) ( r * ( 86400000.0 / 24.0 ) + rRounder ) ; 
line 11586: } else if ( n == 6 && strcmp ( z , "minute" ) == 0 ) { 
line 11587: p -> iJD += ( sqlite3_int64 ) ( r * ( 86400000.0 / ( 24.0 * 60.0 ) ) + rRounder ) ; 
line 11588: } else if ( n == 6 && strcmp ( z , "second" ) == 0 ) { 
line 11589: p -> iJD += ( sqlite3_int64 ) ( r * ( 86400000.0 / ( 24.0 * 60.0 * 60.0 ) ) + rRounder ) ; 
line 11590: } else if ( n == 5 && strcmp ( z , "month" ) == 0 ) { 
line 11591: int x , y ; 
line 11592: computeYMD_HMS ( p ) ; 
line 11593: p -> M += ( int ) r ; 
line 11594: x = p -> M > 0 ? ( p -> M - 1 ) / 12 : ( p -> M - 12 ) / 12 ; 
line 11595: p -> Y += x ; 
line 11596: p -> M -= x * 12 ; 
line 11597: p -> validJD = 0 ; 
line 11598: computeJD ( p ) ; 
line 11599: y = ( int ) r ; 
line 11600: if ( y != r ) { 
line 11601: p -> iJD += ( sqlite3_int64 ) ( ( r - y ) * 30.0 * 86400000.0 + rRounder ) ; 
line 11602: } 
line 11603: } else if ( n == 4 && strcmp ( z , "year" ) == 0 ) { 
line 11604: int y = ( int ) r ; 
line 11605: computeYMD_HMS ( p ) ; 
line 11606: p -> Y += y ; 
line 11607: p -> validJD = 0 ; 
line 11608: computeJD ( p ) ; 
line 11609: if ( y != r ) { 
line 11610: p -> iJD += ( sqlite3_int64 ) ( ( r - y ) * 365.0 * 86400000.0 + rRounder ) ; 
line 11611: } 
line 11612: } else { 
line 11613: rc = 1 ; 
line 11614: } 
line 11615: clearYMD_HMS_TZ ( p ) ; 
line 11616: break ; 
line 11617: } 
line 11618: default : { 
line 11619: break ; 
line 11620: } 
line 11621: } 
line 11622: return rc ; 
line 11623: } 
line 11634: static int isDate ( 
line 11635: sqlite3_context * context , 
line 11636: int argc , 
line 11637: sqlite3_value * * argv , 
line 11638: DateTime * p 
line 11639: ) { 
line 11640: int i ; 
line 11641: const unsigned char * z ; 
line 11642: int eType ; 
line 11643: memset ( p , 0 , sizeof ( * p ) ) ; 
line 11644: if ( argc == 0 ) { 
line 11645: setDateTimeToCurrent ( context , p ) ; 
line 11646: } else if ( ( eType = sqlite3_value_type ( argv [ 0 ] ) ) == SQLITE_FLOAT 
line 11647: || eType == SQLITE_INTEGER ) { 
line 11648: p -> iJD = ( sqlite3_int64 ) ( sqlite3_value_double ( argv [ 0 ] ) * 86400000.0 + 0.5 ) ; 
line 11649: p -> validJD = 1 ; 
line 11650: } else { 
line 11651: z = sqlite3_value_text ( argv [ 0 ] ) ; 
line 11652: if ( ! z || parseDateOrTime ( context , ( char * ) z , p ) ) { 
line 11653: return 1 ; 
line 11654: } 
line 11655: } 
line 11656: for ( i = 1 ; i < argc ; i ++ ) { 
line 11657: if ( ( z = sqlite3_value_text ( argv [ i ] ) ) == 0 || parseModifier ( ( char * ) z , p ) ) { 
line 11658: return 1 ; 
line 11659: } 
line 11660: } 
line 11661: return 0 ; 
line 11662: } 
line 11675: static void juliandayFunc ( 
line 11676: sqlite3_context * context , 
line 11677: int argc , 
line 11678: sqlite3_value * * argv 
line 11679: ) { 
line 11680: DateTime x ; 
line 11681: if ( isDate ( context , argc , argv , & x ) == 0 ) { 
line 11682: computeJD ( & x ) ; 
line 11683: sqlite3_result_double ( context , x . iJD / 86400000.0 ) ; 
line 11684: } 
line 11685: } 
line 11692: static void datetimeFunc ( 
line 11693: sqlite3_context * context , 
line 11694: int argc , 
line 11695: sqlite3_value * * argv 
line 11696: ) { 
line 11697: DateTime x ; 
line 11698: if ( isDate ( context , argc , argv , & x ) == 0 ) { 
line 11699: char zBuf [ 100 ] ; 
line 11700: computeYMD_HMS ( & x ) ; 
line 11701: sqlite3_snprintf ( sizeof ( zBuf ) , zBuf , "%04d-%02d-%02d %02d:%02d:%02d" , 
line 11702: x . Y , x . M , x . D , x . h , x . m , ( int ) ( x . s ) ) ; 
line 11703: sqlite3_result_text ( context , zBuf , - 1 , SQLITE_TRANSIENT ) ; 
line 11704: } 
line 11705: } 
line 11712: static void timeFunc ( 
line 11713: sqlite3_context * context , 
line 11714: int argc , 
line 11715: sqlite3_value * * argv 
line 11716: ) { 
line 11717: DateTime x ; 
line 11718: if ( isDate ( context , argc , argv , & x ) == 0 ) { 
line 11719: char zBuf [ 100 ] ; 
line 11720: computeHMS ( & x ) ; 
line 11721: sqlite3_snprintf ( sizeof ( zBuf ) , zBuf , "%02d:%02d:%02d" , x . h , x . m , ( int ) x . s ) ; 
line 11722: sqlite3_result_text ( context , zBuf , - 1 , SQLITE_TRANSIENT ) ; 
line 11723: } 
line 11724: } 
line 11731: static void dateFunc ( 
line 11732: sqlite3_context * context , 
line 11733: int argc , 
line 11734: sqlite3_value * * argv 
line 11735: ) { 
line 11736: DateTime x ; 
line 11737: if ( isDate ( context , argc , argv , & x ) == 0 ) { 
line 11738: char zBuf [ 100 ] ; 
line 11739: computeYMD ( & x ) ; 
line 11740: sqlite3_snprintf ( sizeof ( zBuf ) , zBuf , "%04d-%02d-%02d" , x . Y , x . M , x . D ) ; 
line 11741: sqlite3_result_text ( context , zBuf , - 1 , SQLITE_TRANSIENT ) ; 
line 11742: } 
line 11743: } 
line 11764: static void strftimeFunc ( 
line 11765: sqlite3_context * context , 
line 11766: int argc , 
line 11767: sqlite3_value * * argv 
line 11768: ) { 
line 11769: DateTime x ; 
line 11770: u64 n ; 
line 11771: size_t i , j ; 
line 11772: char * z ; 
line 11773: sqlite3 * db ; 
line 11774: const char * zFmt = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; 
line 11775: char zBuf [ 100 ] ; 
line 11776: if ( zFmt == 0 || isDate ( context , argc - 1 , argv + 1 , & x ) ) return ; 
line 11777: db = sqlite3_context_db_handle ( context ) ; 
line 11778: for ( i = 0 , n = 1 ; zFmt [ i ] ; i ++ , n ++ ) { 
line 11779: if ( zFmt [ i ] == '%' ) { 
line 11780: switch ( zFmt [ i + 1 ] ) { 
line 11781: case 'd' : 
line 11782: case 'H' : 
line 11783: case 'm' : 
line 11784: case 'M' : 
line 11785: case 'S' : 
line 11786: case 'W' : 
line 11787: n ++ ; 
line 11789: case 'w' : 
line 11790: case '%' : 
line 11791: break ; 
line 11792: case 'f' : 
line 11793: n += 8 ; 
line 11794: break ; 
line 11795: case 'j' : 
line 11796: n += 3 ; 
line 11797: break ; 
line 11798: case 'Y' : 
line 11799: n += 8 ; 
line 11800: break ; 
line 11801: case 's' : 
line 11802: case 'J' : 
line 11803: n += 50 ; 
line 11804: break ; 
line 11805: default : 
line 11806: return ; 
line 11807: } 
line 11808: i ++ ; 
line 11809: } 
line 11810: } 
line 11811: testcase ( n == sizeof ( zBuf ) - 1 ) ; 
line 11812: testcase ( n == sizeof ( zBuf ) ) ; 
line 11813: testcase ( n == ( u64 ) db -> aLimit [ SQLITE_LIMIT_LENGTH ] + 1 ) ; 
line 11814: testcase ( n == ( u64 ) db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) ; 
line 11815: if ( n < sizeof ( zBuf ) ) { 
line 11816: z = zBuf ; 
line 11817: } else if ( n > ( u64 ) db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) { 
line 11818: sqlite3_result_error_toobig ( context ) ; 
line 11819: return ; 
line 11820: } else { 
line 11821: z = sqlite3DbMallocRaw ( db , ( int ) n ) ; 
line 11822: if ( z == 0 ) { 
line 11823: sqlite3_result_error_nomem ( context ) ; 
line 11824: return ; 
line 11825: } 
line 11826: } 
line 11827: computeJD ( & x ) ; 
line 11828: computeYMD_HMS ( & x ) ; 
line 11829: for ( i = j = 0 ; zFmt [ i ] ; i ++ ) { 
line 11830: if ( zFmt [ i ] != '%' ) { 
line 11831: z [ j ++ ] = zFmt [ i ] ; 
line 11832: } else { 
line 11833: i ++ ; 
line 11834: switch ( zFmt [ i ] ) { 
line 11835: case 'd' : sqlite3_snprintf ( 3 , & z [ j ] , "%02d" , x . D ) ; j += 2 ; break ; 
line 11836: case 'f' : { 
line 11837: double s = x . s ; 
line 11838: if ( s > 59.999 ) s = 59.999 ; 
line 11839: sqlite3_snprintf ( 7 , & z [ j ] , "%06.3f" , s ) ; 
line 11840: j += sqlite3Strlen30 ( & z [ j ] ) ; 
line 11841: break ; 
line 11842: } 
line 11843: case 'H' : sqlite3_snprintf ( 3 , & z [ j ] , "%02d" , x . h ) ; j += 2 ; break ; 
line 11844: case 'W' : 
line 11845: case 'j' : { 
line 11846: int nDay ; 
line 11847: DateTime y = x ; 
line 11848: y . validJD = 0 ; 
line 11849: y . M = 1 ; 
line 11850: y . D = 1 ; 
line 11851: computeJD ( & y ) ; 
line 11852: nDay = ( int ) ( ( x . iJD - y . iJD + 43200000 ) / 86400000 ) ; 
line 11853: if ( zFmt [ i ] == 'W' ) { 
line 11854: int wd ; 
line 11855: wd = ( int ) ( ( ( x . iJD + 43200000 ) / 86400000 ) % 7 ) ; 
line 11856: sqlite3_snprintf ( 3 , & z [ j ] , "%02d" , ( nDay + 7 - wd ) / 7 ) ; 
line 11857: j += 2 ; 
line 11858: } else { 
line 11859: sqlite3_snprintf ( 4 , & z [ j ] , "%03d" , nDay + 1 ) ; 
line 11860: j += 3 ; 
line 11861: } 
line 11862: break ; 
line 11863: } 
line 11864: case 'J' : { 
line 11865: sqlite3_snprintf ( 20 , & z [ j ] , "%.16g" , x . iJD / 86400000.0 ) ; 
line 11866: j += sqlite3Strlen30 ( & z [ j ] ) ; 
line 11867: break ; 
line 11868: } 
line 11869: case 'm' : sqlite3_snprintf ( 3 , & z [ j ] , "%02d" , x . M ) ; j += 2 ; break ; 
line 11870: case 'M' : sqlite3_snprintf ( 3 , & z [ j ] , "%02d" , x . m ) ; j += 2 ; break ; 
line 11871: case 's' : { 
line 11872: sqlite3_snprintf ( 30 , & z [ j ] , "%lld" , 
line 11873: ( i64 ) ( x . iJD / 1000 - 21086676 * ( i64 ) 10000 ) ) ; 
line 11874: j += sqlite3Strlen30 ( & z [ j ] ) ; 
line 11875: break ; 
line 11876: } 
line 11877: case 'S' : sqlite3_snprintf ( 3 , & z [ j ] , "%02d" , ( int ) x . s ) ; j += 2 ; break ; 
line 11878: case 'w' : { 
line 11879: z [ j ++ ] = ( char ) ( ( ( x . iJD + 129600000 ) / 86400000 ) % 7 ) + '0' ; 
line 11880: break ; 
line 11881: } 
line 11882: case 'Y' : { 
line 11883: sqlite3_snprintf ( 5 , & z [ j ] , "%04d" , x . Y ) ; j += sqlite3Strlen30 ( & z [ j ] ) ; 
line 11884: break ; 
line 11885: } 
line 11886: default : z [ j ++ ] = '%' ; break ; 
line 11887: } 
line 11888: } 
line 11889: } 
line 11890: z [ j ] = 0 ; 
line 11891: sqlite3_result_text ( context , z , - 1 , 
line 11892: z == zBuf ? SQLITE_TRANSIENT : SQLITE_DYNAMIC ) ; 
line 11893: } 
line 11900: static void ctimeFunc ( 
line 11901: sqlite3_context * context , 
line 11902: int NotUsed , 
line 11903: sqlite3_value * * NotUsed2 
line 11904: ) { 
line 11905: UNUSED_PARAMETER2 ( NotUsed , NotUsed2 ) ; 
line 11906: timeFunc ( context , 0 , 0 ) ; 
line 11907: } 
line 11914: static void cdateFunc ( 
line 11915: sqlite3_context * context , 
line 11916: int NotUsed , 
line 11917: sqlite3_value * * NotUsed2 
line 11918: ) { 
line 11919: UNUSED_PARAMETER2 ( NotUsed , NotUsed2 ) ; 
line 11920: dateFunc ( context , 0 , 0 ) ; 
line 11921: } 
line 11928: static void ctimestampFunc ( 
line 11929: sqlite3_context * context , 
line 11930: int NotUsed , 
line 11931: sqlite3_value * * NotUsed2 
line 11932: ) { 
line 11933: UNUSED_PARAMETER2 ( NotUsed , NotUsed2 ) ; 
line 11934: datetimeFunc ( context , 0 , 0 ) ; 
line 11935: } 
line 11936: # endif 
line 11938: # ifdef SQLITE_OMIT_DATETIME_FUNCS 
line 11950: static void currentTimeFunc ( 
line 11951: sqlite3_context * context , 
line 11952: int argc , 
line 11953: sqlite3_value * * argv 
line 11954: ) { 
line 11955: time_t t ; 
line 11956: char * zFormat = ( char * ) sqlite3_user_data ( context ) ; 
line 11957: sqlite3 * db ; 
line 11958: double rT ; 
line 11959: char zBuf [ 20 ] ; 
line 11961: UNUSED_PARAMETER ( argc ) ; 
line 11962: UNUSED_PARAMETER ( argv ) ; 
line 11964: db = sqlite3_context_db_handle ( context ) ; 
line 11965: sqlite3OsCurrentTime ( db -> pVfs , & rT ) ; 
line 11966: # ifndef SQLITE_OMIT_FLOATING_POINT 
line 11967: t = 86400.0 * ( rT - 2440587.5 ) + 0.5 ; 
line 11968: # else 
line 11972: t = 86400 * ( rT - 2440587 ) - 43200 ; 
line 11973: # endif 
line 11974: # ifdef HAVE_GMTIME_R 
line 11975: { 
line 11976: struct tm sNow ; 
line 11977: gmtime_r ( & t , & sNow ) ; 
line 11978: strftime ( zBuf , 20 , zFormat , & sNow ) ; 
line 11979: } 
line 11980: # else 
line 11981: { 
line 11982: struct tm * pTm ; 
line 11983: sqlite3_mutex_enter ( sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ) ; 
line 11984: pTm = gmtime ( & t ) ; 
line 11985: strftime ( zBuf , 20 , zFormat , pTm ) ; 
line 11986: sqlite3_mutex_leave ( sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ) ; 
line 11987: } 
line 11988: # endif 
line 11990: sqlite3_result_text ( context , zBuf , - 1 , SQLITE_TRANSIENT ) ; 
line 11991: } 
line 11992: # endif 
line 11999: SQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions ( void ) { 
line 12000: static SQLITE_WSD FuncDef aDateTimeFuncs [ ] = { 
line 12001: # ifndef SQLITE_OMIT_DATETIME_FUNCS 
line 12002: FUNCTION ( julianday , - 1 , 0 , 0 , juliandayFunc ) , 
line 12003: FUNCTION ( date , - 1 , 0 , 0 , dateFunc ) , 
line 12004: FUNCTION ( time , - 1 , 0 , 0 , timeFunc ) , 
line 12005: FUNCTION ( datetime , - 1 , 0 , 0 , datetimeFunc ) , 
line 12006: FUNCTION ( strftime , - 1 , 0 , 0 , strftimeFunc ) , 
line 12007: FUNCTION ( current_time , 0 , 0 , 0 , ctimeFunc ) , 
line 12008: FUNCTION ( current_timestamp , 0 , 0 , 0 , ctimestampFunc ) , 
line 12009: FUNCTION ( current_date , 0 , 0 , 0 , cdateFunc ) , 
line 12010: # else 
line 12011: STR_FUNCTION ( current_time , 0 , "%H:%M:%S" , 0 , currentTimeFunc ) , 
line 12012: STR_FUNCTION ( current_timestamp , 0 , "%Y-%m-%d" , 0 , currentTimeFunc ) , 
line 12013: STR_FUNCTION ( current_date , 0 , "%Y-%m-%d %H:%M:%S" , 0 , currentTimeFunc ) , 
line 12014: # endif 
line 12015: } ; 
line 12016: int i ; 
line 12017: FuncDefHash * pHash = & GLOBAL ( FuncDefHash , sqlite3GlobalFunctions ) ; 
line 12018: FuncDef * aFunc = ( FuncDef * ) & GLOBAL ( FuncDef , aDateTimeFuncs ) ; 
line 12020: for ( i = 0 ; i < ArraySize ( aDateTimeFuncs ) ; i ++ ) { 
line 12021: sqlite3FuncDefInsert ( pHash , & aFunc [ i ] ) ; 
line 12022: } 
line 12023: } 
line 12042: # define _SQLITE_OS_C_ 1 
line 12043: # undef _SQLITE_OS_C_ 
line 12062: # if defined ( SQLITE_TEST ) && ( SQLITE_OS_WIN == 0 ) 
line 12063: # define DO_OS_MALLOC_TEST ( x ) if ( ! x || ! sqlite3IsMemJournal ( x ) ) { 
line 12064: void * pTstAlloc = sqlite3Malloc ( 10 ) ; 
line 12065: if ( ! pTstAlloc ) return SQLITE_IOERR_NOMEM ; 
line 12066: sqlite3_free ( pTstAlloc ) ; 
line 12067: } 
line 12068: # else 
line 12069: # define DO_OS_MALLOC_TEST ( x ) 
line 12070: # endif 
line 12078: SQLITE_PRIVATE int sqlite3OsClose ( sqlite3_file * pId ) { 
line 12079: int rc = SQLITE_OK ; 
line 12080: if ( pId -> pMethods ) { 
line 12081: rc = pId -> pMethods -> xClose ( pId ) ; 
line 12082: pId -> pMethods = 0 ; 
line 12083: } 
line 12084: return rc ; 
line 12085: } 
line 12086: SQLITE_PRIVATE int sqlite3OsRead ( sqlite3_file * id , void * pBuf , int amt , i64 offset ) { 
line 12087: DO_OS_MALLOC_TEST ( id ) ; 
line 12088: return id -> pMethods -> xRead ( id , pBuf , amt , offset ) ; 
line 12089: } 
line 12090: SQLITE_PRIVATE int sqlite3OsWrite ( sqlite3_file * id , const void * pBuf , int amt , i64 offset ) { 
line 12091: DO_OS_MALLOC_TEST ( id ) ; 
line 12092: return id -> pMethods -> xWrite ( id , pBuf , amt , offset ) ; 
line 12093: } 
line 12094: SQLITE_PRIVATE int sqlite3OsTruncate ( sqlite3_file * id , i64 size ) { 
line 12095: return id -> pMethods -> xTruncate ( id , size ) ; 
line 12096: } 
line 12097: SQLITE_PRIVATE int sqlite3OsSync ( sqlite3_file * id , int flags ) { 
line 12098: DO_OS_MALLOC_TEST ( id ) ; 
line 12099: return id -> pMethods -> xSync ( id , flags ) ; 
line 12100: } 
line 12101: SQLITE_PRIVATE int sqlite3OsFileSize ( sqlite3_file * id , i64 * pSize ) { 
line 12102: DO_OS_MALLOC_TEST ( id ) ; 
line 12103: return id -> pMethods -> xFileSize ( id , pSize ) ; 
line 12104: } 
line 12105: SQLITE_PRIVATE int sqlite3OsLock ( sqlite3_file * id , int lockType ) { 
line 12106: DO_OS_MALLOC_TEST ( id ) ; 
line 12107: return id -> pMethods -> xLock ( id , lockType ) ; 
line 12108: } 
line 12109: SQLITE_PRIVATE int sqlite3OsUnlock ( sqlite3_file * id , int lockType ) { 
line 12110: return id -> pMethods -> xUnlock ( id , lockType ) ; 
line 12111: } 
line 12112: SQLITE_PRIVATE int sqlite3OsCheckReservedLock ( sqlite3_file * id , int * pResOut ) { 
line 12113: DO_OS_MALLOC_TEST ( id ) ; 
line 12114: return id -> pMethods -> xCheckReservedLock ( id , pResOut ) ; 
line 12115: } 
line 12116: SQLITE_PRIVATE int sqlite3OsFileControl ( sqlite3_file * id , int op , void * pArg ) { 
line 12117: return id -> pMethods -> xFileControl ( id , op , pArg ) ; 
line 12118: } 
line 12119: SQLITE_PRIVATE int sqlite3OsSectorSize ( sqlite3_file * id ) { 
line 12120: int ( * xSectorSize ) ( sqlite3_file * ) = id -> pMethods -> xSectorSize ; 
line 12121: return ( xSectorSize ? xSectorSize ( id ) : SQLITE_DEFAULT_SECTOR_SIZE ) ; 
line 12122: } 
line 12123: SQLITE_PRIVATE int sqlite3OsDeviceCharacteristics ( sqlite3_file * id ) { 
line 12124: return id -> pMethods -> xDeviceCharacteristics ( id ) ; 
line 12125: } 
line 12131: SQLITE_PRIVATE int sqlite3OsOpen ( 
line 12132: sqlite3_vfs * pVfs , 
line 12133: const char * zPath , 
line 12134: sqlite3_file * pFile , 
line 12135: int flags , 
line 12136: int * pFlagsOut 
line 12137: ) { 
line 12138: int rc ; 
line 12139: DO_OS_MALLOC_TEST ( 0 ) ; 
line 12144: rc = pVfs -> xOpen ( pVfs , zPath , pFile , flags & 0x7f1f , pFlagsOut ) ; 
line 12145: assert ( rc == SQLITE_OK || pFile -> pMethods == 0 ) ; 
line 12146: return rc ; 
line 12147: } 
line 12148: SQLITE_PRIVATE int sqlite3OsDelete ( sqlite3_vfs * pVfs , const char * zPath , int dirSync ) { 
line 12149: return pVfs -> xDelete ( pVfs , zPath , dirSync ) ; 
line 12150: } 
line 12151: SQLITE_PRIVATE int sqlite3OsAccess ( 
line 12152: sqlite3_vfs * pVfs , 
line 12153: const char * zPath , 
line 12154: int flags , 
line 12155: int * pResOut 
line 12156: ) { 
line 12157: DO_OS_MALLOC_TEST ( 0 ) ; 
line 12158: return pVfs -> xAccess ( pVfs , zPath , flags , pResOut ) ; 
line 12159: } 
line 12160: SQLITE_PRIVATE int sqlite3OsFullPathname ( 
line 12161: sqlite3_vfs * pVfs , 
line 12162: const char * zPath , 
line 12163: int nPathOut , 
line 12164: char * zPathOut 
line 12165: ) { 
line 12166: zPathOut [ 0 ] = 0 ; 
line 12167: return pVfs -> xFullPathname ( pVfs , zPath , nPathOut , zPathOut ) ; 
line 12168: } 
line 12169: # ifndef SQLITE_OMIT_LOAD_EXTENSION 
line 12170: SQLITE_PRIVATE void * sqlite3OsDlOpen ( sqlite3_vfs * pVfs , const char * zPath ) { 
line 12171: return pVfs -> xDlOpen ( pVfs , zPath ) ; 
line 12172: } 
line 12173: SQLITE_PRIVATE void sqlite3OsDlError ( sqlite3_vfs * pVfs , int nByte , char * zBufOut ) { 
line 12174: pVfs -> xDlError ( pVfs , nByte , zBufOut ) ; 
line 12175: } 
line 12176: SQLITE_PRIVATE void ( * sqlite3OsDlSym ( sqlite3_vfs * pVfs , void * pHdle , const char * zSym ) ) ( void ) { 
line 12177: return pVfs -> xDlSym ( pVfs , pHdle , zSym ) ; 
line 12178: } 
line 12179: SQLITE_PRIVATE void sqlite3OsDlClose ( sqlite3_vfs * pVfs , void * pHandle ) { 
line 12180: pVfs -> xDlClose ( pVfs , pHandle ) ; 
line 12181: } 
line 12182: # endif 
line 12183: SQLITE_PRIVATE int sqlite3OsRandomness ( sqlite3_vfs * pVfs , int nByte , char * zBufOut ) { 
line 12184: return pVfs -> xRandomness ( pVfs , nByte , zBufOut ) ; 
line 12185: } 
line 12186: SQLITE_PRIVATE int sqlite3OsSleep ( sqlite3_vfs * pVfs , int nMicro ) { 
line 12187: return pVfs -> xSleep ( pVfs , nMicro ) ; 
line 12188: } 
line 12189: SQLITE_PRIVATE int sqlite3OsCurrentTime ( sqlite3_vfs * pVfs , double * pTimeOut ) { 
line 12190: return pVfs -> xCurrentTime ( pVfs , pTimeOut ) ; 
line 12191: } 
line 12193: SQLITE_PRIVATE int sqlite3OsOpenMalloc ( 
line 12194: sqlite3_vfs * pVfs , 
line 12195: const char * zFile , 
line 12196: sqlite3_file * * ppFile , 
line 12197: int flags , 
line 12198: int * pOutFlags 
line 12199: ) { 
line 12200: int rc = SQLITE_NOMEM ; 
line 12201: sqlite3_file * pFile ; 
line 12202: pFile = ( sqlite3_file * ) sqlite3Malloc ( pVfs -> szOsFile ) ; 
line 12203: if ( pFile ) { 
line 12204: rc = sqlite3OsOpen ( pVfs , zFile , pFile , flags , pOutFlags ) ; 
line 12205: if ( rc != SQLITE_OK ) { 
line 12206: sqlite3_free ( pFile ) ; 
line 12207: } else { 
line 12208: * ppFile = pFile ; 
line 12209: } 
line 12210: } 
line 12211: return rc ; 
line 12212: } 
line 12213: SQLITE_PRIVATE int sqlite3OsCloseFree ( sqlite3_file * pFile ) { 
line 12214: int rc = SQLITE_OK ; 
line 12215: assert ( pFile ) ; 
line 12216: rc = sqlite3OsClose ( pFile ) ; 
line 12217: sqlite3_free ( pFile ) ; 
line 12218: return rc ; 
line 12219: } 
line 12227: SQLITE_PRIVATE int sqlite3OsInit ( void ) { 
line 12228: void * p = sqlite3_malloc ( 10 ) ; 
line 12229: if ( p == 0 ) return SQLITE_NOMEM ; 
line 12230: sqlite3_free ( p ) ; 
line 12231: return sqlite3_os_init ( ) ; 
line 12232: } 
line 12237: static sqlite3_vfs * SQLITE_WSD vfsList = 0 ; 
line 12238: # define vfsList GLOBAL ( sqlite3_vfs * , vfsList ) 
line 12244: SQLITE_API sqlite3_vfs * sqlite3_vfs_find ( const char * zVfs ) { 
line 12245: sqlite3_vfs * pVfs = 0 ; 
line 12246: # if SQLITE_THREADSAFE 
line 12247: sqlite3_mutex * mutex ; 
line 12248: # endif 
line 12249: # ifndef SQLITE_OMIT_AUTOINIT 
line 12250: int rc = sqlite3_initialize ( ) ; 
line 12251: if ( rc ) return 0 ; 
line 12252: # endif 
line 12253: # if SQLITE_THREADSAFE 
line 12254: mutex = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ; 
line 12255: # endif 
line 12256: sqlite3_mutex_enter ( mutex ) ; 
line 12257: for ( pVfs = vfsList ; pVfs ; pVfs = pVfs -> pNext ) { 
line 12258: if ( zVfs == 0 ) break ; 
line 12259: if ( strcmp ( zVfs , pVfs -> zName ) == 0 ) break ; 
line 12260: } 
line 12261: sqlite3_mutex_leave ( mutex ) ; 
line 12262: return pVfs ; 
line 12263: } 
line 12268: static void vfsUnlink ( sqlite3_vfs * pVfs ) { 
line 12269: assert ( sqlite3_mutex_held ( sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ) ) ; 
line 12270: if ( pVfs == 0 ) { 
line 12272: } else if ( vfsList == pVfs ) { 
line 12273: vfsList = pVfs -> pNext ; 
line 12274: } else if ( vfsList ) { 
line 12275: sqlite3_vfs * p = vfsList ; 
line 12276: while ( p -> pNext && p -> pNext != pVfs ) { 
line 12277: p = p -> pNext ; 
line 12278: } 
line 12279: if ( p -> pNext == pVfs ) { 
line 12280: p -> pNext = pVfs -> pNext ; 
line 12281: } 
line 12282: } 
line 12283: } 
line 12290: SQLITE_API int sqlite3_vfs_register ( sqlite3_vfs * pVfs , int makeDflt ) { 
line 12291: sqlite3_mutex * mutex = 0 ; 
line 12292: # ifndef SQLITE_OMIT_AUTOINIT 
line 12293: int rc = sqlite3_initialize ( ) ; 
line 12294: if ( rc ) return rc ; 
line 12295: # endif 
line 12296: mutex = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ; 
line 12297: sqlite3_mutex_enter ( mutex ) ; 
line 12298: vfsUnlink ( pVfs ) ; 
line 12299: if ( makeDflt || vfsList == 0 ) { 
line 12300: pVfs -> pNext = vfsList ; 
line 12301: vfsList = pVfs ; 
line 12302: } else { 
line 12303: pVfs -> pNext = vfsList -> pNext ; 
line 12304: vfsList -> pNext = pVfs ; 
line 12305: } 
line 12306: assert ( vfsList ) ; 
line 12307: sqlite3_mutex_leave ( mutex ) ; 
line 12308: return SQLITE_OK ; 
line 12309: } 
line 12314: SQLITE_API int sqlite3_vfs_unregister ( sqlite3_vfs * pVfs ) { 
line 12315: # if SQLITE_THREADSAFE 
line 12316: sqlite3_mutex * mutex = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ; 
line 12317: # endif 
line 12318: sqlite3_mutex_enter ( mutex ) ; 
line 12319: vfsUnlink ( pVfs ) ; 
line 12320: sqlite3_mutex_leave ( mutex ) ; 
line 12321: return SQLITE_OK ; 
line 12322: } 
line 12353: # ifndef SQLITE_OMIT_BUILTIN_TEST 
line 12358: typedef struct BenignMallocHooks BenignMallocHooks ; 
line 12359: static SQLITE_WSD struct BenignMallocHooks { 
line 12360: void ( * xBenignBegin ) ( void ) ; 
line 12361: void ( * xBenignEnd ) ( void ) ; 
line 12362: } sqlite3Hooks = { 0 , 0 } ; 
line 12370: # ifdef SQLITE_OMIT_WSD 
line 12371: # define wsdHooksInit 
line 12372: BenignMallocHooks * x = & GLOBAL ( BenignMallocHooks , sqlite3Hooks ) 
line 12373: # define wsdHooks x [ 0 ] 
line 12374: # else 
line 12375: # define wsdHooksInit 
line 12376: # define wsdHooks sqlite3Hooks 
line 12377: # endif 
line 12384: SQLITE_PRIVATE void sqlite3BenignMallocHooks ( 
line 12385: void ( * xBenignBegin ) ( void ) , 
line 12386: void ( * xBenignEnd ) ( void ) 
line 12387: ) { 
line 12388: wsdHooksInit ; 
line 12389: wsdHooks . xBenignBegin = xBenignBegin ; 
line 12390: wsdHooks . xBenignEnd = xBenignEnd ; 
line 12391: } 
line 12398: SQLITE_PRIVATE void sqlite3BeginBenignMalloc ( void ) { 
line 12399: wsdHooksInit ; 
line 12400: if ( wsdHooks . xBenignBegin ) { 
line 12401: wsdHooks . xBenignBegin ( ) ; 
line 12402: } 
line 12403: } 
line 12404: SQLITE_PRIVATE void sqlite3EndBenignMalloc ( void ) { 
line 12405: wsdHooksInit ; 
line 12406: if ( wsdHooks . xBenignEnd ) { 
line 12407: wsdHooks . xBenignEnd ( ) ; 
line 12408: } 
line 12409: } 
line 12411: # endif 
line 12439: # ifdef SQLITE_ZERO_MALLOC 
line 12444: static void * sqlite3MemMalloc ( int nByte ) { return 0 ; } 
line 12445: static void sqlite3MemFree ( void * pPrior ) { return ; } 
line 12446: static void * sqlite3MemRealloc ( void * pPrior , int nByte ) { return 0 ; } 
line 12447: static int sqlite3MemSize ( void * pPrior ) { return 0 ; } 
line 12448: static int sqlite3MemRoundup ( int n ) { return n ; } 
line 12449: static int sqlite3MemInit ( void * NotUsed ) { return SQLITE_OK ; } 
line 12450: static void sqlite3MemShutdown ( void * NotUsed ) { return ; } 
line 12458: SQLITE_PRIVATE void sqlite3MemSetDefault ( void ) { 
line 12459: static const sqlite3_mem_methods defaultMethods = { 
line 12460: sqlite3MemMalloc , 
line 12461: sqlite3MemFree , 
line 12462: sqlite3MemRealloc , 
line 12463: sqlite3MemSize , 
line 12464: sqlite3MemRoundup , 
line 12465: sqlite3MemInit , 
line 12466: sqlite3MemShutdown , 
line 12467: 0 
line 12468: } ; 
line 12469: sqlite3_config ( SQLITE_CONFIG_MALLOC , & defaultMethods ) ; 
line 12470: } 
line 12472: # endif 
line 12501: # ifdef SQLITE_SYSTEM_MALLOC 
line 12511: static void * sqlite3MemMalloc ( int nByte ) { 
line 12512: sqlite3_int64 * p ; 
line 12513: assert ( nByte > 0 ) ; 
line 12514: nByte = ROUND8 ( nByte ) ; 
line 12515: p = malloc ( nByte + 8 ) ; 
line 12516: if ( p ) { 
line 12517: p [ 0 ] = nByte ; 
line 12518: p ++ ; 
line 12519: } 
line 12520: return ( void * ) p ; 
line 12521: } 
line 12531: static void sqlite3MemFree ( void * pPrior ) { 
line 12532: sqlite3_int64 * p = ( sqlite3_int64 * ) pPrior ; 
line 12533: assert ( pPrior != 0 ) ; 
line 12534: p -- ; 
line 12535: free ( p ) ; 
line 12536: } 
line 12548: static void * sqlite3MemRealloc ( void * pPrior , int nByte ) { 
line 12549: sqlite3_int64 * p = ( sqlite3_int64 * ) pPrior ; 
line 12550: assert ( pPrior != 0 && nByte > 0 ) ; 
line 12551: nByte = ROUND8 ( nByte ) ; 
line 12552: p = ( sqlite3_int64 * ) pPrior ; 
line 12553: p -- ; 
line 12554: p = realloc ( p , nByte + 8 ) ; 
line 12555: if ( p ) { 
line 12556: p [ 0 ] = nByte ; 
line 12557: p ++ ; 
line 12558: } 
line 12559: return ( void * ) p ; 
line 12560: } 
line 12566: static int sqlite3MemSize ( void * pPrior ) { 
line 12567: sqlite3_int64 * p ; 
line 12568: if ( pPrior == 0 ) return 0 ; 
line 12569: p = ( sqlite3_int64 * ) pPrior ; 
line 12570: p -- ; 
line 12571: return ( int ) p [ 0 ] ; 
line 12572: } 
line 12577: static int sqlite3MemRoundup ( int n ) { 
line 12578: return ROUND8 ( n ) ; 
line 12579: } 
line 12584: static int sqlite3MemInit ( void * NotUsed ) { 
line 12585: UNUSED_PARAMETER ( NotUsed ) ; 
line 12586: return SQLITE_OK ; 
line 12587: } 
line 12592: static void sqlite3MemShutdown ( void * NotUsed ) { 
line 12593: UNUSED_PARAMETER ( NotUsed ) ; 
line 12594: return ; 
line 12595: } 
line 12603: SQLITE_PRIVATE void sqlite3MemSetDefault ( void ) { 
line 12604: static const sqlite3_mem_methods defaultMethods = { 
line 12605: sqlite3MemMalloc , 
line 12606: sqlite3MemFree , 
line 12607: sqlite3MemRealloc , 
line 12608: sqlite3MemSize , 
line 12609: sqlite3MemRoundup , 
line 12610: sqlite3MemInit , 
line 12611: sqlite3MemShutdown , 
line 12612: 0 
line 12613: } ; 
line 12614: sqlite3_config ( SQLITE_CONFIG_MALLOC , & defaultMethods ) ; 
line 12615: } 
line 12617: # endif 
line 12647: # ifdef SQLITE_MEMDEBUG 
line 12652: # ifdef __GLIBC__ 
line 12653: extern int backtrace ( void * * , int ) ; 
line 12654: extern void backtrace_symbols_fd ( void * const * , int , int ) ; 
line 12655: # else 
line 12656: # define backtrace ( A , B ) 1 
line 12657: # define backtrace_symbols_fd ( A , B , C ) 
line 12658: # endif 
line 12673: struct MemBlockHdr { 
line 12674: i64 iSize ; 
line 12675: struct MemBlockHdr * pNext , * pPrev ; 
line 12676: char nBacktrace ; 
line 12677: char nBacktraceSlots ; 
line 12678: short nTitle ; 
line 12679: int iForeGuard ; 
line 12680: } ; 
line 12685: # define FOREGUARD 0x80F5E153 
line 12686: # define REARGUARD 0xE4676B53 
line 12691: # define NCSIZE 1000 
line 12699: static struct { 
line 12704: sqlite3_mutex * mutex ; 
line 12709: struct MemBlockHdr * pFirst ; 
line 12710: struct MemBlockHdr * pLast ; 
line 12715: int nBacktrace ; 
line 12716: void ( * xBacktrace ) ( int , int , void * * ) ; 
line 12721: int nTitle ; 
line 12722: char zTitle [ 100 ] ; 
line 12728: int disallow ; 
line 12736: int nAlloc [ NCSIZE ] ; 
line 12737: int nCurrent [ NCSIZE ] ; 
line 12738: int mxCurrent [ NCSIZE ] ; 
line 12740: } mem ; 
line 12746: static void adjustStats ( int iSize , int increment ) { 
line 12747: int i = ROUND8 ( iSize ) / 8 ; 
line 12748: if ( i > NCSIZE - 1 ) { 
line 12749: i = NCSIZE - 1 ; 
line 12750: } 
line 12751: if ( increment > 0 ) { 
line 12752: mem . nAlloc [ i ] ++ ; 
line 12753: mem . nCurrent [ i ] ++ ; 
line 12754: if ( mem . nCurrent [ i ] > mem . mxCurrent [ i ] ) { 
line 12755: mem . mxCurrent [ i ] = mem . nCurrent [ i ] ; 
line 12756: } 
line 12757: } else { 
line 12758: mem . nCurrent [ i ] -- ; 
line 12759: assert ( mem . nCurrent [ i ] >= 0 ) ; 
line 12760: } 
line 12761: } 
line 12769: static struct MemBlockHdr * sqlite3MemsysGetHeader ( void * pAllocation ) { 
line 12770: struct MemBlockHdr * p ; 
line 12771: int * pInt ; 
line 12772: u8 * pU8 ; 
line 12773: int nReserve ; 
line 12775: p = ( struct MemBlockHdr * ) pAllocation ; 
line 12776: p -- ; 
line 12777: assert ( p -> iForeGuard == ( int ) FOREGUARD ) ; 
line 12778: nReserve = ROUND8 ( p -> iSize ) ; 
line 12779: pInt = ( int * ) pAllocation ; 
line 12780: pU8 = ( u8 * ) pAllocation ; 
line 12781: assert ( pInt [ nReserve / sizeof ( int ) ] == ( int ) REARGUARD ) ; 
line 12786: while ( nReserve -- > p -> iSize ) assert ( pU8 [ nReserve ] == 0x65 ) ; 
line 12787: return p ; 
line 12788: } 
line 12793: static int sqlite3MemSize ( void * p ) { 
line 12794: struct MemBlockHdr * pHdr ; 
line 12795: if ( ! p ) { 
line 12796: return 0 ; 
line 12797: } 
line 12798: pHdr = sqlite3MemsysGetHeader ( p ) ; 
line 12799: return pHdr -> iSize ; 
line 12800: } 
line 12805: static int sqlite3MemInit ( void * NotUsed ) { 
line 12806: UNUSED_PARAMETER ( NotUsed ) ; 
line 12807: assert ( ( sizeof ( struct MemBlockHdr ) & 7 ) == 0 ) ; 
line 12808: if ( ! sqlite3GlobalConfig . bMemstat ) { 
line 12811: mem . mutex = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MEM ) ; 
line 12812: } 
line 12813: return SQLITE_OK ; 
line 12814: } 
line 12819: static void sqlite3MemShutdown ( void * NotUsed ) { 
line 12820: UNUSED_PARAMETER ( NotUsed ) ; 
line 12821: mem . mutex = 0 ; 
line 12822: } 
line 12827: static int sqlite3MemRoundup ( int n ) { 
line 12828: return ROUND8 ( n ) ; 
line 12829: } 
line 12836: static void randomFill ( char * pBuf , int nByte ) { 
line 12837: unsigned int x , y , r ; 
line 12838: x = SQLITE_PTR_TO_INT ( pBuf ) ; 
line 12839: y = nByte | 1 ; 
line 12840: while ( nByte >= 4 ) { 
line 12841: x = ( x >> 1 ) ^ ( - ( x & 1 ) & 0xd0000001 ) ; 
line 12842: y = y * 1103515245 + 12345 ; 
line 12843: r = x ^ y ; 
line 12844: * ( int * ) pBuf = r ; 
line 12845: pBuf += 4 ; 
line 12846: nByte -= 4 ; 
line 12847: } 
line 12848: while ( nByte -- > 0 ) { 
line 12849: x = ( x >> 1 ) ^ ( - ( x & 1 ) & 0xd0000001 ) ; 
line 12850: y = y * 1103515245 + 12345 ; 
line 12851: r = x ^ y ; 
line 12852: * ( pBuf ++ ) = r & 0xff ; 
line 12853: } 
line 12854: } 
line 12859: static void * sqlite3MemMalloc ( int nByte ) { 
line 12860: struct MemBlockHdr * pHdr ; 
line 12861: void * * pBt ; 
line 12862: char * z ; 
line 12863: int * pInt ; 
line 12864: void * p = 0 ; 
line 12865: int totalSize ; 
line 12866: int nReserve ; 
line 12867: sqlite3_mutex_enter ( mem . mutex ) ; 
line 12868: assert ( mem . disallow == 0 ) ; 
line 12869: nReserve = ROUND8 ( nByte ) ; 
line 12870: totalSize = nReserve + sizeof ( * pHdr ) + sizeof ( int ) + 
line 12871: mem . nBacktrace * sizeof ( void * ) + mem . nTitle ; 
line 12872: p = malloc ( totalSize ) ; 
line 12873: if ( p ) { 
line 12874: z = p ; 
line 12875: pBt = ( void * * ) & z [ mem . nTitle ] ; 
line 12876: pHdr = ( struct MemBlockHdr * ) & pBt [ mem . nBacktrace ] ; 
line 12877: pHdr -> pNext = 0 ; 
line 12878: pHdr -> pPrev = mem . pLast ; 
line 12879: if ( mem . pLast ) { 
line 12880: mem . pLast -> pNext = pHdr ; 
line 12881: } else { 
line 12882: mem . pFirst = pHdr ; 
line 12883: } 
line 12884: mem . pLast = pHdr ; 
line 12885: pHdr -> iForeGuard = FOREGUARD ; 
line 12886: pHdr -> nBacktraceSlots = mem . nBacktrace ; 
line 12887: pHdr -> nTitle = mem . nTitle ; 
line 12888: if ( mem . nBacktrace ) { 
line 12889: void * aAddr [ 40 ] ; 
line 12890: pHdr -> nBacktrace = backtrace ( aAddr , mem . nBacktrace + 1 ) - 1 ; 
line 12891: memcpy ( pBt , & aAddr [ 1 ] , pHdr -> nBacktrace * sizeof ( void * ) ) ; 
line 12892: assert ( pBt [ 0 ] ) ; 
line 12893: if ( mem . xBacktrace ) { 
line 12894: mem . xBacktrace ( nByte , pHdr -> nBacktrace - 1 , & aAddr [ 1 ] ) ; 
line 12895: } 
line 12896: } else { 
line 12897: pHdr -> nBacktrace = 0 ; 
line 12898: } 
line 12899: if ( mem . nTitle ) { 
line 12900: memcpy ( z , mem . zTitle , mem . nTitle ) ; 
line 12901: } 
line 12902: pHdr -> iSize = nByte ; 
line 12903: adjustStats ( nByte , + 1 ) ; 
line 12904: pInt = ( int * ) & pHdr [ 1 ] ; 
line 12905: pInt [ nReserve / sizeof ( int ) ] = REARGUARD ; 
line 12906: randomFill ( ( char * ) pInt , nByte ) ; 
line 12907: memset ( ( ( char * ) pInt ) + nByte , 0x65 , nReserve - nByte ) ; 
line 12908: p = ( void * ) pInt ; 
line 12909: } 
line 12910: sqlite3_mutex_leave ( mem . mutex ) ; 
line 12911: return p ; 
line 12912: } 
line 12917: static void sqlite3MemFree ( void * pPrior ) { 
line 12918: struct MemBlockHdr * pHdr ; 
line 12919: void * * pBt ; 
line 12920: char * z ; 
line 12921: assert ( sqlite3GlobalConfig . bMemstat || mem . mutex != 0 ) ; 
line 12922: pHdr = sqlite3MemsysGetHeader ( pPrior ) ; 
line 12923: pBt = ( void * * ) pHdr ; 
line 12924: pBt -= pHdr -> nBacktraceSlots ; 
line 12925: sqlite3_mutex_enter ( mem . mutex ) ; 
line 12926: if ( pHdr -> pPrev ) { 
line 12927: assert ( pHdr -> pPrev -> pNext == pHdr ) ; 
line 12928: pHdr -> pPrev -> pNext = pHdr -> pNext ; 
line 12929: } else { 
line 12930: assert ( mem . pFirst == pHdr ) ; 
line 12931: mem . pFirst = pHdr -> pNext ; 
line 12932: } 
line 12933: if ( pHdr -> pNext ) { 
line 12934: assert ( pHdr -> pNext -> pPrev == pHdr ) ; 
line 12935: pHdr -> pNext -> pPrev = pHdr -> pPrev ; 
line 12936: } else { 
line 12937: assert ( mem . pLast == pHdr ) ; 
line 12938: mem . pLast = pHdr -> pPrev ; 
line 12939: } 
line 12940: z = ( char * ) pBt ; 
line 12941: z -= pHdr -> nTitle ; 
line 12942: adjustStats ( pHdr -> iSize , - 1 ) ; 
line 12943: randomFill ( z , sizeof ( void * ) * pHdr -> nBacktraceSlots + sizeof ( * pHdr ) + 
line 12944: pHdr -> iSize + sizeof ( int ) + pHdr -> nTitle ) ; 
line 12945: free ( z ) ; 
line 12946: sqlite3_mutex_leave ( mem . mutex ) ; 
line 12947: } 
line 12958: static void * sqlite3MemRealloc ( void * pPrior , int nByte ) { 
line 12959: struct MemBlockHdr * pOldHdr ; 
line 12960: void * pNew ; 
line 12961: assert ( mem . disallow == 0 ) ; 
line 12962: pOldHdr = sqlite3MemsysGetHeader ( pPrior ) ; 
line 12963: pNew = sqlite3MemMalloc ( nByte ) ; 
line 12964: if ( pNew ) { 
line 12965: memcpy ( pNew , pPrior , nByte < pOldHdr -> iSize ? nByte : pOldHdr -> iSize ) ; 
line 12966: if ( nByte > pOldHdr -> iSize ) { 
line 12967: randomFill ( & ( ( char * ) pNew ) [ pOldHdr -> iSize ] , nByte - pOldHdr -> iSize ) ; 
line 12968: } 
line 12969: sqlite3MemFree ( pPrior ) ; 
line 12970: } 
line 12971: return pNew ; 
line 12972: } 
line 12978: SQLITE_PRIVATE void sqlite3MemSetDefault ( void ) { 
line 12979: static const sqlite3_mem_methods defaultMethods = { 
line 12980: sqlite3MemMalloc , 
line 12981: sqlite3MemFree , 
line 12982: sqlite3MemRealloc , 
line 12983: sqlite3MemSize , 
line 12984: sqlite3MemRoundup , 
line 12985: sqlite3MemInit , 
line 12986: sqlite3MemShutdown , 
line 12987: 0 
line 12988: } ; 
line 12989: sqlite3_config ( SQLITE_CONFIG_MALLOC , & defaultMethods ) ; 
line 12990: } 
line 12997: SQLITE_PRIVATE void sqlite3MemdebugBacktrace ( int depth ) { 
line 12998: if ( depth < 0 ) { depth = 0 ; } 
line 12999: if ( depth > 20 ) { depth = 20 ; } 
line 13000: depth = ( depth + 1 ) & 0xfe ; 
line 13001: mem . nBacktrace = depth ; 
line 13002: } 
line 13004: SQLITE_PRIVATE void sqlite3MemdebugBacktraceCallback ( void ( * xBacktrace ) ( int , int , void * * ) ) { 
line 13005: mem . xBacktrace = xBacktrace ; 
line 13006: } 
line 13011: SQLITE_PRIVATE void sqlite3MemdebugSettitle ( const char * zTitle ) { 
line 13012: unsigned int n = sqlite3Strlen30 ( zTitle ) + 1 ; 
line 13013: sqlite3_mutex_enter ( mem . mutex ) ; 
line 13014: if ( n >= sizeof ( mem . zTitle ) ) n = sizeof ( mem . zTitle ) - 1 ; 
line 13015: memcpy ( mem . zTitle , zTitle , n ) ; 
line 13016: mem . zTitle [ n ] = 0 ; 
line 13017: mem . nTitle = ROUND8 ( n ) ; 
line 13018: sqlite3_mutex_leave ( mem . mutex ) ; 
line 13019: } 
line 13021: SQLITE_PRIVATE void sqlite3MemdebugSync ( ) { 
line 13022: struct MemBlockHdr * pHdr ; 
line 13023: for ( pHdr = mem . pFirst ; pHdr ; pHdr = pHdr -> pNext ) { 
line 13024: void * * pBt = ( void * * ) pHdr ; 
line 13025: pBt -= pHdr -> nBacktraceSlots ; 
line 13026: mem . xBacktrace ( pHdr -> iSize , pHdr -> nBacktrace - 1 , & pBt [ 1 ] ) ; 
line 13027: } 
line 13028: } 
line 13034: SQLITE_PRIVATE void sqlite3MemdebugDump ( const char * zFilename ) { 
line 13035: FILE * out ; 
line 13036: struct MemBlockHdr * pHdr ; 
line 13037: void * * pBt ; 
line 13038: int i ; 
line 13039: out = fopen ( zFilename , "w" ) ; 
line 13040: if ( out == 0 ) { 
line 13041: fprintf ( stderr , "** Unable to output memory debug output log: %s **\n" , 
line 13042: zFilename ) ; 
line 13043: return ; 
line 13044: } 
line 13045: for ( pHdr = mem . pFirst ; pHdr ; pHdr = pHdr -> pNext ) { 
line 13046: char * z = ( char * ) pHdr ; 
line 13047: z -= pHdr -> nBacktraceSlots * sizeof ( void * ) + pHdr -> nTitle ; 
line 13048: fprintf ( out , "**** %lld bytes at %p from %s ****\n" , 
line 13049: pHdr -> iSize , & pHdr [ 1 ] , pHdr -> nTitle ? z : "???" ) ; 
line 13050: if ( pHdr -> nBacktrace ) { 
line 13051: fflush ( out ) ; 
line 13052: pBt = ( void * * ) pHdr ; 
line 13053: pBt -= pHdr -> nBacktraceSlots ; 
line 13054: backtrace_symbols_fd ( pBt , pHdr -> nBacktrace , fileno ( out ) ) ; 
line 13055: fprintf ( out , "\n" ) ; 
line 13056: } 
line 13057: } 
line 13058: fprintf ( out , "COUNTS:\n" ) ; 
line 13059: for ( i = 0 ; i < NCSIZE - 1 ; i ++ ) { 
line 13060: if ( mem . nAlloc [ i ] ) { 
line 13061: fprintf ( out , "   %5d: %10d %10d %10d\n" , 
line 13062: i * 8 , mem . nAlloc [ i ] , mem . nCurrent [ i ] , mem . mxCurrent [ i ] ) ; 
line 13063: } 
line 13064: } 
line 13065: if ( mem . nAlloc [ NCSIZE - 1 ] ) { 
line 13066: fprintf ( out , "   %5d: %10d %10d %10d\n" , 
line 13067: NCSIZE * 8 - 8 , mem . nAlloc [ NCSIZE - 1 ] , 
line 13068: mem . nCurrent [ NCSIZE - 1 ] , mem . mxCurrent [ NCSIZE - 1 ] ) ; 
line 13069: } 
line 13070: fclose ( out ) ; 
line 13071: } 
line 13076: SQLITE_PRIVATE int sqlite3MemdebugMallocCount ( ) { 
line 13077: int i ; 
line 13078: int nTotal = 0 ; 
line 13079: for ( i = 0 ; i < NCSIZE ; i ++ ) { 
line 13080: nTotal += mem . nAlloc [ i ] ; 
line 13081: } 
line 13082: return nTotal ; 
line 13083: } 
line 13086: # endif 
line 13123: # ifdef SQLITE_ENABLE_MEMSYS3 
line 13128: # define MX_SMALL 10 
line 13134: # define N_HASH 61 
line 13168: typedef struct Mem3Block Mem3Block ; 
line 13169: struct Mem3Block { 
line 13170: union { 
line 13171: struct { 
line 13172: u32 prevSize ; 
line 13173: u32 size4x ; 
line 13174: } hdr ; 
line 13175: struct { 
line 13176: u32 next ; 
line 13177: u32 prev ; 
line 13178: } list ; 
line 13179: } u ; 
line 13180: } ; 
line 13188: static SQLITE_WSD struct Mem3Global { 
line 13193: u32 nPool ; 
line 13194: Mem3Block * aPool ; 
line 13199: int alarmBusy ; 
line 13204: sqlite3_mutex * mutex ; 
line 13209: u32 mnMaster ; 
line 13217: u32 iMaster ; 
line 13218: u32 szMaster ; 
line 13225: u32 aiSmall [ MX_SMALL - 1 ] ; 
line 13226: u32 aiHash [ N_HASH ] ; 
line 13227: } mem3 = { 97535575 } ; 
line 13229: # define mem3 GLOBAL ( struct Mem3Global , mem3 ) 
line 13235: static void memsys3UnlinkFromList ( u32 i , u32 * pRoot ) { 
line 13236: u32 next = mem3 . aPool [ i ] . u . list . next ; 
line 13237: u32 prev = mem3 . aPool [ i ] . u . list . prev ; 
line 13238: assert ( sqlite3_mutex_held ( mem3 . mutex ) ) ; 
line 13239: if ( prev == 0 ) { 
line 13240: * pRoot = next ; 
line 13241: } else { 
line 13242: mem3 . aPool [ prev ] . u . list . next = next ; 
line 13243: } 
line 13244: if ( next ) { 
line 13245: mem3 . aPool [ next ] . u . list . prev = prev ; 
line 13246: } 
line 13247: mem3 . aPool [ i ] . u . list . next = 0 ; 
line 13248: mem3 . aPool [ i ] . u . list . prev = 0 ; 
line 13249: } 
line 13255: static void memsys3Unlink ( u32 i ) { 
line 13256: u32 size , hash ; 
line 13257: assert ( sqlite3_mutex_held ( mem3 . mutex ) ) ; 
line 13258: assert ( ( mem3 . aPool [ i - 1 ] . u . hdr . size4x & 1 ) == 0 ) ; 
line 13259: assert ( i >= 1 ) ; 
line 13260: size = mem3 . aPool [ i - 1 ] . u . hdr . size4x / 4 ; 
line 13261: assert ( size == mem3 . aPool [ i + size - 1 ] . u . hdr . prevSize ) ; 
line 13262: assert ( size >= 2 ) ; 
line 13263: if ( size <= MX_SMALL ) { 
line 13264: memsys3UnlinkFromList ( i , & mem3 . aiSmall [ size - 2 ] ) ; 
line 13265: } else { 
line 13266: hash = size % N_HASH ; 
line 13267: memsys3UnlinkFromList ( i , & mem3 . aiHash [ hash ] ) ; 
line 13268: } 
line 13269: } 
line 13275: static void memsys3LinkIntoList ( u32 i , u32 * pRoot ) { 
line 13276: assert ( sqlite3_mutex_held ( mem3 . mutex ) ) ; 
line 13277: mem3 . aPool [ i ] . u . list . next = * pRoot ; 
line 13278: mem3 . aPool [ i ] . u . list . prev = 0 ; 
line 13279: if ( * pRoot ) { 
line 13280: mem3 . aPool [ * pRoot ] . u . list . prev = i ; 
line 13281: } 
line 13282: * pRoot = i ; 
line 13283: } 
line 13289: static void memsys3Link ( u32 i ) { 
line 13290: u32 size , hash ; 
line 13291: assert ( sqlite3_mutex_held ( mem3 . mutex ) ) ; 
line 13292: assert ( i >= 1 ) ; 
line 13293: assert ( ( mem3 . aPool [ i - 1 ] . u . hdr . size4x & 1 ) == 0 ) ; 
line 13294: size = mem3 . aPool [ i - 1 ] . u . hdr . size4x / 4 ; 
line 13295: assert ( size == mem3 . aPool [ i + size - 1 ] . u . hdr . prevSize ) ; 
line 13296: assert ( size >= 2 ) ; 
line 13297: if ( size <= MX_SMALL ) { 
line 13298: memsys3LinkIntoList ( i , & mem3 . aiSmall [ size - 2 ] ) ; 
line 13299: } else { 
line 13300: hash = size % N_HASH ; 
line 13301: memsys3LinkIntoList ( i , & mem3 . aiHash [ hash ] ) ; 
line 13302: } 
line 13303: } 
line 13310: static void memsys3Enter ( void ) { 
line 13311: if ( sqlite3GlobalConfig . bMemstat == 0 && mem3 . mutex == 0 ) { 
line 13312: mem3 . mutex = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MEM ) ; 
line 13313: } 
line 13314: sqlite3_mutex_enter ( mem3 . mutex ) ; 
line 13315: } 
line 13316: static void memsys3Leave ( void ) { 
line 13317: sqlite3_mutex_leave ( mem3 . mutex ) ; 
line 13318: } 
line 13323: static void memsys3OutOfMemory ( int nByte ) { 
line 13324: if ( ! mem3 . alarmBusy ) { 
line 13325: mem3 . alarmBusy = 1 ; 
line 13326: assert ( sqlite3_mutex_held ( mem3 . mutex ) ) ; 
line 13327: sqlite3_mutex_leave ( mem3 . mutex ) ; 
line 13328: sqlite3_release_memory ( nByte ) ; 
line 13329: sqlite3_mutex_enter ( mem3 . mutex ) ; 
line 13330: mem3 . alarmBusy = 0 ; 
line 13331: } 
line 13332: } 
line 13340: static void * memsys3Checkout ( u32 i , u32 nBlock ) { 
line 13341: u32 x ; 
line 13342: assert ( sqlite3_mutex_held ( mem3 . mutex ) ) ; 
line 13343: assert ( i >= 1 ) ; 
line 13344: assert ( mem3 . aPool [ i - 1 ] . u . hdr . size4x / 4 == nBlock ) ; 
line 13345: assert ( mem3 . aPool [ i + nBlock - 1 ] . u . hdr . prevSize == nBlock ) ; 
line 13346: x = mem3 . aPool [ i - 1 ] . u . hdr . size4x ; 
line 13347: mem3 . aPool [ i - 1 ] . u . hdr . size4x = nBlock * 4 | 1 | ( x & 2 ) ; 
line 13348: mem3 . aPool [ i + nBlock - 1 ] . u . hdr . prevSize = nBlock ; 
line 13349: mem3 . aPool [ i + nBlock - 1 ] . u . hdr . size4x |= 2 ; 
line 13350: return & mem3 . aPool [ i ] ; 
line 13351: } 
line 13358: static void * memsys3FromMaster ( u32 nBlock ) { 
line 13359: assert ( sqlite3_mutex_held ( mem3 . mutex ) ) ; 
line 13360: assert ( mem3 . szMaster >= nBlock ) ; 
line 13361: if ( nBlock >= mem3 . szMaster - 1 ) { 
line 13363: void * p = memsys3Checkout ( mem3 . iMaster , mem3 . szMaster ) ; 
line 13364: mem3 . iMaster = 0 ; 
line 13365: mem3 . szMaster = 0 ; 
line 13366: mem3 . mnMaster = 0 ; 
line 13367: return p ; 
line 13368: } else { 
line 13370: u32 newi , x ; 
line 13371: newi = mem3 . iMaster + mem3 . szMaster - nBlock ; 
line 13372: assert ( newi > mem3 . iMaster + 1 ) ; 
line 13373: mem3 . aPool [ mem3 . iMaster + mem3 . szMaster - 1 ] . u . hdr . prevSize = nBlock ; 
line 13374: mem3 . aPool [ mem3 . iMaster + mem3 . szMaster - 1 ] . u . hdr . size4x |= 2 ; 
line 13375: mem3 . aPool [ newi - 1 ] . u . hdr . size4x = nBlock * 4 + 1 ; 
line 13376: mem3 . szMaster -= nBlock ; 
line 13377: mem3 . aPool [ newi - 1 ] . u . hdr . prevSize = mem3 . szMaster ; 
line 13378: x = mem3 . aPool [ mem3 . iMaster - 1 ] . u . hdr . size4x & 2 ; 
line 13379: mem3 . aPool [ mem3 . iMaster - 1 ] . u . hdr . size4x = mem3 . szMaster * 4 | x ; 
line 13380: if ( mem3 . szMaster < mem3 . mnMaster ) { 
line 13381: mem3 . mnMaster = mem3 . szMaster ; 
line 13382: } 
line 13383: return ( void * ) & mem3 . aPool [ newi ] ; 
line 13384: } 
line 13385: } 
line 13403: static void memsys3Merge ( u32 * pRoot ) { 
line 13404: u32 iNext , prev , size , i , x ; 
line 13406: assert ( sqlite3_mutex_held ( mem3 . mutex ) ) ; 
line 13407: for ( i = * pRoot ; i > 0 ; i = iNext ) { 
line 13408: iNext = mem3 . aPool [ i ] . u . list . next ; 
line 13409: size = mem3 . aPool [ i - 1 ] . u . hdr . size4x ; 
line 13410: assert ( ( size & 1 ) == 0 ) ; 
line 13411: if ( ( size & 2 ) == 0 ) { 
line 13412: memsys3UnlinkFromList ( i , pRoot ) ; 
line 13413: assert ( i > mem3 . aPool [ i - 1 ] . u . hdr . prevSize ) ; 
line 13414: prev = i - mem3 . aPool [ i - 1 ] . u . hdr . prevSize ; 
line 13415: if ( prev == iNext ) { 
line 13416: iNext = mem3 . aPool [ prev ] . u . list . next ; 
line 13417: } 
line 13418: memsys3Unlink ( prev ) ; 
line 13419: size = i + size / 4 - prev ; 
line 13420: x = mem3 . aPool [ prev - 1 ] . u . hdr . size4x & 2 ; 
line 13421: mem3 . aPool [ prev - 1 ] . u . hdr . size4x = size * 4 | x ; 
line 13422: mem3 . aPool [ prev + size - 1 ] . u . hdr . prevSize = size ; 
line 13423: memsys3Link ( prev ) ; 
line 13424: i = prev ; 
line 13425: } else { 
line 13426: size /= 4 ; 
line 13427: } 
line 13428: if ( size > mem3 . szMaster ) { 
line 13429: mem3 . iMaster = i ; 
line 13430: mem3 . szMaster = size ; 
line 13431: } 
line 13432: } 
line 13433: } 
line 13442: static void * memsys3MallocUnsafe ( int nByte ) { 
line 13443: u32 i ; 
line 13444: u32 nBlock ; 
line 13445: u32 toFree ; 
line 13447: assert ( sqlite3_mutex_held ( mem3 . mutex ) ) ; 
line 13448: assert ( sizeof ( Mem3Block ) == 8 ) ; 
line 13449: if ( nByte <= 12 ) { 
line 13450: nBlock = 2 ; 
line 13451: } else { 
line 13452: nBlock = ( nByte + 11 ) / 8 ; 
line 13453: } 
line 13454: assert ( nBlock >= 2 ) ; 
line 13461: if ( nBlock <= MX_SMALL ) { 
line 13462: i = mem3 . aiSmall [ nBlock - 2 ] ; 
line 13463: if ( i > 0 ) { 
line 13464: memsys3UnlinkFromList ( i , & mem3 . aiSmall [ nBlock - 2 ] ) ; 
line 13465: return memsys3Checkout ( i , nBlock ) ; 
line 13466: } 
line 13467: } else { 
line 13468: int hash = nBlock % N_HASH ; 
line 13469: for ( i = mem3 . aiHash [ hash ] ; i > 0 ; i = mem3 . aPool [ i ] . u . list . next ) { 
line 13470: if ( mem3 . aPool [ i - 1 ] . u . hdr . size4x / 4 == nBlock ) { 
line 13471: memsys3UnlinkFromList ( i , & mem3 . aiHash [ hash ] ) ; 
line 13472: return memsys3Checkout ( i , nBlock ) ; 
line 13473: } 
line 13474: } 
line 13475: } 
line 13481: if ( mem3 . szMaster >= nBlock ) { 
line 13482: return memsys3FromMaster ( nBlock ) ; 
line 13483: } 
line 13493: for ( toFree = nBlock * 16 ; toFree < ( mem3 . nPool * 16 ) ; toFree *= 2 ) { 
line 13494: memsys3OutOfMemory ( toFree ) ; 
line 13495: if ( mem3 . iMaster ) { 
line 13496: memsys3Link ( mem3 . iMaster ) ; 
line 13497: mem3 . iMaster = 0 ; 
line 13498: mem3 . szMaster = 0 ; 
line 13499: } 
line 13500: for ( i = 0 ; i < N_HASH ; i ++ ) { 
line 13501: memsys3Merge ( & mem3 . aiHash [ i ] ) ; 
line 13502: } 
line 13503: for ( i = 0 ; i < MX_SMALL - 1 ; i ++ ) { 
line 13504: memsys3Merge ( & mem3 . aiSmall [ i ] ) ; 
line 13505: } 
line 13506: if ( mem3 . szMaster ) { 
line 13507: memsys3Unlink ( mem3 . iMaster ) ; 
line 13508: if ( mem3 . szMaster >= nBlock ) { 
line 13509: return memsys3FromMaster ( nBlock ) ; 
line 13510: } 
line 13511: } 
line 13512: } 
line 13515: return 0 ; 
line 13516: } 
line 13524: void memsys3FreeUnsafe ( void * pOld ) { 
line 13525: Mem3Block * p = ( Mem3Block * ) pOld ; 
line 13526: int i ; 
line 13527: u32 size , x ; 
line 13528: assert ( sqlite3_mutex_held ( mem3 . mutex ) ) ; 
line 13529: assert ( p > mem3 . aPool && p < & mem3 . aPool [ mem3 . nPool ] ) ; 
line 13530: i = p - mem3 . aPool ; 
line 13531: assert ( ( mem3 . aPool [ i - 1 ] . u . hdr . size4x & 1 ) == 1 ) ; 
line 13532: size = mem3 . aPool [ i - 1 ] . u . hdr . size4x / 4 ; 
line 13533: assert ( i + size <= mem3 . nPool + 1 ) ; 
line 13534: mem3 . aPool [ i - 1 ] . u . hdr . size4x &= ~ 1 ; 
line 13535: mem3 . aPool [ i + size - 1 ] . u . hdr . prevSize = size ; 
line 13536: mem3 . aPool [ i + size - 1 ] . u . hdr . size4x &= ~ 2 ; 
line 13537: memsys3Link ( i ) ; 
line 13540: if ( mem3 . iMaster ) { 
line 13541: while ( ( mem3 . aPool [ mem3 . iMaster - 1 ] . u . hdr . size4x & 2 ) == 0 ) { 
line 13542: size = mem3 . aPool [ mem3 . iMaster - 1 ] . u . hdr . prevSize ; 
line 13543: mem3 . iMaster -= size ; 
line 13544: mem3 . szMaster += size ; 
line 13545: memsys3Unlink ( mem3 . iMaster ) ; 
line 13546: x = mem3 . aPool [ mem3 . iMaster - 1 ] . u . hdr . size4x & 2 ; 
line 13547: mem3 . aPool [ mem3 . iMaster - 1 ] . u . hdr . size4x = mem3 . szMaster * 4 | x ; 
line 13548: mem3 . aPool [ mem3 . iMaster + mem3 . szMaster - 1 ] . u . hdr . prevSize = mem3 . szMaster ; 
line 13549: } 
line 13550: x = mem3 . aPool [ mem3 . iMaster - 1 ] . u . hdr . size4x & 2 ; 
line 13551: while ( ( mem3 . aPool [ mem3 . iMaster + mem3 . szMaster - 1 ] . u . hdr . size4x & 1 ) == 0 ) { 
line 13552: memsys3Unlink ( mem3 . iMaster + mem3 . szMaster ) ; 
line 13553: mem3 . szMaster += mem3 . aPool [ mem3 . iMaster + mem3 . szMaster - 1 ] . u . hdr . size4x / 4 ; 
line 13554: mem3 . aPool [ mem3 . iMaster - 1 ] . u . hdr . size4x = mem3 . szMaster * 4 | x ; 
line 13555: mem3 . aPool [ mem3 . iMaster + mem3 . szMaster - 1 ] . u . hdr . prevSize = mem3 . szMaster ; 
line 13556: } 
line 13557: } 
line 13558: } 
line 13565: static int memsys3Size ( void * p ) { 
line 13566: Mem3Block * pBlock ; 
line 13567: if ( p == 0 ) return 0 ; 
line 13568: pBlock = ( Mem3Block * ) p ; 
line 13569: assert ( ( pBlock [ - 1 ] . u . hdr . size4x & 1 ) != 0 ) ; 
line 13570: return ( pBlock [ - 1 ] . u . hdr . size4x & ~ 3 ) * 2 - 4 ; 
line 13571: } 
line 13576: static int memsys3Roundup ( int n ) { 
line 13577: if ( n <= 12 ) { 
line 13578: return 12 ; 
line 13579: } else { 
line 13580: return ( ( n + 11 ) & ~ 7 ) - 4 ; 
line 13581: } 
line 13582: } 
line 13587: static void * memsys3Malloc ( int nBytes ) { 
line 13588: sqlite3_int64 * p ; 
line 13589: assert ( nBytes > 0 ) ; 
line 13590: memsys3Enter ( ) ; 
line 13591: p = memsys3MallocUnsafe ( nBytes ) ; 
line 13592: memsys3Leave ( ) ; 
line 13593: return ( void * ) p ; 
line 13594: } 
line 13599: void memsys3Free ( void * pPrior ) { 
line 13600: assert ( pPrior ) ; 
line 13601: memsys3Enter ( ) ; 
line 13602: memsys3FreeUnsafe ( pPrior ) ; 
line 13603: memsys3Leave ( ) ; 
line 13604: } 
line 13609: void * memsys3Realloc ( void * pPrior , int nBytes ) { 
line 13610: int nOld ; 
line 13611: void * p ; 
line 13612: if ( pPrior == 0 ) { 
line 13613: return sqlite3_malloc ( nBytes ) ; 
line 13614: } 
line 13615: if ( nBytes <= 0 ) { 
line 13616: sqlite3_free ( pPrior ) ; 
line 13617: return 0 ; 
line 13618: } 
line 13619: nOld = memsys3Size ( pPrior ) ; 
line 13620: if ( nBytes <= nOld && nBytes >= nOld - 128 ) { 
line 13621: return pPrior ; 
line 13622: } 
line 13623: memsys3Enter ( ) ; 
line 13624: p = memsys3MallocUnsafe ( nBytes ) ; 
line 13625: if ( p ) { 
line 13626: if ( nOld < nBytes ) { 
line 13627: memcpy ( p , pPrior , nOld ) ; 
line 13628: } else { 
line 13629: memcpy ( p , pPrior , nBytes ) ; 
line 13630: } 
line 13631: memsys3FreeUnsafe ( pPrior ) ; 
line 13632: } 
line 13633: memsys3Leave ( ) ; 
line 13634: return p ; 
line 13635: } 
line 13640: static int memsys3Init ( void * NotUsed ) { 
line 13641: UNUSED_PARAMETER ( NotUsed ) ; 
line 13642: if ( ! sqlite3GlobalConfig . pHeap ) { 
line 13643: return SQLITE_ERROR ; 
line 13644: } 
line 13647: assert ( sizeof ( Mem3Block ) == 8 ) ; 
line 13648: mem3 . aPool = ( Mem3Block * ) sqlite3GlobalConfig . pHeap ; 
line 13649: mem3 . nPool = ( sqlite3GlobalConfig . nHeap / sizeof ( Mem3Block ) ) - 2 ; 
line 13652: mem3 . szMaster = mem3 . nPool ; 
line 13653: mem3 . mnMaster = mem3 . szMaster ; 
line 13654: mem3 . iMaster = 1 ; 
line 13655: mem3 . aPool [ 0 ] . u . hdr . size4x = ( mem3 . szMaster << 2 ) + 2 ; 
line 13656: mem3 . aPool [ mem3 . nPool ] . u . hdr . prevSize = mem3 . nPool ; 
line 13657: mem3 . aPool [ mem3 . nPool ] . u . hdr . size4x = 1 ; 
line 13659: return SQLITE_OK ; 
line 13660: } 
line 13665: static void memsys3Shutdown ( void * NotUsed ) { 
line 13666: UNUSED_PARAMETER ( NotUsed ) ; 
line 13667: mem3 . mutex = 0 ; 
line 13668: return ; 
line 13669: } 
line 13677: SQLITE_PRIVATE void sqlite3Memsys3Dump ( const char * zFilename ) { 
line 13678: # ifdef SQLITE_DEBUG 
line 13679: FILE * out ; 
line 13680: u32 i , j ; 
line 13681: u32 size ; 
line 13682: if ( zFilename == 0 || zFilename [ 0 ] == 0 ) { 
line 13683: out = stdout ; 
line 13684: } else { 
line 13685: out = fopen ( zFilename , "w" ) ; 
line 13686: if ( out == 0 ) { 
line 13687: fprintf ( stderr , "** Unable to output memory debug output log: %s **\n" , 
line 13688: zFilename ) ; 
line 13689: return ; 
line 13690: } 
line 13691: } 
line 13692: memsys3Enter ( ) ; 
line 13693: fprintf ( out , "CHUNKS:\n" ) ; 
line 13694: for ( i = 1 ; i <= mem3 . nPool ; i += size / 4 ) { 
line 13695: size = mem3 . aPool [ i - 1 ] . u . hdr . size4x ; 
line 13696: if ( size / 4 <= 1 ) { 
line 13697: fprintf ( out , "%p size error\n" , & mem3 . aPool [ i ] ) ; 
line 13698: assert ( 0 ) ; 
line 13699: break ; 
line 13700: } 
line 13701: if ( ( size & 1 ) == 0 && mem3 . aPool [ i + size / 4 - 1 ] . u . hdr . prevSize != size / 4 ) { 
line 13702: fprintf ( out , "%p tail size does not match\n" , & mem3 . aPool [ i ] ) ; 
line 13703: assert ( 0 ) ; 
line 13704: break ; 
line 13705: } 
line 13706: if ( ( ( mem3 . aPool [ i + size / 4 - 1 ] . u . hdr . size4x & 2 ) >> 1 ) != ( size & 1 ) ) { 
line 13707: fprintf ( out , "%p tail checkout bit is incorrect\n" , & mem3 . aPool [ i ] ) ; 
line 13708: assert ( 0 ) ; 
line 13709: break ; 
line 13710: } 
line 13711: if ( size & 1 ) { 
line 13712: fprintf ( out , "%p %6d bytes checked out\n" , & mem3 . aPool [ i ] , ( size / 4 ) * 8 - 8 ) ; 
line 13713: } else { 
line 13714: fprintf ( out , "%p %6d bytes free%s\n" , & mem3 . aPool [ i ] , ( size / 4 ) * 8 - 8 , 
line 13715: i == mem3 . iMaster ? " **master**" : "" ) ; 
line 13716: } 
line 13717: } 
line 13718: for ( i = 0 ; i < MX_SMALL - 1 ; i ++ ) { 
line 13719: if ( mem3 . aiSmall [ i ] == 0 ) continue ; 
line 13720: fprintf ( out , "small(%2d):" , i ) ; 
line 13721: for ( j = mem3 . aiSmall [ i ] ; j > 0 ; j = mem3 . aPool [ j ] . u . list . next ) { 
line 13722: fprintf ( out , " %p(%d)" , & mem3 . aPool [ j ] , 
line 13723: ( mem3 . aPool [ j - 1 ] . u . hdr . size4x / 4 ) * 8 - 8 ) ; 
line 13724: } 
line 13725: fprintf ( out , "\n" ) ; 
line 13726: } 
line 13727: for ( i = 0 ; i < N_HASH ; i ++ ) { 
line 13728: if ( mem3 . aiHash [ i ] == 0 ) continue ; 
line 13729: fprintf ( out , "hash(%2d):" , i ) ; 
line 13730: for ( j = mem3 . aiHash [ i ] ; j > 0 ; j = mem3 . aPool [ j ] . u . list . next ) { 
line 13731: fprintf ( out , " %p(%d)" , & mem3 . aPool [ j ] , 
line 13732: ( mem3 . aPool [ j - 1 ] . u . hdr . size4x / 4 ) * 8 - 8 ) ; 
line 13733: } 
line 13734: fprintf ( out , "\n" ) ; 
line 13735: } 
line 13736: fprintf ( out , "master=%d\n" , mem3 . iMaster ) ; 
line 13737: fprintf ( out , "nowUsed=%d\n" , mem3 . nPool * 8 - mem3 . szMaster * 8 ) ; 
line 13738: fprintf ( out , "mxUsed=%d\n" , mem3 . nPool * 8 - mem3 . mnMaster * 8 ) ; 
line 13739: sqlite3_mutex_leave ( mem3 . mutex ) ; 
line 13740: if ( out == stdout ) { 
line 13741: fflush ( stdout ) ; 
line 13742: } else { 
line 13743: fclose ( out ) ; 
line 13744: } 
line 13745: # else 
line 13746: UNUSED_PARAMETER ( zFilename ) ; 
line 13747: # endif 
line 13748: } 
line 13761: SQLITE_PRIVATE const sqlite3_mem_methods * sqlite3MemGetMemsys3 ( void ) { 
line 13762: static const sqlite3_mem_methods mempoolMethods = { 
line 13763: memsys3Malloc , 
line 13764: memsys3Free , 
line 13765: memsys3Realloc , 
line 13766: memsys3Size , 
line 13767: memsys3Roundup , 
line 13768: memsys3Init , 
line 13769: memsys3Shutdown , 
line 13770: 0 
line 13771: } ; 
line 13772: return & mempoolMethods ; 
line 13773: } 
line 13775: # endif 
line 13834: # ifdef SQLITE_ENABLE_MEMSYS5 
line 13844: typedef struct Mem5Link Mem5Link ; 
line 13845: struct Mem5Link { 
line 13846: int next ; 
line 13847: int prev ; 
line 13848: } ; 
line 13855: # define LOGMAX 30 
line 13860: # define CTRL_LOGSIZE 0x1f 
line 13861: # define CTRL_FREE 0x20 
line 13869: static SQLITE_WSD struct Mem5Global { 
line 13873: int szAtom ; 
line 13874: int nBlock ; 
line 13875: u8 * zPool ; 
line 13880: sqlite3_mutex * mutex ; 
line 13885: u64 nAlloc ; 
line 13886: u64 totalAlloc ; 
line 13887: u64 totalExcess ; 
line 13888: u32 currentOut ; 
line 13889: u32 currentCount ; 
line 13890: u32 maxOut ; 
line 13891: u32 maxCount ; 
line 13892: u32 maxRequest ; 
line 13899: int aiFreelist [ LOGMAX + 1 ] ; 
line 13905: u8 * aCtrl ; 
line 13907: } mem5 = { 0 } ; 
line 13912: # define mem5 GLOBAL ( struct Mem5Global , mem5 ) 
line 13918: # define MEM5LINK ( idx ) ( ( Mem5Link * ) ( & mem5 . zPool [ ( idx ) * mem5 . szAtom ] ) ) 
line 13924: static void memsys5Unlink ( int i , int iLogsize ) { 
line 13925: int next , prev ; 
line 13926: assert ( i >= 0 && i < mem5 . nBlock ) ; 
line 13927: assert ( iLogsize >= 0 && iLogsize <= LOGMAX ) ; 
line 13928: assert ( ( mem5 . aCtrl [ i ] & CTRL_LOGSIZE ) == iLogsize ) ; 
line 13930: next = MEM5LINK ( i ) -> next ; 
line 13931: prev = MEM5LINK ( i ) -> prev ; 
line 13932: if ( prev < 0 ) { 
line 13933: mem5 . aiFreelist [ iLogsize ] = next ; 
line 13934: } else { 
line 13935: MEM5LINK ( prev ) -> next = next ; 
line 13936: } 
line 13937: if ( next >= 0 ) { 
line 13938: MEM5LINK ( next ) -> prev = prev ; 
line 13939: } 
line 13940: } 
line 13946: static void memsys5Link ( int i , int iLogsize ) { 
line 13947: int x ; 
line 13948: assert ( sqlite3_mutex_held ( mem5 . mutex ) ) ; 
line 13949: assert ( i >= 0 && i < mem5 . nBlock ) ; 
line 13950: assert ( iLogsize >= 0 && iLogsize <= LOGMAX ) ; 
line 13951: assert ( ( mem5 . aCtrl [ i ] & CTRL_LOGSIZE ) == iLogsize ) ; 
line 13953: x = MEM5LINK ( i ) -> next = mem5 . aiFreelist [ iLogsize ] ; 
line 13954: MEM5LINK ( i ) -> prev = - 1 ; 
line 13955: if ( x >= 0 ) { 
line 13956: assert ( x < mem5 . nBlock ) ; 
line 13957: MEM5LINK ( x ) -> prev = i ; 
line 13958: } 
line 13959: mem5 . aiFreelist [ iLogsize ] = i ; 
line 13960: } 
line 13967: static void memsys5Enter ( void ) { 
line 13968: sqlite3_mutex_enter ( mem5 . mutex ) ; 
line 13969: } 
line 13970: static void memsys5Leave ( void ) { 
line 13971: sqlite3_mutex_leave ( mem5 . mutex ) ; 
line 13972: } 
line 13979: static int memsys5Size ( void * p ) { 
line 13980: int iSize = 0 ; 
line 13981: if ( p ) { 
line 13982: int i = ( ( u8 * ) p - mem5 . zPool ) / mem5 . szAtom ; 
line 13983: assert ( i >= 0 && i < mem5 . nBlock ) ; 
line 13984: iSize = mem5 . szAtom * ( 1 << ( mem5 . aCtrl [ i ] & CTRL_LOGSIZE ) ) ; 
line 13985: } 
line 13986: return iSize ; 
line 13987: } 
line 13993: static int memsys5UnlinkFirst ( int iLogsize ) { 
line 13994: int i ; 
line 13995: int iFirst ; 
line 13997: assert ( iLogsize >= 0 && iLogsize <= LOGMAX ) ; 
line 13998: i = iFirst = mem5 . aiFreelist [ iLogsize ] ; 
line 13999: assert ( iFirst >= 0 ) ; 
line 14000: while ( i > 0 ) { 
line 14001: if ( i < iFirst ) iFirst = i ; 
line 14002: i = MEM5LINK ( i ) -> next ; 
line 14003: } 
line 14004: memsys5Unlink ( iFirst , iLogsize ) ; 
line 14005: return iFirst ; 
line 14006: } 
line 14018: static void * memsys5MallocUnsafe ( int nByte ) { 
line 14019: int i ; 
line 14020: int iBin ; 
line 14021: int iFullSz ; 
line 14022: int iLogsize ; 
line 14025: assert ( nByte > 0 ) ; 
line 14029: if ( ( u32 ) nByte > mem5 . maxRequest ) { 
line 14030: mem5 . maxRequest = nByte ; 
line 14031: } 
line 14036: if ( nByte > 0x40000000 ) { 
line 14037: return 0 ; 
line 14038: } 
line 14041: for ( iFullSz = mem5 . szAtom , iLogsize = 0 ; iFullSz < nByte ; iFullSz *= 2 , iLogsize ++ ) { } 
line 14047: for ( iBin = iLogsize ; mem5 . aiFreelist [ iBin ] < 0 && iBin <= LOGMAX ; iBin ++ ) { } 
line 14048: if ( iBin > LOGMAX ) return 0 ; 
line 14049: i = memsys5UnlinkFirst ( iBin ) ; 
line 14050: while ( iBin > iLogsize ) { 
line 14051: int newSize ; 
line 14053: iBin -- ; 
line 14054: newSize = 1 << iBin ; 
line 14055: mem5 . aCtrl [ i + newSize ] = CTRL_FREE | iBin ; 
line 14056: memsys5Link ( i + newSize , iBin ) ; 
line 14057: } 
line 14058: mem5 . aCtrl [ i ] = iLogsize ; 
line 14061: mem5 . nAlloc ++ ; 
line 14062: mem5 . totalAlloc += iFullSz ; 
line 14063: mem5 . totalExcess += iFullSz - nByte ; 
line 14064: mem5 . currentCount ++ ; 
line 14065: mem5 . currentOut += iFullSz ; 
line 14066: if ( mem5 . maxCount < mem5 . currentCount ) mem5 . maxCount = mem5 . currentCount ; 
line 14067: if ( mem5 . maxOut < mem5 . currentOut ) mem5 . maxOut = mem5 . currentOut ; 
line 14070: return ( void * ) & mem5 . zPool [ i * mem5 . szAtom ] ; 
line 14071: } 
line 14076: static void memsys5FreeUnsafe ( void * pOld ) { 
line 14077: u32 size , iLogsize ; 
line 14078: int iBlock ; 
line 14083: iBlock = ( ( u8 * ) pOld - mem5 . zPool ) / mem5 . szAtom ; 
line 14086: assert ( iBlock >= 0 && iBlock < mem5 . nBlock ) ; 
line 14087: assert ( ( ( u8 * ) pOld - mem5 . zPool ) % mem5 . szAtom == 0 ) ; 
line 14088: assert ( ( mem5 . aCtrl [ iBlock ] & CTRL_FREE ) == 0 ) ; 
line 14090: iLogsize = mem5 . aCtrl [ iBlock ] & CTRL_LOGSIZE ; 
line 14091: size = 1 << iLogsize ; 
line 14092: assert ( iBlock + size - 1 < ( u32 ) mem5 . nBlock ) ; 
line 14094: mem5 . aCtrl [ iBlock ] |= CTRL_FREE ; 
line 14095: mem5 . aCtrl [ iBlock + size - 1 ] |= CTRL_FREE ; 
line 14096: assert ( mem5 . currentCount > 0 ) ; 
line 14097: assert ( mem5 . currentOut >= ( size * mem5 . szAtom ) ) ; 
line 14098: mem5 . currentCount -- ; 
line 14099: mem5 . currentOut -= size * mem5 . szAtom ; 
line 14100: assert ( mem5 . currentOut > 0 || mem5 . currentCount == 0 ) ; 
line 14101: assert ( mem5 . currentCount > 0 || mem5 . currentOut == 0 ) ; 
line 14103: mem5 . aCtrl [ iBlock ] = CTRL_FREE | iLogsize ; 
line 14104: while ( ALWAYS ( iLogsize < LOGMAX ) ) { 
line 14105: int iBuddy ; 
line 14106: if ( ( iBlock >> iLogsize ) & 1 ) { 
line 14107: iBuddy = iBlock - size ; 
line 14108: } else { 
line 14109: iBuddy = iBlock + size ; 
line 14110: } 
line 14111: assert ( iBuddy >= 0 ) ; 
line 14112: if ( ( iBuddy + ( 1 << iLogsize ) ) > mem5 . nBlock ) break ; 
line 14113: if ( mem5 . aCtrl [ iBuddy ] != ( CTRL_FREE | iLogsize ) ) break ; 
line 14114: memsys5Unlink ( iBuddy , iLogsize ) ; 
line 14115: iLogsize ++ ; 
line 14116: if ( iBuddy < iBlock ) { 
line 14117: mem5 . aCtrl [ iBuddy ] = CTRL_FREE | iLogsize ; 
line 14118: mem5 . aCtrl [ iBlock ] = 0 ; 
line 14119: iBlock = iBuddy ; 
line 14120: } else { 
line 14121: mem5 . aCtrl [ iBlock ] = CTRL_FREE | iLogsize ; 
line 14122: mem5 . aCtrl [ iBuddy ] = 0 ; 
line 14123: } 
line 14124: size *= 2 ; 
line 14125: } 
line 14126: memsys5Link ( iBlock , iLogsize ) ; 
line 14127: } 
line 14132: static void * memsys5Malloc ( int nBytes ) { 
line 14133: sqlite3_int64 * p = 0 ; 
line 14134: if ( nBytes > 0 ) { 
line 14135: memsys5Enter ( ) ; 
line 14136: p = memsys5MallocUnsafe ( nBytes ) ; 
line 14137: memsys5Leave ( ) ; 
line 14138: } 
line 14139: return ( void * ) p ; 
line 14140: } 
line 14148: static void memsys5Free ( void * pPrior ) { 
line 14149: assert ( pPrior != 0 ) ; 
line 14150: memsys5Enter ( ) ; 
line 14151: memsys5FreeUnsafe ( pPrior ) ; 
line 14152: memsys5Leave ( ) ; 
line 14153: } 
line 14167: static void * memsys5Realloc ( void * pPrior , int nBytes ) { 
line 14168: int nOld ; 
line 14169: void * p ; 
line 14170: assert ( pPrior != 0 ) ; 
line 14171: assert ( ( nBytes & ( nBytes - 1 ) ) == 0 ) ; 
line 14172: assert ( nBytes >= 0 ) ; 
line 14173: if ( nBytes == 0 ) { 
line 14174: return 0 ; 
line 14175: } 
line 14176: nOld = memsys5Size ( pPrior ) ; 
line 14177: if ( nBytes <= nOld ) { 
line 14178: return pPrior ; 
line 14179: } 
line 14180: memsys5Enter ( ) ; 
line 14181: p = memsys5MallocUnsafe ( nBytes ) ; 
line 14182: if ( p ) { 
line 14183: memcpy ( p , pPrior , nOld ) ; 
line 14184: memsys5FreeUnsafe ( pPrior ) ; 
line 14185: } 
line 14186: memsys5Leave ( ) ; 
line 14187: return p ; 
line 14188: } 
line 14199: static int memsys5Roundup ( int n ) { 
line 14200: int iFullSz ; 
line 14201: if ( n > 0x40000000 ) return 0 ; 
line 14202: for ( iFullSz = mem5 . szAtom ; iFullSz < n ; iFullSz *= 2 ) ; 
line 14203: return iFullSz ; 
line 14204: } 
line 14216: static int memsys5Log ( int iValue ) { 
line 14217: int iLog ; 
line 14218: for ( iLog = 0 ; ( 1 << iLog ) < iValue ; iLog ++ ) ; 
line 14219: return iLog ; 
line 14220: } 
line 14228: static int memsys5Init ( void * NotUsed ) { 
line 14229: int ii ; 
line 14230: int nByte ; 
line 14231: u8 * zByte ; 
line 14232: int nMinLog ; 
line 14233: int iOffset ; 
line 14235: UNUSED_PARAMETER ( NotUsed ) ; 
line 14238: mem5 . mutex = 0 ; 
line 14243: assert ( ( sizeof ( Mem5Link ) & ( sizeof ( Mem5Link ) - 1 ) ) == 0 ) ; 
line 14245: nByte = sqlite3GlobalConfig . nHeap ; 
line 14246: zByte = ( u8 * ) sqlite3GlobalConfig . pHeap ; 
line 14247: assert ( zByte != 0 ) ; 
line 14249: nMinLog = memsys5Log ( sqlite3GlobalConfig . mnReq ) ; 
line 14250: mem5 . szAtom = ( 1 << nMinLog ) ; 
line 14251: while ( ( int ) sizeof ( Mem5Link ) > mem5 . szAtom ) { 
line 14252: mem5 . szAtom = mem5 . szAtom << 1 ; 
line 14253: } 
line 14255: mem5 . nBlock = ( nByte / ( mem5 . szAtom + sizeof ( u8 ) ) ) ; 
line 14256: mem5 . zPool = zByte ; 
line 14257: mem5 . aCtrl = ( u8 * ) & mem5 . zPool [ mem5 . nBlock * mem5 . szAtom ] ; 
line 14259: for ( ii = 0 ; ii <= LOGMAX ; ii ++ ) { 
line 14260: mem5 . aiFreelist [ ii ] = - 1 ; 
line 14261: } 
line 14263: iOffset = 0 ; 
line 14264: for ( ii = LOGMAX ; ii >= 0 ; ii -- ) { 
line 14265: int nAlloc = ( 1 << ii ) ; 
line 14266: if ( ( iOffset + nAlloc ) <= mem5 . nBlock ) { 
line 14267: mem5 . aCtrl [ iOffset ] = ii | CTRL_FREE ; 
line 14268: memsys5Link ( iOffset , ii ) ; 
line 14269: iOffset += nAlloc ; 
line 14270: } 
line 14271: assert ( ( iOffset + nAlloc ) > mem5 . nBlock ) ; 
line 14272: } 
line 14275: if ( sqlite3GlobalConfig . bMemstat == 0 ) { 
line 14276: mem5 . mutex = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MEM ) ; 
line 14277: } 
line 14279: return SQLITE_OK ; 
line 14280: } 
line 14285: static void memsys5Shutdown ( void * NotUsed ) { 
line 14286: UNUSED_PARAMETER ( NotUsed ) ; 
line 14287: mem5 . mutex = 0 ; 
line 14288: return ; 
line 14289: } 
line 14291: # ifdef SQLITE_TEST 
line 14296: SQLITE_PRIVATE void sqlite3Memsys5Dump ( const char * zFilename ) { 
line 14297: FILE * out ; 
line 14298: int i , j , n ; 
line 14299: int nMinLog ; 
line 14301: if ( zFilename == 0 || zFilename [ 0 ] == 0 ) { 
line 14302: out = stdout ; 
line 14303: } else { 
line 14304: out = fopen ( zFilename , "w" ) ; 
line 14305: if ( out == 0 ) { 
line 14306: fprintf ( stderr , "** Unable to output memory debug output log: %s **\n" , 
line 14307: zFilename ) ; 
line 14308: return ; 
line 14309: } 
line 14310: } 
line 14311: memsys5Enter ( ) ; 
line 14312: nMinLog = memsys5Log ( mem5 . szAtom ) ; 
line 14313: for ( i = 0 ; i <= LOGMAX && i + nMinLog < 32 ; i ++ ) { 
line 14314: for ( n = 0 , j = mem5 . aiFreelist [ i ] ; j >= 0 ; j = MEM5LINK ( j ) -> next , n ++ ) { } 
line 14315: fprintf ( out , "freelist items of size %d: %d\n" , mem5 . szAtom << i , n ) ; 
line 14316: } 
line 14317: fprintf ( out , "mem5.nAlloc       = %llu\n" , mem5 . nAlloc ) ; 
line 14318: fprintf ( out , "mem5.totalAlloc   = %llu\n" , mem5 . totalAlloc ) ; 
line 14319: fprintf ( out , "mem5.totalExcess  = %llu\n" , mem5 . totalExcess ) ; 
line 14320: fprintf ( out , "mem5.currentOut   = %u\n" , mem5 . currentOut ) ; 
line 14321: fprintf ( out , "mem5.currentCount = %u\n" , mem5 . currentCount ) ; 
line 14322: fprintf ( out , "mem5.maxOut       = %u\n" , mem5 . maxOut ) ; 
line 14323: fprintf ( out , "mem5.maxCount     = %u\n" , mem5 . maxCount ) ; 
line 14324: fprintf ( out , "mem5.maxRequest   = %u\n" , mem5 . maxRequest ) ; 
line 14325: memsys5Leave ( ) ; 
line 14326: if ( out == stdout ) { 
line 14327: fflush ( stdout ) ; 
line 14328: } else { 
line 14329: fclose ( out ) ; 
line 14330: } 
line 14331: } 
line 14332: # endif 
line 14339: SQLITE_PRIVATE const sqlite3_mem_methods * sqlite3MemGetMemsys5 ( void ) { 
line 14340: static const sqlite3_mem_methods memsys5Methods = { 
line 14341: memsys5Malloc , 
line 14342: memsys5Free , 
line 14343: memsys5Realloc , 
line 14344: memsys5Size , 
line 14345: memsys5Roundup , 
line 14346: memsys5Init , 
line 14347: memsys5Shutdown , 
line 14348: 0 
line 14349: } ; 
line 14350: return & memsys5Methods ; 
line 14351: } 
line 14353: # endif 
line 14373: # if defined ( SQLITE_DEBUG ) && ! defined ( SQLITE_MUTEX_OMIT ) 
line 14379: static SQLITE_WSD int mutexIsInit = 0 ; 
line 14380: # endif 
line 14383: # ifndef SQLITE_MUTEX_OMIT 
line 14387: SQLITE_PRIVATE int sqlite3MutexInit ( void ) { 
line 14388: int rc = SQLITE_OK ; 
line 14389: if ( sqlite3GlobalConfig . bCoreMutex ) { 
line 14390: if ( ! sqlite3GlobalConfig . mutex . xMutexAlloc ) { 
line 14396: sqlite3_mutex_methods * pFrom = sqlite3DefaultMutex ( ) ; 
line 14397: sqlite3_mutex_methods * pTo = & sqlite3GlobalConfig . mutex ; 
line 14399: memcpy ( pTo , pFrom , offsetof ( sqlite3_mutex_methods , xMutexAlloc ) ) ; 
line 14400: memcpy ( & pTo -> xMutexFree , & pFrom -> xMutexFree , 
line 14401: sizeof ( * pTo ) - offsetof ( sqlite3_mutex_methods , xMutexFree ) ) ; 
line 14402: pTo -> xMutexAlloc = pFrom -> xMutexAlloc ; 
line 14403: } 
line 14404: rc = sqlite3GlobalConfig . mutex . xMutexInit ( ) ; 
line 14405: } 
line 14407: # ifdef SQLITE_DEBUG 
line 14408: GLOBAL ( int , mutexIsInit ) = 1 ; 
line 14409: # endif 
line 14411: return rc ; 
line 14412: } 
line 14418: SQLITE_PRIVATE int sqlite3MutexEnd ( void ) { 
line 14419: int rc = SQLITE_OK ; 
line 14420: if ( sqlite3GlobalConfig . mutex . xMutexEnd ) { 
line 14421: rc = sqlite3GlobalConfig . mutex . xMutexEnd ( ) ; 
line 14422: } 
line 14424: # ifdef SQLITE_DEBUG 
line 14425: GLOBAL ( int , mutexIsInit ) = 0 ; 
line 14426: # endif 
line 14428: return rc ; 
line 14429: } 
line 14434: SQLITE_API sqlite3_mutex * sqlite3_mutex_alloc ( int id ) { 
line 14435: # ifndef SQLITE_OMIT_AUTOINIT 
line 14436: if ( sqlite3_initialize ( ) ) return 0 ; 
line 14437: # endif 
line 14438: return sqlite3GlobalConfig . mutex . xMutexAlloc ( id ) ; 
line 14439: } 
line 14441: SQLITE_PRIVATE sqlite3_mutex * sqlite3MutexAlloc ( int id ) { 
line 14442: if ( ! sqlite3GlobalConfig . bCoreMutex ) { 
line 14443: return 0 ; 
line 14444: } 
line 14445: assert ( GLOBAL ( int , mutexIsInit ) ) ; 
line 14446: return sqlite3GlobalConfig . mutex . xMutexAlloc ( id ) ; 
line 14447: } 
line 14452: SQLITE_API void sqlite3_mutex_free ( sqlite3_mutex * p ) { 
line 14453: if ( p ) { 
line 14454: sqlite3GlobalConfig . mutex . xMutexFree ( p ) ; 
line 14455: } 
line 14456: } 
line 14462: SQLITE_API void sqlite3_mutex_enter ( sqlite3_mutex * p ) { 
line 14463: if ( p ) { 
line 14464: sqlite3GlobalConfig . mutex . xMutexEnter ( p ) ; 
line 14465: } 
line 14466: } 
line 14472: SQLITE_API int sqlite3_mutex_try ( sqlite3_mutex * p ) { 
line 14473: int rc = SQLITE_OK ; 
line 14474: if ( p ) { 
line 14475: return sqlite3GlobalConfig . mutex . xMutexTry ( p ) ; 
line 14476: } 
line 14477: return rc ; 
line 14478: } 
line 14486: SQLITE_API void sqlite3_mutex_leave ( sqlite3_mutex * p ) { 
line 14487: if ( p ) { 
line 14488: sqlite3GlobalConfig . mutex . xMutexLeave ( p ) ; 
line 14489: } 
line 14490: } 
line 14492: # ifndef NDEBUG 
line 14497: SQLITE_API int sqlite3_mutex_held ( sqlite3_mutex * p ) { 
line 14498: return p == 0 || sqlite3GlobalConfig . mutex . xMutexHeld ( p ) ; 
line 14499: } 
line 14500: SQLITE_API int sqlite3_mutex_notheld ( sqlite3_mutex * p ) { 
line 14501: return p == 0 || sqlite3GlobalConfig . mutex . xMutexNotheld ( p ) ; 
line 14502: } 
line 14503: # endif 
line 14505: # endif 
line 14538: # if defined ( SQLITE_MUTEX_NOOP ) && ! defined ( SQLITE_DEBUG ) 
line 14544: static int noopMutexHeld ( sqlite3_mutex * p ) { return 1 ; } 
line 14545: static int noopMutexNotheld ( sqlite3_mutex * p ) { return 1 ; } 
line 14546: static int noopMutexInit ( void ) { return SQLITE_OK ; } 
line 14547: static int noopMutexEnd ( void ) { return SQLITE_OK ; } 
line 14548: static sqlite3_mutex * noopMutexAlloc ( int id ) { return ( sqlite3_mutex * ) 8 ; } 
line 14549: static void noopMutexFree ( sqlite3_mutex * p ) { return ; } 
line 14550: static void noopMutexEnter ( sqlite3_mutex * p ) { return ; } 
line 14551: static int noopMutexTry ( sqlite3_mutex * p ) { return SQLITE_OK ; } 
line 14552: static void noopMutexLeave ( sqlite3_mutex * p ) { return ; } 
line 14554: SQLITE_PRIVATE sqlite3_mutex_methods * sqlite3DefaultMutex ( void ) { 
line 14555: static sqlite3_mutex_methods sMutex = { 
line 14556: noopMutexInit , 
line 14557: noopMutexEnd , 
line 14558: noopMutexAlloc , 
line 14559: noopMutexFree , 
line 14560: noopMutexEnter , 
line 14561: noopMutexTry , 
line 14562: noopMutexLeave , 
line 14564: noopMutexHeld , 
line 14565: noopMutexNotheld 
line 14566: } ; 
line 14568: return & sMutex ; 
line 14569: } 
line 14570: # endif 
line 14572: # if defined ( SQLITE_MUTEX_NOOP ) && defined ( SQLITE_DEBUG ) 
line 14582: struct sqlite3_mutex { 
line 14583: int id ; 
line 14584: int cnt ; 
line 14585: } ; 
line 14591: static int debugMutexHeld ( sqlite3_mutex * p ) { 
line 14592: return p == 0 || p -> cnt > 0 ; 
line 14593: } 
line 14594: static int debugMutexNotheld ( sqlite3_mutex * p ) { 
line 14595: return p == 0 || p -> cnt == 0 ; 
line 14596: } 
line 14601: static int debugMutexInit ( void ) { return SQLITE_OK ; } 
line 14602: static int debugMutexEnd ( void ) { return SQLITE_OK ; } 
line 14609: static sqlite3_mutex * debugMutexAlloc ( int id ) { 
line 14610: static sqlite3_mutex aStatic [ 6 ] ; 
line 14611: sqlite3_mutex * pNew = 0 ; 
line 14612: switch ( id ) { 
line 14613: case SQLITE_MUTEX_FAST : 
line 14614: case SQLITE_MUTEX_RECURSIVE : { 
line 14615: pNew = sqlite3Malloc ( sizeof ( * pNew ) ) ; 
line 14616: if ( pNew ) { 
line 14617: pNew -> id = id ; 
line 14618: pNew -> cnt = 0 ; 
line 14619: } 
line 14620: break ; 
line 14621: } 
line 14622: default : { 
line 14623: assert ( id - 2 >= 0 ) ; 
line 14624: assert ( id - 2 < ( int ) ( sizeof ( aStatic ) / sizeof ( aStatic [ 0 ] ) ) ) ; 
line 14625: pNew = & aStatic [ id - 2 ] ; 
line 14626: pNew -> id = id ; 
line 14627: break ; 
line 14628: } 
line 14629: } 
line 14630: return pNew ; 
line 14631: } 
line 14636: static void debugMutexFree ( sqlite3_mutex * p ) { 
line 14637: assert ( p -> cnt == 0 ) ; 
line 14638: assert ( p -> id == SQLITE_MUTEX_FAST || p -> id == SQLITE_MUTEX_RECURSIVE ) ; 
line 14639: sqlite3_free ( p ) ; 
line 14640: } 
line 14653: static void debugMutexEnter ( sqlite3_mutex * p ) { 
line 14654: assert ( p -> id == SQLITE_MUTEX_RECURSIVE || debugMutexNotheld ( p ) ) ; 
line 14655: p -> cnt ++ ; 
line 14656: } 
line 14657: static int debugMutexTry ( sqlite3_mutex * p ) { 
line 14658: assert ( p -> id == SQLITE_MUTEX_RECURSIVE || debugMutexNotheld ( p ) ) ; 
line 14659: p -> cnt ++ ; 
line 14660: return SQLITE_OK ; 
line 14661: } 
line 14669: static void debugMutexLeave ( sqlite3_mutex * p ) { 
line 14670: assert ( debugMutexHeld ( p ) ) ; 
line 14671: p -> cnt -- ; 
line 14672: assert ( p -> id == SQLITE_MUTEX_RECURSIVE || debugMutexNotheld ( p ) ) ; 
line 14673: } 
line 14675: SQLITE_PRIVATE sqlite3_mutex_methods * sqlite3DefaultMutex ( void ) { 
line 14676: static sqlite3_mutex_methods sMutex = { 
line 14677: debugMutexInit , 
line 14678: debugMutexEnd , 
line 14679: debugMutexAlloc , 
line 14680: debugMutexFree , 
line 14681: debugMutexEnter , 
line 14682: debugMutexTry , 
line 14683: debugMutexLeave , 
line 14685: debugMutexHeld , 
line 14686: debugMutexNotheld 
line 14687: } ; 
line 14689: return & sMutex ; 
line 14690: } 
line 14691: # endif 
line 14713: # ifdef SQLITE_MUTEX_OS2 
line 14724: struct sqlite3_mutex { 
line 14725: HMTX mutex ; 
line 14726: int id ; 
line 14727: int nRef ; 
line 14728: TID owner ; 
line 14729: } ; 
line 14731: # define OS2_MUTEX_INITIALIZER 0 , 0 , 0 , 0 
line 14736: static int os2MutexInit ( void ) { return SQLITE_OK ; } 
line 14737: static int os2MutexEnd ( void ) { return SQLITE_OK ; } 
line 14778: static sqlite3_mutex * os2MutexAlloc ( int iType ) { 
line 14779: sqlite3_mutex * p = NULL ; 
line 14780: switch ( iType ) { 
line 14781: case SQLITE_MUTEX_FAST : 
line 14782: case SQLITE_MUTEX_RECURSIVE : { 
line 14783: p = sqlite3MallocZero ( sizeof ( * p ) ) ; 
line 14784: if ( p ) { 
line 14785: p -> id = iType ; 
line 14786: if ( DosCreateMutexSem ( 0 , & p -> mutex , 0 , FALSE ) != NO_ERROR ) { 
line 14787: sqlite3_free ( p ) ; 
line 14788: p = NULL ; 
line 14789: } 
line 14790: } 
line 14791: break ; 
line 14792: } 
line 14793: default : { 
line 14794: static volatile int isInit = 0 ; 
line 14795: static sqlite3_mutex staticMutexes [ ] = { 
line 14796: { OS2_MUTEX_INITIALIZER , } , 
line 14797: { OS2_MUTEX_INITIALIZER , } , 
line 14798: { OS2_MUTEX_INITIALIZER , } , 
line 14799: { OS2_MUTEX_INITIALIZER , } , 
line 14800: { OS2_MUTEX_INITIALIZER , } , 
line 14801: { OS2_MUTEX_INITIALIZER , } , 
line 14802: } ; 
line 14803: if ( ! isInit ) { 
line 14804: APIRET rc ; 
line 14805: PTIB ptib ; 
line 14806: PPIB ppib ; 
line 14807: HMTX mutex ; 
line 14808: char name [ 32 ] ; 
line 14809: DosGetInfoBlocks ( & ptib , & ppib ) ; 
line 14810: sqlite3_snprintf ( sizeof ( name ) , name , "\\SEM32\\SQLITE%04x" , 
line 14811: ppib -> pib_ulpid ) ; 
line 14812: while ( ! isInit ) { 
line 14813: mutex = 0 ; 
line 14814: rc = DosCreateMutexSem ( name , & mutex , 0 , FALSE ) ; 
line 14815: if ( rc == NO_ERROR ) { 
line 14816: unsigned int i ; 
line 14817: if ( ! isInit ) { 
line 14818: for ( i = 0 ; i < sizeof ( staticMutexes ) / sizeof ( staticMutexes [ 0 ] ) ; i ++ ) { 
line 14819: DosCreateMutexSem ( 0 , & staticMutexes [ i ] . mutex , 0 , FALSE ) ; 
line 14820: } 
line 14821: isInit = 1 ; 
line 14822: } 
line 14823: DosCloseMutexSem ( mutex ) ; 
line 14824: } else if ( rc == ERROR_DUPLICATE_NAME ) { 
line 14825: DosSleep ( 1 ) ; 
line 14826: } else { 
line 14827: return p ; 
line 14828: } 
line 14829: } 
line 14830: } 
line 14831: assert ( iType - 2 >= 0 ) ; 
line 14832: assert ( iType - 2 < sizeof ( staticMutexes ) / sizeof ( staticMutexes [ 0 ] ) ) ; 
line 14833: p = & staticMutexes [ iType - 2 ] ; 
line 14834: p -> id = iType ; 
line 14835: break ; 
line 14836: } 
line 14837: } 
line 14838: return p ; 
line 14839: } 
line 14846: static void os2MutexFree ( sqlite3_mutex * p ) { 
line 14847: if ( p == 0 ) return ; 
line 14848: assert ( p -> nRef == 0 ) ; 
line 14849: assert ( p -> id == SQLITE_MUTEX_FAST || p -> id == SQLITE_MUTEX_RECURSIVE ) ; 
line 14850: DosCloseMutexSem ( p -> mutex ) ; 
line 14851: sqlite3_free ( p ) ; 
line 14852: } 
line 14854: # ifdef SQLITE_DEBUG 
line 14859: static int os2MutexHeld ( sqlite3_mutex * p ) { 
line 14860: TID tid ; 
line 14861: PID pid ; 
line 14862: ULONG ulCount ; 
line 14863: PTIB ptib ; 
line 14864: if ( p != 0 ) { 
line 14865: DosQueryMutexSem ( p -> mutex , & pid , & tid , & ulCount ) ; 
line 14866: } else { 
line 14867: DosGetInfoBlocks ( & ptib , NULL ) ; 
line 14868: tid = ptib -> tib_ptib2 -> tib2_ultid ; 
line 14869: } 
line 14870: return p == 0 || ( p -> nRef != 0 && p -> owner == tid ) ; 
line 14871: } 
line 14872: static int os2MutexNotheld ( sqlite3_mutex * p ) { 
line 14873: TID tid ; 
line 14874: PID pid ; 
line 14875: ULONG ulCount ; 
line 14876: PTIB ptib ; 
line 14877: if ( p != 0 ) { 
line 14878: DosQueryMutexSem ( p -> mutex , & pid , & tid , & ulCount ) ; 
line 14879: } else { 
line 14880: DosGetInfoBlocks ( & ptib , NULL ) ; 
line 14881: tid = ptib -> tib_ptib2 -> tib2_ultid ; 
line 14882: } 
line 14883: return p == 0 || p -> nRef == 0 || p -> owner != tid ; 
line 14884: } 
line 14885: # endif 
line 14898: static void os2MutexEnter ( sqlite3_mutex * p ) { 
line 14899: TID tid ; 
line 14900: PID holder1 ; 
line 14901: ULONG holder2 ; 
line 14902: if ( p == 0 ) return ; 
line 14903: assert ( p -> id == SQLITE_MUTEX_RECURSIVE || os2MutexNotheld ( p ) ) ; 
line 14904: DosRequestMutexSem ( p -> mutex , SEM_INDEFINITE_WAIT ) ; 
line 14905: DosQueryMutexSem ( p -> mutex , & holder1 , & tid , & holder2 ) ; 
line 14906: p -> owner = tid ; 
line 14907: p -> nRef ++ ; 
line 14908: } 
line 14909: static int os2MutexTry ( sqlite3_mutex * p ) { 
line 14910: int rc ; 
line 14911: TID tid ; 
line 14912: PID holder1 ; 
line 14913: ULONG holder2 ; 
line 14914: if ( p == 0 ) return SQLITE_OK ; 
line 14915: assert ( p -> id == SQLITE_MUTEX_RECURSIVE || os2MutexNotheld ( p ) ) ; 
line 14916: if ( DosRequestMutexSem ( p -> mutex , SEM_IMMEDIATE_RETURN ) == NO_ERROR ) { 
line 14917: DosQueryMutexSem ( p -> mutex , & holder1 , & tid , & holder2 ) ; 
line 14918: p -> owner = tid ; 
line 14919: p -> nRef ++ ; 
line 14920: rc = SQLITE_OK ; 
line 14921: } else { 
line 14922: rc = SQLITE_BUSY ; 
line 14923: } 
line 14925: return rc ; 
line 14926: } 
line 14934: static void os2MutexLeave ( sqlite3_mutex * p ) { 
line 14935: TID tid ; 
line 14936: PID holder1 ; 
line 14937: ULONG holder2 ; 
line 14938: if ( p == 0 ) return ; 
line 14939: assert ( p -> nRef > 0 ) ; 
line 14940: DosQueryMutexSem ( p -> mutex , & holder1 , & tid , & holder2 ) ; 
line 14941: assert ( p -> owner == tid ) ; 
line 14942: p -> nRef -- ; 
line 14943: assert ( p -> nRef == 0 || p -> id == SQLITE_MUTEX_RECURSIVE ) ; 
line 14944: DosReleaseMutexSem ( p -> mutex ) ; 
line 14945: } 
line 14947: SQLITE_PRIVATE sqlite3_mutex_methods * sqlite3DefaultMutex ( void ) { 
line 14948: static sqlite3_mutex_methods sMutex = { 
line 14949: os2MutexInit , 
line 14950: os2MutexEnd , 
line 14951: os2MutexAlloc , 
line 14952: os2MutexFree , 
line 14953: os2MutexEnter , 
line 14954: os2MutexTry , 
line 14955: os2MutexLeave , 
line 14956: # ifdef SQLITE_DEBUG 
line 14957: os2MutexHeld , 
line 14958: os2MutexNotheld 
line 14959: # endif 
line 14960: } ; 
line 14962: return & sMutex ; 
line 14963: } 
line 14964: # endif 
line 14989: # ifdef SQLITE_MUTEX_PTHREADS 
line 14991: # include < pthread . h > 
line 14997: struct sqlite3_mutex { 
line 14998: pthread_mutex_t mutex ; 
line 14999: int id ; 
line 15000: int nRef ; 
line 15001: pthread_t owner ; 
line 15002: # ifdef SQLITE_DEBUG 
line 15003: int trace ; 
line 15004: # endif 
line 15005: } ; 
line 15006: # ifdef SQLITE_DEBUG 
line 15007: # define SQLITE3_MUTEX_INITIALIZER { PTHREAD_MUTEX_INITIALIZER , 0 , 0 , ( pthread_t ) 0 , 0 } 
line 15008: # else 
line 15009: # define SQLITE3_MUTEX_INITIALIZER { PTHREAD_MUTEX_INITIALIZER , 0 , 0 , ( pthread_t ) 0 } 
line 15010: # endif 
line 15028: # if ! defined ( NDEBUG ) || defined ( SQLITE_DEBUG ) 
line 15029: static int pthreadMutexHeld ( sqlite3_mutex * p ) { 
line 15030: return ( p -> nRef != 0 && pthread_equal ( p -> owner , pthread_self ( ) ) ) ; 
line 15031: } 
line 15032: static int pthreadMutexNotheld ( sqlite3_mutex * p ) { 
line 15033: return p -> nRef == 0 || pthread_equal ( p -> owner , pthread_self ( ) ) == 0 ; 
line 15034: } 
line 15035: # endif 
line 15040: static int pthreadMutexInit ( void ) { return SQLITE_OK ; } 
line 15041: static int pthreadMutexEnd ( void ) { return SQLITE_OK ; } 
line 15085: static sqlite3_mutex * pthreadMutexAlloc ( int iType ) { 
line 15086: static sqlite3_mutex staticMutexes [ ] = { 
line 15087: SQLITE3_MUTEX_INITIALIZER , 
line 15088: SQLITE3_MUTEX_INITIALIZER , 
line 15089: SQLITE3_MUTEX_INITIALIZER , 
line 15090: SQLITE3_MUTEX_INITIALIZER , 
line 15091: SQLITE3_MUTEX_INITIALIZER , 
line 15092: SQLITE3_MUTEX_INITIALIZER 
line 15093: } ; 
line 15094: sqlite3_mutex * p ; 
line 15095: switch ( iType ) { 
line 15096: case SQLITE_MUTEX_RECURSIVE : { 
line 15097: p = sqlite3MallocZero ( sizeof ( * p ) ) ; 
line 15098: if ( p ) { 
line 15099: # ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX 
line 15102: pthread_mutex_init ( & p -> mutex , 0 ) ; 
line 15103: # else 
line 15105: pthread_mutexattr_t recursiveAttr ; 
line 15106: pthread_mutexattr_init ( & recursiveAttr ) ; 
line 15107: pthread_mutexattr_settype ( & recursiveAttr , PTHREAD_MUTEX_RECURSIVE ) ; 
line 15108: pthread_mutex_init ( & p -> mutex , & recursiveAttr ) ; 
line 15109: pthread_mutexattr_destroy ( & recursiveAttr ) ; 
line 15110: # endif 
line 15111: p -> id = iType ; 
line 15112: } 
line 15113: break ; 
line 15114: } 
line 15115: case SQLITE_MUTEX_FAST : { 
line 15116: p = sqlite3MallocZero ( sizeof ( * p ) ) ; 
line 15117: if ( p ) { 
line 15118: p -> id = iType ; 
line 15119: pthread_mutex_init ( & p -> mutex , 0 ) ; 
line 15120: } 
line 15121: break ; 
line 15122: } 
line 15123: default : { 
line 15124: assert ( iType - 2 >= 0 ) ; 
line 15125: assert ( iType - 2 < ArraySize ( staticMutexes ) ) ; 
line 15126: p = & staticMutexes [ iType - 2 ] ; 
line 15127: p -> id = iType ; 
line 15128: break ; 
line 15129: } 
line 15130: } 
line 15131: return p ; 
line 15132: } 
line 15140: static void pthreadMutexFree ( sqlite3_mutex * p ) { 
line 15141: assert ( p -> nRef == 0 ) ; 
line 15142: assert ( p -> id == SQLITE_MUTEX_FAST || p -> id == SQLITE_MUTEX_RECURSIVE ) ; 
line 15143: pthread_mutex_destroy ( & p -> mutex ) ; 
line 15144: sqlite3_free ( p ) ; 
line 15145: } 
line 15158: static void pthreadMutexEnter ( sqlite3_mutex * p ) { 
line 15159: assert ( p -> id == SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld ( p ) ) ; 
line 15161: # ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX 
line 15172: { 
line 15173: pthread_t self = pthread_self ( ) ; 
line 15174: if ( p -> nRef > 0 && pthread_equal ( p -> owner , self ) ) { 
line 15175: p -> nRef ++ ; 
line 15176: } else { 
line 15177: pthread_mutex_lock ( & p -> mutex ) ; 
line 15178: assert ( p -> nRef == 0 ) ; 
line 15179: p -> owner = self ; 
line 15180: p -> nRef = 1 ; 
line 15181: } 
line 15182: } 
line 15183: # else 
line 15186: pthread_mutex_lock ( & p -> mutex ) ; 
line 15187: p -> owner = pthread_self ( ) ; 
line 15188: p -> nRef ++ ; 
line 15189: # endif 
line 15191: # ifdef SQLITE_DEBUG 
line 15192: if ( p -> trace ) { 
line 15193: printf ( "enter mutex %p (%d) with nRef=%d\n" , p , p -> trace , p -> nRef ) ; 
line 15194: } 
line 15195: # endif 
line 15196: } 
line 15197: static int pthreadMutexTry ( sqlite3_mutex * p ) { 
line 15198: int rc ; 
line 15199: assert ( p -> id == SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld ( p ) ) ; 
line 15201: # ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX 
line 15212: { 
line 15213: pthread_t self = pthread_self ( ) ; 
line 15214: if ( p -> nRef > 0 && pthread_equal ( p -> owner , self ) ) { 
line 15215: p -> nRef ++ ; 
line 15216: rc = SQLITE_OK ; 
line 15217: } else if ( pthread_mutex_trylock ( & p -> mutex ) == 0 ) { 
line 15218: assert ( p -> nRef == 0 ) ; 
line 15219: p -> owner = self ; 
line 15220: p -> nRef = 1 ; 
line 15221: rc = SQLITE_OK ; 
line 15222: } else { 
line 15223: rc = SQLITE_BUSY ; 
line 15224: } 
line 15225: } 
line 15226: # else 
line 15229: if ( pthread_mutex_trylock ( & p -> mutex ) == 0 ) { 
line 15230: p -> owner = pthread_self ( ) ; 
line 15231: p -> nRef ++ ; 
line 15232: rc = SQLITE_OK ; 
line 15233: } else { 
line 15234: rc = SQLITE_BUSY ; 
line 15235: } 
line 15236: # endif 
line 15238: # ifdef SQLITE_DEBUG 
line 15239: if ( rc == SQLITE_OK && p -> trace ) { 
line 15240: printf ( "enter mutex %p (%d) with nRef=%d\n" , p , p -> trace , p -> nRef ) ; 
line 15241: } 
line 15242: # endif 
line 15243: return rc ; 
line 15244: } 
line 15252: static void pthreadMutexLeave ( sqlite3_mutex * p ) { 
line 15253: assert ( pthreadMutexHeld ( p ) ) ; 
line 15254: p -> nRef -- ; 
line 15255: assert ( p -> nRef == 0 || p -> id == SQLITE_MUTEX_RECURSIVE ) ; 
line 15257: # ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX 
line 15258: if ( p -> nRef == 0 ) { 
line 15259: pthread_mutex_unlock ( & p -> mutex ) ; 
line 15260: } 
line 15261: # else 
line 15262: pthread_mutex_unlock ( & p -> mutex ) ; 
line 15263: # endif 
line 15265: # ifdef SQLITE_DEBUG 
line 15266: if ( p -> trace ) { 
line 15267: printf ( "leave mutex %p (%d) with nRef=%d\n" , p , p -> trace , p -> nRef ) ; 
line 15268: } 
line 15269: # endif 
line 15270: } 
line 15272: SQLITE_PRIVATE sqlite3_mutex_methods * sqlite3DefaultMutex ( void ) { 
line 15273: static sqlite3_mutex_methods sMutex = { 
line 15274: pthreadMutexInit , 
line 15275: pthreadMutexEnd , 
line 15276: pthreadMutexAlloc , 
line 15277: pthreadMutexFree , 
line 15278: pthreadMutexEnter , 
line 15279: pthreadMutexTry , 
line 15280: pthreadMutexLeave , 
line 15281: # ifdef SQLITE_DEBUG 
line 15282: pthreadMutexHeld , 
line 15283: pthreadMutexNotheld 
line 15284: # else 
line 15285: 0 , 
line 15286: 0 
line 15287: # endif 
line 15288: } ; 
line 15290: return & sMutex ; 
line 15291: } 
line 15293: # endif 
line 15315: # ifdef SQLITE_MUTEX_W32 
line 15320: struct sqlite3_mutex { 
line 15321: CRITICAL_SECTION mutex ; 
line 15322: int id ; 
line 15323: int nRef ; 
line 15324: DWORD owner ; 
line 15325: } ; 
line 15344: # if 0 
line 15345: # if SQLITE_OS_WINCE 
line 15346: # define mutexIsNT ( ) ( 1 ) 
line 15347: # else 
line 15348: static int mutexIsNT ( void ) { 
line 15349: static int osType = 0 ; 
line 15350: if ( osType == 0 ) { 
line 15351: OSVERSIONINFO sInfo ; 
line 15352: sInfo . dwOSVersionInfoSize = sizeof ( sInfo ) ; 
line 15353: GetVersionEx ( & sInfo ) ; 
line 15354: osType = sInfo . dwPlatformId == VER_PLATFORM_WIN32_NT ? 2 : 1 ; 
line 15355: } 
line 15356: return osType == 2 ; 
line 15357: } 
line 15358: # endif 
line 15359: # endif 
line 15361: # ifdef SQLITE_DEBUG 
line 15366: static int winMutexHeld ( sqlite3_mutex * p ) { 
line 15367: return p -> nRef != 0 && p -> owner == GetCurrentThreadId ( ) ; 
line 15368: } 
line 15369: static int winMutexNotheld ( sqlite3_mutex * p ) { 
line 15370: return p -> nRef == 0 || p -> owner != GetCurrentThreadId ( ) ; 
line 15371: } 
line 15372: # endif 
line 15378: static sqlite3_mutex winMutex_staticMutexes [ 6 ] ; 
line 15379: static int winMutex_isInit = 0 ; 
line 15385: static long winMutex_lock = 0 ; 
line 15387: static int winMutexInit ( void ) { 
line 15389: if ( InterlockedCompareExchange ( & winMutex_lock , 1 , 0 ) == 0 ) { 
line 15390: int i ; 
line 15391: for ( i = 0 ; i < ArraySize ( winMutex_staticMutexes ) ; i ++ ) { 
line 15392: InitializeCriticalSection ( & winMutex_staticMutexes [ i ] . mutex ) ; 
line 15393: } 
line 15394: winMutex_isInit = 1 ; 
line 15395: } else { 
line 15397: while ( ! winMutex_isInit ) { 
line 15398: Sleep ( 1 ) ; 
line 15399: } 
line 15400: } 
line 15401: return SQLITE_OK ; 
line 15402: } 
line 15404: static int winMutexEnd ( void ) { 
line 15407: if ( InterlockedCompareExchange ( & winMutex_lock , 0 , 1 ) == 1 ) { 
line 15408: if ( winMutex_isInit == 1 ) { 
line 15409: int i ; 
line 15410: for ( i = 0 ; i < ArraySize ( winMutex_staticMutexes ) ; i ++ ) { 
line 15411: DeleteCriticalSection ( & winMutex_staticMutexes [ i ] . mutex ) ; 
line 15412: } 
line 15413: winMutex_isInit = 0 ; 
line 15414: } 
line 15415: } 
line 15416: return SQLITE_OK ; 
line 15417: } 
line 15461: static sqlite3_mutex * winMutexAlloc ( int iType ) { 
line 15462: sqlite3_mutex * p ; 
line 15464: switch ( iType ) { 
line 15465: case SQLITE_MUTEX_FAST : 
line 15466: case SQLITE_MUTEX_RECURSIVE : { 
line 15467: p = sqlite3MallocZero ( sizeof ( * p ) ) ; 
line 15468: if ( p ) { 
line 15469: p -> id = iType ; 
line 15470: InitializeCriticalSection ( & p -> mutex ) ; 
line 15471: } 
line 15472: break ; 
line 15473: } 
line 15474: default : { 
line 15475: assert ( winMutex_isInit == 1 ) ; 
line 15476: assert ( iType - 2 >= 0 ) ; 
line 15477: assert ( iType - 2 < ArraySize ( winMutex_staticMutexes ) ) ; 
line 15478: p = & winMutex_staticMutexes [ iType - 2 ] ; 
line 15479: p -> id = iType ; 
line 15480: break ; 
line 15481: } 
line 15482: } 
line 15483: return p ; 
line 15484: } 
line 15492: static void winMutexFree ( sqlite3_mutex * p ) { 
line 15493: assert ( p ) ; 
line 15494: assert ( p -> nRef == 0 ) ; 
line 15495: assert ( p -> id == SQLITE_MUTEX_FAST || p -> id == SQLITE_MUTEX_RECURSIVE ) ; 
line 15496: DeleteCriticalSection ( & p -> mutex ) ; 
line 15497: sqlite3_free ( p ) ; 
line 15498: } 
line 15511: static void winMutexEnter ( sqlite3_mutex * p ) { 
line 15512: assert ( p -> id == SQLITE_MUTEX_RECURSIVE || winMutexNotheld ( p ) ) ; 
line 15513: EnterCriticalSection ( & p -> mutex ) ; 
line 15514: p -> owner = GetCurrentThreadId ( ) ; 
line 15515: p -> nRef ++ ; 
line 15516: } 
line 15517: static int winMutexTry ( sqlite3_mutex * p ) { 
line 15518: int rc = SQLITE_BUSY ; 
line 15519: assert ( p -> id == SQLITE_MUTEX_RECURSIVE || winMutexNotheld ( p ) ) ; 
line 15531: # if 0 
line 15532: if ( mutexIsNT ( ) && TryEnterCriticalSection ( & p -> mutex ) ) { 
line 15533: p -> owner = GetCurrentThreadId ( ) ; 
line 15534: p -> nRef ++ ; 
line 15535: rc = SQLITE_OK ; 
line 15536: } 
line 15537: # else 
line 15538: UNUSED_PARAMETER ( p ) ; 
line 15539: # endif 
line 15540: return rc ; 
line 15541: } 
line 15549: static void winMutexLeave ( sqlite3_mutex * p ) { 
line 15550: assert ( p -> nRef > 0 ) ; 
line 15551: assert ( p -> owner == GetCurrentThreadId ( ) ) ; 
line 15552: p -> nRef -- ; 
line 15553: assert ( p -> nRef == 0 || p -> id == SQLITE_MUTEX_RECURSIVE ) ; 
line 15554: LeaveCriticalSection ( & p -> mutex ) ; 
line 15555: } 
line 15557: SQLITE_PRIVATE sqlite3_mutex_methods * sqlite3DefaultMutex ( void ) { 
line 15558: static sqlite3_mutex_methods sMutex = { 
line 15559: winMutexInit , 
line 15560: winMutexEnd , 
line 15561: winMutexAlloc , 
line 15562: winMutexFree , 
line 15563: winMutexEnter , 
line 15564: winMutexTry , 
line 15565: winMutexLeave , 
line 15566: # ifdef SQLITE_DEBUG 
line 15567: winMutexHeld , 
line 15568: winMutexNotheld 
line 15569: # else 
line 15570: 0 , 
line 15571: 0 
line 15572: # endif 
line 15573: } ; 
line 15575: return & sMutex ; 
line 15576: } 
line 15577: # endif 
line 15601: static void softHeapLimitEnforcer ( 
line 15602: void * NotUsed , 
line 15603: sqlite3_int64 NotUsed2 , 
line 15604: int allocSize 
line 15605: ) { 
line 15606: UNUSED_PARAMETER2 ( NotUsed , NotUsed2 ) ; 
line 15607: sqlite3_release_memory ( allocSize ) ; 
line 15608: } 
line 15614: SQLITE_API void sqlite3_soft_heap_limit ( int n ) { 
line 15615: sqlite3_uint64 iLimit ; 
line 15616: int overage ; 
line 15617: if ( n < 0 ) { 
line 15618: iLimit = 0 ; 
line 15619: } else { 
line 15620: iLimit = n ; 
line 15621: } 
line 15622: # ifndef SQLITE_OMIT_AUTOINIT 
line 15623: sqlite3_initialize ( ) ; 
line 15624: # endif 
line 15625: if ( iLimit > 0 ) { 
line 15626: sqlite3MemoryAlarm ( softHeapLimitEnforcer , 0 , iLimit ) ; 
line 15627: } else { 
line 15628: sqlite3MemoryAlarm ( 0 , 0 , 0 ) ; 
line 15629: } 
line 15630: overage = ( int ) ( sqlite3_memory_used ( ) - ( i64 ) n ) ; 
line 15631: if ( overage > 0 ) { 
line 15632: sqlite3_release_memory ( overage ) ; 
line 15633: } 
line 15634: } 
line 15641: SQLITE_API int sqlite3_release_memory ( int n ) { 
line 15642: # ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT 
line 15643: int nRet = 0 ; 
line 15644: nRet += sqlite3PcacheReleaseMemory ( n - nRet ) ; 
line 15645: return nRet ; 
line 15646: # else 
line 15647: UNUSED_PARAMETER ( n ) ; 
line 15648: return SQLITE_OK ; 
line 15649: # endif 
line 15650: } 
line 15655: static SQLITE_WSD struct Mem0Global { 
line 15657: u32 nScratchFree ; 
line 15658: u32 nPageFree ; 
line 15660: sqlite3_mutex * mutex ; 
line 15668: sqlite3_int64 alarmThreshold ; 
line 15669: void ( * alarmCallback ) ( void * , sqlite3_int64 , int ) ; 
line 15670: void * alarmArg ; 
line 15677: u32 * aScratchFree ; 
line 15678: u32 * aPageFree ; 
line 15679: } mem0 = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; 
line 15681: # define mem0 GLOBAL ( struct Mem0Global , mem0 ) 
line 15686: SQLITE_PRIVATE int sqlite3MallocInit ( void ) { 
line 15687: if ( sqlite3GlobalConfig . m . xMalloc == 0 ) { 
line 15688: sqlite3MemSetDefault ( ) ; 
line 15689: } 
line 15690: memset ( & mem0 , 0 , sizeof ( mem0 ) ) ; 
line 15691: if ( sqlite3GlobalConfig . bCoreMutex ) { 
line 15692: mem0 . mutex = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MEM ) ; 
line 15693: } 
line 15694: if ( sqlite3GlobalConfig . pScratch && sqlite3GlobalConfig . szScratch >= 100 
line 15695: && sqlite3GlobalConfig . nScratch >= 0 ) { 
line 15696: int i ; 
line 15697: sqlite3GlobalConfig . szScratch = ROUNDDOWN8 ( sqlite3GlobalConfig . szScratch - 4 ) ; 
line 15698: mem0 . aScratchFree = ( u32 * ) & ( ( char * ) sqlite3GlobalConfig . pScratch ) 
line 15699: [ sqlite3GlobalConfig . szScratch * sqlite3GlobalConfig . nScratch ] ; 
line 15700: for ( i = 0 ; i < sqlite3GlobalConfig . nScratch ; i ++ ) { mem0 . aScratchFree [ i ] = i ; } 
line 15701: mem0 . nScratchFree = sqlite3GlobalConfig . nScratch ; 
line 15702: } else { 
line 15703: sqlite3GlobalConfig . pScratch = 0 ; 
line 15704: sqlite3GlobalConfig . szScratch = 0 ; 
line 15705: } 
line 15706: if ( sqlite3GlobalConfig . pPage && sqlite3GlobalConfig . szPage >= 512 
line 15707: && sqlite3GlobalConfig . nPage >= 1 ) { 
line 15708: int i ; 
line 15709: int overhead ; 
line 15710: int sz = ROUNDDOWN8 ( sqlite3GlobalConfig . szPage ) ; 
line 15711: int n = sqlite3GlobalConfig . nPage ; 
line 15712: overhead = ( 4 * n + sz - 1 ) / sz ; 
line 15713: sqlite3GlobalConfig . nPage -= overhead ; 
line 15714: mem0 . aPageFree = ( u32 * ) & ( ( char * ) sqlite3GlobalConfig . pPage ) 
line 15715: [ sqlite3GlobalConfig . szPage * sqlite3GlobalConfig . nPage ] ; 
line 15716: for ( i = 0 ; i < sqlite3GlobalConfig . nPage ; i ++ ) { mem0 . aPageFree [ i ] = i ; } 
line 15717: mem0 . nPageFree = sqlite3GlobalConfig . nPage ; 
line 15718: } else { 
line 15719: sqlite3GlobalConfig . pPage = 0 ; 
line 15720: sqlite3GlobalConfig . szPage = 0 ; 
line 15721: } 
line 15722: return sqlite3GlobalConfig . m . xInit ( sqlite3GlobalConfig . m . pAppData ) ; 
line 15723: } 
line 15728: SQLITE_PRIVATE void sqlite3MallocEnd ( void ) { 
line 15729: if ( sqlite3GlobalConfig . m . xShutdown ) { 
line 15730: sqlite3GlobalConfig . m . xShutdown ( sqlite3GlobalConfig . m . pAppData ) ; 
line 15731: } 
line 15732: memset ( & mem0 , 0 , sizeof ( mem0 ) ) ; 
line 15733: } 
line 15738: SQLITE_API sqlite3_int64 sqlite3_memory_used ( void ) { 
line 15739: int n , mx ; 
line 15740: sqlite3_int64 res ; 
line 15741: sqlite3_status ( SQLITE_STATUS_MEMORY_USED , & n , & mx , 0 ) ; 
line 15742: res = ( sqlite3_int64 ) n ; 
line 15743: return res ; 
line 15744: } 
line 15751: SQLITE_API sqlite3_int64 sqlite3_memory_highwater ( int resetFlag ) { 
line 15752: int n , mx ; 
line 15753: sqlite3_int64 res ; 
line 15754: sqlite3_status ( SQLITE_STATUS_MEMORY_USED , & n , & mx , resetFlag ) ; 
line 15755: res = ( sqlite3_int64 ) mx ; 
line 15756: return res ; 
line 15757: } 
line 15762: SQLITE_PRIVATE int sqlite3MemoryAlarm ( 
line 15763: void ( * xCallback ) ( void * pArg , sqlite3_int64 used , int N ) , 
line 15764: void * pArg , 
line 15765: sqlite3_int64 iThreshold 
line 15766: ) { 
line 15767: sqlite3_mutex_enter ( mem0 . mutex ) ; 
line 15768: mem0 . alarmCallback = xCallback ; 
line 15769: mem0 . alarmArg = pArg ; 
line 15770: mem0 . alarmThreshold = iThreshold ; 
line 15771: sqlite3_mutex_leave ( mem0 . mutex ) ; 
line 15772: return SQLITE_OK ; 
line 15773: } 
line 15775: # ifndef SQLITE_OMIT_DEPRECATED 
line 15780: SQLITE_API int sqlite3_memory_alarm ( 
line 15781: void ( * xCallback ) ( void * pArg , sqlite3_int64 used , int N ) , 
line 15782: void * pArg , 
line 15783: sqlite3_int64 iThreshold 
line 15784: ) { 
line 15785: return sqlite3MemoryAlarm ( xCallback , pArg , iThreshold ) ; 
line 15786: } 
line 15787: # endif 
line 15792: static void sqlite3MallocAlarm ( int nByte ) { 
line 15793: void ( * xCallback ) ( void * , sqlite3_int64 , int ) ; 
line 15794: sqlite3_int64 nowUsed ; 
line 15795: void * pArg ; 
line 15796: if ( mem0 . alarmCallback == 0 ) return ; 
line 15797: xCallback = mem0 . alarmCallback ; 
line 15798: nowUsed = sqlite3StatusValue ( SQLITE_STATUS_MEMORY_USED ) ; 
line 15799: pArg = mem0 . alarmArg ; 
line 15800: mem0 . alarmCallback = 0 ; 
line 15801: sqlite3_mutex_leave ( mem0 . mutex ) ; 
line 15802: xCallback ( pArg , nowUsed , nByte ) ; 
line 15803: sqlite3_mutex_enter ( mem0 . mutex ) ; 
line 15804: mem0 . alarmCallback = xCallback ; 
line 15805: mem0 . alarmArg = pArg ; 
line 15806: } 
line 15812: static int mallocWithAlarm ( int n , void * * pp ) { 
line 15813: int nFull ; 
line 15814: void * p ; 
line 15815: assert ( sqlite3_mutex_held ( mem0 . mutex ) ) ; 
line 15816: nFull = sqlite3GlobalConfig . m . xRoundup ( n ) ; 
line 15817: sqlite3StatusSet ( SQLITE_STATUS_MALLOC_SIZE , n ) ; 
line 15818: if ( mem0 . alarmCallback != 0 ) { 
line 15819: int nUsed = sqlite3StatusValue ( SQLITE_STATUS_MEMORY_USED ) ; 
line 15820: if ( nUsed + nFull >= mem0 . alarmThreshold ) { 
line 15821: sqlite3MallocAlarm ( nFull ) ; 
line 15822: } 
line 15823: } 
line 15824: p = sqlite3GlobalConfig . m . xMalloc ( nFull ) ; 
line 15825: if ( p == 0 && mem0 . alarmCallback ) { 
line 15826: sqlite3MallocAlarm ( nFull ) ; 
line 15827: p = sqlite3GlobalConfig . m . xMalloc ( nFull ) ; 
line 15828: } 
line 15829: if ( p ) { 
line 15830: nFull = sqlite3MallocSize ( p ) ; 
line 15831: sqlite3StatusAdd ( SQLITE_STATUS_MEMORY_USED , nFull ) ; 
line 15832: } 
line 15833: * pp = p ; 
line 15834: return nFull ; 
line 15835: } 
line 15841: SQLITE_PRIVATE void * sqlite3Malloc ( int n ) { 
line 15842: void * p ; 
line 15843: if ( n <= 0 || n >= 0x7fffff00 ) { 
line 15849: p = 0 ; 
line 15850: } else if ( sqlite3GlobalConfig . bMemstat ) { 
line 15851: sqlite3_mutex_enter ( mem0 . mutex ) ; 
line 15852: mallocWithAlarm ( n , & p ) ; 
line 15853: sqlite3_mutex_leave ( mem0 . mutex ) ; 
line 15854: } else { 
line 15855: p = sqlite3GlobalConfig . m . xMalloc ( n ) ; 
line 15856: } 
line 15857: return p ; 
line 15858: } 
line 15865: SQLITE_API void * sqlite3_malloc ( int n ) { 
line 15866: # ifndef SQLITE_OMIT_AUTOINIT 
line 15867: if ( sqlite3_initialize ( ) ) return 0 ; 
line 15868: # endif 
line 15869: return sqlite3Malloc ( n ) ; 
line 15870: } 
line 15878: # if SQLITE_THREADSAFE == 0 && ! defined ( NDEBUG ) 
line 15879: static int scratchAllocOut = 0 ; 
line 15880: # endif 
line 15891: SQLITE_PRIVATE void * sqlite3ScratchMalloc ( int n ) { 
line 15892: void * p ; 
line 15893: assert ( n > 0 ) ; 
line 15895: # if SQLITE_THREADSAFE == 0 && ! defined ( NDEBUG ) 
line 15900: assert ( scratchAllocOut == 0 ) ; 
line 15901: # endif 
line 15903: if ( sqlite3GlobalConfig . szScratch < n ) { 
line 15904: goto scratch_overflow ; 
line 15905: } else { 
line 15906: sqlite3_mutex_enter ( mem0 . mutex ) ; 
line 15907: if ( mem0 . nScratchFree == 0 ) { 
line 15908: sqlite3_mutex_leave ( mem0 . mutex ) ; 
line 15909: goto scratch_overflow ; 
line 15910: } else { 
line 15911: int i ; 
line 15912: i = mem0 . aScratchFree [ -- mem0 . nScratchFree ] ; 
line 15913: i *= sqlite3GlobalConfig . szScratch ; 
line 15914: sqlite3StatusAdd ( SQLITE_STATUS_SCRATCH_USED , 1 ) ; 
line 15915: sqlite3StatusSet ( SQLITE_STATUS_SCRATCH_SIZE , n ) ; 
line 15916: sqlite3_mutex_leave ( mem0 . mutex ) ; 
line 15917: p = ( void * ) & ( ( char * ) sqlite3GlobalConfig . pScratch ) [ i ] ; 
line 15918: assert ( ( ( ( u8 * ) p - ( u8 * ) 0 ) & 7 ) == 0 ) ; 
line 15919: } 
line 15920: } 
line 15921: # if SQLITE_THREADSAFE == 0 && ! defined ( NDEBUG ) 
line 15922: scratchAllocOut = p != 0 ; 
line 15923: # endif 
line 15925: return p ; 
line 15927: scratch_overflow : 
line 15928: if ( sqlite3GlobalConfig . bMemstat ) { 
line 15929: sqlite3_mutex_enter ( mem0 . mutex ) ; 
line 15930: sqlite3StatusSet ( SQLITE_STATUS_SCRATCH_SIZE , n ) ; 
line 15931: n = mallocWithAlarm ( n , & p ) ; 
line 15932: if ( p ) sqlite3StatusAdd ( SQLITE_STATUS_SCRATCH_OVERFLOW , n ) ; 
line 15933: sqlite3_mutex_leave ( mem0 . mutex ) ; 
line 15934: } else { 
line 15935: p = sqlite3GlobalConfig . m . xMalloc ( n ) ; 
line 15936: } 
line 15937: # if SQLITE_THREADSAFE == 0 && ! defined ( NDEBUG ) 
line 15938: scratchAllocOut = p != 0 ; 
line 15939: # endif 
line 15940: return p ; 
line 15941: } 
line 15942: SQLITE_PRIVATE void sqlite3ScratchFree ( void * p ) { 
line 15943: if ( p ) { 
line 15945: # if SQLITE_THREADSAFE == 0 && ! defined ( NDEBUG ) 
line 15950: assert ( scratchAllocOut == 1 ) ; 
line 15951: scratchAllocOut = 0 ; 
line 15952: # endif 
line 15954: if ( sqlite3GlobalConfig . pScratch == 0 
line 15955: || p < sqlite3GlobalConfig . pScratch 
line 15956: || p >= ( void * ) mem0 . aScratchFree ) { 
line 15957: if ( sqlite3GlobalConfig . bMemstat ) { 
line 15958: int iSize = sqlite3MallocSize ( p ) ; 
line 15959: sqlite3_mutex_enter ( mem0 . mutex ) ; 
line 15960: sqlite3StatusAdd ( SQLITE_STATUS_SCRATCH_OVERFLOW , - iSize ) ; 
line 15961: sqlite3StatusAdd ( SQLITE_STATUS_MEMORY_USED , - iSize ) ; 
line 15962: sqlite3GlobalConfig . m . xFree ( p ) ; 
line 15963: sqlite3_mutex_leave ( mem0 . mutex ) ; 
line 15964: } else { 
line 15965: sqlite3GlobalConfig . m . xFree ( p ) ; 
line 15966: } 
line 15967: } else { 
line 15968: int i ; 
line 15969: i = ( int ) ( ( u8 * ) p - ( u8 * ) sqlite3GlobalConfig . pScratch ) ; 
line 15970: i /= sqlite3GlobalConfig . szScratch ; 
line 15971: assert ( i >= 0 && i < sqlite3GlobalConfig . nScratch ) ; 
line 15972: sqlite3_mutex_enter ( mem0 . mutex ) ; 
line 15973: assert ( mem0 . nScratchFree < ( u32 ) sqlite3GlobalConfig . nScratch ) ; 
line 15974: mem0 . aScratchFree [ mem0 . nScratchFree ++ ] = i ; 
line 15975: sqlite3StatusAdd ( SQLITE_STATUS_SCRATCH_USED , - 1 ) ; 
line 15976: sqlite3_mutex_leave ( mem0 . mutex ) ; 
line 15977: } 
line 15978: } 
line 15979: } 
line 15984: # ifndef SQLITE_OMIT_LOOKASIDE 
line 15985: static int isLookaside ( sqlite3 * db , void * p ) { 
line 15986: return db && p && p >= db -> lookaside . pStart && p < db -> lookaside . pEnd ; 
line 15987: } 
line 15988: # else 
line 15989: # define isLookaside ( A , B ) 0 
line 15990: # endif 
line 15996: SQLITE_PRIVATE int sqlite3MallocSize ( void * p ) { 
line 15997: return sqlite3GlobalConfig . m . xSize ( p ) ; 
line 15998: } 
line 15999: SQLITE_PRIVATE int sqlite3DbMallocSize ( sqlite3 * db , void * p ) { 
line 16000: assert ( db == 0 || sqlite3_mutex_held ( db -> mutex ) ) ; 
line 16001: if ( isLookaside ( db , p ) ) { 
line 16002: return db -> lookaside . sz ; 
line 16003: } else { 
line 16004: return sqlite3GlobalConfig . m . xSize ( p ) ; 
line 16005: } 
line 16006: } 
line 16011: SQLITE_API void sqlite3_free ( void * p ) { 
line 16012: if ( p == 0 ) return ; 
line 16013: if ( sqlite3GlobalConfig . bMemstat ) { 
line 16014: sqlite3_mutex_enter ( mem0 . mutex ) ; 
line 16015: sqlite3StatusAdd ( SQLITE_STATUS_MEMORY_USED , - sqlite3MallocSize ( p ) ) ; 
line 16016: sqlite3GlobalConfig . m . xFree ( p ) ; 
line 16017: sqlite3_mutex_leave ( mem0 . mutex ) ; 
line 16018: } else { 
line 16019: sqlite3GlobalConfig . m . xFree ( p ) ; 
line 16020: } 
line 16021: } 
line 16027: SQLITE_PRIVATE void sqlite3DbFree ( sqlite3 * db , void * p ) { 
line 16028: assert ( db == 0 || sqlite3_mutex_held ( db -> mutex ) ) ; 
line 16029: if ( isLookaside ( db , p ) ) { 
line 16030: LookasideSlot * pBuf = ( LookasideSlot * ) p ; 
line 16031: pBuf -> pNext = db -> lookaside . pFree ; 
line 16032: db -> lookaside . pFree = pBuf ; 
line 16033: db -> lookaside . nOut -- ; 
line 16034: } else { 
line 16035: sqlite3_free ( p ) ; 
line 16036: } 
line 16037: } 
line 16042: SQLITE_PRIVATE void * sqlite3Realloc ( void * pOld , int nBytes ) { 
line 16043: int nOld , nNew ; 
line 16044: void * pNew ; 
line 16045: if ( pOld == 0 ) { 
line 16046: return sqlite3Malloc ( nBytes ) ; 
line 16047: } 
line 16048: if ( nBytes <= 0 ) { 
line 16049: sqlite3_free ( pOld ) ; 
line 16050: return 0 ; 
line 16051: } 
line 16052: if ( nBytes >= 0x7fffff00 ) { 
line 16054: return 0 ; 
line 16055: } 
line 16056: nOld = sqlite3MallocSize ( pOld ) ; 
line 16057: nNew = sqlite3GlobalConfig . m . xRoundup ( nBytes ) ; 
line 16058: if ( nOld == nNew ) { 
line 16059: pNew = pOld ; 
line 16060: } else if ( sqlite3GlobalConfig . bMemstat ) { 
line 16061: sqlite3_mutex_enter ( mem0 . mutex ) ; 
line 16062: sqlite3StatusSet ( SQLITE_STATUS_MALLOC_SIZE , nBytes ) ; 
line 16063: if ( sqlite3StatusValue ( SQLITE_STATUS_MEMORY_USED ) + nNew - nOld >= 
line 16064: mem0 . alarmThreshold ) { 
line 16065: sqlite3MallocAlarm ( nNew - nOld ) ; 
line 16066: } 
line 16067: pNew = sqlite3GlobalConfig . m . xRealloc ( pOld , nNew ) ; 
line 16068: if ( pNew == 0 && mem0 . alarmCallback ) { 
line 16069: sqlite3MallocAlarm ( nBytes ) ; 
line 16070: pNew = sqlite3GlobalConfig . m . xRealloc ( pOld , nNew ) ; 
line 16071: } 
line 16072: if ( pNew ) { 
line 16073: nNew = sqlite3MallocSize ( pNew ) ; 
line 16074: sqlite3StatusAdd ( SQLITE_STATUS_MEMORY_USED , nNew - nOld ) ; 
line 16075: } 
line 16076: sqlite3_mutex_leave ( mem0 . mutex ) ; 
line 16077: } else { 
line 16078: pNew = sqlite3GlobalConfig . m . xRealloc ( pOld , nNew ) ; 
line 16079: } 
line 16080: return pNew ; 
line 16081: } 
line 16087: SQLITE_API void * sqlite3_realloc ( void * pOld , int n ) { 
line 16088: # ifndef SQLITE_OMIT_AUTOINIT 
line 16089: if ( sqlite3_initialize ( ) ) return 0 ; 
line 16090: # endif 
line 16091: return sqlite3Realloc ( pOld , n ) ; 
line 16092: } 
line 16098: SQLITE_PRIVATE void * sqlite3MallocZero ( int n ) { 
line 16099: void * p = sqlite3Malloc ( n ) ; 
line 16100: if ( p ) { 
line 16101: memset ( p , 0 , n ) ; 
line 16102: } 
line 16103: return p ; 
line 16104: } 
line 16110: SQLITE_PRIVATE void * sqlite3DbMallocZero ( sqlite3 * db , int n ) { 
line 16111: void * p = sqlite3DbMallocRaw ( db , n ) ; 
line 16112: if ( p ) { 
line 16113: memset ( p , 0 , n ) ; 
line 16114: } 
line 16115: return p ; 
line 16116: } 
line 16136: SQLITE_PRIVATE void * sqlite3DbMallocRaw ( sqlite3 * db , int n ) { 
line 16137: void * p ; 
line 16138: assert ( db == 0 || sqlite3_mutex_held ( db -> mutex ) ) ; 
line 16139: # ifndef SQLITE_OMIT_LOOKASIDE 
line 16140: if ( db ) { 
line 16141: LookasideSlot * pBuf ; 
line 16142: if ( db -> mallocFailed ) { 
line 16143: return 0 ; 
line 16144: } 
line 16145: if ( db -> lookaside . bEnabled && n <= db -> lookaside . sz 
line 16146: && ( pBuf = db -> lookaside . pFree ) != 0 ) { 
line 16147: db -> lookaside . pFree = pBuf -> pNext ; 
line 16148: db -> lookaside . nOut ++ ; 
line 16149: if ( db -> lookaside . nOut > db -> lookaside . mxOut ) { 
line 16150: db -> lookaside . mxOut = db -> lookaside . nOut ; 
line 16151: } 
line 16152: return ( void * ) pBuf ; 
line 16153: } 
line 16154: } 
line 16155: # else 
line 16156: if ( db && db -> mallocFailed ) { 
line 16157: return 0 ; 
line 16158: } 
line 16159: # endif 
line 16160: p = sqlite3Malloc ( n ) ; 
line 16161: if ( ! p && db ) { 
line 16162: db -> mallocFailed = 1 ; 
line 16163: } 
line 16164: return p ; 
line 16165: } 
line 16171: SQLITE_PRIVATE void * sqlite3DbRealloc ( sqlite3 * db , void * p , int n ) { 
line 16172: void * pNew = 0 ; 
line 16173: assert ( db != 0 ) ; 
line 16174: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 16175: if ( db -> mallocFailed == 0 ) { 
line 16176: if ( p == 0 ) { 
line 16177: return sqlite3DbMallocRaw ( db , n ) ; 
line 16178: } 
line 16179: if ( isLookaside ( db , p ) ) { 
line 16180: if ( n <= db -> lookaside . sz ) { 
line 16181: return p ; 
line 16182: } 
line 16183: pNew = sqlite3DbMallocRaw ( db , n ) ; 
line 16184: if ( pNew ) { 
line 16185: memcpy ( pNew , p , db -> lookaside . sz ) ; 
line 16186: sqlite3DbFree ( db , p ) ; 
line 16187: } 
line 16188: } else { 
line 16189: pNew = sqlite3_realloc ( p , n ) ; 
line 16190: if ( ! pNew ) { 
line 16191: db -> mallocFailed = 1 ; 
line 16192: } 
line 16193: } 
line 16194: } 
line 16195: return pNew ; 
line 16196: } 
line 16202: SQLITE_PRIVATE void * sqlite3DbReallocOrFree ( sqlite3 * db , void * p , int n ) { 
line 16203: void * pNew ; 
line 16204: pNew = sqlite3DbRealloc ( db , p , n ) ; 
line 16205: if ( ! pNew ) { 
line 16206: sqlite3DbFree ( db , p ) ; 
line 16207: } 
line 16208: return pNew ; 
line 16209: } 
line 16218: SQLITE_PRIVATE char * sqlite3DbStrDup ( sqlite3 * db , const char * z ) { 
line 16219: char * zNew ; 
line 16220: size_t n ; 
line 16221: if ( z == 0 ) { 
line 16222: return 0 ; 
line 16223: } 
line 16224: n = sqlite3Strlen30 ( z ) + 1 ; 
line 16225: assert ( ( n & 0x7fffffff ) == n ) ; 
line 16226: zNew = sqlite3DbMallocRaw ( db , ( int ) n ) ; 
line 16227: if ( zNew ) { 
line 16228: memcpy ( zNew , z , n ) ; 
line 16229: } 
line 16230: return zNew ; 
line 16231: } 
line 16232: SQLITE_PRIVATE char * sqlite3DbStrNDup ( sqlite3 * db , const char * z , int n ) { 
line 16233: char * zNew ; 
line 16234: if ( z == 0 ) { 
line 16235: return 0 ; 
line 16236: } 
line 16237: assert ( ( n & 0x7fffffff ) == n ) ; 
line 16238: zNew = sqlite3DbMallocRaw ( db , n + 1 ) ; 
line 16239: if ( zNew ) { 
line 16240: memcpy ( zNew , z , n ) ; 
line 16241: zNew [ n ] = 0 ; 
line 16242: } 
line 16243: return zNew ; 
line 16244: } 
line 16251: SQLITE_PRIVATE void sqlite3SetString ( char * * pz , sqlite3 * db , const char * zFormat , ... ) { 
line 16252: va_list ap ; 
line 16253: char * z ; 
line 16255: va_start ( ap , zFormat ) ; 
line 16256: z = sqlite3VMPrintf ( db , zFormat , ap ) ; 
line 16257: va_end ( ap ) ; 
line 16258: sqlite3DbFree ( db , * pz ) ; 
line 16259: * pz = z ; 
line 16260: } 
line 16276: SQLITE_PRIVATE int sqlite3ApiExit ( sqlite3 * db , int rc ) { 
line 16281: assert ( ! db || sqlite3_mutex_held ( db -> mutex ) ) ; 
line 16282: if ( db && ( db -> mallocFailed || rc == SQLITE_IOERR_NOMEM ) ) { 
line 16283: sqlite3Error ( db , SQLITE_NOMEM , 0 ) ; 
line 16284: db -> mallocFailed = 0 ; 
line 16285: rc = SQLITE_NOMEM ; 
line 16286: } 
line 16287: return rc & ( db ? db -> errMask : 0xff ) ; 
line 16288: } 
line 16349: # define etRADIX 1 
line 16350: # define etFLOAT 2 
line 16351: # define etEXP 3 
line 16352: # define etGENERIC 4 
line 16353: # define etSIZE 5 
line 16354: # define etSTRING 6 
line 16355: # define etDYNSTRING 7 
line 16356: # define etPERCENT 8 
line 16357: # define etCHARX 9 
line 16359: # define etSQLESCAPE 10 
line 16360: # define etSQLESCAPE2 11 
line 16362: # define etTOKEN 12 
line 16363: # define etSRCLIST 13 
line 16364: # define etPOINTER 14 
line 16365: # define etSQLESCAPE3 15 
line 16366: # define etORDINAL 16 
line 16368: # define etINVALID 0 
line 16374: typedef unsigned char etByte ; 
line 16380: typedef struct et_info { 
line 16381: char fmttype ; 
line 16382: etByte base ; 
line 16383: etByte flags ; 
line 16384: etByte type ; 
line 16385: etByte charset ; 
line 16386: etByte prefix ; 
line 16387: } et_info ; 
line 16392: # define FLAG_SIGNED 1 
line 16393: # define FLAG_INTERN 2 
line 16394: # define FLAG_STRING 4 
line 16401: static const char aDigits [ ] = "0123456789ABCDEF0123456789abcdef" ; 
line 16402: static const char aPrefix [ ] = "-x0\000X0" ; 
line 16403: static const et_info fmtinfo [ ] = { 
line 16404: { 'd' , 10 , 1 , etRADIX , 0 , 0 } , 
line 16405: { 's' , 0 , 4 , etSTRING , 0 , 0 } , 
line 16406: { 'g' , 0 , 1 , etGENERIC , 30 , 0 } , 
line 16407: { 'z' , 0 , 4 , etDYNSTRING , 0 , 0 } , 
line 16408: { 'q' , 0 , 4 , etSQLESCAPE , 0 , 0 } , 
line 16409: { 'Q' , 0 , 4 , etSQLESCAPE2 , 0 , 0 } , 
line 16410: { 'w' , 0 , 4 , etSQLESCAPE3 , 0 , 0 } , 
line 16411: { 'c' , 0 , 0 , etCHARX , 0 , 0 } , 
line 16412: { 'o' , 8 , 0 , etRADIX , 0 , 2 } , 
line 16413: { 'u' , 10 , 0 , etRADIX , 0 , 0 } , 
line 16414: { 'x' , 16 , 0 , etRADIX , 16 , 1 } , 
line 16415: { 'X' , 16 , 0 , etRADIX , 0 , 4 } , 
line 16416: # ifndef SQLITE_OMIT_FLOATING_POINT 
line 16417: { 'f' , 0 , 1 , etFLOAT , 0 , 0 } , 
line 16418: { 'e' , 0 , 1 , etEXP , 30 , 0 } , 
line 16419: { 'E' , 0 , 1 , etEXP , 14 , 0 } , 
line 16420: { 'G' , 0 , 1 , etGENERIC , 14 , 0 } , 
line 16421: # endif 
line 16422: { 'i' , 10 , 1 , etRADIX , 0 , 0 } , 
line 16423: { 'n' , 0 , 0 , etSIZE , 0 , 0 } , 
line 16424: { '%' , 0 , 0 , etPERCENT , 0 , 0 } , 
line 16425: { 'p' , 16 , 0 , etPOINTER , 0 , 1 } , 
line 16429: { 'T' , 0 , 2 , etTOKEN , 0 , 0 } , 
line 16430: { 'S' , 0 , 2 , etSRCLIST , 0 , 0 } , 
line 16431: { 'r' , 10 , 3 , etORDINAL , 0 , 0 } , 
line 16432: } ; 
line 16438: # ifndef SQLITE_OMIT_FLOATING_POINT 
line 16452: static char et_getdigit ( LONGDOUBLE_TYPE * val , int * cnt ) { 
line 16453: int digit ; 
line 16454: LONGDOUBLE_TYPE d ; 
line 16455: if ( ( * cnt ) ++ >= 16 ) return '0' ; 
line 16456: digit = ( int ) * val ; 
line 16457: d = digit ; 
line 16458: digit += '0' ; 
line 16459: * val = ( * val - d ) * 10.0 ; 
line 16460: return ( char ) digit ; 
line 16461: } 
line 16462: # endif 
line 16467: static void appendSpace ( StrAccum * pAccum , int N ) { 
line 16468: static const char zSpaces [ ] = "                             " ; 
line 16469: while ( N >= ( int ) sizeof ( zSpaces ) - 1 ) { 
line 16470: sqlite3StrAccumAppend ( pAccum , zSpaces , sizeof ( zSpaces ) - 1 ) ; 
line 16471: N -= sizeof ( zSpaces ) - 1 ; 
line 16472: } 
line 16473: if ( N > 0 ) { 
line 16474: sqlite3StrAccumAppend ( pAccum , zSpaces , N ) ; 
line 16475: } 
line 16476: } 
line 16482: # ifndef SQLITE_PRINT_BUF_SIZE 
line 16483: # if defined ( SQLITE_SMALL_STACK ) 
line 16484: # define SQLITE_PRINT_BUF_SIZE 50 
line 16485: # else 
line 16486: # define SQLITE_PRINT_BUF_SIZE 350 
line 16487: # endif 
line 16488: # endif 
line 16489: # define etBUFSIZE SQLITE_PRINT_BUF_SIZE 
line 16518: SQLITE_PRIVATE void sqlite3VXPrintf ( 
line 16519: StrAccum * pAccum , 
line 16520: int useExtended , 
line 16521: const char * fmt , 
line 16522: va_list ap 
line 16523: ) { 
line 16524: int c ; 
line 16525: char * bufpt ; 
line 16526: int precision ; 
line 16527: int length ; 
line 16528: int idx ; 
line 16529: int width ; 
line 16530: etByte flag_leftjustify ; 
line 16531: etByte flag_plussign ; 
line 16532: etByte flag_blanksign ; 
line 16533: etByte flag_alternateform ; 
line 16534: etByte flag_altform2 ; 
line 16535: etByte flag_zeropad ; 
line 16536: etByte flag_long ; 
line 16537: etByte flag_longlong ; 
line 16538: etByte done ; 
line 16539: sqlite_uint64 longvalue ; 
line 16540: LONGDOUBLE_TYPE realvalue ; 
line 16541: const et_info * infop ; 
line 16542: char buf [ etBUFSIZE ] ; 
line 16543: char prefix ; 
line 16544: etByte xtype = 0 ; 
line 16545: char * zExtra ; 
line 16546: # ifndef SQLITE_OMIT_FLOATING_POINT 
line 16547: int exp , e2 ; 
line 16548: double rounder ; 
line 16549: etByte flag_dp ; 
line 16550: etByte flag_rtz ; 
line 16551: etByte flag_exp ; 
line 16552: int nsd ; 
line 16553: # endif 
line 16555: length = 0 ; 
line 16556: bufpt = 0 ; 
line 16557: for ( ; ( c = ( * fmt ) ) != 0 ; ++ fmt ) { 
line 16558: if ( c != '%' ) { 
line 16559: int amt ; 
line 16560: bufpt = ( char * ) fmt ; 
line 16561: amt = 1 ; 
line 16562: while ( ( c = ( * ++ fmt ) ) != '%' && c != 0 ) amt ++ ; 
line 16563: sqlite3StrAccumAppend ( pAccum , bufpt , amt ) ; 
line 16564: if ( c == 0 ) break ; 
line 16565: } 
line 16566: if ( ( c = ( * ++ fmt ) ) == 0 ) { 
line 16567: sqlite3StrAccumAppend ( pAccum , "%" , 1 ) ; 
line 16568: break ; 
line 16569: } 
line 16571: flag_leftjustify = flag_plussign = flag_blanksign = 
line 16572: flag_alternateform = flag_altform2 = flag_zeropad = 0 ; 
line 16573: done = 0 ; 
line 16574: do { 
line 16575: switch ( c ) { 
line 16576: case '-' : flag_leftjustify = 1 ; break ; 
line 16577: case '+' : flag_plussign = 1 ; break ; 
line 16578: case ' ' : flag_blanksign = 1 ; break ; 
line 16579: case '#' : flag_alternateform = 1 ; break ; 
line 16580: case '!' : flag_altform2 = 1 ; break ; 
line 16581: case '0' : flag_zeropad = 1 ; break ; 
line 16582: default : done = 1 ; break ; 
line 16583: } 
line 16584: } while ( ! done && ( c = ( * ++ fmt ) ) != 0 ) ; 
line 16586: width = 0 ; 
line 16587: if ( c == '*' ) { 
line 16588: width = va_arg ( ap , int ) ; 
line 16589: if ( width < 0 ) { 
line 16590: flag_leftjustify = 1 ; 
line 16591: width = - width ; 
line 16592: } 
line 16593: c = * ++ fmt ; 
line 16594: } else { 
line 16595: while ( c >= '0' && c <= '9' ) { 
line 16596: width = width * 10 + c - '0' ; 
line 16597: c = * ++ fmt ; 
line 16598: } 
line 16599: } 
line 16600: if ( width > etBUFSIZE - 10 ) { 
line 16601: width = etBUFSIZE - 10 ; 
line 16602: } 
line 16604: if ( c == '.' ) { 
line 16605: precision = 0 ; 
line 16606: c = * ++ fmt ; 
line 16607: if ( c == '*' ) { 
line 16608: precision = va_arg ( ap , int ) ; 
line 16609: if ( precision < 0 ) precision = - precision ; 
line 16610: c = * ++ fmt ; 
line 16611: } else { 
line 16612: while ( c >= '0' && c <= '9' ) { 
line 16613: precision = precision * 10 + c - '0' ; 
line 16614: c = * ++ fmt ; 
line 16615: } 
line 16616: } 
line 16617: } else { 
line 16618: precision = - 1 ; 
line 16619: } 
line 16621: if ( c == 'l' ) { 
line 16622: flag_long = 1 ; 
line 16623: c = * ++ fmt ; 
line 16624: if ( c == 'l' ) { 
line 16625: flag_longlong = 1 ; 
line 16626: c = * ++ fmt ; 
line 16627: } else { 
line 16628: flag_longlong = 0 ; 
line 16629: } 
line 16630: } else { 
line 16631: flag_long = flag_longlong = 0 ; 
line 16632: } 
line 16634: infop = & fmtinfo [ 0 ] ; 
line 16635: xtype = etINVALID ; 
line 16636: for ( idx = 0 ; idx < ArraySize ( fmtinfo ) ; idx ++ ) { 
line 16637: if ( c == fmtinfo [ idx ] . fmttype ) { 
line 16638: infop = & fmtinfo [ idx ] ; 
line 16639: if ( useExtended || ( infop -> flags & FLAG_INTERN ) == 0 ) { 
line 16640: xtype = infop -> type ; 
line 16641: } else { 
line 16642: return ; 
line 16643: } 
line 16644: break ; 
line 16645: } 
line 16646: } 
line 16647: zExtra = 0 ; 
line 16651: if ( precision > etBUFSIZE - 40 && ( infop -> flags & FLAG_STRING ) == 0 ) { 
line 16652: precision = etBUFSIZE - 40 ; 
line 16653: } 
line 16676: switch ( xtype ) { 
line 16677: case etPOINTER : 
line 16678: flag_longlong = sizeof ( char * ) == sizeof ( i64 ) ; 
line 16679: flag_long = sizeof ( char * ) == sizeof ( long int ) ; 
line 16681: case etORDINAL : 
line 16682: case etRADIX : 
line 16683: if ( infop -> flags & FLAG_SIGNED ) { 
line 16684: i64 v ; 
line 16685: if ( flag_longlong ) { 
line 16686: v = va_arg ( ap , i64 ) ; 
line 16687: } else if ( flag_long ) { 
line 16688: v = va_arg ( ap , long int ) ; 
line 16689: } else { 
line 16690: v = va_arg ( ap , int ) ; 
line 16691: } 
line 16692: if ( v < 0 ) { 
line 16693: longvalue = - v ; 
line 16694: prefix = '-' ; 
line 16695: } else { 
line 16696: longvalue = v ; 
line 16697: if ( flag_plussign ) prefix = '+' ; 
line 16698: else if ( flag_blanksign ) prefix = ' ' ; 
line 16699: else prefix = 0 ; 
line 16700: } 
line 16701: } else { 
line 16702: if ( flag_longlong ) { 
line 16703: longvalue = va_arg ( ap , u64 ) ; 
line 16704: } else if ( flag_long ) { 
line 16705: longvalue = va_arg ( ap , unsigned long int ) ; 
line 16706: } else { 
line 16707: longvalue = va_arg ( ap , unsigned int ) ; 
line 16708: } 
line 16709: prefix = 0 ; 
line 16710: } 
line 16711: if ( longvalue == 0 ) flag_alternateform = 0 ; 
line 16712: if ( flag_zeropad && precision < width - ( prefix != 0 ) ) { 
line 16713: precision = width - ( prefix != 0 ) ; 
line 16714: } 
line 16715: bufpt = & buf [ etBUFSIZE - 1 ] ; 
line 16716: if ( xtype == etORDINAL ) { 
line 16717: static const char zOrd [ ] = "thstndrd" ; 
line 16718: int x = ( int ) ( longvalue % 10 ) ; 
line 16719: if ( x >= 4 || ( longvalue / 10 ) % 10 == 1 ) { 
line 16720: x = 0 ; 
line 16721: } 
line 16722: buf [ etBUFSIZE - 3 ] = zOrd [ x * 2 ] ; 
line 16723: buf [ etBUFSIZE - 2 ] = zOrd [ x * 2 + 1 ] ; 
line 16724: bufpt -= 2 ; 
line 16725: } 
line 16726: { 
line 16727: register const char * cset ; 
line 16728: register int base ; 
line 16729: cset = & aDigits [ infop -> charset ] ; 
line 16730: base = infop -> base ; 
line 16731: do { 
line 16732: * ( -- bufpt ) = cset [ longvalue % base ] ; 
line 16733: longvalue = longvalue / base ; 
line 16734: } while ( longvalue > 0 ) ; 
line 16735: } 
line 16736: length = ( int ) ( & buf [ etBUFSIZE - 1 ] - bufpt ) ; 
line 16737: for ( idx = precision - length ; idx > 0 ; idx -- ) { 
line 16738: * ( -- bufpt ) = '0' ; 
line 16739: } 
line 16740: if ( prefix ) * ( -- bufpt ) = prefix ; 
line 16741: if ( flag_alternateform && infop -> prefix ) { 
line 16742: const char * pre ; 
line 16743: char x ; 
line 16744: pre = & aPrefix [ infop -> prefix ] ; 
line 16745: for ( ; ( x = ( * pre ) ) != 0 ; pre ++ ) * ( -- bufpt ) = x ; 
line 16746: } 
line 16747: length = ( int ) ( & buf [ etBUFSIZE - 1 ] - bufpt ) ; 
line 16748: break ; 
line 16749: case etFLOAT : 
line 16750: case etEXP : 
line 16751: case etGENERIC : 
line 16752: realvalue = va_arg ( ap , double ) ; 
line 16753: # ifndef SQLITE_OMIT_FLOATING_POINT 
line 16754: if ( precision < 0 ) precision = 6 ; 
line 16755: if ( precision > etBUFSIZE / 2 - 10 ) precision = etBUFSIZE / 2 - 10 ; 
line 16756: if ( realvalue < 0.0 ) { 
line 16757: realvalue = - realvalue ; 
line 16758: prefix = '-' ; 
line 16759: } else { 
line 16760: if ( flag_plussign ) prefix = '+' ; 
line 16761: else if ( flag_blanksign ) prefix = ' ' ; 
line 16762: else prefix = 0 ; 
line 16763: } 
line 16764: if ( xtype == etGENERIC && precision > 0 ) precision -- ; 
line 16765: # if 0 
line 16767: for ( idx = precision , rounder = 0.4999 ; idx > 0 ; idx -- , rounder *= 0.1 ) ; 
line 16768: # else 
line 16770: for ( idx = precision , rounder = 0.5 ; idx > 0 ; idx -- , rounder *= 0.1 ) { } 
line 16771: # endif 
line 16772: if ( xtype == etFLOAT ) realvalue += rounder ; 
line 16774: exp = 0 ; 
line 16775: if ( sqlite3IsNaN ( ( double ) realvalue ) ) { 
line 16776: bufpt = "NaN" ; 
line 16777: length = 3 ; 
line 16778: break ; 
line 16779: } 
line 16780: if ( realvalue > 0.0 ) { 
line 16781: while ( realvalue >= 1e 32 && exp <= 350 ) { realvalue *= 1e - 32 ; exp += 32 ; } 
line 16782: while ( realvalue >= 1e 8 && exp <= 350 ) { realvalue *= 1e - 8 ; exp += 8 ; } 
line 16783: while ( realvalue >= 10.0 && exp <= 350 ) { realvalue *= 0.1 ; exp ++ ; } 
line 16784: while ( realvalue < 1e - 8 ) { realvalue *= 1e 8 ; exp -= 8 ; } 
line 16785: while ( realvalue < 1.0 ) { realvalue *= 10.0 ; exp -- ; } 
line 16786: if ( exp > 350 ) { 
line 16787: if ( prefix == '-' ) { 
line 16788: bufpt = "-Inf" ; 
line 16789: } else if ( prefix == '+' ) { 
line 16790: bufpt = "+Inf" ; 
line 16791: } else { 
line 16792: bufpt = "Inf" ; 
line 16793: } 
line 16794: length = sqlite3Strlen30 ( bufpt ) ; 
line 16795: break ; 
line 16796: } 
line 16797: } 
line 16798: bufpt = buf ; 
line 16803: flag_exp = xtype == etEXP ; 
line 16804: if ( xtype != etFLOAT ) { 
line 16805: realvalue += rounder ; 
line 16806: if ( realvalue >= 10.0 ) { realvalue *= 0.1 ; exp ++ ; } 
line 16807: } 
line 16808: if ( xtype == etGENERIC ) { 
line 16809: flag_rtz = ! flag_alternateform ; 
line 16810: if ( exp < - 4 || exp > precision ) { 
line 16811: xtype = etEXP ; 
line 16812: } else { 
line 16813: precision = precision - exp ; 
line 16814: xtype = etFLOAT ; 
line 16815: } 
line 16816: } else { 
line 16817: flag_rtz = 0 ; 
line 16818: } 
line 16819: if ( xtype == etEXP ) { 
line 16820: e2 = 0 ; 
line 16821: } else { 
line 16822: e2 = exp ; 
line 16823: } 
line 16824: nsd = 0 ; 
line 16825: flag_dp = ( precision > 0 ? 1 : 0 ) | flag_alternateform | flag_altform2 ; 
line 16827: if ( prefix ) { 
line 16828: * ( bufpt ++ ) = prefix ; 
line 16829: } 
line 16831: if ( e2 < 0 ) { 
line 16832: * ( bufpt ++ ) = '0' ; 
line 16833: } else { 
line 16834: for ( ; e2 >= 0 ; e2 -- ) { 
line 16835: * ( bufpt ++ ) = et_getdigit ( & realvalue , & nsd ) ; 
line 16836: } 
line 16837: } 
line 16839: if ( flag_dp ) { 
line 16840: * ( bufpt ++ ) = '.' ; 
line 16841: } 
line 16844: for ( e2 ++ ; e2 < 0 ; precision -- , e2 ++ ) { 
line 16845: assert ( precision > 0 ) ; 
line 16846: * ( bufpt ++ ) = '0' ; 
line 16847: } 
line 16849: while ( ( precision -- ) > 0 ) { 
line 16850: * ( bufpt ++ ) = et_getdigit ( & realvalue , & nsd ) ; 
line 16851: } 
line 16853: if ( flag_rtz && flag_dp ) { 
line 16854: while ( bufpt [ - 1 ] == '0' ) * ( -- bufpt ) = 0 ; 
line 16855: assert ( bufpt > buf ) ; 
line 16856: if ( bufpt [ - 1 ] == '.' ) { 
line 16857: if ( flag_altform2 ) { 
line 16858: * ( bufpt ++ ) = '0' ; 
line 16859: } else { 
line 16860: * ( -- bufpt ) = 0 ; 
line 16861: } 
line 16862: } 
line 16863: } 
line 16865: if ( flag_exp || xtype == etEXP ) { 
line 16866: * ( bufpt ++ ) = aDigits [ infop -> charset ] ; 
line 16867: if ( exp < 0 ) { 
line 16868: * ( bufpt ++ ) = '-' ; exp = - exp ; 
line 16869: } else { 
line 16870: * ( bufpt ++ ) = '+' ; 
line 16871: } 
line 16872: if ( exp >= 100 ) { 
line 16873: * ( bufpt ++ ) = ( char ) ( ( exp / 100 ) + '0' ) ; 
line 16874: exp %= 100 ; 
line 16875: } 
line 16876: * ( bufpt ++ ) = ( char ) ( exp / 10 + '0' ) ; 
line 16877: * ( bufpt ++ ) = ( char ) ( exp % 10 + '0' ) ; 
line 16878: } 
line 16879: * bufpt = 0 ; 
line 16884: length = ( int ) ( bufpt - buf ) ; 
line 16885: bufpt = buf ; 
line 16889: if ( flag_zeropad && ! flag_leftjustify && length < width ) { 
line 16890: int i ; 
line 16891: int nPad = width - length ; 
line 16892: for ( i = width ; i >= nPad ; i -- ) { 
line 16893: bufpt [ i ] = bufpt [ i - nPad ] ; 
line 16894: } 
line 16895: i = prefix != 0 ; 
line 16896: while ( nPad -- ) bufpt [ i ++ ] = '0' ; 
line 16897: length = width ; 
line 16898: } 
line 16899: # endif 
line 16900: break ; 
line 16901: case etSIZE : 
line 16902: * ( va_arg ( ap , int * ) ) = pAccum -> nChar ; 
line 16903: length = width = 0 ; 
line 16904: break ; 
line 16905: case etPERCENT : 
line 16906: buf [ 0 ] = '%' ; 
line 16907: bufpt = buf ; 
line 16908: length = 1 ; 
line 16909: break ; 
line 16910: case etCHARX : 
line 16911: c = va_arg ( ap , int ) ; 
line 16912: buf [ 0 ] = ( char ) c ; 
line 16913: if ( precision >= 0 ) { 
line 16914: for ( idx = 1 ; idx < precision ; idx ++ ) buf [ idx ] = ( char ) c ; 
line 16915: length = precision ; 
line 16916: } else { 
line 16917: length = 1 ; 
line 16918: } 
line 16919: bufpt = buf ; 
line 16920: break ; 
line 16921: case etSTRING : 
line 16922: case etDYNSTRING : 
line 16923: bufpt = va_arg ( ap , char * ) ; 
line 16924: if ( bufpt == 0 ) { 
line 16925: bufpt = "" ; 
line 16926: } else if ( xtype == etDYNSTRING ) { 
line 16927: zExtra = bufpt ; 
line 16928: } 
line 16929: if ( precision >= 0 ) { 
line 16930: for ( length = 0 ; length < precision && bufpt [ length ] ; length ++ ) { } 
line 16931: } else { 
line 16932: length = sqlite3Strlen30 ( bufpt ) ; 
line 16933: } 
line 16934: break ; 
line 16935: case etSQLESCAPE : 
line 16936: case etSQLESCAPE2 : 
line 16937: case etSQLESCAPE3 : { 
line 16938: int i , j , k , n , isnull ; 
line 16939: int needQuote ; 
line 16940: char ch ; 
line 16941: char q = ( ( xtype == etSQLESCAPE3 ) ? '"' : '\'' ) ; 
line 16942: char * escarg = va_arg ( ap , char * ) ; 
line 16943: isnull = escarg == 0 ; 
line 16944: if ( isnull ) escarg = ( xtype == etSQLESCAPE2 ? "NULL" : "(NULL)" ) ; 
line 16945: k = precision ; 
line 16946: for ( i = n = 0 ; ( ch = escarg [ i ] ) != 0 && k != 0 ; i ++ , k -- ) { 
line 16947: if ( ch == q ) n ++ ; 
line 16948: } 
line 16949: needQuote = ! isnull && xtype == etSQLESCAPE2 ; 
line 16950: n += i + 1 + needQuote * 2 ; 
line 16951: if ( n > etBUFSIZE ) { 
line 16952: bufpt = zExtra = sqlite3Malloc ( n ) ; 
line 16953: if ( bufpt == 0 ) { 
line 16954: pAccum -> mallocFailed = 1 ; 
line 16955: return ; 
line 16956: } 
line 16957: } else { 
line 16958: bufpt = buf ; 
line 16959: } 
line 16960: j = 0 ; 
line 16961: if ( needQuote ) bufpt [ j ++ ] = q ; 
line 16962: k = i ; 
line 16963: for ( i = 0 ; i < k ; i ++ ) { 
line 16964: bufpt [ j ++ ] = ch = escarg [ i ] ; 
line 16965: if ( ch == q ) bufpt [ j ++ ] = ch ; 
line 16966: } 
line 16967: if ( needQuote ) bufpt [ j ++ ] = q ; 
line 16968: bufpt [ j ] = 0 ; 
line 16969: length = j ; 
line 16973: break ; 
line 16974: } 
line 16975: case etTOKEN : { 
line 16976: Token * pToken = va_arg ( ap , Token * ) ; 
line 16977: if ( pToken ) { 
line 16978: sqlite3StrAccumAppend ( pAccum , ( const char * ) pToken -> z , pToken -> n ) ; 
line 16979: } 
line 16980: length = width = 0 ; 
line 16981: break ; 
line 16982: } 
line 16983: case etSRCLIST : { 
line 16984: SrcList * pSrc = va_arg ( ap , SrcList * ) ; 
line 16985: int k = va_arg ( ap , int ) ; 
line 16986: struct SrcList_item * pItem = & pSrc -> a [ k ] ; 
line 16987: assert ( k >= 0 && k < pSrc -> nSrc ) ; 
line 16988: if ( pItem -> zDatabase ) { 
line 16989: sqlite3StrAccumAppend ( pAccum , pItem -> zDatabase , - 1 ) ; 
line 16990: sqlite3StrAccumAppend ( pAccum , "." , 1 ) ; 
line 16991: } 
line 16992: sqlite3StrAccumAppend ( pAccum , pItem -> zName , - 1 ) ; 
line 16993: length = width = 0 ; 
line 16994: break ; 
line 16995: } 
line 16996: default : { 
line 16997: assert ( xtype == etINVALID ) ; 
line 16998: return ; 
line 16999: } 
line 17000: } 
line 17006: if ( ! flag_leftjustify ) { 
line 17007: register int nspace ; 
line 17008: nspace = width - length ; 
line 17009: if ( nspace > 0 ) { 
line 17010: appendSpace ( pAccum , nspace ) ; 
line 17011: } 
line 17012: } 
line 17013: if ( length > 0 ) { 
line 17014: sqlite3StrAccumAppend ( pAccum , bufpt , length ) ; 
line 17015: } 
line 17016: if ( flag_leftjustify ) { 
line 17017: register int nspace ; 
line 17018: nspace = width - length ; 
line 17019: if ( nspace > 0 ) { 
line 17020: appendSpace ( pAccum , nspace ) ; 
line 17021: } 
line 17022: } 
line 17023: if ( zExtra ) { 
line 17024: sqlite3_free ( zExtra ) ; 
line 17025: } 
line 17026: } 
line 17027: } 
line 17032: SQLITE_PRIVATE void sqlite3StrAccumAppend ( StrAccum * p , const char * z , int N ) { 
line 17033: assert ( z != 0 || N == 0 ) ; 
line 17034: if ( p -> tooBig | p -> mallocFailed ) { 
line 17035: testcase ( p -> tooBig ) ; 
line 17036: testcase ( p -> mallocFailed ) ; 
line 17037: return ; 
line 17038: } 
line 17039: if ( N < 0 ) { 
line 17040: N = sqlite3Strlen30 ( z ) ; 
line 17041: } 
line 17042: if ( N == 0 || NEVER ( z == 0 ) ) { 
line 17043: return ; 
line 17044: } 
line 17045: if ( p -> nChar + N >= p -> nAlloc ) { 
line 17046: char * zNew ; 
line 17047: if ( ! p -> useMalloc ) { 
line 17048: p -> tooBig = 1 ; 
line 17049: N = p -> nAlloc - p -> nChar - 1 ; 
line 17050: if ( N <= 0 ) { 
line 17051: return ; 
line 17052: } 
line 17053: } else { 
line 17054: i64 szNew = p -> nChar ; 
line 17055: szNew += N + 1 ; 
line 17056: if ( szNew > p -> mxAlloc ) { 
line 17057: sqlite3StrAccumReset ( p ) ; 
line 17058: p -> tooBig = 1 ; 
line 17059: return ; 
line 17060: } else { 
line 17061: p -> nAlloc = ( int ) szNew ; 
line 17062: } 
line 17063: zNew = sqlite3DbMallocRaw ( p -> db , p -> nAlloc ) ; 
line 17064: if ( zNew ) { 
line 17065: memcpy ( zNew , p -> zText , p -> nChar ) ; 
line 17066: sqlite3StrAccumReset ( p ) ; 
line 17067: p -> zText = zNew ; 
line 17068: } else { 
line 17069: p -> mallocFailed = 1 ; 
line 17070: sqlite3StrAccumReset ( p ) ; 
line 17071: return ; 
line 17072: } 
line 17073: } 
line 17074: } 
line 17075: memcpy ( & p -> zText [ p -> nChar ] , z , N ) ; 
line 17076: p -> nChar += N ; 
line 17077: } 
line 17084: SQLITE_PRIVATE char * sqlite3StrAccumFinish ( StrAccum * p ) { 
line 17085: if ( p -> zText ) { 
line 17086: p -> zText [ p -> nChar ] = 0 ; 
line 17087: if ( p -> useMalloc && p -> zText == p -> zBase ) { 
line 17088: p -> zText = sqlite3DbMallocRaw ( p -> db , p -> nChar + 1 ) ; 
line 17089: if ( p -> zText ) { 
line 17090: memcpy ( p -> zText , p -> zBase , p -> nChar + 1 ) ; 
line 17091: } else { 
line 17092: p -> mallocFailed = 1 ; 
line 17093: } 
line 17094: } 
line 17095: } 
line 17096: return p -> zText ; 
line 17097: } 
line 17102: SQLITE_PRIVATE void sqlite3StrAccumReset ( StrAccum * p ) { 
line 17103: if ( p -> zText != p -> zBase ) { 
line 17104: sqlite3DbFree ( p -> db , p -> zText ) ; 
line 17105: } 
line 17106: p -> zText = 0 ; 
line 17107: } 
line 17112: SQLITE_PRIVATE void sqlite3StrAccumInit ( StrAccum * p , char * zBase , int n , int mx ) { 
line 17113: p -> zText = p -> zBase = zBase ; 
line 17114: p -> db = 0 ; 
line 17115: p -> nChar = 0 ; 
line 17116: p -> nAlloc = n ; 
line 17117: p -> mxAlloc = mx ; 
line 17118: p -> useMalloc = 1 ; 
line 17119: p -> tooBig = 0 ; 
line 17120: p -> mallocFailed = 0 ; 
line 17121: } 
line 17127: SQLITE_PRIVATE char * sqlite3VMPrintf ( sqlite3 * db , const char * zFormat , va_list ap ) { 
line 17128: char * z ; 
line 17129: char zBase [ SQLITE_PRINT_BUF_SIZE ] ; 
line 17130: StrAccum acc ; 
line 17131: assert ( db != 0 ) ; 
line 17132: sqlite3StrAccumInit ( & acc , zBase , sizeof ( zBase ) , 
line 17133: db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) ; 
line 17134: acc . db = db ; 
line 17135: sqlite3VXPrintf ( & acc , 1 , zFormat , ap ) ; 
line 17136: z = sqlite3StrAccumFinish ( & acc ) ; 
line 17137: if ( acc . mallocFailed ) { 
line 17138: db -> mallocFailed = 1 ; 
line 17139: } 
line 17140: return z ; 
line 17141: } 
line 17147: SQLITE_PRIVATE char * sqlite3MPrintf ( sqlite3 * db , const char * zFormat , ... ) { 
line 17148: va_list ap ; 
line 17149: char * z ; 
line 17150: va_start ( ap , zFormat ) ; 
line 17151: z = sqlite3VMPrintf ( db , zFormat , ap ) ; 
line 17152: va_end ( ap ) ; 
line 17153: return z ; 
line 17154: } 
line 17164: SQLITE_PRIVATE char * sqlite3MAppendf ( sqlite3 * db , char * zStr , const char * zFormat , ... ) { 
line 17165: va_list ap ; 
line 17166: char * z ; 
line 17167: va_start ( ap , zFormat ) ; 
line 17168: z = sqlite3VMPrintf ( db , zFormat , ap ) ; 
line 17169: va_end ( ap ) ; 
line 17170: sqlite3DbFree ( db , zStr ) ; 
line 17171: return z ; 
line 17172: } 
line 17178: SQLITE_API char * sqlite3_vmprintf ( const char * zFormat , va_list ap ) { 
line 17179: char * z ; 
line 17180: char zBase [ SQLITE_PRINT_BUF_SIZE ] ; 
line 17181: StrAccum acc ; 
line 17182: # ifndef SQLITE_OMIT_AUTOINIT 
line 17183: if ( sqlite3_initialize ( ) ) return 0 ; 
line 17184: # endif 
line 17185: sqlite3StrAccumInit ( & acc , zBase , sizeof ( zBase ) , SQLITE_MAX_LENGTH ) ; 
line 17186: sqlite3VXPrintf ( & acc , 0 , zFormat , ap ) ; 
line 17187: z = sqlite3StrAccumFinish ( & acc ) ; 
line 17188: return z ; 
line 17189: } 
line 17195: SQLITE_API char * sqlite3_mprintf ( const char * zFormat , ... ) { 
line 17196: va_list ap ; 
line 17197: char * z ; 
line 17198: # ifndef SQLITE_OMIT_AUTOINIT 
line 17199: if ( sqlite3_initialize ( ) ) return 0 ; 
line 17200: # endif 
line 17201: va_start ( ap , zFormat ) ; 
line 17202: z = sqlite3_vmprintf ( zFormat , ap ) ; 
line 17203: va_end ( ap ) ; 
line 17204: return z ; 
line 17205: } 
line 17213: SQLITE_API char * sqlite3_snprintf ( int n , char * zBuf , const char * zFormat , ... ) { 
line 17214: char * z ; 
line 17215: va_list ap ; 
line 17216: StrAccum acc ; 
line 17218: if ( n <= 0 ) { 
line 17219: return zBuf ; 
line 17220: } 
line 17221: sqlite3StrAccumInit ( & acc , zBuf , n , 0 ) ; 
line 17222: acc . useMalloc = 0 ; 
line 17223: va_start ( ap , zFormat ) ; 
line 17224: sqlite3VXPrintf ( & acc , 0 , zFormat , ap ) ; 
line 17225: va_end ( ap ) ; 
line 17226: z = sqlite3StrAccumFinish ( & acc ) ; 
line 17227: return z ; 
line 17228: } 
line 17230: # if defined ( SQLITE_DEBUG ) 
line 17236: SQLITE_PRIVATE void sqlite3DebugPrintf ( const char * zFormat , ... ) { 
line 17237: va_list ap ; 
line 17238: StrAccum acc ; 
line 17239: char zBuf [ 500 ] ; 
line 17240: sqlite3StrAccumInit ( & acc , zBuf , sizeof ( zBuf ) , 0 ) ; 
line 17241: acc . useMalloc = 0 ; 
line 17242: va_start ( ap , zFormat ) ; 
line 17243: sqlite3VXPrintf ( & acc , 0 , zFormat , ap ) ; 
line 17244: va_end ( ap ) ; 
line 17245: sqlite3StrAccumFinish ( & acc ) ; 
line 17246: fprintf ( stdout , "%s" , zBuf ) ; 
line 17247: fflush ( stdout ) ; 
line 17248: } 
line 17249: # endif 
line 17251: # ifndef SQLITE_OMIT_TRACE 
line 17255: SQLITE_PRIVATE void sqlite3XPrintf ( StrAccum * p , const char * zFormat , ... ) { 
line 17256: va_list ap ; 
line 17257: va_start ( ap , zFormat ) ; 
line 17258: sqlite3VXPrintf ( p , 1 , zFormat , ap ) ; 
line 17259: va_end ( ap ) ; 
line 17260: } 
line 17261: # endif 
line 17287: static SQLITE_WSD struct sqlite3PrngType { 
line 17288: unsigned char isInit ; 
line 17289: unsigned char i , j ; 
line 17290: unsigned char s [ 256 ] ; 
line 17291: } sqlite3Prng ; 
line 17309: static u8 randomByte ( void ) { 
line 17310: unsigned char t ; 
line 17319: # ifdef SQLITE_OMIT_WSD 
line 17320: struct sqlite3PrngType * p = & GLOBAL ( struct sqlite3PrngType , sqlite3Prng ) ; 
line 17321: # define wsdPrng p [ 0 ] 
line 17322: # else 
line 17323: # define wsdPrng sqlite3Prng 
line 17324: # endif 
line 17336: if ( ! wsdPrng . isInit ) { 
line 17337: int i ; 
line 17338: char k [ 256 ] ; 
line 17339: wsdPrng . j = 0 ; 
line 17340: wsdPrng . i = 0 ; 
line 17341: sqlite3OsRandomness ( sqlite3_vfs_find ( 0 ) , 256 , k ) ; 
line 17342: for ( i = 0 ; i < 256 ; i ++ ) { 
line 17343: wsdPrng . s [ i ] = ( u8 ) i ; 
line 17344: } 
line 17345: for ( i = 0 ; i < 256 ; i ++ ) { 
line 17346: wsdPrng . j += wsdPrng . s [ i ] + k [ i ] ; 
line 17347: t = wsdPrng . s [ wsdPrng . j ] ; 
line 17348: wsdPrng . s [ wsdPrng . j ] = wsdPrng . s [ i ] ; 
line 17349: wsdPrng . s [ i ] = t ; 
line 17350: } 
line 17351: wsdPrng . isInit = 1 ; 
line 17352: } 
line 17356: wsdPrng . i ++ ; 
line 17357: t = wsdPrng . s [ wsdPrng . i ] ; 
line 17358: wsdPrng . j += t ; 
line 17359: wsdPrng . s [ wsdPrng . i ] = wsdPrng . s [ wsdPrng . j ] ; 
line 17360: wsdPrng . s [ wsdPrng . j ] = t ; 
line 17361: t += wsdPrng . s [ wsdPrng . i ] ; 
line 17362: return wsdPrng . s [ t ] ; 
line 17363: } 
line 17368: SQLITE_API void sqlite3_randomness ( int N , void * pBuf ) { 
line 17369: unsigned char * zBuf = pBuf ; 
line 17370: # if SQLITE_THREADSAFE 
line 17371: sqlite3_mutex * mutex = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_PRNG ) ; 
line 17372: # endif 
line 17373: sqlite3_mutex_enter ( mutex ) ; 
line 17374: while ( N -- ) { 
line 17375: * ( zBuf ++ ) = randomByte ( ) ; 
line 17376: } 
line 17377: sqlite3_mutex_leave ( mutex ) ; 
line 17378: } 
line 17380: # ifndef SQLITE_OMIT_BUILTIN_TEST 
line 17390: static SQLITE_WSD struct sqlite3PrngType sqlite3SavedPrng ; 
line 17391: SQLITE_PRIVATE void sqlite3PrngSaveState ( void ) { 
line 17392: memcpy ( 
line 17393: & GLOBAL ( struct sqlite3PrngType , sqlite3SavedPrng ) , 
line 17394: & GLOBAL ( struct sqlite3PrngType , sqlite3Prng ) , 
line 17395: sizeof ( sqlite3Prng ) 
line 17396: ) ; 
line 17397: } 
line 17398: SQLITE_PRIVATE void sqlite3PrngRestoreState ( void ) { 
line 17399: memcpy ( 
line 17400: & GLOBAL ( struct sqlite3PrngType , sqlite3Prng ) , 
line 17401: & GLOBAL ( struct sqlite3PrngType , sqlite3SavedPrng ) , 
line 17402: sizeof ( sqlite3Prng ) 
line 17403: ) ; 
line 17404: } 
line 17405: SQLITE_PRIVATE void sqlite3PrngResetState ( void ) { 
line 17406: GLOBAL ( struct sqlite3PrngType , sqlite3Prng ) . isInit = 0 ; 
line 17407: } 
line 17408: # endif 
line 17466: # ifndef _VDBEINT_H_ 
line 17467: # define _VDBEINT_H_ 
line 17474: typedef struct VdbeOp Op ; 
line 17479: typedef unsigned char Bool ; 
line 17496: struct VdbeCursor { 
line 17497: BtCursor * pCursor ; 
line 17498: int iDb ; 
line 17499: i64 lastRowid ; 
line 17500: Bool zeroed ; 
line 17501: Bool rowidIsValid ; 
line 17502: Bool atFirst ; 
line 17503: Bool useRandomRowid ; 
line 17504: Bool nullRow ; 
line 17505: Bool deferredMoveto ; 
line 17506: Bool isTable ; 
line 17507: Bool isIndex ; 
line 17508: i64 movetoTarget ; 
line 17509: Btree * pBt ; 
line 17510: int pseudoTableReg ; 
line 17511: KeyInfo * pKeyInfo ; 
line 17512: int nField ; 
line 17513: i64 seqCount ; 
line 17514: sqlite3_vtab_cursor * pVtabCursor ; 
line 17515: const sqlite3_module * pModule ; 
line 17519: int seekResult ; 
line 17530: u32 cacheStatus ; 
line 17531: int payloadSize ; 
line 17532: u32 * aType ; 
line 17533: u32 * aOffset ; 
line 17534: u8 * aRow ; 
line 17535: } ; 
line 17536: typedef struct VdbeCursor VdbeCursor ; 
line 17551: typedef struct VdbeFrame VdbeFrame ; 
line 17552: struct VdbeFrame { 
line 17553: Vdbe * v ; 
line 17554: int pc ; 
line 17555: Op * aOp ; 
line 17556: int nOp ; 
line 17557: Mem * aMem ; 
line 17558: int nMem ; 
line 17559: VdbeCursor * * apCsr ; 
line 17560: u16 nCursor ; 
line 17561: void * token ; 
line 17562: int nChildMem ; 
line 17563: int nChildCsr ; 
line 17564: i64 lastRowid ; 
line 17565: int nChange ; 
line 17566: VdbeFrame * pParent ; 
line 17567: } ; 
line 17569: # define VdbeFrameMem ( p ) ( ( Mem * ) & ( ( u8 * ) p ) [ ROUND8 ( sizeof ( VdbeFrame ) ) ] ) 
line 17574: # define CACHE_STALE 0 
line 17587: struct Mem { 
line 17588: union { 
line 17589: i64 i ; 
line 17590: int nZero ; 
line 17591: FuncDef * pDef ; 
line 17592: RowSet * pRowSet ; 
line 17593: VdbeFrame * pFrame ; 
line 17594: } u ; 
line 17595: double r ; 
line 17596: sqlite3 * db ; 
line 17597: char * z ; 
line 17598: int n ; 
line 17599: u16 flags ; 
line 17600: u8 type ; 
line 17601: u8 enc ; 
line 17602: void ( * xDel ) ( void * ) ; 
line 17603: char * zMalloc ; 
line 17604: } ; 
line 17621: # define MEM_Null 0x0001 
line 17622: # define MEM_Str 0x0002 
line 17623: # define MEM_Int 0x0004 
line 17624: # define MEM_Real 0x0008 
line 17625: # define MEM_Blob 0x0010 
line 17626: # define MEM_RowSet 0x0020 
line 17627: # define MEM_Frame 0x0040 
line 17628: # define MEM_TypeMask 0x00ff 
line 17635: # define MEM_Term 0x0200 
line 17636: # define MEM_Dyn 0x0400 
line 17637: # define MEM_Static 0x0800 
line 17638: # define MEM_Ephem 0x1000 
line 17639: # define MEM_Agg 0x2000 
line 17640: # define MEM_Zero 0x4000 
line 17642: # ifdef SQLITE_OMIT_INCRBLOB 
line 17643: # undef MEM_Zero 
line 17644: # define MEM_Zero 0x0000 
line 17645: # endif 
line 17651: # define MemSetTypeFlag ( p , f ) 
line 17652: ( ( p ) -> flags = ( ( p ) -> flags & ~ ( MEM_TypeMask | MEM_Zero ) ) | f ) 
line 17664: struct VdbeFunc { 
line 17665: FuncDef * pFunc ; 
line 17666: int nAux ; 
line 17667: struct AuxData { 
line 17668: void * pAux ; 
line 17669: void ( * xDelete ) ( void * ) ; 
line 17670: } apAux [ 1 ] ; 
line 17671: } ; 
line 17686: struct sqlite3_context { 
line 17687: FuncDef * pFunc ; 
line 17688: VdbeFunc * pVdbeFunc ; 
line 17689: Mem s ; 
line 17690: Mem * pMem ; 
line 17691: int isError ; 
line 17692: CollSeq * pColl ; 
line 17693: } ; 
line 17701: typedef struct Set Set ; 
line 17702: struct Set { 
line 17703: Hash hash ; 
line 17704: HashElem * prev ; 
line 17705: } ; 
line 17722: struct Vdbe { 
line 17723: sqlite3 * db ; 
line 17724: Vdbe * pPrev , * pNext ; 
line 17725: int nOp ; 
line 17726: int nOpAlloc ; 
line 17727: Op * aOp ; 
line 17728: int nLabel ; 
line 17729: int nLabelAlloc ; 
line 17730: int * aLabel ; 
line 17731: Mem * * apArg ; 
line 17732: Mem * aColName ; 
line 17733: Mem * pResultSet ; 
line 17734: u16 nResColumn ; 
line 17735: u16 nCursor ; 
line 17736: VdbeCursor * * apCsr ; 
line 17737: u8 errorAction ; 
line 17738: u8 okVar ; 
line 17739: ynVar nVar ; 
line 17740: Mem * aVar ; 
line 17741: char * * azVar ; 
line 17742: u32 magic ; 
line 17743: int nMem ; 
line 17744: Mem * aMem ; 
line 17745: u32 cacheCtr ; 
line 17746: int pc ; 
line 17747: int rc ; 
line 17748: char * zErrMsg ; 
line 17749: u8 explain ; 
line 17750: u8 changeCntOn ; 
line 17751: u8 expired ; 
line 17752: u8 minWriteFileFormat ; 
line 17753: u8 inVtabMethod ; 
line 17754: u8 usesStmtJournal ; 
line 17755: u8 readOnly ; 
line 17756: u8 isPrepareV2 ; 
line 17757: int nChange ; 
line 17758: int btreeMask ; 
line 17759: i64 startTime ; 
line 17760: BtreeMutexArray aMutex ; 
line 17761: int aCounter [ 2 ] ; 
line 17762: char * zSql ; 
line 17763: void * pFree ; 
line 17764: i64 nFkConstraint ; 
line 17765: i64 nStmtDefCons ; 
line 17766: int iStatement ; 
line 17767: # ifdef SQLITE_DEBUG 
line 17768: FILE * trace ; 
line 17769: # endif 
line 17770: VdbeFrame * pFrame ; 
line 17771: int nFrame ; 
line 17772: u32 expmask ; 
line 17773: } ; 
line 17778: # define VDBE_MAGIC_INIT 0x26bceaa5 
line 17779: # define VDBE_MAGIC_RUN 0xbdf20da3 
line 17780: # define VDBE_MAGIC_HALT 0x519c2973 
line 17781: # define VDBE_MAGIC_DEAD 0xb606c3c8 
line 17786: SQLITE_PRIVATE void sqlite3VdbeFreeCursor ( Vdbe * , VdbeCursor * ) ; 
line 17787: void sqliteVdbePopStack ( Vdbe * , int ) ; 
line 17788: SQLITE_PRIVATE int sqlite3VdbeCursorMoveto ( VdbeCursor * ) ; 
line 17789: # if defined ( SQLITE_DEBUG ) || defined ( VDBE_PROFILE ) 
line 17790: SQLITE_PRIVATE void sqlite3VdbePrintOp ( FILE * , int , Op * ) ; 
line 17791: # endif 
line 17792: SQLITE_PRIVATE u32 sqlite3VdbeSerialTypeLen ( u32 ) ; 
line 17793: SQLITE_PRIVATE u32 sqlite3VdbeSerialType ( Mem * , int ) ; 
line 17794: SQLITE_PRIVATE u32 sqlite3VdbeSerialPut ( unsigned char * , int , Mem * , int ) ; 
line 17795: SQLITE_PRIVATE u32 sqlite3VdbeSerialGet ( const unsigned char * , u32 , Mem * ) ; 
line 17796: SQLITE_PRIVATE void sqlite3VdbeDeleteAuxData ( VdbeFunc * , int ) ; 
line 17798: int sqlite2BtreeKeyCompare ( BtCursor * , const void * , int , int , int * ) ; 
line 17799: SQLITE_PRIVATE int sqlite3VdbeIdxKeyCompare ( VdbeCursor * , UnpackedRecord * , int * ) ; 
line 17800: SQLITE_PRIVATE int sqlite3VdbeIdxRowid ( sqlite3 * , BtCursor * , i64 * ) ; 
line 17801: SQLITE_PRIVATE int sqlite3MemCompare ( const Mem * , const Mem * , const CollSeq * ) ; 
line 17802: SQLITE_PRIVATE int sqlite3VdbeExec ( Vdbe * ) ; 
line 17803: SQLITE_PRIVATE int sqlite3VdbeList ( Vdbe * ) ; 
line 17804: SQLITE_PRIVATE int sqlite3VdbeHalt ( Vdbe * ) ; 
line 17805: SQLITE_PRIVATE int sqlite3VdbeChangeEncoding ( Mem * , int ) ; 
line 17806: SQLITE_PRIVATE int sqlite3VdbeMemTooBig ( Mem * ) ; 
line 17807: SQLITE_PRIVATE int sqlite3VdbeMemCopy ( Mem * , const Mem * ) ; 
line 17808: SQLITE_PRIVATE void sqlite3VdbeMemShallowCopy ( Mem * , const Mem * , int ) ; 
line 17809: SQLITE_PRIVATE void sqlite3VdbeMemMove ( Mem * , Mem * ) ; 
line 17810: SQLITE_PRIVATE int sqlite3VdbeMemNulTerminate ( Mem * ) ; 
line 17811: SQLITE_PRIVATE int sqlite3VdbeMemSetStr ( Mem * , const char * , int , u8 , void ( * ) ( void * ) ) ; 
line 17812: SQLITE_PRIVATE void sqlite3VdbeMemSetInt64 ( Mem * , i64 ) ; 
line 17813: SQLITE_PRIVATE void sqlite3VdbeMemSetDouble ( Mem * , double ) ; 
line 17814: SQLITE_PRIVATE void sqlite3VdbeMemSetNull ( Mem * ) ; 
line 17815: SQLITE_PRIVATE void sqlite3VdbeMemSetZeroBlob ( Mem * , int ) ; 
line 17816: SQLITE_PRIVATE void sqlite3VdbeMemSetRowSet ( Mem * ) ; 
line 17817: SQLITE_PRIVATE int sqlite3VdbeMemMakeWriteable ( Mem * ) ; 
line 17818: SQLITE_PRIVATE int sqlite3VdbeMemStringify ( Mem * , int ) ; 
line 17819: SQLITE_PRIVATE i64 sqlite3VdbeIntValue ( Mem * ) ; 
line 17820: SQLITE_PRIVATE int sqlite3VdbeMemIntegerify ( Mem * ) ; 
line 17821: SQLITE_PRIVATE double sqlite3VdbeRealValue ( Mem * ) ; 
line 17822: SQLITE_PRIVATE void sqlite3VdbeIntegerAffinity ( Mem * ) ; 
line 17823: SQLITE_PRIVATE int sqlite3VdbeMemRealify ( Mem * ) ; 
line 17824: SQLITE_PRIVATE int sqlite3VdbeMemNumerify ( Mem * ) ; 
line 17825: SQLITE_PRIVATE int sqlite3VdbeMemFromBtree ( BtCursor * , int , int , int , Mem * ) ; 
line 17826: SQLITE_PRIVATE void sqlite3VdbeMemRelease ( Mem * p ) ; 
line 17827: SQLITE_PRIVATE void sqlite3VdbeMemReleaseExternal ( Mem * p ) ; 
line 17828: SQLITE_PRIVATE int sqlite3VdbeMemFinalize ( Mem * , FuncDef * ) ; 
line 17829: SQLITE_PRIVATE const char * sqlite3OpcodeName ( int ) ; 
line 17830: SQLITE_PRIVATE int sqlite3VdbeMemGrow ( Mem * pMem , int n , int preserve ) ; 
line 17831: SQLITE_PRIVATE int sqlite3VdbeCloseStatement ( Vdbe * , int ) ; 
line 17832: SQLITE_PRIVATE void sqlite3VdbeFrameDelete ( VdbeFrame * ) ; 
line 17833: SQLITE_PRIVATE int sqlite3VdbeFrameRestore ( VdbeFrame * ) ; 
line 17834: SQLITE_PRIVATE void sqlite3VdbeMemStoreType ( Mem * pMem ) ; 
line 17836: # ifndef SQLITE_OMIT_FOREIGN_KEY 
line 17837: SQLITE_PRIVATE int sqlite3VdbeCheckFk ( Vdbe * , int ) ; 
line 17838: # else 
line 17839: # define sqlite3VdbeCheckFk ( p , i ) 0 
line 17840: # endif 
line 17842: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 17843: SQLITE_PRIVATE void sqlite3VdbeMutexArrayEnter ( Vdbe * p ) ; 
line 17844: # else 
line 17845: # define sqlite3VdbeMutexArrayEnter ( p ) 
line 17846: # endif 
line 17848: SQLITE_PRIVATE int sqlite3VdbeMemTranslate ( Mem * , u8 ) ; 
line 17849: # ifdef SQLITE_DEBUG 
line 17850: SQLITE_PRIVATE void sqlite3VdbePrintSql ( Vdbe * ) ; 
line 17851: SQLITE_PRIVATE void sqlite3VdbeMemPrettyPrint ( Mem * pMem , char * zBuf ) ; 
line 17852: # endif 
line 17853: SQLITE_PRIVATE int sqlite3VdbeMemHandleBom ( Mem * pMem ) ; 
line 17855: # ifndef SQLITE_OMIT_INCRBLOB 
line 17856: SQLITE_PRIVATE int sqlite3VdbeMemExpandBlob ( Mem * ) ; 
line 17857: # else 
line 17858: # define sqlite3VdbeMemExpandBlob ( x ) SQLITE_OK 
line 17859: # endif 
line 17861: # endif 
line 17866: # ifndef SQLITE_AMALGAMATION 
line 17871: SQLITE_PRIVATE const int sqlite3one = 1 ; 
line 17872: # endif 
line 17878: static const unsigned char sqlite3Utf8Trans1 [ ] = { 
line 17879: 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 
line 17880: 0x08 , 0x09 , 0x0a , 0x0b , 0x0c , 0x0d , 0x0e , 0x0f , 
line 17881: 0x10 , 0x11 , 0x12 , 0x13 , 0x14 , 0x15 , 0x16 , 0x17 , 
line 17882: 0x18 , 0x19 , 0x1a , 0x1b , 0x1c , 0x1d , 0x1e , 0x1f , 
line 17883: 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 
line 17884: 0x08 , 0x09 , 0x0a , 0x0b , 0x0c , 0x0d , 0x0e , 0x0f , 
line 17885: 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 
line 17886: 0x00 , 0x01 , 0x02 , 0x03 , 0x00 , 0x01 , 0x00 , 0x00 , 
line 17887: } ; 
line 17890: # define WRITE_UTF8 ( zOut , c ) { 
line 17891: if ( c < 0x00080 ) { 
line 17892: * zOut ++ = ( u8 ) ( c & 0xFF ) ; 
line 17893: } 
line 17894: else if ( c < 0x00800 ) { 
line 17895: * zOut ++ = 0xC0 + ( u8 ) ( ( c >> 6 ) & 0x1F ) ; 
line 17896: * zOut ++ = 0x80 + ( u8 ) ( c & 0x3F ) ; 
line 17897: } 
line 17898: else if ( c < 0x10000 ) { 
line 17899: * zOut ++ = 0xE0 + ( u8 ) ( ( c >> 12 ) & 0x0F ) ; 
line 17900: * zOut ++ = 0x80 + ( u8 ) ( ( c >> 6 ) & 0x3F ) ; 
line 17901: * zOut ++ = 0x80 + ( u8 ) ( c & 0x3F ) ; 
line 17902: } else { 
line 17903: * zOut ++ = 0xF0 + ( u8 ) ( ( c >> 18 ) & 0x07 ) ; 
line 17904: * zOut ++ = 0x80 + ( u8 ) ( ( c >> 12 ) & 0x3F ) ; 
line 17905: * zOut ++ = 0x80 + ( u8 ) ( ( c >> 6 ) & 0x3F ) ; 
line 17906: * zOut ++ = 0x80 + ( u8 ) ( c & 0x3F ) ; 
line 17907: } 
line 17908: } 
line 17910: # define WRITE_UTF16LE ( zOut , c ) { 
line 17911: if ( c <= 0xFFFF ) { 
line 17912: * zOut ++ = ( u8 ) ( c & 0x00FF ) ; 
line 17913: * zOut ++ = ( u8 ) ( ( c >> 8 ) & 0x00FF ) ; 
line 17914: } else { 
line 17915: * zOut ++ = ( u8 ) ( ( ( c >> 10 ) & 0x003F ) + ( ( ( c - 0x10000 ) >> 10 ) & 0x00C0 ) ) ; 
line 17916: * zOut ++ = ( u8 ) ( 0x00D8 + ( ( ( c - 0x10000 ) >> 18 ) & 0x03 ) ) ; 
line 17917: * zOut ++ = ( u8 ) ( c & 0x00FF ) ; 
line 17918: * zOut ++ = ( u8 ) ( 0x00DC + ( ( c >> 8 ) & 0x03 ) ) ; 
line 17919: } 
line 17920: } 
line 17922: # define WRITE_UTF16BE ( zOut , c ) { 
line 17923: if ( c <= 0xFFFF ) { 
line 17924: * zOut ++ = ( u8 ) ( ( c >> 8 ) & 0x00FF ) ; 
line 17925: * zOut ++ = ( u8 ) ( c & 0x00FF ) ; 
line 17926: } else { 
line 17927: * zOut ++ = ( u8 ) ( 0x00D8 + ( ( ( c - 0x10000 ) >> 18 ) & 0x03 ) ) ; 
line 17928: * zOut ++ = ( u8 ) ( ( ( c >> 10 ) & 0x003F ) + ( ( ( c - 0x10000 ) >> 10 ) & 0x00C0 ) ) ; 
line 17929: * zOut ++ = ( u8 ) ( 0x00DC + ( ( c >> 8 ) & 0x03 ) ) ; 
line 17930: * zOut ++ = ( u8 ) ( c & 0x00FF ) ; 
line 17931: } 
line 17932: } 
line 17934: # define READ_UTF16LE ( zIn , TERM , c ) { 
line 17935: c = ( * zIn ++ ) ; 
line 17936: c += ( ( * zIn ++ ) << 8 ) ; 
line 17937: if ( c >= 0xD800 && c < 0xE000 && TERM ) { 
line 17938: int c2 = ( * zIn ++ ) ; 
line 17939: c2 += ( ( * zIn ++ ) << 8 ) ; 
line 17940: c = ( c2 & 0x03FF ) + ( ( c & 0x003F ) << 10 ) + ( ( ( c & 0x03C0 ) + 0x0040 ) << 10 ) ; 
line 17941: } 
line 17942: } 
line 17944: # define READ_UTF16BE ( zIn , TERM , c ) { 
line 17945: c = ( ( * zIn ++ ) << 8 ) ; 
line 17946: c += ( * zIn ++ ) ; 
line 17947: if ( c >= 0xD800 && c < 0xE000 && TERM ) { 
line 17948: int c2 = ( ( * zIn ++ ) << 8 ) ; 
line 17949: c2 += ( * zIn ++ ) ; 
line 17950: c = ( c2 & 0x03FF ) + ( ( c & 0x003F ) << 10 ) + ( ( ( c & 0x03C0 ) + 0x0040 ) << 10 ) ; 
line 17951: } 
line 17952: } 
line 17981: # define READ_UTF8 ( zIn , zTerm , c ) 
line 17982: c = * ( zIn ++ ) ; 
line 17983: if ( c >= 0xc0 ) { 
line 17984: c = sqlite3Utf8Trans1 [ c - 0xc0 ] ; 
line 17985: while ( zIn != zTerm && ( * zIn & 0xc0 ) == 0x80 ) { 
line 17986: c = ( c << 6 ) + ( 0x3f & * ( zIn ++ ) ) ; 
line 17987: } 
line 17988: if ( c < 0x80 
line 17989: || ( c & 0xFFFFF800 ) == 0xD800 
line 17990: || ( c & 0xFFFFFFFE ) == 0xFFFE ) { c = 0xFFFD ; } 
line 17991: } 
line 17992: SQLITE_PRIVATE int sqlite3Utf8Read ( 
line 17993: const unsigned char * zIn , 
line 17994: const unsigned char * * pzNext 
line 17995: ) { 
line 17996: int c ; 
line 18001: c = * ( zIn ++ ) ; 
line 18002: if ( c >= 0xc0 ) { 
line 18003: c = sqlite3Utf8Trans1 [ c - 0xc0 ] ; 
line 18004: while ( ( * zIn & 0xc0 ) == 0x80 ) { 
line 18005: c = ( c << 6 ) + ( 0x3f & * ( zIn ++ ) ) ; 
line 18006: } 
line 18007: if ( c < 0x80 
line 18008: || ( c & 0xFFFFF800 ) == 0xD800 
line 18009: || ( c & 0xFFFFFFFE ) == 0xFFFE ) { c = 0xFFFD ; } 
line 18010: } 
line 18011: * pzNext = zIn ; 
line 18012: return c ; 
line 18013: } 
line 18024: # ifndef SQLITE_OMIT_UTF16 
line 18030: SQLITE_PRIVATE int sqlite3VdbeMemTranslate ( Mem * pMem , u8 desiredEnc ) { 
line 18031: int len ; 
line 18032: unsigned char * zOut ; 
line 18033: unsigned char * zIn ; 
line 18034: unsigned char * zTerm ; 
line 18035: unsigned char * z ; 
line 18036: unsigned int c ; 
line 18038: assert ( pMem -> db == 0 || sqlite3_mutex_held ( pMem -> db -> mutex ) ) ; 
line 18039: assert ( pMem -> flags & MEM_Str ) ; 
line 18040: assert ( pMem -> enc != desiredEnc ) ; 
line 18041: assert ( pMem -> enc != 0 ) ; 
line 18042: assert ( pMem -> n >= 0 ) ; 
line 18044: # if defined ( TRANSLATE_TRACE ) && defined ( SQLITE_DEBUG ) 
line 18045: { 
line 18046: char zBuf [ 100 ] ; 
line 18047: sqlite3VdbeMemPrettyPrint ( pMem , zBuf ) ; 
line 18048: fprintf ( stderr , "INPUT:  %s\n" , zBuf ) ; 
line 18049: } 
line 18050: # endif 
line 18056: if ( pMem -> enc != SQLITE_UTF8 && desiredEnc != SQLITE_UTF8 ) { 
line 18057: u8 temp ; 
line 18058: int rc ; 
line 18059: rc = sqlite3VdbeMemMakeWriteable ( pMem ) ; 
line 18060: if ( rc != SQLITE_OK ) { 
line 18061: assert ( rc == SQLITE_NOMEM ) ; 
line 18062: return SQLITE_NOMEM ; 
line 18063: } 
line 18064: zIn = ( u8 * ) pMem -> z ; 
line 18065: zTerm = & zIn [ pMem -> n & ~ 1 ] ; 
line 18066: while ( zIn < zTerm ) { 
line 18067: temp = * zIn ; 
line 18068: * zIn = * ( zIn + 1 ) ; 
line 18069: zIn ++ ; 
line 18070: * zIn ++ = temp ; 
line 18071: } 
line 18072: pMem -> enc = desiredEnc ; 
line 18073: goto translate_out ; 
line 18074: } 
line 18077: if ( desiredEnc == SQLITE_UTF8 ) { 
line 18083: pMem -> n &= ~ 1 ; 
line 18084: len = pMem -> n * 2 + 1 ; 
line 18085: } else { 
line 18091: len = pMem -> n * 2 + 2 ; 
line 18092: } 
line 18100: zIn = ( u8 * ) pMem -> z ; 
line 18101: zTerm = & zIn [ pMem -> n ] ; 
line 18102: zOut = sqlite3DbMallocRaw ( pMem -> db , len ) ; 
line 18103: if ( ! zOut ) { 
line 18104: return SQLITE_NOMEM ; 
line 18105: } 
line 18106: z = zOut ; 
line 18108: if ( pMem -> enc == SQLITE_UTF8 ) { 
line 18109: if ( desiredEnc == SQLITE_UTF16LE ) { 
line 18111: while ( zIn < zTerm ) { 
line 18113: READ_UTF8 ( zIn , zTerm , c ) ; 
line 18114: WRITE_UTF16LE ( z , c ) ; 
line 18115: } 
line 18116: } else { 
line 18117: assert ( desiredEnc == SQLITE_UTF16BE ) ; 
line 18119: while ( zIn < zTerm ) { 
line 18121: READ_UTF8 ( zIn , zTerm , c ) ; 
line 18122: WRITE_UTF16BE ( z , c ) ; 
line 18123: } 
line 18124: } 
line 18125: pMem -> n = ( int ) ( z - zOut ) ; 
line 18126: * z ++ = 0 ; 
line 18127: } else { 
line 18128: assert ( desiredEnc == SQLITE_UTF8 ) ; 
line 18129: if ( pMem -> enc == SQLITE_UTF16LE ) { 
line 18131: while ( zIn < zTerm ) { 
line 18132: READ_UTF16LE ( zIn , zIn < zTerm , c ) ; 
line 18133: WRITE_UTF8 ( z , c ) ; 
line 18134: } 
line 18135: } else { 
line 18137: while ( zIn < zTerm ) { 
line 18138: READ_UTF16BE ( zIn , zIn < zTerm , c ) ; 
line 18139: WRITE_UTF8 ( z , c ) ; 
line 18140: } 
line 18141: } 
line 18142: pMem -> n = ( int ) ( z - zOut ) ; 
line 18143: } 
line 18144: * z = 0 ; 
line 18145: assert ( ( pMem -> n + ( desiredEnc == SQLITE_UTF8 ? 1 : 2 ) ) <= len ) ; 
line 18147: sqlite3VdbeMemRelease ( pMem ) ; 
line 18148: pMem -> flags &= ~ ( MEM_Static | MEM_Dyn | MEM_Ephem ) ; 
line 18149: pMem -> enc = desiredEnc ; 
line 18150: pMem -> flags |= ( MEM_Term | MEM_Dyn ) ; 
line 18151: pMem -> z = ( char * ) zOut ; 
line 18152: pMem -> zMalloc = pMem -> z ; 
line 18154: translate_out : 
line 18155: # if defined ( TRANSLATE_TRACE ) && defined ( SQLITE_DEBUG ) 
line 18156: { 
line 18157: char zBuf [ 100 ] ; 
line 18158: sqlite3VdbeMemPrettyPrint ( pMem , zBuf ) ; 
line 18159: fprintf ( stderr , "OUTPUT: %s\n" , zBuf ) ; 
line 18160: } 
line 18161: # endif 
line 18162: return SQLITE_OK ; 
line 18163: } 
line 18174: SQLITE_PRIVATE int sqlite3VdbeMemHandleBom ( Mem * pMem ) { 
line 18175: int rc = SQLITE_OK ; 
line 18176: u8 bom = 0 ; 
line 18178: assert ( pMem -> n >= 0 ) ; 
line 18179: if ( pMem -> n > 1 ) { 
line 18180: u8 b1 = * ( u8 * ) pMem -> z ; 
line 18181: u8 b2 = * ( ( ( u8 * ) pMem -> z ) + 1 ) ; 
line 18182: if ( b1 == 0xFE && b2 == 0xFF ) { 
line 18183: bom = SQLITE_UTF16BE ; 
line 18184: } 
line 18185: if ( b1 == 0xFF && b2 == 0xFE ) { 
line 18186: bom = SQLITE_UTF16LE ; 
line 18187: } 
line 18188: } 
line 18190: if ( bom ) { 
line 18191: rc = sqlite3VdbeMemMakeWriteable ( pMem ) ; 
line 18192: if ( rc == SQLITE_OK ) { 
line 18193: pMem -> n -= 2 ; 
line 18194: memmove ( pMem -> z , & pMem -> z [ 2 ] , pMem -> n ) ; 
line 18195: pMem -> z [ pMem -> n ] = '\0' ; 
line 18196: pMem -> z [ pMem -> n + 1 ] = '\0' ; 
line 18197: pMem -> flags |= MEM_Term ; 
line 18198: pMem -> enc = bom ; 
line 18199: } 
line 18200: } 
line 18201: return rc ; 
line 18202: } 
line 18203: # endif 
line 18212: SQLITE_PRIVATE int sqlite3Utf8CharLen ( const char * zIn , int nByte ) { 
line 18213: int r = 0 ; 
line 18214: const u8 * z = ( const u8 * ) zIn ; 
line 18215: const u8 * zTerm ; 
line 18216: if ( nByte >= 0 ) { 
line 18217: zTerm = & z [ nByte ] ; 
line 18218: } else { 
line 18219: zTerm = ( const u8 * ) ( - 1 ) ; 
line 18220: } 
line 18221: assert ( z <= zTerm ) ; 
line 18222: while ( * z != 0 && z < zTerm ) { 
line 18223: SQLITE_SKIP_UTF8 ( z ) ; 
line 18224: r ++ ; 
line 18225: } 
line 18226: return r ; 
line 18227: } 
line 18232: # if defined ( SQLITE_TEST ) && defined ( SQLITE_DEBUG ) 
line 18242: SQLITE_PRIVATE int sqlite3Utf8To8 ( unsigned char * zIn ) { 
line 18243: unsigned char * zOut = zIn ; 
line 18244: unsigned char * zStart = zIn ; 
line 18245: u32 c ; 
line 18247: while ( zIn [ 0 ] ) { 
line 18248: c = sqlite3Utf8Read ( zIn , ( const u8 * * ) & zIn ) ; 
line 18249: if ( c != 0xfffd ) { 
line 18250: WRITE_UTF8 ( zOut , c ) ; 
line 18251: } 
line 18252: } 
line 18253: * zOut = 0 ; 
line 18254: return ( int ) ( zOut - zStart ) ; 
line 18255: } 
line 18256: # endif 
line 18258: # ifndef SQLITE_OMIT_UTF16 
line 18266: SQLITE_PRIVATE char * sqlite3Utf16to8 ( sqlite3 * db , const void * z , int nByte ) { 
line 18267: Mem m ; 
line 18268: memset ( & m , 0 , sizeof ( m ) ) ; 
line 18269: m . db = db ; 
line 18270: sqlite3VdbeMemSetStr ( & m , z , nByte , SQLITE_UTF16NATIVE , SQLITE_STATIC ) ; 
line 18271: sqlite3VdbeChangeEncoding ( & m , SQLITE_UTF8 ) ; 
line 18272: if ( db -> mallocFailed ) { 
line 18273: sqlite3VdbeMemRelease ( & m ) ; 
line 18274: m . z = 0 ; 
line 18275: } 
line 18276: assert ( ( m . flags & MEM_Term ) != 0 || db -> mallocFailed ) ; 
line 18277: assert ( ( m . flags & MEM_Str ) != 0 || db -> mallocFailed ) ; 
line 18278: return ( m . flags & MEM_Dyn ) != 0 ? m . z : sqlite3DbStrDup ( db , m . z ) ; 
line 18279: } 
line 18291: # ifdef SQLITE_ENABLE_STAT2 
line 18292: SQLITE_PRIVATE char * sqlite3Utf8to16 ( sqlite3 * db , u8 enc , char * z , int n , int * pnOut ) { 
line 18293: Mem m ; 
line 18294: memset ( & m , 0 , sizeof ( m ) ) ; 
line 18295: m . db = db ; 
line 18296: sqlite3VdbeMemSetStr ( & m , z , n , SQLITE_UTF8 , SQLITE_STATIC ) ; 
line 18297: if ( sqlite3VdbeMemTranslate ( & m , enc ) ) { 
line 18298: assert ( db -> mallocFailed ) ; 
line 18299: return 0 ; 
line 18300: } 
line 18301: assert ( m . z == m . zMalloc ) ; 
line 18302: * pnOut = m . n ; 
line 18303: return m . z ; 
line 18304: } 
line 18305: # endif 
line 18312: SQLITE_PRIVATE int sqlite3Utf16ByteLen ( const void * zIn , int nChar ) { 
line 18313: int c ; 
line 18314: unsigned char const * z = zIn ; 
line 18315: int n = 0 ; 
line 18317: if ( SQLITE_UTF16NATIVE == SQLITE_UTF16BE ) { 
line 18318: while ( n < nChar ) { 
line 18319: READ_UTF16BE ( z , 1 , c ) ; 
line 18320: n ++ ; 
line 18321: } 
line 18322: } else { 
line 18323: while ( n < nChar ) { 
line 18324: READ_UTF16LE ( z , 1 , c ) ; 
line 18325: n ++ ; 
line 18326: } 
line 18327: } 
line 18328: return ( int ) ( z - ( unsigned char const * ) zIn ) ; 
line 18329: } 
line 18331: # if defined ( SQLITE_TEST ) 
line 18337: SQLITE_PRIVATE void sqlite3UtfSelfTest ( void ) { 
line 18338: unsigned int i , t ; 
line 18339: unsigned char zBuf [ 20 ] ; 
line 18340: unsigned char * z ; 
line 18341: int n ; 
line 18342: unsigned int c ; 
line 18344: for ( i = 0 ; i < 0x00110000 ; i ++ ) { 
line 18345: z = zBuf ; 
line 18346: WRITE_UTF8 ( z , i ) ; 
line 18347: n = ( int ) ( z - zBuf ) ; 
line 18348: assert ( n > 0 && n <= 4 ) ; 
line 18349: z [ 0 ] = 0 ; 
line 18350: z = zBuf ; 
line 18351: c = sqlite3Utf8Read ( z , ( const u8 * * ) & z ) ; 
line 18352: t = i ; 
line 18353: if ( i >= 0xD800 && i <= 0xDFFF ) t = 0xFFFD ; 
line 18354: if ( ( i & 0xFFFFFFFE ) == 0xFFFE ) t = 0xFFFD ; 
line 18355: assert ( c == t ) ; 
line 18356: assert ( ( z - zBuf ) == n ) ; 
line 18357: } 
line 18358: for ( i = 0 ; i < 0x00110000 ; i ++ ) { 
line 18359: if ( i >= 0xD800 && i < 0xE000 ) continue ; 
line 18360: z = zBuf ; 
line 18361: WRITE_UTF16LE ( z , i ) ; 
line 18362: n = ( int ) ( z - zBuf ) ; 
line 18363: assert ( n > 0 && n <= 4 ) ; 
line 18364: z [ 0 ] = 0 ; 
line 18365: z = zBuf ; 
line 18366: READ_UTF16LE ( z , 1 , c ) ; 
line 18367: assert ( c == i ) ; 
line 18368: assert ( ( z - zBuf ) == n ) ; 
line 18369: } 
line 18370: for ( i = 0 ; i < 0x00110000 ; i ++ ) { 
line 18371: if ( i >= 0xD800 && i < 0xE000 ) continue ; 
line 18372: z = zBuf ; 
line 18373: WRITE_UTF16BE ( z , i ) ; 
line 18374: n = ( int ) ( z - zBuf ) ; 
line 18375: assert ( n > 0 && n <= 4 ) ; 
line 18376: z [ 0 ] = 0 ; 
line 18377: z = zBuf ; 
line 18378: READ_UTF16BE ( z , 1 , c ) ; 
line 18379: assert ( c == i ) ; 
line 18380: assert ( ( z - zBuf ) == n ) ; 
line 18381: } 
line 18382: } 
line 18383: # endif 
line 18384: # endif 
line 18405: # ifdef SQLITE_HAVE_ISNAN 
line 18406: # include < math . h > 
line 18407: # endif 
line 18412: # ifdef SQLITE_COVERAGE_TEST 
line 18413: SQLITE_PRIVATE void sqlite3Coverage ( int x ) { 
line 18414: static int dummy = 0 ; 
line 18415: dummy += x ; 
line 18416: } 
line 18417: # endif 
line 18425: SQLITE_PRIVATE int sqlite3IsNaN ( double x ) { 
line 18426: int rc ; 
line 18427: # if ! defined ( SQLITE_HAVE_ISNAN ) 
line 18451: # ifdef __FAST_MATH__ 
line 18452: # error SQLite will not work correctly with the - ffast - math option of GCC . 
line 18453: # endif 
line 18454: volatile double y = x ; 
line 18455: volatile double z = y ; 
line 18456: rc = ( y != z ) ; 
line 18457: # else 
line 18458: rc = isnan ( x ) ; 
line 18459: # endif 
line 18460: testcase ( rc ) ; 
line 18461: return rc ; 
line 18462: } 
line 18472: SQLITE_PRIVATE int sqlite3Strlen30 ( const char * z ) { 
line 18473: const char * z2 = z ; 
line 18474: if ( z == 0 ) return 0 ; 
line 18475: while ( * z2 ) { z2 ++ ; } 
line 18476: return 0x3fffffff & ( int ) ( z2 - z ) ; 
line 18477: } 
line 18500: SQLITE_PRIVATE void sqlite3Error ( sqlite3 * db , int err_code , const char * zFormat , ... ) { 
line 18501: if ( db && ( db -> pErr || ( db -> pErr = sqlite3ValueNew ( db ) ) != 0 ) ) { 
line 18502: db -> errCode = err_code ; 
line 18503: if ( zFormat ) { 
line 18504: char * z ; 
line 18505: va_list ap ; 
line 18506: va_start ( ap , zFormat ) ; 
line 18507: z = sqlite3VMPrintf ( db , zFormat , ap ) ; 
line 18508: va_end ( ap ) ; 
line 18509: sqlite3ValueSetStr ( db -> pErr , - 1 , z , SQLITE_UTF8 , SQLITE_DYNAMIC ) ; 
line 18510: } else { 
line 18511: sqlite3ValueSetStr ( db -> pErr , 0 , 0 , SQLITE_UTF8 , SQLITE_STATIC ) ; 
line 18512: } 
line 18513: } 
line 18514: } 
line 18533: SQLITE_PRIVATE void sqlite3ErrorMsg ( Parse * pParse , const char * zFormat , ... ) { 
line 18534: va_list ap ; 
line 18535: sqlite3 * db = pParse -> db ; 
line 18536: pParse -> nErr ++ ; 
line 18537: sqlite3DbFree ( db , pParse -> zErrMsg ) ; 
line 18538: va_start ( ap , zFormat ) ; 
line 18539: pParse -> zErrMsg = sqlite3VMPrintf ( db , zFormat , ap ) ; 
line 18540: va_end ( ap ) ; 
line 18541: pParse -> rc = SQLITE_ERROR ; 
line 18542: } 
line 18547: SQLITE_PRIVATE void sqlite3ErrorClear ( Parse * pParse ) { 
line 18548: sqlite3DbFree ( pParse -> db , pParse -> zErrMsg ) ; 
line 18549: pParse -> zErrMsg = 0 ; 
line 18550: pParse -> nErr = 0 ; 
line 18551: } 
line 18570: SQLITE_PRIVATE int sqlite3Dequote ( char * z ) { 
line 18571: char quote ; 
line 18572: int i , j ; 
line 18573: if ( z == 0 ) return - 1 ; 
line 18574: quote = z [ 0 ] ; 
line 18575: switch ( quote ) { 
line 18576: case '\'' : break ; 
line 18577: case '"' : break ; 
line 18578: case '`' : break ; 
line 18579: case '[' : quote = ']' ; break ; 
line 18580: default : return - 1 ; 
line 18581: } 
line 18582: for ( i = 1 , j = 0 ; ALWAYS ( z [ i ] ) ; i ++ ) { 
line 18583: if ( z [ i ] == quote ) { 
line 18584: if ( z [ i + 1 ] == quote ) { 
line 18585: z [ j ++ ] = quote ; 
line 18586: i ++ ; 
line 18587: } else { 
line 18588: break ; 
line 18589: } 
line 18590: } else { 
line 18591: z [ j ++ ] = z [ i ] ; 
line 18592: } 
line 18593: } 
line 18594: z [ j ] = 0 ; 
line 18595: return j ; 
line 18596: } 
line 18599: # define UpperToLower sqlite3UpperToLower 
line 18605: SQLITE_PRIVATE int sqlite3StrICmp ( const char * zLeft , const char * zRight ) { 
line 18606: register unsigned char * a , * b ; 
line 18607: a = ( unsigned char * ) zLeft ; 
line 18608: b = ( unsigned char * ) zRight ; 
line 18609: while ( * a != 0 && UpperToLower [ * a ] == UpperToLower [ * b ] ) { a ++ ; b ++ ; } 
line 18610: return UpperToLower [ * a ] - UpperToLower [ * b ] ; 
line 18611: } 
line 18612: SQLITE_API int sqlite3_strnicmp ( const char * zLeft , const char * zRight , int N ) { 
line 18613: register unsigned char * a , * b ; 
line 18614: a = ( unsigned char * ) zLeft ; 
line 18615: b = ( unsigned char * ) zRight ; 
line 18616: while ( N -- > 0 && * a != 0 && UpperToLower [ * a ] == UpperToLower [ * b ] ) { a ++ ; b ++ ; } 
line 18617: return N < 0 ? 0 : UpperToLower [ * a ] - UpperToLower [ * b ] ; 
line 18618: } 
line 18633: SQLITE_PRIVATE int sqlite3IsNumber ( const char * z , int * realnum , u8 enc ) { 
line 18634: int incr = ( enc == SQLITE_UTF8 ? 1 : 2 ) ; 
line 18635: if ( enc == SQLITE_UTF16BE ) z ++ ; 
line 18636: if ( * z == '-' || * z == '+' ) z += incr ; 
line 18637: if ( ! sqlite3Isdigit ( * z ) ) { 
line 18638: return 0 ; 
line 18639: } 
line 18640: z += incr ; 
line 18641: * realnum = 0 ; 
line 18642: while ( sqlite3Isdigit ( * z ) ) { z += incr ; } 
line 18643: if ( * z == '.' ) { 
line 18644: z += incr ; 
line 18645: if ( ! sqlite3Isdigit ( * z ) ) return 0 ; 
line 18646: while ( sqlite3Isdigit ( * z ) ) { z += incr ; } 
line 18647: * realnum = 1 ; 
line 18648: } 
line 18649: if ( * z == 'e' || * z == 'E' ) { 
line 18650: z += incr ; 
line 18651: if ( * z == '+' || * z == '-' ) z += incr ; 
line 18652: if ( ! sqlite3Isdigit ( * z ) ) return 0 ; 
line 18653: while ( sqlite3Isdigit ( * z ) ) { z += incr ; } 
line 18654: * realnum = 1 ; 
line 18655: } 
line 18656: return * z == 0 ; 
line 18657: } 
line 18671: SQLITE_PRIVATE int sqlite3AtoF ( const char * z , double * pResult ) { 
line 18672: # ifndef SQLITE_OMIT_FLOATING_POINT 
line 18673: const char * zBegin = z ; 
line 18675: int sign = 1 ; 
line 18676: i64 s = 0 ; 
line 18677: int d = 0 ; 
line 18678: int esign = 1 ; 
line 18679: int e = 0 ; 
line 18680: double result ; 
line 18681: int nDigits = 0 ; 
line 18684: while ( sqlite3Isspace ( * z ) ) z ++ ; 
line 18686: if ( * z == '-' ) { 
line 18687: sign = - 1 ; 
line 18688: z ++ ; 
line 18689: } else if ( * z == '+' ) { 
line 18690: z ++ ; 
line 18691: } 
line 18693: while ( z [ 0 ] == '0' ) z ++ , nDigits ++ ; 
line 18696: while ( sqlite3Isdigit ( * z ) && s < ( ( LARGEST_INT64 - 9 ) / 10 ) ) { 
line 18697: s = s * 10 + ( * z - '0' ) ; 
line 18698: z ++ , nDigits ++ ; 
line 18699: } 
line 18702: while ( sqlite3Isdigit ( * z ) ) z ++ , nDigits ++ , d ++ ; 
line 18705: if ( * z == '.' ) { 
line 18706: z ++ ; 
line 18709: while ( sqlite3Isdigit ( * z ) && s < ( ( LARGEST_INT64 - 9 ) / 10 ) ) { 
line 18710: s = s * 10 + ( * z - '0' ) ; 
line 18711: z ++ , nDigits ++ , d -- ; 
line 18712: } 
line 18714: while ( sqlite3Isdigit ( * z ) ) z ++ , nDigits ++ ; 
line 18715: } 
line 18718: if ( * z == 'e' || * z == 'E' ) { 
line 18719: z ++ ; 
line 18721: if ( * z == '-' ) { 
line 18722: esign = - 1 ; 
line 18723: z ++ ; 
line 18724: } else if ( * z == '+' ) { 
line 18725: z ++ ; 
line 18726: } 
line 18728: while ( sqlite3Isdigit ( * z ) ) { 
line 18729: e = e * 10 + ( * z - '0' ) ; 
line 18730: z ++ ; 
line 18731: } 
line 18732: } 
line 18735: e = ( e * esign ) + d ; 
line 18736: if ( e < 0 ) { 
line 18737: esign = - 1 ; 
line 18738: e *= - 1 ; 
line 18739: } else { 
line 18740: esign = 1 ; 
line 18741: } 
line 18744: if ( ! s ) { 
line 18747: result = ( sign < 0 && nDigits ) ? - ( double ) 0 : ( double ) 0 ; 
line 18748: } else { 
line 18750: if ( esign > 0 ) { 
line 18751: while ( s < ( LARGEST_INT64 / 10 ) && e > 0 ) e -- , s *= 10 ; 
line 18752: } else { 
line 18753: while ( ! ( s % 10 ) && e > 0 ) e -- , s /= 10 ; 
line 18754: } 
line 18757: s = sign < 0 ? - s : s ; 
line 18761: if ( e ) { 
line 18762: double scale = 1.0 ; 
line 18764: if ( e > 307 && e < 342 ) { 
line 18765: while ( e % 308 ) { scale *= 1.0e+1 ; e -= 1 ; } 
line 18766: if ( esign < 0 ) { 
line 18767: result = s / scale ; 
line 18768: result /= 1.0e+308 ; 
line 18769: } else { 
line 18770: result = s * scale ; 
line 18771: result *= 1.0e+308 ; 
line 18772: } 
line 18773: } else { 
line 18776: while ( e % 22 ) { scale *= 1.0e+1 ; e -= 1 ; } 
line 18777: while ( e > 0 ) { scale *= 1.0e+22 ; e -= 22 ; } 
line 18778: if ( esign < 0 ) { 
line 18779: result = s / scale ; 
line 18780: } else { 
line 18781: result = s * scale ; 
line 18782: } 
line 18783: } 
line 18784: } else { 
line 18785: result = ( double ) s ; 
line 18786: } 
line 18787: } 
line 18790: * pResult = result ; 
line 18793: return ( int ) ( z - zBegin ) ; 
line 18794: # else 
line 18795: return sqlite3Atoi64 ( z , pResult ) ; 
line 18796: # endif 
line 18797: } 
line 18812: static int compare2pow63 ( const char * zNum ) { 
line 18813: int c ; 
line 18814: c = memcmp ( zNum , "922337203685477580" , 18 ) * 10 ; 
line 18815: if ( c == 0 ) { 
line 18816: c = zNum [ 18 ] - '8' ; 
line 18817: } 
line 18818: return c ; 
line 18819: } 
line 18832: SQLITE_PRIVATE int sqlite3Atoi64 ( const char * zNum , i64 * pNum ) { 
line 18833: i64 v = 0 ; 
line 18834: int neg ; 
line 18835: int i , c ; 
line 18836: const char * zStart ; 
line 18837: while ( sqlite3Isspace ( * zNum ) ) zNum ++ ; 
line 18838: if ( * zNum == '-' ) { 
line 18839: neg = 1 ; 
line 18840: zNum ++ ; 
line 18841: } else if ( * zNum == '+' ) { 
line 18842: neg = 0 ; 
line 18843: zNum ++ ; 
line 18844: } else { 
line 18845: neg = 0 ; 
line 18846: } 
line 18847: zStart = zNum ; 
line 18848: while ( zNum [ 0 ] == '0' ) { zNum ++ ; } 
line 18849: for ( i = 0 ; ( c = zNum [ i ] ) >= '0' && c <= '9' ; i ++ ) { 
line 18850: v = v * 10 + c - '0' ; 
line 18851: } 
line 18852: * pNum = neg ? - v : v ; 
line 18853: if ( c != 0 || ( i == 0 && zStart == zNum ) || i > 19 ) { 
line 18856: return 0 ; 
line 18857: } else if ( i < 19 ) { 
line 18859: return 1 ; 
line 18860: } else { 
line 18864: return compare2pow63 ( zNum ) < neg ; 
line 18865: } 
line 18866: } 
line 18885: SQLITE_PRIVATE int sqlite3FitsIn64Bits ( const char * zNum , int negFlag ) { 
line 18886: int i ; 
line 18887: int neg = 0 ; 
line 18889: assert ( zNum [ 0 ] >= '0' && zNum [ 0 ] <= '9' ) ; 
line 18891: if ( negFlag ) neg = 1 - neg ; 
line 18892: while ( * zNum == '0' ) { 
line 18893: zNum ++ ; 
line 18894: } 
line 18895: for ( i = 0 ; zNum [ i ] ; i ++ ) { assert ( zNum [ i ] >= '0' && zNum [ i ] <= '9' ) ; } 
line 18896: if ( i < 19 ) { 
line 18898: return 1 ; 
line 18899: } else if ( i > 19 ) { 
line 18901: return 0 ; 
line 18902: } else { 
line 18904: return compare2pow63 ( zNum ) < neg ; 
line 18905: } 
line 18906: } 
line 18916: SQLITE_PRIVATE int sqlite3GetInt32 ( const char * zNum , int * pValue ) { 
line 18917: sqlite_int64 v = 0 ; 
line 18918: int i , c ; 
line 18919: int neg = 0 ; 
line 18920: if ( zNum [ 0 ] == '-' ) { 
line 18921: neg = 1 ; 
line 18922: zNum ++ ; 
line 18923: } else if ( zNum [ 0 ] == '+' ) { 
line 18924: zNum ++ ; 
line 18925: } 
line 18926: while ( zNum [ 0 ] == '0' ) zNum ++ ; 
line 18927: for ( i = 0 ; i < 11 && ( c = zNum [ i ] - '0' ) >= 0 && c <= 9 ; i ++ ) { 
line 18928: v = v * 10 + c ; 
line 18929: } 
line 18936: if ( i > 10 ) { 
line 18937: return 0 ; 
line 18938: } 
line 18939: if ( v - neg > 2147483647 ) { 
line 18940: return 0 ; 
line 18941: } 
line 18942: if ( neg ) { 
line 18943: v = - v ; 
line 18944: } 
line 18945: * pValue = ( int ) v ; 
line 18946: return 1 ; 
line 18947: } 
line 18978: SQLITE_PRIVATE int sqlite3PutVarint ( unsigned char * p , u64 v ) { 
line 18979: int i , j , n ; 
line 18980: u8 buf [ 10 ] ; 
line 18981: if ( v & ( ( ( u64 ) 0xff000000 ) << 32 ) ) { 
line 18982: p [ 8 ] = ( u8 ) v ; 
line 18983: v >>= 8 ; 
line 18984: for ( i = 7 ; i >= 0 ; i -- ) { 
line 18985: p [ i ] = ( u8 ) ( ( v & 0x7f ) | 0x80 ) ; 
line 18986: v >>= 7 ; 
line 18987: } 
line 18988: return 9 ; 
line 18989: } 
line 18990: n = 0 ; 
line 18991: do { 
line 18992: buf [ n ++ ] = ( u8 ) ( ( v & 0x7f ) | 0x80 ) ; 
line 18993: v >>= 7 ; 
line 18994: } while ( v != 0 ) ; 
line 18995: buf [ 0 ] &= 0x7f ; 
line 18996: assert ( n <= 9 ) ; 
line 18997: for ( i = 0 , j = n - 1 ; j >= 0 ; j -- , i ++ ) { 
line 18998: p [ i ] = buf [ j ] ; 
line 18999: } 
line 19000: return n ; 
line 19001: } 
line 19011: SQLITE_PRIVATE int sqlite3PutVarint32 ( unsigned char * p , u32 v ) { 
line 19012: # ifndef putVarint32 
line 19013: if ( ( v & ~ 0x7f ) == 0 ) { 
line 19014: p [ 0 ] = v ; 
line 19015: return 1 ; 
line 19016: } 
line 19017: # endif 
line 19018: if ( ( v & ~ 0x3fff ) == 0 ) { 
line 19019: p [ 0 ] = ( u8 ) ( ( v >> 7 ) | 0x80 ) ; 
line 19020: p [ 1 ] = ( u8 ) ( v & 0x7f ) ; 
line 19021: return 2 ; 
line 19022: } 
line 19023: return sqlite3PutVarint ( p , v ) ; 
line 19024: } 
line 19030: SQLITE_PRIVATE u8 sqlite3GetVarint ( const unsigned char * p , u64 * v ) { 
line 19031: u32 a , b , s ; 
line 19033: a = * p ; 
line 19035: if ( ! ( a & 0x80 ) ) 
line 19036: { 
line 19037: * v = a ; 
line 19038: return 1 ; 
line 19039: } 
line 19041: p ++ ; 
line 19042: b = * p ; 
line 19044: if ( ! ( b & 0x80 ) ) 
line 19045: { 
line 19046: a &= 0x7f ; 
line 19047: a = a << 7 ; 
line 19048: a |= b ; 
line 19049: * v = a ; 
line 19050: return 2 ; 
line 19051: } 
line 19053: p ++ ; 
line 19054: a = a << 14 ; 
line 19055: a |= * p ; 
line 19057: if ( ! ( a & 0x80 ) ) 
line 19058: { 
line 19059: a &= ( 0x7f << 14 ) | ( 0x7f ) ; 
line 19060: b &= 0x7f ; 
line 19061: b = b << 7 ; 
line 19062: a |= b ; 
line 19063: * v = a ; 
line 19064: return 3 ; 
line 19065: } 
line 19068: a &= ( 0x7f << 14 ) | ( 0x7f ) ; 
line 19069: p ++ ; 
line 19070: b = b << 14 ; 
line 19071: b |= * p ; 
line 19073: if ( ! ( b & 0x80 ) ) 
line 19074: { 
line 19075: b &= ( 0x7f << 14 ) | ( 0x7f ) ; 
line 19078: a = a << 7 ; 
line 19079: a |= b ; 
line 19080: * v = a ; 
line 19081: return 4 ; 
line 19082: } 
line 19089: b &= ( 0x7f << 14 ) | ( 0x7f ) ; 
line 19090: s = a ; 
line 19093: p ++ ; 
line 19094: a = a << 14 ; 
line 19095: a |= * p ; 
line 19097: if ( ! ( a & 0x80 ) ) 
line 19098: { 
line 19102: b = b << 7 ; 
line 19103: a |= b ; 
line 19104: s = s >> 18 ; 
line 19105: * v = ( ( u64 ) s ) << 32 | a ; 
line 19106: return 5 ; 
line 19107: } 
line 19110: s = s << 7 ; 
line 19111: s |= b ; 
line 19114: p ++ ; 
line 19115: b = b << 14 ; 
line 19116: b |= * p ; 
line 19118: if ( ! ( b & 0x80 ) ) 
line 19119: { 
line 19122: a &= ( 0x7f << 14 ) | ( 0x7f ) ; 
line 19123: a = a << 7 ; 
line 19124: a |= b ; 
line 19125: s = s >> 18 ; 
line 19126: * v = ( ( u64 ) s ) << 32 | a ; 
line 19127: return 6 ; 
line 19128: } 
line 19130: p ++ ; 
line 19131: a = a << 14 ; 
line 19132: a |= * p ; 
line 19134: if ( ! ( a & 0x80 ) ) 
line 19135: { 
line 19136: a &= ( 0x1f << 28 ) | ( 0x7f << 14 ) | ( 0x7f ) ; 
line 19137: b &= ( 0x7f << 14 ) | ( 0x7f ) ; 
line 19138: b = b << 7 ; 
line 19139: a |= b ; 
line 19140: s = s >> 11 ; 
line 19141: * v = ( ( u64 ) s ) << 32 | a ; 
line 19142: return 7 ; 
line 19143: } 
line 19146: a &= ( 0x7f << 14 ) | ( 0x7f ) ; 
line 19147: p ++ ; 
line 19148: b = b << 14 ; 
line 19149: b |= * p ; 
line 19151: if ( ! ( b & 0x80 ) ) 
line 19152: { 
line 19153: b &= ( 0x1f << 28 ) | ( 0x7f << 14 ) | ( 0x7f ) ; 
line 19156: a = a << 7 ; 
line 19157: a |= b ; 
line 19158: s = s >> 4 ; 
line 19159: * v = ( ( u64 ) s ) << 32 | a ; 
line 19160: return 8 ; 
line 19161: } 
line 19163: p ++ ; 
line 19164: a = a << 15 ; 
line 19165: a |= * p ; 
line 19170: b &= ( 0x7f << 14 ) | ( 0x7f ) ; 
line 19171: b = b << 8 ; 
line 19172: a |= b ; 
line 19174: s = s << 4 ; 
line 19175: b = p [ - 4 ] ; 
line 19176: b &= 0x7f ; 
line 19177: b = b >> 3 ; 
line 19178: s |= b ; 
line 19180: * v = ( ( u64 ) s ) << 32 | a ; 
line 19182: return 9 ; 
line 19183: } 
line 19196: SQLITE_PRIVATE u8 sqlite3GetVarint32 ( const unsigned char * p , u32 * v ) { 
line 19197: u32 a , b ; 
line 19201: a = * p ; 
line 19203: # ifndef getVarint32 
line 19204: if ( ! ( a & 0x80 ) ) 
line 19205: { 
line 19207: * v = a ; 
line 19208: return 1 ; 
line 19209: } 
line 19210: # endif 
line 19213: p ++ ; 
line 19214: b = * p ; 
line 19216: if ( ! ( b & 0x80 ) ) 
line 19217: { 
line 19219: a &= 0x7f ; 
line 19220: a = a << 7 ; 
line 19221: * v = a | b ; 
line 19222: return 2 ; 
line 19223: } 
line 19226: p ++ ; 
line 19227: a = a << 14 ; 
line 19228: a |= * p ; 
line 19230: if ( ! ( a & 0x80 ) ) 
line 19231: { 
line 19233: a &= ( 0x7f << 14 ) | ( 0x7f ) ; 
line 19234: b &= 0x7f ; 
line 19235: b = b << 7 ; 
line 19236: * v = a | b ; 
line 19237: return 3 ; 
line 19238: } 
line 19249: # if 1 
line 19250: { 
line 19251: u64 v64 ; 
line 19252: u8 n ; 
line 19254: p -= 2 ; 
line 19255: n = sqlite3GetVarint ( p , & v64 ) ; 
line 19256: assert ( n > 3 && n <= 9 ) ; 
line 19257: if ( ( v64 & SQLITE_MAX_U32 ) != v64 ) { 
line 19258: * v = 0xffffffff ; 
line 19259: } else { 
line 19260: * v = ( u32 ) v64 ; 
line 19261: } 
line 19262: return n ; 
line 19263: } 
line 19265: # else 
line 19270: p ++ ; 
line 19271: b = b << 14 ; 
line 19272: b |= * p ; 
line 19274: if ( ! ( b & 0x80 ) ) 
line 19275: { 
line 19277: b &= ( 0x7f << 14 ) | ( 0x7f ) ; 
line 19278: a &= ( 0x7f << 14 ) | ( 0x7f ) ; 
line 19279: a = a << 7 ; 
line 19280: * v = a | b ; 
line 19281: return 4 ; 
line 19282: } 
line 19284: p ++ ; 
line 19285: a = a << 14 ; 
line 19286: a |= * p ; 
line 19288: if ( ! ( a & 0x80 ) ) 
line 19289: { 
line 19291: a &= ( 0x1f << 28 ) | ( 0x7f << 14 ) | ( 0x7f ) ; 
line 19292: b &= ( 0x1f << 28 ) | ( 0x7f << 14 ) | ( 0x7f ) ; 
line 19293: b = b << 7 ; 
line 19294: * v = a | b ; 
line 19295: return 5 ; 
line 19296: } 
line 19302: { 
line 19303: u64 v64 ; 
line 19304: u8 n ; 
line 19306: p -= 4 ; 
line 19307: n = sqlite3GetVarint ( p , & v64 ) ; 
line 19308: assert ( n > 5 && n <= 9 ) ; 
line 19309: * v = ( u32 ) v64 ; 
line 19310: return n ; 
line 19311: } 
line 19312: # endif 
line 19313: } 
line 19319: SQLITE_PRIVATE int sqlite3VarintLen ( u64 v ) { 
line 19320: int i = 0 ; 
line 19321: do { 
line 19322: i ++ ; 
line 19323: v >>= 7 ; 
line 19324: } while ( v != 0 && ALWAYS ( i < 9 ) ) ; 
line 19325: return i ; 
line 19326: } 
line 19332: SQLITE_PRIVATE u32 sqlite3Get4byte ( const u8 * p ) { 
line 19333: return ( p [ 0 ] << 24 ) | ( p [ 1 ] << 16 ) | ( p [ 2 ] << 8 ) | p [ 3 ] ; 
line 19334: } 
line 19335: SQLITE_PRIVATE void sqlite3Put4byte ( unsigned char * p , u32 v ) { 
line 19336: p [ 0 ] = ( u8 ) ( v >> 24 ) ; 
line 19337: p [ 1 ] = ( u8 ) ( v >> 16 ) ; 
line 19338: p [ 2 ] = ( u8 ) ( v >> 8 ) ; 
line 19339: p [ 3 ] = ( u8 ) v ; 
line 19340: } 
line 19344: # if ! defined ( SQLITE_OMIT_BLOB_LITERAL ) || defined ( SQLITE_HAS_CODEC ) 
line 19350: static u8 hexToInt ( int h ) { 
line 19351: assert ( ( h >= '0' && h <= '9' ) || ( h >= 'a' && h <= 'f' ) || ( h >= 'A' && h <= 'F' ) ) ; 
line 19352: # ifdef SQLITE_ASCII 
line 19353: h += 9 * ( 1 & ( h >> 6 ) ) ; 
line 19354: # endif 
line 19355: # ifdef SQLITE_EBCDIC 
line 19356: h += 9 * ( 1 & ~ ( h >> 4 ) ) ; 
line 19357: # endif 
line 19358: return ( u8 ) ( h & 0xf ) ; 
line 19359: } 
line 19360: # endif 
line 19362: # if ! defined ( SQLITE_OMIT_BLOB_LITERAL ) || defined ( SQLITE_HAS_CODEC ) 
line 19369: SQLITE_PRIVATE void * sqlite3HexToBlob ( sqlite3 * db , const char * z , int n ) { 
line 19370: char * zBlob ; 
line 19371: int i ; 
line 19373: zBlob = ( char * ) sqlite3DbMallocRaw ( db , n / 2 + 1 ) ; 
line 19374: n -- ; 
line 19375: if ( zBlob ) { 
line 19376: for ( i = 0 ; i < n ; i += 2 ) { 
line 19377: zBlob [ i / 2 ] = ( hexToInt ( z [ i ] ) << 4 ) | hexToInt ( z [ i + 1 ] ) ; 
line 19378: } 
line 19379: zBlob [ i / 2 ] = 0 ; 
line 19380: } 
line 19381: return zBlob ; 
line 19382: } 
line 19383: # endif 
line 19411: # ifdef SQLITE_DEBUG 
line 19412: SQLITE_PRIVATE int sqlite3SafetyOn ( sqlite3 * db ) { 
line 19413: if ( db -> magic == SQLITE_MAGIC_OPEN ) { 
line 19414: db -> magic = SQLITE_MAGIC_BUSY ; 
line 19415: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 19416: return 0 ; 
line 19417: } else if ( db -> magic == SQLITE_MAGIC_BUSY ) { 
line 19418: db -> magic = SQLITE_MAGIC_ERROR ; 
line 19419: db -> u1 . isInterrupted = 1 ; 
line 19420: } 
line 19421: return 1 ; 
line 19422: } 
line 19423: # endif 
line 19430: # ifdef SQLITE_DEBUG 
line 19431: SQLITE_PRIVATE int sqlite3SafetyOff ( sqlite3 * db ) { 
line 19432: if ( db -> magic == SQLITE_MAGIC_BUSY ) { 
line 19433: db -> magic = SQLITE_MAGIC_OPEN ; 
line 19434: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 19435: return 0 ; 
line 19436: } else { 
line 19437: db -> magic = SQLITE_MAGIC_ERROR ; 
line 19438: db -> u1 . isInterrupted = 1 ; 
line 19439: return 1 ; 
line 19440: } 
line 19441: } 
line 19442: # endif 
line 19458: SQLITE_PRIVATE int sqlite3SafetyCheckOk ( sqlite3 * db ) { 
line 19459: u32 magic ; 
line 19460: if ( db == 0 ) return 0 ; 
line 19461: magic = db -> magic ; 
line 19462: if ( magic != SQLITE_MAGIC_OPEN 
line 19463: # ifdef SQLITE_DEBUG 
line 19464: && magic != SQLITE_MAGIC_BUSY 
line 19465: # endif 
line 19466: ) { 
line 19467: return 0 ; 
line 19468: } else { 
line 19469: return 1 ; 
line 19470: } 
line 19471: } 
line 19472: SQLITE_PRIVATE int sqlite3SafetyCheckSickOrOk ( sqlite3 * db ) { 
line 19473: u32 magic ; 
line 19474: magic = db -> magic ; 
line 19475: if ( magic != SQLITE_MAGIC_SICK && 
line 19476: magic != SQLITE_MAGIC_OPEN && 
line 19477: magic != SQLITE_MAGIC_BUSY ) return 0 ; 
line 19478: return 1 ; 
line 19479: } 
line 19503: SQLITE_PRIVATE void sqlite3HashInit ( Hash * pNew ) { 
line 19504: assert ( pNew != 0 ) ; 
line 19505: pNew -> first = 0 ; 
line 19506: pNew -> count = 0 ; 
line 19507: pNew -> htsize = 0 ; 
line 19508: pNew -> ht = 0 ; 
line 19509: } 
line 19515: SQLITE_PRIVATE void sqlite3HashClear ( Hash * pH ) { 
line 19516: HashElem * elem ; 
line 19518: assert ( pH != 0 ) ; 
line 19519: elem = pH -> first ; 
line 19520: pH -> first = 0 ; 
line 19521: sqlite3_free ( pH -> ht ) ; 
line 19522: pH -> ht = 0 ; 
line 19523: pH -> htsize = 0 ; 
line 19524: while ( elem ) { 
line 19525: HashElem * next_elem = elem -> next ; 
line 19526: sqlite3_free ( elem ) ; 
line 19527: elem = next_elem ; 
line 19528: } 
line 19529: pH -> count = 0 ; 
line 19530: } 
line 19535: static unsigned int strHash ( const char * z , int nKey ) { 
line 19536: int h = 0 ; 
line 19537: assert ( nKey >= 0 ) ; 
line 19538: while ( nKey > 0 ) { 
line 19539: h = ( h << 3 ) ^ h ^ sqlite3UpperToLower [ ( unsigned char ) * z ++ ] ; 
line 19540: nKey -- ; 
line 19541: } 
line 19542: return h ; 
line 19543: } 
line 19549: static void insertElement ( 
line 19550: Hash * pH , 
line 19551: struct _ht * pEntry , 
line 19552: HashElem * pNew 
line 19553: ) { 
line 19554: HashElem * pHead ; 
line 19555: if ( pEntry ) { 
line 19556: pHead = pEntry -> count ? pEntry -> chain : 0 ; 
line 19557: pEntry -> count ++ ; 
line 19558: pEntry -> chain = pNew ; 
line 19559: } else { 
line 19560: pHead = 0 ; 
line 19561: } 
line 19562: if ( pHead ) { 
line 19563: pNew -> next = pHead ; 
line 19564: pNew -> prev = pHead -> prev ; 
line 19565: if ( pHead -> prev ) { pHead -> prev -> next = pNew ; } 
line 19566: else { pH -> first = pNew ; } 
line 19567: pHead -> prev = pNew ; 
line 19568: } else { 
line 19569: pNew -> next = pH -> first ; 
line 19570: if ( pH -> first ) { pH -> first -> prev = pNew ; } 
line 19571: pNew -> prev = 0 ; 
line 19572: pH -> first = pNew ; 
line 19573: } 
line 19574: } 
line 19583: static int rehash ( Hash * pH , unsigned int new_size ) { 
line 19584: struct _ht * new_ht ; 
line 19585: HashElem * elem , * next_elem ; 
line 19587: # if SQLITE_MALLOC_SOFT_LIMIT > 0 
line 19588: if ( new_size * sizeof ( struct _ht ) > SQLITE_MALLOC_SOFT_LIMIT ) { 
line 19589: new_size = SQLITE_MALLOC_SOFT_LIMIT / sizeof ( struct _ht ) ; 
line 19590: } 
line 19591: if ( new_size == pH -> htsize ) return 0 ; 
line 19592: # endif 
line 19598: sqlite3BeginBenignMalloc ( ) ; 
line 19599: new_ht = ( struct _ht * ) sqlite3Malloc ( new_size * sizeof ( struct _ht ) ) ; 
line 19600: sqlite3EndBenignMalloc ( ) ; 
line 19602: if ( new_ht == 0 ) return 0 ; 
line 19603: sqlite3_free ( pH -> ht ) ; 
line 19604: pH -> ht = new_ht ; 
line 19605: pH -> htsize = new_size = sqlite3MallocSize ( new_ht ) / sizeof ( struct _ht ) ; 
line 19606: memset ( new_ht , 0 , new_size * sizeof ( struct _ht ) ) ; 
line 19607: for ( elem = pH -> first , pH -> first = 0 ; elem ; elem = next_elem ) { 
line 19608: unsigned int h = strHash ( elem -> pKey , elem -> nKey ) % new_size ; 
line 19609: next_elem = elem -> next ; 
line 19610: insertElement ( pH , & new_ht [ h ] , elem ) ; 
line 19611: } 
line 19612: return 1 ; 
line 19613: } 
line 19619: static HashElem * findElementGivenHash ( 
line 19620: const Hash * pH , 
line 19621: const char * pKey , 
line 19622: int nKey , 
line 19623: unsigned int h 
line 19624: ) { 
line 19625: HashElem * elem ; 
line 19626: int count ; 
line 19628: if ( pH -> ht ) { 
line 19629: struct _ht * pEntry = & pH -> ht [ h ] ; 
line 19630: elem = pEntry -> chain ; 
line 19631: count = pEntry -> count ; 
line 19632: } else { 
line 19633: elem = pH -> first ; 
line 19634: count = pH -> count ; 
line 19635: } 
line 19636: while ( count -- && ALWAYS ( elem ) ) { 
line 19637: if ( elem -> nKey == nKey && sqlite3StrNICmp ( elem -> pKey , pKey , nKey ) == 0 ) { 
line 19638: return elem ; 
line 19639: } 
line 19640: elem = elem -> next ; 
line 19641: } 
line 19642: return 0 ; 
line 19643: } 
line 19648: static void removeElementGivenHash ( 
line 19649: Hash * pH , 
line 19650: HashElem * elem , 
line 19651: unsigned int h 
line 19652: ) { 
line 19653: struct _ht * pEntry ; 
line 19654: if ( elem -> prev ) { 
line 19655: elem -> prev -> next = elem -> next ; 
line 19656: } else { 
line 19657: pH -> first = elem -> next ; 
line 19658: } 
line 19659: if ( elem -> next ) { 
line 19660: elem -> next -> prev = elem -> prev ; 
line 19661: } 
line 19662: if ( pH -> ht ) { 
line 19663: pEntry = & pH -> ht [ h ] ; 
line 19664: if ( pEntry -> chain == elem ) { 
line 19665: pEntry -> chain = elem -> next ; 
line 19666: } 
line 19667: pEntry -> count -- ; 
line 19668: assert ( pEntry -> count >= 0 ) ; 
line 19669: } 
line 19670: sqlite3_free ( elem ) ; 
line 19671: pH -> count -- ; 
line 19672: if ( pH -> count <= 0 ) { 
line 19673: assert ( pH -> first == 0 ) ; 
line 19674: assert ( pH -> count == 0 ) ; 
line 19675: sqlite3HashClear ( pH ) ; 
line 19676: } 
line 19677: } 
line 19683: SQLITE_PRIVATE void * sqlite3HashFind ( const Hash * pH , const char * pKey , int nKey ) { 
line 19684: HashElem * elem ; 
line 19685: unsigned int h ; 
line 19687: assert ( pH != 0 ) ; 
line 19688: assert ( pKey != 0 ) ; 
line 19689: assert ( nKey >= 0 ) ; 
line 19690: if ( pH -> ht ) { 
line 19691: h = strHash ( pKey , nKey ) % pH -> htsize ; 
line 19692: } else { 
line 19693: h = 0 ; 
line 19694: } 
line 19695: elem = findElementGivenHash ( pH , pKey , nKey , h ) ; 
line 19696: return elem ? elem -> data : 0 ; 
line 19697: } 
line 19713: SQLITE_PRIVATE void * sqlite3HashInsert ( Hash * pH , const char * pKey , int nKey , void * data ) { 
line 19714: unsigned int h ; 
line 19715: HashElem * elem ; 
line 19716: HashElem * new_elem ; 
line 19718: assert ( pH != 0 ) ; 
line 19719: assert ( pKey != 0 ) ; 
line 19720: assert ( nKey >= 0 ) ; 
line 19721: if ( pH -> htsize ) { 
line 19722: h = strHash ( pKey , nKey ) % pH -> htsize ; 
line 19723: } else { 
line 19724: h = 0 ; 
line 19725: } 
line 19726: elem = findElementGivenHash ( pH , pKey , nKey , h ) ; 
line 19727: if ( elem ) { 
line 19728: void * old_data = elem -> data ; 
line 19729: if ( data == 0 ) { 
line 19730: removeElementGivenHash ( pH , elem , h ) ; 
line 19731: } else { 
line 19732: elem -> data = data ; 
line 19733: elem -> pKey = pKey ; 
line 19734: assert ( nKey == elem -> nKey ) ; 
line 19735: } 
line 19736: return old_data ; 
line 19737: } 
line 19738: if ( data == 0 ) return 0 ; 
line 19739: new_elem = ( HashElem * ) sqlite3Malloc ( sizeof ( HashElem ) ) ; 
line 19740: if ( new_elem == 0 ) return data ; 
line 19741: new_elem -> pKey = pKey ; 
line 19742: new_elem -> nKey = nKey ; 
line 19743: new_elem -> data = data ; 
line 19744: pH -> count ++ ; 
line 19745: if ( pH -> count >= 10 && pH -> count > 2 * pH -> htsize ) { 
line 19746: if ( rehash ( pH , pH -> count * 2 ) ) { 
line 19747: assert ( pH -> htsize > 0 ) ; 
line 19748: h = strHash ( pKey , nKey ) % pH -> htsize ; 
line 19749: } 
line 19750: } 
line 19751: if ( pH -> ht ) { 
line 19752: insertElement ( pH , & pH -> ht [ h ] , new_elem ) ; 
line 19753: } else { 
line 19754: insertElement ( pH , 0 , new_elem ) ; 
line 19755: } 
line 19756: return 0 ; 
line 19757: } 
line 19763: # if ! defined ( SQLITE_OMIT_EXPLAIN ) || ! defined ( NDEBUG ) || defined ( VDBE_PROFILE ) || defined ( SQLITE_DEBUG ) 
line 19764: SQLITE_PRIVATE const char * sqlite3OpcodeName ( int i ) { 
line 19765: static const char * const azName [ ] = { "?" , 
line 19766: "Goto" , 
line 19767: "Gosub" , 
line 19768: "Return" , 
line 19769: "Yield" , 
line 19770: "HaltIfNull" , 
line 19771: "Halt" , 
line 19772: "Integer" , 
line 19773: "Int64" , 
line 19774: "String" , 
line 19775: "Null" , 
line 19776: "Blob" , 
line 19777: "Variable" , 
line 19778: "Move" , 
line 19779: "Copy" , 
line 19780: "SCopy" , 
line 19781: "ResultRow" , 
line 19782: "CollSeq" , 
line 19783: "Function" , 
line 19784: "Not" , 
line 19785: "AddImm" , 
line 19786: "MustBeInt" , 
line 19787: "RealAffinity" , 
line 19788: "Permutation" , 
line 19789: "Compare" , 
line 19790: "Jump" , 
line 19791: "If" , 
line 19792: "IfNot" , 
line 19793: "Column" , 
line 19794: "Affinity" , 
line 19795: "MakeRecord" , 
line 19796: "Count" , 
line 19797: "Savepoint" , 
line 19798: "AutoCommit" , 
line 19799: "Transaction" , 
line 19800: "ReadCookie" , 
line 19801: "SetCookie" , 
line 19802: "VerifyCookie" , 
line 19803: "OpenRead" , 
line 19804: "OpenWrite" , 
line 19805: "OpenEphemeral" , 
line 19806: "OpenPseudo" , 
line 19807: "Close" , 
line 19808: "SeekLt" , 
line 19809: "SeekLe" , 
line 19810: "SeekGe" , 
line 19811: "SeekGt" , 
line 19812: "Seek" , 
line 19813: "NotFound" , 
line 19814: "Found" , 
line 19815: "IsUnique" , 
line 19816: "NotExists" , 
line 19817: "Sequence" , 
line 19818: "NewRowid" , 
line 19819: "Insert" , 
line 19820: "InsertInt" , 
line 19821: "Delete" , 
line 19822: "ResetCount" , 
line 19823: "RowKey" , 
line 19824: "RowData" , 
line 19825: "Rowid" , 
line 19826: "NullRow" , 
line 19827: "Last" , 
line 19828: "Sort" , 
line 19829: "Rewind" , 
line 19830: "Prev" , 
line 19831: "Next" , 
line 19832: "IdxInsert" , 
line 19833: "Or" , 
line 19834: "And" , 
line 19835: "IdxDelete" , 
line 19836: "IdxRowid" , 
line 19837: "IdxLT" , 
line 19838: "IsNull" , 
line 19839: "NotNull" , 
line 19840: "Ne" , 
line 19841: "Eq" , 
line 19842: "Gt" , 
line 19843: "Le" , 
line 19844: "Lt" , 
line 19845: "Ge" , 
line 19846: "IdxGE" , 
line 19847: "BitAnd" , 
line 19848: "BitOr" , 
line 19849: "ShiftLeft" , 
line 19850: "ShiftRight" , 
line 19851: "Add" , 
line 19852: "Subtract" , 
line 19853: "Multiply" , 
line 19854: "Divide" , 
line 19855: "Remainder" , 
line 19856: "Concat" , 
line 19857: "Destroy" , 
line 19858: "BitNot" , 
line 19859: "String8" , 
line 19860: "Clear" , 
line 19861: "CreateIndex" , 
line 19862: "CreateTable" , 
line 19863: "ParseSchema" , 
line 19864: "LoadAnalysis" , 
line 19865: "DropTable" , 
line 19866: "DropIndex" , 
line 19867: "DropTrigger" , 
line 19868: "IntegrityCk" , 
line 19869: "RowSetAdd" , 
line 19870: "RowSetRead" , 
line 19871: "RowSetTest" , 
line 19872: "Program" , 
line 19873: "Param" , 
line 19874: "FkCounter" , 
line 19875: "FkIfZero" , 
line 19876: "MemMax" , 
line 19877: "IfPos" , 
line 19878: "IfNeg" , 
line 19879: "IfZero" , 
line 19880: "AggStep" , 
line 19881: "AggFinal" , 
line 19882: "Vacuum" , 
line 19883: "IncrVacuum" , 
line 19884: "Expire" , 
line 19885: "TableLock" , 
line 19886: "VBegin" , 
line 19887: "VCreate" , 
line 19888: "VDestroy" , 
line 19889: "VOpen" , 
line 19890: "VFilter" , 
line 19891: "VColumn" , 
line 19892: "VNext" , 
line 19893: "VRename" , 
line 19894: "VUpdate" , 
line 19895: "Real" , 
line 19896: "Pagecount" , 
line 19897: "Trace" , 
line 19898: "Noop" , 
line 19899: "Explain" , 
line 19900: "NotUsed_135" , 
line 19901: "NotUsed_136" , 
line 19902: "NotUsed_137" , 
line 19903: "NotUsed_138" , 
line 19904: "NotUsed_139" , 
line 19905: "NotUsed_140" , 
line 19906: "ToText" , 
line 19907: "ToBlob" , 
line 19908: "ToNumeric" , 
line 19909: "ToInt" , 
line 19910: "ToReal" , 
line 19911: } ; 
line 19912: return azName [ i ] ; 
line 19913: } 
line 19914: # endif 
line 19934: # if SQLITE_OS_OS2 
line 19965: # if defined ( SQLITE_THREADSAFE ) && SQLITE_THREADSAFE 
line 19966: # define SQLITE_OS2_THREADS 1 
line 19967: # endif 
line 19993: # ifndef _OS_COMMON_H_ 
line 19994: # define _OS_COMMON_H_ 
line 20001: # ifdef MEMORY_DEBUG 
line 20002: # error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead." 
line 20003: # endif 
line 20005: # ifdef SQLITE_DEBUG 
line 20006: SQLITE_PRIVATE int sqlite3OSTrace = 0 ; 
line 20007: # define OSTRACE1 ( X ) if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X ) 
line 20008: # define OSTRACE2 ( X , Y ) if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y ) 
line 20009: # define OSTRACE3 ( X , Y , Z ) if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y , Z ) 
line 20010: # define OSTRACE4 ( X , Y , Z , A ) if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y , Z , A ) 
line 20011: # define OSTRACE5 ( X , Y , Z , A , B ) if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y , Z , A , B ) 
line 20012: # define OSTRACE6 ( X , Y , Z , A , B , C ) 
line 20013: if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y , Z , A , B , C ) 
line 20014: # define OSTRACE7 ( X , Y , Z , A , B , C , D ) 
line 20015: if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y , Z , A , B , C , D ) 
line 20016: # else 
line 20017: # define OSTRACE1 ( X ) 
line 20018: # define OSTRACE2 ( X , Y ) 
line 20019: # define OSTRACE3 ( X , Y , Z ) 
line 20020: # define OSTRACE4 ( X , Y , Z , A ) 
line 20021: # define OSTRACE5 ( X , Y , Z , A , B ) 
line 20022: # define OSTRACE6 ( X , Y , Z , A , B , C ) 
line 20023: # define OSTRACE7 ( X , Y , Z , A , B , C , D ) 
line 20024: # endif 
line 20030: # ifdef SQLITE_PERFORMANCE_TRACE 
line 20053: # ifndef _HWTIME_H_ 
line 20054: # define _HWTIME_H_ 
line 20062: # if ( defined ( __GNUC__ ) || defined ( _MSC_VER ) ) && 
line 20063: ( defined ( i386 ) || defined ( __i386__ ) || defined ( _M_IX86 ) ) 
line 20065: # if defined ( __GNUC__ ) 
line 20067: __inline__ sqlite_uint64 sqlite3Hwtime ( void ) { 
line 20068: unsigned int lo , hi ; 
line 20069: __asm__ __volatile__ ( "rdtsc" : "=a" ( lo ) , "=d" ( hi ) ) ; 
line 20070: return ( sqlite_uint64 ) hi << 32 | lo ; 
line 20071: } 
line 20073: # elif defined ( _MSC_VER ) 
line 20075: __declspec ( naked ) __inline sqlite_uint64 __cdecl sqlite3Hwtime ( void ) { 
line 20076: __asm { 
line 20077: rdtsc 
line 20078: ret ; return value at EDX : EAX 
line 20079: } 
line 20080: } 
line 20082: # endif 
line 20084: # elif ( defined ( __GNUC__ ) && defined ( __x86_64__ ) ) 
line 20086: __inline__ sqlite_uint64 sqlite3Hwtime ( void ) { 
line 20087: unsigned long val ; 
line 20088: __asm__ __volatile__ ( "rdtsc" : "=A" ( val ) ) ; 
line 20089: return val ; 
line 20090: } 
line 20092: # elif ( defined ( __GNUC__ ) && defined ( __ppc__ ) ) 
line 20094: __inline__ sqlite_uint64 sqlite3Hwtime ( void ) { 
line 20095: unsigned long long retval ; 
line 20096: unsigned long junk ; 
line 20097: __asm__ __volatile__ ( 
line 20098: "\n\
 1 : mftbu % 1 \ 
line 20099: n mftb % L0 \ 
line 20100: n mftbu % 0 \ 
line 20101: n cmpw % 0 , % 1 \ 
line 20102: n bne 1b 
line 20103: "
 : "=r" ( retval ) , "=r" ( junk ) ) ; 
line 20104: return retval ; 
line 20105: } 
line 20107: # else 
line 20109: # error Need implementation of sqlite3Hwtime ( ) for your platform . 
line 20118: SQLITE_PRIVATE sqlite_uint64 sqlite3Hwtime ( void ) { return ( ( sqlite_uint64 ) 0 ) ; } 
line 20120: # endif 
line 20122: # endif 
line 20127: static sqlite_uint64 g_start ; 
line 20128: static sqlite_uint64 g_elapsed ; 
line 20129: # define TIMER_START g_start = sqlite3Hwtime ( ) 
line 20130: # define TIMER_END g_elapsed = sqlite3Hwtime ( ) - g_start 
line 20131: # define TIMER_ELAPSED g_elapsed 
line 20132: # else 
line 20133: # define TIMER_START 
line 20134: # define TIMER_END 
line 20135: # define TIMER_ELAPSED ( ( sqlite_uint64 ) 0 ) 
line 20136: # endif 
line 20143: # ifdef SQLITE_TEST 
line 20144: SQLITE_API int sqlite3_io_error_hit = 0 ; 
line 20145: SQLITE_API int sqlite3_io_error_hardhit = 0 ; 
line 20146: SQLITE_API int sqlite3_io_error_pending = 0 ; 
line 20147: SQLITE_API int sqlite3_io_error_persist = 0 ; 
line 20148: SQLITE_API int sqlite3_io_error_benign = 0 ; 
line 20149: SQLITE_API int sqlite3_diskfull_pending = 0 ; 
line 20150: SQLITE_API int sqlite3_diskfull = 0 ; 
line 20151: # define SimulateIOErrorBenign ( X ) sqlite3_io_error_benign = ( X ) 
line 20152: # define SimulateIOError ( CODE ) 
line 20153: if ( ( sqlite3_io_error_persist && sqlite3_io_error_hit ) 
line 20154: || sqlite3_io_error_pending -- == 1 ) 
line 20155: { local_ioerr ( ) ; CODE ; } 
line 20156: static void local_ioerr ( ) { 
line 20157: IOTRACE ( ( "IOERR\n" ) ) ; 
line 20158: sqlite3_io_error_hit ++ ; 
line 20159: if ( ! sqlite3_io_error_benign ) sqlite3_io_error_hardhit ++ ; 
line 20160: } 
line 20161: # define SimulateDiskfullError ( CODE ) 
line 20162: if ( sqlite3_diskfull_pending ) { 
line 20163: if ( sqlite3_diskfull_pending == 1 ) { 
line 20164: local_ioerr ( ) ; 
line 20165: sqlite3_diskfull = 1 ; 
line 20166: sqlite3_io_error_hit = 1 ; 
line 20167: CODE ; 
line 20168: } else { 
line 20169: sqlite3_diskfull_pending -- ; 
line 20170: } 
line 20171: } 
line 20172: # else 
line 20173: # define SimulateIOErrorBenign ( X ) 
line 20174: # define SimulateIOError ( A ) 
line 20175: # define SimulateDiskfullError ( A ) 
line 20176: # endif 
line 20181: # ifdef SQLITE_TEST 
line 20182: SQLITE_API int sqlite3_open_file_count = 0 ; 
line 20183: # define OpenCounter ( X ) sqlite3_open_file_count += ( X ) 
line 20184: # else 
line 20185: # define OpenCounter ( X ) 
line 20186: # endif 
line 20188: # endif 
line 20197: typedef struct os2File os2File ; 
line 20198: struct os2File { 
line 20199: const sqlite3_io_methods * pMethod ; 
line 20200: HFILE h ; 
line 20201: char * pathToDel ; 
line 20202: unsigned char locktype ; 
line 20203: } ; 
line 20205: # define LOCK_TIMEOUT 10L 
line 20215: static int os2Close ( sqlite3_file * id ) { 
line 20216: APIRET rc = NO_ERROR ; 
line 20217: os2File * pFile ; 
line 20218: if ( id && ( pFile = ( os2File * ) id ) != 0 ) { 
line 20219: OSTRACE2 ( "CLOSE %d\n" , pFile -> h ) ; 
line 20220: rc = DosClose ( pFile -> h ) ; 
line 20221: pFile -> locktype = NO_LOCK ; 
line 20222: if ( pFile -> pathToDel != NULL ) { 
line 20223: rc = DosForceDelete ( ( PSZ ) pFile -> pathToDel ) ; 
line 20224: free ( pFile -> pathToDel ) ; 
line 20225: pFile -> pathToDel = NULL ; 
line 20226: } 
line 20227: id = 0 ; 
line 20228: OpenCounter ( - 1 ) ; 
line 20229: } 
line 20231: return rc == NO_ERROR ? SQLITE_OK : SQLITE_IOERR ; 
line 20232: } 
line 20239: static int os2Read ( 
line 20240: sqlite3_file * id , 
line 20241: void * pBuf , 
line 20242: int amt , 
line 20243: sqlite3_int64 offset 
line 20244: ) { 
line 20245: ULONG fileLocation = 0L ; 
line 20246: ULONG got ; 
line 20247: os2File * pFile = ( os2File * ) id ; 
line 20248: assert ( id != 0 ) ; 
line 20249: SimulateIOError ( return SQLITE_IOERR_READ ) ; 
line 20250: OSTRACE3 ( "READ %d lock=%d\n" , pFile -> h , pFile -> locktype ) ; 
line 20251: if ( DosSetFilePtr ( pFile -> h , offset , FILE_BEGIN , & fileLocation ) != NO_ERROR ) { 
line 20252: return SQLITE_IOERR ; 
line 20253: } 
line 20254: if ( DosRead ( pFile -> h , pBuf , amt , & got ) != NO_ERROR ) { 
line 20255: return SQLITE_IOERR_READ ; 
line 20256: } 
line 20257: if ( got == ( ULONG ) amt ) 
line 20258: return SQLITE_OK ; 
line 20259: else { 
line 20261: memset ( & ( ( char * ) pBuf ) [ got ] , 0 , amt - got ) ; 
line 20262: return SQLITE_IOERR_SHORT_READ ; 
line 20263: } 
line 20264: } 
line 20270: static int os2Write ( 
line 20271: sqlite3_file * id , 
line 20272: const void * pBuf , 
line 20273: int amt , 
line 20274: sqlite3_int64 offset 
line 20275: ) { 
line 20276: ULONG fileLocation = 0L ; 
line 20277: APIRET rc = NO_ERROR ; 
line 20278: ULONG wrote ; 
line 20279: os2File * pFile = ( os2File * ) id ; 
line 20280: assert ( id != 0 ) ; 
line 20281: SimulateIOError ( return SQLITE_IOERR_WRITE ) ; 
line 20282: SimulateDiskfullError ( return SQLITE_FULL ) ; 
line 20283: OSTRACE3 ( "WRITE %d lock=%d\n" , pFile -> h , pFile -> locktype ) ; 
line 20284: if ( DosSetFilePtr ( pFile -> h , offset , FILE_BEGIN , & fileLocation ) != NO_ERROR ) { 
line 20285: return SQLITE_IOERR ; 
line 20286: } 
line 20287: assert ( amt > 0 ) ; 
line 20288: while ( amt > 0 && 
line 20289: ( rc = DosWrite ( pFile -> h , ( PVOID ) pBuf , amt , & wrote ) ) == NO_ERROR && 
line 20290: wrote > 0 
line 20291: ) { 
line 20292: amt -= wrote ; 
line 20293: pBuf = & ( ( char * ) pBuf ) [ wrote ] ; 
line 20294: } 
line 20296: return ( rc != NO_ERROR || amt > ( int ) wrote ) ? SQLITE_FULL : SQLITE_OK ; 
line 20297: } 
line 20302: static int os2Truncate ( sqlite3_file * id , i64 nByte ) { 
line 20303: APIRET rc = NO_ERROR ; 
line 20304: os2File * pFile = ( os2File * ) id ; 
line 20305: OSTRACE3 ( "TRUNCATE %d %lld\n" , pFile -> h , nByte ) ; 
line 20306: SimulateIOError ( return SQLITE_IOERR_TRUNCATE ) ; 
line 20307: rc = DosSetFileSize ( pFile -> h , nByte ) ; 
line 20308: return rc == NO_ERROR ? SQLITE_OK : SQLITE_IOERR_TRUNCATE ; 
line 20309: } 
line 20311: # ifdef SQLITE_TEST 
line 20316: SQLITE_API int sqlite3_sync_count = 0 ; 
line 20317: SQLITE_API int sqlite3_fullsync_count = 0 ; 
line 20318: # endif 
line 20323: static int os2Sync ( sqlite3_file * id , int flags ) { 
line 20324: os2File * pFile = ( os2File * ) id ; 
line 20325: OSTRACE3 ( "SYNC %d lock=%d\n" , pFile -> h , pFile -> locktype ) ; 
line 20326: # ifdef SQLITE_TEST 
line 20327: if ( flags & SQLITE_SYNC_FULL ) { 
line 20328: sqlite3_fullsync_count ++ ; 
line 20329: } 
line 20330: sqlite3_sync_count ++ ; 
line 20331: # endif 
line 20335: # ifdef SQLITE_NO_SYNC 
line 20336: UNUSED_PARAMETER ( pFile ) ; 
line 20337: return SQLITE_OK ; 
line 20338: # else 
line 20339: return DosResetBuffer ( pFile -> h ) == NO_ERROR ? SQLITE_OK : SQLITE_IOERR ; 
line 20340: # endif 
line 20341: } 
line 20346: static int os2FileSize ( sqlite3_file * id , sqlite3_int64 * pSize ) { 
line 20347: APIRET rc = NO_ERROR ; 
line 20348: FILESTATUS3 fsts3FileInfo ; 
line 20349: memset ( & fsts3FileInfo , 0 , sizeof ( fsts3FileInfo ) ) ; 
line 20350: assert ( id != 0 ) ; 
line 20351: SimulateIOError ( return SQLITE_IOERR_FSTAT ) ; 
line 20352: rc = DosQueryFileInfo ( ( ( os2File * ) id ) -> h , FIL_STANDARD , & fsts3FileInfo , sizeof ( FILESTATUS3 ) ) ; 
line 20353: if ( rc == NO_ERROR ) { 
line 20354: * pSize = fsts3FileInfo . cbFile ; 
line 20355: return SQLITE_OK ; 
line 20356: } else { 
line 20357: return SQLITE_IOERR_FSTAT ; 
line 20358: } 
line 20359: } 
line 20364: static int getReadLock ( os2File * pFile ) { 
line 20365: FILELOCK LockArea , 
line 20366: UnlockArea ; 
line 20367: APIRET res ; 
line 20368: memset ( & LockArea , 0 , sizeof ( LockArea ) ) ; 
line 20369: memset ( & UnlockArea , 0 , sizeof ( UnlockArea ) ) ; 
line 20370: LockArea . lOffset = SHARED_FIRST ; 
line 20371: LockArea . lRange = SHARED_SIZE ; 
line 20372: UnlockArea . lOffset = 0L ; 
line 20373: UnlockArea . lRange = 0L ; 
line 20374: res = DosSetFileLocks ( pFile -> h , & UnlockArea , & LockArea , LOCK_TIMEOUT , 1L ) ; 
line 20375: OSTRACE3 ( "GETREADLOCK %d res=%d\n" , pFile -> h , res ) ; 
line 20376: return res ; 
line 20377: } 
line 20382: static int unlockReadLock ( os2File * id ) { 
line 20383: FILELOCK LockArea , 
line 20384: UnlockArea ; 
line 20385: APIRET res ; 
line 20386: memset ( & LockArea , 0 , sizeof ( LockArea ) ) ; 
line 20387: memset ( & UnlockArea , 0 , sizeof ( UnlockArea ) ) ; 
line 20388: LockArea . lOffset = 0L ; 
line 20389: LockArea . lRange = 0L ; 
line 20390: UnlockArea . lOffset = SHARED_FIRST ; 
line 20391: UnlockArea . lRange = SHARED_SIZE ; 
line 20392: res = DosSetFileLocks ( id -> h , & UnlockArea , & LockArea , LOCK_TIMEOUT , 1L ) ; 
line 20393: OSTRACE3 ( "UNLOCK-READLOCK file handle=%d res=%d?\n" , id -> h , res ) ; 
line 20394: return res ; 
line 20395: } 
line 20423: static int os2Lock ( sqlite3_file * id , int locktype ) { 
line 20424: int rc = SQLITE_OK ; 
line 20425: APIRET res = NO_ERROR ; 
line 20426: int newLocktype ; 
line 20427: int gotPendingLock = 0 ; 
line 20428: FILELOCK LockArea , 
line 20429: UnlockArea ; 
line 20430: os2File * pFile = ( os2File * ) id ; 
line 20431: memset ( & LockArea , 0 , sizeof ( LockArea ) ) ; 
line 20432: memset ( & UnlockArea , 0 , sizeof ( UnlockArea ) ) ; 
line 20433: assert ( pFile != 0 ) ; 
line 20434: OSTRACE4 ( "LOCK %d %d was %d\n" , pFile -> h , locktype , pFile -> locktype ) ; 
line 20440: if ( pFile -> locktype >= locktype ) { 
line 20441: OSTRACE3 ( "LOCK %d %d ok (already held)\n" , pFile -> h , locktype ) ; 
line 20442: return SQLITE_OK ; 
line 20443: } 
line 20447: assert ( pFile -> locktype != NO_LOCK || locktype == SHARED_LOCK ) ; 
line 20448: assert ( locktype != PENDING_LOCK ) ; 
line 20449: assert ( locktype != RESERVED_LOCK || pFile -> locktype == SHARED_LOCK ) ; 
line 20455: newLocktype = pFile -> locktype ; 
line 20456: if ( pFile -> locktype == NO_LOCK 
line 20457: || ( locktype == EXCLUSIVE_LOCK && pFile -> locktype == RESERVED_LOCK ) 
line 20458: ) { 
line 20459: LockArea . lOffset = PENDING_BYTE ; 
line 20460: LockArea . lRange = 1L ; 
line 20461: UnlockArea . lOffset = 0L ; 
line 20462: UnlockArea . lRange = 0L ; 
line 20465: res = DosSetFileLocks ( pFile -> h , & UnlockArea , & LockArea , 100L , 0L ) ; 
line 20466: if ( res == NO_ERROR ) { 
line 20467: gotPendingLock = 1 ; 
line 20468: OSTRACE3 ( "LOCK %d pending lock boolean set.  res=%d\n" , pFile -> h , res ) ; 
line 20469: } 
line 20470: } 
line 20474: if ( locktype == SHARED_LOCK && res == NO_ERROR ) { 
line 20475: assert ( pFile -> locktype == NO_LOCK ) ; 
line 20476: res = getReadLock ( pFile ) ; 
line 20477: if ( res == NO_ERROR ) { 
line 20478: newLocktype = SHARED_LOCK ; 
line 20479: } 
line 20480: OSTRACE3 ( "LOCK %d acquire shared lock. res=%d\n" , pFile -> h , res ) ; 
line 20481: } 
line 20485: if ( locktype == RESERVED_LOCK && res == NO_ERROR ) { 
line 20486: assert ( pFile -> locktype == SHARED_LOCK ) ; 
line 20487: LockArea . lOffset = RESERVED_BYTE ; 
line 20488: LockArea . lRange = 1L ; 
line 20489: UnlockArea . lOffset = 0L ; 
line 20490: UnlockArea . lRange = 0L ; 
line 20491: res = DosSetFileLocks ( pFile -> h , & UnlockArea , & LockArea , LOCK_TIMEOUT , 0L ) ; 
line 20492: if ( res == NO_ERROR ) { 
line 20493: newLocktype = RESERVED_LOCK ; 
line 20494: } 
line 20495: OSTRACE3 ( "LOCK %d acquire reserved lock. res=%d\n" , pFile -> h , res ) ; 
line 20496: } 
line 20500: if ( locktype == EXCLUSIVE_LOCK && res == NO_ERROR ) { 
line 20501: newLocktype = PENDING_LOCK ; 
line 20502: gotPendingLock = 0 ; 
line 20503: OSTRACE2 ( "LOCK %d acquire pending lock. pending lock boolean unset.\n" , pFile -> h ) ; 
line 20504: } 
line 20508: if ( locktype == EXCLUSIVE_LOCK && res == NO_ERROR ) { 
line 20509: assert ( pFile -> locktype >= SHARED_LOCK ) ; 
line 20510: res = unlockReadLock ( pFile ) ; 
line 20511: OSTRACE2 ( "unreadlock = %d\n" , res ) ; 
line 20512: LockArea . lOffset = SHARED_FIRST ; 
line 20513: LockArea . lRange = SHARED_SIZE ; 
line 20514: UnlockArea . lOffset = 0L ; 
line 20515: UnlockArea . lRange = 0L ; 
line 20516: res = DosSetFileLocks ( pFile -> h , & UnlockArea , & LockArea , LOCK_TIMEOUT , 0L ) ; 
line 20517: if ( res == NO_ERROR ) { 
line 20518: newLocktype = EXCLUSIVE_LOCK ; 
line 20519: } else { 
line 20520: OSTRACE2 ( "OS/2 error-code = %d\n" , res ) ; 
line 20521: getReadLock ( pFile ) ; 
line 20522: } 
line 20523: OSTRACE3 ( "LOCK %d acquire exclusive lock.  res=%d\n" , pFile -> h , res ) ; 
line 20524: } 
line 20529: if ( gotPendingLock && locktype == SHARED_LOCK ) { 
line 20530: int r ; 
line 20531: LockArea . lOffset = 0L ; 
line 20532: LockArea . lRange = 0L ; 
line 20533: UnlockArea . lOffset = PENDING_BYTE ; 
line 20534: UnlockArea . lRange = 1L ; 
line 20535: r = DosSetFileLocks ( pFile -> h , & UnlockArea , & LockArea , LOCK_TIMEOUT , 0L ) ; 
line 20536: OSTRACE3 ( "LOCK %d unlocking pending/is shared. r=%d\n" , pFile -> h , r ) ; 
line 20537: } 
line 20542: if ( res == NO_ERROR ) { 
line 20543: rc = SQLITE_OK ; 
line 20544: } else { 
line 20545: OSTRACE4 ( "LOCK FAILED %d trying for %d but got %d\n" , pFile -> h , 
line 20546: locktype , newLocktype ) ; 
line 20547: rc = SQLITE_BUSY ; 
line 20548: } 
line 20549: pFile -> locktype = newLocktype ; 
line 20550: OSTRACE3 ( "LOCK %d now %d\n" , pFile -> h , pFile -> locktype ) ; 
line 20551: return rc ; 
line 20552: } 
line 20559: static int os2CheckReservedLock ( sqlite3_file * id , int * pOut ) { 
line 20560: int r = 0 ; 
line 20561: os2File * pFile = ( os2File * ) id ; 
line 20562: assert ( pFile != 0 ) ; 
line 20563: if ( pFile -> locktype >= RESERVED_LOCK ) { 
line 20564: r = 1 ; 
line 20565: OSTRACE3 ( "TEST WR-LOCK %d %d (local)\n" , pFile -> h , r ) ; 
line 20566: } else { 
line 20567: FILELOCK LockArea , 
line 20568: UnlockArea ; 
line 20569: APIRET rc = NO_ERROR ; 
line 20570: memset ( & LockArea , 0 , sizeof ( LockArea ) ) ; 
line 20571: memset ( & UnlockArea , 0 , sizeof ( UnlockArea ) ) ; 
line 20572: LockArea . lOffset = RESERVED_BYTE ; 
line 20573: LockArea . lRange = 1L ; 
line 20574: UnlockArea . lOffset = 0L ; 
line 20575: UnlockArea . lRange = 0L ; 
line 20576: rc = DosSetFileLocks ( pFile -> h , & UnlockArea , & LockArea , LOCK_TIMEOUT , 0L ) ; 
line 20577: OSTRACE3 ( "TEST WR-LOCK %d lock reserved byte rc=%d\n" , pFile -> h , rc ) ; 
line 20578: if ( rc == NO_ERROR ) { 
line 20579: APIRET rcu = NO_ERROR ; 
line 20580: LockArea . lOffset = 0L ; 
line 20581: LockArea . lRange = 0L ; 
line 20582: UnlockArea . lOffset = RESERVED_BYTE ; 
line 20583: UnlockArea . lRange = 1L ; 
line 20584: rcu = DosSetFileLocks ( pFile -> h , & UnlockArea , & LockArea , LOCK_TIMEOUT , 0L ) ; 
line 20585: OSTRACE3 ( "TEST WR-LOCK %d unlock reserved byte r=%d\n" , pFile -> h , rcu ) ; 
line 20586: } 
line 20587: r = ! ( rc == NO_ERROR ) ; 
line 20588: OSTRACE3 ( "TEST WR-LOCK %d %d (remote)\n" , pFile -> h , r ) ; 
line 20589: } 
line 20590: * pOut = r ; 
line 20591: return SQLITE_OK ; 
line 20592: } 
line 20605: static int os2Unlock ( sqlite3_file * id , int locktype ) { 
line 20606: int type ; 
line 20607: os2File * pFile = ( os2File * ) id ; 
line 20608: APIRET rc = SQLITE_OK ; 
line 20609: APIRET res = NO_ERROR ; 
line 20610: FILELOCK LockArea , 
line 20611: UnlockArea ; 
line 20612: memset ( & LockArea , 0 , sizeof ( LockArea ) ) ; 
line 20613: memset ( & UnlockArea , 0 , sizeof ( UnlockArea ) ) ; 
line 20614: assert ( pFile != 0 ) ; 
line 20615: assert ( locktype <= SHARED_LOCK ) ; 
line 20616: OSTRACE4 ( "UNLOCK %d to %d was %d\n" , pFile -> h , locktype , pFile -> locktype ) ; 
line 20617: type = pFile -> locktype ; 
line 20618: if ( type >= EXCLUSIVE_LOCK ) { 
line 20619: LockArea . lOffset = 0L ; 
line 20620: LockArea . lRange = 0L ; 
line 20621: UnlockArea . lOffset = SHARED_FIRST ; 
line 20622: UnlockArea . lRange = SHARED_SIZE ; 
line 20623: res = DosSetFileLocks ( pFile -> h , & UnlockArea , & LockArea , LOCK_TIMEOUT , 0L ) ; 
line 20624: OSTRACE3 ( "UNLOCK %d exclusive lock res=%d\n" , pFile -> h , res ) ; 
line 20625: if ( locktype == SHARED_LOCK && getReadLock ( pFile ) != NO_ERROR ) { 
line 20628: OSTRACE3 ( "UNLOCK %d to %d getReadLock() failed\n" , pFile -> h , locktype ) ; 
line 20629: rc = SQLITE_IOERR_UNLOCK ; 
line 20630: } 
line 20631: } 
line 20632: if ( type >= RESERVED_LOCK ) { 
line 20633: LockArea . lOffset = 0L ; 
line 20634: LockArea . lRange = 0L ; 
line 20635: UnlockArea . lOffset = RESERVED_BYTE ; 
line 20636: UnlockArea . lRange = 1L ; 
line 20637: res = DosSetFileLocks ( pFile -> h , & UnlockArea , & LockArea , LOCK_TIMEOUT , 0L ) ; 
line 20638: OSTRACE3 ( "UNLOCK %d reserved res=%d\n" , pFile -> h , res ) ; 
line 20639: } 
line 20640: if ( locktype == NO_LOCK && type >= SHARED_LOCK ) { 
line 20641: res = unlockReadLock ( pFile ) ; 
line 20642: OSTRACE5 ( "UNLOCK %d is %d want %d res=%d\n" , pFile -> h , type , locktype , res ) ; 
line 20643: } 
line 20644: if ( type >= PENDING_LOCK ) { 
line 20645: LockArea . lOffset = 0L ; 
line 20646: LockArea . lRange = 0L ; 
line 20647: UnlockArea . lOffset = PENDING_BYTE ; 
line 20648: UnlockArea . lRange = 1L ; 
line 20649: res = DosSetFileLocks ( pFile -> h , & UnlockArea , & LockArea , LOCK_TIMEOUT , 0L ) ; 
line 20650: OSTRACE3 ( "UNLOCK %d pending res=%d\n" , pFile -> h , res ) ; 
line 20651: } 
line 20652: pFile -> locktype = locktype ; 
line 20653: OSTRACE3 ( "UNLOCK %d now %d\n" , pFile -> h , pFile -> locktype ) ; 
line 20654: return rc ; 
line 20655: } 
line 20660: static int os2FileControl ( sqlite3_file * id , int op , void * pArg ) { 
line 20661: switch ( op ) { 
line 20662: case SQLITE_FCNTL_LOCKSTATE : { 
line 20663: * ( int * ) pArg = ( ( os2File * ) id ) -> locktype ; 
line 20664: OSTRACE3 ( "FCNTL_LOCKSTATE %d lock=%d\n" , ( ( os2File * ) id ) -> h , ( ( os2File * ) id ) -> locktype ) ; 
line 20665: return SQLITE_OK ; 
line 20666: } 
line 20667: } 
line 20668: return SQLITE_ERROR ; 
line 20669: } 
line 20681: static int os2SectorSize ( sqlite3_file * id ) { 
line 20682: return SQLITE_DEFAULT_SECTOR_SIZE ; 
line 20683: } 
line 20688: static int os2DeviceCharacteristics ( sqlite3_file * id ) { 
line 20689: return 0 ; 
line 20690: } 
line 20696: static UconvObject ucUtf8 = NULL ; 
line 20697: static UconvObject uclCp = NULL ; 
line 20702: static void initUconvObjects ( void ) { 
line 20703: if ( UniCreateUconvObject ( UTF_8 , & ucUtf8 ) != ULS_SUCCESS ) 
line 20704: ucUtf8 = NULL ; 
line 20705: if ( UniCreateUconvObject ( ( UniChar * ) L "@path=yes" , & uclCp ) != ULS_SUCCESS ) 
line 20706: uclCp = NULL ; 
line 20707: } 
line 20712: static void freeUconvObjects ( void ) { 
line 20713: if ( ucUtf8 ) 
line 20714: UniFreeUconvObject ( ucUtf8 ) ; 
line 20715: if ( uclCp ) 
line 20716: UniFreeUconvObject ( uclCp ) ; 
line 20717: ucUtf8 = NULL ; 
line 20718: uclCp = NULL ; 
line 20719: } 
line 20727: static char * convertUtf8PathToCp ( const char * in ) { 
line 20728: UniChar tempPath [ CCHMAXPATH ] ; 
line 20729: char * out = ( char * ) calloc ( CCHMAXPATH , 1 ) ; 
line 20731: if ( ! out ) 
line 20732: return NULL ; 
line 20734: if ( ! ucUtf8 || ! uclCp ) 
line 20735: initUconvObjects ( ) ; 
line 20738: if ( UniStrToUcs ( ucUtf8 , tempPath , ( char * ) in , CCHMAXPATH ) != ULS_SUCCESS ) 
line 20739: return out ; 
line 20742: UniStrFromUcs ( uclCp , out , tempPath , CCHMAXPATH ) ; 
line 20744: return out ; 
line 20745: } 
line 20756: char * convertCpPathToUtf8 ( const char * in ) { 
line 20757: UniChar tempPath [ CCHMAXPATH ] ; 
line 20758: char * out = ( char * ) calloc ( CCHMAXPATH , 1 ) ; 
line 20760: if ( ! out ) 
line 20761: return NULL ; 
line 20763: if ( ! ucUtf8 || ! uclCp ) 
line 20764: initUconvObjects ( ) ; 
line 20767: if ( UniStrToUcs ( uclCp , tempPath , ( char * ) in , CCHMAXPATH ) != ULS_SUCCESS ) 
line 20768: return out ; 
line 20771: UniStrFromUcs ( ucUtf8 , out , tempPath , CCHMAXPATH ) ; 
line 20773: return out ; 
line 20774: } 
line 20780: static const sqlite3_io_methods os2IoMethod = { 
line 20781: 1 , 
line 20782: os2Close , 
line 20783: os2Read , 
line 20784: os2Write , 
line 20785: os2Truncate , 
line 20786: os2Sync , 
line 20787: os2FileSize , 
line 20788: os2Lock , 
line 20789: os2Unlock , 
line 20790: os2CheckReservedLock , 
line 20791: os2FileControl , 
line 20792: os2SectorSize , 
line 20793: os2DeviceCharacteristics 
line 20794: } ; 
line 20806: static int getTempname ( int nBuf , char * zBuf ) { 
line 20807: static const unsigned char zChars [ ] = 
line 20808: "abcdefghijklmnopqrstuvwxyz" 
line 20809: "ABCDEFGHIJKLMNOPQRSTUVWXYZ" 
line 20810: "0123456789" ; 
line 20811: int i , j ; 
line 20812: char zTempPathBuf [ 3 ] ; 
line 20813: PSZ zTempPath = ( PSZ ) & zTempPathBuf ; 
line 20814: if ( sqlite3_temp_directory ) { 
line 20815: zTempPath = sqlite3_temp_directory ; 
line 20816: } else { 
line 20817: if ( DosScanEnv ( ( PSZ ) "TEMP" , & zTempPath ) ) { 
line 20818: if ( DosScanEnv ( ( PSZ ) "TMP" , & zTempPath ) ) { 
line 20819: if ( DosScanEnv ( ( PSZ ) "TMPDIR" , & zTempPath ) ) { 
line 20820: ULONG ulDriveNum = 0 , ulDriveMap = 0 ; 
line 20821: DosQueryCurrentDisk ( & ulDriveNum , & ulDriveMap ) ; 
line 20822: sprintf ( ( char * ) zTempPath , "%c:" , ( char ) ( 'A' + ulDriveNum - 1 ) ) ; 
line 20823: } 
line 20824: } 
line 20825: } 
line 20826: } 
line 20830: j = sqlite3Strlen30 ( zTempPath ) ; 
line 20831: while ( j > 0 && ( zTempPath [ j - 1 ] == '\\' || zTempPath[j-1] == ' / 
line 20832: '
 || zTempPath [ j - 1 ] == ' ' ) ) { 
line 20833: j -- ; 
line 20834: } 
line 20835: zTempPath [ j ] = '\0' ; 
line 20836: if ( ! sqlite3_temp_directory ) { 
line 20837: char * zTempPathUTF = convertCpPathToUtf8 ( zTempPath ) ; 
line 20838: sqlite3_snprintf ( nBuf - 30 , zBuf , 
line 20840: "%s\\"SQLITE_TEMP_FILE_PREFIX, zTempPathUTF );
 free ( zTempPathUTF ) ; 
line 20841: } else { 
line 20842: sqlite3_snprintf ( nBuf - 30 , zBuf , 
line 20844: "%s\\"SQLITE_TEMP_FILE_PREFIX, zTempPath );
 } 
line 20845: j = sqlite3Strlen30 ( zBuf ) ; 
line 20846: sqlite3_randomness ( 20 , & zBuf [ j ] ) ; 
line 20847: for ( i = 0 ; i < 20 ; i ++ , j ++ ) { 
line 20848: zBuf [ j ] = ( char ) zChars [ ( ( unsigned char ) zBuf [ j ] ) % ( sizeof ( zChars ) - 1 ) ] ; 
line 20849: } 
line 20850: zBuf [ j ] = 0 ; 
line 20851: OSTRACE2 ( "TEMP FILENAME: %s\n" , zBuf ) ; 
line 20852: return SQLITE_OK ; 
line 20853: } 
line 20861: static int os2FullPathname ( 
line 20862: sqlite3_vfs * pVfs , 
line 20863: const char * zRelative , 
line 20864: int nFull , 
line 20865: char * zFull 
line 20866: ) { 
line 20867: char * zRelativeCp = convertUtf8PathToCp ( zRelative ) ; 
line 20868: char zFullCp [ CCHMAXPATH ] = "\0" ; 
line 20869: char * zFullUTF ; 
line 20870: APIRET rc = DosQueryPathInfo ( zRelativeCp , FIL_QUERYFULLNAME , zFullCp , 
line 20871: CCHMAXPATH ) ; 
line 20872: free ( zRelativeCp ) ; 
line 20873: zFullUTF = convertCpPathToUtf8 ( zFullCp ) ; 
line 20874: sqlite3_snprintf ( nFull , zFull , zFullUTF ) ; 
line 20875: free ( zFullUTF ) ; 
line 20876: return rc == NO_ERROR ? SQLITE_OK : SQLITE_IOERR ; 
line 20877: } 
line 20883: static int os2Open ( 
line 20884: sqlite3_vfs * pVfs , 
line 20885: const char * zName , 
line 20886: sqlite3_file * id , 
line 20887: int flags , 
line 20888: int * pOutFlags 
line 20889: ) { 
line 20890: HFILE h ; 
line 20891: ULONG ulFileAttribute = FILE_NORMAL ; 
line 20892: ULONG ulOpenFlags = 0 ; 
line 20893: ULONG ulOpenMode = 0 ; 
line 20894: os2File * pFile = ( os2File * ) id ; 
line 20895: APIRET rc = NO_ERROR ; 
line 20896: ULONG ulAction ; 
line 20897: char * zNameCp ; 
line 20898: char zTmpname [ CCHMAXPATH + 1 ] ; 
line 20903: if ( ! zName ) { 
line 20904: int rc = getTempname ( CCHMAXPATH + 1 , zTmpname ) ; 
line 20905: if ( rc != SQLITE_OK ) { 
line 20906: return rc ; 
line 20907: } 
line 20908: zName = zTmpname ; 
line 20909: } 
line 20912: memset ( pFile , 0 , sizeof ( * pFile ) ) ; 
line 20914: OSTRACE2 ( "OPEN want %d\n" , flags ) ; 
line 20916: if ( flags & SQLITE_OPEN_READWRITE ) { 
line 20917: ulOpenMode |= OPEN_ACCESS_READWRITE ; 
line 20918: OSTRACE1 ( "OPEN read/write\n" ) ; 
line 20919: } else { 
line 20920: ulOpenMode |= OPEN_ACCESS_READONLY ; 
line 20921: OSTRACE1 ( "OPEN read only\n" ) ; 
line 20922: } 
line 20924: if ( flags & SQLITE_OPEN_CREATE ) { 
line 20925: ulOpenFlags |= OPEN_ACTION_OPEN_IF_EXISTS | OPEN_ACTION_CREATE_IF_NEW ; 
line 20926: OSTRACE1 ( "OPEN open new/create\n" ) ; 
line 20927: } else { 
line 20928: ulOpenFlags |= OPEN_ACTION_OPEN_IF_EXISTS | OPEN_ACTION_FAIL_IF_NEW ; 
line 20929: OSTRACE1 ( "OPEN open existing\n" ) ; 
line 20930: } 
line 20932: if ( flags & SQLITE_OPEN_MAIN_DB ) { 
line 20933: ulOpenMode |= OPEN_SHARE_DENYNONE ; 
line 20934: OSTRACE1 ( "OPEN share read/write\n" ) ; 
line 20935: } else { 
line 20936: ulOpenMode |= OPEN_SHARE_DENYWRITE ; 
line 20937: OSTRACE1 ( "OPEN share read only\n" ) ; 
line 20938: } 
line 20940: if ( flags & SQLITE_OPEN_DELETEONCLOSE ) { 
line 20941: char pathUtf8 [ CCHMAXPATH ] ; 
line 20942: # ifdef NDEBUG 
line 20943: ulFileAttribute = FILE_HIDDEN ; 
line 20944: # endif 
line 20945: os2FullPathname ( pVfs , zName , CCHMAXPATH , pathUtf8 ) ; 
line 20946: pFile -> pathToDel = convertUtf8PathToCp ( pathUtf8 ) ; 
line 20947: OSTRACE1 ( "OPEN hidden/delete on close file attributes\n" ) ; 
line 20948: } else { 
line 20949: pFile -> pathToDel = NULL ; 
line 20950: OSTRACE1 ( "OPEN normal file attribute\n" ) ; 
line 20951: } 
line 20954: ulOpenMode |= OPEN_FLAGS_RANDOM ; 
line 20955: ulOpenMode |= OPEN_FLAGS_FAIL_ON_ERROR ; 
line 20956: ulOpenMode |= OPEN_FLAGS_NOINHERIT ; 
line 20958: zNameCp = convertUtf8PathToCp ( zName ) ; 
line 20959: rc = DosOpen ( ( PSZ ) zNameCp , 
line 20960: & h , 
line 20961: & ulAction , 
line 20962: 0L , 
line 20963: ulFileAttribute , 
line 20964: ulOpenFlags , 
line 20965: ulOpenMode , 
line 20966: ( PEAOP2 ) NULL ) ; 
line 20967: free ( zNameCp ) ; 
line 20968: if ( rc != NO_ERROR ) { 
line 20969: OSTRACE7 ( "OPEN Invalid handle rc=%d: zName=%s, ulAction=%#lx, ulAttr=%#lx, ulFlags=%#lx, ulMode=%#lx\n" , 
line 20970: rc , zName , ulAction , ulFileAttribute , ulOpenFlags , ulOpenMode ) ; 
line 20971: if ( pFile -> pathToDel ) 
line 20972: free ( pFile -> pathToDel ) ; 
line 20973: pFile -> pathToDel = NULL ; 
line 20974: if ( flags & SQLITE_OPEN_READWRITE ) { 
line 20975: OSTRACE2 ( "OPEN %d Invalid handle\n" , ( ( flags | SQLITE_OPEN_READONLY ) & ~ SQLITE_OPEN_READWRITE ) ) ; 
line 20976: return os2Open ( pVfs , zName , id , 
line 20977: ( ( flags | SQLITE_OPEN_READONLY ) & ~ SQLITE_OPEN_READWRITE ) , 
line 20978: pOutFlags ) ; 
line 20979: } else { 
line 20980: return SQLITE_CANTOPEN ; 
line 20981: } 
line 20982: } 
line 20984: if ( pOutFlags ) { 
line 20985: * pOutFlags = flags & SQLITE_OPEN_READWRITE ? SQLITE_OPEN_READWRITE : SQLITE_OPEN_READONLY ; 
line 20986: } 
line 20988: pFile -> pMethod = & os2IoMethod ; 
line 20989: pFile -> h = h ; 
line 20990: OpenCounter ( + 1 ) ; 
line 20991: OSTRACE3 ( "OPEN %d pOutFlags=%d\n" , pFile -> h , pOutFlags ) ; 
line 20992: return SQLITE_OK ; 
line 20993: } 
line 20998: static int os2Delete ( 
line 20999: sqlite3_vfs * pVfs , 
line 21000: const char * zFilename , 
line 21001: int syncDir 
line 21002: ) { 
line 21003: APIRET rc = NO_ERROR ; 
line 21004: char * zFilenameCp = convertUtf8PathToCp ( zFilename ) ; 
line 21005: SimulateIOError ( return SQLITE_IOERR_DELETE ) ; 
line 21006: rc = DosDelete ( ( PSZ ) zFilenameCp ) ; 
line 21007: free ( zFilenameCp ) ; 
line 21008: OSTRACE2 ( "DELETE \"%s\"\n" , zFilename ) ; 
line 21009: return rc == NO_ERROR ? SQLITE_OK : SQLITE_IOERR_DELETE ; 
line 21010: } 
line 21015: static int os2Access ( 
line 21016: sqlite3_vfs * pVfs , 
line 21017: const char * zFilename , 
line 21018: int flags , 
line 21019: int * pOut 
line 21020: ) { 
line 21021: FILESTATUS3 fsts3ConfigInfo ; 
line 21022: APIRET rc = NO_ERROR ; 
line 21023: char * zFilenameCp = convertUtf8PathToCp ( zFilename ) ; 
line 21025: memset ( & fsts3ConfigInfo , 0 , sizeof ( fsts3ConfigInfo ) ) ; 
line 21026: rc = DosQueryPathInfo ( ( PSZ ) zFilenameCp , FIL_STANDARD , 
line 21027: & fsts3ConfigInfo , sizeof ( FILESTATUS3 ) ) ; 
line 21028: free ( zFilenameCp ) ; 
line 21029: OSTRACE4 ( "ACCESS fsts3ConfigInfo.attrFile=%d flags=%d rc=%d\n" , 
line 21030: fsts3ConfigInfo . attrFile , flags , rc ) ; 
line 21031: switch ( flags ) { 
line 21032: case SQLITE_ACCESS_READ : 
line 21033: case SQLITE_ACCESS_EXISTS : 
line 21034: rc = ( rc == NO_ERROR ) ; 
line 21035: OSTRACE3 ( "ACCESS %s access of read and exists  rc=%d\n" , zFilename , rc ) ; 
line 21036: break ; 
line 21037: case SQLITE_ACCESS_READWRITE : 
line 21038: rc = ( rc == NO_ERROR ) && ( ( fsts3ConfigInfo . attrFile & FILE_READONLY ) == 0 ) ; 
line 21039: OSTRACE3 ( "ACCESS %s access of read/write  rc=%d\n" , zFilename , rc ) ; 
line 21040: break ; 
line 21041: default : 
line 21042: assert ( ! "Invalid flags argument" ) ; 
line 21043: } 
line 21044: * pOut = rc ; 
line 21045: return SQLITE_OK ; 
line 21046: } 
line 21049: # ifndef SQLITE_OMIT_LOAD_EXTENSION 
line 21058: static void * os2DlOpen ( sqlite3_vfs * pVfs , const char * zFilename ) { 
line 21059: UCHAR loadErr [ 256 ] ; 
line 21060: HMODULE hmod ; 
line 21061: APIRET rc ; 
line 21062: char * zFilenameCp = convertUtf8PathToCp ( zFilename ) ; 
line 21063: rc = DosLoadModule ( ( PSZ ) loadErr , sizeof ( loadErr ) , zFilenameCp , & hmod ) ; 
line 21064: free ( zFilenameCp ) ; 
line 21065: return rc != NO_ERROR ? 0 : ( void * ) hmod ; 
line 21066: } 
line 21071: static void os2DlError ( sqlite3_vfs * pVfs , int nBuf , char * zBufOut ) { 
line 21073: } 
line 21074: static void * os2DlSym ( sqlite3_vfs * pVfs , void * pHandle , const char * zSymbol ) { 
line 21075: PFN pfn ; 
line 21076: APIRET rc ; 
line 21077: rc = DosQueryProcAddr ( ( HMODULE ) pHandle , 0L , zSymbol , & pfn ) ; 
line 21078: if ( rc != NO_ERROR ) { 
line 21082: char _zSymbol [ 256 ] = "_" ; 
line 21083: strncat ( _zSymbol , zSymbol , 255 ) ; 
line 21084: rc = DosQueryProcAddr ( ( HMODULE ) pHandle , 0L , _zSymbol , & pfn ) ; 
line 21085: } 
line 21086: return rc != NO_ERROR ? 0 : ( void * ) pfn ; 
line 21087: } 
line 21088: static void os2DlClose ( sqlite3_vfs * pVfs , void * pHandle ) { 
line 21089: DosFreeModule ( ( HMODULE ) pHandle ) ; 
line 21090: } 
line 21091: # else 
line 21092: # define os2DlOpen 0 
line 21093: # define os2DlError 0 
line 21094: # define os2DlSym 0 
line 21095: # define os2DlClose 0 
line 21096: # endif 
line 21102: static int os2Randomness ( sqlite3_vfs * pVfs , int nBuf , char * zBuf ) { 
line 21103: int n = 0 ; 
line 21104: # if defined ( SQLITE_TEST ) 
line 21105: n = nBuf ; 
line 21106: memset ( zBuf , 0 , nBuf ) ; 
line 21107: # else 
line 21108: int sizeofULong = sizeof ( ULONG ) ; 
line 21109: if ( ( int ) sizeof ( DATETIME ) <= nBuf - n ) { 
line 21110: DATETIME x ; 
line 21111: DosGetDateTime ( & x ) ; 
line 21112: memcpy ( & zBuf [ n ] , & x , sizeof ( x ) ) ; 
line 21113: n += sizeof ( x ) ; 
line 21114: } 
line 21116: if ( sizeofULong <= nBuf - n ) { 
line 21117: PPIB ppib ; 
line 21118: DosGetInfoBlocks ( NULL , & ppib ) ; 
line 21119: memcpy ( & zBuf [ n ] , & ppib -> pib_ulpid , sizeofULong ) ; 
line 21120: n += sizeofULong ; 
line 21121: } 
line 21123: if ( sizeofULong <= nBuf - n ) { 
line 21124: PTIB ptib ; 
line 21125: DosGetInfoBlocks ( & ptib , NULL ) ; 
line 21126: memcpy ( & zBuf [ n ] , & ptib -> tib_ptib2 -> tib2_ultid , sizeofULong ) ; 
line 21127: n += sizeofULong ; 
line 21128: } 
line 21132: if ( sizeofULong <= nBuf - n ) { 
line 21133: ULONG ulSysInfo [ QSV_MAX ] ; 
line 21134: DosQuerySysInfo ( 1L , QSV_MAX , ulSysInfo , sizeofULong * QSV_MAX ) ; 
line 21136: memcpy ( & zBuf [ n ] , & ulSysInfo [ QSV_MS_COUNT - 1 ] , sizeofULong ) ; 
line 21137: n += sizeofULong ; 
line 21139: if ( sizeofULong <= nBuf - n ) { 
line 21140: memcpy ( & zBuf [ n ] , & ulSysInfo [ QSV_TIMER_INTERVAL - 1 ] , sizeofULong ) ; 
line 21141: n += sizeofULong ; 
line 21142: } 
line 21143: if ( sizeofULong <= nBuf - n ) { 
line 21144: memcpy ( & zBuf [ n ] , & ulSysInfo [ QSV_TIME_LOW - 1 ] , sizeofULong ) ; 
line 21145: n += sizeofULong ; 
line 21146: } 
line 21147: if ( sizeofULong <= nBuf - n ) { 
line 21148: memcpy ( & zBuf [ n ] , & ulSysInfo [ QSV_TIME_HIGH - 1 ] , sizeofULong ) ; 
line 21149: n += sizeofULong ; 
line 21150: } 
line 21151: if ( sizeofULong <= nBuf - n ) { 
line 21152: memcpy ( & zBuf [ n ] , & ulSysInfo [ QSV_TOTAVAILMEM - 1 ] , sizeofULong ) ; 
line 21153: n += sizeofULong ; 
line 21154: } 
line 21155: } 
line 21156: # endif 
line 21158: return n ; 
line 21159: } 
line 21169: static int os2Sleep ( sqlite3_vfs * pVfs , int microsec ) { 
line 21170: DosSleep ( ( microsec / 1000 ) ) ; 
line 21171: return microsec ; 
line 21172: } 
line 21178: # ifdef SQLITE_TEST 
line 21179: SQLITE_API int sqlite3_current_time = 0 ; 
line 21180: # endif 
line 21187: int os2CurrentTime ( sqlite3_vfs * pVfs , double * prNow ) { 
line 21188: double now ; 
line 21189: SHORT minute ; 
line 21190: USHORT second , hour , 
line 21191: day , month , year ; 
line 21192: DATETIME dt ; 
line 21193: DosGetDateTime ( & dt ) ; 
line 21194: second = ( USHORT ) dt . seconds ; 
line 21195: minute = ( SHORT ) dt . minutes + dt . timezone ; 
line 21196: hour = ( USHORT ) dt . hours ; 
line 21197: day = ( USHORT ) dt . day ; 
line 21198: month = ( USHORT ) dt . month ; 
line 21199: year = ( USHORT ) dt . year ; 
line 21204: now = day - 32076 + 
line 21205: 1461 * ( year + 4800 + ( month - 14 ) / 12 ) / 4 + 
line 21206: 367 * ( month - 2 - ( month - 14 ) / 12 * 12 ) / 12 - 
line 21207: 3 * ( ( year + 4900 + ( month - 14 ) / 12 ) / 100 ) / 4 ; 
line 21210: now += ( hour + 12.0 ) / 24.0 ; 
line 21211: now += minute / 1440.0 ; 
line 21212: now += second / 86400.0 ; 
line 21213: * prNow = now ; 
line 21214: # ifdef SQLITE_TEST 
line 21215: if ( sqlite3_current_time ) { 
line 21216: * prNow = sqlite3_current_time / 86400.0 + 2440587.5 ; 
line 21217: } 
line 21218: # endif 
line 21219: return 0 ; 
line 21220: } 
line 21222: static int os2GetLastError ( sqlite3_vfs * pVfs , int nBuf , char * zBuf ) { 
line 21223: return 0 ; 
line 21224: } 
line 21229: SQLITE_API int sqlite3_os_init ( void ) { 
line 21230: static sqlite3_vfs os2Vfs = { 
line 21231: 1 , 
line 21232: sizeof ( os2File ) , 
line 21233: CCHMAXPATH , 
line 21234: 0 , 
line 21235: "os2" , 
line 21236: 0 , 
line 21238: os2Open , 
line 21239: os2Delete , 
line 21240: os2Access , 
line 21241: os2FullPathname , 
line 21242: os2DlOpen , 
line 21243: os2DlError , 
line 21244: os2DlSym , 
line 21245: os2DlClose , 
line 21246: os2Randomness , 
line 21247: os2Sleep , 
line 21248: os2CurrentTime , 
line 21249: os2GetLastError 
line 21250: } ; 
line 21251: sqlite3_vfs_register ( & os2Vfs , 1 ) ; 
line 21252: initUconvObjects ( ) ; 
line 21253: return SQLITE_OK ; 
line 21254: } 
line 21255: SQLITE_API int sqlite3_os_end ( void ) { 
line 21256: freeUconvObjects ( ) ; 
line 21257: return SQLITE_OK ; 
line 21258: } 
line 21260: # endif 
line 21309: # if SQLITE_OS_UNIX 
line 21328: # if ! defined ( SQLITE_ENABLE_LOCKING_STYLE ) 
line 21329: # if defined ( __APPLE__ ) 
line 21330: # define SQLITE_ENABLE_LOCKING_STYLE 1 
line 21331: # else 
line 21332: # define SQLITE_ENABLE_LOCKING_STYLE 0 
line 21333: # endif 
line 21334: # endif 
line 21340: # ifndef OS_VXWORKS 
line 21341: # if defined ( __RTP__ ) || defined ( _WRS_KERNEL ) 
line 21342: # define OS_VXWORKS 1 
line 21343: # else 
line 21344: # define OS_VXWORKS 0 
line 21345: # endif 
line 21346: # endif 
line 21366: # ifndef SQLITE_DISABLE_LFS 
line 21367: # define _LARGE_FILE 1 
line 21368: # ifndef _FILE_OFFSET_BITS 
line 21369: # define _FILE_OFFSET_BITS 64 
line 21370: # endif 
line 21371: # define _LARGEFILE_SOURCE 1 
line 21372: # endif 
line 21377: # include < sys / types . h > 
line 21378: # include < sys / stat . h > 
line 21379: # include < fcntl . h > 
line 21380: # include < unistd . h > 
line 21381: # include < sys / time . h > 
line 21382: # include < errno . h > 
line 21384: # if SQLITE_ENABLE_LOCKING_STYLE 
line 21385: # include < sys / ioctl . h > 
line 21386: # if OS_VXWORKS 
line 21387: # include < semaphore . h > 
line 21388: # include < limits . h > 
line 21389: # else 
line 21390: # include < sys / file . h > 
line 21391: # include < sys / param . h > 
line 21392: # include < sys / mount . h > 
line 21393: # endif 
line 21394: # endif 
line 21400: # if SQLITE_THREADSAFE 
line 21401: # define SQLITE_UNIX_THREADS 1 
line 21402: # endif 
line 21407: # ifndef SQLITE_DEFAULT_FILE_PERMISSIONS 
line 21408: # define SQLITE_DEFAULT_FILE_PERMISSIONS 0644 
line 21409: # endif 
line 21414: # ifndef SQLITE_DEFAULT_PROXYDIR_PERMISSIONS 
line 21415: # define SQLITE_DEFAULT_PROXYDIR_PERMISSIONS 0755 
line 21416: # endif 
line 21421: # define MAX_PATHNAME 512 
line 21427: # define IS_LOCK_ERROR ( x ) ( ( x != SQLITE_OK ) && ( x != SQLITE_BUSY ) ) 
line 21436: typedef struct UnixUnusedFd UnixUnusedFd ; 
line 21437: struct UnixUnusedFd { 
line 21438: int fd ; 
line 21439: int flags ; 
line 21440: UnixUnusedFd * pNext ; 
line 21441: } ; 
line 21447: typedef struct unixFile unixFile ; 
line 21448: struct unixFile { 
line 21449: sqlite3_io_methods const * pMethod ; 
line 21450: struct unixOpenCnt * pOpen ; 
line 21451: struct unixLockInfo * pLock ; 
line 21452: int h ; 
line 21453: int dirfd ; 
line 21454: unsigned char locktype ; 
line 21455: int lastErrno ; 
line 21456: void * lockingContext ; 
line 21457: UnixUnusedFd * pUnused ; 
line 21458: int fileFlags ; 
line 21459: # if SQLITE_ENABLE_LOCKING_STYLE 
line 21460: int openFlags ; 
line 21461: # endif 
line 21462: # if SQLITE_THREADSAFE && defined ( __linux__ ) 
line 21463: pthread_t tid ; 
line 21464: # endif 
line 21465: # if OS_VXWORKS 
line 21466: int isDelete ; 
line 21467: struct vxworksFileId * pId ; 
line 21468: # endif 
line 21469: # ifndef NDEBUG 
line 21477: unsigned char transCntrChng ; 
line 21478: unsigned char dbUpdate ; 
line 21479: unsigned char inNormalWrite ; 
line 21480: # endif 
line 21481: # ifdef SQLITE_TEST 
line 21485: char aPadding [ 32 ] ; 
line 21486: # endif 
line 21487: } ; 
line 21492: # define SQLITE_WHOLE_FILE_LOCKING 0x0001 
line 21518: # ifndef _OS_COMMON_H_ 
line 21519: # define _OS_COMMON_H_ 
line 21526: # ifdef MEMORY_DEBUG 
line 21527: # error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead." 
line 21528: # endif 
line 21530: # ifdef SQLITE_DEBUG 
line 21531: SQLITE_PRIVATE int sqlite3OSTrace = 0 ; 
line 21532: # define OSTRACE1 ( X ) if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X ) 
line 21533: # define OSTRACE2 ( X , Y ) if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y ) 
line 21534: # define OSTRACE3 ( X , Y , Z ) if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y , Z ) 
line 21535: # define OSTRACE4 ( X , Y , Z , A ) if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y , Z , A ) 
line 21536: # define OSTRACE5 ( X , Y , Z , A , B ) if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y , Z , A , B ) 
line 21537: # define OSTRACE6 ( X , Y , Z , A , B , C ) 
line 21538: if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y , Z , A , B , C ) 
line 21539: # define OSTRACE7 ( X , Y , Z , A , B , C , D ) 
line 21540: if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y , Z , A , B , C , D ) 
line 21541: # else 
line 21542: # define OSTRACE1 ( X ) 
line 21543: # define OSTRACE2 ( X , Y ) 
line 21544: # define OSTRACE3 ( X , Y , Z ) 
line 21545: # define OSTRACE4 ( X , Y , Z , A ) 
line 21546: # define OSTRACE5 ( X , Y , Z , A , B ) 
line 21547: # define OSTRACE6 ( X , Y , Z , A , B , C ) 
line 21548: # define OSTRACE7 ( X , Y , Z , A , B , C , D ) 
line 21549: # endif 
line 21555: # ifdef SQLITE_PERFORMANCE_TRACE 
line 21578: # ifndef _HWTIME_H_ 
line 21579: # define _HWTIME_H_ 
line 21587: # if ( defined ( __GNUC__ ) || defined ( _MSC_VER ) ) && 
line 21588: ( defined ( i386 ) || defined ( __i386__ ) || defined ( _M_IX86 ) ) 
line 21590: # if defined ( __GNUC__ ) 
line 21592: __inline__ sqlite_uint64 sqlite3Hwtime ( void ) { 
line 21593: unsigned int lo , hi ; 
line 21594: __asm__ __volatile__ ( "rdtsc" : "=a" ( lo ) , "=d" ( hi ) ) ; 
line 21595: return ( sqlite_uint64 ) hi << 32 | lo ; 
line 21596: } 
line 21598: # elif defined ( _MSC_VER ) 
line 21600: __declspec ( naked ) __inline sqlite_uint64 __cdecl sqlite3Hwtime ( void ) { 
line 21601: __asm { 
line 21602: rdtsc 
line 21603: ret ; return value at EDX : EAX 
line 21604: } 
line 21605: } 
line 21607: # endif 
line 21609: # elif ( defined ( __GNUC__ ) && defined ( __x86_64__ ) ) 
line 21611: __inline__ sqlite_uint64 sqlite3Hwtime ( void ) { 
line 21612: unsigned long val ; 
line 21613: __asm__ __volatile__ ( "rdtsc" : "=A" ( val ) ) ; 
line 21614: return val ; 
line 21615: } 
line 21617: # elif ( defined ( __GNUC__ ) && defined ( __ppc__ ) ) 
line 21619: __inline__ sqlite_uint64 sqlite3Hwtime ( void ) { 
line 21620: unsigned long long retval ; 
line 21621: unsigned long junk ; 
line 21622: __asm__ __volatile__ ( 
line 21623: "\n\
 1 : mftbu % 1 \ 
line 21624: n mftb % L0 \ 
line 21625: n mftbu % 0 \ 
line 21626: n cmpw % 0 , % 1 \ 
line 21627: n bne 1b 
line 21628: "
 : "=r" ( retval ) , "=r" ( junk ) ) ; 
line 21629: return retval ; 
line 21630: } 
line 21632: # else 
line 21634: # error Need implementation of sqlite3Hwtime ( ) for your platform . 
line 21643: SQLITE_PRIVATE sqlite_uint64 sqlite3Hwtime ( void ) { return ( ( sqlite_uint64 ) 0 ) ; } 
line 21645: # endif 
line 21647: # endif 
line 21652: static sqlite_uint64 g_start ; 
line 21653: static sqlite_uint64 g_elapsed ; 
line 21654: # define TIMER_START g_start = sqlite3Hwtime ( ) 
line 21655: # define TIMER_END g_elapsed = sqlite3Hwtime ( ) - g_start 
line 21656: # define TIMER_ELAPSED g_elapsed 
line 21657: # else 
line 21658: # define TIMER_START 
line 21659: # define TIMER_END 
line 21660: # define TIMER_ELAPSED ( ( sqlite_uint64 ) 0 ) 
line 21661: # endif 
line 21668: # ifdef SQLITE_TEST 
line 21669: SQLITE_API int sqlite3_io_error_hit = 0 ; 
line 21670: SQLITE_API int sqlite3_io_error_hardhit = 0 ; 
line 21671: SQLITE_API int sqlite3_io_error_pending = 0 ; 
line 21672: SQLITE_API int sqlite3_io_error_persist = 0 ; 
line 21673: SQLITE_API int sqlite3_io_error_benign = 0 ; 
line 21674: SQLITE_API int sqlite3_diskfull_pending = 0 ; 
line 21675: SQLITE_API int sqlite3_diskfull = 0 ; 
line 21676: # define SimulateIOErrorBenign ( X ) sqlite3_io_error_benign = ( X ) 
line 21677: # define SimulateIOError ( CODE ) 
line 21678: if ( ( sqlite3_io_error_persist && sqlite3_io_error_hit ) 
line 21679: || sqlite3_io_error_pending -- == 1 ) 
line 21680: { local_ioerr ( ) ; CODE ; } 
line 21681: static void local_ioerr ( ) { 
line 21682: IOTRACE ( ( "IOERR\n" ) ) ; 
line 21683: sqlite3_io_error_hit ++ ; 
line 21684: if ( ! sqlite3_io_error_benign ) sqlite3_io_error_hardhit ++ ; 
line 21685: } 
line 21686: # define SimulateDiskfullError ( CODE ) 
line 21687: if ( sqlite3_diskfull_pending ) { 
line 21688: if ( sqlite3_diskfull_pending == 1 ) { 
line 21689: local_ioerr ( ) ; 
line 21690: sqlite3_diskfull = 1 ; 
line 21691: sqlite3_io_error_hit = 1 ; 
line 21692: CODE ; 
line 21693: } else { 
line 21694: sqlite3_diskfull_pending -- ; 
line 21695: } 
line 21696: } 
line 21697: # else 
line 21698: # define SimulateIOErrorBenign ( X ) 
line 21699: # define SimulateIOError ( A ) 
line 21700: # define SimulateDiskfullError ( A ) 
line 21701: # endif 
line 21706: # ifdef SQLITE_TEST 
line 21707: SQLITE_API int sqlite3_open_file_count = 0 ; 
line 21708: # define OpenCounter ( X ) sqlite3_open_file_count += ( X ) 
line 21709: # else 
line 21710: # define OpenCounter ( X ) 
line 21711: # endif 
line 21713: # endif 
line 21721: # ifndef O_LARGEFILE 
line 21722: # define O_LARGEFILE 0 
line 21723: # endif 
line 21724: # ifdef SQLITE_DISABLE_LFS 
line 21725: # undef O_LARGEFILE 
line 21726: # define O_LARGEFILE 0 
line 21727: # endif 
line 21728: # ifndef O_NOFOLLOW 
line 21729: # define O_NOFOLLOW 0 
line 21730: # endif 
line 21731: # ifndef O_BINARY 
line 21732: # define O_BINARY 0 
line 21733: # endif 
line 21741: # ifdef __DJGPP__ 
line 21742: # define fcntl ( A , B , C ) 0 
line 21743: # endif 
line 21749: # if SQLITE_THREADSAFE 
line 21750: # define threadid pthread_self ( ) 
line 21751: # else 
line 21752: # define threadid 0 
line 21753: # endif 
line 21770: static void unixEnterMutex ( void ) { 
line 21771: sqlite3_mutex_enter ( sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ) ; 
line 21772: } 
line 21773: static void unixLeaveMutex ( void ) { 
line 21774: sqlite3_mutex_leave ( sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ) ; 
line 21775: } 
line 21776: # ifdef SQLITE_DEBUG 
line 21777: static int unixMutexHeld ( void ) { 
line 21778: return sqlite3_mutex_held ( sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ) ; 
line 21779: } 
line 21780: # endif 
line 21783: # ifdef SQLITE_DEBUG 
line 21789: static const char * locktypeName ( int locktype ) { 
line 21790: switch ( locktype ) { 
line 21791: case NO_LOCK : return "NONE" ; 
line 21792: case SHARED_LOCK : return "SHARED" ; 
line 21793: case RESERVED_LOCK : return "RESERVED" ; 
line 21794: case PENDING_LOCK : return "PENDING" ; 
line 21795: case EXCLUSIVE_LOCK : return "EXCLUSIVE" ; 
line 21796: } 
line 21797: return "ERROR" ; 
line 21798: } 
line 21799: # endif 
line 21801: # ifdef SQLITE_LOCK_TRACE 
line 21810: static int lockTrace ( int fd , int op , struct flock * p ) { 
line 21811: char * zOpName , * zType ; 
line 21812: int s ; 
line 21813: int savedErrno ; 
line 21814: if ( op == F_GETLK ) { 
line 21815: zOpName = "GETLK" ; 
line 21816: } else if ( op == F_SETLK ) { 
line 21817: zOpName = "SETLK" ; 
line 21818: } else { 
line 21819: s = fcntl ( fd , op , p ) ; 
line 21820: sqlite3DebugPrintf ( "fcntl unknown %d %d %d\n" , fd , op , s ) ; 
line 21821: return s ; 
line 21822: } 
line 21823: if ( p -> l_type == F_RDLCK ) { 
line 21824: zType = "RDLCK" ; 
line 21825: } else if ( p -> l_type == F_WRLCK ) { 
line 21826: zType = "WRLCK" ; 
line 21827: } else if ( p -> l_type == F_UNLCK ) { 
line 21828: zType = "UNLCK" ; 
line 21829: } else { 
line 21830: assert ( 0 ) ; 
line 21831: } 
line 21832: assert ( p -> l_whence == SEEK_SET ) ; 
line 21833: s = fcntl ( fd , op , p ) ; 
line 21834: savedErrno = errno ; 
line 21835: sqlite3DebugPrintf ( "fcntl %d %d %s %s %d %d %d %d\n" , 
line 21836: threadid , fd , zOpName , zType , ( int ) p -> l_start , ( int ) p -> l_len , 
line 21837: ( int ) p -> l_pid , s ) ; 
line 21838: if ( s == ( - 1 ) && op == F_SETLK && ( p -> l_type == F_RDLCK || p -> l_type == F_WRLCK ) ) { 
line 21839: struct flock l2 ; 
line 21840: l2 = * p ; 
line 21841: fcntl ( fd , F_GETLK , & l2 ) ; 
line 21842: if ( l2 . l_type == F_RDLCK ) { 
line 21843: zType = "RDLCK" ; 
line 21844: } else if ( l2 . l_type == F_WRLCK ) { 
line 21845: zType = "WRLCK" ; 
line 21846: } else if ( l2 . l_type == F_UNLCK ) { 
line 21847: zType = "UNLCK" ; 
line 21848: } else { 
line 21849: assert ( 0 ) ; 
line 21850: } 
line 21851: sqlite3DebugPrintf ( "fcntl-failure-reason: %s %d %d %d\n" , 
line 21852: zType , ( int ) l2 . l_start , ( int ) l2 . l_len , ( int ) l2 . l_pid ) ; 
line 21853: } 
line 21854: errno = savedErrno ; 
line 21855: return s ; 
line 21856: } 
line 21857: # define fcntl lockTrace 
line 21858: # endif 
line 21872: static int sqliteErrorFromPosixError ( int posixError , int sqliteIOErr ) { 
line 21873: switch ( posixError ) { 
line 21874: case 0 : 
line 21875: return SQLITE_OK ; 
line 21877: case EAGAIN : 
line 21878: case ETIMEDOUT : 
line 21879: case EBUSY : 
line 21880: case EINTR : 
line 21881: case ENOLCK : 
line 21884: return SQLITE_BUSY ; 
line 21886: case EACCES : 
line 21888: if ( ( sqliteIOErr == SQLITE_IOERR_LOCK ) || 
line 21889: ( sqliteIOErr == SQLITE_IOERR_UNLOCK ) || 
line 21890: ( sqliteIOErr == SQLITE_IOERR_RDLOCK ) || 
line 21891: ( sqliteIOErr == SQLITE_IOERR_CHECKRESERVEDLOCK ) ) { 
line 21892: return SQLITE_BUSY ; 
line 21893: } 
line 21895: case EPERM : 
line 21896: return SQLITE_PERM ; 
line 21898: case EDEADLK : 
line 21899: return SQLITE_IOERR_BLOCKED ; 
line 21901: # if EOPNOTSUPP != ENOTSUP 
line 21902: case EOPNOTSUPP : 
line 21905: # endif 
line 21906: # ifdef ENOTSUP 
line 21907: case ENOTSUP : 
line 21910: # endif 
line 21911: case EIO : 
line 21912: case EBADF : 
line 21913: case EINVAL : 
line 21914: case ENOTCONN : 
line 21915: case ENODEV : 
line 21916: case ENXIO : 
line 21917: case ENOENT : 
line 21918: case ESTALE : 
line 21919: case ENOSYS : 
line 21922: default : 
line 21923: return sqliteIOErr ; 
line 21924: } 
line 21925: } 
line 21946: struct vxworksFileId { 
line 21947: struct vxworksFileId * pNext ; 
line 21948: int nRef ; 
line 21949: int nName ; 
line 21950: char * zCanonicalName ; 
line 21951: } ; 
line 21953: # if OS_VXWORKS 
line 21958: static struct vxworksFileId * vxworksFileList = 0 ; 
line 21973: static int vxworksSimplifyName ( char * z , int n ) { 
line 21974: int i , j ; 
line 21975: while ( n > 1 && z [ n - 1 ] == '/' ) { n -- ; } 
line 21976: for ( i = j = 0 ; i < n ; i ++ ) { 
line 21977: if ( z [ i ] == '/' ) { 
line 21978: if ( z [ i + 1 ] == '/' ) continue ; 
line 21979: if ( z [ i + 1 ] == '.' && i + 2 < n && z [ i + 2 ] == '/' ) { 
line 21980: i += 1 ; 
line 21981: continue ; 
line 21982: } 
line 21983: if ( z [ i + 1 ] == '.' && i + 3 < n && z [ i + 2 ] == '.' && z [ i + 3 ] == '/' ) { 
line 21984: while ( j > 0 && z [ j - 1 ] != '/' ) { j -- ; } 
line 21985: if ( j > 0 ) { j -- ; } 
line 21986: i += 2 ; 
line 21987: continue ; 
line 21988: } 
line 21989: } 
line 21990: z [ j ++ ] = z [ i ] ; 
line 21991: } 
line 21992: z [ j ] = 0 ; 
line 21993: return j ; 
line 21994: } 
line 22007: static struct vxworksFileId * vxworksFindFileId ( const char * zAbsoluteName ) { 
line 22008: struct vxworksFileId * pNew ; 
line 22009: struct vxworksFileId * pCandidate ; 
line 22010: int n ; 
line 22012: assert ( zAbsoluteName [ 0 ] == '/' ) ; 
line 22013: n = ( int ) strlen ( zAbsoluteName ) ; 
line 22014: pNew = sqlite3_malloc ( sizeof ( * pNew ) + ( n + 1 ) ) ; 
line 22015: if ( pNew == 0 ) return 0 ; 
line 22016: pNew -> zCanonicalName = ( char * ) & pNew [ 1 ] ; 
line 22017: memcpy ( pNew -> zCanonicalName , zAbsoluteName , n + 1 ) ; 
line 22018: n = vxworksSimplifyName ( pNew -> zCanonicalName , n ) ; 
line 22024: unixEnterMutex ( ) ; 
line 22025: for ( pCandidate = vxworksFileList ; pCandidate ; pCandidate = pCandidate -> pNext ) { 
line 22026: if ( pCandidate -> nName == n 
line 22027: && memcmp ( pCandidate -> zCanonicalName , pNew -> zCanonicalName , n ) == 0 
line 22028: ) { 
line 22029: sqlite3_free ( pNew ) ; 
line 22030: pCandidate -> nRef ++ ; 
line 22031: unixLeaveMutex ( ) ; 
line 22032: return pCandidate ; 
line 22033: } 
line 22034: } 
line 22037: pNew -> nRef = 1 ; 
line 22038: pNew -> nName = n ; 
line 22039: pNew -> pNext = vxworksFileList ; 
line 22040: vxworksFileList = pNew ; 
line 22041: unixLeaveMutex ( ) ; 
line 22042: return pNew ; 
line 22043: } 
line 22049: static void vxworksReleaseFileId ( struct vxworksFileId * pId ) { 
line 22050: unixEnterMutex ( ) ; 
line 22051: assert ( pId -> nRef > 0 ) ; 
line 22052: pId -> nRef -- ; 
line 22053: if ( pId -> nRef == 0 ) { 
line 22054: struct vxworksFileId * * pp ; 
line 22055: for ( pp = & vxworksFileList ; * pp && * pp != pId ; pp = & ( ( * pp ) -> pNext ) ) { } 
line 22056: assert ( * pp == pId ) ; 
line 22057: * pp = pId -> pNext ; 
line 22058: sqlite3_free ( pId ) ; 
line 22059: } 
line 22060: unixLeaveMutex ( ) ; 
line 22061: } 
line 22062: # endif 
line 22175: # if SQLITE_THREADSAFE && defined ( __linux__ ) 
line 22176: # define SET_THREADID ( X ) ( X ) -> tid = pthread_self ( ) 
line 22177: # define CHECK_THREADID ( X ) ( threadsOverrideEachOthersLocks == 0 && 
line 22178: ! pthread_equal ( ( X ) -> tid , pthread_self ( ) ) ) 
line 22179: # else 
line 22180: # define SET_THREADID ( X ) 
line 22181: # define CHECK_THREADID ( X ) 0 
line 22182: # endif 
line 22189: struct unixFileId { 
line 22190: dev_t dev ; 
line 22191: # if OS_VXWORKS 
line 22192: struct vxworksFileId * pId ; 
line 22193: # else 
line 22194: ino_t ino ; 
line 22195: # endif 
line 22196: } ; 
line 22208: struct unixLockKey { 
line 22209: struct unixFileId fid ; 
line 22210: # if SQLITE_THREADSAFE && defined ( __linux__ ) 
line 22211: pthread_t tid ; 
line 22212: # endif 
line 22213: } ; 
line 22224: struct unixLockInfo { 
line 22225: struct unixLockKey lockKey ; 
line 22226: int cnt ; 
line 22227: int locktype ; 
line 22228: int nRef ; 
line 22229: struct unixLockInfo * pNext ; 
line 22230: struct unixLockInfo * pPrev ; 
line 22231: } ; 
line 22245: struct unixOpenCnt { 
line 22246: struct unixFileId fileId ; 
line 22247: int nRef ; 
line 22248: int nLock ; 
line 22249: UnixUnusedFd * pUnused ; 
line 22250: # if OS_VXWORKS 
line 22251: sem_t * pSem ; 
line 22252: char aSemName [ MAX_PATHNAME + 2 ] ; 
line 22253: # endif 
line 22254: struct unixOpenCnt * pNext , * pPrev ; 
line 22255: } ; 
line 22263: static struct unixLockInfo * lockList = 0 ; 
line 22264: static struct unixOpenCnt * openList = 0 ; 
line 22284: # if SQLITE_THREADSAFE && defined ( __linux__ ) 
line 22285: # ifndef SQLITE_THREAD_OVERRIDE_LOCK 
line 22286: # define SQLITE_THREAD_OVERRIDE_LOCK - 1 
line 22287: # endif 
line 22288: # ifdef SQLITE_TEST 
line 22289: int threadsOverrideEachOthersLocks = SQLITE_THREAD_OVERRIDE_LOCK ; 
line 22290: # else 
line 22291: static int threadsOverrideEachOthersLocks = SQLITE_THREAD_OVERRIDE_LOCK ; 
line 22292: # endif 
line 22293: # endif 
line 22299: struct threadTestData { 
line 22300: int fd ; 
line 22301: struct flock lock ; 
line 22302: int result ; 
line 22303: } ; 
line 22305: # if SQLITE_THREADSAFE && defined ( __linux__ ) 
line 22315: static void * threadLockingTest ( void * pArg ) { 
line 22316: struct threadTestData * pData = ( struct threadTestData * ) pArg ; 
line 22317: pData -> result = fcntl ( pData -> fd , F_GETLK , & pData -> lock ) ; 
line 22318: return pArg ; 
line 22319: } 
line 22320: # endif 
line 22323: # if SQLITE_THREADSAFE && defined ( __linux__ ) 
line 22329: static void testThreadLockingBehavior ( int fd_orig ) { 
line 22330: int fd ; 
line 22331: int rc ; 
line 22332: struct threadTestData d ; 
line 22333: struct flock l ; 
line 22334: pthread_t t ; 
line 22336: fd = dup ( fd_orig ) ; 
line 22337: if ( fd < 0 ) return ; 
line 22338: memset ( & l , 0 , sizeof ( l ) ) ; 
line 22339: l . l_type = F_RDLCK ; 
line 22340: l . l_len = 1 ; 
line 22341: l . l_start = 0 ; 
line 22342: l . l_whence = SEEK_SET ; 
line 22343: rc = fcntl ( fd_orig , F_SETLK , & l ) ; 
line 22344: if ( rc != 0 ) return ; 
line 22345: memset ( & d , 0 , sizeof ( d ) ) ; 
line 22346: d . fd = fd ; 
line 22347: d . lock = l ; 
line 22348: d . lock . l_type = F_WRLCK ; 
line 22349: if ( pthread_create ( & t , 0 , threadLockingTest , & d ) == 0 ) { 
line 22350: pthread_join ( t , 0 ) ; 
line 22351: } 
line 22352: close ( fd ) ; 
line 22353: if ( d . result != 0 ) return ; 
line 22354: threadsOverrideEachOthersLocks = ( d . lock . l_type == F_UNLCK ) ; 
line 22355: } 
line 22356: # endif 
line 22364: static void releaseLockInfo ( struct unixLockInfo * pLock ) { 
line 22365: assert ( unixMutexHeld ( ) ) ; 
line 22366: if ( pLock ) { 
line 22367: pLock -> nRef -- ; 
line 22368: if ( pLock -> nRef == 0 ) { 
line 22369: if ( pLock -> pPrev ) { 
line 22370: assert ( pLock -> pPrev -> pNext == pLock ) ; 
line 22371: pLock -> pPrev -> pNext = pLock -> pNext ; 
line 22372: } else { 
line 22373: assert ( lockList == pLock ) ; 
line 22374: lockList = pLock -> pNext ; 
line 22375: } 
line 22376: if ( pLock -> pNext ) { 
line 22377: assert ( pLock -> pNext -> pPrev == pLock ) ; 
line 22378: pLock -> pNext -> pPrev = pLock -> pPrev ; 
line 22379: } 
line 22380: sqlite3_free ( pLock ) ; 
line 22381: } 
line 22382: } 
line 22383: } 
line 22391: static void releaseOpenCnt ( struct unixOpenCnt * pOpen ) { 
line 22392: assert ( unixMutexHeld ( ) ) ; 
line 22393: if ( pOpen ) { 
line 22394: pOpen -> nRef -- ; 
line 22395: if ( pOpen -> nRef == 0 ) { 
line 22396: if ( pOpen -> pPrev ) { 
line 22397: assert ( pOpen -> pPrev -> pNext == pOpen ) ; 
line 22398: pOpen -> pPrev -> pNext = pOpen -> pNext ; 
line 22399: } else { 
line 22400: assert ( openList == pOpen ) ; 
line 22401: openList = pOpen -> pNext ; 
line 22402: } 
line 22403: if ( pOpen -> pNext ) { 
line 22404: assert ( pOpen -> pNext -> pPrev == pOpen ) ; 
line 22405: pOpen -> pNext -> pPrev = pOpen -> pPrev ; 
line 22406: } 
line 22407: # if SQLITE_THREADSAFE && defined ( __linux__ ) 
line 22408: assert ( ! pOpen -> pUnused || threadsOverrideEachOthersLocks == 0 ) ; 
line 22409: # endif 
line 22418: sqlite3_free ( pOpen ) ; 
line 22419: } 
line 22420: } 
line 22421: } 
line 22433: static int findLockInfo ( 
line 22434: unixFile * pFile , 
line 22435: struct unixLockInfo * * ppLock , 
line 22436: struct unixOpenCnt * * ppOpen 
line 22437: ) { 
line 22438: int rc ; 
line 22439: int fd ; 
line 22440: struct unixLockKey lockKey ; 
line 22441: struct unixFileId fileId ; 
line 22442: struct stat statbuf ; 
line 22443: struct unixLockInfo * pLock = 0 ; 
line 22444: struct unixOpenCnt * pOpen ; 
line 22446: assert ( unixMutexHeld ( ) ) ; 
line 22451: fd = pFile -> h ; 
line 22452: rc = fstat ( fd , & statbuf ) ; 
line 22453: if ( rc != 0 ) { 
line 22454: pFile -> lastErrno = errno ; 
line 22455: # ifdef EOVERFLOW 
line 22456: if ( pFile -> lastErrno == EOVERFLOW ) return SQLITE_NOLFS ; 
line 22457: # endif 
line 22458: return SQLITE_IOERR ; 
line 22459: } 
line 22461: # ifdef __APPLE__ 
line 22472: if ( statbuf . st_size == 0 ) { 
line 22473: rc = write ( fd , "S" , 1 ) ; 
line 22474: if ( rc != 1 ) { 
line 22475: return SQLITE_IOERR ; 
line 22476: } 
line 22477: rc = fstat ( fd , & statbuf ) ; 
line 22478: if ( rc != 0 ) { 
line 22479: pFile -> lastErrno = errno ; 
line 22480: return SQLITE_IOERR ; 
line 22481: } 
line 22482: } 
line 22483: # endif 
line 22485: memset ( & lockKey , 0 , sizeof ( lockKey ) ) ; 
line 22486: lockKey . fid . dev = statbuf . st_dev ; 
line 22487: # if OS_VXWORKS 
line 22488: lockKey . fid . pId = pFile -> pId ; 
line 22489: # else 
line 22490: lockKey . fid . ino = statbuf . st_ino ; 
line 22491: # endif 
line 22492: # if SQLITE_THREADSAFE && defined ( __linux__ ) 
line 22493: if ( threadsOverrideEachOthersLocks < 0 ) { 
line 22494: testThreadLockingBehavior ( fd ) ; 
line 22495: } 
line 22496: lockKey . tid = threadsOverrideEachOthersLocks ? 0 : pthread_self ( ) ; 
line 22497: # endif 
line 22498: fileId = lockKey . fid ; 
line 22499: if ( ppLock != 0 ) { 
line 22500: pLock = lockList ; 
line 22501: while ( pLock && memcmp ( & lockKey , & pLock -> lockKey , sizeof ( lockKey ) ) ) { 
line 22502: pLock = pLock -> pNext ; 
line 22503: } 
line 22504: if ( pLock == 0 ) { 
line 22505: pLock = sqlite3_malloc ( sizeof ( * pLock ) ) ; 
line 22506: if ( pLock == 0 ) { 
line 22507: rc = SQLITE_NOMEM ; 
line 22508: goto exit_findlockinfo ; 
line 22509: } 
line 22510: memcpy ( & pLock -> lockKey , & lockKey , sizeof ( lockKey ) ) ; 
line 22511: pLock -> nRef = 1 ; 
line 22512: pLock -> cnt = 0 ; 
line 22513: pLock -> locktype = 0 ; 
line 22514: pLock -> pNext = lockList ; 
line 22515: pLock -> pPrev = 0 ; 
line 22516: if ( lockList ) lockList -> pPrev = pLock ; 
line 22517: lockList = pLock ; 
line 22518: } else { 
line 22519: pLock -> nRef ++ ; 
line 22520: } 
line 22521: * ppLock = pLock ; 
line 22522: } 
line 22523: if ( ppOpen != 0 ) { 
line 22524: pOpen = openList ; 
line 22525: while ( pOpen && memcmp ( & fileId , & pOpen -> fileId , sizeof ( fileId ) ) ) { 
line 22526: pOpen = pOpen -> pNext ; 
line 22527: } 
line 22528: if ( pOpen == 0 ) { 
line 22529: pOpen = sqlite3_malloc ( sizeof ( * pOpen ) ) ; 
line 22530: if ( pOpen == 0 ) { 
line 22531: releaseLockInfo ( pLock ) ; 
line 22532: rc = SQLITE_NOMEM ; 
line 22533: goto exit_findlockinfo ; 
line 22534: } 
line 22535: memset ( pOpen , 0 , sizeof ( * pOpen ) ) ; 
line 22536: pOpen -> fileId = fileId ; 
line 22537: pOpen -> nRef = 1 ; 
line 22538: pOpen -> pNext = openList ; 
line 22539: if ( openList ) openList -> pPrev = pOpen ; 
line 22540: openList = pOpen ; 
line 22541: } else { 
line 22542: pOpen -> nRef ++ ; 
line 22543: } 
line 22544: * ppOpen = pOpen ; 
line 22545: } 
line 22547: exit_findlockinfo : 
line 22548: return rc ; 
line 22549: } 
line 22562: # if SQLITE_THREADSAFE && defined ( __linux__ ) 
line 22563: static int transferOwnership ( unixFile * pFile ) { 
line 22564: int rc ; 
line 22565: pthread_t hSelf ; 
line 22566: if ( threadsOverrideEachOthersLocks ) { 
line 22568: return SQLITE_OK ; 
line 22569: } 
line 22570: hSelf = pthread_self ( ) ; 
line 22571: if ( pthread_equal ( pFile -> tid , hSelf ) ) { 
line 22573: OSTRACE1 ( "No-transfer, same thread\n" ) ; 
line 22574: return SQLITE_OK ; 
line 22575: } 
line 22576: if ( pFile -> locktype != NO_LOCK ) { 
line 22578: return SQLITE_MISUSE ; 
line 22579: } 
line 22580: OSTRACE4 ( "Transfer ownership of %d from %d to %d\n" , 
line 22581: pFile -> h , pFile -> tid , hSelf ) ; 
line 22582: pFile -> tid = hSelf ; 
line 22583: if ( pFile -> pLock != NULL ) { 
line 22584: releaseLockInfo ( pFile -> pLock ) ; 
line 22585: rc = findLockInfo ( pFile , & pFile -> pLock , 0 ) ; 
line 22586: OSTRACE5 ( "LOCK    %d is now %s(%s,%d)\n" , pFile -> h , 
line 22587: locktypeName ( pFile -> locktype ) , 
line 22588: locktypeName ( pFile -> pLock -> locktype ) , pFile -> pLock -> cnt ) ; 
line 22589: return rc ; 
line 22590: } else { 
line 22591: return SQLITE_OK ; 
line 22592: } 
line 22593: } 
line 22594: # else 
line 22596: # define transferOwnership ( X ) SQLITE_OK 
line 22597: # endif 
line 22606: static int unixCheckReservedLock ( sqlite3_file * id , int * pResOut ) { 
line 22607: int rc = SQLITE_OK ; 
line 22608: int reserved = 0 ; 
line 22609: unixFile * pFile = ( unixFile * ) id ; 
line 22611: SimulateIOError ( return SQLITE_IOERR_CHECKRESERVEDLOCK ; ) ; 
line 22613: assert ( pFile ) ; 
line 22614: unixEnterMutex ( ) ; 
line 22617: if ( pFile -> pLock -> locktype > SHARED_LOCK ) { 
line 22618: reserved = 1 ; 
line 22619: } 
line 22623: # ifndef __DJGPP__ 
line 22624: if ( ! reserved ) { 
line 22625: struct flock lock ; 
line 22626: lock . l_whence = SEEK_SET ; 
line 22627: lock . l_start = RESERVED_BYTE ; 
line 22628: lock . l_len = 1 ; 
line 22629: lock . l_type = F_WRLCK ; 
line 22630: if ( - 1 == fcntl ( pFile -> h , F_GETLK , & lock ) ) { 
line 22631: int tErrno = errno ; 
line 22632: rc = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_CHECKRESERVEDLOCK ) ; 
line 22633: pFile -> lastErrno = tErrno ; 
line 22634: } else if ( lock . l_type != F_UNLCK ) { 
line 22635: reserved = 1 ; 
line 22636: } 
line 22637: } 
line 22638: # endif 
line 22640: unixLeaveMutex ( ) ; 
line 22641: OSTRACE4 ( "TEST WR-LOCK %d %d %d (unix)\n" , pFile -> h , rc , reserved ) ; 
line 22643: * pResOut = reserved ; 
line 22644: return rc ; 
line 22645: } 
line 22673: static int rangeLock ( unixFile * pFile , int op , int * pErrcode ) { 
line 22674: struct flock lock ; 
line 22675: int rc ; 
line 22676: lock . l_type = op ; 
line 22677: lock . l_start = SHARED_FIRST ; 
line 22678: lock . l_whence = SEEK_SET ; 
line 22679: if ( ( pFile -> fileFlags & SQLITE_WHOLE_FILE_LOCKING ) == 0 ) { 
line 22680: lock . l_len = SHARED_SIZE ; 
line 22681: rc = fcntl ( pFile -> h , F_SETLK , & lock ) ; 
line 22682: * pErrcode = errno ; 
line 22683: } else { 
line 22684: lock . l_len = 0 ; 
line 22685: rc = fcntl ( pFile -> h , F_SETLK , & lock ) ; 
line 22686: * pErrcode = errno ; 
line 22687: if ( NEVER ( op == F_UNLCK ) || rc != ( - 1 ) ) { 
line 22688: lock . l_start = 0 ; 
line 22689: lock . l_len = PENDING_BYTE ; 
line 22690: rc = fcntl ( pFile -> h , F_SETLK , & lock ) ; 
line 22691: if ( ALWAYS ( op != F_UNLCK ) && rc == ( - 1 ) ) { 
line 22692: * pErrcode = errno ; 
line 22693: lock . l_type = F_UNLCK ; 
line 22694: lock . l_start = SHARED_FIRST ; 
line 22695: lock . l_len = 0 ; 
line 22696: fcntl ( pFile -> h , F_SETLK , & lock ) ; 
line 22697: } 
line 22698: } 
line 22699: } 
line 22700: return rc ; 
line 22701: } 
line 22727: static int unixLock ( sqlite3_file * id , int locktype ) { 
line 22766: int rc = SQLITE_OK ; 
line 22767: unixFile * pFile = ( unixFile * ) id ; 
line 22768: struct unixLockInfo * pLock = pFile -> pLock ; 
line 22769: struct flock lock ; 
line 22770: int s = 0 ; 
line 22771: int tErrno ; 
line 22773: assert ( pFile ) ; 
line 22774: OSTRACE7 ( "LOCK    %d %s was %s(%s,%d) pid=%d (unix)\n" , pFile -> h , 
line 22775: locktypeName ( locktype ) , locktypeName ( pFile -> locktype ) , 
line 22776: locktypeName ( pLock -> locktype ) , pLock -> cnt , getpid ( ) ) ; 
line 22782: if ( pFile -> locktype >= locktype ) { 
line 22783: OSTRACE3 ( "LOCK    %d %s ok (already held) (unix)\n" , pFile -> h , 
line 22784: locktypeName ( locktype ) ) ; 
line 22785: return SQLITE_OK ; 
line 22786: } 
line 22793: assert ( pFile -> locktype != NO_LOCK || locktype == SHARED_LOCK ) ; 
line 22794: assert ( locktype != PENDING_LOCK ) ; 
line 22795: assert ( locktype != RESERVED_LOCK || pFile -> locktype == SHARED_LOCK ) ; 
line 22799: unixEnterMutex ( ) ; 
line 22803: rc = transferOwnership ( pFile ) ; 
line 22804: if ( rc != SQLITE_OK ) { 
line 22805: unixLeaveMutex ( ) ; 
line 22806: return rc ; 
line 22807: } 
line 22808: pLock = pFile -> pLock ; 
line 22813: if ( ( pFile -> locktype != pLock -> locktype && 
line 22814: ( pLock -> locktype >= PENDING_LOCK || locktype > SHARED_LOCK ) ) 
line 22815: ) { 
line 22816: rc = SQLITE_BUSY ; 
line 22817: goto end_lock ; 
line 22818: } 
line 22824: if ( locktype == SHARED_LOCK && 
line 22825: ( pLock -> locktype == SHARED_LOCK || pLock -> locktype == RESERVED_LOCK ) ) { 
line 22826: assert ( locktype == SHARED_LOCK ) ; 
line 22827: assert ( pFile -> locktype == 0 ) ; 
line 22828: assert ( pLock -> cnt > 0 ) ; 
line 22829: pFile -> locktype = SHARED_LOCK ; 
line 22830: pLock -> cnt ++ ; 
line 22831: pFile -> pOpen -> nLock ++ ; 
line 22832: goto end_lock ; 
line 22833: } 
line 22840: lock . l_len = 1L ; 
line 22841: lock . l_whence = SEEK_SET ; 
line 22842: if ( locktype == SHARED_LOCK 
line 22843: || ( locktype == EXCLUSIVE_LOCK && pFile -> locktype < PENDING_LOCK ) 
line 22844: ) { 
line 22845: lock . l_type = ( locktype == SHARED_LOCK ? F_RDLCK : F_WRLCK ) ; 
line 22846: lock . l_start = PENDING_BYTE ; 
line 22847: s = fcntl ( pFile -> h , F_SETLK , & lock ) ; 
line 22848: if ( s == ( - 1 ) ) { 
line 22849: tErrno = errno ; 
line 22850: rc = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_LOCK ) ; 
line 22851: if ( IS_LOCK_ERROR ( rc ) ) { 
line 22852: pFile -> lastErrno = tErrno ; 
line 22853: } 
line 22854: goto end_lock ; 
line 22855: } 
line 22856: } 
line 22862: if ( locktype == SHARED_LOCK ) { 
line 22863: assert ( pLock -> cnt == 0 ) ; 
line 22864: assert ( pLock -> locktype == 0 ) ; 
line 22867: s = rangeLock ( pFile , F_RDLCK , & tErrno ) ; 
line 22870: lock . l_start = PENDING_BYTE ; 
line 22871: lock . l_len = 1L ; 
line 22872: lock . l_type = F_UNLCK ; 
line 22873: if ( fcntl ( pFile -> h , F_SETLK , & lock ) != 0 ) { 
line 22874: if ( s != - 1 ) { 
line 22876: tErrno = errno ; 
line 22877: rc = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_UNLOCK ) ; 
line 22878: if ( IS_LOCK_ERROR ( rc ) ) { 
line 22879: pFile -> lastErrno = tErrno ; 
line 22880: } 
line 22881: goto end_lock ; 
line 22882: } 
line 22883: } 
line 22884: if ( s == ( - 1 ) ) { 
line 22885: rc = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_LOCK ) ; 
line 22886: if ( IS_LOCK_ERROR ( rc ) ) { 
line 22887: pFile -> lastErrno = tErrno ; 
line 22888: } 
line 22889: } else { 
line 22890: pFile -> locktype = SHARED_LOCK ; 
line 22891: pFile -> pOpen -> nLock ++ ; 
line 22892: pLock -> cnt = 1 ; 
line 22893: } 
line 22894: } else if ( locktype == EXCLUSIVE_LOCK && pLock -> cnt > 1 ) { 
line 22897: rc = SQLITE_BUSY ; 
line 22898: } else { 
line 22903: assert ( 0 != pFile -> locktype ) ; 
line 22904: lock . l_type = F_WRLCK ; 
line 22905: switch ( locktype ) { 
line 22906: case RESERVED_LOCK : 
line 22907: lock . l_start = RESERVED_BYTE ; 
line 22908: s = fcntl ( pFile -> h , F_SETLK , & lock ) ; 
line 22909: tErrno = errno ; 
line 22910: break ; 
line 22911: case EXCLUSIVE_LOCK : 
line 22912: s = rangeLock ( pFile , F_WRLCK , & tErrno ) ; 
line 22913: break ; 
line 22914: default : 
line 22915: assert ( 0 ) ; 
line 22916: } 
line 22917: if ( s == ( - 1 ) ) { 
line 22918: rc = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_LOCK ) ; 
line 22919: if ( IS_LOCK_ERROR ( rc ) ) { 
line 22920: pFile -> lastErrno = tErrno ; 
line 22921: } 
line 22922: } 
line 22923: } 
line 22926: # ifndef NDEBUG 
line 22932: if ( rc == SQLITE_OK 
line 22933: && pFile -> locktype <= SHARED_LOCK 
line 22934: && locktype == RESERVED_LOCK 
line 22935: ) { 
line 22936: pFile -> transCntrChng = 0 ; 
line 22937: pFile -> dbUpdate = 0 ; 
line 22938: pFile -> inNormalWrite = 1 ; 
line 22939: } 
line 22940: # endif 
line 22943: if ( rc == SQLITE_OK ) { 
line 22944: pFile -> locktype = locktype ; 
line 22945: pLock -> locktype = locktype ; 
line 22946: } else if ( locktype == EXCLUSIVE_LOCK ) { 
line 22947: pFile -> locktype = PENDING_LOCK ; 
line 22948: pLock -> locktype = PENDING_LOCK ; 
line 22949: } 
line 22951: end_lock : 
line 22952: unixLeaveMutex ( ) ; 
line 22953: OSTRACE4 ( "LOCK    %d %s %s (unix)\n" , pFile -> h , locktypeName ( locktype ) , 
line 22954: rc == SQLITE_OK ? "ok" : "failed" ) ; 
line 22955: return rc ; 
line 22956: } 
line 22967: static int closePendingFds ( unixFile * pFile ) { 
line 22968: int rc = SQLITE_OK ; 
line 22969: struct unixOpenCnt * pOpen = pFile -> pOpen ; 
line 22970: UnixUnusedFd * pError = 0 ; 
line 22971: UnixUnusedFd * p ; 
line 22972: UnixUnusedFd * pNext ; 
line 22973: for ( p = pOpen -> pUnused ; p ; p = pNext ) { 
line 22974: pNext = p -> pNext ; 
line 22975: if ( close ( p -> fd ) ) { 
line 22976: pFile -> lastErrno = errno ; 
line 22977: rc = SQLITE_IOERR_CLOSE ; 
line 22978: p -> pNext = pError ; 
line 22979: pError = p ; 
line 22980: } else { 
line 22981: sqlite3_free ( p ) ; 
line 22982: } 
line 22983: } 
line 22984: pOpen -> pUnused = pError ; 
line 22985: return rc ; 
line 22986: } 
line 22992: static void setPendingFd ( unixFile * pFile ) { 
line 22993: struct unixOpenCnt * pOpen = pFile -> pOpen ; 
line 22994: UnixUnusedFd * p = pFile -> pUnused ; 
line 22995: p -> pNext = pOpen -> pUnused ; 
line 22996: pOpen -> pUnused = p ; 
line 22997: pFile -> h = - 1 ; 
line 22998: pFile -> pUnused = 0 ; 
line 22999: } 
line 23008: static int unixUnlock ( sqlite3_file * id , int locktype ) { 
line 23009: unixFile * pFile = ( unixFile * ) id ; 
line 23010: struct unixLockInfo * pLock ; 
line 23011: struct flock lock ; 
line 23012: int rc = SQLITE_OK ; 
line 23013: int h ; 
line 23014: int tErrno ; 
line 23016: assert ( pFile ) ; 
line 23017: OSTRACE7 ( "UNLOCK  %d %d was %d(%d,%d) pid=%d (unix)\n" , pFile -> h , locktype , 
line 23018: pFile -> locktype , pFile -> pLock -> locktype , pFile -> pLock -> cnt , getpid ( ) ) ; 
line 23020: assert ( locktype <= SHARED_LOCK ) ; 
line 23021: if ( pFile -> locktype <= locktype ) { 
line 23022: return SQLITE_OK ; 
line 23023: } 
line 23024: if ( CHECK_THREADID ( pFile ) ) { 
line 23025: return SQLITE_MISUSE ; 
line 23026: } 
line 23027: unixEnterMutex ( ) ; 
line 23028: h = pFile -> h ; 
line 23029: pLock = pFile -> pLock ; 
line 23030: assert ( pLock -> cnt != 0 ) ; 
line 23031: if ( pFile -> locktype > SHARED_LOCK ) { 
line 23032: assert ( pLock -> locktype == pFile -> locktype ) ; 
line 23033: SimulateIOErrorBenign ( 1 ) ; 
line 23034: SimulateIOError ( h = ( - 1 ) ) 
line 23035: SimulateIOErrorBenign ( 0 ) ; 
line 23037: # ifndef NDEBUG 
line 23046: assert ( pFile -> inNormalWrite == 0 
line 23047: || pFile -> dbUpdate == 0 
line 23048: || pFile -> transCntrChng == 1 ) ; 
line 23049: pFile -> inNormalWrite = 0 ; 
line 23050: # endif 
line 23053: if ( locktype == SHARED_LOCK ) { 
line 23054: if ( rangeLock ( pFile , F_RDLCK , & tErrno ) == ( - 1 ) ) { 
line 23055: rc = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_RDLOCK ) ; 
line 23056: if ( IS_LOCK_ERROR ( rc ) ) { 
line 23057: pFile -> lastErrno = tErrno ; 
line 23058: } 
line 23059: goto end_unlock ; 
line 23060: } 
line 23061: } 
line 23062: lock . l_type = F_UNLCK ; 
line 23063: lock . l_whence = SEEK_SET ; 
line 23064: lock . l_start = PENDING_BYTE ; 
line 23065: lock . l_len = 2L ; assert ( PENDING_BYTE + 1 == RESERVED_BYTE ) ; 
line 23066: if ( fcntl ( h , F_SETLK , & lock ) != ( - 1 ) ) { 
line 23067: pLock -> locktype = SHARED_LOCK ; 
line 23068: } else { 
line 23069: tErrno = errno ; 
line 23070: rc = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_UNLOCK ) ; 
line 23071: if ( IS_LOCK_ERROR ( rc ) ) { 
line 23072: pFile -> lastErrno = tErrno ; 
line 23073: } 
line 23074: goto end_unlock ; 
line 23075: } 
line 23076: } 
line 23077: if ( locktype == NO_LOCK ) { 
line 23078: struct unixOpenCnt * pOpen ; 
line 23084: pLock -> cnt -- ; 
line 23085: if ( pLock -> cnt == 0 ) { 
line 23086: lock . l_type = F_UNLCK ; 
line 23087: lock . l_whence = SEEK_SET ; 
line 23088: lock . l_start = lock . l_len = 0L ; 
line 23089: SimulateIOErrorBenign ( 1 ) ; 
line 23090: SimulateIOError ( h = ( - 1 ) ) 
line 23091: SimulateIOErrorBenign ( 0 ) ; 
line 23092: if ( fcntl ( h , F_SETLK , & lock ) != ( - 1 ) ) { 
line 23093: pLock -> locktype = NO_LOCK ; 
line 23094: } else { 
line 23095: tErrno = errno ; 
line 23096: rc = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_UNLOCK ) ; 
line 23097: if ( IS_LOCK_ERROR ( rc ) ) { 
line 23098: pFile -> lastErrno = tErrno ; 
line 23099: } 
line 23100: pLock -> locktype = NO_LOCK ; 
line 23101: pFile -> locktype = NO_LOCK ; 
line 23102: } 
line 23103: } 
line 23109: pOpen = pFile -> pOpen ; 
line 23110: pOpen -> nLock -- ; 
line 23111: assert ( pOpen -> nLock >= 0 ) ; 
line 23112: if ( pOpen -> nLock == 0 ) { 
line 23113: int rc2 = closePendingFds ( pFile ) ; 
line 23114: if ( rc == SQLITE_OK ) { 
line 23115: rc = rc2 ; 
line 23116: } 
line 23117: } 
line 23118: } 
line 23120: end_unlock : 
line 23121: unixLeaveMutex ( ) ; 
line 23122: if ( rc == SQLITE_OK ) pFile -> locktype = locktype ; 
line 23123: return rc ; 
line 23124: } 
line 23136: static int closeUnixFile ( sqlite3_file * id ) { 
line 23137: unixFile * pFile = ( unixFile * ) id ; 
line 23138: if ( pFile ) { 
line 23139: if ( pFile -> dirfd >= 0 ) { 
line 23140: int err = close ( pFile -> dirfd ) ; 
line 23141: if ( err ) { 
line 23142: pFile -> lastErrno = errno ; 
line 23143: return SQLITE_IOERR_DIR_CLOSE ; 
line 23144: } else { 
line 23145: pFile -> dirfd = - 1 ; 
line 23146: } 
line 23147: } 
line 23148: if ( pFile -> h >= 0 ) { 
line 23149: int err = close ( pFile -> h ) ; 
line 23150: if ( err ) { 
line 23151: pFile -> lastErrno = errno ; 
line 23152: return SQLITE_IOERR_CLOSE ; 
line 23153: } 
line 23154: } 
line 23155: # if OS_VXWORKS 
line 23156: if ( pFile -> pId ) { 
line 23157: if ( pFile -> isDelete ) { 
line 23158: unlink ( pFile -> pId -> zCanonicalName ) ; 
line 23159: } 
line 23160: vxworksReleaseFileId ( pFile -> pId ) ; 
line 23161: pFile -> pId = 0 ; 
line 23162: } 
line 23163: # endif 
line 23164: OSTRACE2 ( "CLOSE   %-3d\n" , pFile -> h ) ; 
line 23165: OpenCounter ( - 1 ) ; 
line 23166: sqlite3_free ( pFile -> pUnused ) ; 
line 23167: memset ( pFile , 0 , sizeof ( unixFile ) ) ; 
line 23168: } 
line 23169: return SQLITE_OK ; 
line 23170: } 
line 23175: static int unixClose ( sqlite3_file * id ) { 
line 23176: int rc = SQLITE_OK ; 
line 23177: if ( id ) { 
line 23178: unixFile * pFile = ( unixFile * ) id ; 
line 23179: unixUnlock ( id , NO_LOCK ) ; 
line 23180: unixEnterMutex ( ) ; 
line 23181: if ( pFile -> pOpen && pFile -> pOpen -> nLock ) { 
line 23187: setPendingFd ( pFile ) ; 
line 23188: } 
line 23189: releaseLockInfo ( pFile -> pLock ) ; 
line 23190: releaseOpenCnt ( pFile -> pOpen ) ; 
line 23191: rc = closeUnixFile ( id ) ; 
line 23192: unixLeaveMutex ( ) ; 
line 23193: } 
line 23194: return rc ; 
line 23195: } 
line 23217: static int nolockCheckReservedLock ( sqlite3_file * NotUsed , int * pResOut ) { 
line 23218: UNUSED_PARAMETER ( NotUsed ) ; 
line 23219: * pResOut = 0 ; 
line 23220: return SQLITE_OK ; 
line 23221: } 
line 23222: static int nolockLock ( sqlite3_file * NotUsed , int NotUsed2 ) { 
line 23223: UNUSED_PARAMETER2 ( NotUsed , NotUsed2 ) ; 
line 23224: return SQLITE_OK ; 
line 23225: } 
line 23226: static int nolockUnlock ( sqlite3_file * NotUsed , int NotUsed2 ) { 
line 23227: UNUSED_PARAMETER2 ( NotUsed , NotUsed2 ) ; 
line 23228: return SQLITE_OK ; 
line 23229: } 
line 23234: static int nolockClose ( sqlite3_file * id ) { 
line 23235: return closeUnixFile ( id ) ; 
line 23236: } 
line 23267: # define DOTLOCK_SUFFIX ".lock" 
line 23279: static int dotlockCheckReservedLock ( sqlite3_file * id , int * pResOut ) { 
line 23280: int rc = SQLITE_OK ; 
line 23281: int reserved = 0 ; 
line 23282: unixFile * pFile = ( unixFile * ) id ; 
line 23284: SimulateIOError ( return SQLITE_IOERR_CHECKRESERVEDLOCK ; ) ; 
line 23286: assert ( pFile ) ; 
line 23289: if ( pFile -> locktype > SHARED_LOCK ) { 
line 23292: reserved = 1 ; 
line 23293: } else { 
line 23295: const char * zLockFile = ( const char * ) pFile -> lockingContext ; 
line 23296: reserved = access ( zLockFile , 0 ) == 0 ; 
line 23297: } 
line 23298: OSTRACE4 ( "TEST WR-LOCK %d %d %d (dotlock)\n" , pFile -> h , rc , reserved ) ; 
line 23299: * pResOut = reserved ; 
line 23300: return rc ; 
line 23301: } 
line 23330: static int dotlockLock ( sqlite3_file * id , int locktype ) { 
line 23331: unixFile * pFile = ( unixFile * ) id ; 
line 23332: int fd ; 
line 23333: char * zLockFile = ( char * ) pFile -> lockingContext ; 
line 23334: int rc = SQLITE_OK ; 
line 23340: if ( pFile -> locktype > NO_LOCK ) { 
line 23341: pFile -> locktype = locktype ; 
line 23342: # if ! OS_VXWORKS 
line 23344: utimes ( zLockFile , NULL ) ; 
line 23345: # endif 
line 23346: return SQLITE_OK ; 
line 23347: } 
line 23350: fd = open ( zLockFile , O_RDONLY | O_CREAT | O_EXCL , 0600 ) ; 
line 23351: if ( fd < 0 ) { 
line 23353: int tErrno = errno ; 
line 23354: if ( EEXIST == tErrno ) { 
line 23355: rc = SQLITE_BUSY ; 
line 23356: } else { 
line 23357: rc = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_LOCK ) ; 
line 23358: if ( IS_LOCK_ERROR ( rc ) ) { 
line 23359: pFile -> lastErrno = tErrno ; 
line 23360: } 
line 23361: } 
line 23362: return rc ; 
line 23363: } 
line 23364: if ( close ( fd ) ) { 
line 23365: pFile -> lastErrno = errno ; 
line 23366: rc = SQLITE_IOERR_CLOSE ; 
line 23367: } 
line 23370: pFile -> locktype = locktype ; 
line 23371: return rc ; 
line 23372: } 
line 23383: static int dotlockUnlock ( sqlite3_file * id , int locktype ) { 
line 23384: unixFile * pFile = ( unixFile * ) id ; 
line 23385: char * zLockFile = ( char * ) pFile -> lockingContext ; 
line 23387: assert ( pFile ) ; 
line 23388: OSTRACE5 ( "UNLOCK  %d %d was %d pid=%d (dotlock)\n" , pFile -> h , locktype , 
line 23389: pFile -> locktype , getpid ( ) ) ; 
line 23390: assert ( locktype <= SHARED_LOCK ) ; 
line 23393: if ( pFile -> locktype == locktype ) { 
line 23394: return SQLITE_OK ; 
line 23395: } 
line 23400: if ( locktype == SHARED_LOCK ) { 
line 23401: pFile -> locktype = SHARED_LOCK ; 
line 23402: return SQLITE_OK ; 
line 23403: } 
line 23406: assert ( locktype == NO_LOCK ) ; 
line 23407: if ( unlink ( zLockFile ) ) { 
line 23408: int rc = 0 ; 
line 23409: int tErrno = errno ; 
line 23410: if ( ENOENT != tErrno ) { 
line 23411: rc = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_UNLOCK ) ; 
line 23412: } 
line 23413: if ( IS_LOCK_ERROR ( rc ) ) { 
line 23414: pFile -> lastErrno = tErrno ; 
line 23415: } 
line 23416: return rc ; 
line 23417: } 
line 23418: pFile -> locktype = NO_LOCK ; 
line 23419: return SQLITE_OK ; 
line 23420: } 
line 23425: static int dotlockClose ( sqlite3_file * id ) { 
line 23426: int rc ; 
line 23427: if ( id ) { 
line 23428: unixFile * pFile = ( unixFile * ) id ; 
line 23429: dotlockUnlock ( id , NO_LOCK ) ; 
line 23430: sqlite3_free ( pFile -> lockingContext ) ; 
line 23431: } 
line 23432: rc = closeUnixFile ( id ) ; 
line 23433: return rc ; 
line 23434: } 
line 23453: # if SQLITE_ENABLE_LOCKING_STYLE && ! OS_VXWORKS 
line 23461: static int flockCheckReservedLock ( sqlite3_file * id , int * pResOut ) { 
line 23462: int rc = SQLITE_OK ; 
line 23463: int reserved = 0 ; 
line 23464: unixFile * pFile = ( unixFile * ) id ; 
line 23466: SimulateIOError ( return SQLITE_IOERR_CHECKRESERVEDLOCK ; ) ; 
line 23468: assert ( pFile ) ; 
line 23471: if ( pFile -> locktype > SHARED_LOCK ) { 
line 23472: reserved = 1 ; 
line 23473: } 
line 23476: if ( ! reserved ) { 
line 23478: int lrc = flock ( pFile -> h , LOCK_EX | LOCK_NB ) ; 
line 23479: if ( ! lrc ) { 
line 23481: lrc = flock ( pFile -> h , LOCK_UN ) ; 
line 23482: if ( lrc ) { 
line 23483: int tErrno = errno ; 
line 23485: lrc = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_UNLOCK ) ; 
line 23486: if ( IS_LOCK_ERROR ( lrc ) ) { 
line 23487: pFile -> lastErrno = tErrno ; 
line 23488: rc = lrc ; 
line 23489: } 
line 23490: } 
line 23491: } else { 
line 23492: int tErrno = errno ; 
line 23493: reserved = 1 ; 
line 23495: lrc = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_LOCK ) ; 
line 23496: if ( IS_LOCK_ERROR ( lrc ) ) { 
line 23497: pFile -> lastErrno = tErrno ; 
line 23498: rc = lrc ; 
line 23499: } 
line 23500: } 
line 23501: } 
line 23502: OSTRACE4 ( "TEST WR-LOCK %d %d %d (flock)\n" , pFile -> h , rc , reserved ) ; 
line 23504: # ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS 
line 23505: if ( ( rc & SQLITE_IOERR ) == SQLITE_IOERR ) { 
line 23506: rc = SQLITE_OK ; 
line 23507: reserved = 1 ; 
line 23508: } 
line 23509: # endif 
line 23510: * pResOut = reserved ; 
line 23511: return rc ; 
line 23512: } 
line 23543: static int flockLock ( sqlite3_file * id , int locktype ) { 
line 23544: int rc = SQLITE_OK ; 
line 23545: unixFile * pFile = ( unixFile * ) id ; 
line 23547: assert ( pFile ) ; 
line 23551: if ( pFile -> locktype > NO_LOCK ) { 
line 23552: pFile -> locktype = locktype ; 
line 23553: return SQLITE_OK ; 
line 23554: } 
line 23558: if ( flock ( pFile -> h , LOCK_EX | LOCK_NB ) ) { 
line 23559: int tErrno = errno ; 
line 23561: rc = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_LOCK ) ; 
line 23562: if ( IS_LOCK_ERROR ( rc ) ) { 
line 23563: pFile -> lastErrno = tErrno ; 
line 23564: } 
line 23565: } else { 
line 23567: pFile -> locktype = locktype ; 
line 23568: } 
line 23569: OSTRACE4 ( "LOCK    %d %s %s (flock)\n" , pFile -> h , locktypeName ( locktype ) , 
line 23570: rc == SQLITE_OK ? "ok" : "failed" ) ; 
line 23571: # ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS 
line 23572: if ( ( rc & SQLITE_IOERR ) == SQLITE_IOERR ) { 
line 23573: rc = SQLITE_BUSY ; 
line 23574: } 
line 23575: # endif 
line 23576: return rc ; 
line 23577: } 
line 23587: static int flockUnlock ( sqlite3_file * id , int locktype ) { 
line 23588: unixFile * pFile = ( unixFile * ) id ; 
line 23590: assert ( pFile ) ; 
line 23591: OSTRACE5 ( "UNLOCK  %d %d was %d pid=%d (flock)\n" , pFile -> h , locktype , 
line 23592: pFile -> locktype , getpid ( ) ) ; 
line 23593: assert ( locktype <= SHARED_LOCK ) ; 
line 23596: if ( pFile -> locktype == locktype ) { 
line 23597: return SQLITE_OK ; 
line 23598: } 
line 23601: if ( locktype == SHARED_LOCK ) { 
line 23602: pFile -> locktype = locktype ; 
line 23603: return SQLITE_OK ; 
line 23604: } 
line 23607: int rc = flock ( pFile -> h , LOCK_UN ) ; 
line 23608: if ( rc ) { 
line 23609: int r , tErrno = errno ; 
line 23610: r = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_UNLOCK ) ; 
line 23611: if ( IS_LOCK_ERROR ( r ) ) { 
line 23612: pFile -> lastErrno = tErrno ; 
line 23613: } 
line 23614: # ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS 
line 23615: if ( ( r & SQLITE_IOERR ) == SQLITE_IOERR ) { 
line 23616: r = SQLITE_BUSY ; 
line 23617: } 
line 23618: # endif 
line 23620: return r ; 
line 23621: } else { 
line 23622: pFile -> locktype = NO_LOCK ; 
line 23623: return SQLITE_OK ; 
line 23624: } 
line 23625: } 
line 23630: static int flockClose ( sqlite3_file * id ) { 
line 23631: if ( id ) { 
line 23632: flockUnlock ( id , NO_LOCK ) ; 
line 23633: } 
line 23634: return closeUnixFile ( id ) ; 
line 23635: } 
line 23637: # endif 
line 23652: # if OS_VXWORKS 
line 23660: static int semCheckReservedLock ( sqlite3_file * id , int * pResOut ) { 
line 23661: int rc = SQLITE_OK ; 
line 23662: int reserved = 0 ; 
line 23663: unixFile * pFile = ( unixFile * ) id ; 
line 23665: SimulateIOError ( return SQLITE_IOERR_CHECKRESERVEDLOCK ; ) ; 
line 23667: assert ( pFile ) ; 
line 23670: if ( pFile -> locktype > SHARED_LOCK ) { 
line 23671: reserved = 1 ; 
line 23672: } 
line 23675: if ( ! reserved ) { 
line 23676: sem_t * pSem = pFile -> pOpen -> pSem ; 
line 23677: struct stat statBuf ; 
line 23679: if ( sem_trywait ( pSem ) == - 1 ) { 
line 23680: int tErrno = errno ; 
line 23681: if ( EAGAIN != tErrno ) { 
line 23682: rc = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_CHECKRESERVEDLOCK ) ; 
line 23683: pFile -> lastErrno = tErrno ; 
line 23684: } else { 
line 23686: reserved = ( pFile -> locktype < SHARED_LOCK ) ; 
line 23687: } 
line 23688: } else { 
line 23690: sem_post ( pSem ) ; 
line 23691: } 
line 23692: } 
line 23693: OSTRACE4 ( "TEST WR-LOCK %d %d %d (sem)\n" , pFile -> h , rc , reserved ) ; 
line 23695: * pResOut = reserved ; 
line 23696: return rc ; 
line 23697: } 
line 23728: static int semLock ( sqlite3_file * id , int locktype ) { 
line 23729: unixFile * pFile = ( unixFile * ) id ; 
line 23730: int fd ; 
line 23731: sem_t * pSem = pFile -> pOpen -> pSem ; 
line 23732: int rc = SQLITE_OK ; 
line 23736: if ( pFile -> locktype > NO_LOCK ) { 
line 23737: pFile -> locktype = locktype ; 
line 23738: rc = SQLITE_OK ; 
line 23739: goto sem_end_lock ; 
line 23740: } 
line 23743: if ( sem_trywait ( pSem ) == - 1 ) { 
line 23744: rc = SQLITE_BUSY ; 
line 23745: goto sem_end_lock ; 
line 23746: } 
line 23749: pFile -> locktype = locktype ; 
line 23751: sem_end_lock : 
line 23752: return rc ; 
line 23753: } 
line 23762: static int semUnlock ( sqlite3_file * id , int locktype ) { 
line 23763: unixFile * pFile = ( unixFile * ) id ; 
line 23764: sem_t * pSem = pFile -> pOpen -> pSem ; 
line 23766: assert ( pFile ) ; 
line 23767: assert ( pSem ) ; 
line 23768: OSTRACE5 ( "UNLOCK  %d %d was %d pid=%d (sem)\n" , pFile -> h , locktype , 
line 23769: pFile -> locktype , getpid ( ) ) ; 
line 23770: assert ( locktype <= SHARED_LOCK ) ; 
line 23773: if ( pFile -> locktype == locktype ) { 
line 23774: return SQLITE_OK ; 
line 23775: } 
line 23778: if ( locktype == SHARED_LOCK ) { 
line 23779: pFile -> locktype = locktype ; 
line 23780: return SQLITE_OK ; 
line 23781: } 
line 23784: if ( sem_post ( pSem ) == - 1 ) { 
line 23785: int rc , tErrno = errno ; 
line 23786: rc = sqliteErrorFromPosixError ( tErrno , SQLITE_IOERR_UNLOCK ) ; 
line 23787: if ( IS_LOCK_ERROR ( rc ) ) { 
line 23788: pFile -> lastErrno = tErrno ; 
line 23789: } 
line 23790: return rc ; 
line 23791: } 
line 23792: pFile -> locktype = NO_LOCK ; 
line 23793: return SQLITE_OK ; 
line 23794: } 
line 23799: static int semClose ( sqlite3_file * id ) { 
line 23800: if ( id ) { 
line 23801: unixFile * pFile = ( unixFile * ) id ; 
line 23802: semUnlock ( id , NO_LOCK ) ; 
line 23803: assert ( pFile ) ; 
line 23804: unixEnterMutex ( ) ; 
line 23805: releaseLockInfo ( pFile -> pLock ) ; 
line 23806: releaseOpenCnt ( pFile -> pOpen ) ; 
line 23807: unixLeaveMutex ( ) ; 
line 23808: closeUnixFile ( id ) ; 
line 23809: } 
line 23810: return SQLITE_OK ; 
line 23811: } 
line 23813: # endif 
line 23831: # if defined ( __APPLE__ ) && SQLITE_ENABLE_LOCKING_STYLE 
line 23835: typedef struct afpLockingContext afpLockingContext ; 
line 23836: struct afpLockingContext { 
line 23837: unsigned long long sharedByte ; 
line 23838: const char * dbPath ; 
line 23839: } ; 
line 23841: struct ByteRangeLockPB2 
line 23842: { 
line 23843: unsigned long long offset ; 
line 23844: unsigned long long length ; 
line 23845: unsigned long long retRangeStart ; 
line 23846: unsigned char unLockFlag ; 
line 23847: unsigned char startEndFlag ; 
line 23848: int fd ; 
line 23849: } ; 
line 23851: # define afpfsByteRangeLock2FSCTL _IOWR ( 'z' , 23 , struct ByteRangeLockPB2 ) 
line 23859: static int afpSetLock ( 
line 23860: const char * path , 
line 23861: unixFile * pFile , 
line 23862: unsigned long long offset , 
line 23863: unsigned long long length , 
line 23864: int setLockFlag 
line 23865: ) { 
line 23866: struct ByteRangeLockPB2 pb ; 
line 23867: int err ; 
line 23869: pb . unLockFlag = setLockFlag ? 0 : 1 ; 
line 23870: pb . startEndFlag = 0 ; 
line 23871: pb . offset = offset ; 
line 23872: pb . length = length ; 
line 23873: pb . fd = pFile -> h ; 
line 23875: OSTRACE6 ( "AFPSETLOCK [%s] for %d%s in range %llx:%llx\n" , 
line 23876: ( setLockFlag ? "ON" : "OFF" ) , pFile -> h , ( pb . fd == - 1 ? "[testval-1]" : "" ) , 
line 23877: offset , length ) ; 
line 23878: err = fsctl ( path , afpfsByteRangeLock2FSCTL , & pb , 0 ) ; 
line 23879: if ( err == - 1 ) { 
line 23880: int rc ; 
line 23881: int tErrno = errno ; 
line 23882: OSTRACE4 ( "AFPSETLOCK failed to fsctl() '%s' %d %s\n" , 
line 23883: path , tErrno , strerror ( tErrno ) ) ; 
line 23884: # ifdef SQLITE_IGNORE_AFP_LOCK_ERRORS 
line 23885: rc = SQLITE_BUSY ; 
line 23886: # else 
line 23887: rc = sqliteErrorFromPosixError ( tErrno , 
line 23888: setLockFlag ? SQLITE_IOERR_LOCK : SQLITE_IOERR_UNLOCK ) ; 
line 23889: # endif 
line 23890: if ( IS_LOCK_ERROR ( rc ) ) { 
line 23891: pFile -> lastErrno = tErrno ; 
line 23892: } 
line 23893: return rc ; 
line 23894: } else { 
line 23895: return SQLITE_OK ; 
line 23896: } 
line 23897: } 
line 23905: static int afpCheckReservedLock ( sqlite3_file * id , int * pResOut ) { 
line 23906: int rc = SQLITE_OK ; 
line 23907: int reserved = 0 ; 
line 23908: unixFile * pFile = ( unixFile * ) id ; 
line 23910: SimulateIOError ( return SQLITE_IOERR_CHECKRESERVEDLOCK ; ) ; 
line 23912: assert ( pFile ) ; 
line 23913: afpLockingContext * context = ( afpLockingContext * ) pFile -> lockingContext ; 
line 23916: if ( pFile -> locktype > SHARED_LOCK ) { 
line 23917: reserved = 1 ; 
line 23918: } 
line 23922: if ( ! reserved ) { 
line 23924: int lrc = afpSetLock ( context -> dbPath , pFile , RESERVED_BYTE , 1 , 1 ) ; 
line 23925: if ( SQLITE_OK == lrc ) { 
line 23928: lrc = afpSetLock ( context -> dbPath , pFile , RESERVED_BYTE , 1 , 0 ) ; 
line 23929: } else { 
line 23931: reserved = 1 ; 
line 23932: } 
line 23933: if ( IS_LOCK_ERROR ( lrc ) ) { 
line 23934: rc = lrc ; 
line 23935: } 
line 23936: } 
line 23938: OSTRACE4 ( "TEST WR-LOCK %d %d %d (afp)\n" , pFile -> h , rc , reserved ) ; 
line 23940: * pResOut = reserved ; 
line 23941: return rc ; 
line 23942: } 
line 23968: static int afpLock ( sqlite3_file * id , int locktype ) { 
line 23969: int rc = SQLITE_OK ; 
line 23970: unixFile * pFile = ( unixFile * ) id ; 
line 23971: afpLockingContext * context = ( afpLockingContext * ) pFile -> lockingContext ; 
line 23973: assert ( pFile ) ; 
line 23974: OSTRACE5 ( "LOCK    %d %s was %s pid=%d (afp)\n" , pFile -> h , 
line 23975: locktypeName ( locktype ) , locktypeName ( pFile -> locktype ) , getpid ( ) ) ; 
line 23981: if ( pFile -> locktype >= locktype ) { 
line 23982: OSTRACE3 ( "LOCK    %d %s ok (already held) (afp)\n" , pFile -> h , 
line 23983: locktypeName ( locktype ) ) ; 
line 23984: return SQLITE_OK ; 
line 23985: } 
line 23989: assert ( pFile -> locktype != NO_LOCK || locktype == SHARED_LOCK ) ; 
line 23990: assert ( locktype != PENDING_LOCK ) ; 
line 23991: assert ( locktype != RESERVED_LOCK || pFile -> locktype == SHARED_LOCK ) ; 
line 23995: unixEnterMutex ( ) ; 
line 23999: rc = transferOwnership ( pFile ) ; 
line 24000: if ( rc != SQLITE_OK ) { 
line 24001: unixLeaveMutex ( ) ; 
line 24002: return rc ; 
line 24003: } 
line 24009: if ( locktype == SHARED_LOCK 
line 24010: || ( locktype == EXCLUSIVE_LOCK && pFile -> locktype < PENDING_LOCK ) 
line 24011: ) { 
line 24012: int failed ; 
line 24013: failed = afpSetLock ( context -> dbPath , pFile , PENDING_BYTE , 1 , 1 ) ; 
line 24014: if ( failed ) { 
line 24015: rc = failed ; 
line 24016: goto afp_end_lock ; 
line 24017: } 
line 24018: } 
line 24023: if ( locktype == SHARED_LOCK ) { 
line 24024: int lk , lrc1 , lrc2 ; 
line 24025: int lrc1Errno = 0 ; 
line 24029: lk = random ( ) ; 
line 24030: context -> sharedByte = ( lk & 0x7fffffff ) % ( SHARED_SIZE - 1 ) ; 
line 24031: lrc1 = afpSetLock ( context -> dbPath , pFile , 
line 24032: SHARED_FIRST + context -> sharedByte , 1 , 1 ) ; 
line 24033: if ( IS_LOCK_ERROR ( lrc1 ) ) { 
line 24034: lrc1Errno = pFile -> lastErrno ; 
line 24035: } 
line 24037: lrc2 = afpSetLock ( context -> dbPath , pFile , PENDING_BYTE , 1 , 0 ) ; 
line 24039: if ( IS_LOCK_ERROR ( lrc1 ) ) { 
line 24040: pFile -> lastErrno = lrc1Errno ; 
line 24041: rc = lrc1 ; 
line 24042: goto afp_end_lock ; 
line 24043: } else if ( IS_LOCK_ERROR ( lrc2 ) ) { 
line 24044: rc = lrc2 ; 
line 24045: goto afp_end_lock ; 
line 24046: } else if ( lrc1 != SQLITE_OK ) { 
line 24047: rc = lrc1 ; 
line 24048: } else { 
line 24049: pFile -> locktype = SHARED_LOCK ; 
line 24050: pFile -> pOpen -> nLock ++ ; 
line 24051: } 
line 24052: } else { 
line 24057: int failed = 0 ; 
line 24058: assert ( 0 != pFile -> locktype ) ; 
line 24059: if ( locktype >= RESERVED_LOCK && pFile -> locktype < RESERVED_LOCK ) { 
line 24061: failed = afpSetLock ( context -> dbPath , pFile , RESERVED_BYTE , 1 , 1 ) ; 
line 24062: } 
line 24063: if ( ! failed && locktype == EXCLUSIVE_LOCK ) { 
line 24069: if ( ! ( failed = afpSetLock ( context -> dbPath , pFile , SHARED_FIRST + 
line 24070: context -> sharedByte , 1 , 0 ) ) ) { 
line 24071: int failed2 = SQLITE_OK ; 
line 24073: failed = afpSetLock ( context -> dbPath , pFile , SHARED_FIRST , 
line 24074: SHARED_SIZE , 1 ) ; 
line 24075: if ( failed && ( failed2 = afpSetLock ( context -> dbPath , pFile , 
line 24076: SHARED_FIRST + context -> sharedByte , 1 , 1 ) ) ) { 
line 24080: rc = ( ( failed & SQLITE_IOERR ) == SQLITE_IOERR ) ? failed2 : 
line 24081: SQLITE_IOERR_LOCK ; 
line 24082: goto afp_end_lock ; 
line 24083: } 
line 24084: } else { 
line 24085: rc = failed ; 
line 24086: } 
line 24087: } 
line 24088: if ( failed ) { 
line 24089: rc = failed ; 
line 24090: } 
line 24091: } 
line 24093: if ( rc == SQLITE_OK ) { 
line 24094: pFile -> locktype = locktype ; 
line 24095: } else if ( locktype == EXCLUSIVE_LOCK ) { 
line 24096: pFile -> locktype = PENDING_LOCK ; 
line 24097: } 
line 24099: afp_end_lock : 
line 24100: unixLeaveMutex ( ) ; 
line 24101: OSTRACE4 ( "LOCK    %d %s %s (afp)\n" , pFile -> h , locktypeName ( locktype ) , 
line 24102: rc == SQLITE_OK ? "ok" : "failed" ) ; 
line 24103: return rc ; 
line 24104: } 
line 24113: static int afpUnlock ( sqlite3_file * id , int locktype ) { 
line 24114: int rc = SQLITE_OK ; 
line 24115: unixFile * pFile = ( unixFile * ) id ; 
line 24116: afpLockingContext * pCtx = ( afpLockingContext * ) pFile -> lockingContext ; 
line 24118: assert ( pFile ) ; 
line 24119: OSTRACE5 ( "UNLOCK  %d %d was %d pid=%d (afp)\n" , pFile -> h , locktype , 
line 24120: pFile -> locktype , getpid ( ) ) ; 
line 24122: assert ( locktype <= SHARED_LOCK ) ; 
line 24123: if ( pFile -> locktype <= locktype ) { 
line 24124: return SQLITE_OK ; 
line 24125: } 
line 24126: if ( CHECK_THREADID ( pFile ) ) { 
line 24127: return SQLITE_MISUSE ; 
line 24128: } 
line 24129: unixEnterMutex ( ) ; 
line 24130: if ( pFile -> locktype > SHARED_LOCK ) { 
line 24132: if ( pFile -> locktype == EXCLUSIVE_LOCK ) { 
line 24133: rc = afpSetLock ( pCtx -> dbPath , pFile , SHARED_FIRST , SHARED_SIZE , 0 ) ; 
line 24134: if ( rc == SQLITE_OK && locktype == SHARED_LOCK ) { 
line 24136: int sharedLockByte = SHARED_FIRST + pCtx -> sharedByte ; 
line 24137: rc = afpSetLock ( pCtx -> dbPath , pFile , sharedLockByte , 1 , 1 ) ; 
line 24138: } 
line 24139: } 
line 24140: if ( rc == SQLITE_OK && pFile -> locktype >= PENDING_LOCK ) { 
line 24141: rc = afpSetLock ( pCtx -> dbPath , pFile , PENDING_BYTE , 1 , 0 ) ; 
line 24142: } 
line 24143: if ( rc == SQLITE_OK && pFile -> locktype >= RESERVED_LOCK ) { 
line 24144: rc = afpSetLock ( pCtx -> dbPath , pFile , RESERVED_BYTE , 1 , 0 ) ; 
line 24145: } 
line 24146: } else if ( locktype == NO_LOCK ) { 
line 24148: int sharedLockByte = SHARED_FIRST + pCtx -> sharedByte ; 
line 24149: rc = afpSetLock ( pCtx -> dbPath , pFile , sharedLockByte , 1 , 0 ) ; 
line 24150: } 
line 24152: if ( rc == SQLITE_OK ) { 
line 24153: if ( locktype == NO_LOCK ) { 
line 24154: struct unixOpenCnt * pOpen = pFile -> pOpen ; 
line 24155: pOpen -> nLock -- ; 
line 24156: assert ( pOpen -> nLock >= 0 ) ; 
line 24157: if ( pOpen -> nLock == 0 ) { 
line 24158: rc = closePendingFds ( pFile ) ; 
line 24159: } 
line 24160: } 
line 24161: } 
line 24162: unixLeaveMutex ( ) ; 
line 24163: if ( rc == SQLITE_OK ) { 
line 24164: pFile -> locktype = locktype ; 
line 24165: } 
line 24166: return rc ; 
line 24167: } 
line 24172: static int afpClose ( sqlite3_file * id ) { 
line 24173: if ( id ) { 
line 24174: unixFile * pFile = ( unixFile * ) id ; 
line 24175: afpUnlock ( id , NO_LOCK ) ; 
line 24176: unixEnterMutex ( ) ; 
line 24177: if ( pFile -> pOpen && pFile -> pOpen -> nLock ) { 
line 24183: setPendingFd ( pFile ) ; 
line 24184: } 
line 24185: releaseOpenCnt ( pFile -> pOpen ) ; 
line 24186: sqlite3_free ( pFile -> lockingContext ) ; 
line 24187: closeUnixFile ( id ) ; 
line 24188: unixLeaveMutex ( ) ; 
line 24189: } 
line 24190: return SQLITE_OK ; 
line 24191: } 
line 24193: # endif 
line 24227: static int seekAndRead ( unixFile * id , sqlite3_int64 offset , void * pBuf , int cnt ) { 
line 24228: int got ; 
line 24229: i64 newOffset ; 
line 24230: TIMER_START ; 
line 24231: # if defined ( USE_PREAD ) 
line 24232: got = pread ( id -> h , pBuf , cnt , offset ) ; 
line 24233: SimulateIOError ( got = - 1 ) ; 
line 24234: # elif defined ( USE_PREAD64 ) 
line 24235: got = pread64 ( id -> h , pBuf , cnt , offset ) ; 
line 24236: SimulateIOError ( got = - 1 ) ; 
line 24237: # else 
line 24238: newOffset = lseek ( id -> h , offset , SEEK_SET ) ; 
line 24239: SimulateIOError ( newOffset -- ) ; 
line 24240: if ( newOffset != offset ) { 
line 24241: if ( newOffset == - 1 ) { 
line 24242: ( ( unixFile * ) id ) -> lastErrno = errno ; 
line 24243: } else { 
line 24244: ( ( unixFile * ) id ) -> lastErrno = 0 ; 
line 24245: } 
line 24246: return - 1 ; 
line 24247: } 
line 24248: got = read ( id -> h , pBuf , cnt ) ; 
line 24249: # endif 
line 24250: TIMER_END ; 
line 24251: if ( got < 0 ) { 
line 24252: ( ( unixFile * ) id ) -> lastErrno = errno ; 
line 24253: } 
line 24254: OSTRACE5 ( "READ    %-3d %5d %7lld %llu\n" , id -> h , got , offset , TIMER_ELAPSED ) ; 
line 24255: return got ; 
line 24256: } 
line 24263: static int unixRead ( 
line 24264: sqlite3_file * id , 
line 24265: void * pBuf , 
line 24266: int amt , 
line 24267: sqlite3_int64 offset 
line 24268: ) { 
line 24269: unixFile * pFile = ( unixFile * ) id ; 
line 24270: int got ; 
line 24271: assert ( id ) ; 
line 24275: assert ( pFile -> pUnused == 0 
line 24276: || offset >= PENDING_BYTE + 512 
line 24277: || offset + amt <= PENDING_BYTE 
line 24278: ) ; 
line 24280: got = seekAndRead ( pFile , offset , pBuf , amt ) ; 
line 24281: if ( got == amt ) { 
line 24282: return SQLITE_OK ; 
line 24283: } else if ( got < 0 ) { 
line 24285: return SQLITE_IOERR_READ ; 
line 24286: } else { 
line 24287: pFile -> lastErrno = 0 ; 
line 24289: memset ( & ( ( char * ) pBuf ) [ got ] , 0 , amt - got ) ; 
line 24290: return SQLITE_IOERR_SHORT_READ ; 
line 24291: } 
line 24292: } 
line 24301: static int seekAndWrite ( unixFile * id , i64 offset , const void * pBuf , int cnt ) { 
line 24302: int got ; 
line 24303: i64 newOffset ; 
line 24304: TIMER_START ; 
line 24305: # if defined ( USE_PREAD ) 
line 24306: got = pwrite ( id -> h , pBuf , cnt , offset ) ; 
line 24307: # elif defined ( USE_PREAD64 ) 
line 24308: got = pwrite64 ( id -> h , pBuf , cnt , offset ) ; 
line 24309: # else 
line 24310: newOffset = lseek ( id -> h , offset , SEEK_SET ) ; 
line 24311: if ( newOffset != offset ) { 
line 24312: if ( newOffset == - 1 ) { 
line 24313: ( ( unixFile * ) id ) -> lastErrno = errno ; 
line 24314: } else { 
line 24315: ( ( unixFile * ) id ) -> lastErrno = 0 ; 
line 24316: } 
line 24317: return - 1 ; 
line 24318: } 
line 24319: got = write ( id -> h , pBuf , cnt ) ; 
line 24320: # endif 
line 24321: TIMER_END ; 
line 24322: if ( got < 0 ) { 
line 24323: ( ( unixFile * ) id ) -> lastErrno = errno ; 
line 24324: } 
line 24326: OSTRACE5 ( "WRITE   %-3d %5d %7lld %llu\n" , id -> h , got , offset , TIMER_ELAPSED ) ; 
line 24327: return got ; 
line 24328: } 
line 24335: static int unixWrite ( 
line 24336: sqlite3_file * id , 
line 24337: const void * pBuf , 
line 24338: int amt , 
line 24339: sqlite3_int64 offset 
line 24340: ) { 
line 24341: unixFile * pFile = ( unixFile * ) id ; 
line 24342: int wrote = 0 ; 
line 24343: assert ( id ) ; 
line 24344: assert ( amt > 0 ) ; 
line 24348: assert ( pFile -> pUnused == 0 
line 24349: || offset >= PENDING_BYTE + 512 
line 24350: || offset + amt <= PENDING_BYTE 
line 24351: ) ; 
line 24353: # ifndef NDEBUG 
line 24360: if ( pFile -> inNormalWrite ) { 
line 24361: pFile -> dbUpdate = 1 ; 
line 24362: if ( offset <= 24 && offset + amt >= 27 ) { 
line 24363: int rc ; 
line 24364: char oldCntr [ 4 ] ; 
line 24365: SimulateIOErrorBenign ( 1 ) ; 
line 24366: rc = seekAndRead ( pFile , 24 , oldCntr , 4 ) ; 
line 24367: SimulateIOErrorBenign ( 0 ) ; 
line 24368: if ( rc != 4 || memcmp ( oldCntr , & ( ( char * ) pBuf ) [ 24 - offset ] , 4 ) != 0 ) { 
line 24369: pFile -> transCntrChng = 1 ; 
line 24370: } 
line 24371: } 
line 24372: } 
line 24373: # endif 
line 24375: while ( amt > 0 && ( wrote = seekAndWrite ( pFile , offset , pBuf , amt ) ) > 0 ) { 
line 24376: amt -= wrote ; 
line 24377: offset += wrote ; 
line 24378: pBuf = & ( ( char * ) pBuf ) [ wrote ] ; 
line 24379: } 
line 24380: SimulateIOError ( ( wrote = ( - 1 ) , amt = 1 ) ) ; 
line 24381: SimulateDiskfullError ( ( wrote = 0 , amt = 1 ) ) ; 
line 24382: if ( amt > 0 ) { 
line 24383: if ( wrote < 0 ) { 
line 24385: return SQLITE_IOERR_WRITE ; 
line 24386: } else { 
line 24387: pFile -> lastErrno = 0 ; 
line 24388: return SQLITE_FULL ; 
line 24389: } 
line 24390: } 
line 24391: return SQLITE_OK ; 
line 24392: } 
line 24394: # ifdef SQLITE_TEST 
line 24399: SQLITE_API int sqlite3_sync_count = 0 ; 
line 24400: SQLITE_API int sqlite3_fullsync_count = 0 ; 
line 24401: # endif 
line 24409: # if ! defined ( fdatasync ) && ! defined ( __linux__ ) 
line 24410: # define fdatasync fsync 
line 24411: # endif 
line 24418: # ifdef F_FULLFSYNC 
line 24419: # define HAVE_FULLFSYNC 1 
line 24420: # else 
line 24421: # define HAVE_FULLFSYNC 0 
line 24422: # endif 
line 24449: static int full_fsync ( int fd , int fullSync , int dataOnly ) { 
line 24450: int rc ; 
line 24456: # ifdef SQLITE_NO_SYNC 
line 24457: UNUSED_PARAMETER ( fd ) ; 
line 24458: UNUSED_PARAMETER ( fullSync ) ; 
line 24459: UNUSED_PARAMETER ( dataOnly ) ; 
line 24460: # elif HAVE_FULLFSYNC 
line 24461: UNUSED_PARAMETER ( dataOnly ) ; 
line 24462: # else 
line 24463: UNUSED_PARAMETER ( fullSync ) ; 
line 24464: UNUSED_PARAMETER ( dataOnly ) ; 
line 24465: # endif 
line 24471: # ifdef SQLITE_TEST 
line 24472: if ( fullSync ) sqlite3_fullsync_count ++ ; 
line 24473: sqlite3_sync_count ++ ; 
line 24474: # endif 
line 24479: # ifdef SQLITE_NO_SYNC 
line 24480: rc = SQLITE_OK ; 
line 24481: # elif HAVE_FULLFSYNC 
line 24482: if ( fullSync ) { 
line 24483: rc = fcntl ( fd , F_FULLFSYNC , 0 ) ; 
line 24484: } else { 
line 24485: rc = 1 ; 
line 24486: } 
line 24495: if ( rc ) rc = fsync ( fd ) ; 
line 24497: # else 
line 24498: rc = fdatasync ( fd ) ; 
line 24499: # if OS_VXWORKS 
line 24500: if ( rc == - 1 && errno == ENOTSUP ) { 
line 24501: rc = fsync ( fd ) ; 
line 24502: } 
line 24503: # endif 
line 24504: # endif 
line 24506: if ( OS_VXWORKS && rc != - 1 ) { 
line 24507: rc = 0 ; 
line 24508: } 
line 24509: return rc ; 
line 24510: } 
line 24527: static int unixSync ( sqlite3_file * id , int flags ) { 
line 24528: int rc ; 
line 24529: unixFile * pFile = ( unixFile * ) id ; 
line 24531: int isDataOnly = ( flags & SQLITE_SYNC_DATAONLY ) ; 
line 24532: int isFullsync = ( flags & 0x0F ) == SQLITE_SYNC_FULL ; 
line 24535: assert ( ( flags & 0x0F ) == SQLITE_SYNC_NORMAL 
line 24536: || ( flags & 0x0F ) == SQLITE_SYNC_FULL 
line 24537: ) ; 
line 24542: SimulateDiskfullError ( return SQLITE_FULL ) ; 
line 24544: assert ( pFile ) ; 
line 24545: OSTRACE2 ( "SYNC    %-3d\n" , pFile -> h ) ; 
line 24546: rc = full_fsync ( pFile -> h , isFullsync , isDataOnly ) ; 
line 24547: SimulateIOError ( rc = 1 ) ; 
line 24548: if ( rc ) { 
line 24549: pFile -> lastErrno = errno ; 
line 24550: return SQLITE_IOERR_FSYNC ; 
line 24551: } 
line 24552: if ( pFile -> dirfd >= 0 ) { 
line 24553: int err ; 
line 24554: OSTRACE4 ( "DIRSYNC %-3d (have_fullfsync=%d fullsync=%d)\n" , pFile -> dirfd , 
line 24555: HAVE_FULLFSYNC , isFullsync ) ; 
line 24556: # ifndef SQLITE_DISABLE_DIRSYNC 
line 24561: if ( ( ! HAVE_FULLFSYNC || ! isFullsync ) && full_fsync ( pFile -> dirfd , 0 , 0 ) ) { 
line 24570: } 
line 24571: # endif 
line 24572: err = close ( pFile -> dirfd ) ; 
line 24573: if ( err == 0 ) { 
line 24574: pFile -> dirfd = - 1 ; 
line 24575: } else { 
line 24576: pFile -> lastErrno = errno ; 
line 24577: rc = SQLITE_IOERR_DIR_CLOSE ; 
line 24578: } 
line 24579: } 
line 24580: return rc ; 
line 24581: } 
line 24586: static int unixTruncate ( sqlite3_file * id , i64 nByte ) { 
line 24587: int rc ; 
line 24588: assert ( id ) ; 
line 24589: SimulateIOError ( return SQLITE_IOERR_TRUNCATE ) ; 
line 24590: rc = ftruncate ( ( ( unixFile * ) id ) -> h , ( off_t ) nByte ) ; 
line 24591: if ( rc ) { 
line 24592: ( ( unixFile * ) id ) -> lastErrno = errno ; 
line 24593: return SQLITE_IOERR_TRUNCATE ; 
line 24594: } else { 
line 24595: # ifndef NDEBUG 
line 24603: if ( ( ( unixFile * ) id ) -> inNormalWrite && nByte == 0 ) { 
line 24604: ( ( unixFile * ) id ) -> transCntrChng = 1 ; 
line 24605: } 
line 24606: # endif 
line 24608: return SQLITE_OK ; 
line 24609: } 
line 24610: } 
line 24615: static int unixFileSize ( sqlite3_file * id , i64 * pSize ) { 
line 24616: int rc ; 
line 24617: struct stat buf ; 
line 24618: assert ( id ) ; 
line 24619: rc = fstat ( ( ( unixFile * ) id ) -> h , & buf ) ; 
line 24620: SimulateIOError ( rc = 1 ) ; 
line 24621: if ( rc != 0 ) { 
line 24622: ( ( unixFile * ) id ) -> lastErrno = errno ; 
line 24623: return SQLITE_IOERR_FSTAT ; 
line 24624: } 
line 24625: * pSize = buf . st_size ; 
line 24633: if ( * pSize == 1 ) * pSize = 0 ; 
line 24636: return SQLITE_OK ; 
line 24637: } 
line 24639: # if SQLITE_ENABLE_LOCKING_STYLE && defined ( __APPLE__ ) 
line 24644: static int proxyFileControl ( sqlite3_file * , int , void * ) ; 
line 24645: # endif 
line 24651: static int unixFileControl ( sqlite3_file * id , int op , void * pArg ) { 
line 24652: switch ( op ) { 
line 24653: case SQLITE_FCNTL_LOCKSTATE : { 
line 24654: * ( int * ) pArg = ( ( unixFile * ) id ) -> locktype ; 
line 24655: return SQLITE_OK ; 
line 24656: } 
line 24657: case SQLITE_LAST_ERRNO : { 
line 24658: * ( int * ) pArg = ( ( unixFile * ) id ) -> lastErrno ; 
line 24659: return SQLITE_OK ; 
line 24660: } 
line 24661: # ifndef NDEBUG 
line 24667: case SQLITE_FCNTL_DB_UNCHANGED : { 
line 24668: ( ( unixFile * ) id ) -> dbUpdate = 0 ; 
line 24669: return SQLITE_OK ; 
line 24670: } 
line 24671: # endif 
line 24672: # if SQLITE_ENABLE_LOCKING_STYLE && defined ( __APPLE__ ) 
line 24673: case SQLITE_SET_LOCKPROXYFILE : 
line 24674: case SQLITE_GET_LOCKPROXYFILE : { 
line 24675: return proxyFileControl ( id , op , pArg ) ; 
line 24676: } 
line 24677: # endif 
line 24678: } 
line 24679: return SQLITE_ERROR ; 
line 24680: } 
line 24692: static int unixSectorSize ( sqlite3_file * NotUsed ) { 
line 24693: UNUSED_PARAMETER ( NotUsed ) ; 
line 24694: return SQLITE_DEFAULT_SECTOR_SIZE ; 
line 24695: } 
line 24700: static int unixDeviceCharacteristics ( sqlite3_file * NotUsed ) { 
line 24701: UNUSED_PARAMETER ( NotUsed ) ; 
line 24702: return 0 ; 
line 24703: } 
line 24745: # define IOMETHODS ( FINDER , METHOD , CLOSE , LOCK , UNLOCK , CKLOCK ) 
line 24746: static const sqlite3_io_methods METHOD = { 
line 24747: 1 , 
line 24748: CLOSE , 
line 24749: unixRead , 
line 24750: unixWrite , 
line 24751: unixTruncate , 
line 24752: unixSync , 
line 24753: unixFileSize , 
line 24754: LOCK , 
line 24755: UNLOCK , 
line 24756: CKLOCK , 
line 24757: unixFileControl , 
line 24758: unixSectorSize , 
line 24759: unixDeviceCharacteristics 
line 24760: } ; 
line 24761: static const sqlite3_io_methods * FINDER ## Impl ( const char * z , unixFile * p ) { 
line 24762: UNUSED_PARAMETER ( z ) ; UNUSED_PARAMETER ( p ) ; 
line 24763: return & METHOD ; 
line 24764: } 
line 24765: static const sqlite3_io_methods * ( * const FINDER ) ( const char * , unixFile * p ) 
line 24766: = FINDER ## Impl ; 
line 24773: IOMETHODS ( 
line 24774: posixIoFinder , 
line 24775: posixIoMethods , 
line 24776: unixClose , 
line 24777: unixLock , 
line 24778: unixUnlock , 
line 24779: unixCheckReservedLock 
line 24780: ) 
line 24781: IOMETHODS ( 
line 24782: nolockIoFinder , 
line 24783: nolockIoMethods , 
line 24784: nolockClose , 
line 24785: nolockLock , 
line 24786: nolockUnlock , 
line 24787: nolockCheckReservedLock 
line 24788: ) 
line 24789: IOMETHODS ( 
line 24790: dotlockIoFinder , 
line 24791: dotlockIoMethods , 
line 24792: dotlockClose , 
line 24793: dotlockLock , 
line 24794: dotlockUnlock , 
line 24795: dotlockCheckReservedLock 
line 24796: ) 
line 24798: # if SQLITE_ENABLE_LOCKING_STYLE && ! OS_VXWORKS 
line 24799: IOMETHODS ( 
line 24800: flockIoFinder , 
line 24801: flockIoMethods , 
line 24802: flockClose , 
line 24803: flockLock , 
line 24804: flockUnlock , 
line 24805: flockCheckReservedLock 
line 24806: ) 
line 24807: # endif 
line 24809: # if OS_VXWORKS 
line 24810: IOMETHODS ( 
line 24811: semIoFinder , 
line 24812: semIoMethods , 
line 24813: semClose , 
line 24814: semLock , 
line 24815: semUnlock , 
line 24816: semCheckReservedLock 
line 24817: ) 
line 24818: # endif 
line 24820: # if defined ( __APPLE__ ) && SQLITE_ENABLE_LOCKING_STYLE 
line 24821: IOMETHODS ( 
line 24822: afpIoFinder , 
line 24823: afpIoMethods , 
line 24824: afpClose , 
line 24825: afpLock , 
line 24826: afpUnlock , 
line 24827: afpCheckReservedLock 
line 24828: ) 
line 24829: # endif 
line 24840: static const sqlite3_io_methods * posixWflIoFinderImpl ( const char * z , unixFile * p ) { 
line 24841: UNUSED_PARAMETER ( z ) ; 
line 24842: p -> fileFlags = SQLITE_WHOLE_FILE_LOCKING ; 
line 24843: return & posixIoMethods ; 
line 24844: } 
line 24845: static const sqlite3_io_methods 
line 24846: * ( * const posixWflIoFinder ) ( const char * , unixFile * p ) = posixWflIoFinderImpl ; 
line 24857: # if defined ( __APPLE__ ) && SQLITE_ENABLE_LOCKING_STYLE 
line 24858: static int proxyClose ( sqlite3_file * ) ; 
line 24859: static int proxyLock ( sqlite3_file * , int ) ; 
line 24860: static int proxyUnlock ( sqlite3_file * , int ) ; 
line 24861: static int proxyCheckReservedLock ( sqlite3_file * , int * ) ; 
line 24862: IOMETHODS ( 
line 24863: proxyIoFinder , 
line 24864: proxyIoMethods , 
line 24865: proxyClose , 
line 24866: proxyLock , 
line 24867: proxyUnlock , 
line 24868: proxyCheckReservedLock 
line 24869: ) 
line 24870: # endif 
line 24873: # if defined ( __APPLE__ ) && SQLITE_ENABLE_LOCKING_STYLE 
line 24881: static const sqlite3_io_methods * autolockIoFinderImpl ( 
line 24882: const char * filePath , 
line 24883: unixFile * pNew 
line 24884: ) { 
line 24885: static const struct Mapping { 
line 24886: const char * zFilesystem ; 
line 24887: const sqlite3_io_methods * pMethods ; 
line 24888: } aMap [ ] = { 
line 24889: { "hfs" , & posixIoMethods } , 
line 24890: { "ufs" , & posixIoMethods } , 
line 24891: { "afpfs" , & afpIoMethods } , 
line 24892: # ifdef SQLITE_ENABLE_AFP_LOCKING_SMB 
line 24893: { "smbfs" , & afpIoMethods } , 
line 24894: # else 
line 24895: { "smbfs" , & flockIoMethods } , 
line 24896: # endif 
line 24897: { "webdav" , & nolockIoMethods } , 
line 24898: { 0 , 0 } 
line 24899: } ; 
line 24900: int i ; 
line 24901: struct statfs fsInfo ; 
line 24902: struct flock lockInfo ; 
line 24904: if ( ! filePath ) { 
line 24907: return & nolockIoMethods ; 
line 24908: } 
line 24909: if ( statfs ( filePath , & fsInfo ) != - 1 ) { 
line 24910: if ( fsInfo . f_flags & MNT_RDONLY ) { 
line 24911: return & nolockIoMethods ; 
line 24912: } 
line 24913: for ( i = 0 ; aMap [ i ] . zFilesystem ; i ++ ) { 
line 24914: if ( strcmp ( fsInfo . f_fstypename , aMap [ i ] . zFilesystem ) == 0 ) { 
line 24915: return aMap [ i ] . pMethods ; 
line 24916: } 
line 24917: } 
line 24918: } 
line 24924: lockInfo . l_len = 1 ; 
line 24925: lockInfo . l_start = 0 ; 
line 24926: lockInfo . l_whence = SEEK_SET ; 
line 24927: lockInfo . l_type = F_RDLCK ; 
line 24928: if ( fcntl ( pNew -> h , F_GETLK , & lockInfo ) != - 1 ) { 
line 24929: pNew -> fileFlags = SQLITE_WHOLE_FILE_LOCKING ; 
line 24930: return & posixIoMethods ; 
line 24931: } else { 
line 24932: return & dotlockIoMethods ; 
line 24933: } 
line 24934: } 
line 24935: static const sqlite3_io_methods 
line 24936: * ( * const autolockIoFinder ) ( const char * , unixFile * ) = autolockIoFinderImpl ; 
line 24938: # endif 
line 24940: # if OS_VXWORKS && SQLITE_ENABLE_LOCKING_STYLE 
line 24948: static const sqlite3_io_methods * autolockIoFinderImpl ( 
line 24949: const char * filePath , 
line 24950: unixFile * pNew 
line 24951: ) { 
line 24952: struct flock lockInfo ; 
line 24954: if ( ! filePath ) { 
line 24957: return & nolockIoMethods ; 
line 24958: } 
line 24963: lockInfo . l_len = 1 ; 
line 24964: lockInfo . l_start = 0 ; 
line 24965: lockInfo . l_whence = SEEK_SET ; 
line 24966: lockInfo . l_type = F_RDLCK ; 
line 24967: if ( fcntl ( pNew -> h , F_GETLK , & lockInfo ) != - 1 ) { 
line 24968: return & posixIoMethods ; 
line 24969: } else { 
line 24970: return & semIoMethods ; 
line 24971: } 
line 24972: } 
line 24973: static const sqlite3_io_methods 
line 24974: * ( * const autolockIoFinder ) ( const char * , unixFile * ) = autolockIoFinderImpl ; 
line 24976: # endif 
line 24981: typedef const sqlite3_io_methods * ( * finder_type ) ( const char * , unixFile * ) ; 
line 24994: static int fillInUnixFile ( 
line 24995: sqlite3_vfs * pVfs , 
line 24996: int h , 
line 24997: int dirfd , 
line 24998: sqlite3_file * pId , 
line 24999: const char * zFilename , 
line 25000: int noLock , 
line 25001: int isDelete 
line 25002: ) { 
line 25003: const sqlite3_io_methods * pLockingStyle ; 
line 25004: unixFile * pNew = ( unixFile * ) pId ; 
line 25005: int rc = SQLITE_OK ; 
line 25007: assert ( pNew -> pLock == NULL ) ; 
line 25008: assert ( pNew -> pOpen == NULL ) ; 
line 25013: UNUSED_PARAMETER ( isDelete ) ; 
line 25015: OSTRACE3 ( "OPEN    %-3d %s\n" , h , zFilename ) ; 
line 25016: pNew -> h = h ; 
line 25017: pNew -> dirfd = dirfd ; 
line 25018: SET_THREADID ( pNew ) ; 
line 25019: pNew -> fileFlags = 0 ; 
line 25021: # if OS_VXWORKS 
line 25022: pNew -> pId = vxworksFindFileId ( zFilename ) ; 
line 25023: if ( pNew -> pId == 0 ) { 
line 25024: noLock = 1 ; 
line 25025: rc = SQLITE_NOMEM ; 
line 25026: } 
line 25027: # endif 
line 25029: if ( noLock ) { 
line 25030: pLockingStyle = & nolockIoMethods ; 
line 25031: } else { 
line 25032: pLockingStyle = ( * * ( finder_type * ) pVfs -> pAppData ) ( zFilename , pNew ) ; 
line 25033: # if SQLITE_ENABLE_LOCKING_STYLE 
line 25037: pNew -> lockingContext = ( void * ) zFilename ; 
line 25038: # endif 
line 25039: } 
line 25041: if ( pLockingStyle == & posixIoMethods ) { 
line 25042: unixEnterMutex ( ) ; 
line 25043: rc = findLockInfo ( pNew , & pNew -> pLock , & pNew -> pOpen ) ; 
line 25044: if ( rc != SQLITE_OK ) { 
line 25063: close ( h ) ; 
line 25064: h = - 1 ; 
line 25065: } 
line 25066: unixLeaveMutex ( ) ; 
line 25067: } 
line 25069: # if SQLITE_ENABLE_LOCKING_STYLE && defined ( __APPLE__ ) 
line 25070: else if ( pLockingStyle == & afpIoMethods ) { 
line 25074: afpLockingContext * pCtx ; 
line 25075: pNew -> lockingContext = pCtx = sqlite3_malloc ( sizeof ( * pCtx ) ) ; 
line 25076: if ( pCtx == 0 ) { 
line 25077: rc = SQLITE_NOMEM ; 
line 25078: } else { 
line 25082: pCtx -> dbPath = zFilename ; 
line 25083: srandomdev ( ) ; 
line 25084: unixEnterMutex ( ) ; 
line 25085: rc = findLockInfo ( pNew , NULL , & pNew -> pOpen ) ; 
line 25086: unixLeaveMutex ( ) ; 
line 25087: } 
line 25088: } 
line 25089: # endif 
line 25091: else if ( pLockingStyle == & dotlockIoMethods ) { 
line 25095: char * zLockFile ; 
line 25096: int nFilename ; 
line 25097: nFilename = ( int ) strlen ( zFilename ) + 6 ; 
line 25098: zLockFile = ( char * ) sqlite3_malloc ( nFilename ) ; 
line 25099: if ( zLockFile == 0 ) { 
line 25100: rc = SQLITE_NOMEM ; 
line 25101: } else { 
line 25102: sqlite3_snprintf ( nFilename , zLockFile , "%s" DOTLOCK_SUFFIX , zFilename ) ; 
line 25103: } 
line 25104: pNew -> lockingContext = zLockFile ; 
line 25105: } 
line 25107: # if OS_VXWORKS 
line 25108: else if ( pLockingStyle == & semIoMethods ) { 
line 25112: unixEnterMutex ( ) ; 
line 25113: rc = findLockInfo ( pNew , & pNew -> pLock , & pNew -> pOpen ) ; 
line 25114: if ( ( rc == SQLITE_OK ) && ( pNew -> pOpen -> pSem == NULL ) ) { 
line 25115: char * zSemName = pNew -> pOpen -> aSemName ; 
line 25116: int n ; 
line 25117: sqlite3_snprintf ( MAX_PATHNAME , zSemName , "/%s.sem" , 
line 25118: pNew -> pId -> zCanonicalName ) ; 
line 25119: for ( n = 1 ; zSemName [ n ] ; n ++ ) 
line 25120: if ( zSemName [ n ] == '/' ) zSemName [ n ] = '_' ; 
line 25121: pNew -> pOpen -> pSem = sem_open ( zSemName , O_CREAT , 0666 , 1 ) ; 
line 25122: if ( pNew -> pOpen -> pSem == SEM_FAILED ) { 
line 25123: rc = SQLITE_NOMEM ; 
line 25124: pNew -> pOpen -> aSemName [ 0 ] = '\0' ; 
line 25125: } 
line 25126: } 
line 25127: unixLeaveMutex ( ) ; 
line 25128: } 
line 25129: # endif 
line 25131: pNew -> lastErrno = 0 ; 
line 25132: # if OS_VXWORKS 
line 25133: if ( rc != SQLITE_OK ) { 
line 25134: unlink ( zFilename ) ; 
line 25135: isDelete = 0 ; 
line 25136: } 
line 25137: pNew -> isDelete = isDelete ; 
line 25138: # endif 
line 25139: if ( rc != SQLITE_OK ) { 
line 25140: if ( dirfd >= 0 ) close ( dirfd ) ; 
line 25141: if ( h >= 0 ) close ( h ) ; 
line 25142: } else { 
line 25143: pNew -> pMethod = pLockingStyle ; 
line 25144: OpenCounter ( + 1 ) ; 
line 25145: } 
line 25146: return rc ; 
line 25147: } 
line 25159: static int openDirectory ( const char * zFilename , int * pFd ) { 
line 25160: int ii ; 
line 25161: int fd = - 1 ; 
line 25162: char zDirname [ MAX_PATHNAME + 1 ] ; 
line 25164: sqlite3_snprintf ( MAX_PATHNAME , zDirname , "%s" , zFilename ) ; 
line 25165: for ( ii = ( int ) strlen ( zDirname ) ; ii > 1 && zDirname [ ii ] != '/' ; ii -- ) ; 
line 25166: if ( ii > 0 ) { 
line 25167: zDirname [ ii ] = '\0' ; 
line 25168: fd = open ( zDirname , O_RDONLY | O_BINARY , 0 ) ; 
line 25169: if ( fd >= 0 ) { 
line 25170: # ifdef FD_CLOEXEC 
line 25171: fcntl ( fd , F_SETFD , fcntl ( fd , F_GETFD , 0 ) | FD_CLOEXEC ) ; 
line 25172: # endif 
line 25173: OSTRACE3 ( "OPENDIR %-3d %s\n" , fd , zDirname ) ; 
line 25174: } 
line 25175: } 
line 25176: * pFd = fd ; 
line 25177: return ( fd >= 0 ? SQLITE_OK : SQLITE_CANTOPEN ) ; 
line 25178: } 
line 25185: static int getTempname ( int nBuf , char * zBuf ) { 
line 25186: static const char * azDirs [ ] = { 
line 25187: 0 , 
line 25188: 0 , 
line 25189: "/var/tmp" , 
line 25190: "/usr/tmp" , 
line 25191: "/tmp" , 
line 25192: "." , 
line 25193: } ; 
line 25194: static const unsigned char zChars [ ] = 
line 25195: "abcdefghijklmnopqrstuvwxyz" 
line 25196: "ABCDEFGHIJKLMNOPQRSTUVWXYZ" 
line 25197: "0123456789" ; 
line 25198: unsigned int i , j ; 
line 25199: struct stat buf ; 
line 25200: const char * zDir = "." ; 
line 25206: SimulateIOError ( return SQLITE_IOERR ) ; 
line 25208: azDirs [ 0 ] = sqlite3_temp_directory ; 
line 25209: if ( NULL == azDirs [ 1 ] ) { 
line 25210: azDirs [ 1 ] = getenv ( "TMPDIR" ) ; 
line 25211: } 
line 25213: for ( i = 0 ; i < sizeof ( azDirs ) / sizeof ( azDirs [ 0 ] ) ; i ++ ) { 
line 25214: if ( azDirs [ i ] == 0 ) continue ; 
line 25215: if ( stat ( azDirs [ i ] , & buf ) ) continue ; 
line 25216: if ( ! S_ISDIR ( buf . st_mode ) ) continue ; 
line 25217: if ( access ( azDirs [ i ] , 07 ) ) continue ; 
line 25218: zDir = azDirs [ i ] ; 
line 25219: break ; 
line 25220: } 
line 25225: if ( ( strlen ( zDir ) + strlen ( SQLITE_TEMP_FILE_PREFIX ) + 17 ) >= ( size_t ) nBuf ) { 
line 25226: return SQLITE_ERROR ; 
line 25227: } 
line 25229: do { 
line 25230: sqlite3_snprintf ( nBuf - 17 , zBuf , "%s/" SQLITE_TEMP_FILE_PREFIX , zDir ) ; 
line 25231: j = ( int ) strlen ( zBuf ) ; 
line 25232: sqlite3_randomness ( 15 , & zBuf [ j ] ) ; 
line 25233: for ( i = 0 ; i < 15 ; i ++ , j ++ ) { 
line 25234: zBuf [ j ] = ( char ) zChars [ ( ( unsigned char ) zBuf [ j ] ) % ( sizeof ( zChars ) - 1 ) ] ; 
line 25235: } 
line 25236: zBuf [ j ] = 0 ; 
line 25237: } while ( access ( zBuf , 0 ) == 0 ) ; 
line 25238: return SQLITE_OK ; 
line 25239: } 
line 25241: # if SQLITE_ENABLE_LOCKING_STYLE && defined ( __APPLE__ ) 
line 25247: static int proxyTransformUnixFile ( unixFile * , const char * ) ; 
line 25248: # endif 
line 25266: static UnixUnusedFd * findReusableFd ( const char * zPath , int flags ) { 
line 25267: UnixUnusedFd * pUnused = 0 ; 
line 25274: # if ! OS_VXWORKS 
line 25275: struct stat sStat ; 
line 25285: if ( 0 == stat ( zPath , & sStat ) ) { 
line 25286: struct unixOpenCnt * pOpen ; 
line 25288: unixEnterMutex ( ) ; 
line 25289: pOpen = openList ; 
line 25290: while ( pOpen && ( pOpen -> fileId . dev != sStat . st_dev 
line 25291: || pOpen -> fileId . ino != sStat . st_ino ) ) { 
line 25292: pOpen = pOpen -> pNext ; 
line 25293: } 
line 25294: if ( pOpen ) { 
line 25295: UnixUnusedFd * * pp ; 
line 25296: for ( pp = & pOpen -> pUnused ; * pp && ( * pp ) -> flags != flags ; pp = & ( ( * pp ) -> pNext ) ) ; 
line 25297: pUnused = * pp ; 
line 25298: if ( pUnused ) { 
line 25299: * pp = pUnused -> pNext ; 
line 25300: } 
line 25301: } 
line 25302: unixLeaveMutex ( ) ; 
line 25303: } 
line 25304: # endif 
line 25305: return pUnused ; 
line 25306: } 
line 25330: static int unixOpen ( 
line 25331: sqlite3_vfs * pVfs , 
line 25332: const char * zPath , 
line 25333: sqlite3_file * pFile , 
line 25334: int flags , 
line 25335: int * pOutFlags 
line 25336: ) { 
line 25337: unixFile * p = ( unixFile * ) pFile ; 
line 25338: int fd = - 1 ; 
line 25339: int dirfd = - 1 ; 
line 25340: int openFlags = 0 ; 
line 25341: int eType = flags & 0xFFFFFF00 ; 
line 25342: int noLock ; 
line 25343: int rc = SQLITE_OK ; 
line 25345: int isExclusive = ( flags & SQLITE_OPEN_EXCLUSIVE ) ; 
line 25346: int isDelete = ( flags & SQLITE_OPEN_DELETEONCLOSE ) ; 
line 25347: int isCreate = ( flags & SQLITE_OPEN_CREATE ) ; 
line 25348: int isReadonly = ( flags & SQLITE_OPEN_READONLY ) ; 
line 25349: int isReadWrite = ( flags & SQLITE_OPEN_READWRITE ) ; 
line 25355: int isOpenDirectory = ( isCreate && 
line 25356: ( eType == SQLITE_OPEN_MASTER_JOURNAL || eType == SQLITE_OPEN_MAIN_JOURNAL ) 
line 25357: ) ; 
line 25362: char zTmpname [ MAX_PATHNAME + 1 ] ; 
line 25363: const char * zName = zPath ; 
line 25372: assert ( ( isReadonly == 0 || isReadWrite == 0 ) && ( isReadWrite || isReadonly ) ) ; 
line 25373: assert ( isCreate == 0 || isReadWrite ) ; 
line 25374: assert ( isExclusive == 0 || isCreate ) ; 
line 25375: assert ( isDelete == 0 || isCreate ) ; 
line 25379: assert ( ( ! isDelete && zName ) || eType != SQLITE_OPEN_MAIN_DB ) ; 
line 25380: assert ( ( ! isDelete && zName ) || eType != SQLITE_OPEN_MAIN_JOURNAL ) ; 
line 25381: assert ( ( ! isDelete && zName ) || eType != SQLITE_OPEN_MASTER_JOURNAL ) ; 
line 25384: assert ( eType == SQLITE_OPEN_MAIN_DB || eType == SQLITE_OPEN_TEMP_DB 
line 25385: || eType == SQLITE_OPEN_MAIN_JOURNAL || eType == SQLITE_OPEN_TEMP_JOURNAL 
line 25386: || eType == SQLITE_OPEN_SUBJOURNAL || eType == SQLITE_OPEN_MASTER_JOURNAL 
line 25387: || eType == SQLITE_OPEN_TRANSIENT_DB 
line 25388: ) ; 
line 25390: memset ( p , 0 , sizeof ( unixFile ) ) ; 
line 25392: if ( eType == SQLITE_OPEN_MAIN_DB ) { 
line 25393: UnixUnusedFd * pUnused ; 
line 25394: pUnused = findReusableFd ( zName , flags ) ; 
line 25395: if ( pUnused ) { 
line 25396: fd = pUnused -> fd ; 
line 25397: } else { 
line 25398: pUnused = sqlite3_malloc ( sizeof ( * pUnused ) ) ; 
line 25399: if ( ! pUnused ) { 
line 25400: return SQLITE_NOMEM ; 
line 25401: } 
line 25402: } 
line 25403: p -> pUnused = pUnused ; 
line 25404: } else if ( ! zName ) { 
line 25406: assert ( isDelete && ! isOpenDirectory ) ; 
line 25407: rc = getTempname ( MAX_PATHNAME + 1 , zTmpname ) ; 
line 25408: if ( rc != SQLITE_OK ) { 
line 25409: return rc ; 
line 25410: } 
line 25411: zName = zTmpname ; 
line 25412: } 
line 25418: if ( isReadonly ) openFlags |= O_RDONLY ; 
line 25419: if ( isReadWrite ) openFlags |= O_RDWR ; 
line 25420: if ( isCreate ) openFlags |= O_CREAT ; 
line 25421: if ( isExclusive ) openFlags |= ( O_EXCL | O_NOFOLLOW ) ; 
line 25422: openFlags |= ( O_LARGEFILE | O_BINARY ) ; 
line 25424: if ( fd < 0 ) { 
line 25425: mode_t openMode = ( isDelete ? 0600 : SQLITE_DEFAULT_FILE_PERMISSIONS ) ; 
line 25426: fd = open ( zName , openFlags , openMode ) ; 
line 25427: OSTRACE4 ( "OPENX   %-3d %s 0%o\n" , fd , zName , openFlags ) ; 
line 25428: if ( fd < 0 && errno != EISDIR && isReadWrite && ! isExclusive ) { 
line 25430: flags &= ~ ( SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE ) ; 
line 25431: openFlags &= ~ ( O_RDWR | O_CREAT ) ; 
line 25432: flags |= SQLITE_OPEN_READONLY ; 
line 25433: openFlags |= O_RDONLY ; 
line 25434: fd = open ( zName , openFlags , openMode ) ; 
line 25435: } 
line 25436: if ( fd < 0 ) { 
line 25437: rc = SQLITE_CANTOPEN ; 
line 25438: goto open_finished ; 
line 25439: } 
line 25440: } 
line 25441: assert ( fd >= 0 ) ; 
line 25442: if ( pOutFlags ) { 
line 25443: * pOutFlags = flags ; 
line 25444: } 
line 25446: if ( p -> pUnused ) { 
line 25447: p -> pUnused -> fd = fd ; 
line 25448: p -> pUnused -> flags = flags ; 
line 25449: } 
line 25451: if ( isDelete ) { 
line 25452: # if OS_VXWORKS 
line 25453: zPath = zName ; 
line 25454: # else 
line 25455: unlink ( zName ) ; 
line 25456: # endif 
line 25457: } 
line 25458: # if SQLITE_ENABLE_LOCKING_STYLE 
line 25459: else { 
line 25460: p -> openFlags = openFlags ; 
line 25461: } 
line 25462: # endif 
line 25464: if ( isOpenDirectory ) { 
line 25465: rc = openDirectory ( zPath , & dirfd ) ; 
line 25466: if ( rc != SQLITE_OK ) { 
line 25471: assert ( eType != SQLITE_OPEN_MAIN_DB ) ; 
line 25472: close ( fd ) ; 
line 25473: goto open_finished ; 
line 25474: } 
line 25475: } 
line 25477: # ifdef FD_CLOEXEC 
line 25478: fcntl ( fd , F_SETFD , fcntl ( fd , F_GETFD , 0 ) | FD_CLOEXEC ) ; 
line 25479: # endif 
line 25481: noLock = eType != SQLITE_OPEN_MAIN_DB ; 
line 25483: # if SQLITE_PREFER_PROXY_LOCKING 
line 25484: if ( zPath != NULL && ! noLock && pVfs -> xOpen ) { 
line 25485: char * envforce = getenv ( "SQLITE_FORCE_PROXY_LOCKING" ) ; 
line 25486: int useProxy = 0 ; 
line 25490: if ( envforce != NULL ) { 
line 25491: useProxy = atoi ( envforce ) > 0 ; 
line 25492: } else { 
line 25493: struct statfs fsInfo ; 
line 25494: if ( statfs ( zPath , & fsInfo ) == - 1 ) { 
line 25502: p -> lastErrno = errno ; 
line 25503: if ( dirfd >= 0 ) { 
line 25504: close ( dirfd ) ; 
line 25505: } 
line 25506: close ( fd ) ; 
line 25507: rc = SQLITE_IOERR_ACCESS ; 
line 25508: goto open_finished ; 
line 25509: } 
line 25510: useProxy = ! ( fsInfo . f_flags & MNT_LOCAL ) ; 
line 25511: } 
line 25512: if ( useProxy ) { 
line 25513: rc = fillInUnixFile ( pVfs , fd , dirfd , pFile , zPath , noLock , isDelete ) ; 
line 25514: if ( rc == SQLITE_OK ) { 
line 25515: rc = proxyTransformUnixFile ( ( unixFile * ) pFile , ":auto:" ) ; 
line 25516: } 
line 25517: goto open_finished ; 
line 25518: } 
line 25519: } 
line 25520: # endif 
line 25522: rc = fillInUnixFile ( pVfs , fd , dirfd , pFile , zPath , noLock , isDelete ) ; 
line 25523: open_finished : 
line 25524: if ( rc != SQLITE_OK ) { 
line 25525: sqlite3_free ( p -> pUnused ) ; 
line 25526: } 
line 25527: return rc ; 
line 25528: } 
line 25535: static int unixDelete ( 
line 25536: sqlite3_vfs * NotUsed , 
line 25537: const char * zPath , 
line 25538: int dirSync 
line 25539: ) { 
line 25540: int rc = SQLITE_OK ; 
line 25541: UNUSED_PARAMETER ( NotUsed ) ; 
line 25542: SimulateIOError ( return SQLITE_IOERR_DELETE ) ; 
line 25543: unlink ( zPath ) ; 
line 25544: # ifndef SQLITE_DISABLE_DIRSYNC 
line 25545: if ( dirSync ) { 
line 25546: int fd ; 
line 25547: rc = openDirectory ( zPath , & fd ) ; 
line 25548: if ( rc == SQLITE_OK ) { 
line 25549: # if OS_VXWORKS 
line 25550: if ( fsync ( fd ) == - 1 ) 
line 25551: # else 
line 25552: if ( fsync ( fd ) ) 
line 25553: # endif 
line 25554: { 
line 25555: rc = SQLITE_IOERR_DIR_FSYNC ; 
line 25556: } 
line 25557: if ( close ( fd ) && ! rc ) { 
line 25558: rc = SQLITE_IOERR_DIR_CLOSE ; 
line 25559: } 
line 25560: } 
line 25561: } 
line 25562: # endif 
line 25563: return rc ; 
line 25564: } 
line 25576: static int unixAccess ( 
line 25577: sqlite3_vfs * NotUsed , 
line 25578: const char * zPath , 
line 25579: int flags , 
line 25580: int * pResOut 
line 25581: ) { 
line 25582: int amode = 0 ; 
line 25583: UNUSED_PARAMETER ( NotUsed ) ; 
line 25584: SimulateIOError ( return SQLITE_IOERR_ACCESS ; ) ; 
line 25585: switch ( flags ) { 
line 25586: case SQLITE_ACCESS_EXISTS : 
line 25587: amode = F_OK ; 
line 25588: break ; 
line 25589: case SQLITE_ACCESS_READWRITE : 
line 25590: amode = W_OK | R_OK ; 
line 25591: break ; 
line 25592: case SQLITE_ACCESS_READ : 
line 25593: amode = R_OK ; 
line 25594: break ; 
line 25596: default : 
line 25597: assert ( ! "Invalid flags argument" ) ; 
line 25598: } 
line 25599: * pResOut = ( access ( zPath , amode ) == 0 ) ; 
line 25600: return SQLITE_OK ; 
line 25601: } 
line 25613: static int unixFullPathname ( 
line 25614: sqlite3_vfs * pVfs , 
line 25615: const char * zPath , 
line 25616: int nOut , 
line 25617: char * zOut 
line 25618: ) { 
line 25625: SimulateIOError ( return SQLITE_ERROR ) ; 
line 25627: assert ( pVfs -> mxPathname == MAX_PATHNAME ) ; 
line 25628: UNUSED_PARAMETER ( pVfs ) ; 
line 25630: zOut [ nOut - 1 ] = '\0' ; 
line 25631: if ( zPath [ 0 ] == '/' ) { 
line 25632: sqlite3_snprintf ( nOut , zOut , "%s" , zPath ) ; 
line 25633: } else { 
line 25634: int nCwd ; 
line 25635: if ( getcwd ( zOut , nOut - 1 ) == 0 ) { 
line 25636: return SQLITE_CANTOPEN ; 
line 25637: } 
line 25638: nCwd = ( int ) strlen ( zOut ) ; 
line 25639: sqlite3_snprintf ( nOut - nCwd , & zOut [ nCwd ] , "/%s" , zPath ) ; 
line 25640: } 
line 25641: return SQLITE_OK ; 
line 25642: } 
line 25645: # ifndef SQLITE_OMIT_LOAD_EXTENSION 
line 25650: # include < dlfcn . h > 
line 25651: static void * unixDlOpen ( sqlite3_vfs * NotUsed , const char * zFilename ) { 
line 25652: UNUSED_PARAMETER ( NotUsed ) ; 
line 25653: return dlopen ( zFilename , RTLD_NOW | RTLD_GLOBAL ) ; 
line 25654: } 
line 25663: static void unixDlError ( sqlite3_vfs * NotUsed , int nBuf , char * zBufOut ) { 
line 25664: char * zErr ; 
line 25665: UNUSED_PARAMETER ( NotUsed ) ; 
line 25666: unixEnterMutex ( ) ; 
line 25667: zErr = dlerror ( ) ; 
line 25668: if ( zErr ) { 
line 25669: sqlite3_snprintf ( nBuf , zBufOut , "%s" , zErr ) ; 
line 25670: } 
line 25671: unixLeaveMutex ( ) ; 
line 25672: } 
line 25673: static void ( * unixDlSym ( sqlite3_vfs * NotUsed , void * p , const char * zSym ) ) ( void ) { 
line 25691: void ( * ( * x ) ( void * , const char * ) ) ( void ) ; 
line 25692: UNUSED_PARAMETER ( NotUsed ) ; 
line 25693: x = ( void ( * ( * ) ( void * , const char * ) ) ( void ) ) dlsym ; 
line 25694: return ( * x ) ( p , zSym ) ; 
line 25695: } 
line 25696: static void unixDlClose ( sqlite3_vfs * NotUsed , void * pHandle ) { 
line 25697: UNUSED_PARAMETER ( NotUsed ) ; 
line 25698: dlclose ( pHandle ) ; 
line 25699: } 
line 25700: # else 
line 25701: # define unixDlOpen 0 
line 25702: # define unixDlError 0 
line 25703: # define unixDlSym 0 
line 25704: # define unixDlClose 0 
line 25705: # endif 
line 25710: static int unixRandomness ( sqlite3_vfs * NotUsed , int nBuf , char * zBuf ) { 
line 25711: UNUSED_PARAMETER ( NotUsed ) ; 
line 25712: assert ( ( size_t ) nBuf >= ( sizeof ( time_t ) + sizeof ( int ) ) ) ; 
line 25726: memset ( zBuf , 0 , nBuf ) ; 
line 25727: # if ! defined ( SQLITE_TEST ) 
line 25728: { 
line 25729: int pid , fd ; 
line 25730: fd = open ( "/dev/urandom" , O_RDONLY ) ; 
line 25731: if ( fd < 0 ) { 
line 25732: time_t t ; 
line 25733: time ( & t ) ; 
line 25734: memcpy ( zBuf , & t , sizeof ( t ) ) ; 
line 25735: pid = getpid ( ) ; 
line 25736: memcpy ( & zBuf [ sizeof ( t ) ] , & pid , sizeof ( pid ) ) ; 
line 25737: assert ( sizeof ( t ) + sizeof ( pid ) <= ( size_t ) nBuf ) ; 
line 25738: nBuf = sizeof ( t ) + sizeof ( pid ) ; 
line 25739: } else { 
line 25740: nBuf = read ( fd , zBuf , nBuf ) ; 
line 25741: close ( fd ) ; 
line 25742: } 
line 25743: } 
line 25744: # endif 
line 25745: return nBuf ; 
line 25746: } 
line 25757: static int unixSleep ( sqlite3_vfs * NotUsed , int microseconds ) { 
line 25758: # if OS_VXWORKS 
line 25759: struct timespec sp ; 
line 25761: sp . tv_sec = microseconds / 1000000 ; 
line 25762: sp . tv_nsec = ( microseconds % 1000000 ) * 1000 ; 
line 25763: nanosleep ( & sp , NULL ) ; 
line 25764: UNUSED_PARAMETER ( NotUsed ) ; 
line 25765: return microseconds ; 
line 25766: # elif defined ( HAVE_USLEEP ) && HAVE_USLEEP 
line 25767: usleep ( microseconds ) ; 
line 25768: UNUSED_PARAMETER ( NotUsed ) ; 
line 25769: return microseconds ; 
line 25770: # else 
line 25771: int seconds = ( microseconds + 999999 ) / 1000000 ; 
line 25772: sleep ( seconds ) ; 
line 25773: UNUSED_PARAMETER ( NotUsed ) ; 
line 25774: return seconds * 1000000 ; 
line 25775: # endif 
line 25776: } 
line 25783: # ifdef SQLITE_TEST 
line 25784: SQLITE_API int sqlite3_current_time = 0 ; 
line 25785: # endif 
line 25792: static int unixCurrentTime ( sqlite3_vfs * NotUsed , double * prNow ) { 
line 25793: # if defined ( SQLITE_OMIT_FLOATING_POINT ) 
line 25794: time_t t ; 
line 25795: time ( & t ) ; 
line 25796: * prNow = ( ( ( sqlite3_int64 ) t ) / 8640 + 24405875 ) / 10 ; 
line 25797: # elif defined ( NO_GETTOD ) 
line 25798: time_t t ; 
line 25799: time ( & t ) ; 
line 25800: * prNow = t / 86400.0 + 2440587.5 ; 
line 25801: # elif OS_VXWORKS 
line 25802: struct timespec sNow ; 
line 25803: clock_gettime ( CLOCK_REALTIME , & sNow ) ; 
line 25804: * prNow = 2440587.5 + sNow . tv_sec / 86400.0 + sNow . tv_nsec / 86400000000000.0 ; 
line 25805: # else 
line 25806: struct timeval sNow ; 
line 25807: gettimeofday ( & sNow , 0 ) ; 
line 25808: * prNow = 2440587.5 + sNow . tv_sec / 86400.0 + sNow . tv_usec / 86400000000.0 ; 
line 25809: # endif 
line 25811: # ifdef SQLITE_TEST 
line 25812: if ( sqlite3_current_time ) { 
line 25813: * prNow = sqlite3_current_time / 86400.0 + 2440587.5 ; 
line 25814: } 
line 25815: # endif 
line 25816: UNUSED_PARAMETER ( NotUsed ) ; 
line 25817: return 0 ; 
line 25818: } 
line 25827: static int unixGetLastError ( sqlite3_vfs * NotUsed , int NotUsed2 , char * NotUsed3 ) { 
line 25828: UNUSED_PARAMETER ( NotUsed ) ; 
line 25829: UNUSED_PARAMETER ( NotUsed2 ) ; 
line 25830: UNUSED_PARAMETER ( NotUsed3 ) ; 
line 25831: return 0 ; 
line 25832: } 
line 25999: # if defined ( __APPLE__ ) && SQLITE_ENABLE_LOCKING_STYLE 
line 26001: # ifdef SQLITE_TEST 
line 26003: SQLITE_API int sqlite3_hostid_num = 0 ; 
line 26004: # endif 
line 26010: typedef struct proxyLockingContext proxyLockingContext ; 
line 26011: struct proxyLockingContext { 
line 26012: unixFile * conchFile ; 
line 26013: char * conchFilePath ; 
line 26014: unixFile * lockProxy ; 
line 26015: char * lockProxyPath ; 
line 26016: char * dbPath ; 
line 26017: int conchHeld ; 
line 26018: void * oldLockingContext ; 
line 26019: sqlite3_io_methods const * pOldMethod ; 
line 26020: } ; 
line 26025: # define HOSTIDLEN 128 
line 26026: # define CONCHLEN ( MAXPATHLEN + HOSTIDLEN + 1 ) 
line 26027: # ifndef HOSTIDPATH 
line 26028: # define HOSTIDPATH "/Library/Caches/.com.apple.sqliteConchHostId" 
line 26029: # endif 
line 26033: static int proxyGenerateHostID ( char * pHostID ) { 
line 26034: int pid , fd , len ; 
line 26035: unsigned char * key = ( unsigned char * ) pHostID ; 
line 26037: memset ( key , 0 , HOSTIDLEN ) ; 
line 26038: len = 0 ; 
line 26039: fd = open ( "/dev/urandom" , O_RDONLY ) ; 
line 26040: if ( fd >= 0 ) { 
line 26041: len = read ( fd , key , HOSTIDLEN ) ; 
line 26042: close ( fd ) ; 
line 26043: } 
line 26044: if ( len < HOSTIDLEN ) { 
line 26045: time_t t ; 
line 26046: time ( & t ) ; 
line 26047: memcpy ( key , & t , sizeof ( t ) ) ; 
line 26048: pid = getpid ( ) ; 
line 26049: memcpy ( & key [ sizeof ( t ) ] , & pid , sizeof ( pid ) ) ; 
line 26050: } 
line 26052: # ifdef MAKE_PRETTY_HOSTID 
line 26053: { 
line 26054: int i ; 
line 26056: key [ ( HOSTIDLEN - 1 ) ] = 0x00 ; 
line 26057: for ( i = 0 ; i < ( HOSTIDLEN - 1 ) ; i ++ ) { 
line 26058: unsigned char pa = key [ i ] & 0x7F ; 
line 26059: if ( pa < 0x20 ) { 
line 26060: key [ i ] = ( key [ i ] & 0x80 == 0x80 ) ? pa + 0x40 : pa + 0x20 ; 
line 26061: } else if ( pa == 0x7F ) { 
line 26062: key [ i ] = ( key [ i ] & 0x80 == 0x80 ) ? pa = 0x20 : pa + 0x7E ; 
line 26063: } 
line 26064: } 
line 26065: } 
line 26066: # endif 
line 26067: return SQLITE_OK ; 
line 26068: } 
line 26073: static void proxyGetHostIDPath ( char * path , size_t len ) { 
line 26074: strlcpy ( path , HOSTIDPATH , len ) ; 
line 26075: # ifdef SQLITE_TEST 
line 26076: if ( sqlite3_hostid_num > 0 ) { 
line 26077: char suffix [ 2 ] = "1" ; 
line 26078: suffix [ 0 ] = suffix [ 0 ] + sqlite3_hostid_num ; 
line 26079: strlcat ( path , suffix , len ) ; 
line 26080: } 
line 26081: # endif 
line 26082: OSTRACE3 ( "GETHOSTIDPATH  %s pid=%d\n" , path , getpid ( ) ) ; 
line 26083: } 
line 26088: static int proxyGetHostID ( char * pHostID , int * pError ) { 
line 26089: int fd ; 
line 26090: char path [ MAXPATHLEN ] ; 
line 26091: size_t len ; 
line 26092: int rc = SQLITE_OK ; 
line 26094: proxyGetHostIDPath ( path , MAXPATHLEN ) ; 
line 26096: fd = open ( path , O_CREAT | O_WRONLY | O_EXCL , 0644 ) ; 
line 26097: if ( fd < 0 ) { 
line 26098: int err = errno ; 
line 26100: if ( err != EEXIST ) { 
line 26101: # ifdef SQLITE_PROXY_DEBUG 
line 26102: fprintf ( stderr , "sqlite error creating host ID file %s: %s\n" , 
line 26103: path , strerror ( err ) ) ; 
line 26104: # endif 
line 26105: return SQLITE_PERM ; 
line 26106: } 
line 26108: fd = open ( path , O_RDONLY | O_EXCL ) ; 
line 26109: if ( fd < 0 ) { 
line 26110: # ifdef SQLITE_PROXY_DEBUG 
line 26111: int err = errno ; 
line 26112: fprintf ( stderr , "sqlite error opening host ID file %s: %s\n" , 
line 26113: path , strerror ( err ) ) ; 
line 26114: # endif 
line 26115: return SQLITE_PERM ; 
line 26116: } 
line 26117: len = pread ( fd , pHostID , HOSTIDLEN , 0 ) ; 
line 26118: if ( len < 0 ) { 
line 26119: * pError = errno ; 
line 26120: rc = SQLITE_IOERR_READ ; 
line 26121: } else if ( len < HOSTIDLEN ) { 
line 26122: * pError = 0 ; 
line 26123: rc = SQLITE_IOERR_SHORT_READ ; 
line 26124: } 
line 26125: close ( fd ) ; 
line 26126: OSTRACE3 ( "GETHOSTID  read %s pid=%d\n" , pHostID , getpid ( ) ) ; 
line 26127: return rc ; 
line 26128: } else { 
line 26130: proxyGenerateHostID ( pHostID ) ; 
line 26131: len = pwrite ( fd , pHostID , HOSTIDLEN , 0 ) ; 
line 26132: if ( len < 0 ) { 
line 26133: * pError = errno ; 
line 26134: rc = SQLITE_IOERR_WRITE ; 
line 26135: } else if ( len < HOSTIDLEN ) { 
line 26136: * pError = 0 ; 
line 26137: rc = SQLITE_IOERR_WRITE ; 
line 26138: } 
line 26139: close ( fd ) ; 
line 26140: OSTRACE3 ( "GETHOSTID  wrote %s pid=%d\n" , pHostID , getpid ( ) ) ; 
line 26141: return rc ; 
line 26142: } 
line 26143: } 
line 26145: static int proxyGetLockPath ( const char * dbPath , char * lPath , size_t maxLen ) { 
line 26146: int len ; 
line 26147: int dbLen ; 
line 26148: int i ; 
line 26150: # ifdef LOCKPROXYDIR 
line 26151: len = strlcpy ( lPath , LOCKPROXYDIR , maxLen ) ; 
line 26152: # else 
line 26153: # ifdef _CS_DARWIN_USER_TEMP_DIR 
line 26154: { 
line 26155: confstr ( _CS_DARWIN_USER_TEMP_DIR , lPath , maxLen ) ; 
line 26156: len = strlcat ( lPath , "sqliteplocks" , maxLen ) ; 
line 26157: if ( mkdir ( lPath , SQLITE_DEFAULT_PROXYDIR_PERMISSIONS ) ) { 
line 26159: # ifdef SQLITE_DEBUG 
line 26160: int err = errno ; 
line 26161: if ( err != EEXIST ) { 
line 26162: fprintf ( stderr , "proxyGetLockPath: mkdir(%s,0%o) error %d %s\n" , lPath , 
line 26163: SQLITE_DEFAULT_PROXYDIR_PERMISSIONS , err , strerror ( err ) ) ; 
line 26164: } 
line 26165: # endif 
line 26166: } else { 
line 26167: OSTRACE3 ( "GETLOCKPATH  mkdir %s pid=%d\n" , lPath , getpid ( ) ) ; 
line 26168: } 
line 26170: } 
line 26171: # else 
line 26172: len = strlcpy ( lPath , "/tmp/" , maxLen ) ; 
line 26173: # endif 
line 26174: # endif 
line 26176: if ( lPath [ len - 1 ] != '/' ) { 
line 26177: len = strlcat ( lPath , "/" , maxLen ) ; 
line 26178: } 
line 26181: dbLen = ( int ) strlen ( dbPath ) ; 
line 26182: for ( i = 0 ; i < dbLen && ( i + len + 7 ) < maxLen ; i ++ ) { 
line 26183: char c = dbPath [ i ] ; 
line 26184: lPath [ i + len ] = ( c == '/' ) ? '_' : c ; 
line 26185: } 
line 26186: lPath [ i + len ] = '\0' ; 
line 26187: strlcat ( lPath , ":auto:" , maxLen ) ; 
line 26188: return SQLITE_OK ; 
line 26189: } 
line 26198: static int proxyCreateUnixFile ( const char * path , unixFile * * ppFile ) { 
line 26199: unixFile * pNew ; 
line 26200: int flags = SQLITE_OPEN_MAIN_DB | SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE ; 
line 26201: int rc = SQLITE_OK ; 
line 26202: sqlite3_vfs dummyVfs ; 
line 26204: pNew = ( unixFile * ) sqlite3_malloc ( sizeof ( unixFile ) ) ; 
line 26205: if ( ! pNew ) { 
line 26206: return SQLITE_NOMEM ; 
line 26207: } 
line 26208: memset ( pNew , 0 , sizeof ( unixFile ) ) ; 
line 26222: dummyVfs . pAppData = ( void * ) & autolockIoFinder ; 
line 26223: dummyVfs . xOpen = 0 ; 
line 26224: rc = unixOpen ( & dummyVfs , path , ( sqlite3_file * ) pNew , flags , & flags ) ; 
line 26225: if ( rc == SQLITE_OK && ( flags & SQLITE_OPEN_READONLY ) ) { 
line 26226: pNew -> pMethod -> xClose ( ( sqlite3_file * ) pNew ) ; 
line 26227: rc = SQLITE_CANTOPEN ; 
line 26228: } 
line 26230: if ( rc != SQLITE_OK ) { 
line 26231: sqlite3_free ( pNew ) ; 
line 26232: pNew = 0 ; 
line 26233: } 
line 26235: * ppFile = pNew ; 
line 26236: return rc ; 
line 26237: } 
line 26245: static int proxyTakeConch ( unixFile * pFile ) { 
line 26246: proxyLockingContext * pCtx = ( proxyLockingContext * ) pFile -> lockingContext ; 
line 26248: if ( pCtx -> conchHeld > 0 ) { 
line 26249: return SQLITE_OK ; 
line 26250: } else { 
line 26251: unixFile * conchFile = pCtx -> conchFile ; 
line 26252: char testValue [ CONCHLEN ] ; 
line 26253: char conchValue [ CONCHLEN ] ; 
line 26254: char lockPath [ MAXPATHLEN ] ; 
line 26255: char * tLockPath = NULL ; 
line 26256: int rc = SQLITE_OK ; 
line 26257: int readRc = SQLITE_OK ; 
line 26258: int syncPerms = 0 ; 
line 26260: OSTRACE4 ( "TAKECONCH  %d for %s pid=%d\n" , conchFile -> h , 
line 26261: ( pCtx -> lockProxyPath ? pCtx -> lockProxyPath : ":auto:" ) , getpid ( ) ) ; 
line 26263: rc = conchFile -> pMethod -> xLock ( ( sqlite3_file * ) conchFile , SHARED_LOCK ) ; 
line 26264: if ( rc == SQLITE_OK ) { 
line 26265: int pError = 0 ; 
line 26266: memset ( testValue , 0 , CONCHLEN ) ; 
line 26267: rc = proxyGetHostID ( testValue , & pError ) ; 
line 26268: if ( ( rc & 0xff ) == SQLITE_IOERR ) { 
line 26269: pFile -> lastErrno = pError ; 
line 26270: } 
line 26271: if ( pCtx -> lockProxyPath ) { 
line 26272: strlcpy ( & testValue [ HOSTIDLEN ] , pCtx -> lockProxyPath , MAXPATHLEN ) ; 
line 26273: } 
line 26274: } 
line 26275: if ( rc != SQLITE_OK ) { 
line 26276: goto end_takeconch ; 
line 26277: } 
line 26279: readRc = unixRead ( ( sqlite3_file * ) conchFile , conchValue , CONCHLEN , 0 ) ; 
line 26280: if ( readRc != SQLITE_IOERR_SHORT_READ ) { 
line 26281: if ( readRc != SQLITE_OK ) { 
line 26282: if ( ( rc & 0xff ) == SQLITE_IOERR ) { 
line 26283: pFile -> lastErrno = conchFile -> lastErrno ; 
line 26284: } 
line 26285: rc = readRc ; 
line 26286: goto end_takeconch ; 
line 26287: } 
line 26289: if ( ! pCtx -> lockProxyPath ) { 
line 26292: if ( ! memcmp ( testValue , conchValue , HOSTIDLEN ) ) { 
line 26293: tLockPath = ( char * ) & conchValue [ HOSTIDLEN ] ; 
line 26294: goto end_takeconch ; 
line 26295: } 
line 26296: } else { 
line 26298: if ( ! memcmp ( testValue , conchValue , CONCHLEN ) ) { 
line 26299: goto end_takeconch ; 
line 26300: } 
line 26301: } 
line 26302: } else { 
line 26307: syncPerms = 1 ; 
line 26308: } 
line 26311: if ( ! pCtx -> lockProxyPath ) { 
line 26312: proxyGetLockPath ( pCtx -> dbPath , lockPath , MAXPATHLEN ) ; 
line 26313: tLockPath = lockPath ; 
line 26314: strlcpy ( & testValue [ HOSTIDLEN ] , lockPath , MAXPATHLEN ) ; 
line 26315: } 
line 26319: rc = conchFile -> pMethod -> xLock ( ( sqlite3_file * ) conchFile , EXCLUSIVE_LOCK ) ; 
line 26320: if ( rc == SQLITE_OK ) { 
line 26321: rc = unixWrite ( ( sqlite3_file * ) conchFile , testValue , CONCHLEN , 0 ) ; 
line 26322: if ( rc == SQLITE_OK && syncPerms ) { 
line 26323: struct stat buf ; 
line 26324: int err = fstat ( pFile -> h , & buf ) ; 
line 26325: if ( err == 0 ) { 
line 26327: # ifndef SQLITE_PROXY_DEBUG 
line 26328: fchmod ( conchFile -> h , buf . st_mode ) ; 
line 26329: # else 
line 26330: if ( fchmod ( conchFile -> h , buf . st_mode ) != 0 ) { 
line 26331: int code = errno ; 
line 26332: fprintf ( stderr , "fchmod %o FAILED with %d %s\n" , 
line 26333: buf . st_mode , code , strerror ( code ) ) ; 
line 26334: } else { 
line 26335: fprintf ( stderr , "fchmod %o SUCCEDED\n" , buf . st_mode ) ; 
line 26336: } 
line 26337: } else { 
line 26338: int code = errno ; 
line 26339: fprintf ( stderr , "STAT FAILED[%d] with %d %s\n" , 
line 26340: err , code , strerror ( code ) ) ; 
line 26341: # endif 
line 26342: } 
line 26343: } 
line 26344: } 
line 26345: conchFile -> pMethod -> xUnlock ( ( sqlite3_file * ) conchFile , SHARED_LOCK ) ; 
line 26347: end_takeconch : 
line 26348: OSTRACE2 ( "TRANSPROXY: CLOSE  %d\n" , pFile -> h ) ; 
line 26349: if ( rc == SQLITE_OK && pFile -> openFlags ) { 
line 26350: if ( pFile -> h >= 0 ) { 
line 26351: # ifdef STRICT_CLOSE_ERROR 
line 26352: if ( close ( pFile -> h ) ) { 
line 26353: pFile -> lastErrno = errno ; 
line 26354: return SQLITE_IOERR_CLOSE ; 
line 26355: } 
line 26356: # else 
line 26357: close ( pFile -> h ) ; 
line 26358: # endif 
line 26359: } 
line 26360: pFile -> h = - 1 ; 
line 26361: int fd = open ( pCtx -> dbPath , pFile -> openFlags , 
line 26362: SQLITE_DEFAULT_FILE_PERMISSIONS ) ; 
line 26363: OSTRACE2 ( "TRANSPROXY: OPEN  %d\n" , fd ) ; 
line 26364: if ( fd >= 0 ) { 
line 26365: pFile -> h = fd ; 
line 26366: } else { 
line 26367: rc = SQLITE_CANTOPEN ; 
line 26369: } 
line 26370: } 
line 26371: if ( rc == SQLITE_OK && ! pCtx -> lockProxy ) { 
line 26372: char * path = tLockPath ? tLockPath : pCtx -> lockProxyPath ; 
line 26374: rc = proxyCreateUnixFile ( path , & pCtx -> lockProxy ) ; 
line 26375: } 
line 26376: if ( rc == SQLITE_OK ) { 
line 26377: pCtx -> conchHeld = 1 ; 
line 26379: if ( tLockPath ) { 
line 26380: pCtx -> lockProxyPath = sqlite3DbStrDup ( 0 , tLockPath ) ; 
line 26381: if ( pCtx -> lockProxy -> pMethod == & afpIoMethods ) { 
line 26382: ( ( afpLockingContext * ) pCtx -> lockProxy -> lockingContext ) -> dbPath = 
line 26383: pCtx -> lockProxyPath ; 
line 26384: } 
line 26385: } 
line 26386: } else { 
line 26387: conchFile -> pMethod -> xUnlock ( ( sqlite3_file * ) conchFile , NO_LOCK ) ; 
line 26388: } 
line 26389: OSTRACE3 ( "TAKECONCH  %d %s\n" , conchFile -> h , rc == SQLITE_OK ? "ok" : "failed" ) ; 
line 26390: return rc ; 
line 26391: } 
line 26392: } 
line 26397: static int proxyReleaseConch ( unixFile * pFile ) { 
line 26398: int rc ; 
line 26399: proxyLockingContext * pCtx ; 
line 26400: unixFile * conchFile ; 
line 26402: pCtx = ( proxyLockingContext * ) pFile -> lockingContext ; 
line 26403: conchFile = pCtx -> conchFile ; 
line 26404: OSTRACE4 ( "RELEASECONCH  %d for %s pid=%d\n" , conchFile -> h , 
line 26405: ( pCtx -> lockProxyPath ? pCtx -> lockProxyPath : ":auto:" ) , 
line 26406: getpid ( ) ) ; 
line 26407: pCtx -> conchHeld = 0 ; 
line 26408: rc = conchFile -> pMethod -> xUnlock ( ( sqlite3_file * ) conchFile , NO_LOCK ) ; 
line 26409: OSTRACE3 ( "RELEASECONCH  %d %s\n" , conchFile -> h , 
line 26410: ( rc == SQLITE_OK ? "ok" : "failed" ) ) ; 
line 26411: return rc ; 
line 26412: } 
line 26425: static int proxyCreateConchPathname ( char * dbPath , char * * pConchPath ) { 
line 26426: int i ; 
line 26427: int len = ( int ) strlen ( dbPath ) ; 
line 26428: char * conchPath ; 
line 26432: * pConchPath = conchPath = ( char * ) sqlite3_malloc ( len + 8 ) ; 
line 26433: if ( conchPath == 0 ) { 
line 26434: return SQLITE_NOMEM ; 
line 26435: } 
line 26436: memcpy ( conchPath , dbPath , len + 1 ) ; 
line 26439: for ( i = ( len - 1 ) ; i >= 0 ; i -- ) { 
line 26440: if ( conchPath [ i ] == '/' ) { 
line 26441: i ++ ; 
line 26442: break ; 
line 26443: } 
line 26444: } 
line 26445: conchPath [ i ] = '.' ; 
line 26446: while ( i < len ) { 
line 26447: conchPath [ i + 1 ] = dbPath [ i ] ; 
line 26448: i ++ ; 
line 26449: } 
line 26452: memcpy ( & conchPath [ i + 1 ] , "-conch" , 7 ) ; 
line 26453: assert ( ( int ) strlen ( conchPath ) == len + 7 ) ; 
line 26455: return SQLITE_OK ; 
line 26456: } 
line 26462: static int switchLockProxyPath ( unixFile * pFile , const char * path ) { 
line 26463: proxyLockingContext * pCtx = ( proxyLockingContext * ) pFile -> lockingContext ; 
line 26464: char * oldPath = pCtx -> lockProxyPath ; 
line 26465: int rc = SQLITE_OK ; 
line 26467: if ( pFile -> locktype != NO_LOCK ) { 
line 26468: return SQLITE_BUSY ; 
line 26469: } 
line 26472: if ( ! path || path [ 0 ] == '\0' || ! strcmp ( path , ":auto:" ) || 
line 26473: ( oldPath && ! strncmp ( oldPath , path , MAXPATHLEN ) ) ) { 
line 26474: return SQLITE_OK ; 
line 26475: } else { 
line 26476: unixFile * lockProxy = pCtx -> lockProxy ; 
line 26477: pCtx -> lockProxy = NULL ; 
line 26478: pCtx -> conchHeld = 0 ; 
line 26479: if ( lockProxy != NULL ) { 
line 26480: rc = lockProxy -> pMethod -> xClose ( ( sqlite3_file * ) lockProxy ) ; 
line 26481: if ( rc ) return rc ; 
line 26482: sqlite3_free ( lockProxy ) ; 
line 26483: } 
line 26484: sqlite3_free ( oldPath ) ; 
line 26485: pCtx -> lockProxyPath = sqlite3DbStrDup ( 0 , path ) ; 
line 26486: } 
line 26488: return rc ; 
line 26489: } 
line 26498: static int proxyGetDbPathForUnixFile ( unixFile * pFile , char * dbPath ) { 
line 26499: # if defined ( __APPLE__ ) 
line 26500: if ( pFile -> pMethod == & afpIoMethods ) { 
line 26503: assert ( ( int ) strlen ( ( char * ) pFile -> lockingContext ) <= MAXPATHLEN ) ; 
line 26504: strcpy ( dbPath , ( ( afpLockingContext * ) pFile -> lockingContext ) -> dbPath ) ; 
line 26505: } else 
line 26506: # endif 
line 26507: if ( pFile -> pMethod == & dotlockIoMethods ) { 
line 26510: int len = strlen ( ( char * ) pFile -> lockingContext ) - strlen ( DOTLOCK_SUFFIX ) ; 
line 26511: memcpy ( dbPath , ( char * ) pFile -> lockingContext , len + 1 ) ; 
line 26512: } else { 
line 26514: assert ( strlen ( ( char * ) pFile -> lockingContext ) <= MAXPATHLEN ) ; 
line 26515: strcpy ( dbPath , ( char * ) pFile -> lockingContext ) ; 
line 26516: } 
line 26517: return SQLITE_OK ; 
line 26518: } 
line 26528: static int proxyTransformUnixFile ( unixFile * pFile , const char * path ) { 
line 26529: proxyLockingContext * pCtx ; 
line 26530: char dbPath [ MAXPATHLEN + 1 ] ; 
line 26531: char * lockPath = NULL ; 
line 26532: int rc = SQLITE_OK ; 
line 26534: if ( pFile -> locktype != NO_LOCK ) { 
line 26535: return SQLITE_BUSY ; 
line 26536: } 
line 26537: proxyGetDbPathForUnixFile ( pFile , dbPath ) ; 
line 26538: if ( ! path || path [ 0 ] == '\0' || ! strcmp ( path , ":auto:" ) ) { 
line 26539: lockPath = NULL ; 
line 26540: } else { 
line 26541: lockPath = ( char * ) path ; 
line 26542: } 
line 26544: OSTRACE4 ( "TRANSPROXY  %d for %s pid=%d\n" , pFile -> h , 
line 26545: ( lockPath ? lockPath : ":auto:" ) , getpid ( ) ) ; 
line 26547: pCtx = sqlite3_malloc ( sizeof ( * pCtx ) ) ; 
line 26548: if ( pCtx == 0 ) { 
line 26549: return SQLITE_NOMEM ; 
line 26550: } 
line 26551: memset ( pCtx , 0 , sizeof ( * pCtx ) ) ; 
line 26553: rc = proxyCreateConchPathname ( dbPath , & pCtx -> conchFilePath ) ; 
line 26554: if ( rc == SQLITE_OK ) { 
line 26555: rc = proxyCreateUnixFile ( pCtx -> conchFilePath , & pCtx -> conchFile ) ; 
line 26556: } 
line 26557: if ( rc == SQLITE_OK && lockPath ) { 
line 26558: pCtx -> lockProxyPath = sqlite3DbStrDup ( 0 , lockPath ) ; 
line 26559: } 
line 26561: if ( rc == SQLITE_OK ) { 
line 26565: pCtx -> dbPath = sqlite3DbStrDup ( 0 , dbPath ) ; 
line 26566: pCtx -> oldLockingContext = pFile -> lockingContext ; 
line 26567: pFile -> lockingContext = pCtx ; 
line 26568: pCtx -> pOldMethod = pFile -> pMethod ; 
line 26569: pFile -> pMethod = & proxyIoMethods ; 
line 26570: } else { 
line 26571: if ( pCtx -> conchFile ) { 
line 26572: rc = pCtx -> conchFile -> pMethod -> xClose ( ( sqlite3_file * ) pCtx -> conchFile ) ; 
line 26573: if ( rc ) return rc ; 
line 26574: sqlite3_free ( pCtx -> conchFile ) ; 
line 26575: } 
line 26576: sqlite3_free ( pCtx -> conchFilePath ) ; 
line 26577: sqlite3_free ( pCtx ) ; 
line 26578: } 
line 26579: OSTRACE3 ( "TRANSPROXY  %d %s\n" , pFile -> h , 
line 26580: ( rc == SQLITE_OK ? "ok" : "failed" ) ) ; 
line 26581: return rc ; 
line 26582: } 
line 26589: static int proxyFileControl ( sqlite3_file * id , int op , void * pArg ) { 
line 26590: switch ( op ) { 
line 26591: case SQLITE_GET_LOCKPROXYFILE : { 
line 26592: unixFile * pFile = ( unixFile * ) id ; 
line 26593: if ( pFile -> pMethod == & proxyIoMethods ) { 
line 26594: proxyLockingContext * pCtx = ( proxyLockingContext * ) pFile -> lockingContext ; 
line 26595: proxyTakeConch ( pFile ) ; 
line 26596: if ( pCtx -> lockProxyPath ) { 
line 26597: * ( const char * * ) pArg = pCtx -> lockProxyPath ; 
line 26598: } else { 
line 26599: * ( const char * * ) pArg = ":auto: (not held)" ; 
line 26600: } 
line 26601: } else { 
line 26602: * ( const char * * ) pArg = NULL ; 
line 26603: } 
line 26604: return SQLITE_OK ; 
line 26605: } 
line 26606: case SQLITE_SET_LOCKPROXYFILE : { 
line 26607: unixFile * pFile = ( unixFile * ) id ; 
line 26608: int rc = SQLITE_OK ; 
line 26609: int isProxyStyle = ( pFile -> pMethod == & proxyIoMethods ) ; 
line 26610: if ( pArg == NULL || ( const char * ) pArg == 0 ) { 
line 26611: if ( isProxyStyle ) { 
line 26613: rc = SQLITE_ERROR ; 
line 26614: } else { 
line 26616: rc = SQLITE_OK ; 
line 26617: } 
line 26618: } else { 
line 26619: const char * proxyPath = ( const char * ) pArg ; 
line 26620: if ( isProxyStyle ) { 
line 26621: proxyLockingContext * pCtx = 
line 26622: ( proxyLockingContext * ) pFile -> lockingContext ; 
line 26623: if ( ! strcmp ( pArg , ":auto:" ) 
line 26624: || ( pCtx -> lockProxyPath && 
line 26625: ! strncmp ( pCtx -> lockProxyPath , proxyPath , MAXPATHLEN ) ) 
line 26626: ) { 
line 26627: rc = SQLITE_OK ; 
line 26628: } else { 
line 26629: rc = switchLockProxyPath ( pFile , proxyPath ) ; 
line 26630: } 
line 26631: } else { 
line 26633: rc = proxyTransformUnixFile ( pFile , proxyPath ) ; 
line 26634: } 
line 26635: } 
line 26636: return rc ; 
line 26637: } 
line 26638: default : { 
line 26639: assert ( 0 ) ; 
line 26640: } 
line 26641: } 
line 26643: return SQLITE_ERROR ; 
line 26644: } 
line 26659: static int proxyCheckReservedLock ( sqlite3_file * id , int * pResOut ) { 
line 26660: unixFile * pFile = ( unixFile * ) id ; 
line 26661: int rc = proxyTakeConch ( pFile ) ; 
line 26662: if ( rc == SQLITE_OK ) { 
line 26663: proxyLockingContext * pCtx = ( proxyLockingContext * ) pFile -> lockingContext ; 
line 26664: unixFile * proxy = pCtx -> lockProxy ; 
line 26665: return proxy -> pMethod -> xCheckReservedLock ( ( sqlite3_file * ) proxy , pResOut ) ; 
line 26666: } 
line 26667: return rc ; 
line 26668: } 
line 26694: static int proxyLock ( sqlite3_file * id , int locktype ) { 
line 26695: unixFile * pFile = ( unixFile * ) id ; 
line 26696: int rc = proxyTakeConch ( pFile ) ; 
line 26697: if ( rc == SQLITE_OK ) { 
line 26698: proxyLockingContext * pCtx = ( proxyLockingContext * ) pFile -> lockingContext ; 
line 26699: unixFile * proxy = pCtx -> lockProxy ; 
line 26700: rc = proxy -> pMethod -> xLock ( ( sqlite3_file * ) proxy , locktype ) ; 
line 26701: pFile -> locktype = proxy -> locktype ; 
line 26702: } 
line 26703: return rc ; 
line 26704: } 
line 26714: static int proxyUnlock ( sqlite3_file * id , int locktype ) { 
line 26715: unixFile * pFile = ( unixFile * ) id ; 
line 26716: int rc = proxyTakeConch ( pFile ) ; 
line 26717: if ( rc == SQLITE_OK ) { 
line 26718: proxyLockingContext * pCtx = ( proxyLockingContext * ) pFile -> lockingContext ; 
line 26719: unixFile * proxy = pCtx -> lockProxy ; 
line 26720: rc = proxy -> pMethod -> xUnlock ( ( sqlite3_file * ) proxy , locktype ) ; 
line 26721: pFile -> locktype = proxy -> locktype ; 
line 26722: } 
line 26723: return rc ; 
line 26724: } 
line 26729: static int proxyClose ( sqlite3_file * id ) { 
line 26730: if ( id ) { 
line 26731: unixFile * pFile = ( unixFile * ) id ; 
line 26732: proxyLockingContext * pCtx = ( proxyLockingContext * ) pFile -> lockingContext ; 
line 26733: unixFile * lockProxy = pCtx -> lockProxy ; 
line 26734: unixFile * conchFile = pCtx -> conchFile ; 
line 26735: int rc = SQLITE_OK ; 
line 26737: if ( lockProxy ) { 
line 26738: rc = lockProxy -> pMethod -> xUnlock ( ( sqlite3_file * ) lockProxy , NO_LOCK ) ; 
line 26739: if ( rc ) return rc ; 
line 26740: rc = lockProxy -> pMethod -> xClose ( ( sqlite3_file * ) lockProxy ) ; 
line 26741: if ( rc ) return rc ; 
line 26742: sqlite3_free ( lockProxy ) ; 
line 26743: pCtx -> lockProxy = 0 ; 
line 26744: } 
line 26745: if ( conchFile ) { 
line 26746: if ( pCtx -> conchHeld ) { 
line 26747: rc = proxyReleaseConch ( pFile ) ; 
line 26748: if ( rc ) return rc ; 
line 26749: } 
line 26750: rc = conchFile -> pMethod -> xClose ( ( sqlite3_file * ) conchFile ) ; 
line 26751: if ( rc ) return rc ; 
line 26752: sqlite3_free ( conchFile ) ; 
line 26753: } 
line 26754: sqlite3_free ( pCtx -> lockProxyPath ) ; 
line 26755: sqlite3_free ( pCtx -> conchFilePath ) ; 
line 26756: sqlite3_free ( pCtx -> dbPath ) ; 
line 26758: pFile -> lockingContext = pCtx -> oldLockingContext ; 
line 26759: pFile -> pMethod = pCtx -> pOldMethod ; 
line 26760: sqlite3_free ( pCtx ) ; 
line 26761: return pFile -> pMethod -> xClose ( id ) ; 
line 26762: } 
line 26763: return SQLITE_OK ; 
line 26764: } 
line 26768: # endif 
line 26791: SQLITE_API int sqlite3_os_init ( void ) { 
line 26812: # define UNIXVFS ( VFSNAME , FINDER ) { 
line 26813: 1 , 
line 26814: sizeof ( unixFile ) , 
line 26815: MAX_PATHNAME , 
line 26816: 0 , 
line 26817: VFSNAME , 
line 26818: ( void * ) & FINDER , 
line 26819: unixOpen , 
line 26820: unixDelete , 
line 26821: unixAccess , 
line 26822: unixFullPathname , 
line 26823: unixDlOpen , 
line 26824: unixDlError , 
line 26825: unixDlSym , 
line 26826: unixDlClose , 
line 26827: unixRandomness , 
line 26828: unixSleep , 
line 26829: unixCurrentTime , 
line 26830: unixGetLastError 
line 26831: } 
line 26840: static sqlite3_vfs aVfs [ ] = { 
line 26841: # if SQLITE_ENABLE_LOCKING_STYLE && ( OS_VXWORKS || defined ( __APPLE__ ) ) 
line 26842: UNIXVFS ( "unix" , autolockIoFinder ) , 
line 26843: # else 
line 26844: UNIXVFS ( "unix" , posixIoFinder ) , 
line 26845: # endif 
line 26846: UNIXVFS ( "unix-none" , nolockIoFinder ) , 
line 26847: UNIXVFS ( "unix-dotfile" , dotlockIoFinder ) , 
line 26848: UNIXVFS ( "unix-wfl" , posixWflIoFinder ) , 
line 26849: # if OS_VXWORKS 
line 26850: UNIXVFS ( "unix-namedsem" , semIoFinder ) , 
line 26851: # endif 
line 26852: # if SQLITE_ENABLE_LOCKING_STYLE 
line 26853: UNIXVFS ( "unix-posix" , posixIoFinder ) , 
line 26854: # if ! OS_VXWORKS 
line 26855: UNIXVFS ( "unix-flock" , flockIoFinder ) , 
line 26856: # endif 
line 26857: # endif 
line 26858: # if SQLITE_ENABLE_LOCKING_STYLE && defined ( __APPLE__ ) 
line 26859: UNIXVFS ( "unix-afp" , afpIoFinder ) , 
line 26860: UNIXVFS ( "unix-proxy" , proxyIoFinder ) , 
line 26861: # endif 
line 26862: } ; 
line 26863: unsigned int i ; 
line 26866: for ( i = 0 ; i < ( sizeof ( aVfs ) / sizeof ( sqlite3_vfs ) ) ; i ++ ) { 
line 26867: sqlite3_vfs_register ( & aVfs [ i ] , i == 0 ) ; 
line 26868: } 
line 26869: return SQLITE_OK ; 
line 26870: } 
line 26879: SQLITE_API int sqlite3_os_end ( void ) { 
line 26880: return SQLITE_OK ; 
line 26881: } 
line 26883: # endif 
line 26901: # if SQLITE_OS_WIN 
line 26930: # include < winbase . h > 
line 26932: # ifdef __CYGWIN__ 
line 26933: # include < sys / cygwin . h > 
line 26934: # endif 
line 26939: # if defined ( THREADSAFE ) && THREADSAFE 
line 26940: # define SQLITE_W32_THREADS 1 
line 26941: # endif 
line 26967: # ifndef _OS_COMMON_H_ 
line 26968: # define _OS_COMMON_H_ 
line 26975: # ifdef MEMORY_DEBUG 
line 26976: # error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead." 
line 26977: # endif 
line 26979: # ifdef SQLITE_DEBUG 
line 26980: SQLITE_PRIVATE int sqlite3OSTrace = 0 ; 
line 26981: # define OSTRACE1 ( X ) if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X ) 
line 26982: # define OSTRACE2 ( X , Y ) if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y ) 
line 26983: # define OSTRACE3 ( X , Y , Z ) if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y , Z ) 
line 26984: # define OSTRACE4 ( X , Y , Z , A ) if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y , Z , A ) 
line 26985: # define OSTRACE5 ( X , Y , Z , A , B ) if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y , Z , A , B ) 
line 26986: # define OSTRACE6 ( X , Y , Z , A , B , C ) 
line 26987: if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y , Z , A , B , C ) 
line 26988: # define OSTRACE7 ( X , Y , Z , A , B , C , D ) 
line 26989: if ( sqlite3OSTrace ) sqlite3DebugPrintf ( X , Y , Z , A , B , C , D ) 
line 26990: # else 
line 26991: # define OSTRACE1 ( X ) 
line 26992: # define OSTRACE2 ( X , Y ) 
line 26993: # define OSTRACE3 ( X , Y , Z ) 
line 26994: # define OSTRACE4 ( X , Y , Z , A ) 
line 26995: # define OSTRACE5 ( X , Y , Z , A , B ) 
line 26996: # define OSTRACE6 ( X , Y , Z , A , B , C ) 
line 26997: # define OSTRACE7 ( X , Y , Z , A , B , C , D ) 
line 26998: # endif 
line 27004: # ifdef SQLITE_PERFORMANCE_TRACE 
line 27027: # ifndef _HWTIME_H_ 
line 27028: # define _HWTIME_H_ 
line 27036: # if ( defined ( __GNUC__ ) || defined ( _MSC_VER ) ) && 
line 27037: ( defined ( i386 ) || defined ( __i386__ ) || defined ( _M_IX86 ) ) 
line 27039: # if defined ( __GNUC__ ) 
line 27041: __inline__ sqlite_uint64 sqlite3Hwtime ( void ) { 
line 27042: unsigned int lo , hi ; 
line 27043: __asm__ __volatile__ ( "rdtsc" : "=a" ( lo ) , "=d" ( hi ) ) ; 
line 27044: return ( sqlite_uint64 ) hi << 32 | lo ; 
line 27045: } 
line 27047: # elif defined ( _MSC_VER ) 
line 27049: __declspec ( naked ) __inline sqlite_uint64 __cdecl sqlite3Hwtime ( void ) { 
line 27050: __asm { 
line 27051: rdtsc 
line 27052: ret ; return value at EDX : EAX 
line 27053: } 
line 27054: } 
line 27056: # endif 
line 27058: # elif ( defined ( __GNUC__ ) && defined ( __x86_64__ ) ) 
line 27060: __inline__ sqlite_uint64 sqlite3Hwtime ( void ) { 
line 27061: unsigned long val ; 
line 27062: __asm__ __volatile__ ( "rdtsc" : "=A" ( val ) ) ; 
line 27063: return val ; 
line 27064: } 
line 27066: # elif ( defined ( __GNUC__ ) && defined ( __ppc__ ) ) 
line 27068: __inline__ sqlite_uint64 sqlite3Hwtime ( void ) { 
line 27069: unsigned long long retval ; 
line 27070: unsigned long junk ; 
line 27071: __asm__ __volatile__ ( 
line 27072: "\n\
 1 : mftbu % 1 \ 
line 27073: n mftb % L0 \ 
line 27074: n mftbu % 0 \ 
line 27075: n cmpw % 0 , % 1 \ 
line 27076: n bne 1b 
line 27077: "
 : "=r" ( retval ) , "=r" ( junk ) ) ; 
line 27078: return retval ; 
line 27079: } 
line 27081: # else 
line 27083: # error Need implementation of sqlite3Hwtime ( ) for your platform . 
line 27092: SQLITE_PRIVATE sqlite_uint64 sqlite3Hwtime ( void ) { return ( ( sqlite_uint64 ) 0 ) ; } 
line 27094: # endif 
line 27096: # endif 
line 27101: static sqlite_uint64 g_start ; 
line 27102: static sqlite_uint64 g_elapsed ; 
line 27103: # define TIMER_START g_start = sqlite3Hwtime ( ) 
line 27104: # define TIMER_END g_elapsed = sqlite3Hwtime ( ) - g_start 
line 27105: # define TIMER_ELAPSED g_elapsed 
line 27106: # else 
line 27107: # define TIMER_START 
line 27108: # define TIMER_END 
line 27109: # define TIMER_ELAPSED ( ( sqlite_uint64 ) 0 ) 
line 27110: # endif 
line 27117: # ifdef SQLITE_TEST 
line 27118: SQLITE_API int sqlite3_io_error_hit = 0 ; 
line 27119: SQLITE_API int sqlite3_io_error_hardhit = 0 ; 
line 27120: SQLITE_API int sqlite3_io_error_pending = 0 ; 
line 27121: SQLITE_API int sqlite3_io_error_persist = 0 ; 
line 27122: SQLITE_API int sqlite3_io_error_benign = 0 ; 
line 27123: SQLITE_API int sqlite3_diskfull_pending = 0 ; 
line 27124: SQLITE_API int sqlite3_diskfull = 0 ; 
line 27125: # define SimulateIOErrorBenign ( X ) sqlite3_io_error_benign = ( X ) 
line 27126: # define SimulateIOError ( CODE ) 
line 27127: if ( ( sqlite3_io_error_persist && sqlite3_io_error_hit ) 
line 27128: || sqlite3_io_error_pending -- == 1 ) 
line 27129: { local_ioerr ( ) ; CODE ; } 
line 27130: static void local_ioerr ( ) { 
line 27131: IOTRACE ( ( "IOERR\n" ) ) ; 
line 27132: sqlite3_io_error_hit ++ ; 
line 27133: if ( ! sqlite3_io_error_benign ) sqlite3_io_error_hardhit ++ ; 
line 27134: } 
line 27135: # define SimulateDiskfullError ( CODE ) 
line 27136: if ( sqlite3_diskfull_pending ) { 
line 27137: if ( sqlite3_diskfull_pending == 1 ) { 
line 27138: local_ioerr ( ) ; 
line 27139: sqlite3_diskfull = 1 ; 
line 27140: sqlite3_io_error_hit = 1 ; 
line 27141: CODE ; 
line 27142: } else { 
line 27143: sqlite3_diskfull_pending -- ; 
line 27144: } 
line 27145: } 
line 27146: # else 
line 27147: # define SimulateIOErrorBenign ( X ) 
line 27148: # define SimulateIOError ( A ) 
line 27149: # define SimulateDiskfullError ( A ) 
line 27150: # endif 
line 27155: # ifdef SQLITE_TEST 
line 27156: SQLITE_API int sqlite3_open_file_count = 0 ; 
line 27157: # define OpenCounter ( X ) sqlite3_open_file_count += ( X ) 
line 27158: # else 
line 27159: # define OpenCounter ( X ) 
line 27160: # endif 
line 27162: # endif 
line 27170: # ifndef INVALID_FILE_ATTRIBUTES 
line 27171: # define INVALID_FILE_ATTRIBUTES ( ( DWORD ) - 1 ) 
line 27172: # endif 
line 27178: # if SQLITE_OS_WINCE 
line 27179: # define AreFileApisANSI ( ) 1 
line 27180: # define FormatMessageW ( a , b , c , d , e , f , g ) 0 
line 27181: # endif 
line 27187: # if SQLITE_OS_WINCE 
line 27188: typedef struct winceLock { 
line 27189: int nReaders ; 
line 27190: BOOL bPending ; 
line 27191: BOOL bReserved ; 
line 27192: BOOL bExclusive ; 
line 27193: } winceLock ; 
line 27194: # endif 
line 27200: typedef struct winFile winFile ; 
line 27201: struct winFile { 
line 27202: const sqlite3_io_methods * pMethod ; 
line 27203: HANDLE h ; 
line 27204: unsigned char locktype ; 
line 27205: short sharedLockByte ; 
line 27206: DWORD lastErrno ; 
line 27207: DWORD sectorSize ; 
line 27208: # if SQLITE_OS_WINCE 
line 27209: WCHAR * zDeleteOnClose ; 
line 27210: HANDLE hMutex ; 
line 27211: HANDLE hShared ; 
line 27212: winceLock local ; 
line 27213: winceLock * shared ; 
line 27214: # endif 
line 27215: } ; 
line 27220: static int getSectorSize ( 
line 27221: sqlite3_vfs * pVfs , 
line 27222: const char * zRelative 
line 27223: ) ; 
line 27237: # ifdef SQLITE_TEST 
line 27238: SQLITE_API int sqlite3_os_type = 0 ; 
line 27239: # else 
line 27240: static int sqlite3_os_type = 0 ; 
line 27241: # endif 
line 27254: # if SQLITE_OS_WINCE 
line 27255: # define isNT ( ) ( 1 ) 
line 27256: # else 
line 27257: static int isNT ( void ) { 
line 27258: if ( sqlite3_os_type == 0 ) { 
line 27259: OSVERSIONINFO sInfo ; 
line 27260: sInfo . dwOSVersionInfoSize = sizeof ( sInfo ) ; 
line 27261: GetVersionEx ( & sInfo ) ; 
line 27262: sqlite3_os_type = sInfo . dwPlatformId == VER_PLATFORM_WIN32_NT ? 2 : 1 ; 
line 27263: } 
line 27264: return sqlite3_os_type == 2 ; 
line 27265: } 
line 27266: # endif 
line 27273: static WCHAR * utf8ToUnicode ( const char * zFilename ) { 
line 27274: int nChar ; 
line 27275: WCHAR * zWideFilename ; 
line 27277: nChar = MultiByteToWideChar ( CP_UTF8 , 0 , zFilename , - 1 , NULL , 0 ) ; 
line 27278: zWideFilename = malloc ( nChar * sizeof ( zWideFilename [ 0 ] ) ) ; 
line 27279: if ( zWideFilename == 0 ) { 
line 27280: return 0 ; 
line 27281: } 
line 27282: nChar = MultiByteToWideChar ( CP_UTF8 , 0 , zFilename , - 1 , zWideFilename , nChar ) ; 
line 27283: if ( nChar == 0 ) { 
line 27284: free ( zWideFilename ) ; 
line 27285: zWideFilename = 0 ; 
line 27286: } 
line 27287: return zWideFilename ; 
line 27288: } 
line 27294: static char * unicodeToUtf8 ( const WCHAR * zWideFilename ) { 
line 27295: int nByte ; 
line 27296: char * zFilename ; 
line 27298: nByte = WideCharToMultiByte ( CP_UTF8 , 0 , zWideFilename , - 1 , 0 , 0 , 0 , 0 ) ; 
line 27299: zFilename = malloc ( nByte ) ; 
line 27300: if ( zFilename == 0 ) { 
line 27301: return 0 ; 
line 27302: } 
line 27303: nByte = WideCharToMultiByte ( CP_UTF8 , 0 , zWideFilename , - 1 , zFilename , nByte , 
line 27304: 0 , 0 ) ; 
line 27305: if ( nByte == 0 ) { 
line 27306: free ( zFilename ) ; 
line 27307: zFilename = 0 ; 
line 27308: } 
line 27309: return zFilename ; 
line 27310: } 
line 27319: static WCHAR * mbcsToUnicode ( const char * zFilename ) { 
line 27320: int nByte ; 
line 27321: WCHAR * zMbcsFilename ; 
line 27322: int codepage = AreFileApisANSI ( ) ? CP_ACP : CP_OEMCP ; 
line 27324: nByte = MultiByteToWideChar ( codepage , 0 , zFilename , - 1 , NULL , 0 ) * sizeof ( WCHAR ) ; 
line 27325: zMbcsFilename = malloc ( nByte * sizeof ( zMbcsFilename [ 0 ] ) ) ; 
line 27326: if ( zMbcsFilename == 0 ) { 
line 27327: return 0 ; 
line 27328: } 
line 27329: nByte = MultiByteToWideChar ( codepage , 0 , zFilename , - 1 , zMbcsFilename , nByte ) ; 
line 27330: if ( nByte == 0 ) { 
line 27331: free ( zMbcsFilename ) ; 
line 27332: zMbcsFilename = 0 ; 
line 27333: } 
line 27334: return zMbcsFilename ; 
line 27335: } 
line 27344: static char * unicodeToMbcs ( const WCHAR * zWideFilename ) { 
line 27345: int nByte ; 
line 27346: char * zFilename ; 
line 27347: int codepage = AreFileApisANSI ( ) ? CP_ACP : CP_OEMCP ; 
line 27349: nByte = WideCharToMultiByte ( codepage , 0 , zWideFilename , - 1 , 0 , 0 , 0 , 0 ) ; 
line 27350: zFilename = malloc ( nByte ) ; 
line 27351: if ( zFilename == 0 ) { 
line 27352: return 0 ; 
line 27353: } 
line 27354: nByte = WideCharToMultiByte ( codepage , 0 , zWideFilename , - 1 , zFilename , nByte , 
line 27355: 0 , 0 ) ; 
line 27356: if ( nByte == 0 ) { 
line 27357: free ( zFilename ) ; 
line 27358: zFilename = 0 ; 
line 27359: } 
line 27360: return zFilename ; 
line 27361: } 
line 27367: SQLITE_API char * sqlite3_win32_mbcs_to_utf8 ( const char * zFilename ) { 
line 27368: char * zFilenameUtf8 ; 
line 27369: WCHAR * zTmpWide ; 
line 27371: zTmpWide = mbcsToUnicode ( zFilename ) ; 
line 27372: if ( zTmpWide == 0 ) { 
line 27373: return 0 ; 
line 27374: } 
line 27375: zFilenameUtf8 = unicodeToUtf8 ( zTmpWide ) ; 
line 27376: free ( zTmpWide ) ; 
line 27377: return zFilenameUtf8 ; 
line 27378: } 
line 27384: static char * utf8ToMbcs ( const char * zFilename ) { 
line 27385: char * zFilenameMbcs ; 
line 27386: WCHAR * zTmpWide ; 
line 27388: zTmpWide = utf8ToUnicode ( zFilename ) ; 
line 27389: if ( zTmpWide == 0 ) { 
line 27390: return 0 ; 
line 27391: } 
line 27392: zFilenameMbcs = unicodeToMbcs ( zTmpWide ) ; 
line 27393: free ( zTmpWide ) ; 
line 27394: return zFilenameMbcs ; 
line 27395: } 
line 27397: # if SQLITE_OS_WINCE 
line 27405: struct tm * __cdecl localtime ( const time_t * t ) 
line 27406: { 
line 27407: static struct tm y ; 
line 27408: FILETIME uTm , lTm ; 
line 27409: SYSTEMTIME pTm ; 
line 27410: sqlite3_int64 t64 ; 
line 27411: t64 = * t ; 
line 27412: t64 = ( t64 + 11644473600 ) * 10000000 ; 
line 27413: uTm . dwLowDateTime = ( DWORD ) ( t64 & 0xFFFFFFFF ) ; 
line 27414: uTm . dwHighDateTime = ( DWORD ) ( t64 >> 32 ) ; 
line 27415: FileTimeToLocalFileTime ( & uTm , & lTm ) ; 
line 27416: FileTimeToSystemTime ( & lTm , & pTm ) ; 
line 27417: y . tm_year = pTm . wYear - 1900 ; 
line 27418: y . tm_mon = pTm . wMonth - 1 ; 
line 27419: y . tm_wday = pTm . wDayOfWeek ; 
line 27420: y . tm_mday = pTm . wDay ; 
line 27421: y . tm_hour = pTm . wHour ; 
line 27422: y . tm_min = pTm . wMinute ; 
line 27423: y . tm_sec = pTm . wSecond ; 
line 27424: return & y ; 
line 27425: } 
line 27428: # define GetTempPathA ( a , b ) 
line 27430: # define LockFile ( a , b , c , d , e ) winceLockFile ( & a , b , c , d , e ) 
line 27431: # define UnlockFile ( a , b , c , d , e ) winceUnlockFile ( & a , b , c , d , e ) 
line 27432: # define LockFileEx ( a , b , c , d , e , f ) winceLockFileEx ( & a , b , c , d , e , f ) 
line 27434: # define HANDLE_TO_WINFILE ( a ) ( winFile * ) & ( ( char * ) a ) [ - ( int ) offsetof ( winFile , h ) ] 
line 27439: static void winceMutexAcquire ( HANDLE h ) { 
line 27440: DWORD dwErr ; 
line 27441: do { 
line 27442: dwErr = WaitForSingleObject ( h , INFINITE ) ; 
line 27443: } while ( dwErr != WAIT_OBJECT_0 && dwErr != WAIT_ABANDONED ) ; 
line 27444: } 
line 27448: # define winceMutexRelease ( h ) ReleaseMutex ( h ) 
line 27454: static BOOL winceCreateLock ( const char * zFilename , winFile * pFile ) { 
line 27455: WCHAR * zTok ; 
line 27456: WCHAR * zName = utf8ToUnicode ( zFilename ) ; 
line 27457: BOOL bInit = TRUE ; 
line 27460: ZeroMemory ( & pFile -> local , sizeof ( pFile -> local ) ) ; 
line 27464: zTok = CharLowerW ( zName ) ; 
line 27465: for ( ; * zTok ; zTok ++ ) { 
line 27466: if ( * zTok == '\\') *zTok = ' _ 
line 27467: ';
 } 
line 27470: pFile -> hMutex = CreateMutexW ( NULL , FALSE , zName ) ; 
line 27471: if ( ! pFile -> hMutex ) { 
line 27472: pFile -> lastErrno = GetLastError ( ) ; 
line 27473: free ( zName ) ; 
line 27474: return FALSE ; 
line 27475: } 
line 27478: winceMutexAcquire ( pFile -> hMutex ) ; 
line 27484: CharUpperW ( zName ) ; 
line 27485: pFile -> hShared = CreateFileMappingW ( INVALID_HANDLE_VALUE , NULL , 
line 27486: PAGE_READWRITE , 0 , sizeof ( winceLock ) , 
line 27487: zName ) ; 
line 27491: if ( GetLastError ( ) == ERROR_ALREADY_EXISTS ) { 
line 27492: bInit = FALSE ; 
line 27493: } 
line 27495: free ( zName ) ; 
line 27498: if ( pFile -> hShared ) { 
line 27499: pFile -> shared = ( winceLock * ) MapViewOfFile ( pFile -> hShared , 
line 27500: FILE_MAP_READ | FILE_MAP_WRITE , 0 , 0 , sizeof ( winceLock ) ) ; 
line 27502: if ( ! pFile -> shared ) { 
line 27503: pFile -> lastErrno = GetLastError ( ) ; 
line 27504: CloseHandle ( pFile -> hShared ) ; 
line 27505: pFile -> hShared = NULL ; 
line 27506: } 
line 27507: } 
line 27510: if ( pFile -> hShared == NULL ) { 
line 27511: winceMutexRelease ( pFile -> hMutex ) ; 
line 27512: CloseHandle ( pFile -> hMutex ) ; 
line 27513: pFile -> hMutex = NULL ; 
line 27514: return FALSE ; 
line 27515: } 
line 27518: if ( bInit ) { 
line 27519: ZeroMemory ( pFile -> shared , sizeof ( winceLock ) ) ; 
line 27520: } 
line 27522: winceMutexRelease ( pFile -> hMutex ) ; 
line 27523: return TRUE ; 
line 27524: } 
line 27529: static void winceDestroyLock ( winFile * pFile ) { 
line 27530: if ( pFile -> hMutex ) { 
line 27532: winceMutexAcquire ( pFile -> hMutex ) ; 
line 27536: if ( pFile -> local . nReaders ) { 
line 27537: pFile -> shared -> nReaders -- ; 
line 27538: } 
line 27539: if ( pFile -> local . bReserved ) { 
line 27540: pFile -> shared -> bReserved = FALSE ; 
line 27541: } 
line 27542: if ( pFile -> local . bPending ) { 
line 27543: pFile -> shared -> bPending = FALSE ; 
line 27544: } 
line 27545: if ( pFile -> local . bExclusive ) { 
line 27546: pFile -> shared -> bExclusive = FALSE ; 
line 27547: } 
line 27550: UnmapViewOfFile ( pFile -> shared ) ; 
line 27551: CloseHandle ( pFile -> hShared ) ; 
line 27554: winceMutexRelease ( pFile -> hMutex ) ; 
line 27555: CloseHandle ( pFile -> hMutex ) ; 
line 27556: pFile -> hMutex = NULL ; 
line 27557: } 
line 27558: } 
line 27563: static BOOL winceLockFile ( 
line 27564: HANDLE * phFile , 
line 27565: DWORD dwFileOffsetLow , 
line 27566: DWORD dwFileOffsetHigh , 
line 27567: DWORD nNumberOfBytesToLockLow , 
line 27568: DWORD nNumberOfBytesToLockHigh 
line 27569: ) { 
line 27570: winFile * pFile = HANDLE_TO_WINFILE ( phFile ) ; 
line 27571: BOOL bReturn = FALSE ; 
line 27573: UNUSED_PARAMETER ( dwFileOffsetHigh ) ; 
line 27574: UNUSED_PARAMETER ( nNumberOfBytesToLockHigh ) ; 
line 27576: if ( ! pFile -> hMutex ) return TRUE ; 
line 27577: winceMutexAcquire ( pFile -> hMutex ) ; 
line 27580: if ( dwFileOffsetLow == ( DWORD ) SHARED_FIRST 
line 27581: && nNumberOfBytesToLockLow == ( DWORD ) SHARED_SIZE ) { 
line 27582: if ( pFile -> shared -> nReaders == 0 && pFile -> shared -> bExclusive == 0 ) { 
line 27583: pFile -> shared -> bExclusive = TRUE ; 
line 27584: pFile -> local . bExclusive = TRUE ; 
line 27585: bReturn = TRUE ; 
line 27586: } 
line 27587: } 
line 27590: else if ( dwFileOffsetLow == ( DWORD ) SHARED_FIRST && 
line 27591: nNumberOfBytesToLockLow == 1 ) { 
line 27592: if ( pFile -> shared -> bExclusive == 0 ) { 
line 27593: pFile -> local . nReaders ++ ; 
line 27594: if ( pFile -> local . nReaders == 1 ) { 
line 27595: pFile -> shared -> nReaders ++ ; 
line 27596: } 
line 27597: bReturn = TRUE ; 
line 27598: } 
line 27599: } 
line 27602: else if ( dwFileOffsetLow == ( DWORD ) PENDING_BYTE && nNumberOfBytesToLockLow == 1 ) { 
line 27604: if ( pFile -> shared -> bPending == 0 ) { 
line 27605: pFile -> shared -> bPending = TRUE ; 
line 27606: pFile -> local . bPending = TRUE ; 
line 27607: bReturn = TRUE ; 
line 27608: } 
line 27609: } 
line 27612: else if ( dwFileOffsetLow == ( DWORD ) RESERVED_BYTE && nNumberOfBytesToLockLow == 1 ) { 
line 27613: if ( pFile -> shared -> bReserved == 0 ) { 
line 27614: pFile -> shared -> bReserved = TRUE ; 
line 27615: pFile -> local . bReserved = TRUE ; 
line 27616: bReturn = TRUE ; 
line 27617: } 
line 27618: } 
line 27620: winceMutexRelease ( pFile -> hMutex ) ; 
line 27621: return bReturn ; 
line 27622: } 
line 27627: static BOOL winceUnlockFile ( 
line 27628: HANDLE * phFile , 
line 27629: DWORD dwFileOffsetLow , 
line 27630: DWORD dwFileOffsetHigh , 
line 27631: DWORD nNumberOfBytesToUnlockLow , 
line 27632: DWORD nNumberOfBytesToUnlockHigh 
line 27633: ) { 
line 27634: winFile * pFile = HANDLE_TO_WINFILE ( phFile ) ; 
line 27635: BOOL bReturn = FALSE ; 
line 27637: UNUSED_PARAMETER ( dwFileOffsetHigh ) ; 
line 27638: UNUSED_PARAMETER ( nNumberOfBytesToUnlockHigh ) ; 
line 27640: if ( ! pFile -> hMutex ) return TRUE ; 
line 27641: winceMutexAcquire ( pFile -> hMutex ) ; 
line 27644: if ( dwFileOffsetLow == ( DWORD ) SHARED_FIRST ) { 
line 27646: if ( pFile -> local . bExclusive ) { 
line 27647: assert ( nNumberOfBytesToUnlockLow == ( DWORD ) SHARED_SIZE ) ; 
line 27648: pFile -> local . bExclusive = FALSE ; 
line 27649: pFile -> shared -> bExclusive = FALSE ; 
line 27650: bReturn = TRUE ; 
line 27651: } 
line 27654: else if ( pFile -> local . nReaders ) { 
line 27655: assert ( nNumberOfBytesToUnlockLow == ( DWORD ) SHARED_SIZE || nNumberOfBytesToUnlockLow == 1 ) ; 
line 27656: pFile -> local . nReaders -- ; 
line 27657: if ( pFile -> local . nReaders == 0 ) 
line 27658: { 
line 27659: pFile -> shared -> nReaders -- ; 
line 27660: } 
line 27661: bReturn = TRUE ; 
line 27662: } 
line 27663: } 
line 27666: else if ( dwFileOffsetLow == ( DWORD ) PENDING_BYTE && nNumberOfBytesToUnlockLow == 1 ) { 
line 27667: if ( pFile -> local . bPending ) { 
line 27668: pFile -> local . bPending = FALSE ; 
line 27669: pFile -> shared -> bPending = FALSE ; 
line 27670: bReturn = TRUE ; 
line 27671: } 
line 27672: } 
line 27674: else if ( dwFileOffsetLow == ( DWORD ) RESERVED_BYTE && nNumberOfBytesToUnlockLow == 1 ) { 
line 27675: if ( pFile -> local . bReserved ) { 
line 27676: pFile -> local . bReserved = FALSE ; 
line 27677: pFile -> shared -> bReserved = FALSE ; 
line 27678: bReturn = TRUE ; 
line 27679: } 
line 27680: } 
line 27682: winceMutexRelease ( pFile -> hMutex ) ; 
line 27683: return bReturn ; 
line 27684: } 
line 27689: static BOOL winceLockFileEx ( 
line 27690: HANDLE * phFile , 
line 27691: DWORD dwFlags , 
line 27692: DWORD dwReserved , 
line 27693: DWORD nNumberOfBytesToLockLow , 
line 27694: DWORD nNumberOfBytesToLockHigh , 
line 27695: LPOVERLAPPED lpOverlapped 
line 27696: ) { 
line 27697: UNUSED_PARAMETER ( dwReserved ) ; 
line 27698: UNUSED_PARAMETER ( nNumberOfBytesToLockHigh ) ; 
line 27702: if ( lpOverlapped -> Offset == ( DWORD ) SHARED_FIRST && 
line 27703: dwFlags == 1 && 
line 27704: nNumberOfBytesToLockLow == ( DWORD ) SHARED_SIZE ) { 
line 27705: return winceLockFile ( phFile , SHARED_FIRST , 0 , 1 , 0 ) ; 
line 27706: } 
line 27707: return FALSE ; 
line 27708: } 
line 27712: # endif 
line 27729: # define MX_CLOSE_ATTEMPT 3 
line 27730: static int winClose ( sqlite3_file * id ) { 
line 27731: int rc , cnt = 0 ; 
line 27732: winFile * pFile = ( winFile * ) id ; 
line 27734: assert ( id != 0 ) ; 
line 27735: OSTRACE2 ( "CLOSE %d\n" , pFile -> h ) ; 
line 27736: do { 
line 27737: rc = CloseHandle ( pFile -> h ) ; 
line 27738: } while ( rc == 0 && ++ cnt < MX_CLOSE_ATTEMPT && ( Sleep ( 100 ) , 1 ) ) ; 
line 27739: # if SQLITE_OS_WINCE 
line 27740: # define WINCE_DELETION_ATTEMPTS 3 
line 27741: winceDestroyLock ( pFile ) ; 
line 27742: if ( pFile -> zDeleteOnClose ) { 
line 27743: int cnt = 0 ; 
line 27744: while ( 
line 27745: DeleteFileW ( pFile -> zDeleteOnClose ) == 0 
line 27746: && GetFileAttributesW ( pFile -> zDeleteOnClose ) != 0xffffffff 
line 27747: && cnt ++ < WINCE_DELETION_ATTEMPTS 
line 27748: ) { 
line 27749: Sleep ( 100 ) ; 
line 27750: } 
line 27751: free ( pFile -> zDeleteOnClose ) ; 
line 27752: } 
line 27753: # endif 
line 27754: OpenCounter ( - 1 ) ; 
line 27755: return rc ? SQLITE_OK : SQLITE_IOERR ; 
line 27756: } 
line 27761: # ifndef INVALID_SET_FILE_POINTER 
line 27762: # define INVALID_SET_FILE_POINTER ( ( DWORD ) - 1 ) 
line 27763: # endif 
line 27770: static int winRead ( 
line 27771: sqlite3_file * id , 
line 27772: void * pBuf , 
line 27773: int amt , 
line 27774: sqlite3_int64 offset 
line 27775: ) { 
line 27776: LONG upperBits = ( LONG ) ( ( offset >> 32 ) & 0x7fffffff ) ; 
line 27777: LONG lowerBits = ( LONG ) ( offset & 0xffffffff ) ; 
line 27778: DWORD rc ; 
line 27779: winFile * pFile = ( winFile * ) id ; 
line 27780: DWORD error ; 
line 27781: DWORD got ; 
line 27783: assert ( id != 0 ) ; 
line 27784: SimulateIOError ( return SQLITE_IOERR_READ ) ; 
line 27785: OSTRACE3 ( "READ %d lock=%d\n" , pFile -> h , pFile -> locktype ) ; 
line 27786: rc = SetFilePointer ( pFile -> h , lowerBits , & upperBits , FILE_BEGIN ) ; 
line 27787: if ( rc == INVALID_SET_FILE_POINTER && ( error = GetLastError ( ) ) != NO_ERROR ) { 
line 27788: pFile -> lastErrno = error ; 
line 27789: return SQLITE_FULL ; 
line 27790: } 
line 27791: if ( ! ReadFile ( pFile -> h , pBuf , amt , & got , 0 ) ) { 
line 27792: pFile -> lastErrno = GetLastError ( ) ; 
line 27793: return SQLITE_IOERR_READ ; 
line 27794: } 
line 27795: if ( got == ( DWORD ) amt ) { 
line 27796: return SQLITE_OK ; 
line 27797: } else { 
line 27799: memset ( & ( ( char * ) pBuf ) [ got ] , 0 , amt - got ) ; 
line 27800: return SQLITE_IOERR_SHORT_READ ; 
line 27801: } 
line 27802: } 
line 27808: static int winWrite ( 
line 27809: sqlite3_file * id , 
line 27810: const void * pBuf , 
line 27811: int amt , 
line 27812: sqlite3_int64 offset 
line 27813: ) { 
line 27814: LONG upperBits = ( LONG ) ( ( offset >> 32 ) & 0x7fffffff ) ; 
line 27815: LONG lowerBits = ( LONG ) ( offset & 0xffffffff ) ; 
line 27816: DWORD rc ; 
line 27817: winFile * pFile = ( winFile * ) id ; 
line 27818: DWORD error ; 
line 27819: DWORD wrote = 0 ; 
line 27821: assert ( id != 0 ) ; 
line 27822: SimulateIOError ( return SQLITE_IOERR_WRITE ) ; 
line 27823: SimulateDiskfullError ( return SQLITE_FULL ) ; 
line 27824: OSTRACE3 ( "WRITE %d lock=%d\n" , pFile -> h , pFile -> locktype ) ; 
line 27825: rc = SetFilePointer ( pFile -> h , lowerBits , & upperBits , FILE_BEGIN ) ; 
line 27826: if ( rc == INVALID_SET_FILE_POINTER && ( error = GetLastError ( ) ) != NO_ERROR ) { 
line 27827: pFile -> lastErrno = error ; 
line 27828: return SQLITE_FULL ; 
line 27829: } 
line 27830: assert ( amt > 0 ) ; 
line 27831: while ( 
line 27832: amt > 0 
line 27833: && ( rc = WriteFile ( pFile -> h , pBuf , amt , & wrote , 0 ) ) != 0 
line 27834: && wrote > 0 
line 27835: ) { 
line 27836: amt -= wrote ; 
line 27837: pBuf = & ( ( char * ) pBuf ) [ wrote ] ; 
line 27838: } 
line 27839: if ( ! rc || amt > ( int ) wrote ) { 
line 27840: pFile -> lastErrno = GetLastError ( ) ; 
line 27841: return SQLITE_FULL ; 
line 27842: } 
line 27843: return SQLITE_OK ; 
line 27844: } 
line 27849: static int winTruncate ( sqlite3_file * id , sqlite3_int64 nByte ) { 
line 27850: LONG upperBits = ( LONG ) ( ( nByte >> 32 ) & 0x7fffffff ) ; 
line 27851: LONG lowerBits = ( LONG ) ( nByte & 0xffffffff ) ; 
line 27852: DWORD rc ; 
line 27853: winFile * pFile = ( winFile * ) id ; 
line 27854: DWORD error ; 
line 27856: assert ( id != 0 ) ; 
line 27857: OSTRACE3 ( "TRUNCATE %d %lld\n" , pFile -> h , nByte ) ; 
line 27858: SimulateIOError ( return SQLITE_IOERR_TRUNCATE ) ; 
line 27859: rc = SetFilePointer ( pFile -> h , lowerBits , & upperBits , FILE_BEGIN ) ; 
line 27860: if ( rc == INVALID_SET_FILE_POINTER && ( error = GetLastError ( ) ) != NO_ERROR ) { 
line 27861: pFile -> lastErrno = error ; 
line 27862: return SQLITE_IOERR_TRUNCATE ; 
line 27863: } 
line 27865: if ( ! SetEndOfFile ( pFile -> h ) ) { 
line 27866: pFile -> lastErrno = GetLastError ( ) ; 
line 27867: return SQLITE_IOERR_TRUNCATE ; 
line 27868: } 
line 27869: return SQLITE_OK ; 
line 27870: } 
line 27872: # ifdef SQLITE_TEST 
line 27877: SQLITE_API int sqlite3_sync_count = 0 ; 
line 27878: SQLITE_API int sqlite3_fullsync_count = 0 ; 
line 27879: # endif 
line 27884: static int winSync ( sqlite3_file * id , int flags ) { 
line 27885: # ifndef SQLITE_NO_SYNC 
line 27886: winFile * pFile = ( winFile * ) id ; 
line 27888: assert ( id != 0 ) ; 
line 27889: OSTRACE3 ( "SYNC %d lock=%d\n" , pFile -> h , pFile -> locktype ) ; 
line 27890: # else 
line 27891: UNUSED_PARAMETER ( id ) ; 
line 27892: # endif 
line 27893: # ifndef SQLITE_TEST 
line 27894: UNUSED_PARAMETER ( flags ) ; 
line 27895: # else 
line 27896: if ( flags & SQLITE_SYNC_FULL ) { 
line 27897: sqlite3_fullsync_count ++ ; 
line 27898: } 
line 27899: sqlite3_sync_count ++ ; 
line 27900: # endif 
line 27904: # ifdef SQLITE_NO_SYNC 
line 27905: return SQLITE_OK ; 
line 27906: # else 
line 27907: if ( FlushFileBuffers ( pFile -> h ) ) { 
line 27908: return SQLITE_OK ; 
line 27909: } else { 
line 27910: pFile -> lastErrno = GetLastError ( ) ; 
line 27911: return SQLITE_IOERR ; 
line 27912: } 
line 27913: # endif 
line 27914: } 
line 27919: static int winFileSize ( sqlite3_file * id , sqlite3_int64 * pSize ) { 
line 27920: DWORD upperBits ; 
line 27921: DWORD lowerBits ; 
line 27922: winFile * pFile = ( winFile * ) id ; 
line 27923: DWORD error ; 
line 27925: assert ( id != 0 ) ; 
line 27926: SimulateIOError ( return SQLITE_IOERR_FSTAT ) ; 
line 27927: lowerBits = GetFileSize ( pFile -> h , & upperBits ) ; 
line 27928: if ( ( lowerBits == INVALID_FILE_SIZE ) 
line 27929: && ( ( error = GetLastError ( ) ) != NO_ERROR ) ) 
line 27930: { 
line 27931: pFile -> lastErrno = error ; 
line 27932: return SQLITE_IOERR_FSTAT ; 
line 27933: } 
line 27934: * pSize = ( ( ( sqlite3_int64 ) upperBits ) << 32 ) + lowerBits ; 
line 27935: return SQLITE_OK ; 
line 27936: } 
line 27941: # ifndef LOCKFILE_FAIL_IMMEDIATELY 
line 27942: # define LOCKFILE_FAIL_IMMEDIATELY 1 
line 27943: # endif 
line 27950: static int getReadLock ( winFile * pFile ) { 
line 27951: int res ; 
line 27952: if ( isNT ( ) ) { 
line 27953: OVERLAPPED ovlp ; 
line 27954: ovlp . Offset = SHARED_FIRST ; 
line 27955: ovlp . OffsetHigh = 0 ; 
line 27956: ovlp . hEvent = 0 ; 
line 27957: res = LockFileEx ( pFile -> h , LOCKFILE_FAIL_IMMEDIATELY , 
line 27958: 0 , SHARED_SIZE , 0 , & ovlp ) ; 
line 27961: # if SQLITE_OS_WINCE == 0 
line 27962: } else { 
line 27963: int lk ; 
line 27964: sqlite3_randomness ( sizeof ( lk ) , & lk ) ; 
line 27965: pFile -> sharedLockByte = ( short ) ( ( lk & 0x7fffffff ) % ( SHARED_SIZE - 1 ) ) ; 
line 27966: res = LockFile ( pFile -> h , SHARED_FIRST + pFile -> sharedLockByte , 0 , 1 , 0 ) ; 
line 27967: # endif 
line 27968: } 
line 27969: if ( res == 0 ) { 
line 27970: pFile -> lastErrno = GetLastError ( ) ; 
line 27971: } 
line 27972: return res ; 
line 27973: } 
line 27978: static int unlockReadLock ( winFile * pFile ) { 
line 27979: int res ; 
line 27980: if ( isNT ( ) ) { 
line 27981: res = UnlockFile ( pFile -> h , SHARED_FIRST , 0 , SHARED_SIZE , 0 ) ; 
line 27984: # if SQLITE_OS_WINCE == 0 
line 27985: } else { 
line 27986: res = UnlockFile ( pFile -> h , SHARED_FIRST + pFile -> sharedLockByte , 0 , 1 , 0 ) ; 
line 27987: # endif 
line 27988: } 
line 27989: if ( res == 0 ) { 
line 27990: pFile -> lastErrno = GetLastError ( ) ; 
line 27991: } 
line 27992: return res ; 
line 27993: } 
line 28021: static int winLock ( sqlite3_file * id , int locktype ) { 
line 28022: int rc = SQLITE_OK ; 
line 28023: int res = 1 ; 
line 28024: int newLocktype ; 
line 28025: int gotPendingLock = 0 ; 
line 28026: winFile * pFile = ( winFile * ) id ; 
line 28027: DWORD error = NO_ERROR ; 
line 28029: assert ( id != 0 ) ; 
line 28030: OSTRACE5 ( "LOCK %d %d was %d(%d)\n" , 
line 28031: pFile -> h , locktype , pFile -> locktype , pFile -> sharedLockByte ) ; 
line 28037: if ( pFile -> locktype >= locktype ) { 
line 28038: return SQLITE_OK ; 
line 28039: } 
line 28043: assert ( pFile -> locktype != NO_LOCK || locktype == SHARED_LOCK ) ; 
line 28044: assert ( locktype != PENDING_LOCK ) ; 
line 28045: assert ( locktype != RESERVED_LOCK || pFile -> locktype == SHARED_LOCK ) ; 
line 28051: newLocktype = pFile -> locktype ; 
line 28052: if ( ( pFile -> locktype == NO_LOCK ) 
line 28053: || ( ( locktype == EXCLUSIVE_LOCK ) 
line 28054: && ( pFile -> locktype == RESERVED_LOCK ) ) 
line 28055: ) { 
line 28056: int cnt = 3 ; 
line 28057: while ( cnt -- > 0 && ( res = LockFile ( pFile -> h , PENDING_BYTE , 0 , 1 , 0 ) ) == 0 ) { 
line 28061: OSTRACE2 ( "could not get a PENDING lock. cnt=%d\n" , cnt ) ; 
line 28062: Sleep ( 1 ) ; 
line 28063: } 
line 28064: gotPendingLock = res ; 
line 28065: if ( ! res ) { 
line 28066: error = GetLastError ( ) ; 
line 28067: } 
line 28068: } 
line 28072: if ( locktype == SHARED_LOCK && res ) { 
line 28073: assert ( pFile -> locktype == NO_LOCK ) ; 
line 28074: res = getReadLock ( pFile ) ; 
line 28075: if ( res ) { 
line 28076: newLocktype = SHARED_LOCK ; 
line 28077: } else { 
line 28078: error = GetLastError ( ) ; 
line 28079: } 
line 28080: } 
line 28084: if ( locktype == RESERVED_LOCK && res ) { 
line 28085: assert ( pFile -> locktype == SHARED_LOCK ) ; 
line 28086: res = LockFile ( pFile -> h , RESERVED_BYTE , 0 , 1 , 0 ) ; 
line 28087: if ( res ) { 
line 28088: newLocktype = RESERVED_LOCK ; 
line 28089: } else { 
line 28090: error = GetLastError ( ) ; 
line 28091: } 
line 28092: } 
line 28096: if ( locktype == EXCLUSIVE_LOCK && res ) { 
line 28097: newLocktype = PENDING_LOCK ; 
line 28098: gotPendingLock = 0 ; 
line 28099: } 
line 28103: if ( locktype == EXCLUSIVE_LOCK && res ) { 
line 28104: assert ( pFile -> locktype >= SHARED_LOCK ) ; 
line 28105: res = unlockReadLock ( pFile ) ; 
line 28106: OSTRACE2 ( "unreadlock = %d\n" , res ) ; 
line 28107: res = LockFile ( pFile -> h , SHARED_FIRST , 0 , SHARED_SIZE , 0 ) ; 
line 28108: if ( res ) { 
line 28109: newLocktype = EXCLUSIVE_LOCK ; 
line 28110: } else { 
line 28111: error = GetLastError ( ) ; 
line 28112: OSTRACE2 ( "error-code = %d\n" , error ) ; 
line 28113: getReadLock ( pFile ) ; 
line 28114: } 
line 28115: } 
line 28120: if ( gotPendingLock && locktype == SHARED_LOCK ) { 
line 28121: UnlockFile ( pFile -> h , PENDING_BYTE , 0 , 1 , 0 ) ; 
line 28122: } 
line 28127: if ( res ) { 
line 28128: rc = SQLITE_OK ; 
line 28129: } else { 
line 28130: OSTRACE4 ( "LOCK FAILED %d trying for %d but got %d\n" , pFile -> h , 
line 28131: locktype , newLocktype ) ; 
line 28132: pFile -> lastErrno = error ; 
line 28133: rc = SQLITE_BUSY ; 
line 28134: } 
line 28135: pFile -> locktype = ( u8 ) newLocktype ; 
line 28136: return rc ; 
line 28137: } 
line 28144: static int winCheckReservedLock ( sqlite3_file * id , int * pResOut ) { 
line 28145: int rc ; 
line 28146: winFile * pFile = ( winFile * ) id ; 
line 28148: assert ( id != 0 ) ; 
line 28149: if ( pFile -> locktype >= RESERVED_LOCK ) { 
line 28150: rc = 1 ; 
line 28151: OSTRACE3 ( "TEST WR-LOCK %d %d (local)\n" , pFile -> h , rc ) ; 
line 28152: } else { 
line 28153: rc = LockFile ( pFile -> h , RESERVED_BYTE , 0 , 1 , 0 ) ; 
line 28154: if ( rc ) { 
line 28155: UnlockFile ( pFile -> h , RESERVED_BYTE , 0 , 1 , 0 ) ; 
line 28156: } 
line 28157: rc = ! rc ; 
line 28158: OSTRACE3 ( "TEST WR-LOCK %d %d (remote)\n" , pFile -> h , rc ) ; 
line 28159: } 
line 28160: * pResOut = rc ; 
line 28161: return SQLITE_OK ; 
line 28162: } 
line 28175: static int winUnlock ( sqlite3_file * id , int locktype ) { 
line 28176: int type ; 
line 28177: winFile * pFile = ( winFile * ) id ; 
line 28178: int rc = SQLITE_OK ; 
line 28179: assert ( pFile != 0 ) ; 
line 28180: assert ( locktype <= SHARED_LOCK ) ; 
line 28181: OSTRACE5 ( "UNLOCK %d to %d was %d(%d)\n" , pFile -> h , locktype , 
line 28182: pFile -> locktype , pFile -> sharedLockByte ) ; 
line 28183: type = pFile -> locktype ; 
line 28184: if ( type >= EXCLUSIVE_LOCK ) { 
line 28185: UnlockFile ( pFile -> h , SHARED_FIRST , 0 , SHARED_SIZE , 0 ) ; 
line 28186: if ( locktype == SHARED_LOCK && ! getReadLock ( pFile ) ) { 
line 28189: rc = SQLITE_IOERR_UNLOCK ; 
line 28190: } 
line 28191: } 
line 28192: if ( type >= RESERVED_LOCK ) { 
line 28193: UnlockFile ( pFile -> h , RESERVED_BYTE , 0 , 1 , 0 ) ; 
line 28194: } 
line 28195: if ( locktype == NO_LOCK && type >= SHARED_LOCK ) { 
line 28196: unlockReadLock ( pFile ) ; 
line 28197: } 
line 28198: if ( type >= PENDING_LOCK ) { 
line 28199: UnlockFile ( pFile -> h , PENDING_BYTE , 0 , 1 , 0 ) ; 
line 28200: } 
line 28201: pFile -> locktype = ( u8 ) locktype ; 
line 28202: return rc ; 
line 28203: } 
line 28208: static int winFileControl ( sqlite3_file * id , int op , void * pArg ) { 
line 28209: switch ( op ) { 
line 28210: case SQLITE_FCNTL_LOCKSTATE : { 
line 28211: * ( int * ) pArg = ( ( winFile * ) id ) -> locktype ; 
line 28212: return SQLITE_OK ; 
line 28213: } 
line 28214: case SQLITE_LAST_ERRNO : { 
line 28215: * ( int * ) pArg = ( int ) ( ( winFile * ) id ) -> lastErrno ; 
line 28216: return SQLITE_OK ; 
line 28217: } 
line 28218: } 
line 28219: return SQLITE_ERROR ; 
line 28220: } 
line 28232: static int winSectorSize ( sqlite3_file * id ) { 
line 28233: assert ( id != 0 ) ; 
line 28234: return ( int ) ( ( ( winFile * ) id ) -> sectorSize ) ; 
line 28235: } 
line 28240: static int winDeviceCharacteristics ( sqlite3_file * id ) { 
line 28241: UNUSED_PARAMETER ( id ) ; 
line 28242: return 0 ; 
line 28243: } 
line 28249: static const sqlite3_io_methods winIoMethod = { 
line 28250: 1 , 
line 28251: winClose , 
line 28252: winRead , 
line 28253: winWrite , 
line 28254: winTruncate , 
line 28255: winSync , 
line 28256: winFileSize , 
line 28257: winLock , 
line 28258: winUnlock , 
line 28259: winCheckReservedLock , 
line 28260: winFileControl , 
line 28261: winSectorSize , 
line 28262: winDeviceCharacteristics 
line 28263: } ; 
line 28277: static void * convertUtf8Filename ( const char * zFilename ) { 
line 28278: void * zConverted = 0 ; 
line 28279: if ( isNT ( ) ) { 
line 28280: zConverted = utf8ToUnicode ( zFilename ) ; 
line 28283: # if SQLITE_OS_WINCE == 0 
line 28284: } else { 
line 28285: zConverted = utf8ToMbcs ( zFilename ) ; 
line 28286: # endif 
line 28287: } 
line 28289: return zConverted ; 
line 28290: } 
line 28296: static int getTempname ( int nBuf , char * zBuf ) { 
line 28297: static char zChars [ ] = 
line 28298: "abcdefghijklmnopqrstuvwxyz" 
line 28299: "ABCDEFGHIJKLMNOPQRSTUVWXYZ" 
line 28300: "0123456789" ; 
line 28301: size_t i , j ; 
line 28302: char zTempPath [ MAX_PATH + 1 ] ; 
line 28303: if ( sqlite3_temp_directory ) { 
line 28304: sqlite3_snprintf ( MAX_PATH - 30 , zTempPath , "%s" , sqlite3_temp_directory ) ; 
line 28305: } else if ( isNT ( ) ) { 
line 28306: char * zMulti ; 
line 28307: WCHAR zWidePath [ MAX_PATH ] ; 
line 28308: GetTempPathW ( MAX_PATH - 30 , zWidePath ) ; 
line 28309: zMulti = unicodeToUtf8 ( zWidePath ) ; 
line 28310: if ( zMulti ) { 
line 28311: sqlite3_snprintf ( MAX_PATH - 30 , zTempPath , "%s" , zMulti ) ; 
line 28312: free ( zMulti ) ; 
line 28313: } else { 
line 28314: return SQLITE_NOMEM ; 
line 28315: } 
line 28320: # if SQLITE_OS_WINCE == 0 
line 28321: } else { 
line 28322: char * zUtf8 ; 
line 28323: char zMbcsPath [ MAX_PATH ] ; 
line 28324: GetTempPathA ( MAX_PATH - 30 , zMbcsPath ) ; 
line 28325: zUtf8 = sqlite3_win32_mbcs_to_utf8 ( zMbcsPath ) ; 
line 28326: if ( zUtf8 ) { 
line 28327: sqlite3_snprintf ( MAX_PATH - 30 , zTempPath , "%s" , zUtf8 ) ; 
line 28328: free ( zUtf8 ) ; 
line 28329: } else { 
line 28330: return SQLITE_NOMEM ; 
line 28331: } 
line 28332: # endif 
line 28333: } 
line 28334: for ( i = sqlite3Strlen30 ( zTempPath ) ; i > 0 && zTempPath [ i - 1 ] == 
line 28335: '\\'; i--){}
 zTempPath [ i ] = 0 ; 
line 28336: sqlite3_snprintf ( nBuf - 30 , zBuf , 
line 28338: "%s\\"SQLITE_TEMP_FILE_PREFIX, zTempPath);
 j = sqlite3Strlen30 ( zBuf ) ; 
line 28339: sqlite3_randomness ( 20 , & zBuf [ j ] ) ; 
line 28340: for ( i = 0 ; i < 20 ; i ++ , j ++ ) { 
line 28341: zBuf [ j ] = ( char ) zChars [ ( ( unsigned char ) zBuf [ j ] ) % ( sizeof ( zChars ) - 1 ) ] ; 
line 28342: } 
line 28343: zBuf [ j ] = 0 ; 
line 28344: OSTRACE2 ( "TEMP FILENAME: %s\n" , zBuf ) ; 
line 28345: return SQLITE_OK ; 
line 28346: } 
line 28353: static int getLastErrorMsg ( int nBuf , char * zBuf ) { 
line 28358: DWORD error = GetLastError ( ) ; 
line 28359: DWORD dwLen = 0 ; 
line 28360: char * zOut = 0 ; 
line 28362: if ( isNT ( ) ) { 
line 28363: WCHAR * zTempWide = NULL ; 
line 28364: dwLen = FormatMessageW ( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS , 
line 28365: NULL , 
line 28366: error , 
line 28367: 0 , 
line 28368: ( LPWSTR ) & zTempWide , 
line 28369: 0 , 
line 28370: 0 ) ; 
line 28371: if ( dwLen > 0 ) { 
line 28373: zOut = unicodeToUtf8 ( zTempWide ) ; 
line 28375: LocalFree ( zTempWide ) ; 
line 28376: } 
line 28381: # if SQLITE_OS_WINCE == 0 
line 28382: } else { 
line 28383: char * zTemp = NULL ; 
line 28384: dwLen = FormatMessageA ( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS , 
line 28385: NULL , 
line 28386: error , 
line 28387: 0 , 
line 28388: ( LPSTR ) & zTemp , 
line 28389: 0 , 
line 28390: 0 ) ; 
line 28391: if ( dwLen > 0 ) { 
line 28393: zOut = sqlite3_win32_mbcs_to_utf8 ( zTemp ) ; 
line 28395: LocalFree ( zTemp ) ; 
line 28396: } 
line 28397: # endif 
line 28398: } 
line 28399: if ( 0 == dwLen ) { 
line 28400: sqlite3_snprintf ( nBuf , zBuf , "OsError 0x%x (%u)" , error , error ) ; 
line 28401: } else { 
line 28403: sqlite3_snprintf ( nBuf , zBuf , "%s" , zOut ) ; 
line 28405: free ( zOut ) ; 
line 28406: } 
line 28407: return 0 ; 
line 28408: } 
line 28413: static int winOpen ( 
line 28414: sqlite3_vfs * pVfs , 
line 28415: const char * zName , 
line 28416: sqlite3_file * id , 
line 28417: int flags , 
line 28418: int * pOutFlags 
line 28419: ) { 
line 28420: HANDLE h ; 
line 28421: DWORD dwDesiredAccess ; 
line 28422: DWORD dwShareMode ; 
line 28423: DWORD dwCreationDisposition ; 
line 28424: DWORD dwFlagsAndAttributes = 0 ; 
line 28425: # if SQLITE_OS_WINCE 
line 28426: int isTemp = 0 ; 
line 28427: # endif 
line 28428: winFile * pFile = ( winFile * ) id ; 
line 28429: void * zConverted ; 
line 28430: const char * zUtf8Name = zName ; 
line 28431: char zTmpname [ MAX_PATH + 1 ] ; 
line 28433: assert ( id != 0 ) ; 
line 28434: UNUSED_PARAMETER ( pVfs ) ; 
line 28439: if ( ! zUtf8Name ) { 
line 28440: int rc = getTempname ( MAX_PATH + 1 , zTmpname ) ; 
line 28441: if ( rc != SQLITE_OK ) { 
line 28442: return rc ; 
line 28443: } 
line 28444: zUtf8Name = zTmpname ; 
line 28445: } 
line 28448: zConverted = convertUtf8Filename ( zUtf8Name ) ; 
line 28449: if ( zConverted == 0 ) { 
line 28450: return SQLITE_NOMEM ; 
line 28451: } 
line 28453: if ( flags & SQLITE_OPEN_READWRITE ) { 
line 28454: dwDesiredAccess = GENERIC_READ | GENERIC_WRITE ; 
line 28455: } else { 
line 28456: dwDesiredAccess = GENERIC_READ ; 
line 28457: } 
line 28462: assert ( ! ( flags & SQLITE_OPEN_EXCLUSIVE ) || ( flags & SQLITE_OPEN_CREATE ) ) ; 
line 28463: if ( flags & SQLITE_OPEN_EXCLUSIVE ) { 
line 28466: dwCreationDisposition = CREATE_NEW ; 
line 28467: } else if ( flags & SQLITE_OPEN_CREATE ) { 
line 28469: dwCreationDisposition = OPEN_ALWAYS ; 
line 28470: } else { 
line 28472: dwCreationDisposition = OPEN_EXISTING ; 
line 28473: } 
line 28474: dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE ; 
line 28475: if ( flags & SQLITE_OPEN_DELETEONCLOSE ) { 
line 28476: # if SQLITE_OS_WINCE 
line 28477: dwFlagsAndAttributes = FILE_ATTRIBUTE_HIDDEN ; 
line 28478: isTemp = 1 ; 
line 28479: # else 
line 28480: dwFlagsAndAttributes = FILE_ATTRIBUTE_TEMPORARY 
line 28481: | FILE_ATTRIBUTE_HIDDEN 
line 28482: | FILE_FLAG_DELETE_ON_CLOSE ; 
line 28483: # endif 
line 28484: } else { 
line 28485: dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL ; 
line 28486: } 
line 28489: # if SQLITE_OS_WINCE 
line 28490: dwFlagsAndAttributes |= FILE_FLAG_RANDOM_ACCESS ; 
line 28491: # endif 
line 28492: if ( isNT ( ) ) { 
line 28493: h = CreateFileW ( ( WCHAR * ) zConverted , 
line 28494: dwDesiredAccess , 
line 28495: dwShareMode , 
line 28496: NULL , 
line 28497: dwCreationDisposition , 
line 28498: dwFlagsAndAttributes , 
line 28499: NULL 
line 28500: ) ; 
line 28505: # if SQLITE_OS_WINCE == 0 
line 28506: } else { 
line 28507: h = CreateFileA ( ( char * ) zConverted , 
line 28508: dwDesiredAccess , 
line 28509: dwShareMode , 
line 28510: NULL , 
line 28511: dwCreationDisposition , 
line 28512: dwFlagsAndAttributes , 
line 28513: NULL 
line 28514: ) ; 
line 28515: # endif 
line 28516: } 
line 28517: if ( h == INVALID_HANDLE_VALUE ) { 
line 28518: free ( zConverted ) ; 
line 28519: if ( flags & SQLITE_OPEN_READWRITE ) { 
line 28520: return winOpen ( pVfs , zName , id , 
line 28521: ( ( flags | SQLITE_OPEN_READONLY ) & ~ SQLITE_OPEN_READWRITE ) , pOutFlags ) ; 
line 28522: } else { 
line 28523: return SQLITE_CANTOPEN ; 
line 28524: } 
line 28525: } 
line 28526: if ( pOutFlags ) { 
line 28527: if ( flags & SQLITE_OPEN_READWRITE ) { 
line 28528: * pOutFlags = SQLITE_OPEN_READWRITE ; 
line 28529: } else { 
line 28530: * pOutFlags = SQLITE_OPEN_READONLY ; 
line 28531: } 
line 28532: } 
line 28533: memset ( pFile , 0 , sizeof ( * pFile ) ) ; 
line 28534: pFile -> pMethod = & winIoMethod ; 
line 28535: pFile -> h = h ; 
line 28536: pFile -> lastErrno = NO_ERROR ; 
line 28537: pFile -> sectorSize = getSectorSize ( pVfs , zUtf8Name ) ; 
line 28538: # if SQLITE_OS_WINCE 
line 28539: if ( ( flags & ( SQLITE_OPEN_READWRITE | SQLITE_OPEN_MAIN_DB ) ) == 
line 28540: ( SQLITE_OPEN_READWRITE | SQLITE_OPEN_MAIN_DB ) 
line 28541: && ! winceCreateLock ( zName , pFile ) 
line 28542: ) { 
line 28543: CloseHandle ( h ) ; 
line 28544: free ( zConverted ) ; 
line 28545: return SQLITE_CANTOPEN ; 
line 28546: } 
line 28547: if ( isTemp ) { 
line 28548: pFile -> zDeleteOnClose = zConverted ; 
line 28549: } else 
line 28550: # endif 
line 28551: { 
line 28552: free ( zConverted ) ; 
line 28553: } 
line 28554: OpenCounter ( + 1 ) ; 
line 28555: return SQLITE_OK ; 
line 28556: } 
line 28570: # define MX_DELETION_ATTEMPTS 5 
line 28571: static int winDelete ( 
line 28572: sqlite3_vfs * pVfs , 
line 28573: const char * zFilename , 
line 28574: int syncDir 
line 28575: ) { 
line 28576: int cnt = 0 ; 
line 28577: DWORD rc ; 
line 28578: DWORD error = 0 ; 
line 28579: void * zConverted = convertUtf8Filename ( zFilename ) ; 
line 28580: UNUSED_PARAMETER ( pVfs ) ; 
line 28581: UNUSED_PARAMETER ( syncDir ) ; 
line 28582: if ( zConverted == 0 ) { 
line 28583: return SQLITE_NOMEM ; 
line 28584: } 
line 28585: SimulateIOError ( return SQLITE_IOERR_DELETE ) ; 
line 28586: if ( isNT ( ) ) { 
line 28587: do { 
line 28588: DeleteFileW ( zConverted ) ; 
line 28589: } while ( ( ( ( rc = GetFileAttributesW ( zConverted ) ) != INVALID_FILE_ATTRIBUTES ) 
line 28590: || ( ( error = GetLastError ( ) ) == ERROR_ACCESS_DENIED ) ) 
line 28591: && ( ++ cnt < MX_DELETION_ATTEMPTS ) 
line 28592: && ( Sleep ( 100 ) , 1 ) ) ; 
line 28597: # if SQLITE_OS_WINCE == 0 
line 28598: } else { 
line 28599: do { 
line 28600: DeleteFileA ( zConverted ) ; 
line 28601: } while ( ( ( ( rc = GetFileAttributesA ( zConverted ) ) != INVALID_FILE_ATTRIBUTES ) 
line 28602: || ( ( error = GetLastError ( ) ) == ERROR_ACCESS_DENIED ) ) 
line 28603: && ( ++ cnt < MX_DELETION_ATTEMPTS ) 
line 28604: && ( Sleep ( 100 ) , 1 ) ) ; 
line 28605: # endif 
line 28606: } 
line 28607: free ( zConverted ) ; 
line 28608: OSTRACE2 ( "DELETE \"%s\"\n" , zFilename ) ; 
line 28609: return ( ( rc == INVALID_FILE_ATTRIBUTES ) 
line 28610: && ( error == ERROR_FILE_NOT_FOUND ) ) ? SQLITE_OK : SQLITE_IOERR_DELETE ; 
line 28611: } 
line 28616: static int winAccess ( 
line 28617: sqlite3_vfs * pVfs , 
line 28618: const char * zFilename , 
line 28619: int flags , 
line 28620: int * pResOut 
line 28621: ) { 
line 28622: DWORD attr ; 
line 28623: int rc = 0 ; 
line 28624: void * zConverted = convertUtf8Filename ( zFilename ) ; 
line 28625: UNUSED_PARAMETER ( pVfs ) ; 
line 28626: if ( zConverted == 0 ) { 
line 28627: return SQLITE_NOMEM ; 
line 28628: } 
line 28629: if ( isNT ( ) ) { 
line 28630: attr = GetFileAttributesW ( ( WCHAR * ) zConverted ) ; 
line 28635: # if SQLITE_OS_WINCE == 0 
line 28636: } else { 
line 28637: attr = GetFileAttributesA ( ( char * ) zConverted ) ; 
line 28638: # endif 
line 28639: } 
line 28640: free ( zConverted ) ; 
line 28641: switch ( flags ) { 
line 28642: case SQLITE_ACCESS_READ : 
line 28643: case SQLITE_ACCESS_EXISTS : 
line 28644: rc = attr != INVALID_FILE_ATTRIBUTES ; 
line 28645: break ; 
line 28646: case SQLITE_ACCESS_READWRITE : 
line 28647: rc = ( attr & FILE_ATTRIBUTE_READONLY ) == 0 ; 
line 28648: break ; 
line 28649: default : 
line 28650: assert ( ! "Invalid flags argument" ) ; 
line 28651: } 
line 28652: * pResOut = rc ; 
line 28653: return SQLITE_OK ; 
line 28654: } 
line 28662: static int winFullPathname ( 
line 28663: sqlite3_vfs * pVfs , 
line 28664: const char * zRelative , 
line 28665: int nFull , 
line 28666: char * zFull 
line 28667: ) { 
line 28669: # if defined ( __CYGWIN__ ) 
line 28670: UNUSED_PARAMETER ( nFull ) ; 
line 28671: cygwin_conv_to_full_win32_path ( zRelative , zFull ) ; 
line 28672: return SQLITE_OK ; 
line 28673: # endif 
line 28675: # if SQLITE_OS_WINCE 
line 28676: UNUSED_PARAMETER ( nFull ) ; 
line 28678: sqlite3_snprintf ( pVfs -> mxPathname , zFull , "%s" , zRelative ) ; 
line 28679: return SQLITE_OK ; 
line 28680: # endif 
line 28682: # if ! SQLITE_OS_WINCE && ! defined ( __CYGWIN__ ) 
line 28683: int nByte ; 
line 28684: void * zConverted ; 
line 28685: char * zOut ; 
line 28686: UNUSED_PARAMETER ( nFull ) ; 
line 28687: zConverted = convertUtf8Filename ( zRelative ) ; 
line 28688: if ( isNT ( ) ) { 
line 28689: WCHAR * zTemp ; 
line 28690: nByte = GetFullPathNameW ( ( WCHAR * ) zConverted , 0 , 0 , 0 ) + 3 ; 
line 28691: zTemp = malloc ( nByte * sizeof ( zTemp [ 0 ] ) ) ; 
line 28692: if ( zTemp == 0 ) { 
line 28693: free ( zConverted ) ; 
line 28694: return SQLITE_NOMEM ; 
line 28695: } 
line 28696: GetFullPathNameW ( ( WCHAR * ) zConverted , nByte , zTemp , 0 ) ; 
line 28697: free ( zConverted ) ; 
line 28698: zOut = unicodeToUtf8 ( zTemp ) ; 
line 28699: free ( zTemp ) ; 
line 28704: # if SQLITE_OS_WINCE == 0 
line 28705: } else { 
line 28706: char * zTemp ; 
line 28707: nByte = GetFullPathNameA ( ( char * ) zConverted , 0 , 0 , 0 ) + 3 ; 
line 28708: zTemp = malloc ( nByte * sizeof ( zTemp [ 0 ] ) ) ; 
line 28709: if ( zTemp == 0 ) { 
line 28710: free ( zConverted ) ; 
line 28711: return SQLITE_NOMEM ; 
line 28712: } 
line 28713: GetFullPathNameA ( ( char * ) zConverted , nByte , zTemp , 0 ) ; 
line 28714: free ( zConverted ) ; 
line 28715: zOut = sqlite3_win32_mbcs_to_utf8 ( zTemp ) ; 
line 28716: free ( zTemp ) ; 
line 28717: # endif 
line 28718: } 
line 28719: if ( zOut ) { 
line 28720: sqlite3_snprintf ( pVfs -> mxPathname , zFull , "%s" , zOut ) ; 
line 28721: free ( zOut ) ; 
line 28722: return SQLITE_OK ; 
line 28723: } else { 
line 28724: return SQLITE_NOMEM ; 
line 28725: } 
line 28726: # endif 
line 28727: } 
line 28733: static int getSectorSize ( 
line 28734: sqlite3_vfs * pVfs , 
line 28735: const char * zRelative 
line 28736: ) { 
line 28737: DWORD bytesPerSector = SQLITE_DEFAULT_SECTOR_SIZE ; 
line 28739: # if SQLITE_OS_WINCE 
line 28740: UNUSED_PARAMETER ( pVfs ) ; 
line 28741: UNUSED_PARAMETER ( zRelative ) ; 
line 28742: # else 
line 28743: char zFullpath [ MAX_PATH + 1 ] ; 
line 28744: int rc ; 
line 28745: DWORD dwRet = 0 ; 
line 28746: DWORD dwDummy ; 
line 28753: rc = winFullPathname ( pVfs , zRelative , MAX_PATH , zFullpath ) ; 
line 28754: if ( rc == SQLITE_OK ) 
line 28755: { 
line 28756: void * zConverted = convertUtf8Filename ( zFullpath ) ; 
line 28757: if ( zConverted ) { 
line 28758: if ( isNT ( ) ) { 
line 28760: WCHAR * p = zConverted ; 
line 28761: for ( ; * p ; p ++ ) { 
line 28762: if ( * p == 
line 28763: '\\' ){
 * p = '\0' ; 
line 28764: break ; 
line 28765: } 
line 28766: } 
line 28767: dwRet = GetDiskFreeSpaceW ( ( WCHAR * ) zConverted , 
line 28768: & dwDummy , 
line 28769: & bytesPerSector , 
line 28770: & dwDummy , 
line 28771: & dwDummy ) ; 
line 28772: } else { 
line 28774: char * p = ( char * ) zConverted ; 
line 28775: for ( ; * p ; p ++ ) { 
line 28776: if ( * p == 
line 28777: '\\' ){
 * p = '\0' ; 
line 28778: break ; 
line 28779: } 
line 28780: } 
line 28781: dwRet = GetDiskFreeSpaceA ( ( char * ) zConverted , 
line 28782: & dwDummy , 
line 28783: & bytesPerSector , 
line 28784: & dwDummy , 
line 28785: & dwDummy ) ; 
line 28786: } 
line 28787: free ( zConverted ) ; 
line 28788: } 
line 28789: if ( ! dwRet ) { 
line 28790: bytesPerSector = SQLITE_DEFAULT_SECTOR_SIZE ; 
line 28791: } 
line 28792: } 
line 28793: # endif 
line 28794: return ( int ) bytesPerSector ; 
line 28795: } 
line 28797: # ifndef SQLITE_OMIT_LOAD_EXTENSION 
line 28806: static void * winDlOpen ( sqlite3_vfs * pVfs , const char * zFilename ) { 
line 28807: HANDLE h ; 
line 28808: void * zConverted = convertUtf8Filename ( zFilename ) ; 
line 28809: UNUSED_PARAMETER ( pVfs ) ; 
line 28810: if ( zConverted == 0 ) { 
line 28811: return 0 ; 
line 28812: } 
line 28813: if ( isNT ( ) ) { 
line 28814: h = LoadLibraryW ( ( WCHAR * ) zConverted ) ; 
line 28819: # if SQLITE_OS_WINCE == 0 
line 28820: } else { 
line 28821: h = LoadLibraryA ( ( char * ) zConverted ) ; 
line 28822: # endif 
line 28823: } 
line 28824: free ( zConverted ) ; 
line 28825: return ( void * ) h ; 
line 28826: } 
line 28827: static void winDlError ( sqlite3_vfs * pVfs , int nBuf , char * zBufOut ) { 
line 28828: UNUSED_PARAMETER ( pVfs ) ; 
line 28829: getLastErrorMsg ( nBuf , zBufOut ) ; 
line 28830: } 
line 28831: void ( * winDlSym ( sqlite3_vfs * pVfs , void * pHandle , const char * zSymbol ) ) ( void ) { 
line 28832: UNUSED_PARAMETER ( pVfs ) ; 
line 28833: # if SQLITE_OS_WINCE 
line 28835: return ( void ( * ) ( void ) ) GetProcAddressA ( ( HANDLE ) pHandle , zSymbol ) ; 
line 28836: # else 
line 28839: return ( void ( * ) ( void ) ) GetProcAddress ( ( HANDLE ) pHandle , zSymbol ) ; 
line 28840: # endif 
line 28841: } 
line 28842: void winDlClose ( sqlite3_vfs * pVfs , void * pHandle ) { 
line 28843: UNUSED_PARAMETER ( pVfs ) ; 
line 28844: FreeLibrary ( ( HANDLE ) pHandle ) ; 
line 28845: } 
line 28846: # else 
line 28847: # define winDlOpen 0 
line 28848: # define winDlError 0 
line 28849: # define winDlSym 0 
line 28850: # define winDlClose 0 
line 28851: # endif 
line 28857: static int winRandomness ( sqlite3_vfs * pVfs , int nBuf , char * zBuf ) { 
line 28858: int n = 0 ; 
line 28859: UNUSED_PARAMETER ( pVfs ) ; 
line 28860: # if defined ( SQLITE_TEST ) 
line 28861: n = nBuf ; 
line 28862: memset ( zBuf , 0 , nBuf ) ; 
line 28863: # else 
line 28864: if ( sizeof ( SYSTEMTIME ) <= nBuf - n ) { 
line 28865: SYSTEMTIME x ; 
line 28866: GetSystemTime ( & x ) ; 
line 28867: memcpy ( & zBuf [ n ] , & x , sizeof ( x ) ) ; 
line 28868: n += sizeof ( x ) ; 
line 28869: } 
line 28870: if ( sizeof ( DWORD ) <= nBuf - n ) { 
line 28871: DWORD pid = GetCurrentProcessId ( ) ; 
line 28872: memcpy ( & zBuf [ n ] , & pid , sizeof ( pid ) ) ; 
line 28873: n += sizeof ( pid ) ; 
line 28874: } 
line 28875: if ( sizeof ( DWORD ) <= nBuf - n ) { 
line 28876: DWORD cnt = GetTickCount ( ) ; 
line 28877: memcpy ( & zBuf [ n ] , & cnt , sizeof ( cnt ) ) ; 
line 28878: n += sizeof ( cnt ) ; 
line 28879: } 
line 28880: if ( sizeof ( LARGE_INTEGER ) <= nBuf - n ) { 
line 28881: LARGE_INTEGER i ; 
line 28882: QueryPerformanceCounter ( & i ) ; 
line 28883: memcpy ( & zBuf [ n ] , & i , sizeof ( i ) ) ; 
line 28884: n += sizeof ( i ) ; 
line 28885: } 
line 28886: # endif 
line 28887: return n ; 
line 28888: } 
line 28894: static int winSleep ( sqlite3_vfs * pVfs , int microsec ) { 
line 28895: Sleep ( ( microsec + 999 ) / 1000 ) ; 
line 28896: UNUSED_PARAMETER ( pVfs ) ; 
line 28897: return ( ( microsec + 999 ) / 1000 ) * 1000 ; 
line 28898: } 
line 28904: # ifdef SQLITE_TEST 
line 28905: SQLITE_API int sqlite3_current_time = 0 ; 
line 28906: # endif 
line 28913: int winCurrentTime ( sqlite3_vfs * pVfs , double * prNow ) { 
line 28914: FILETIME ft ; 
line 28918: sqlite3_int64 timeW ; 
line 28919: sqlite3_int64 timeF ; 
line 28922: static const sqlite3_int64 ntuPerDay = 
line 28923: 10000000 * ( sqlite3_int64 ) 86400 ; 
line 28926: static const sqlite3_int64 ntuPerHalfDay = 
line 28927: 10000000 * ( sqlite3_int64 ) 43200 ; 
line 28930: static const sqlite3_int64 max32BitValue = 
line 28931: ( sqlite3_int64 ) 2000000000 + ( sqlite3_int64 ) 2000000000 + ( sqlite3_int64 ) 294967296 ; 
line 28933: # if SQLITE_OS_WINCE 
line 28934: SYSTEMTIME time ; 
line 28935: GetSystemTime ( & time ) ; 
line 28937: if ( ! SystemTimeToFileTime ( & time , & ft ) ) { 
line 28938: return 1 ; 
line 28939: } 
line 28940: # else 
line 28941: GetSystemTimeAsFileTime ( & ft ) ; 
line 28942: # endif 
line 28943: UNUSED_PARAMETER ( pVfs ) ; 
line 28944: timeW = ( ( ( sqlite3_int64 ) ft . dwHighDateTime ) * max32BitValue ) + ( sqlite3_int64 ) ft . dwLowDateTime ; 
line 28945: timeF = timeW % ntuPerDay ; 
line 28946: timeW = timeW / ntuPerDay ; 
line 28947: timeW = timeW + 2305813 ; 
line 28948: timeF = timeF + ntuPerHalfDay ; 
line 28949: timeW = timeW + ( timeF / ntuPerDay ) ; 
line 28950: timeF = timeF % ntuPerDay ; 
line 28951: * prNow = ( double ) timeW + ( ( double ) timeF / ( double ) ntuPerDay ) ; 
line 28952: # ifdef SQLITE_TEST 
line 28953: if ( sqlite3_current_time ) { 
line 28954: * prNow = ( ( double ) sqlite3_current_time + ( double ) 43200 ) / ( double ) 86400 + ( double ) 2440587 ; 
line 28955: } 
line 28956: # endif 
line 28957: return 0 ; 
line 28958: } 
line 28990: static int winGetLastError ( sqlite3_vfs * pVfs , int nBuf , char * zBuf ) { 
line 28991: UNUSED_PARAMETER ( pVfs ) ; 
line 28992: return getLastErrorMsg ( nBuf , zBuf ) ; 
line 28993: } 
line 28998: SQLITE_API int sqlite3_os_init ( void ) { 
line 28999: static sqlite3_vfs winVfs = { 
line 29000: 1 , 
line 29001: sizeof ( winFile ) , 
line 29002: MAX_PATH , 
line 29003: 0 , 
line 29004: "win32" , 
line 29005: 0 , 
line 29007: winOpen , 
line 29008: winDelete , 
line 29009: winAccess , 
line 29010: winFullPathname , 
line 29011: winDlOpen , 
line 29012: winDlError , 
line 29013: winDlSym , 
line 29014: winDlClose , 
line 29015: winRandomness , 
line 29016: winSleep , 
line 29017: winCurrentTime , 
line 29018: winGetLastError 
line 29019: } ; 
line 29021: sqlite3_vfs_register ( & winVfs , 1 ) ; 
line 29022: return SQLITE_OK ; 
line 29023: } 
line 29024: SQLITE_API int sqlite3_os_end ( void ) { 
line 29025: return SQLITE_OK ; 
line 29026: } 
line 29028: # endif 
line 29070: # define BITVEC_SZ ( sizeof ( void * ) * 128 ) 
line 29074: # define BITVEC_USIZE ( ( ( BITVEC_SZ - ( 3 * sizeof ( u32 ) ) ) / sizeof ( Bitvec * ) ) * sizeof ( Bitvec * ) ) 
line 29080: # define BITVEC_TELEM u8 
line 29082: # define BITVEC_SZELEM 8 
line 29084: # define BITVEC_NELEM ( BITVEC_USIZE / sizeof ( BITVEC_TELEM ) ) 
line 29086: # define BITVEC_NBIT ( BITVEC_NELEM * BITVEC_SZELEM ) 
line 29089: # define BITVEC_NINT ( BITVEC_USIZE / sizeof ( u32 ) ) 
line 29092: # define BITVEC_MXHASH ( BITVEC_NINT / 2 ) 
line 29097: # define BITVEC_HASH ( X ) ( ( ( X ) * 1 ) % BITVEC_NINT ) 
line 29099: # define BITVEC_NPTR ( BITVEC_USIZE / sizeof ( Bitvec * ) ) 
line 29123: struct Bitvec { 
line 29124: u32 iSize ; 
line 29125: u32 nSet ; 
line 29128: u32 iDivisor ; 
line 29132: union { 
line 29133: BITVEC_TELEM aBitmap [ BITVEC_NELEM ] ; 
line 29134: u32 aHash [ BITVEC_NINT ] ; 
line 29135: Bitvec * apSub [ BITVEC_NPTR ] ; 
line 29136: } u ; 
line 29137: } ; 
line 29144: SQLITE_PRIVATE Bitvec * sqlite3BitvecCreate ( u32 iSize ) { 
line 29145: Bitvec * p ; 
line 29146: assert ( sizeof ( * p ) == BITVEC_SZ ) ; 
line 29147: p = sqlite3MallocZero ( sizeof ( * p ) ) ; 
line 29148: if ( p ) { 
line 29149: p -> iSize = iSize ; 
line 29150: } 
line 29151: return p ; 
line 29152: } 
line 29159: SQLITE_PRIVATE int sqlite3BitvecTest ( Bitvec * p , u32 i ) { 
line 29160: if ( p == 0 ) return 0 ; 
line 29161: if ( i > p -> iSize || i == 0 ) return 0 ; 
line 29162: i -- ; 
line 29163: while ( p -> iDivisor ) { 
line 29164: u32 bin = i / p -> iDivisor ; 
line 29165: i = i % p -> iDivisor ; 
line 29166: p = p -> u . apSub [ bin ] ; 
line 29167: if ( ! p ) { 
line 29168: return 0 ; 
line 29169: } 
line 29170: } 
line 29171: if ( p -> iSize <= BITVEC_NBIT ) { 
line 29172: return ( p -> u . aBitmap [ i / BITVEC_SZELEM ] & ( 1 << ( i & ( BITVEC_SZELEM - 1 ) ) ) ) != 0 ; 
line 29173: } else { 
line 29174: u32 h = BITVEC_HASH ( i ++ ) ; 
line 29175: while ( p -> u . aHash [ h ] ) { 
line 29176: if ( p -> u . aHash [ h ] == i ) return 1 ; 
line 29177: h = ( h + 1 ) % BITVEC_NINT ; 
line 29178: } 
line 29179: return 0 ; 
line 29180: } 
line 29181: } 
line 29195: SQLITE_PRIVATE int sqlite3BitvecSet ( Bitvec * p , u32 i ) { 
line 29196: u32 h ; 
line 29197: if ( p == 0 ) return SQLITE_OK ; 
line 29198: assert ( i > 0 ) ; 
line 29199: assert ( i <= p -> iSize ) ; 
line 29200: i -- ; 
line 29201: while ( ( p -> iSize > BITVEC_NBIT ) && p -> iDivisor ) { 
line 29202: u32 bin = i / p -> iDivisor ; 
line 29203: i = i % p -> iDivisor ; 
line 29204: if ( p -> u . apSub [ bin ] == 0 ) { 
line 29205: p -> u . apSub [ bin ] = sqlite3BitvecCreate ( p -> iDivisor ) ; 
line 29206: if ( p -> u . apSub [ bin ] == 0 ) return SQLITE_NOMEM ; 
line 29207: } 
line 29208: p = p -> u . apSub [ bin ] ; 
line 29209: } 
line 29210: if ( p -> iSize <= BITVEC_NBIT ) { 
line 29211: p -> u . aBitmap [ i / BITVEC_SZELEM ] |= 1 << ( i & ( BITVEC_SZELEM - 1 ) ) ; 
line 29212: return SQLITE_OK ; 
line 29213: } 
line 29214: h = BITVEC_HASH ( i ++ ) ; 
line 29218: if ( ! p -> u . aHash [ h ] ) { 
line 29219: if ( p -> nSet < ( BITVEC_NINT - 1 ) ) { 
line 29220: goto bitvec_set_end ; 
line 29221: } else { 
line 29222: goto bitvec_set_rehash ; 
line 29223: } 
line 29224: } 
line 29227: do { 
line 29228: if ( p -> u . aHash [ h ] == i ) return SQLITE_OK ; 
line 29229: h ++ ; 
line 29230: if ( h >= BITVEC_NINT ) h = 0 ; 
line 29231: } while ( p -> u . aHash [ h ] ) ; 
line 29235: bitvec_set_rehash : 
line 29236: if ( p -> nSet >= BITVEC_MXHASH ) { 
line 29237: unsigned int j ; 
line 29238: int rc ; 
line 29239: u32 * aiValues = sqlite3StackAllocRaw ( 0 , sizeof ( p -> u . aHash ) ) ; 
line 29240: if ( aiValues == 0 ) { 
line 29241: return SQLITE_NOMEM ; 
line 29242: } else { 
line 29243: memcpy ( aiValues , p -> u . aHash , sizeof ( p -> u . aHash ) ) ; 
line 29244: memset ( p -> u . apSub , 0 , sizeof ( p -> u . apSub ) ) ; 
line 29245: p -> iDivisor = ( p -> iSize + BITVEC_NPTR - 1 ) / BITVEC_NPTR ; 
line 29246: rc = sqlite3BitvecSet ( p , i ) ; 
line 29247: for ( j = 0 ; j < BITVEC_NINT ; j ++ ) { 
line 29248: if ( aiValues [ j ] ) rc |= sqlite3BitvecSet ( p , aiValues [ j ] ) ; 
line 29249: } 
line 29250: sqlite3StackFree ( 0 , aiValues ) ; 
line 29251: return rc ; 
line 29252: } 
line 29253: } 
line 29254: bitvec_set_end : 
line 29255: p -> nSet ++ ; 
line 29256: p -> u . aHash [ h ] = i ; 
line 29257: return SQLITE_OK ; 
line 29258: } 
line 29266: SQLITE_PRIVATE void sqlite3BitvecClear ( Bitvec * p , u32 i , void * pBuf ) { 
line 29267: if ( p == 0 ) return ; 
line 29268: assert ( i > 0 ) ; 
line 29269: i -- ; 
line 29270: while ( p -> iDivisor ) { 
line 29271: u32 bin = i / p -> iDivisor ; 
line 29272: i = i % p -> iDivisor ; 
line 29273: p = p -> u . apSub [ bin ] ; 
line 29274: if ( ! p ) { 
line 29275: return ; 
line 29276: } 
line 29277: } 
line 29278: if ( p -> iSize <= BITVEC_NBIT ) { 
line 29279: p -> u . aBitmap [ i / BITVEC_SZELEM ] &= ~ ( 1 << ( i & ( BITVEC_SZELEM - 1 ) ) ) ; 
line 29280: } else { 
line 29281: unsigned int j ; 
line 29282: u32 * aiValues = pBuf ; 
line 29283: memcpy ( aiValues , p -> u . aHash , sizeof ( p -> u . aHash ) ) ; 
line 29284: memset ( p -> u . aHash , 0 , sizeof ( p -> u . aHash ) ) ; 
line 29285: p -> nSet = 0 ; 
line 29286: for ( j = 0 ; j < BITVEC_NINT ; j ++ ) { 
line 29287: if ( aiValues [ j ] && aiValues [ j ] != ( i + 1 ) ) { 
line 29288: u32 h = BITVEC_HASH ( aiValues [ j ] - 1 ) ; 
line 29289: p -> nSet ++ ; 
line 29290: while ( p -> u . aHash [ h ] ) { 
line 29291: h ++ ; 
line 29292: if ( h >= BITVEC_NINT ) h = 0 ; 
line 29293: } 
line 29294: p -> u . aHash [ h ] = aiValues [ j ] ; 
line 29295: } 
line 29296: } 
line 29297: } 
line 29298: } 
line 29303: SQLITE_PRIVATE void sqlite3BitvecDestroy ( Bitvec * p ) { 
line 29304: if ( p == 0 ) return ; 
line 29305: if ( p -> iDivisor ) { 
line 29306: unsigned int i ; 
line 29307: for ( i = 0 ; i < BITVEC_NPTR ; i ++ ) { 
line 29308: sqlite3BitvecDestroy ( p -> u . apSub [ i ] ) ; 
line 29309: } 
line 29310: } 
line 29311: sqlite3_free ( p ) ; 
line 29312: } 
line 29318: SQLITE_PRIVATE u32 sqlite3BitvecSize ( Bitvec * p ) { 
line 29319: return p -> iSize ; 
line 29320: } 
line 29322: # ifndef SQLITE_OMIT_BUILTIN_TEST 
line 29329: # define SETBIT ( V , I ) V [ I >> 3 ] |= ( 1 << ( I & 7 ) ) 
line 29330: # define CLEARBIT ( V , I ) V [ I >> 3 ] &= ~ ( 1 << ( I & 7 ) ) 
line 29331: # define TESTBIT ( V , I ) ( V [ I >> 3 ] & ( 1 << ( I & 7 ) ) ) != 0 
line 29363: SQLITE_PRIVATE int sqlite3BitvecBuiltinTest ( int sz , int * aOp ) { 
line 29364: Bitvec * pBitvec = 0 ; 
line 29365: unsigned char * pV = 0 ; 
line 29366: int rc = - 1 ; 
line 29367: int i , nx , pc , op ; 
line 29368: void * pTmpSpace ; 
line 29372: pBitvec = sqlite3BitvecCreate ( sz ) ; 
line 29373: pV = sqlite3_malloc ( ( sz + 7 ) / 8 + 1 ) ; 
line 29374: pTmpSpace = sqlite3_malloc ( BITVEC_SZ ) ; 
line 29375: if ( pBitvec == 0 || pV == 0 || pTmpSpace == 0 ) goto bitvec_end ; 
line 29376: memset ( pV , 0 , ( sz + 7 ) / 8 + 1 ) ; 
line 29379: sqlite3BitvecSet ( 0 , 1 ) ; 
line 29380: sqlite3BitvecClear ( 0 , 1 , pTmpSpace ) ; 
line 29383: pc = 0 ; 
line 29384: while ( ( op = aOp [ pc ] ) != 0 ) { 
line 29385: switch ( op ) { 
line 29386: case 1 : 
line 29387: case 2 : 
line 29388: case 5 : { 
line 29389: nx = 4 ; 
line 29390: i = aOp [ pc + 2 ] - 1 ; 
line 29391: aOp [ pc + 2 ] += aOp [ pc + 3 ] ; 
line 29392: break ; 
line 29393: } 
line 29394: case 3 : 
line 29395: case 4 : 
line 29396: default : { 
line 29397: nx = 2 ; 
line 29398: sqlite3_randomness ( sizeof ( i ) , & i ) ; 
line 29399: break ; 
line 29400: } 
line 29401: } 
line 29402: if ( ( -- aOp [ pc + 1 ] ) > 0 ) nx = 0 ; 
line 29403: pc += nx ; 
line 29404: i = ( i & 0x7fffffff ) % sz ; 
line 29405: if ( ( op & 1 ) != 0 ) { 
line 29406: SETBIT ( pV , ( i + 1 ) ) ; 
line 29407: if ( op != 5 ) { 
line 29408: if ( sqlite3BitvecSet ( pBitvec , i + 1 ) ) goto bitvec_end ; 
line 29409: } 
line 29410: } else { 
line 29411: CLEARBIT ( pV , ( i + 1 ) ) ; 
line 29412: sqlite3BitvecClear ( pBitvec , i + 1 , pTmpSpace ) ; 
line 29413: } 
line 29414: } 
line 29421: rc = sqlite3BitvecTest ( 0 , 0 ) + sqlite3BitvecTest ( pBitvec , sz + 1 ) 
line 29422: + sqlite3BitvecTest ( pBitvec , 0 ) 
line 29423: + ( sqlite3BitvecSize ( pBitvec ) - sz ) ; 
line 29424: for ( i = 1 ; i <= sz ; i ++ ) { 
line 29425: if ( ( TESTBIT ( pV , i ) ) != sqlite3BitvecTest ( pBitvec , i ) ) { 
line 29426: rc = i ; 
line 29427: break ; 
line 29428: } 
line 29429: } 
line 29432: bitvec_end : 
line 29433: sqlite3_free ( pTmpSpace ) ; 
line 29434: sqlite3_free ( pV ) ; 
line 29435: sqlite3BitvecDestroy ( pBitvec ) ; 
line 29436: return rc ; 
line 29437: } 
line 29438: # endif 
line 29459: struct PCache { 
line 29460: PgHdr * pDirty , * pDirtyTail ; 
line 29461: PgHdr * pSynced ; 
line 29462: int nRef ; 
line 29463: int nMax ; 
line 29464: int szPage ; 
line 29465: int szExtra ; 
line 29466: int bPurgeable ; 
line 29467: int ( * xStress ) ( void * , PgHdr * ) ; 
line 29468: void * pStress ; 
line 29469: sqlite3_pcache * pCache ; 
line 29470: PgHdr * pPage1 ; 
line 29471: } ; 
line 29479: # ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT 
line 29480: # define expensive_assert ( X ) assert ( X ) 
line 29481: # else 
line 29482: # define expensive_assert ( X ) 
line 29483: # endif 
line 29487: # if ! defined ( NDEBUG ) && defined ( SQLITE_ENABLE_EXPENSIVE_ASSERT ) 
line 29495: static int pcacheCheckSynced ( PCache * pCache ) { 
line 29496: PgHdr * p ; 
line 29497: for ( p = pCache -> pDirtyTail ; p != pCache -> pSynced ; p = p -> pDirtyPrev ) { 
line 29498: assert ( p -> nRef || ( p -> flags & PGHDR_NEED_SYNC ) ) ; 
line 29499: } 
line 29500: return ( p == 0 || p -> nRef || ( p -> flags & PGHDR_NEED_SYNC ) == 0 ) ; 
line 29501: } 
line 29502: # endif 
line 29507: static void pcacheRemoveFromDirtyList ( PgHdr * pPage ) { 
line 29508: PCache * p = pPage -> pCache ; 
line 29510: assert ( pPage -> pDirtyNext || pPage == p -> pDirtyTail ) ; 
line 29511: assert ( pPage -> pDirtyPrev || pPage == p -> pDirty ) ; 
line 29514: if ( p -> pSynced == pPage ) { 
line 29515: PgHdr * pSynced = pPage -> pDirtyPrev ; 
line 29516: while ( pSynced && ( pSynced -> flags & PGHDR_NEED_SYNC ) ) { 
line 29517: pSynced = pSynced -> pDirtyPrev ; 
line 29518: } 
line 29519: p -> pSynced = pSynced ; 
line 29520: } 
line 29522: if ( pPage -> pDirtyNext ) { 
line 29523: pPage -> pDirtyNext -> pDirtyPrev = pPage -> pDirtyPrev ; 
line 29524: } else { 
line 29525: assert ( pPage == p -> pDirtyTail ) ; 
line 29526: p -> pDirtyTail = pPage -> pDirtyPrev ; 
line 29527: } 
line 29528: if ( pPage -> pDirtyPrev ) { 
line 29529: pPage -> pDirtyPrev -> pDirtyNext = pPage -> pDirtyNext ; 
line 29530: } else { 
line 29531: assert ( pPage == p -> pDirty ) ; 
line 29532: p -> pDirty = pPage -> pDirtyNext ; 
line 29533: } 
line 29534: pPage -> pDirtyNext = 0 ; 
line 29535: pPage -> pDirtyPrev = 0 ; 
line 29537: expensive_assert ( pcacheCheckSynced ( p ) ) ; 
line 29538: } 
line 29544: static void pcacheAddToDirtyList ( PgHdr * pPage ) { 
line 29545: PCache * p = pPage -> pCache ; 
line 29547: assert ( pPage -> pDirtyNext == 0 && pPage -> pDirtyPrev == 0 && p -> pDirty != pPage ) ; 
line 29549: pPage -> pDirtyNext = p -> pDirty ; 
line 29550: if ( pPage -> pDirtyNext ) { 
line 29551: assert ( pPage -> pDirtyNext -> pDirtyPrev == 0 ) ; 
line 29552: pPage -> pDirtyNext -> pDirtyPrev = pPage ; 
line 29553: } 
line 29554: p -> pDirty = pPage ; 
line 29555: if ( ! p -> pDirtyTail ) { 
line 29556: p -> pDirtyTail = pPage ; 
line 29557: } 
line 29558: if ( ! p -> pSynced && 0 == ( pPage -> flags & PGHDR_NEED_SYNC ) ) { 
line 29559: p -> pSynced = pPage ; 
line 29560: } 
line 29561: expensive_assert ( pcacheCheckSynced ( p ) ) ; 
line 29562: } 
line 29568: static void pcacheUnpin ( PgHdr * p ) { 
line 29569: PCache * pCache = p -> pCache ; 
line 29570: if ( pCache -> bPurgeable ) { 
line 29571: if ( p -> pgno == 1 ) { 
line 29572: pCache -> pPage1 = 0 ; 
line 29573: } 
line 29574: sqlite3GlobalConfig . pcache . xUnpin ( pCache -> pCache , p , 0 ) ; 
line 29575: } 
line 29576: } 
line 29583: SQLITE_PRIVATE int sqlite3PcacheInitialize ( void ) { 
line 29584: if ( sqlite3GlobalConfig . pcache . xInit == 0 ) { 
line 29585: sqlite3PCacheSetDefault ( ) ; 
line 29586: } 
line 29587: return sqlite3GlobalConfig . pcache . xInit ( sqlite3GlobalConfig . pcache . pArg ) ; 
line 29588: } 
line 29589: SQLITE_PRIVATE void sqlite3PcacheShutdown ( void ) { 
line 29590: if ( sqlite3GlobalConfig . pcache . xShutdown ) { 
line 29591: sqlite3GlobalConfig . pcache . xShutdown ( sqlite3GlobalConfig . pcache . pArg ) ; 
line 29592: } 
line 29593: } 
line 29598: SQLITE_PRIVATE int sqlite3PcacheSize ( void ) { return sizeof ( PCache ) ; } 
line 29606: SQLITE_PRIVATE void sqlite3PcacheOpen ( 
line 29607: int szPage , 
line 29608: int szExtra , 
line 29609: int bPurgeable , 
line 29610: int ( * xStress ) ( void * , PgHdr * ) , 
line 29611: void * pStress , 
line 29612: PCache * p 
line 29613: ) { 
line 29614: memset ( p , 0 , sizeof ( PCache ) ) ; 
line 29615: p -> szPage = szPage ; 
line 29616: p -> szExtra = szExtra ; 
line 29617: p -> bPurgeable = bPurgeable ; 
line 29618: p -> xStress = xStress ; 
line 29619: p -> pStress = pStress ; 
line 29620: p -> nMax = 100 ; 
line 29621: } 
line 29627: SQLITE_PRIVATE void sqlite3PcacheSetPageSize ( PCache * pCache , int szPage ) { 
line 29628: assert ( pCache -> nRef == 0 && pCache -> pDirty == 0 ) ; 
line 29629: if ( pCache -> pCache ) { 
line 29630: sqlite3GlobalConfig . pcache . xDestroy ( pCache -> pCache ) ; 
line 29631: pCache -> pCache = 0 ; 
line 29632: } 
line 29633: pCache -> szPage = szPage ; 
line 29634: } 
line 29639: SQLITE_PRIVATE int sqlite3PcacheFetch ( 
line 29640: PCache * pCache , 
line 29641: Pgno pgno , 
line 29642: int createFlag , 
line 29643: PgHdr * * ppPage 
line 29644: ) { 
line 29645: PgHdr * pPage = 0 ; 
line 29646: int eCreate ; 
line 29648: assert ( pCache != 0 ) ; 
line 29649: assert ( createFlag == 1 || createFlag == 0 ) ; 
line 29650: assert ( pgno > 0 ) ; 
line 29655: if ( ! pCache -> pCache && createFlag ) { 
line 29656: sqlite3_pcache * p ; 
line 29657: int nByte ; 
line 29658: nByte = pCache -> szPage + pCache -> szExtra + sizeof ( PgHdr ) ; 
line 29659: p = sqlite3GlobalConfig . pcache . xCreate ( nByte , pCache -> bPurgeable ) ; 
line 29660: if ( ! p ) { 
line 29661: return SQLITE_NOMEM ; 
line 29662: } 
line 29663: sqlite3GlobalConfig . pcache . xCachesize ( p , pCache -> nMax ) ; 
line 29664: pCache -> pCache = p ; 
line 29665: } 
line 29667: eCreate = createFlag * ( 1 + ( ! pCache -> bPurgeable || ! pCache -> pDirty ) ) ; 
line 29668: if ( pCache -> pCache ) { 
line 29669: pPage = sqlite3GlobalConfig . pcache . xFetch ( pCache -> pCache , pgno , eCreate ) ; 
line 29670: } 
line 29672: if ( ! pPage && eCreate == 1 ) { 
line 29673: PgHdr * pPg ; 
line 29680: expensive_assert ( pcacheCheckSynced ( pCache ) ) ; 
line 29681: for ( pPg = pCache -> pSynced ; 
line 29682: pPg && ( pPg -> nRef || ( pPg -> flags & PGHDR_NEED_SYNC ) ) ; 
line 29683: pPg = pPg -> pDirtyPrev 
line 29684: ) ; 
line 29685: if ( ! pPg ) { 
line 29686: for ( pPg = pCache -> pDirtyTail ; pPg && pPg -> nRef ; pPg = pPg -> pDirtyPrev ) ; 
line 29687: } 
line 29688: if ( pPg ) { 
line 29689: int rc ; 
line 29690: rc = pCache -> xStress ( pCache -> pStress , pPg ) ; 
line 29691: if ( rc != SQLITE_OK && rc != SQLITE_BUSY ) { 
line 29692: return rc ; 
line 29693: } 
line 29694: } 
line 29696: pPage = sqlite3GlobalConfig . pcache . xFetch ( pCache -> pCache , pgno , 2 ) ; 
line 29697: } 
line 29699: if ( pPage ) { 
line 29700: if ( ! pPage -> pData ) { 
line 29701: memset ( pPage , 0 , sizeof ( PgHdr ) + pCache -> szExtra ) ; 
line 29702: pPage -> pExtra = ( void * ) & pPage [ 1 ] ; 
line 29703: pPage -> pData = ( void * ) & ( ( char * ) pPage ) [ sizeof ( PgHdr ) + pCache -> szExtra ] ; 
line 29704: pPage -> pCache = pCache ; 
line 29705: pPage -> pgno = pgno ; 
line 29706: } 
line 29707: assert ( pPage -> pCache == pCache ) ; 
line 29708: assert ( pPage -> pgno == pgno ) ; 
line 29709: assert ( pPage -> pExtra == ( void * ) & pPage [ 1 ] ) ; 
line 29711: if ( 0 == pPage -> nRef ) { 
line 29712: pCache -> nRef ++ ; 
line 29713: } 
line 29714: pPage -> nRef ++ ; 
line 29715: if ( pgno == 1 ) { 
line 29716: pCache -> pPage1 = pPage ; 
line 29717: } 
line 29718: } 
line 29719: * ppPage = pPage ; 
line 29720: return ( pPage == 0 && eCreate ) ? SQLITE_NOMEM : SQLITE_OK ; 
line 29721: } 
line 29727: SQLITE_PRIVATE void sqlite3PcacheRelease ( PgHdr * p ) { 
line 29728: assert ( p -> nRef > 0 ) ; 
line 29729: p -> nRef -- ; 
line 29730: if ( p -> nRef == 0 ) { 
line 29731: PCache * pCache = p -> pCache ; 
line 29732: pCache -> nRef -- ; 
line 29733: if ( ( p -> flags & PGHDR_DIRTY ) == 0 ) { 
line 29734: pcacheUnpin ( p ) ; 
line 29735: } else { 
line 29737: pcacheRemoveFromDirtyList ( p ) ; 
line 29738: pcacheAddToDirtyList ( p ) ; 
line 29739: } 
line 29740: } 
line 29741: } 
line 29746: SQLITE_PRIVATE void sqlite3PcacheRef ( PgHdr * p ) { 
line 29747: assert ( p -> nRef > 0 ) ; 
line 29748: p -> nRef ++ ; 
line 29749: } 
line 29756: SQLITE_PRIVATE void sqlite3PcacheDrop ( PgHdr * p ) { 
line 29757: PCache * pCache ; 
line 29758: assert ( p -> nRef == 1 ) ; 
line 29759: if ( p -> flags & PGHDR_DIRTY ) { 
line 29760: pcacheRemoveFromDirtyList ( p ) ; 
line 29761: } 
line 29762: pCache = p -> pCache ; 
line 29763: pCache -> nRef -- ; 
line 29764: if ( p -> pgno == 1 ) { 
line 29765: pCache -> pPage1 = 0 ; 
line 29766: } 
line 29767: sqlite3GlobalConfig . pcache . xUnpin ( pCache -> pCache , p , 1 ) ; 
line 29768: } 
line 29774: SQLITE_PRIVATE void sqlite3PcacheMakeDirty ( PgHdr * p ) { 
line 29775: p -> flags &= ~ PGHDR_DONT_WRITE ; 
line 29776: assert ( p -> nRef > 0 ) ; 
line 29777: if ( 0 == ( p -> flags & PGHDR_DIRTY ) ) { 
line 29778: p -> flags |= PGHDR_DIRTY ; 
line 29779: pcacheAddToDirtyList ( p ) ; 
line 29780: } 
line 29781: } 
line 29787: SQLITE_PRIVATE void sqlite3PcacheMakeClean ( PgHdr * p ) { 
line 29788: if ( ( p -> flags & PGHDR_DIRTY ) ) { 
line 29789: pcacheRemoveFromDirtyList ( p ) ; 
line 29790: p -> flags &= ~ ( PGHDR_DIRTY | PGHDR_NEED_SYNC ) ; 
line 29791: if ( p -> nRef == 0 ) { 
line 29792: pcacheUnpin ( p ) ; 
line 29793: } 
line 29794: } 
line 29795: } 
line 29800: SQLITE_PRIVATE void sqlite3PcacheCleanAll ( PCache * pCache ) { 
line 29801: PgHdr * p ; 
line 29802: while ( ( p = pCache -> pDirty ) != 0 ) { 
line 29803: sqlite3PcacheMakeClean ( p ) ; 
line 29804: } 
line 29805: } 
line 29810: SQLITE_PRIVATE void sqlite3PcacheClearSyncFlags ( PCache * pCache ) { 
line 29811: PgHdr * p ; 
line 29812: for ( p = pCache -> pDirty ; p ; p = p -> pDirtyNext ) { 
line 29813: p -> flags &= ~ PGHDR_NEED_SYNC ; 
line 29814: } 
line 29815: pCache -> pSynced = pCache -> pDirtyTail ; 
line 29816: } 
line 29821: SQLITE_PRIVATE void sqlite3PcacheMove ( PgHdr * p , Pgno newPgno ) { 
line 29822: PCache * pCache = p -> pCache ; 
line 29823: assert ( p -> nRef > 0 ) ; 
line 29824: assert ( newPgno > 0 ) ; 
line 29825: sqlite3GlobalConfig . pcache . xRekey ( pCache -> pCache , p , p -> pgno , newPgno ) ; 
line 29826: p -> pgno = newPgno ; 
line 29827: if ( ( p -> flags & PGHDR_DIRTY ) && ( p -> flags & PGHDR_NEED_SYNC ) ) { 
line 29828: pcacheRemoveFromDirtyList ( p ) ; 
line 29829: pcacheAddToDirtyList ( p ) ; 
line 29830: } 
line 29831: } 
line 29842: SQLITE_PRIVATE void sqlite3PcacheTruncate ( PCache * pCache , Pgno pgno ) { 
line 29843: if ( pCache -> pCache ) { 
line 29844: PgHdr * p ; 
line 29845: PgHdr * pNext ; 
line 29846: for ( p = pCache -> pDirty ; p ; p = pNext ) { 
line 29847: pNext = p -> pDirtyNext ; 
line 29848: if ( p -> pgno > pgno ) { 
line 29849: assert ( p -> flags & PGHDR_DIRTY ) ; 
line 29850: sqlite3PcacheMakeClean ( p ) ; 
line 29851: } 
line 29852: } 
line 29853: if ( pgno == 0 && pCache -> pPage1 ) { 
line 29854: memset ( pCache -> pPage1 -> pData , 0 , pCache -> szPage ) ; 
line 29855: pgno = 1 ; 
line 29856: } 
line 29857: sqlite3GlobalConfig . pcache . xTruncate ( pCache -> pCache , pgno + 1 ) ; 
line 29858: } 
line 29859: } 
line 29864: SQLITE_PRIVATE void sqlite3PcacheClose ( PCache * pCache ) { 
line 29865: if ( pCache -> pCache ) { 
line 29866: sqlite3GlobalConfig . pcache . xDestroy ( pCache -> pCache ) ; 
line 29867: } 
line 29868: } 
line 29873: SQLITE_PRIVATE void sqlite3PcacheClear ( PCache * pCache ) { 
line 29874: sqlite3PcacheTruncate ( pCache , 0 ) ; 
line 29875: } 
line 29881: static PgHdr * pcacheMergeDirtyList ( PgHdr * pA , PgHdr * pB ) { 
line 29882: PgHdr result , * pTail ; 
line 29883: pTail = & result ; 
line 29884: while ( pA && pB ) { 
line 29885: if ( pA -> pgno < pB -> pgno ) { 
line 29886: pTail -> pDirty = pA ; 
line 29887: pTail = pA ; 
line 29888: pA = pA -> pDirty ; 
line 29889: } else { 
line 29890: pTail -> pDirty = pB ; 
line 29891: pTail = pB ; 
line 29892: pB = pB -> pDirty ; 
line 29893: } 
line 29894: } 
line 29895: if ( pA ) { 
line 29896: pTail -> pDirty = pA ; 
line 29897: } else if ( pB ) { 
line 29898: pTail -> pDirty = pB ; 
line 29899: } else { 
line 29900: pTail -> pDirty = 0 ; 
line 29901: } 
line 29902: return result . pDirty ; 
line 29903: } 
line 29915: # define N_SORT_BUCKET 32 
line 29916: static PgHdr * pcacheSortDirtyList ( PgHdr * pIn ) { 
line 29917: PgHdr * a [ N_SORT_BUCKET ] , * p ; 
line 29918: int i ; 
line 29919: memset ( a , 0 , sizeof ( a ) ) ; 
line 29920: while ( pIn ) { 
line 29921: p = pIn ; 
line 29922: pIn = p -> pDirty ; 
line 29923: p -> pDirty = 0 ; 
line 29924: for ( i = 0 ; ALWAYS ( i < N_SORT_BUCKET - 1 ) ; i ++ ) { 
line 29925: if ( a [ i ] == 0 ) { 
line 29926: a [ i ] = p ; 
line 29927: break ; 
line 29928: } else { 
line 29929: p = pcacheMergeDirtyList ( a [ i ] , p ) ; 
line 29930: a [ i ] = 0 ; 
line 29931: } 
line 29932: } 
line 29933: if ( NEVER ( i == N_SORT_BUCKET - 1 ) ) { 
line 29937: a [ i ] = pcacheMergeDirtyList ( a [ i ] , p ) ; 
line 29938: } 
line 29939: } 
line 29940: p = a [ 0 ] ; 
line 29941: for ( i = 1 ; i < N_SORT_BUCKET ; i ++ ) { 
line 29942: p = pcacheMergeDirtyList ( p , a [ i ] ) ; 
line 29943: } 
line 29944: return p ; 
line 29945: } 
line 29950: SQLITE_PRIVATE PgHdr * sqlite3PcacheDirtyList ( PCache * pCache ) { 
line 29951: PgHdr * p ; 
line 29952: for ( p = pCache -> pDirty ; p ; p = p -> pDirtyNext ) { 
line 29953: p -> pDirty = p -> pDirtyNext ; 
line 29954: } 
line 29955: return pcacheSortDirtyList ( pCache -> pDirty ) ; 
line 29956: } 
line 29961: SQLITE_PRIVATE int sqlite3PcacheRefCount ( PCache * pCache ) { 
line 29962: return pCache -> nRef ; 
line 29963: } 
line 29968: SQLITE_PRIVATE int sqlite3PcachePageRefcount ( PgHdr * p ) { 
line 29969: return p -> nRef ; 
line 29970: } 
line 29975: SQLITE_PRIVATE int sqlite3PcachePagecount ( PCache * pCache ) { 
line 29976: int nPage = 0 ; 
line 29977: if ( pCache -> pCache ) { 
line 29978: nPage = sqlite3GlobalConfig . pcache . xPagecount ( pCache -> pCache ) ; 
line 29979: } 
line 29980: return nPage ; 
line 29981: } 
line 29983: # ifdef SQLITE_TEST 
line 29987: SQLITE_PRIVATE int sqlite3PcacheGetCachesize ( PCache * pCache ) { 
line 29988: return pCache -> nMax ; 
line 29989: } 
line 29990: # endif 
line 29995: SQLITE_PRIVATE void sqlite3PcacheSetCachesize ( PCache * pCache , int mxPage ) { 
line 29996: pCache -> nMax = mxPage ; 
line 29997: if ( pCache -> pCache ) { 
line 29998: sqlite3GlobalConfig . pcache . xCachesize ( pCache -> pCache , mxPage ) ; 
line 29999: } 
line 30000: } 
line 30002: # if defined ( SQLITE_CHECK_PAGES ) || defined ( SQLITE_DEBUG ) 
line 30008: SQLITE_PRIVATE void sqlite3PcacheIterateDirty ( PCache * pCache , void ( * xIter ) ( PgHdr * ) ) { 
line 30009: PgHdr * pDirty ; 
line 30010: for ( pDirty = pCache -> pDirty ; pDirty ; pDirty = pDirty -> pDirtyNext ) { 
line 30011: xIter ( pDirty ) ; 
line 30012: } 
line 30013: } 
line 30014: # endif 
line 30038: typedef struct PCache1 PCache1 ; 
line 30039: typedef struct PgHdr1 PgHdr1 ; 
line 30040: typedef struct PgFreeslot PgFreeslot ; 
line 30045: struct PCache1 { 
line 30051: int szPage ; 
line 30052: int bPurgeable ; 
line 30053: unsigned int nMin ; 
line 30054: unsigned int nMax ; 
line 30060: unsigned int nRecyclable ; 
line 30061: unsigned int nPage ; 
line 30062: unsigned int nHash ; 
line 30063: PgHdr1 * * apHash ; 
line 30065: unsigned int iMaxKey ; 
line 30066: } ; 
line 30074: struct PgHdr1 { 
line 30075: unsigned int iKey ; 
line 30076: PgHdr1 * pNext ; 
line 30077: PCache1 * pCache ; 
line 30078: PgHdr1 * pLruNext ; 
line 30079: PgHdr1 * pLruPrev ; 
line 30080: } ; 
line 30086: struct PgFreeslot { 
line 30087: PgFreeslot * pNext ; 
line 30088: } ; 
line 30093: static SQLITE_WSD struct PCacheGlobal { 
line 30094: sqlite3_mutex * mutex ; 
line 30096: int nMaxPage ; 
line 30097: int nMinPage ; 
line 30098: int nCurrentPage ; 
line 30099: PgHdr1 * pLruHead , * pLruTail ; 
line 30102: int szSlot ; 
line 30103: void * pStart , * pEnd ; 
line 30104: PgFreeslot * pFree ; 
line 30105: int isInit ; 
line 30106: } pcache1_g ; 
line 30113: # define pcache1 ( GLOBAL ( struct PCacheGlobal , pcache1_g ) ) 
line 30127: # define PGHDR1_TO_PAGE ( p ) ( void * ) ( ( ( char * ) p ) - p -> pCache -> szPage ) 
line 30128: # define PAGE_TO_PGHDR1 ( c , p ) ( PgHdr1 * ) ( ( ( char * ) p ) + c -> szPage ) 
line 30133: # define pcache1EnterMutex ( ) sqlite3_mutex_enter ( pcache1 . mutex ) 
line 30134: # define pcache1LeaveMutex ( ) sqlite3_mutex_leave ( pcache1 . mutex ) 
line 30145: SQLITE_PRIVATE void sqlite3PCacheBufferSetup ( void * pBuf , int sz , int n ) { 
line 30146: if ( pcache1 . isInit ) { 
line 30147: PgFreeslot * p ; 
line 30148: sz = ROUNDDOWN8 ( sz ) ; 
line 30149: pcache1 . szSlot = sz ; 
line 30150: pcache1 . pStart = pBuf ; 
line 30151: pcache1 . pFree = 0 ; 
line 30152: while ( n -- ) { 
line 30153: p = ( PgFreeslot * ) pBuf ; 
line 30154: p -> pNext = pcache1 . pFree ; 
line 30155: pcache1 . pFree = p ; 
line 30156: pBuf = ( void * ) & ( ( char * ) pBuf ) [ sz ] ; 
line 30157: } 
line 30158: pcache1 . pEnd = pBuf ; 
line 30159: } 
line 30160: } 
line 30168: static void * pcache1Alloc ( int nByte ) { 
line 30169: void * p ; 
line 30170: assert ( sqlite3_mutex_held ( pcache1 . mutex ) ) ; 
line 30171: if ( nByte <= pcache1 . szSlot && pcache1 . pFree ) { 
line 30172: assert ( pcache1 . isInit ) ; 
line 30173: p = ( PgHdr1 * ) pcache1 . pFree ; 
line 30174: pcache1 . pFree = pcache1 . pFree -> pNext ; 
line 30175: sqlite3StatusSet ( SQLITE_STATUS_PAGECACHE_SIZE , nByte ) ; 
line 30176: sqlite3StatusAdd ( SQLITE_STATUS_PAGECACHE_USED , 1 ) ; 
line 30177: } else { 
line 30185: pcache1LeaveMutex ( ) ; 
line 30186: p = sqlite3Malloc ( nByte ) ; 
line 30187: pcache1EnterMutex ( ) ; 
line 30188: if ( p ) { 
line 30189: int sz = sqlite3MallocSize ( p ) ; 
line 30190: sqlite3StatusAdd ( SQLITE_STATUS_PAGECACHE_OVERFLOW , sz ) ; 
line 30191: } 
line 30192: } 
line 30193: return p ; 
line 30194: } 
line 30199: static void pcache1Free ( void * p ) { 
line 30200: assert ( sqlite3_mutex_held ( pcache1 . mutex ) ) ; 
line 30201: if ( p == 0 ) return ; 
line 30202: if ( p >= pcache1 . pStart && p < pcache1 . pEnd ) { 
line 30203: PgFreeslot * pSlot ; 
line 30204: sqlite3StatusAdd ( SQLITE_STATUS_PAGECACHE_USED , - 1 ) ; 
line 30205: pSlot = ( PgFreeslot * ) p ; 
line 30206: pSlot -> pNext = pcache1 . pFree ; 
line 30207: pcache1 . pFree = pSlot ; 
line 30208: } else { 
line 30209: int iSize = sqlite3MallocSize ( p ) ; 
line 30210: sqlite3StatusAdd ( SQLITE_STATUS_PAGECACHE_OVERFLOW , - iSize ) ; 
line 30211: sqlite3_free ( p ) ; 
line 30212: } 
line 30213: } 
line 30218: static PgHdr1 * pcache1AllocPage ( PCache1 * pCache ) { 
line 30219: int nByte = sizeof ( PgHdr1 ) + pCache -> szPage ; 
line 30220: void * pPg = pcache1Alloc ( nByte ) ; 
line 30221: PgHdr1 * p ; 
line 30222: if ( pPg ) { 
line 30223: p = PAGE_TO_PGHDR1 ( pCache , pPg ) ; 
line 30224: if ( pCache -> bPurgeable ) { 
line 30225: pcache1 . nCurrentPage ++ ; 
line 30226: } 
line 30227: } else { 
line 30228: p = 0 ; 
line 30229: } 
line 30230: return p ; 
line 30231: } 
line 30240: static void pcache1FreePage ( PgHdr1 * p ) { 
line 30241: if ( ALWAYS ( p ) ) { 
line 30242: if ( p -> pCache -> bPurgeable ) { 
line 30243: pcache1 . nCurrentPage -- ; 
line 30244: } 
line 30245: pcache1Free ( PGHDR1_TO_PAGE ( p ) ) ; 
line 30246: } 
line 30247: } 
line 30254: SQLITE_PRIVATE void * sqlite3PageMalloc ( int sz ) { 
line 30255: void * p ; 
line 30256: pcache1EnterMutex ( ) ; 
line 30257: p = pcache1Alloc ( sz ) ; 
line 30258: pcache1LeaveMutex ( ) ; 
line 30259: return p ; 
line 30260: } 
line 30265: SQLITE_PRIVATE void sqlite3PageFree ( void * p ) { 
line 30266: pcache1EnterMutex ( ) ; 
line 30267: pcache1Free ( p ) ; 
line 30268: pcache1LeaveMutex ( ) ; 
line 30269: } 
line 30280: static int pcache1ResizeHash ( PCache1 * p ) { 
line 30281: PgHdr1 * * apNew ; 
line 30282: unsigned int nNew ; 
line 30283: unsigned int i ; 
line 30285: assert ( sqlite3_mutex_held ( pcache1 . mutex ) ) ; 
line 30287: nNew = p -> nHash * 2 ; 
line 30288: if ( nNew < 256 ) { 
line 30289: nNew = 256 ; 
line 30290: } 
line 30292: pcache1LeaveMutex ( ) ; 
line 30293: if ( p -> nHash ) { sqlite3BeginBenignMalloc ( ) ; } 
line 30294: apNew = ( PgHdr1 * * ) sqlite3_malloc ( sizeof ( PgHdr1 * ) * nNew ) ; 
line 30295: if ( p -> nHash ) { sqlite3EndBenignMalloc ( ) ; } 
line 30296: pcache1EnterMutex ( ) ; 
line 30297: if ( apNew ) { 
line 30298: memset ( apNew , 0 , sizeof ( PgHdr1 * ) * nNew ) ; 
line 30299: for ( i = 0 ; i < p -> nHash ; i ++ ) { 
line 30300: PgHdr1 * pPage ; 
line 30301: PgHdr1 * pNext = p -> apHash [ i ] ; 
line 30302: while ( ( pPage = pNext ) != 0 ) { 
line 30303: unsigned int h = pPage -> iKey % nNew ; 
line 30304: pNext = pPage -> pNext ; 
line 30305: pPage -> pNext = apNew [ h ] ; 
line 30306: apNew [ h ] = pPage ; 
line 30307: } 
line 30308: } 
line 30309: sqlite3_free ( p -> apHash ) ; 
line 30310: p -> apHash = apNew ; 
line 30311: p -> nHash = nNew ; 
line 30312: } 
line 30314: return ( p -> apHash ? SQLITE_OK : SQLITE_NOMEM ) ; 
line 30315: } 
line 30324: static void pcache1PinPage ( PgHdr1 * pPage ) { 
line 30325: assert ( sqlite3_mutex_held ( pcache1 . mutex ) ) ; 
line 30326: if ( pPage && ( pPage -> pLruNext || pPage == pcache1 . pLruTail ) ) { 
line 30327: if ( pPage -> pLruPrev ) { 
line 30328: pPage -> pLruPrev -> pLruNext = pPage -> pLruNext ; 
line 30329: } 
line 30330: if ( pPage -> pLruNext ) { 
line 30331: pPage -> pLruNext -> pLruPrev = pPage -> pLruPrev ; 
line 30332: } 
line 30333: if ( pcache1 . pLruHead == pPage ) { 
line 30334: pcache1 . pLruHead = pPage -> pLruNext ; 
line 30335: } 
line 30336: if ( pcache1 . pLruTail == pPage ) { 
line 30337: pcache1 . pLruTail = pPage -> pLruPrev ; 
line 30338: } 
line 30339: pPage -> pLruNext = 0 ; 
line 30340: pPage -> pLruPrev = 0 ; 
line 30341: pPage -> pCache -> nRecyclable -- ; 
line 30342: } 
line 30343: } 
line 30352: static void pcache1RemoveFromHash ( PgHdr1 * pPage ) { 
line 30353: unsigned int h ; 
line 30354: PCache1 * pCache = pPage -> pCache ; 
line 30355: PgHdr1 * * pp ; 
line 30357: h = pPage -> iKey % pCache -> nHash ; 
line 30358: for ( pp = & pCache -> apHash [ h ] ; ( * pp ) != pPage ; pp = & ( * pp ) -> pNext ) ; 
line 30359: * pp = ( * pp ) -> pNext ; 
line 30361: pCache -> nPage -- ; 
line 30362: } 
line 30368: static void pcache1EnforceMaxPage ( void ) { 
line 30369: assert ( sqlite3_mutex_held ( pcache1 . mutex ) ) ; 
line 30370: while ( pcache1 . nCurrentPage > pcache1 . nMaxPage && pcache1 . pLruTail ) { 
line 30371: PgHdr1 * p = pcache1 . pLruTail ; 
line 30372: pcache1PinPage ( p ) ; 
line 30373: pcache1RemoveFromHash ( p ) ; 
line 30374: pcache1FreePage ( p ) ; 
line 30375: } 
line 30376: } 
line 30385: static void pcache1TruncateUnsafe ( 
line 30386: PCache1 * pCache , 
line 30387: unsigned int iLimit 
line 30388: ) { 
line 30389: TESTONLY ( unsigned int nPage = 0 ; ) 
line 30390: unsigned int h ; 
line 30391: assert ( sqlite3_mutex_held ( pcache1 . mutex ) ) ; 
line 30392: for ( h = 0 ; h < pCache -> nHash ; h ++ ) { 
line 30393: PgHdr1 * * pp = & pCache -> apHash [ h ] ; 
line 30394: PgHdr1 * pPage ; 
line 30395: while ( ( pPage = * pp ) != 0 ) { 
line 30396: if ( pPage -> iKey >= iLimit ) { 
line 30397: pCache -> nPage -- ; 
line 30398: * pp = pPage -> pNext ; 
line 30399: pcache1PinPage ( pPage ) ; 
line 30400: pcache1FreePage ( pPage ) ; 
line 30401: } else { 
line 30402: pp = & pPage -> pNext ; 
line 30403: TESTONLY ( nPage ++ ; ) 
line 30404: } 
line 30405: } 
line 30406: } 
line 30407: assert ( pCache -> nPage == nPage ) ; 
line 30408: } 
line 30416: static int pcache1Init ( void * NotUsed ) { 
line 30417: UNUSED_PARAMETER ( NotUsed ) ; 
line 30418: assert ( pcache1 . isInit == 0 ) ; 
line 30419: memset ( & pcache1 , 0 , sizeof ( pcache1 ) ) ; 
line 30420: if ( sqlite3GlobalConfig . bCoreMutex ) { 
line 30421: pcache1 . mutex = sqlite3_mutex_alloc ( SQLITE_MUTEX_STATIC_LRU ) ; 
line 30422: } 
line 30423: pcache1 . isInit = 1 ; 
line 30424: return SQLITE_OK ; 
line 30425: } 
line 30432: static void pcache1Shutdown ( void * NotUsed ) { 
line 30433: UNUSED_PARAMETER ( NotUsed ) ; 
line 30434: assert ( pcache1 . isInit != 0 ) ; 
line 30435: memset ( & pcache1 , 0 , sizeof ( pcache1 ) ) ; 
line 30436: } 
line 30443: static sqlite3_pcache * pcache1Create ( int szPage , int bPurgeable ) { 
line 30444: PCache1 * pCache ; 
line 30446: pCache = ( PCache1 * ) sqlite3_malloc ( sizeof ( PCache1 ) ) ; 
line 30447: if ( pCache ) { 
line 30448: memset ( pCache , 0 , sizeof ( PCache1 ) ) ; 
line 30449: pCache -> szPage = szPage ; 
line 30450: pCache -> bPurgeable = ( bPurgeable ? 1 : 0 ) ; 
line 30451: if ( bPurgeable ) { 
line 30452: pCache -> nMin = 10 ; 
line 30453: pcache1EnterMutex ( ) ; 
line 30454: pcache1 . nMinPage += pCache -> nMin ; 
line 30455: pcache1LeaveMutex ( ) ; 
line 30456: } 
line 30457: } 
line 30458: return ( sqlite3_pcache * ) pCache ; 
line 30459: } 
line 30466: static void pcache1Cachesize ( sqlite3_pcache * p , int nMax ) { 
line 30467: PCache1 * pCache = ( PCache1 * ) p ; 
line 30468: if ( pCache -> bPurgeable ) { 
line 30469: pcache1EnterMutex ( ) ; 
line 30470: pcache1 . nMaxPage += ( nMax - pCache -> nMax ) ; 
line 30471: pCache -> nMax = nMax ; 
line 30472: pcache1EnforceMaxPage ( ) ; 
line 30473: pcache1LeaveMutex ( ) ; 
line 30474: } 
line 30475: } 
line 30480: static int pcache1Pagecount ( sqlite3_pcache * p ) { 
line 30481: int n ; 
line 30482: pcache1EnterMutex ( ) ; 
line 30483: n = ( ( PCache1 * ) p ) -> nPage ; 
line 30484: pcache1LeaveMutex ( ) ; 
line 30485: return n ; 
line 30486: } 
line 30537: static void * pcache1Fetch ( sqlite3_pcache * p , unsigned int iKey , int createFlag ) { 
line 30538: unsigned int nPinned ; 
line 30539: PCache1 * pCache = ( PCache1 * ) p ; 
line 30540: PgHdr1 * pPage = 0 ; 
line 30542: assert ( pCache -> bPurgeable || createFlag != 1 ) ; 
line 30543: pcache1EnterMutex ( ) ; 
line 30544: if ( createFlag == 1 ) sqlite3BeginBenignMalloc ( ) ; 
line 30547: if ( pCache -> nHash > 0 ) { 
line 30548: unsigned int h = iKey % pCache -> nHash ; 
line 30549: for ( pPage = pCache -> apHash [ h ] ; pPage && pPage -> iKey != iKey ; pPage = pPage -> pNext ) ; 
line 30550: } 
line 30552: if ( pPage || createFlag == 0 ) { 
line 30553: pcache1PinPage ( pPage ) ; 
line 30554: goto fetch_out ; 
line 30555: } 
line 30558: nPinned = pCache -> nPage - pCache -> nRecyclable ; 
line 30559: if ( createFlag == 1 && ( 
line 30560: nPinned >= ( pcache1 . nMaxPage + pCache -> nMin - pcache1 . nMinPage ) 
line 30561: || nPinned >= ( pCache -> nMax * 9 / 10 ) 
line 30562: ) ) { 
line 30563: goto fetch_out ; 
line 30564: } 
line 30566: if ( pCache -> nPage >= pCache -> nHash && pcache1ResizeHash ( pCache ) ) { 
line 30567: goto fetch_out ; 
line 30568: } 
line 30571: if ( pCache -> bPurgeable && pcache1 . pLruTail && ( 
line 30572: ( pCache -> nPage + 1 >= pCache -> nMax ) || pcache1 . nCurrentPage >= pcache1 . nMaxPage 
line 30573: ) ) { 
line 30574: pPage = pcache1 . pLruTail ; 
line 30575: pcache1RemoveFromHash ( pPage ) ; 
line 30576: pcache1PinPage ( pPage ) ; 
line 30577: if ( pPage -> pCache -> szPage != pCache -> szPage ) { 
line 30578: pcache1FreePage ( pPage ) ; 
line 30579: pPage = 0 ; 
line 30580: } else { 
line 30581: pcache1 . nCurrentPage -= ( pPage -> pCache -> bPurgeable - pCache -> bPurgeable ) ; 
line 30582: } 
line 30583: } 
line 30588: if ( ! pPage ) { 
line 30589: pPage = pcache1AllocPage ( pCache ) ; 
line 30590: } 
line 30592: if ( pPage ) { 
line 30593: unsigned int h = iKey % pCache -> nHash ; 
line 30594: pCache -> nPage ++ ; 
line 30595: pPage -> iKey = iKey ; 
line 30596: pPage -> pNext = pCache -> apHash [ h ] ; 
line 30597: pPage -> pCache = pCache ; 
line 30598: pPage -> pLruPrev = 0 ; 
line 30599: pPage -> pLruNext = 0 ; 
line 30600: * ( void * * ) ( PGHDR1_TO_PAGE ( pPage ) ) = 0 ; 
line 30601: pCache -> apHash [ h ] = pPage ; 
line 30602: } 
line 30604: fetch_out : 
line 30605: if ( pPage && iKey > pCache -> iMaxKey ) { 
line 30606: pCache -> iMaxKey = iKey ; 
line 30607: } 
line 30608: if ( createFlag == 1 ) sqlite3EndBenignMalloc ( ) ; 
line 30609: pcache1LeaveMutex ( ) ; 
line 30610: return ( pPage ? PGHDR1_TO_PAGE ( pPage ) : 0 ) ; 
line 30611: } 
line 30619: static void pcache1Unpin ( sqlite3_pcache * p , void * pPg , int reuseUnlikely ) { 
line 30620: PCache1 * pCache = ( PCache1 * ) p ; 
line 30621: PgHdr1 * pPage = PAGE_TO_PGHDR1 ( pCache , pPg ) ; 
line 30623: assert ( pPage -> pCache == pCache ) ; 
line 30624: pcache1EnterMutex ( ) ; 
line 30629: assert ( pPage -> pLruPrev == 0 && pPage -> pLruNext == 0 ) ; 
line 30630: assert ( pcache1 . pLruHead != pPage && pcache1 . pLruTail != pPage ) ; 
line 30632: if ( reuseUnlikely || pcache1 . nCurrentPage > pcache1 . nMaxPage ) { 
line 30633: pcache1RemoveFromHash ( pPage ) ; 
line 30634: pcache1FreePage ( pPage ) ; 
line 30635: } else { 
line 30641: if ( pcache1 . pLruHead ) { 
line 30642: pcache1 . pLruHead -> pLruPrev = pPage ; 
line 30643: pPage -> pLruNext = pcache1 . pLruHead ; 
line 30644: pcache1 . pLruHead = pPage ; 
line 30645: } else { 
line 30646: pcache1 . pLruTail = pPage ; 
line 30647: pcache1 . pLruHead = pPage ; 
line 30648: } 
line 30649: pCache -> nRecyclable ++ ; 
line 30650: } 
line 30652: pcache1LeaveMutex ( ) ; 
line 30653: } 
line 30658: static void pcache1Rekey ( 
line 30659: sqlite3_pcache * p , 
line 30660: void * pPg , 
line 30661: unsigned int iOld , 
line 30662: unsigned int iNew 
line 30663: ) { 
line 30664: PCache1 * pCache = ( PCache1 * ) p ; 
line 30665: PgHdr1 * pPage = PAGE_TO_PGHDR1 ( pCache , pPg ) ; 
line 30666: PgHdr1 * * pp ; 
line 30667: unsigned int h ; 
line 30668: assert ( pPage -> iKey == iOld ) ; 
line 30669: assert ( pPage -> pCache == pCache ) ; 
line 30671: pcache1EnterMutex ( ) ; 
line 30673: h = iOld % pCache -> nHash ; 
line 30674: pp = & pCache -> apHash [ h ] ; 
line 30675: while ( ( * pp ) != pPage ) { 
line 30676: pp = & ( * pp ) -> pNext ; 
line 30677: } 
line 30678: * pp = pPage -> pNext ; 
line 30680: h = iNew % pCache -> nHash ; 
line 30681: pPage -> iKey = iNew ; 
line 30682: pPage -> pNext = pCache -> apHash [ h ] ; 
line 30683: pCache -> apHash [ h ] = pPage ; 
line 30684: if ( iNew > pCache -> iMaxKey ) { 
line 30685: pCache -> iMaxKey = iNew ; 
line 30686: } 
line 30688: pcache1LeaveMutex ( ) ; 
line 30689: } 
line 30698: static void pcache1Truncate ( sqlite3_pcache * p , unsigned int iLimit ) { 
line 30699: PCache1 * pCache = ( PCache1 * ) p ; 
line 30700: pcache1EnterMutex ( ) ; 
line 30701: if ( iLimit <= pCache -> iMaxKey ) { 
line 30702: pcache1TruncateUnsafe ( pCache , iLimit ) ; 
line 30703: pCache -> iMaxKey = iLimit - 1 ; 
line 30704: } 
line 30705: pcache1LeaveMutex ( ) ; 
line 30706: } 
line 30713: static void pcache1Destroy ( sqlite3_pcache * p ) { 
line 30714: PCache1 * pCache = ( PCache1 * ) p ; 
line 30715: pcache1EnterMutex ( ) ; 
line 30716: pcache1TruncateUnsafe ( pCache , 0 ) ; 
line 30717: pcache1 . nMaxPage -= pCache -> nMax ; 
line 30718: pcache1 . nMinPage -= pCache -> nMin ; 
line 30719: pcache1EnforceMaxPage ( ) ; 
line 30720: pcache1LeaveMutex ( ) ; 
line 30721: sqlite3_free ( pCache -> apHash ) ; 
line 30722: sqlite3_free ( pCache ) ; 
line 30723: } 
line 30730: SQLITE_PRIVATE void sqlite3PCacheSetDefault ( void ) { 
line 30731: static sqlite3_pcache_methods defaultMethods = { 
line 30732: 0 , 
line 30733: pcache1Init , 
line 30734: pcache1Shutdown , 
line 30735: pcache1Create , 
line 30736: pcache1Cachesize , 
line 30737: pcache1Pagecount , 
line 30738: pcache1Fetch , 
line 30739: pcache1Unpin , 
line 30740: pcache1Rekey , 
line 30741: pcache1Truncate , 
line 30742: pcache1Destroy 
line 30743: } ; 
line 30744: sqlite3_config ( SQLITE_CONFIG_PCACHE , & defaultMethods ) ; 
line 30745: } 
line 30747: # ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT 
line 30757: SQLITE_PRIVATE int sqlite3PcacheReleaseMemory ( int nReq ) { 
line 30758: int nFree = 0 ; 
line 30759: if ( pcache1 . pStart == 0 ) { 
line 30760: PgHdr1 * p ; 
line 30761: pcache1EnterMutex ( ) ; 
line 30762: while ( ( nReq < 0 || nFree < nReq ) && ( p = pcache1 . pLruTail ) ) { 
line 30763: nFree += sqlite3MallocSize ( PGHDR1_TO_PAGE ( p ) ) ; 
line 30764: pcache1PinPage ( p ) ; 
line 30765: pcache1RemoveFromHash ( p ) ; 
line 30766: pcache1FreePage ( p ) ; 
line 30767: } 
line 30768: pcache1LeaveMutex ( ) ; 
line 30769: } 
line 30770: return nFree ; 
line 30771: } 
line 30772: # endif 
line 30774: # ifdef SQLITE_TEST 
line 30779: SQLITE_PRIVATE void sqlite3PcacheStats ( 
line 30780: int * pnCurrent , 
line 30781: int * pnMax , 
line 30782: int * pnMin , 
line 30783: int * pnRecyclable 
line 30784: ) { 
line 30785: PgHdr1 * p ; 
line 30786: int nRecyclable = 0 ; 
line 30787: for ( p = pcache1 . pLruHead ; p ; p = p -> pLruNext ) { 
line 30788: nRecyclable ++ ; 
line 30789: } 
line 30790: * pnCurrent = pcache1 . nCurrentPage ; 
line 30791: * pnMax = pcache1 . nMaxPage ; 
line 30792: * pnMin = pcache1 . nMinPage ; 
line 30793: * pnRecyclable = nRecyclable ; 
line 30794: } 
line 30795: # endif 
line 30866: # define ROWSET_ALLOCATION_SIZE 1024 
line 30871: # define ROWSET_ENTRY_PER_CHUNK 
line 30872: ( ( ROWSET_ALLOCATION_SIZE - 8 ) / sizeof ( struct RowSetEntry ) ) 
line 30877: struct RowSetEntry { 
line 30878: i64 v ; 
line 30879: struct RowSetEntry * pRight ; 
line 30880: struct RowSetEntry * pLeft ; 
line 30881: } ; 
line 30889: struct RowSetChunk { 
line 30890: struct RowSetChunk * pNextChunk ; 
line 30891: struct RowSetEntry aEntry [ ROWSET_ENTRY_PER_CHUNK ] ; 
line 30892: } ; 
line 30899: struct RowSet { 
line 30900: struct RowSetChunk * pChunk ; 
line 30901: sqlite3 * db ; 
line 30902: struct RowSetEntry * pEntry ; 
line 30903: struct RowSetEntry * pLast ; 
line 30904: struct RowSetEntry * pFresh ; 
line 30905: struct RowSetEntry * pTree ; 
line 30906: u16 nFresh ; 
line 30907: u8 isSorted ; 
line 30908: u8 iBatch ; 
line 30909: } ; 
line 30923: SQLITE_PRIVATE RowSet * sqlite3RowSetInit ( sqlite3 * db , void * pSpace , unsigned int N ) { 
line 30924: RowSet * p ; 
line 30925: assert ( N >= ROUND8 ( sizeof ( * p ) ) ) ; 
line 30926: p = pSpace ; 
line 30927: p -> pChunk = 0 ; 
line 30928: p -> db = db ; 
line 30929: p -> pEntry = 0 ; 
line 30930: p -> pLast = 0 ; 
line 30931: p -> pTree = 0 ; 
line 30932: p -> pFresh = ( struct RowSetEntry * ) ( ROUND8 ( sizeof ( * p ) ) + ( char * ) p ) ; 
line 30933: p -> nFresh = ( u16 ) ( ( N - ROUND8 ( sizeof ( * p ) ) ) / sizeof ( struct RowSetEntry ) ) ; 
line 30934: p -> isSorted = 1 ; 
line 30935: p -> iBatch = 0 ; 
line 30936: return p ; 
line 30937: } 
line 30944: SQLITE_PRIVATE void sqlite3RowSetClear ( RowSet * p ) { 
line 30945: struct RowSetChunk * pChunk , * pNextChunk ; 
line 30946: for ( pChunk = p -> pChunk ; pChunk ; pChunk = pNextChunk ) { 
line 30947: pNextChunk = pChunk -> pNextChunk ; 
line 30948: sqlite3DbFree ( p -> db , pChunk ) ; 
line 30949: } 
line 30950: p -> pChunk = 0 ; 
line 30951: p -> nFresh = 0 ; 
line 30952: p -> pEntry = 0 ; 
line 30953: p -> pLast = 0 ; 
line 30954: p -> pTree = 0 ; 
line 30955: p -> isSorted = 1 ; 
line 30956: } 
line 30964: SQLITE_PRIVATE void sqlite3RowSetInsert ( RowSet * p , i64 rowid ) { 
line 30965: struct RowSetEntry * pEntry ; 
line 30966: struct RowSetEntry * pLast ; 
line 30967: assert ( p != 0 ) ; 
line 30968: if ( p -> nFresh == 0 ) { 
line 30969: struct RowSetChunk * pNew ; 
line 30970: pNew = sqlite3DbMallocRaw ( p -> db , sizeof ( * pNew ) ) ; 
line 30971: if ( pNew == 0 ) { 
line 30972: return ; 
line 30973: } 
line 30974: pNew -> pNextChunk = p -> pChunk ; 
line 30975: p -> pChunk = pNew ; 
line 30976: p -> pFresh = pNew -> aEntry ; 
line 30977: p -> nFresh = ROWSET_ENTRY_PER_CHUNK ; 
line 30978: } 
line 30979: pEntry = p -> pFresh ++ ; 
line 30980: p -> nFresh -- ; 
line 30981: pEntry -> v = rowid ; 
line 30982: pEntry -> pRight = 0 ; 
line 30983: pLast = p -> pLast ; 
line 30984: if ( pLast ) { 
line 30985: if ( p -> isSorted && rowid <= pLast -> v ) { 
line 30986: p -> isSorted = 0 ; 
line 30987: } 
line 30988: pLast -> pRight = pEntry ; 
line 30989: } else { 
line 30990: assert ( p -> pEntry == 0 ) ; 
line 30991: p -> pEntry = pEntry ; 
line 30992: } 
line 30993: p -> pLast = pEntry ; 
line 30994: } 
line 31002: static struct RowSetEntry * rowSetMerge ( 
line 31003: struct RowSetEntry * pA , 
line 31004: struct RowSetEntry * pB 
line 31005: ) { 
line 31006: struct RowSetEntry head ; 
line 31007: struct RowSetEntry * pTail ; 
line 31009: pTail = & head ; 
line 31010: while ( pA && pB ) { 
line 31011: assert ( pA -> pRight == 0 || pA -> v <= pA -> pRight -> v ) ; 
line 31012: assert ( pB -> pRight == 0 || pB -> v <= pB -> pRight -> v ) ; 
line 31013: if ( pA -> v < pB -> v ) { 
line 31014: pTail -> pRight = pA ; 
line 31015: pA = pA -> pRight ; 
line 31016: pTail = pTail -> pRight ; 
line 31017: } else if ( pB -> v < pA -> v ) { 
line 31018: pTail -> pRight = pB ; 
line 31019: pB = pB -> pRight ; 
line 31020: pTail = pTail -> pRight ; 
line 31021: } else { 
line 31022: pA = pA -> pRight ; 
line 31023: } 
line 31024: } 
line 31025: if ( pA ) { 
line 31026: assert ( pA -> pRight == 0 || pA -> v <= pA -> pRight -> v ) ; 
line 31027: pTail -> pRight = pA ; 
line 31028: } else { 
line 31029: assert ( pB == 0 || pB -> pRight == 0 || pB -> v <= pB -> pRight -> v ) ; 
line 31030: pTail -> pRight = pB ; 
line 31031: } 
line 31032: return head . pRight ; 
line 31033: } 
line 31038: static void rowSetSort ( RowSet * p ) { 
line 31039: unsigned int i ; 
line 31040: struct RowSetEntry * pEntry ; 
line 31041: struct RowSetEntry * aBucket [ 40 ] ; 
line 31043: assert ( p -> isSorted == 0 ) ; 
line 31044: memset ( aBucket , 0 , sizeof ( aBucket ) ) ; 
line 31045: while ( p -> pEntry ) { 
line 31046: pEntry = p -> pEntry ; 
line 31047: p -> pEntry = pEntry -> pRight ; 
line 31048: pEntry -> pRight = 0 ; 
line 31049: for ( i = 0 ; aBucket [ i ] ; i ++ ) { 
line 31050: pEntry = rowSetMerge ( aBucket [ i ] , pEntry ) ; 
line 31051: aBucket [ i ] = 0 ; 
line 31052: } 
line 31053: aBucket [ i ] = pEntry ; 
line 31054: } 
line 31055: pEntry = 0 ; 
line 31056: for ( i = 0 ; i < sizeof ( aBucket ) / sizeof ( aBucket [ 0 ] ) ; i ++ ) { 
line 31057: pEntry = rowSetMerge ( pEntry , aBucket [ i ] ) ; 
line 31058: } 
line 31059: p -> pEntry = pEntry ; 
line 31060: p -> pLast = 0 ; 
line 31061: p -> isSorted = 1 ; 
line 31062: } 
line 31070: static void rowSetTreeToList ( 
line 31071: struct RowSetEntry * pIn , 
line 31072: struct RowSetEntry * * ppFirst , 
line 31073: struct RowSetEntry * * ppLast 
line 31074: ) { 
line 31075: assert ( pIn != 0 ) ; 
line 31076: if ( pIn -> pLeft ) { 
line 31077: struct RowSetEntry * p ; 
line 31078: rowSetTreeToList ( pIn -> pLeft , ppFirst , & p ) ; 
line 31079: p -> pRight = pIn ; 
line 31080: } else { 
line 31081: * ppFirst = pIn ; 
line 31082: } 
line 31083: if ( pIn -> pRight ) { 
line 31084: rowSetTreeToList ( pIn -> pRight , & pIn -> pRight , ppLast ) ; 
line 31085: } else { 
line 31086: * ppLast = pIn ; 
line 31087: } 
line 31088: assert ( ( * ppLast ) -> pRight == 0 ) ; 
line 31089: } 
line 31105: static struct RowSetEntry * rowSetNDeepTree ( 
line 31106: struct RowSetEntry * * ppList , 
line 31107: int iDepth 
line 31108: ) { 
line 31109: struct RowSetEntry * p ; 
line 31110: struct RowSetEntry * pLeft ; 
line 31111: if ( * ppList == 0 ) { 
line 31112: return 0 ; 
line 31113: } 
line 31114: if ( iDepth == 1 ) { 
line 31115: p = * ppList ; 
line 31116: * ppList = p -> pRight ; 
line 31117: p -> pLeft = p -> pRight = 0 ; 
line 31118: return p ; 
line 31119: } 
line 31120: pLeft = rowSetNDeepTree ( ppList , iDepth - 1 ) ; 
line 31121: p = * ppList ; 
line 31122: if ( p == 0 ) { 
line 31123: return pLeft ; 
line 31124: } 
line 31125: p -> pLeft = pLeft ; 
line 31126: * ppList = p -> pRight ; 
line 31127: p -> pRight = rowSetNDeepTree ( ppList , iDepth - 1 ) ; 
line 31128: return p ; 
line 31129: } 
line 31135: static struct RowSetEntry * rowSetListToTree ( struct RowSetEntry * pList ) { 
line 31136: int iDepth ; 
line 31137: struct RowSetEntry * p ; 
line 31138: struct RowSetEntry * pLeft ; 
line 31140: assert ( pList != 0 ) ; 
line 31141: p = pList ; 
line 31142: pList = p -> pRight ; 
line 31143: p -> pLeft = p -> pRight = 0 ; 
line 31144: for ( iDepth = 1 ; pList ; iDepth ++ ) { 
line 31145: pLeft = p ; 
line 31146: p = pList ; 
line 31147: pList = p -> pRight ; 
line 31148: p -> pLeft = pLeft ; 
line 31149: p -> pRight = rowSetNDeepTree ( & pList , iDepth ) ; 
line 31150: } 
line 31151: return p ; 
line 31152: } 
line 31159: static void rowSetToList ( RowSet * p ) { 
line 31160: if ( ! p -> isSorted ) { 
line 31161: rowSetSort ( p ) ; 
line 31162: } 
line 31163: if ( p -> pTree ) { 
line 31164: struct RowSetEntry * pHead , * pTail ; 
line 31165: rowSetTreeToList ( p -> pTree , & pHead , & pTail ) ; 
line 31166: p -> pTree = 0 ; 
line 31167: p -> pEntry = rowSetMerge ( p -> pEntry , pHead ) ; 
line 31168: } 
line 31169: } 
line 31179: SQLITE_PRIVATE int sqlite3RowSetNext ( RowSet * p , i64 * pRowid ) { 
line 31180: rowSetToList ( p ) ; 
line 31181: if ( p -> pEntry ) { 
line 31182: * pRowid = p -> pEntry -> v ; 
line 31183: p -> pEntry = p -> pEntry -> pRight ; 
line 31184: if ( p -> pEntry == 0 ) { 
line 31185: sqlite3RowSetClear ( p ) ; 
line 31186: } 
line 31187: return 1 ; 
line 31188: } else { 
line 31189: return 0 ; 
line 31190: } 
line 31191: } 
line 31197: SQLITE_PRIVATE int sqlite3RowSetTest ( RowSet * pRowSet , u8 iBatch , sqlite3_int64 iRowid ) { 
line 31198: struct RowSetEntry * p ; 
line 31199: if ( iBatch != pRowSet -> iBatch ) { 
line 31200: if ( pRowSet -> pEntry ) { 
line 31201: rowSetToList ( pRowSet ) ; 
line 31202: pRowSet -> pTree = rowSetListToTree ( pRowSet -> pEntry ) ; 
line 31203: pRowSet -> pEntry = 0 ; 
line 31204: pRowSet -> pLast = 0 ; 
line 31205: } 
line 31206: pRowSet -> iBatch = iBatch ; 
line 31207: } 
line 31208: p = pRowSet -> pTree ; 
line 31209: while ( p ) { 
line 31210: if ( p -> v < iRowid ) { 
line 31211: p = p -> pRight ; 
line 31212: } else if ( p -> v > iRowid ) { 
line 31213: p = p -> pLeft ; 
line 31214: } else { 
line 31215: return 1 ; 
line 31216: } 
line 31217: } 
line 31218: return 0 ; 
line 31219: } 
line 31243: # ifndef SQLITE_OMIT_DISKIO 
line 31248: # if 0 
line 31249: int sqlite3PagerTrace = 1 ; 
line 31250: # define sqlite3DebugPrintf printf 
line 31251: # define PAGERTRACE ( X ) if ( sqlite3PagerTrace ) { sqlite3DebugPrintf X ; } 
line 31252: # else 
line 31253: # define PAGERTRACE ( X ) 
line 31254: # endif 
line 31264: # define PAGERID ( p ) ( ( int ) ( p -> fd ) ) 
line 31265: # define FILEHANDLEID ( fd ) ( ( int ) fd ) 
line 31315: # define PAGER_UNLOCK 0 
line 31316: # define PAGER_SHARED 1 
line 31317: # define PAGER_RESERVED 2 
line 31318: # define PAGER_EXCLUSIVE 4 
line 31319: # define PAGER_SYNCED 5 
line 31324: # ifdef SQLITE_HAS_CODEC 
line 31325: # define CODEC1 ( P , D , N , X , E ) 
line 31326: if ( P -> xCodec && P -> xCodec ( P -> pCodec , D , N , X ) == 0 ) { E ; } 
line 31327: # define CODEC2 ( P , D , N , X , E , O ) 
line 31328: if ( P -> xCodec == 0 ) { O = ( char * ) D ; } else 
line 31329: if ( ( O = ( char * ) ( P -> xCodec ( P -> pCodec , D , N , X ) ) ) == 0 ) { E ; } 
line 31330: # else 
line 31331: # define CODEC1 ( P , D , N , X , E ) 
line 31332: # define CODEC2 ( P , D , N , X , E , O ) O = ( char * ) D 
line 31333: # endif 
line 31341: # define MAX_SECTOR_SIZE 0x10000 
line 31356: typedef struct PagerSavepoint PagerSavepoint ; 
line 31357: struct PagerSavepoint { 
line 31358: i64 iOffset ; 
line 31359: i64 iHdrOffset ; 
line 31360: Bitvec * pInSavepoint ; 
line 31361: Pgno nOrig ; 
line 31362: Pgno iSubRec ; 
line 31363: } ; 
line 31461: struct Pager { 
line 31462: sqlite3_vfs * pVfs ; 
line 31463: u8 exclusiveMode ; 
line 31464: u8 journalMode ; 
line 31465: u8 useJournal ; 
line 31466: u8 noReadlock ; 
line 31467: u8 noSync ; 
line 31468: u8 fullSync ; 
line 31469: u8 sync_flags ; 
line 31470: u8 tempFile ; 
line 31471: u8 readOnly ; 
line 31472: u8 memDb ; 
line 31485: u8 state ; 
line 31486: u8 dbModified ; 
line 31487: u8 needSync ; 
line 31488: u8 journalStarted ; 
line 31489: u8 changeCountDone ; 
line 31490: u8 setMaster ; 
line 31491: u8 doNotSync ; 
line 31492: u8 dbSizeValid ; 
line 31493: u8 subjInMemory ; 
line 31494: Pgno dbSize ; 
line 31495: Pgno dbOrigSize ; 
line 31496: Pgno dbFileSize ; 
line 31497: int errCode ; 
line 31498: int nRec ; 
line 31499: u32 cksumInit ; 
line 31500: u32 nSubRec ; 
line 31501: Bitvec * pInJournal ; 
line 31502: sqlite3_file * fd ; 
line 31503: sqlite3_file * jfd ; 
line 31504: sqlite3_file * sjfd ; 
line 31505: i64 journalOff ; 
line 31506: i64 journalHdr ; 
line 31507: PagerSavepoint * aSavepoint ; 
line 31508: int nSavepoint ; 
line 31509: char dbFileVers [ 16 ] ; 
line 31510: u32 sectorSize ; 
line 31512: u16 nExtra ; 
line 31513: i16 nReserve ; 
line 31514: u32 vfsFlags ; 
line 31515: int pageSize ; 
line 31516: Pgno mxPgno ; 
line 31517: char * zFilename ; 
line 31518: char * zJournal ; 
line 31519: int ( * xBusyHandler ) ( void * ) ; 
line 31520: void * pBusyHandlerArg ; 
line 31521: # ifdef SQLITE_TEST 
line 31522: int nHit , nMiss ; 
line 31523: int nRead , nWrite ; 
line 31524: # endif 
line 31525: void ( * xReiniter ) ( DbPage * ) ; 
line 31526: # ifdef SQLITE_HAS_CODEC 
line 31527: void * ( * xCodec ) ( void * , void * , Pgno , int ) ; 
line 31528: void ( * xCodecSizeChng ) ( void * , int , int ) ; 
line 31529: void ( * xCodecFree ) ( void * ) ; 
line 31530: void * pCodec ; 
line 31531: # endif 
line 31532: char * pTmpSpace ; 
line 31533: i64 journalSizeLimit ; 
line 31534: PCache * pPCache ; 
line 31535: sqlite3_backup * pBackup ; 
line 31536: } ; 
line 31543: # ifdef SQLITE_TEST 
line 31544: SQLITE_API int sqlite3_pager_readdb_count = 0 ; 
line 31545: SQLITE_API int sqlite3_pager_writedb_count = 0 ; 
line 31546: SQLITE_API int sqlite3_pager_writej_count = 0 ; 
line 31547: # define PAGER_INCR ( v ) v ++ 
line 31548: # else 
line 31549: # define PAGER_INCR ( v ) 
line 31550: # endif 
line 31577: static const unsigned char aJournalMagic [ ] = { 
line 31578: 0xd9 , 0xd5 , 0x05 , 0xf9 , 0x20 , 0xa1 , 0x63 , 0xd7 , 
line 31579: } ; 
line 31585: # define JOURNAL_PG_SZ ( pPager ) ( ( pPager -> pageSize ) + 8 ) 
line 31591: # define JOURNAL_HDR_SZ ( pPager ) ( pPager -> sectorSize ) 
line 31599: # ifdef SQLITE_OMIT_MEMORYDB 
line 31600: # define MEMDB 0 
line 31601: # else 
line 31602: # define MEMDB pPager -> memDb 
line 31603: # endif 
line 31608: # define PAGER_MAX_PGNO 2147483647 
line 31610: # ifndef NDEBUG 
line 31616: static int assert_pager_state ( Pager * pPager ) { 
line 31619: assert ( pPager -> tempFile == 0 || pPager -> state >= PAGER_EXCLUSIVE ) ; 
line 31622: assert ( pPager -> tempFile == 0 || pPager -> changeCountDone ) ; 
line 31624: return 1 ; 
line 31625: } 
line 31626: # endif 
line 31637: static int subjRequiresPage ( PgHdr * pPg ) { 
line 31638: Pgno pgno = pPg -> pgno ; 
line 31639: Pager * pPager = pPg -> pPager ; 
line 31640: int i ; 
line 31641: for ( i = 0 ; i < pPager -> nSavepoint ; i ++ ) { 
line 31642: PagerSavepoint * p = & pPager -> aSavepoint [ i ] ; 
line 31643: if ( p -> nOrig >= pgno && 0 == sqlite3BitvecTest ( p -> pInSavepoint , pgno ) ) { 
line 31644: return 1 ; 
line 31645: } 
line 31646: } 
line 31647: return 0 ; 
line 31648: } 
line 31653: static int pageInJournal ( PgHdr * pPg ) { 
line 31654: return sqlite3BitvecTest ( pPg -> pPager -> pInJournal , pPg -> pgno ) ; 
line 31655: } 
line 31664: static int read32bits ( sqlite3_file * fd , i64 offset , u32 * pRes ) { 
line 31665: unsigned char ac [ 4 ] ; 
line 31666: int rc = sqlite3OsRead ( fd , ac , sizeof ( ac ) , offset ) ; 
line 31667: if ( rc == SQLITE_OK ) { 
line 31668: * pRes = sqlite3Get4byte ( ac ) ; 
line 31669: } 
line 31670: return rc ; 
line 31671: } 
line 31676: # define put32bits ( A , B ) sqlite3Put4byte ( ( u8 * ) A , B ) 
line 31682: static int write32bits ( sqlite3_file * fd , i64 offset , u32 val ) { 
line 31683: char ac [ 4 ] ; 
line 31684: put32bits ( ac , val ) ; 
line 31685: return sqlite3OsWrite ( fd , ac , 4 , offset ) ; 
line 31686: } 
line 31700: # define isOpen ( pFd ) ( ( pFd ) -> pMethods ) 
line 31705: static int osUnlock ( sqlite3_file * pFd , int eLock ) { 
line 31706: if ( ! isOpen ( pFd ) ) { 
line 31707: return SQLITE_OK ; 
line 31708: } 
line 31709: return sqlite3OsUnlock ( pFd , eLock ) ; 
line 31710: } 
line 31729: # ifdef SQLITE_ENABLE_ATOMIC_WRITE 
line 31730: static int jrnlBufferSize ( Pager * pPager ) { 
line 31731: assert ( ! MEMDB ) ; 
line 31732: if ( ! pPager -> tempFile ) { 
line 31733: int dc ; 
line 31734: int nSector ; 
line 31735: int szPage ; 
line 31737: assert ( isOpen ( pPager -> fd ) ) ; 
line 31738: dc = sqlite3OsDeviceCharacteristics ( pPager -> fd ) ; 
line 31739: nSector = pPager -> sectorSize ; 
line 31740: szPage = pPager -> pageSize ; 
line 31742: assert ( SQLITE_IOCAP_ATOMIC512 == ( 512 >> 8 ) ) ; 
line 31743: assert ( SQLITE_IOCAP_ATOMIC64K == ( 65536 >> 8 ) ) ; 
line 31744: if ( 0 == ( dc & ( SQLITE_IOCAP_ATOMIC | ( szPage >> 8 ) ) || nSector > szPage ) ) { 
line 31745: return 0 ; 
line 31746: } 
line 31747: } 
line 31749: return JOURNAL_HDR_SZ ( pPager ) + JOURNAL_PG_SZ ( pPager ) ; 
line 31750: } 
line 31751: # endif 
line 31758: # ifdef SQLITE_CHECK_PAGES 
line 31762: static u32 pager_datahash ( int nByte , unsigned char * pData ) { 
line 31763: u32 hash = 0 ; 
line 31764: int i ; 
line 31765: for ( i = 0 ; i < nByte ; i ++ ) { 
line 31766: hash = ( hash * 1039 ) + pData [ i ] ; 
line 31767: } 
line 31768: return hash ; 
line 31769: } 
line 31770: static u32 pager_pagehash ( PgHdr * pPage ) { 
line 31771: return pager_datahash ( pPage -> pPager -> pageSize , ( unsigned char * ) pPage -> pData ) ; 
line 31772: } 
line 31773: static void pager_set_pagehash ( PgHdr * pPage ) { 
line 31774: pPage -> pageHash = pager_pagehash ( pPage ) ; 
line 31775: } 
line 31782: # define CHECK_PAGE ( x ) checkPage ( x ) 
line 31783: static void checkPage ( PgHdr * pPg ) { 
line 31784: Pager * pPager = pPg -> pPager ; 
line 31785: assert ( ! pPg -> pageHash || pPager -> errCode 
line 31786: || ( pPg -> flags & PGHDR_DIRTY ) || pPg -> pageHash == pager_pagehash ( pPg ) ) ; 
line 31787: } 
line 31789: # else 
line 31790: # define pager_datahash ( X , Y ) 0 
line 31791: # define pager_pagehash ( X ) 0 
line 31792: # define CHECK_PAGE ( x ) 
line 31793: # endif 
line 31820: static int readMasterJournal ( sqlite3_file * pJrnl , char * zMaster , u32 nMaster ) { 
line 31821: int rc ; 
line 31822: u32 len ; 
line 31823: i64 szJ ; 
line 31824: u32 cksum ; 
line 31825: u32 u ; 
line 31826: unsigned char aMagic [ 8 ] ; 
line 31827: zMaster [ 0 ] = '\0' ; 
line 31829: if ( SQLITE_OK != ( rc = sqlite3OsFileSize ( pJrnl , & szJ ) ) 
line 31830: || szJ < 16 
line 31831: || SQLITE_OK != ( rc = read32bits ( pJrnl , szJ - 16 , & len ) ) 
line 31832: || len >= nMaster 
line 31833: || SQLITE_OK != ( rc = read32bits ( pJrnl , szJ - 12 , & cksum ) ) 
line 31834: || SQLITE_OK != ( rc = sqlite3OsRead ( pJrnl , aMagic , 8 , szJ - 8 ) ) 
line 31835: || memcmp ( aMagic , aJournalMagic , 8 ) 
line 31836: || SQLITE_OK != ( rc = sqlite3OsRead ( pJrnl , zMaster , len , szJ - 16 - len ) ) 
line 31837: ) { 
line 31838: return rc ; 
line 31839: } 
line 31842: for ( u = 0 ; u < len ; u ++ ) { 
line 31843: cksum -= zMaster [ u ] ; 
line 31844: } 
line 31845: if ( cksum ) { 
line 31851: len = 0 ; 
line 31852: } 
line 31853: zMaster [ len ] = '\0' ; 
line 31855: return SQLITE_OK ; 
line 31856: } 
line 31873: static i64 journalHdrOffset ( Pager * pPager ) { 
line 31874: i64 offset = 0 ; 
line 31875: i64 c = pPager -> journalOff ; 
line 31876: if ( c ) { 
line 31877: offset = ( ( c - 1 ) / JOURNAL_HDR_SZ ( pPager ) + 1 ) * JOURNAL_HDR_SZ ( pPager ) ; 
line 31878: } 
line 31879: assert ( offset % JOURNAL_HDR_SZ ( pPager ) == 0 ) ; 
line 31880: assert ( offset >= c ) ; 
line 31881: assert ( ( offset - c ) < JOURNAL_HDR_SZ ( pPager ) ) ; 
line 31882: return offset ; 
line 31883: } 
line 31906: static int zeroJournalHdr ( Pager * pPager , int doTruncate ) { 
line 31907: int rc = SQLITE_OK ; 
line 31908: assert ( isOpen ( pPager -> jfd ) ) ; 
line 31909: if ( pPager -> journalOff ) { 
line 31910: const i64 iLimit = pPager -> journalSizeLimit ; 
line 31912: IOTRACE ( ( "JZEROHDR %p\n" , pPager ) ) 
line 31913: if ( doTruncate || iLimit == 0 ) { 
line 31914: rc = sqlite3OsTruncate ( pPager -> jfd , 0 ) ; 
line 31915: } else { 
line 31916: static const char zeroHdr [ 28 ] = { 0 } ; 
line 31917: rc = sqlite3OsWrite ( pPager -> jfd , zeroHdr , sizeof ( zeroHdr ) , 0 ) ; 
line 31918: } 
line 31919: if ( rc == SQLITE_OK && ! pPager -> noSync ) { 
line 31920: rc = sqlite3OsSync ( pPager -> jfd , SQLITE_SYNC_DATAONLY | pPager -> sync_flags ) ; 
line 31921: } 
line 31929: if ( rc == SQLITE_OK && iLimit > 0 ) { 
line 31930: i64 sz ; 
line 31931: rc = sqlite3OsFileSize ( pPager -> jfd , & sz ) ; 
line 31932: if ( rc == SQLITE_OK && sz > iLimit ) { 
line 31933: rc = sqlite3OsTruncate ( pPager -> jfd , iLimit ) ; 
line 31934: } 
line 31935: } 
line 31936: } 
line 31937: return rc ; 
line 31938: } 
line 31955: static int writeJournalHdr ( Pager * pPager ) { 
line 31956: int rc = SQLITE_OK ; 
line 31957: char * zHeader = pPager -> pTmpSpace ; 
line 31958: u32 nHeader = pPager -> pageSize ; 
line 31959: u32 nWrite ; 
line 31960: int ii ; 
line 31962: assert ( isOpen ( pPager -> jfd ) ) ; 
line 31964: if ( nHeader > JOURNAL_HDR_SZ ( pPager ) ) { 
line 31965: nHeader = JOURNAL_HDR_SZ ( pPager ) ; 
line 31966: } 
line 31972: for ( ii = 0 ; ii < pPager -> nSavepoint ; ii ++ ) { 
line 31973: if ( pPager -> aSavepoint [ ii ] . iHdrOffset == 0 ) { 
line 31974: pPager -> aSavepoint [ ii ] . iHdrOffset = pPager -> journalOff ; 
line 31975: } 
line 31976: } 
line 31978: pPager -> journalHdr = pPager -> journalOff = journalHdrOffset ( pPager ) ; 
line 32000: assert ( isOpen ( pPager -> fd ) || pPager -> noSync ) ; 
line 32001: if ( ( pPager -> noSync ) || ( pPager -> journalMode == PAGER_JOURNALMODE_MEMORY ) 
line 32002: || ( sqlite3OsDeviceCharacteristics ( pPager -> fd ) & SQLITE_IOCAP_SAFE_APPEND ) 
line 32003: ) { 
line 32004: memcpy ( zHeader , aJournalMagic , sizeof ( aJournalMagic ) ) ; 
line 32005: put32bits ( & zHeader [ sizeof ( aJournalMagic ) ] , 0xffffffff ) ; 
line 32006: } else { 
line 32007: memset ( zHeader , 0 , sizeof ( aJournalMagic ) + 4 ) ; 
line 32008: } 
line 32011: sqlite3_randomness ( sizeof ( pPager -> cksumInit ) , & pPager -> cksumInit ) ; 
line 32012: put32bits ( & zHeader [ sizeof ( aJournalMagic ) + 4 ] , pPager -> cksumInit ) ; 
line 32014: put32bits ( & zHeader [ sizeof ( aJournalMagic ) + 8 ] , pPager -> dbOrigSize ) ; 
line 32016: put32bits ( & zHeader [ sizeof ( aJournalMagic ) + 12 ] , pPager -> sectorSize ) ; 
line 32019: put32bits ( & zHeader [ sizeof ( aJournalMagic ) + 16 ] , pPager -> pageSize ) ; 
line 32026: memset ( & zHeader [ sizeof ( aJournalMagic ) + 20 ] , 0 , 
line 32027: nHeader - ( sizeof ( aJournalMagic ) + 20 ) ) ; 
line 32046: for ( nWrite = 0 ; rc == SQLITE_OK && nWrite < JOURNAL_HDR_SZ ( pPager ) ; nWrite += nHeader ) { 
line 32047: IOTRACE ( ( "JHDR %p %lld %d\n" , pPager , pPager -> journalHdr , nHeader ) ) 
line 32048: rc = sqlite3OsWrite ( pPager -> jfd , zHeader , nHeader , pPager -> journalOff ) ; 
line 32049: pPager -> journalOff += nHeader ; 
line 32050: } 
line 32052: return rc ; 
line 32053: } 
line 32072: static int readJournalHdr ( 
line 32073: Pager * pPager , 
line 32074: int isHot , 
line 32075: i64 journalSize , 
line 32076: u32 * pNRec , 
line 32077: u32 * pDbSize 
line 32078: ) { 
line 32079: int rc ; 
line 32080: unsigned char aMagic [ 8 ] ; 
line 32081: i64 iHdrOff ; 
line 32083: assert ( isOpen ( pPager -> jfd ) ) ; 
line 32089: pPager -> journalOff = journalHdrOffset ( pPager ) ; 
line 32090: if ( pPager -> journalOff + JOURNAL_HDR_SZ ( pPager ) > journalSize ) { 
line 32091: return SQLITE_DONE ; 
line 32092: } 
line 32093: iHdrOff = pPager -> journalOff ; 
line 32100: if ( isHot || iHdrOff != pPager -> journalHdr ) { 
line 32101: rc = sqlite3OsRead ( pPager -> jfd , aMagic , sizeof ( aMagic ) , iHdrOff ) ; 
line 32102: if ( rc ) { 
line 32103: return rc ; 
line 32104: } 
line 32105: if ( memcmp ( aMagic , aJournalMagic , sizeof ( aMagic ) ) != 0 ) { 
line 32106: return SQLITE_DONE ; 
line 32107: } 
line 32108: } 
line 32114: if ( SQLITE_OK != ( rc = read32bits ( pPager -> jfd , iHdrOff + 8 , pNRec ) ) 
line 32115: || SQLITE_OK != ( rc = read32bits ( pPager -> jfd , iHdrOff + 12 , & pPager -> cksumInit ) ) 
line 32116: || SQLITE_OK != ( rc = read32bits ( pPager -> jfd , iHdrOff + 16 , pDbSize ) ) 
line 32117: ) { 
line 32118: return rc ; 
line 32119: } 
line 32121: if ( pPager -> journalOff == 0 ) { 
line 32122: u32 iPageSize ; 
line 32123: u32 iSectorSize ; 
line 32124: u16 iPageSize16 ; 
line 32127: if ( SQLITE_OK != ( rc = read32bits ( pPager -> jfd , iHdrOff + 20 , & iSectorSize ) ) 
line 32128: || SQLITE_OK != ( rc = read32bits ( pPager -> jfd , iHdrOff + 24 , & iPageSize ) ) 
line 32129: ) { 
line 32130: return rc ; 
line 32131: } 
line 32138: if ( iPageSize < 512 || iSectorSize < 32 
line 32139: || iPageSize > SQLITE_MAX_PAGE_SIZE || iSectorSize > MAX_SECTOR_SIZE 
line 32140: || ( ( iPageSize - 1 ) & iPageSize ) != 0 || ( ( iSectorSize - 1 ) & iSectorSize ) != 0 
line 32141: ) { 
line 32147: return SQLITE_DONE ; 
line 32148: } 
line 32154: iPageSize16 = ( u16 ) iPageSize ; 
line 32155: rc = sqlite3PagerSetPagesize ( pPager , & iPageSize16 , - 1 ) ; 
line 32156: testcase ( rc != SQLITE_OK ) ; 
line 32157: assert ( rc != SQLITE_OK || iPageSize16 == ( u16 ) iPageSize ) ; 
line 32165: pPager -> sectorSize = iSectorSize ; 
line 32166: } 
line 32168: pPager -> journalOff += JOURNAL_HDR_SZ ( pPager ) ; 
line 32169: return rc ; 
line 32170: } 
line 32192: static int writeMasterJournal ( Pager * pPager , const char * zMaster ) { 
line 32193: int rc ; 
line 32194: int nMaster ; 
line 32195: i64 iHdrOff ; 
line 32196: i64 jrnlSize ; 
line 32197: u32 cksum = 0 ; 
line 32199: if ( ! zMaster || pPager -> setMaster 
line 32200: || pPager -> journalMode == PAGER_JOURNALMODE_MEMORY 
line 32201: || pPager -> journalMode == PAGER_JOURNALMODE_OFF 
line 32202: ) { 
line 32203: return SQLITE_OK ; 
line 32204: } 
line 32205: pPager -> setMaster = 1 ; 
line 32206: assert ( isOpen ( pPager -> jfd ) ) ; 
line 32209: for ( nMaster = 0 ; zMaster [ nMaster ] ; nMaster ++ ) { 
line 32210: cksum += zMaster [ nMaster ] ; 
line 32211: } 
line 32217: if ( pPager -> fullSync ) { 
line 32218: pPager -> journalOff = journalHdrOffset ( pPager ) ; 
line 32219: } 
line 32220: iHdrOff = pPager -> journalOff ; 
line 32225: if ( ( 0 != ( rc = write32bits ( pPager -> jfd , iHdrOff , PAGER_MJ_PGNO ( pPager ) ) ) ) 
line 32226: || ( 0 != ( rc = sqlite3OsWrite ( pPager -> jfd , zMaster , nMaster , iHdrOff + 4 ) ) ) 
line 32227: || ( 0 != ( rc = write32bits ( pPager -> jfd , iHdrOff + 4 + nMaster , nMaster ) ) ) 
line 32228: || ( 0 != ( rc = write32bits ( pPager -> jfd , iHdrOff + 4 + nMaster + 4 , cksum ) ) ) 
line 32229: || ( 0 != ( rc = sqlite3OsWrite ( pPager -> jfd , aJournalMagic , 8 , iHdrOff + 4 + nMaster + 8 ) ) ) 
line 32230: ) { 
line 32231: return rc ; 
line 32232: } 
line 32233: pPager -> journalOff += ( nMaster + 20 ) ; 
line 32234: pPager -> needSync = ! pPager -> noSync ; 
line 32246: if ( SQLITE_OK == ( rc = sqlite3OsFileSize ( pPager -> jfd , & jrnlSize ) ) 
line 32247: && jrnlSize > pPager -> journalOff 
line 32248: ) { 
line 32249: rc = sqlite3OsTruncate ( pPager -> jfd , pPager -> journalOff ) ; 
line 32250: } 
line 32251: return rc ; 
line 32252: } 
line 32259: static PgHdr * pager_lookup ( Pager * pPager , Pgno pgno ) { 
line 32260: PgHdr * p ; 
line 32265: ( void ) sqlite3PcacheFetch ( pPager -> pPCache , pgno , 0 , & p ) ; 
line 32266: return p ; 
line 32267: } 
line 32275: static void pager_reset ( Pager * pPager ) { 
line 32276: if ( SQLITE_OK == pPager -> errCode ) { 
line 32277: sqlite3BackupRestart ( pPager -> pBackup ) ; 
line 32278: sqlite3PcacheClear ( pPager -> pPCache ) ; 
line 32279: pPager -> dbSizeValid = 0 ; 
line 32280: } 
line 32281: } 
line 32288: static void releaseAllSavepoints ( Pager * pPager ) { 
line 32289: int ii ; 
line 32290: for ( ii = 0 ; ii < pPager -> nSavepoint ; ii ++ ) { 
line 32291: sqlite3BitvecDestroy ( pPager -> aSavepoint [ ii ] . pInSavepoint ) ; 
line 32292: } 
line 32293: if ( ! pPager -> exclusiveMode || sqlite3IsMemJournal ( pPager -> sjfd ) ) { 
line 32294: sqlite3OsClose ( pPager -> sjfd ) ; 
line 32295: } 
line 32296: sqlite3_free ( pPager -> aSavepoint ) ; 
line 32297: pPager -> aSavepoint = 0 ; 
line 32298: pPager -> nSavepoint = 0 ; 
line 32299: pPager -> nSubRec = 0 ; 
line 32300: } 
line 32307: static int addToSavepointBitvecs ( Pager * pPager , Pgno pgno ) { 
line 32308: int ii ; 
line 32309: int rc = SQLITE_OK ; 
line 32311: for ( ii = 0 ; ii < pPager -> nSavepoint ; ii ++ ) { 
line 32312: PagerSavepoint * p = & pPager -> aSavepoint [ ii ] ; 
line 32313: if ( pgno <= p -> nOrig ) { 
line 32314: rc |= sqlite3BitvecSet ( p -> pInSavepoint , pgno ) ; 
line 32315: testcase ( rc == SQLITE_NOMEM ) ; 
line 32316: assert ( rc == SQLITE_OK || rc == SQLITE_NOMEM ) ; 
line 32317: } 
line 32318: } 
line 32319: return rc ; 
line 32320: } 
line 32332: static void pager_unlock ( Pager * pPager ) { 
line 32333: if ( ! pPager -> exclusiveMode ) { 
line 32334: int rc ; 
line 32340: sqlite3OsClose ( pPager -> jfd ) ; 
line 32341: sqlite3BitvecDestroy ( pPager -> pInJournal ) ; 
line 32342: pPager -> pInJournal = 0 ; 
line 32343: releaseAllSavepoints ( pPager ) ; 
line 32350: pPager -> dbSizeValid = 0 ; 
line 32352: rc = osUnlock ( pPager -> fd , NO_LOCK ) ; 
line 32353: if ( rc ) { 
line 32354: pPager -> errCode = rc ; 
line 32355: } 
line 32356: IOTRACE ( ( "UNLOCK %p\n" , pPager ) ) 
line 32362: if ( pPager -> errCode ) { 
line 32363: if ( rc == SQLITE_OK ) { 
line 32364: pPager -> errCode = SQLITE_OK ; 
line 32365: } 
line 32366: pager_reset ( pPager ) ; 
line 32367: } 
line 32369: pPager -> changeCountDone = 0 ; 
line 32370: pPager -> state = PAGER_UNLOCK ; 
line 32371: pPager -> dbModified = 0 ; 
line 32372: } 
line 32373: } 
line 32394: static int pager_error ( Pager * pPager , int rc ) { 
line 32395: int rc2 = rc & 0xff ; 
line 32396: assert ( rc == SQLITE_OK || ! MEMDB ) ; 
line 32397: assert ( 
line 32398: pPager -> errCode == SQLITE_FULL || 
line 32399: pPager -> errCode == SQLITE_OK || 
line 32400: ( pPager -> errCode & 0xff ) == SQLITE_IOERR 
line 32401: ) ; 
line 32402: if ( rc2 == SQLITE_FULL || rc2 == SQLITE_IOERR ) { 
line 32403: pPager -> errCode = rc ; 
line 32404: } 
line 32405: return rc ; 
line 32406: } 
line 32425: static void pagerUnlockAndRollback ( Pager * pPager ) { 
line 32426: if ( pPager -> errCode == SQLITE_OK && pPager -> state >= PAGER_RESERVED ) { 
line 32427: sqlite3BeginBenignMalloc ( ) ; 
line 32428: sqlite3PagerRollback ( pPager ) ; 
line 32429: sqlite3EndBenignMalloc ( ) ; 
line 32430: } 
line 32431: pager_unlock ( pPager ) ; 
line 32432: } 
line 32490: static int pager_end_transaction ( Pager * pPager , int hasMaster ) { 
line 32491: int rc = SQLITE_OK ; 
line 32492: int rc2 = SQLITE_OK ; 
line 32494: if ( pPager -> state < PAGER_RESERVED ) { 
line 32495: return SQLITE_OK ; 
line 32496: } 
line 32497: releaseAllSavepoints ( pPager ) ; 
line 32499: assert ( isOpen ( pPager -> jfd ) || pPager -> pInJournal == 0 ) ; 
line 32500: if ( isOpen ( pPager -> jfd ) ) { 
line 32503: if ( sqlite3IsMemJournal ( pPager -> jfd ) ) { 
line 32504: assert ( pPager -> journalMode == PAGER_JOURNALMODE_MEMORY ) ; 
line 32505: sqlite3OsClose ( pPager -> jfd ) ; 
line 32506: } else if ( pPager -> journalMode == PAGER_JOURNALMODE_TRUNCATE ) { 
line 32507: if ( pPager -> journalOff == 0 ) { 
line 32508: rc = SQLITE_OK ; 
line 32509: } else { 
line 32510: rc = sqlite3OsTruncate ( pPager -> jfd , 0 ) ; 
line 32511: } 
line 32512: pPager -> journalOff = 0 ; 
line 32513: pPager -> journalStarted = 0 ; 
line 32514: } else if ( pPager -> exclusiveMode 
line 32515: || pPager -> journalMode == PAGER_JOURNALMODE_PERSIST 
line 32516: ) { 
line 32517: rc = zeroJournalHdr ( pPager , hasMaster ) ; 
line 32518: pager_error ( pPager , rc ) ; 
line 32519: pPager -> journalOff = 0 ; 
line 32520: pPager -> journalStarted = 0 ; 
line 32521: } else { 
line 32526: assert ( pPager -> journalMode == PAGER_JOURNALMODE_DELETE 
line 32527: || pPager -> journalMode == PAGER_JOURNALMODE_MEMORY 
line 32528: ) ; 
line 32529: sqlite3OsClose ( pPager -> jfd ) ; 
line 32530: if ( ! pPager -> tempFile ) { 
line 32531: rc = sqlite3OsDelete ( pPager -> pVfs , pPager -> zJournal , 0 ) ; 
line 32532: } 
line 32533: } 
line 32535: # ifdef SQLITE_CHECK_PAGES 
line 32536: sqlite3PcacheIterateDirty ( pPager -> pPCache , pager_set_pagehash ) ; 
line 32537: # endif 
line 32539: sqlite3PcacheCleanAll ( pPager -> pPCache ) ; 
line 32540: sqlite3BitvecDestroy ( pPager -> pInJournal ) ; 
line 32541: pPager -> pInJournal = 0 ; 
line 32542: pPager -> nRec = 0 ; 
line 32543: } 
line 32545: if ( ! pPager -> exclusiveMode ) { 
line 32546: rc2 = osUnlock ( pPager -> fd , SHARED_LOCK ) ; 
line 32547: pPager -> state = PAGER_SHARED ; 
line 32548: pPager -> changeCountDone = 0 ; 
line 32549: } else if ( pPager -> state == PAGER_SYNCED ) { 
line 32550: pPager -> state = PAGER_EXCLUSIVE ; 
line 32551: } 
line 32552: pPager -> setMaster = 0 ; 
line 32553: pPager -> needSync = 0 ; 
line 32554: pPager -> dbModified = 0 ; 
line 32558: pPager -> dbOrigSize = 0 ; 
line 32559: sqlite3PcacheTruncate ( pPager -> pPCache , pPager -> dbSize ) ; 
line 32560: if ( ! MEMDB ) { 
line 32561: pPager -> dbSizeValid = 0 ; 
line 32562: } 
line 32564: return ( rc == SQLITE_OK ? rc2 : rc ) ; 
line 32565: } 
line 32586: static u32 pager_cksum ( Pager * pPager , const u8 * aData ) { 
line 32587: u32 cksum = pPager -> cksumInit ; 
line 32588: int i = pPager -> pageSize - 200 ; 
line 32589: while ( i > 0 ) { 
line 32590: cksum += aData [ i ] ; 
line 32591: i -= 200 ; 
line 32592: } 
line 32593: return cksum ; 
line 32594: } 
line 32634: static int pager_playback_one_page ( 
line 32635: Pager * pPager , 
line 32636: int isMainJrnl , 
line 32637: int isUnsync , 
line 32638: i64 * pOffset , 
line 32639: int isSavepnt , 
line 32640: Bitvec * pDone 
line 32641: ) { 
line 32642: int rc ; 
line 32643: PgHdr * pPg ; 
line 32644: Pgno pgno ; 
line 32645: u32 cksum ; 
line 32646: char * aData ; 
line 32647: sqlite3_file * jfd ; 
line 32649: assert ( ( isMainJrnl & ~ 1 ) == 0 ) ; 
line 32650: assert ( ( isSavepnt & ~ 1 ) == 0 ) ; 
line 32651: assert ( isMainJrnl || pDone ) ; 
line 32652: assert ( isSavepnt || pDone == 0 ) ; 
line 32654: aData = pPager -> pTmpSpace ; 
line 32655: assert ( aData ) ; 
line 32660: jfd = isMainJrnl ? pPager -> jfd : pPager -> sjfd ; 
line 32661: rc = read32bits ( jfd , * pOffset , & pgno ) ; 
line 32662: if ( rc != SQLITE_OK ) return rc ; 
line 32663: rc = sqlite3OsRead ( jfd , ( u8 * ) aData , pPager -> pageSize , ( * pOffset ) + 4 ) ; 
line 32664: if ( rc != SQLITE_OK ) return rc ; 
line 32665: * pOffset += pPager -> pageSize + 4 + isMainJrnl * 4 ; 
line 32672: if ( pgno == 0 || pgno == PAGER_MJ_PGNO ( pPager ) ) { 
line 32673: assert ( ! isSavepnt ) ; 
line 32674: return SQLITE_DONE ; 
line 32675: } 
line 32676: if ( pgno > ( Pgno ) pPager -> dbSize || sqlite3BitvecTest ( pDone , pgno ) ) { 
line 32677: return SQLITE_OK ; 
line 32678: } 
line 32679: if ( isMainJrnl ) { 
line 32680: rc = read32bits ( jfd , ( * pOffset ) - 4 , & cksum ) ; 
line 32681: if ( rc ) return rc ; 
line 32682: if ( ! isSavepnt && pager_cksum ( pPager , ( u8 * ) aData ) != cksum ) { 
line 32683: return SQLITE_DONE ; 
line 32684: } 
line 32685: } 
line 32687: if ( pDone && ( rc = sqlite3BitvecSet ( pDone , pgno ) ) != SQLITE_OK ) { 
line 32688: return rc ; 
line 32689: } 
line 32691: assert ( pPager -> state == PAGER_RESERVED || pPager -> state >= PAGER_EXCLUSIVE ) ; 
line 32725: pPg = pager_lookup ( pPager , pgno ) ; 
line 32726: assert ( pPg || ! MEMDB ) ; 
line 32727: PAGERTRACE ( ( "PLAYBACK %d page %d hash(%08x) %s\n" , 
line 32728: PAGERID ( pPager ) , pgno , pager_datahash ( pPager -> pageSize , ( u8 * ) aData ) , 
line 32729: ( isMainJrnl ? "main-journal" : "sub-journal" ) 
line 32730: ) ) ; 
line 32731: if ( ( pPager -> state >= PAGER_EXCLUSIVE ) 
line 32732: && ( pPg == 0 || 0 == ( pPg -> flags & PGHDR_NEED_SYNC ) ) 
line 32733: && isOpen ( pPager -> fd ) 
line 32734: && ! isUnsync 
line 32735: ) { 
line 32736: i64 ofst = ( pgno - 1 ) * ( i64 ) pPager -> pageSize ; 
line 32737: rc = sqlite3OsWrite ( pPager -> fd , ( u8 * ) aData , pPager -> pageSize , ofst ) ; 
line 32738: if ( pgno > pPager -> dbFileSize ) { 
line 32739: pPager -> dbFileSize = pgno ; 
line 32740: } 
line 32741: if ( pPager -> pBackup ) { 
line 32742: CODEC1 ( pPager , aData , pgno , 3 , rc = SQLITE_NOMEM ) ; 
line 32743: sqlite3BackupUpdate ( pPager -> pBackup , pgno , ( u8 * ) aData ) ; 
line 32744: CODEC2 ( pPager , aData , pgno , 7 , rc = SQLITE_NOMEM , aData ) ; 
line 32745: } 
line 32746: } else if ( ! isMainJrnl && pPg == 0 ) { 
line 32763: assert ( isSavepnt ) ; 
line 32764: if ( ( rc = sqlite3PagerAcquire ( pPager , pgno , & pPg , 1 ) ) != SQLITE_OK ) { 
line 32765: return rc ; 
line 32766: } 
line 32767: pPg -> flags &= ~ PGHDR_NEED_READ ; 
line 32768: sqlite3PcacheMakeDirty ( pPg ) ; 
line 32769: } 
line 32770: if ( pPg ) { 
line 32777: void * pData ; 
line 32778: pData = pPg -> pData ; 
line 32779: memcpy ( pData , ( u8 * ) aData , pPager -> pageSize ) ; 
line 32780: pPager -> xReiniter ( pPg ) ; 
line 32781: if ( isMainJrnl && ( ! isSavepnt || * pOffset <= pPager -> journalHdr ) ) { 
line 32800: sqlite3PcacheMakeClean ( pPg ) ; 
line 32801: } 
line 32802: # ifdef SQLITE_CHECK_PAGES 
line 32803: pPg -> pageHash = pager_pagehash ( pPg ) ; 
line 32804: # endif 
line 32807: if ( pgno == 1 ) { 
line 32808: memcpy ( & pPager -> dbFileVers , & ( ( u8 * ) pData ) [ 24 ] , sizeof ( pPager -> dbFileVers ) ) ; 
line 32809: } 
line 32812: CODEC1 ( pPager , pData , pPg -> pgno , 3 , rc = SQLITE_NOMEM ) ; 
line 32813: sqlite3PcacheRelease ( pPg ) ; 
line 32814: } 
line 32815: return rc ; 
line 32816: } 
line 32861: static int pager_delmaster ( Pager * pPager , const char * zMaster ) { 
line 32862: sqlite3_vfs * pVfs = pPager -> pVfs ; 
line 32863: int rc ; 
line 32864: sqlite3_file * pMaster ; 
line 32865: sqlite3_file * pJournal ; 
line 32866: char * zMasterJournal = 0 ; 
line 32867: i64 nMasterJournal ; 
line 32872: pMaster = ( sqlite3_file * ) sqlite3MallocZero ( pVfs -> szOsFile * 2 ) ; 
line 32873: pJournal = ( sqlite3_file * ) ( ( ( u8 * ) pMaster ) + pVfs -> szOsFile ) ; 
line 32874: if ( ! pMaster ) { 
line 32875: rc = SQLITE_NOMEM ; 
line 32876: } else { 
line 32877: const int flags = ( SQLITE_OPEN_READONLY | SQLITE_OPEN_MASTER_JOURNAL ) ; 
line 32878: rc = sqlite3OsOpen ( pVfs , zMaster , pMaster , flags , 0 ) ; 
line 32879: } 
line 32880: if ( rc != SQLITE_OK ) goto delmaster_out ; 
line 32882: rc = sqlite3OsFileSize ( pMaster , & nMasterJournal ) ; 
line 32883: if ( rc != SQLITE_OK ) goto delmaster_out ; 
line 32885: if ( nMasterJournal > 0 ) { 
line 32886: char * zJournal ; 
line 32887: char * zMasterPtr = 0 ; 
line 32888: int nMasterPtr = pVfs -> mxPathname + 1 ; 
line 32893: zMasterJournal = sqlite3Malloc ( ( int ) nMasterJournal + nMasterPtr + 1 ) ; 
line 32894: if ( ! zMasterJournal ) { 
line 32895: rc = SQLITE_NOMEM ; 
line 32896: goto delmaster_out ; 
line 32897: } 
line 32898: zMasterPtr = & zMasterJournal [ nMasterJournal + 1 ] ; 
line 32899: rc = sqlite3OsRead ( pMaster , zMasterJournal , ( int ) nMasterJournal , 0 ) ; 
line 32900: if ( rc != SQLITE_OK ) goto delmaster_out ; 
line 32901: zMasterJournal [ nMasterJournal ] = 0 ; 
line 32903: zJournal = zMasterJournal ; 
line 32904: while ( ( zJournal - zMasterJournal ) < nMasterJournal ) { 
line 32905: int exists ; 
line 32906: rc = sqlite3OsAccess ( pVfs , zJournal , SQLITE_ACCESS_EXISTS , & exists ) ; 
line 32907: if ( rc != SQLITE_OK ) { 
line 32908: goto delmaster_out ; 
line 32909: } 
line 32910: if ( exists ) { 
line 32915: int c ; 
line 32916: int flags = ( SQLITE_OPEN_READONLY | SQLITE_OPEN_MAIN_JOURNAL ) ; 
line 32917: rc = sqlite3OsOpen ( pVfs , zJournal , pJournal , flags , 0 ) ; 
line 32918: if ( rc != SQLITE_OK ) { 
line 32919: goto delmaster_out ; 
line 32920: } 
line 32922: rc = readMasterJournal ( pJournal , zMasterPtr , nMasterPtr ) ; 
line 32923: sqlite3OsClose ( pJournal ) ; 
line 32924: if ( rc != SQLITE_OK ) { 
line 32925: goto delmaster_out ; 
line 32926: } 
line 32928: c = zMasterPtr [ 0 ] != 0 && strcmp ( zMasterPtr , zMaster ) == 0 ; 
line 32929: if ( c ) { 
line 32931: goto delmaster_out ; 
line 32932: } 
line 32933: } 
line 32934: zJournal += ( sqlite3Strlen30 ( zJournal ) + 1 ) ; 
line 32935: } 
line 32936: } 
line 32938: rc = sqlite3OsDelete ( pVfs , zMaster , 0 ) ; 
line 32940: delmaster_out : 
line 32941: if ( zMasterJournal ) { 
line 32942: sqlite3_free ( zMasterJournal ) ; 
line 32943: } 
line 32944: if ( pMaster ) { 
line 32945: sqlite3OsClose ( pMaster ) ; 
line 32946: assert ( ! isOpen ( pJournal ) ) ; 
line 32947: } 
line 32948: sqlite3_free ( pMaster ) ; 
line 32949: return rc ; 
line 32950: } 
line 32973: static int pager_truncate ( Pager * pPager , Pgno nPage ) { 
line 32974: int rc = SQLITE_OK ; 
line 32975: if ( pPager -> state >= PAGER_EXCLUSIVE && isOpen ( pPager -> fd ) ) { 
line 32976: i64 currentSize , newSize ; 
line 32978: rc = sqlite3OsFileSize ( pPager -> fd , & currentSize ) ; 
line 32979: newSize = pPager -> pageSize * ( i64 ) nPage ; 
line 32980: if ( rc == SQLITE_OK && currentSize != newSize ) { 
line 32981: if ( currentSize > newSize ) { 
line 32982: rc = sqlite3OsTruncate ( pPager -> fd , newSize ) ; 
line 32983: } else { 
line 32984: rc = sqlite3OsWrite ( pPager -> fd , "" , 1 , newSize - 1 ) ; 
line 32985: } 
line 32986: if ( rc == SQLITE_OK ) { 
line 32987: pPager -> dbFileSize = nPage ; 
line 32988: } 
line 32989: } 
line 32990: } 
line 32991: return rc ; 
line 32992: } 
line 33008: static void setSectorSize ( Pager * pPager ) { 
line 33009: assert ( isOpen ( pPager -> fd ) || pPager -> tempFile ) ; 
line 33011: if ( ! pPager -> tempFile ) { 
line 33016: pPager -> sectorSize = sqlite3OsSectorSize ( pPager -> fd ) ; 
line 33017: } 
line 33018: if ( pPager -> sectorSize < 32 ) { 
line 33019: pPager -> sectorSize = 512 ; 
line 33020: } 
line 33021: if ( pPager -> sectorSize > MAX_SECTOR_SIZE ) { 
line 33022: assert ( MAX_SECTOR_SIZE >= 512 ) ; 
line 33023: pPager -> sectorSize = MAX_SECTOR_SIZE ; 
line 33024: } 
line 33025: } 
line 33084: static int pager_playback ( Pager * pPager , int isHot ) { 
line 33085: sqlite3_vfs * pVfs = pPager -> pVfs ; 
line 33086: i64 szJ ; 
line 33087: u32 nRec ; 
line 33088: u32 u ; 
line 33089: Pgno mxPg = 0 ; 
line 33090: int rc ; 
line 33091: int res = 1 ; 
line 33092: char * zMaster = 0 ; 
line 33093: int needPagerReset ; 
line 33098: assert ( isOpen ( pPager -> jfd ) ) ; 
line 33099: rc = sqlite3OsFileSize ( pPager -> jfd , & szJ ) ; 
line 33100: if ( rc != SQLITE_OK || szJ == 0 ) { 
line 33101: goto end_playback ; 
line 33102: } 
line 33115: zMaster = pPager -> pTmpSpace ; 
line 33116: rc = readMasterJournal ( pPager -> jfd , zMaster , pPager -> pVfs -> mxPathname + 1 ) ; 
line 33117: if ( rc == SQLITE_OK && zMaster [ 0 ] ) { 
line 33118: rc = sqlite3OsAccess ( pVfs , zMaster , SQLITE_ACCESS_EXISTS , & res ) ; 
line 33119: } 
line 33120: zMaster = 0 ; 
line 33121: if ( rc != SQLITE_OK || ! res ) { 
line 33122: goto end_playback ; 
line 33123: } 
line 33124: pPager -> journalOff = 0 ; 
line 33125: needPagerReset = isHot ; 
line 33131: while ( 1 ) { 
line 33132: int isUnsync = 0 ; 
line 33139: rc = readJournalHdr ( pPager , isHot , szJ , & nRec , & mxPg ) ; 
line 33140: if ( rc != SQLITE_OK ) { 
line 33141: if ( rc == SQLITE_DONE ) { 
line 33142: rc = SQLITE_OK ; 
line 33143: } 
line 33144: goto end_playback ; 
line 33145: } 
line 33152: if ( nRec == 0xffffffff ) { 
line 33153: assert ( pPager -> journalOff == JOURNAL_HDR_SZ ( pPager ) ) ; 
line 33154: nRec = ( int ) ( ( szJ - JOURNAL_HDR_SZ ( pPager ) ) / JOURNAL_PG_SZ ( pPager ) ) ; 
line 33155: } 
line 33171: if ( nRec == 0 && ! isHot && 
line 33172: pPager -> journalHdr + JOURNAL_HDR_SZ ( pPager ) == pPager -> journalOff ) { 
line 33173: nRec = ( int ) ( ( szJ - pPager -> journalOff ) / JOURNAL_PG_SZ ( pPager ) ) ; 
line 33174: isUnsync = 1 ; 
line 33175: } 
line 33180: if ( pPager -> journalOff == JOURNAL_HDR_SZ ( pPager ) ) { 
line 33181: rc = pager_truncate ( pPager , mxPg ) ; 
line 33182: if ( rc != SQLITE_OK ) { 
line 33183: goto end_playback ; 
line 33184: } 
line 33185: pPager -> dbSize = mxPg ; 
line 33186: } 
line 33191: for ( u = 0 ; u < nRec ; u ++ ) { 
line 33192: if ( needPagerReset ) { 
line 33193: pager_reset ( pPager ) ; 
line 33194: needPagerReset = 0 ; 
line 33195: } 
line 33196: rc = pager_playback_one_page ( pPager , 1 , isUnsync , & pPager -> journalOff , 0 , 0 ) ; 
line 33197: if ( rc != SQLITE_OK ) { 
line 33198: if ( rc == SQLITE_DONE ) { 
line 33199: rc = SQLITE_OK ; 
line 33200: pPager -> journalOff = szJ ; 
line 33201: break ; 
line 33202: } else { 
line 33208: goto end_playback ; 
line 33209: } 
line 33210: } 
line 33211: } 
line 33212: } 
line 33214: assert ( 0 ) ; 
line 33216: end_playback : 
line 33222: assert ( 
line 33223: pPager -> fd -> pMethods == 0 || 
line 33224: sqlite3OsFileControl ( pPager -> fd , SQLITE_FCNTL_DB_UNCHANGED , 0 ) >= SQLITE_OK 
line 33225: ) ; 
line 33236: pPager -> changeCountDone = pPager -> tempFile ; 
line 33238: if ( rc == SQLITE_OK ) { 
line 33239: zMaster = pPager -> pTmpSpace ; 
line 33240: rc = readMasterJournal ( pPager -> jfd , zMaster , pPager -> pVfs -> mxPathname + 1 ) ; 
line 33241: testcase ( rc != SQLITE_OK ) ; 
line 33242: } 
line 33243: if ( rc == SQLITE_OK ) { 
line 33244: rc = pager_end_transaction ( pPager , zMaster [ 0 ] != '\0' ) ; 
line 33245: testcase ( rc != SQLITE_OK ) ; 
line 33246: } 
line 33247: if ( rc == SQLITE_OK && zMaster [ 0 ] && res ) { 
line 33251: rc = pager_delmaster ( pPager , zMaster ) ; 
line 33252: testcase ( rc != SQLITE_OK ) ; 
line 33253: } 
line 33259: setSectorSize ( pPager ) ; 
line 33260: return rc ; 
line 33261: } 
line 33299: static int pagerPlaybackSavepoint ( Pager * pPager , PagerSavepoint * pSavepoint ) { 
line 33300: i64 szJ ; 
line 33301: i64 iHdrOff ; 
line 33302: int rc = SQLITE_OK ; 
line 33303: Bitvec * pDone = 0 ; 
line 33305: assert ( pPager -> state >= PAGER_SHARED ) ; 
line 33308: if ( pSavepoint ) { 
line 33309: pDone = sqlite3BitvecCreate ( pSavepoint -> nOrig ) ; 
line 33310: if ( ! pDone ) { 
line 33311: return SQLITE_NOMEM ; 
line 33312: } 
line 33313: } 
line 33318: pPager -> dbSize = pSavepoint ? pSavepoint -> nOrig : pPager -> dbOrigSize ; 
line 33325: szJ = pPager -> journalOff ; 
line 33334: if ( pSavepoint ) { 
line 33335: iHdrOff = pSavepoint -> iHdrOffset ? pSavepoint -> iHdrOffset : szJ ; 
line 33336: pPager -> journalOff = pSavepoint -> iOffset ; 
line 33337: while ( rc == SQLITE_OK && pPager -> journalOff < iHdrOff ) { 
line 33338: rc = pager_playback_one_page ( pPager , 1 , 0 , & pPager -> journalOff , 1 , pDone ) ; 
line 33339: } 
line 33340: assert ( rc != SQLITE_DONE ) ; 
line 33341: } else { 
line 33342: pPager -> journalOff = 0 ; 
line 33343: } 
line 33350: while ( rc == SQLITE_OK && pPager -> journalOff < szJ ) { 
line 33351: u32 ii ; 
line 33352: u32 nJRec = 0 ; 
line 33353: u32 dummy ; 
line 33354: rc = readJournalHdr ( pPager , 0 , szJ , & nJRec , & dummy ) ; 
line 33355: assert ( rc != SQLITE_DONE ) ; 
line 33362: if ( nJRec == 0 
line 33363: && pPager -> journalHdr + JOURNAL_HDR_SZ ( pPager ) == pPager -> journalOff 
line 33364: ) { 
line 33365: nJRec = ( u32 ) ( ( szJ - pPager -> journalOff ) / JOURNAL_PG_SZ ( pPager ) ) ; 
line 33366: } 
line 33367: for ( ii = 0 ; rc == SQLITE_OK && ii < nJRec && pPager -> journalOff < szJ ; ii ++ ) { 
line 33368: rc = pager_playback_one_page ( pPager , 1 , 0 , & pPager -> journalOff , 1 , pDone ) ; 
line 33369: } 
line 33370: assert ( rc != SQLITE_DONE ) ; 
line 33371: } 
line 33372: assert ( rc != SQLITE_OK || pPager -> journalOff == szJ ) ; 
line 33378: if ( pSavepoint ) { 
line 33379: u32 ii ; 
line 33380: i64 offset = pSavepoint -> iSubRec * ( 4 + pPager -> pageSize ) ; 
line 33381: for ( ii = pSavepoint -> iSubRec ; rc == SQLITE_OK && ii < pPager -> nSubRec ; ii ++ ) { 
line 33382: assert ( offset == ii * ( 4 + pPager -> pageSize ) ) ; 
line 33383: rc = pager_playback_one_page ( pPager , 0 , 0 , & offset , 1 , pDone ) ; 
line 33384: } 
line 33385: assert ( rc != SQLITE_DONE ) ; 
line 33386: } 
line 33388: sqlite3BitvecDestroy ( pDone ) ; 
line 33389: if ( rc == SQLITE_OK ) { 
line 33390: pPager -> journalOff = szJ ; 
line 33391: } 
line 33392: return rc ; 
line 33393: } 
line 33398: SQLITE_PRIVATE void sqlite3PagerSetCachesize ( Pager * pPager , int mxPage ) { 
line 33399: sqlite3PcacheSetCachesize ( pPager -> pPCache , mxPage ) ; 
line 33400: } 
line 33428: # ifndef SQLITE_OMIT_PAGER_PRAGMAS 
line 33429: SQLITE_PRIVATE void sqlite3PagerSetSafetyLevel ( Pager * pPager , int level , int bFullFsync ) { 
line 33430: pPager -> noSync = ( level == 1 || pPager -> tempFile ) ? 1 : 0 ; 
line 33431: pPager -> fullSync = ( level == 3 && ! pPager -> tempFile ) ? 1 : 0 ; 
line 33432: pPager -> sync_flags = ( bFullFsync ? SQLITE_SYNC_FULL : SQLITE_SYNC_NORMAL ) ; 
line 33433: if ( pPager -> noSync ) pPager -> needSync = 0 ; 
line 33434: } 
line 33435: # endif 
line 33442: # ifdef SQLITE_TEST 
line 33443: SQLITE_API int sqlite3_opentemp_count = 0 ; 
line 33444: # endif 
line 33461: static int pagerOpentemp ( 
line 33462: Pager * pPager , 
line 33463: sqlite3_file * pFile , 
line 33464: int vfsFlags 
line 33465: ) { 
line 33466: int rc ; 
line 33468: # ifdef SQLITE_TEST 
line 33469: sqlite3_opentemp_count ++ ; 
line 33470: # endif 
line 33472: vfsFlags |= SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | 
line 33473: SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE ; 
line 33474: rc = sqlite3OsOpen ( pPager -> pVfs , 0 , pFile , vfsFlags , 0 ) ; 
line 33475: assert ( rc != SQLITE_OK || isOpen ( pFile ) ) ; 
line 33476: return rc ; 
line 33477: } 
line 33500: SQLITE_PRIVATE void sqlite3PagerSetBusyhandler ( 
line 33501: Pager * pPager , 
line 33502: int ( * xBusyHandler ) ( void * ) , 
line 33503: void * pBusyHandlerArg 
line 33504: ) { 
line 33505: pPager -> xBusyHandler = xBusyHandler ; 
line 33506: pPager -> pBusyHandlerArg = pBusyHandlerArg ; 
line 33507: } 
line 33513: # ifdef SQLITE_HAS_CODEC 
line 33514: static void pagerReportSize ( Pager * pPager ) { 
line 33515: if ( pPager -> xCodecSizeChng ) { 
line 33516: pPager -> xCodecSizeChng ( pPager -> pCodec , pPager -> pageSize , 
line 33517: ( int ) pPager -> nReserve ) ; 
line 33518: } 
line 33519: } 
line 33520: # else 
line 33521: # define pagerReportSize ( X ) 
line 33522: # endif 
line 33554: SQLITE_PRIVATE int sqlite3PagerSetPagesize ( Pager * pPager , u16 * pPageSize , int nReserve ) { 
line 33555: int rc = pPager -> errCode ; 
line 33557: if ( rc == SQLITE_OK ) { 
line 33558: u16 pageSize = * pPageSize ; 
line 33559: assert ( pageSize == 0 || ( pageSize >= 512 && pageSize <= SQLITE_MAX_PAGE_SIZE ) ) ; 
line 33560: if ( ( pPager -> memDb == 0 || pPager -> dbSize == 0 ) 
line 33561: && sqlite3PcacheRefCount ( pPager -> pPCache ) == 0 
line 33562: && pageSize && pageSize != pPager -> pageSize 
line 33563: ) { 
line 33564: char * pNew = ( char * ) sqlite3PageMalloc ( pageSize ) ; 
line 33565: if ( ! pNew ) { 
line 33566: rc = SQLITE_NOMEM ; 
line 33567: } else { 
line 33568: pager_reset ( pPager ) ; 
line 33569: pPager -> pageSize = pageSize ; 
line 33570: sqlite3PageFree ( pPager -> pTmpSpace ) ; 
line 33571: pPager -> pTmpSpace = pNew ; 
line 33572: sqlite3PcacheSetPageSize ( pPager -> pPCache , pageSize ) ; 
line 33573: } 
line 33574: } 
line 33575: * pPageSize = ( u16 ) pPager -> pageSize ; 
line 33576: if ( nReserve < 0 ) nReserve = pPager -> nReserve ; 
line 33577: assert ( nReserve >= 0 && nReserve < 1000 ) ; 
line 33578: pPager -> nReserve = ( i16 ) nReserve ; 
line 33579: pagerReportSize ( pPager ) ; 
line 33580: } 
line 33581: return rc ; 
line 33582: } 
line 33592: SQLITE_PRIVATE void * sqlite3PagerTempSpace ( Pager * pPager ) { 
line 33593: return pPager -> pTmpSpace ; 
line 33594: } 
line 33603: SQLITE_PRIVATE int sqlite3PagerMaxPageCount ( Pager * pPager , int mxPage ) { 
line 33604: if ( mxPage > 0 ) { 
line 33605: pPager -> mxPgno = mxPage ; 
line 33606: } 
line 33607: sqlite3PagerPagecount ( pPager , 0 ) ; 
line 33608: return pPager -> mxPgno ; 
line 33609: } 
line 33619: # ifdef SQLITE_TEST 
line 33620: SQLITE_API extern int sqlite3_io_error_pending ; 
line 33621: SQLITE_API extern int sqlite3_io_error_hit ; 
line 33622: static int saved_cnt ; 
line 33623: void disable_simulated_io_errors ( void ) { 
line 33624: saved_cnt = sqlite3_io_error_pending ; 
line 33625: sqlite3_io_error_pending = - 1 ; 
line 33626: } 
line 33627: void enable_simulated_io_errors ( void ) { 
line 33628: sqlite3_io_error_pending = saved_cnt ; 
line 33629: } 
line 33630: # else 
line 33631: # define disable_simulated_io_errors ( ) 
line 33632: # define enable_simulated_io_errors ( ) 
line 33633: # endif 
line 33649: SQLITE_PRIVATE int sqlite3PagerReadFileheader ( Pager * pPager , int N , unsigned char * pDest ) { 
line 33650: int rc = SQLITE_OK ; 
line 33651: memset ( pDest , 0 , N ) ; 
line 33652: assert ( isOpen ( pPager -> fd ) || pPager -> tempFile ) ; 
line 33653: if ( isOpen ( pPager -> fd ) ) { 
line 33654: IOTRACE ( ( "DBHDR %p 0 %d\n" , pPager , N ) ) 
line 33655: rc = sqlite3OsRead ( pPager -> fd , pDest , N , 0 ) ; 
line 33656: if ( rc == SQLITE_IOERR_SHORT_READ ) { 
line 33657: rc = SQLITE_OK ; 
line 33658: } 
line 33659: } 
line 33660: return rc ; 
line 33661: } 
line 33678: SQLITE_PRIVATE int sqlite3PagerPagecount ( Pager * pPager , int * pnPage ) { 
line 33679: Pgno nPage ; 
line 33682: if ( pPager -> errCode ) { 
line 33683: return pPager -> errCode ; 
line 33684: } 
line 33687: if ( pPager -> dbSizeValid ) { 
line 33688: nPage = pPager -> dbSize ; 
line 33689: } else { 
line 33690: int rc ; 
line 33691: i64 n = 0 ; 
line 33693: assert ( isOpen ( pPager -> fd ) || pPager -> tempFile ) ; 
line 33694: if ( isOpen ( pPager -> fd ) && ( 0 != ( rc = sqlite3OsFileSize ( pPager -> fd , & n ) ) ) ) { 
line 33695: pager_error ( pPager , rc ) ; 
line 33696: return rc ; 
line 33697: } 
line 33698: if ( n > 0 && n < pPager -> pageSize ) { 
line 33699: nPage = 1 ; 
line 33700: } else { 
line 33701: nPage = ( Pgno ) ( n / pPager -> pageSize ) ; 
line 33702: } 
line 33703: if ( pPager -> state != PAGER_UNLOCK ) { 
line 33704: pPager -> dbSize = nPage ; 
line 33705: pPager -> dbFileSize = nPage ; 
line 33706: pPager -> dbSizeValid = 1 ; 
line 33707: } 
line 33708: } 
line 33714: if ( nPage > pPager -> mxPgno ) { 
line 33715: pPager -> mxPgno = ( Pgno ) nPage ; 
line 33716: } 
line 33719: if ( pnPage ) { 
line 33720: * pnPage = nPage ; 
line 33721: } 
line 33722: return SQLITE_OK ; 
line 33723: } 
line 33740: static int pager_wait_on_lock ( Pager * pPager , int locktype ) { 
line 33741: int rc ; 
line 33744: assert ( PAGER_SHARED == SHARED_LOCK ) ; 
line 33745: assert ( PAGER_RESERVED == RESERVED_LOCK ) ; 
line 33746: assert ( PAGER_EXCLUSIVE == EXCLUSIVE_LOCK ) ; 
line 33751: assert ( pPager -> state >= PAGER_SHARED || pPager -> dbSizeValid == 0 ) ; 
line 33752: assert ( pPager -> state >= PAGER_SHARED || pPager -> dbModified == 0 ) ; 
line 33759: assert ( ( pPager -> state >= locktype ) 
line 33760: || ( pPager -> state == PAGER_UNLOCK && locktype == PAGER_SHARED ) 
line 33761: || ( pPager -> state == PAGER_RESERVED && locktype == PAGER_EXCLUSIVE ) 
line 33762: ) ; 
line 33764: if ( pPager -> state >= locktype ) { 
line 33765: rc = SQLITE_OK ; 
line 33766: } else { 
line 33767: do { 
line 33768: rc = sqlite3OsLock ( pPager -> fd , locktype ) ; 
line 33769: } while ( rc == SQLITE_BUSY && pPager -> xBusyHandler ( pPager -> pBusyHandlerArg ) ) ; 
line 33770: if ( rc == SQLITE_OK ) { 
line 33771: pPager -> state = ( u8 ) locktype ; 
line 33772: IOTRACE ( ( "LOCK %p %d\n" , pPager , locktype ) ) 
line 33773: } 
line 33774: } 
line 33775: return rc ; 
line 33776: } 
line 33800: # if defined ( SQLITE_DEBUG ) 
line 33801: static void assertTruncateConstraintCb ( PgHdr * pPg ) { 
line 33802: assert ( pPg -> flags & PGHDR_DIRTY ) ; 
line 33803: assert ( ! subjRequiresPage ( pPg ) || pPg -> pgno <= pPg -> pPager -> dbSize ) ; 
line 33804: } 
line 33805: static void assertTruncateConstraint ( Pager * pPager ) { 
line 33806: sqlite3PcacheIterateDirty ( pPager -> pPCache , assertTruncateConstraintCb ) ; 
line 33807: } 
line 33808: # else 
line 33809: # define assertTruncateConstraint ( pPager ) 
line 33810: # endif 
line 33818: SQLITE_PRIVATE void sqlite3PagerTruncateImage ( Pager * pPager , Pgno nPage ) { 
line 33819: assert ( pPager -> dbSizeValid ) ; 
line 33820: assert ( pPager -> dbSize >= nPage ) ; 
line 33821: assert ( pPager -> state >= PAGER_RESERVED ) ; 
line 33822: pPager -> dbSize = nPage ; 
line 33823: assertTruncateConstraint ( pPager ) ; 
line 33824: } 
line 33840: SQLITE_PRIVATE int sqlite3PagerClose ( Pager * pPager ) { 
line 33841: disable_simulated_io_errors ( ) ; 
line 33842: sqlite3BeginBenignMalloc ( ) ; 
line 33843: pPager -> errCode = 0 ; 
line 33844: pPager -> exclusiveMode = 0 ; 
line 33845: pager_reset ( pPager ) ; 
line 33846: if ( MEMDB ) { 
line 33847: pager_unlock ( pPager ) ; 
line 33848: } else { 
line 33855: pPager -> journalHdr = - 1 ; 
line 33856: pagerUnlockAndRollback ( pPager ) ; 
line 33857: } 
line 33858: sqlite3EndBenignMalloc ( ) ; 
line 33859: enable_simulated_io_errors ( ) ; 
line 33860: PAGERTRACE ( ( "CLOSE %d\n" , PAGERID ( pPager ) ) ) ; 
line 33861: IOTRACE ( ( "CLOSE %p\n" , pPager ) ) 
line 33862: sqlite3OsClose ( pPager -> fd ) ; 
line 33863: sqlite3PageFree ( pPager -> pTmpSpace ) ; 
line 33864: sqlite3PcacheClose ( pPager -> pPCache ) ; 
line 33866: # ifdef SQLITE_HAS_CODEC 
line 33867: if ( pPager -> xCodecFree ) pPager -> xCodecFree ( pPager -> pCodec ) ; 
line 33868: # endif 
line 33870: assert ( ! pPager -> aSavepoint && ! pPager -> pInJournal ) ; 
line 33871: assert ( ! isOpen ( pPager -> jfd ) && ! isOpen ( pPager -> sjfd ) ) ; 
line 33873: sqlite3_free ( pPager ) ; 
line 33874: return SQLITE_OK ; 
line 33875: } 
line 33877: # if ! defined ( NDEBUG ) || defined ( SQLITE_TEST ) 
line 33881: SQLITE_PRIVATE Pgno sqlite3PagerPagenumber ( DbPage * pPg ) { 
line 33882: return pPg -> pgno ; 
line 33883: } 
line 33884: # endif 
line 33889: SQLITE_PRIVATE void sqlite3PagerRef ( DbPage * pPg ) { 
line 33890: sqlite3PcacheRef ( pPg ) ; 
line 33891: } 
line 33931: static int syncJournal ( Pager * pPager ) { 
line 33932: if ( pPager -> needSync ) { 
line 33933: assert ( ! pPager -> tempFile ) ; 
line 33934: if ( pPager -> journalMode != PAGER_JOURNALMODE_MEMORY ) { 
line 33935: int rc ; 
line 33936: const int iDc = sqlite3OsDeviceCharacteristics ( pPager -> fd ) ; 
line 33937: assert ( isOpen ( pPager -> jfd ) ) ; 
line 33939: if ( 0 == ( iDc & SQLITE_IOCAP_SAFE_APPEND ) ) { 
line 33962: i64 iNextHdrOffset ; 
line 33963: u8 aMagic [ 8 ] ; 
line 33964: u8 zHeader [ sizeof ( aJournalMagic ) + 4 ] ; 
line 33966: memcpy ( zHeader , aJournalMagic , sizeof ( aJournalMagic ) ) ; 
line 33967: put32bits ( & zHeader [ sizeof ( aJournalMagic ) ] , pPager -> nRec ) ; 
line 33969: iNextHdrOffset = journalHdrOffset ( pPager ) ; 
line 33970: rc = sqlite3OsRead ( pPager -> jfd , aMagic , 8 , iNextHdrOffset ) ; 
line 33971: if ( rc == SQLITE_OK && 0 == memcmp ( aMagic , aJournalMagic , 8 ) ) { 
line 33972: static const u8 zerobyte = 0 ; 
line 33973: rc = sqlite3OsWrite ( pPager -> jfd , & zerobyte , 1 , iNextHdrOffset ) ; 
line 33974: } 
line 33975: if ( rc != SQLITE_OK && rc != SQLITE_IOERR_SHORT_READ ) { 
line 33976: return rc ; 
line 33977: } 
line 33990: if ( pPager -> fullSync && 0 == ( iDc & SQLITE_IOCAP_SEQUENTIAL ) ) { 
line 33991: PAGERTRACE ( ( "SYNC journal of %d\n" , PAGERID ( pPager ) ) ) ; 
line 33992: IOTRACE ( ( "JSYNC %p\n" , pPager ) ) 
line 33993: rc = sqlite3OsSync ( pPager -> jfd , pPager -> sync_flags ) ; 
line 33994: if ( rc != SQLITE_OK ) return rc ; 
line 33995: } 
line 33996: IOTRACE ( ( "JHDR %p %lld\n" , pPager , pPager -> journalHdr ) ) ; 
line 33997: rc = sqlite3OsWrite ( 
line 33998: pPager -> jfd , zHeader , sizeof ( zHeader ) , pPager -> journalHdr 
line 33999: ) ; 
line 34000: if ( rc != SQLITE_OK ) return rc ; 
line 34001: } 
line 34002: if ( 0 == ( iDc & SQLITE_IOCAP_SEQUENTIAL ) ) { 
line 34003: PAGERTRACE ( ( "SYNC journal of %d\n" , PAGERID ( pPager ) ) ) ; 
line 34004: IOTRACE ( ( "JSYNC %p\n" , pPager ) ) 
line 34005: rc = sqlite3OsSync ( pPager -> jfd , pPager -> sync_flags | 
line 34006: ( pPager -> sync_flags == SQLITE_SYNC_FULL ? SQLITE_SYNC_DATAONLY : 0 ) 
line 34007: ) ; 
line 34008: if ( rc != SQLITE_OK ) return rc ; 
line 34009: } 
line 34010: } 
line 34015: pPager -> needSync = 0 ; 
line 34016: pPager -> journalStarted = 1 ; 
line 34017: sqlite3PcacheClearSyncFlags ( pPager -> pPCache ) ; 
line 34018: } 
line 34020: return SQLITE_OK ; 
line 34021: } 
line 34055: static int pager_write_pagelist ( PgHdr * pList ) { 
line 34056: Pager * pPager ; 
line 34057: int rc ; 
line 34059: if ( NEVER ( pList == 0 ) ) return SQLITE_OK ; 
line 34060: pPager = pList -> pPager ; 
line 34078: assert ( pPager -> state >= PAGER_RESERVED ) ; 
line 34079: rc = pager_wait_on_lock ( pPager , EXCLUSIVE_LOCK ) ; 
line 34085: if ( ! isOpen ( pPager -> fd ) ) { 
line 34086: assert ( pPager -> tempFile && rc == SQLITE_OK ) ; 
line 34087: rc = pagerOpentemp ( pPager , pPager -> fd , pPager -> vfsFlags ) ; 
line 34088: } 
line 34090: while ( rc == SQLITE_OK && pList ) { 
line 34091: Pgno pgno = pList -> pgno ; 
line 34103: if ( pgno <= pPager -> dbSize && 0 == ( pList -> flags & PGHDR_DONT_WRITE ) ) { 
line 34104: i64 offset = ( pgno - 1 ) * ( i64 ) pPager -> pageSize ; 
line 34105: char * pData ; 
line 34108: CODEC2 ( pPager , pList -> pData , pgno , 6 , return SQLITE_NOMEM , pData ) ; 
line 34111: rc = sqlite3OsWrite ( pPager -> fd , pData , pPager -> pageSize , offset ) ; 
line 34117: if ( pgno == 1 ) { 
line 34118: memcpy ( & pPager -> dbFileVers , & pData [ 24 ] , sizeof ( pPager -> dbFileVers ) ) ; 
line 34119: } 
line 34120: if ( pgno > pPager -> dbFileSize ) { 
line 34121: pPager -> dbFileSize = pgno ; 
line 34122: } 
line 34125: sqlite3BackupUpdate ( pPager -> pBackup , pgno , ( u8 * ) pList -> pData ) ; 
line 34127: PAGERTRACE ( ( "STORE %d page %d hash(%08x)\n" , 
line 34128: PAGERID ( pPager ) , pgno , pager_pagehash ( pList ) ) ) ; 
line 34129: IOTRACE ( ( "PGOUT %p %d\n" , pPager , pgno ) ) ; 
line 34130: PAGER_INCR ( sqlite3_pager_writedb_count ) ; 
line 34131: PAGER_INCR ( pPager -> nWrite ) ; 
line 34132: } else { 
line 34133: PAGERTRACE ( ( "NOSTORE %d page %d\n" , PAGERID ( pPager ) , pgno ) ) ; 
line 34134: } 
line 34135: # ifdef SQLITE_CHECK_PAGES 
line 34136: pList -> pageHash = pager_pagehash ( pList ) ; 
line 34137: # endif 
line 34138: pList = pList -> pDirty ; 
line 34139: } 
line 34141: return rc ; 
line 34142: } 
line 34157: static int subjournalPage ( PgHdr * pPg ) { 
line 34158: int rc = SQLITE_OK ; 
line 34159: Pager * pPager = pPg -> pPager ; 
line 34160: if ( isOpen ( pPager -> sjfd ) ) { 
line 34161: void * pData = pPg -> pData ; 
line 34162: i64 offset = pPager -> nSubRec * ( 4 + pPager -> pageSize ) ; 
line 34163: char * pData2 ; 
line 34165: CODEC2 ( pPager , pData , pPg -> pgno , 7 , return SQLITE_NOMEM , pData2 ) ; 
line 34166: PAGERTRACE ( ( "STMT-JOURNAL %d page %d\n" , PAGERID ( pPager ) , pPg -> pgno ) ) ; 
line 34168: assert ( pageInJournal ( pPg ) || pPg -> pgno > pPager -> dbOrigSize ) ; 
line 34169: rc = write32bits ( pPager -> sjfd , offset , pPg -> pgno ) ; 
line 34170: if ( rc == SQLITE_OK ) { 
line 34171: rc = sqlite3OsWrite ( pPager -> sjfd , pData2 , pPager -> pageSize , offset + 4 ) ; 
line 34172: } 
line 34173: } 
line 34174: if ( rc == SQLITE_OK ) { 
line 34175: pPager -> nSubRec ++ ; 
line 34176: assert ( pPager -> nSavepoint > 0 ) ; 
line 34177: rc = addToSavepointBitvecs ( pPager , pPg -> pgno ) ; 
line 34178: } 
line 34179: return rc ; 
line 34180: } 
line 34202: static int pagerStress ( void * p , PgHdr * pPg ) { 
line 34203: Pager * pPager = ( Pager * ) p ; 
line 34204: int rc = SQLITE_OK ; 
line 34206: assert ( pPg -> pPager == pPager ) ; 
line 34207: assert ( pPg -> flags & PGHDR_DIRTY ) ; 
line 34222: if ( NEVER ( pPager -> errCode ) 
line 34223: || ( pPager -> doNotSync && pPg -> flags & PGHDR_NEED_SYNC ) 
line 34224: ) { 
line 34225: return SQLITE_OK ; 
line 34226: } 
line 34229: if ( pPg -> flags & PGHDR_NEED_SYNC ) { 
line 34230: rc = syncJournal ( pPager ) ; 
line 34231: if ( rc == SQLITE_OK && pPager -> fullSync && 
line 34232: ! ( pPager -> journalMode == PAGER_JOURNALMODE_MEMORY ) && 
line 34233: ! ( sqlite3OsDeviceCharacteristics ( pPager -> fd ) & SQLITE_IOCAP_SAFE_APPEND ) 
line 34234: ) { 
line 34235: pPager -> nRec = 0 ; 
line 34236: rc = writeJournalHdr ( pPager ) ; 
line 34237: } 
line 34238: } 
line 34267: if ( NEVER ( 
line 34268: rc == SQLITE_OK && pPg -> pgno > pPager -> dbSize && subjRequiresPage ( pPg ) 
line 34269: ) ) { 
line 34270: rc = subjournalPage ( pPg ) ; 
line 34271: } 
line 34274: if ( rc == SQLITE_OK ) { 
line 34275: pPg -> pDirty = 0 ; 
line 34276: rc = pager_write_pagelist ( pPg ) ; 
line 34277: } 
line 34280: if ( rc == SQLITE_OK ) { 
line 34281: PAGERTRACE ( ( "STRESS %d page %d\n" , PAGERID ( pPager ) , pPg -> pgno ) ) ; 
line 34282: sqlite3PcacheMakeClean ( pPg ) ; 
line 34283: } 
line 34285: return pager_error ( pPager , rc ) ; 
line 34286: } 
line 34319: SQLITE_PRIVATE int sqlite3PagerOpen ( 
line 34320: sqlite3_vfs * pVfs , 
line 34321: Pager * * ppPager , 
line 34322: const char * zFilename , 
line 34323: int nExtra , 
line 34324: int flags , 
line 34325: int vfsFlags , 
line 34326: void ( * xReinit ) ( DbPage * ) 
line 34327: ) { 
line 34328: u8 * pPtr ; 
line 34329: Pager * pPager = 0 ; 
line 34330: int rc = SQLITE_OK ; 
line 34331: int tempFile = 0 ; 
line 34332: int memDb = 0 ; 
line 34333: int readOnly = 0 ; 
line 34334: int journalFileSize ; 
line 34335: char * zPathname = 0 ; 
line 34336: int nPathname = 0 ; 
line 34337: int useJournal = ( flags & PAGER_OMIT_JOURNAL ) == 0 ; 
line 34338: int noReadlock = ( flags & PAGER_NO_READLOCK ) != 0 ; 
line 34339: int pcacheSize = sqlite3PcacheSize ( ) ; 
line 34340: u16 szPageDflt = SQLITE_DEFAULT_PAGE_SIZE ; 
line 34350: if ( sqlite3JournalSize ( pVfs ) > sqlite3MemJournalSize ( ) ) { 
line 34351: journalFileSize = ROUND8 ( sqlite3JournalSize ( pVfs ) ) ; 
line 34352: } else { 
line 34353: journalFileSize = ROUND8 ( sqlite3MemJournalSize ( ) ) ; 
line 34354: } 
line 34357: * ppPager = 0 ; 
line 34363: if ( zFilename && zFilename [ 0 ] ) { 
line 34364: nPathname = pVfs -> mxPathname + 1 ; 
line 34365: zPathname = sqlite3Malloc ( nPathname * 2 ) ; 
line 34366: if ( zPathname == 0 ) { 
line 34367: return SQLITE_NOMEM ; 
line 34368: } 
line 34369: # ifndef SQLITE_OMIT_MEMORYDB 
line 34370: if ( strcmp ( zFilename , ":memory:" ) == 0 ) { 
line 34371: memDb = 1 ; 
line 34372: zPathname [ 0 ] = 0 ; 
line 34373: } else 
line 34374: # endif 
line 34375: { 
line 34376: zPathname [ 0 ] = 0 ; 
line 34377: rc = sqlite3OsFullPathname ( pVfs , zFilename , nPathname , zPathname ) ; 
line 34378: } 
line 34380: nPathname = sqlite3Strlen30 ( zPathname ) ; 
line 34381: if ( rc == SQLITE_OK && nPathname + 8 > pVfs -> mxPathname ) { 
line 34388: rc = SQLITE_CANTOPEN ; 
line 34389: } 
line 34390: if ( rc != SQLITE_OK ) { 
line 34391: sqlite3_free ( zPathname ) ; 
line 34392: return rc ; 
line 34393: } 
line 34394: } 
line 34408: pPtr = ( u8 * ) sqlite3MallocZero ( 
line 34409: ROUND8 ( sizeof ( * pPager ) ) + 
line 34410: ROUND8 ( pcacheSize ) + 
line 34411: ROUND8 ( pVfs -> szOsFile ) + 
line 34412: journalFileSize * 2 + 
line 34413: nPathname + 1 + 
line 34414: nPathname + 8 + 1 
line 34415: ) ; 
line 34416: assert ( EIGHT_BYTE_ALIGNMENT ( SQLITE_INT_TO_PTR ( journalFileSize ) ) ) ; 
line 34417: if ( ! pPtr ) { 
line 34418: sqlite3_free ( zPathname ) ; 
line 34419: return SQLITE_NOMEM ; 
line 34420: } 
line 34421: pPager = ( Pager * ) ( pPtr ) ; 
line 34422: pPager -> pPCache = ( PCache * ) ( pPtr += ROUND8 ( sizeof ( * pPager ) ) ) ; 
line 34423: pPager -> fd = ( sqlite3_file * ) ( pPtr += ROUND8 ( pcacheSize ) ) ; 
line 34424: pPager -> sjfd = ( sqlite3_file * ) ( pPtr += ROUND8 ( pVfs -> szOsFile ) ) ; 
line 34425: pPager -> jfd = ( sqlite3_file * ) ( pPtr += journalFileSize ) ; 
line 34426: pPager -> zFilename = ( char * ) ( pPtr += journalFileSize ) ; 
line 34427: assert ( EIGHT_BYTE_ALIGNMENT ( pPager -> jfd ) ) ; 
line 34430: if ( zPathname ) { 
line 34431: pPager -> zJournal = ( char * ) ( pPtr += nPathname + 1 ) ; 
line 34432: memcpy ( pPager -> zFilename , zPathname , nPathname ) ; 
line 34433: memcpy ( pPager -> zJournal , zPathname , nPathname ) ; 
line 34434: memcpy ( & pPager -> zJournal [ nPathname ] , "-journal" , 8 ) ; 
line 34435: if ( pPager -> zFilename [ 0 ] == 0 ) pPager -> zJournal [ 0 ] = 0 ; 
line 34436: sqlite3_free ( zPathname ) ; 
line 34437: } 
line 34438: pPager -> pVfs = pVfs ; 
line 34439: pPager -> vfsFlags = vfsFlags ; 
line 34443: if ( zFilename && zFilename [ 0 ] && ! memDb ) { 
line 34444: int fout = 0 ; 
line 34445: rc = sqlite3OsOpen ( pVfs , pPager -> zFilename , pPager -> fd , vfsFlags , & fout ) ; 
line 34446: readOnly = ( fout & SQLITE_OPEN_READONLY ) ; 
line 34456: if ( rc == SQLITE_OK && ! readOnly ) { 
line 34457: setSectorSize ( pPager ) ; 
line 34458: assert ( SQLITE_DEFAULT_PAGE_SIZE <= SQLITE_MAX_DEFAULT_PAGE_SIZE ) ; 
line 34459: if ( szPageDflt < pPager -> sectorSize ) { 
line 34460: if ( pPager -> sectorSize > SQLITE_MAX_DEFAULT_PAGE_SIZE ) { 
line 34461: szPageDflt = SQLITE_MAX_DEFAULT_PAGE_SIZE ; 
line 34462: } else { 
line 34463: szPageDflt = ( u16 ) pPager -> sectorSize ; 
line 34464: } 
line 34465: } 
line 34466: # ifdef SQLITE_ENABLE_ATOMIC_WRITE 
line 34467: { 
line 34468: int iDc = sqlite3OsDeviceCharacteristics ( pPager -> fd ) ; 
line 34469: int ii ; 
line 34470: assert ( SQLITE_IOCAP_ATOMIC512 == ( 512 >> 8 ) ) ; 
line 34471: assert ( SQLITE_IOCAP_ATOMIC64K == ( 65536 >> 8 ) ) ; 
line 34472: assert ( SQLITE_MAX_DEFAULT_PAGE_SIZE <= 65536 ) ; 
line 34473: for ( ii = szPageDflt ; ii <= SQLITE_MAX_DEFAULT_PAGE_SIZE ; ii = ii * 2 ) { 
line 34474: if ( iDc & ( SQLITE_IOCAP_ATOMIC | ( ii >> 8 ) ) ) { 
line 34475: szPageDflt = ii ; 
line 34476: } 
line 34477: } 
line 34478: } 
line 34479: # endif 
line 34480: } 
line 34481: } else { 
line 34490: tempFile = 1 ; 
line 34491: pPager -> state = PAGER_EXCLUSIVE ; 
line 34492: readOnly = ( vfsFlags & SQLITE_OPEN_READONLY ) ; 
line 34493: } 
line 34498: if ( rc == SQLITE_OK ) { 
line 34499: assert ( pPager -> memDb == 0 ) ; 
line 34500: rc = sqlite3PagerSetPagesize ( pPager , & szPageDflt , - 1 ) ; 
line 34501: testcase ( rc != SQLITE_OK ) ; 
line 34502: } 
line 34507: if ( rc != SQLITE_OK ) { 
line 34508: assert ( ! pPager -> pTmpSpace ) ; 
line 34509: sqlite3OsClose ( pPager -> fd ) ; 
line 34510: sqlite3_free ( pPager ) ; 
line 34511: return rc ; 
line 34512: } 
line 34515: assert ( nExtra < 1000 ) ; 
line 34516: nExtra = ROUND8 ( nExtra ) ; 
line 34517: sqlite3PcacheOpen ( szPageDflt , nExtra , ! memDb , 
line 34518: ! memDb ? pagerStress : 0 , ( void * ) pPager , pPager -> pPCache ) ; 
line 34520: PAGERTRACE ( ( "OPEN %d %s\n" , FILEHANDLEID ( pPager -> fd ) , pPager -> zFilename ) ) ; 
line 34521: IOTRACE ( ( "OPEN %p %s\n" , pPager , pPager -> zFilename ) ) 
line 34523: pPager -> useJournal = ( u8 ) useJournal ; 
line 34524: pPager -> noReadlock = ( noReadlock && readOnly ) ? 1 : 0 ; 
line 34528: pPager -> dbSizeValid = ( u8 ) memDb ; 
line 34532: pPager -> mxPgno = SQLITE_MAX_PAGE_COUNT ; 
line 34534: assert ( pPager -> state == ( tempFile ? PAGER_EXCLUSIVE : PAGER_UNLOCK ) ) ; 
line 34536: pPager -> tempFile = ( u8 ) tempFile ; 
line 34537: assert ( tempFile == PAGER_LOCKINGMODE_NORMAL 
line 34538: || tempFile == PAGER_LOCKINGMODE_EXCLUSIVE ) ; 
line 34539: assert ( PAGER_LOCKINGMODE_EXCLUSIVE == 1 ) ; 
line 34540: pPager -> exclusiveMode = ( u8 ) tempFile ; 
line 34541: pPager -> changeCountDone = pPager -> tempFile ; 
line 34542: pPager -> memDb = ( u8 ) memDb ; 
line 34543: pPager -> readOnly = ( u8 ) readOnly ; 
line 34545: assert ( useJournal || pPager -> tempFile ) ; 
line 34546: pPager -> noSync = pPager -> tempFile ; 
line 34547: pPager -> fullSync = pPager -> noSync ? 0 : 1 ; 
line 34548: pPager -> sync_flags = SQLITE_SYNC_NORMAL ; 
line 34552: pPager -> nExtra = ( u16 ) nExtra ; 
line 34553: pPager -> journalSizeLimit = SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT ; 
line 34554: assert ( isOpen ( pPager -> fd ) || tempFile ) ; 
line 34555: setSectorSize ( pPager ) ; 
line 34556: if ( ! useJournal ) { 
line 34557: pPager -> journalMode = PAGER_JOURNALMODE_OFF ; 
line 34558: } else if ( memDb ) { 
line 34559: pPager -> journalMode = PAGER_JOURNALMODE_MEMORY ; 
line 34560: } 
line 34563: pPager -> xReiniter = xReinit ; 
line 34565: * ppPager = pPager ; 
line 34566: return SQLITE_OK ; 
line 34567: } 
line 34602: static int hasHotJournal ( Pager * pPager , int * pExists ) { 
line 34603: sqlite3_vfs * const pVfs = pPager -> pVfs ; 
line 34604: int rc ; 
line 34605: int exists ; 
line 34607: assert ( pPager != 0 ) ; 
line 34608: assert ( pPager -> useJournal ) ; 
line 34609: assert ( isOpen ( pPager -> fd ) ) ; 
line 34610: assert ( ! isOpen ( pPager -> jfd ) ) ; 
line 34611: assert ( pPager -> state <= PAGER_SHARED ) ; 
line 34613: * pExists = 0 ; 
line 34614: rc = sqlite3OsAccess ( pVfs , pPager -> zJournal , SQLITE_ACCESS_EXISTS , & exists ) ; 
line 34615: if ( rc == SQLITE_OK && exists ) { 
line 34616: int locked ; 
line 34626: rc = sqlite3OsCheckReservedLock ( pPager -> fd , & locked ) ; 
line 34627: if ( rc == SQLITE_OK && ! locked ) { 
line 34628: int nPage ; 
line 34636: rc = sqlite3PagerPagecount ( pPager , & nPage ) ; 
line 34637: if ( rc == SQLITE_OK ) { 
line 34638: if ( nPage == 0 ) { 
line 34639: sqlite3BeginBenignMalloc ( ) ; 
line 34640: if ( sqlite3OsLock ( pPager -> fd , RESERVED_LOCK ) == SQLITE_OK ) { 
line 34641: sqlite3OsDelete ( pVfs , pPager -> zJournal , 0 ) ; 
line 34642: sqlite3OsUnlock ( pPager -> fd , SHARED_LOCK ) ; 
line 34643: } 
line 34644: sqlite3EndBenignMalloc ( ) ; 
line 34645: } else { 
line 34652: int f = SQLITE_OPEN_READONLY | SQLITE_OPEN_MAIN_JOURNAL ; 
line 34653: rc = sqlite3OsOpen ( pVfs , pPager -> zJournal , pPager -> jfd , f , & f ) ; 
line 34654: if ( rc == SQLITE_OK ) { 
line 34655: u8 first = 0 ; 
line 34656: rc = sqlite3OsRead ( pPager -> jfd , ( void * ) & first , 1 , 0 ) ; 
line 34657: if ( rc == SQLITE_IOERR_SHORT_READ ) { 
line 34658: rc = SQLITE_OK ; 
line 34659: } 
line 34660: sqlite3OsClose ( pPager -> jfd ) ; 
line 34661: * pExists = ( first != 0 ) ; 
line 34662: } else if ( rc == SQLITE_CANTOPEN ) { 
line 34672: * pExists = 1 ; 
line 34673: rc = SQLITE_OK ; 
line 34674: } 
line 34675: } 
line 34676: } 
line 34677: } 
line 34678: } 
line 34680: return rc ; 
line 34681: } 
line 34694: static int readDbPage ( PgHdr * pPg ) { 
line 34695: Pager * pPager = pPg -> pPager ; 
line 34696: Pgno pgno = pPg -> pgno ; 
line 34697: int rc ; 
line 34698: i64 iOffset ; 
line 34700: assert ( pPager -> state >= PAGER_SHARED && ! MEMDB ) ; 
line 34701: assert ( isOpen ( pPager -> fd ) ) ; 
line 34703: if ( NEVER ( ! isOpen ( pPager -> fd ) ) ) { 
line 34704: assert ( pPager -> tempFile ) ; 
line 34705: memset ( pPg -> pData , 0 , pPager -> pageSize ) ; 
line 34706: return SQLITE_OK ; 
line 34707: } 
line 34708: iOffset = ( pgno - 1 ) * ( i64 ) pPager -> pageSize ; 
line 34709: rc = sqlite3OsRead ( pPager -> fd , pPg -> pData , pPager -> pageSize , iOffset ) ; 
line 34710: if ( rc == SQLITE_IOERR_SHORT_READ ) { 
line 34711: rc = SQLITE_OK ; 
line 34712: } 
line 34713: if ( pgno == 1 ) { 
line 34714: u8 * dbFileVers = & ( ( u8 * ) pPg -> pData ) [ 24 ] ; 
line 34715: memcpy ( & pPager -> dbFileVers , dbFileVers , sizeof ( pPager -> dbFileVers ) ) ; 
line 34716: } 
line 34717: CODEC1 ( pPager , pPg -> pData , pgno , 3 , rc = SQLITE_NOMEM ) ; 
line 34719: PAGER_INCR ( sqlite3_pager_readdb_count ) ; 
line 34720: PAGER_INCR ( pPager -> nRead ) ; 
line 34721: IOTRACE ( ( "PGIN %p %d\n" , pPager , pgno ) ) ; 
line 34722: PAGERTRACE ( ( "FETCH %d page %d hash(%08x)\n" , 
line 34723: PAGERID ( pPager ) , pgno , pager_pagehash ( pPg ) ) ) ; 
line 34725: return rc ; 
line 34726: } 
line 34760: SQLITE_PRIVATE int sqlite3PagerSharedLock ( Pager * pPager ) { 
line 34761: int rc = SQLITE_OK ; 
line 34762: int isErrorReset = 0 ; 
line 34766: assert ( sqlite3PcacheRefCount ( pPager -> pPCache ) == 0 ) ; 
line 34767: if ( NEVER ( MEMDB && pPager -> errCode ) ) { return pPager -> errCode ; } 
line 34773: if ( pPager -> errCode ) { 
line 34774: if ( isOpen ( pPager -> jfd ) || pPager -> zJournal ) { 
line 34775: isErrorReset = 1 ; 
line 34776: } 
line 34777: pPager -> errCode = SQLITE_OK ; 
line 34778: pager_reset ( pPager ) ; 
line 34779: } 
line 34781: if ( pPager -> state == PAGER_UNLOCK || isErrorReset ) { 
line 34782: sqlite3_vfs * const pVfs = pPager -> pVfs ; 
line 34783: int isHotJournal = 0 ; 
line 34784: assert ( ! MEMDB ) ; 
line 34785: assert ( sqlite3PcacheRefCount ( pPager -> pPCache ) == 0 ) ; 
line 34786: if ( pPager -> noReadlock ) { 
line 34787: assert ( pPager -> readOnly ) ; 
line 34788: pPager -> state = PAGER_SHARED ; 
line 34789: } else { 
line 34790: rc = pager_wait_on_lock ( pPager , SHARED_LOCK ) ; 
line 34791: if ( rc != SQLITE_OK ) { 
line 34792: assert ( pPager -> state == PAGER_UNLOCK ) ; 
line 34793: return pager_error ( pPager , rc ) ; 
line 34794: } 
line 34795: } 
line 34796: assert ( pPager -> state >= SHARED_LOCK ) ; 
line 34801: if ( ! isErrorReset ) { 
line 34802: assert ( pPager -> state <= PAGER_SHARED ) ; 
line 34803: rc = hasHotJournal ( pPager , & isHotJournal ) ; 
line 34804: if ( rc != SQLITE_OK ) { 
line 34805: goto failed ; 
line 34806: } 
line 34807: } 
line 34808: if ( isErrorReset || isHotJournal ) { 
line 34821: if ( pPager -> state < EXCLUSIVE_LOCK ) { 
line 34822: rc = sqlite3OsLock ( pPager -> fd , EXCLUSIVE_LOCK ) ; 
line 34823: if ( rc != SQLITE_OK ) { 
line 34824: rc = pager_error ( pPager , rc ) ; 
line 34825: goto failed ; 
line 34826: } 
line 34827: pPager -> state = PAGER_EXCLUSIVE ; 
line 34828: } 
line 34836: if ( ! isOpen ( pPager -> jfd ) ) { 
line 34837: int res ; 
line 34838: rc = sqlite3OsAccess ( pVfs , pPager -> zJournal , SQLITE_ACCESS_EXISTS , & res ) ; 
line 34839: if ( rc == SQLITE_OK ) { 
line 34840: if ( res ) { 
line 34841: int fout = 0 ; 
line 34842: int f = SQLITE_OPEN_READWRITE | SQLITE_OPEN_MAIN_JOURNAL ; 
line 34843: assert ( ! pPager -> tempFile ) ; 
line 34844: rc = sqlite3OsOpen ( pVfs , pPager -> zJournal , pPager -> jfd , f , & fout ) ; 
line 34845: assert ( rc != SQLITE_OK || isOpen ( pPager -> jfd ) ) ; 
line 34846: if ( rc == SQLITE_OK && fout & SQLITE_OPEN_READONLY ) { 
line 34847: rc = SQLITE_CANTOPEN ; 
line 34848: sqlite3OsClose ( pPager -> jfd ) ; 
line 34849: } 
line 34850: } else { 
line 34856: rc = pager_end_transaction ( pPager , 0 ) ; 
line 34857: } 
line 34858: } 
line 34859: } 
line 34860: if ( rc != SQLITE_OK ) { 
line 34861: goto failed ; 
line 34862: } 
line 34865: pPager -> journalStarted = 0 ; 
line 34866: pPager -> journalOff = 0 ; 
line 34867: pPager -> setMaster = 0 ; 
line 34868: pPager -> journalHdr = 0 ; 
line 34875: if ( isOpen ( pPager -> jfd ) ) { 
line 34876: rc = pager_playback ( pPager , 1 ) ; 
line 34877: if ( rc != SQLITE_OK ) { 
line 34878: rc = pager_error ( pPager , rc ) ; 
line 34879: goto failed ; 
line 34880: } 
line 34881: } 
line 34882: assert ( ( pPager -> state == PAGER_SHARED ) 
line 34883: || ( pPager -> exclusiveMode && pPager -> state > PAGER_SHARED ) 
line 34884: ) ; 
line 34885: } 
line 34887: if ( pPager -> pBackup || sqlite3PcachePagecount ( pPager -> pPCache ) > 0 ) { 
line 34904: char dbFileVers [ sizeof ( pPager -> dbFileVers ) ] ; 
line 34905: sqlite3PagerPagecount ( pPager , 0 ) ; 
line 34907: if ( pPager -> errCode ) { 
line 34908: rc = pPager -> errCode ; 
line 34909: goto failed ; 
line 34910: } 
line 34912: assert ( pPager -> dbSizeValid ) ; 
line 34913: if ( pPager -> dbSize > 0 ) { 
line 34914: IOTRACE ( ( "CKVERS %p %d\n" , pPager , sizeof ( dbFileVers ) ) ) ; 
line 34915: rc = sqlite3OsRead ( pPager -> fd , & dbFileVers , sizeof ( dbFileVers ) , 24 ) ; 
line 34916: if ( rc != SQLITE_OK ) { 
line 34917: goto failed ; 
line 34918: } 
line 34919: } else { 
line 34920: memset ( dbFileVers , 0 , sizeof ( dbFileVers ) ) ; 
line 34921: } 
line 34923: if ( memcmp ( pPager -> dbFileVers , dbFileVers , sizeof ( dbFileVers ) ) != 0 ) { 
line 34924: pager_reset ( pPager ) ; 
line 34925: } 
line 34926: } 
line 34927: assert ( pPager -> exclusiveMode || pPager -> state == PAGER_SHARED ) ; 
line 34928: } 
line 34930: failed : 
line 34931: if ( rc != SQLITE_OK ) { 
line 34933: pager_unlock ( pPager ) ; 
line 34934: } 
line 34935: return rc ; 
line 34936: } 
line 34946: static void pagerUnlockIfUnused ( Pager * pPager ) { 
line 34947: if ( ( sqlite3PcacheRefCount ( pPager -> pPCache ) == 0 ) 
line 34948: && ( ! pPager -> exclusiveMode || pPager -> journalOff > 0 ) 
line 34949: ) { 
line 34950: pagerUnlockAndRollback ( pPager ) ; 
line 34951: } 
line 34952: } 
line 35004: SQLITE_PRIVATE int sqlite3PagerAcquire ( 
line 35005: Pager * pPager , 
line 35006: Pgno pgno , 
line 35007: DbPage * * ppPage , 
line 35008: int noContent 
line 35009: ) { 
line 35010: int rc ; 
line 35011: PgHdr * pPg ; 
line 35013: assert ( assert_pager_state ( pPager ) ) ; 
line 35014: assert ( pPager -> state > PAGER_UNLOCK ) ; 
line 35016: if ( pgno == 0 ) { 
line 35017: return SQLITE_CORRUPT_BKPT ; 
line 35018: } 
line 35022: if ( pPager -> errCode != SQLITE_OK && pPager -> errCode != SQLITE_FULL ) { 
line 35023: rc = pPager -> errCode ; 
line 35024: } else { 
line 35025: rc = sqlite3PcacheFetch ( pPager -> pPCache , pgno , 1 , ppPage ) ; 
line 35026: } 
line 35028: if ( rc != SQLITE_OK ) { 
line 35032: pPg = 0 ; 
line 35033: goto pager_acquire_err ; 
line 35034: } 
line 35035: assert ( ( * ppPage ) -> pgno == pgno ) ; 
line 35036: assert ( ( * ppPage ) -> pPager == pPager || ( * ppPage ) -> pPager == 0 ) ; 
line 35038: if ( ( * ppPage ) -> pPager ) { 
line 35041: assert ( pgno <= PAGER_MAX_PGNO && pgno != PAGER_MJ_PGNO ( pPager ) ) ; 
line 35042: PAGER_INCR ( pPager -> nHit ) ; 
line 35043: return SQLITE_OK ; 
line 35045: } else { 
line 35048: int nMax ; 
line 35050: PAGER_INCR ( pPager -> nMiss ) ; 
line 35051: pPg = * ppPage ; 
line 35052: pPg -> pPager = pPager ; 
line 35056: if ( pgno > PAGER_MAX_PGNO || pgno == PAGER_MJ_PGNO ( pPager ) ) { 
line 35057: rc = SQLITE_CORRUPT_BKPT ; 
line 35058: goto pager_acquire_err ; 
line 35059: } 
line 35061: rc = sqlite3PagerPagecount ( pPager , & nMax ) ; 
line 35062: if ( rc != SQLITE_OK ) { 
line 35063: goto pager_acquire_err ; 
line 35064: } 
line 35066: if ( MEMDB || nMax < ( int ) pgno || noContent ) { 
line 35067: if ( pgno > pPager -> mxPgno ) { 
line 35068: rc = SQLITE_FULL ; 
line 35069: goto pager_acquire_err ; 
line 35070: } 
line 35071: if ( noContent ) { 
line 35078: sqlite3BeginBenignMalloc ( ) ; 
line 35079: if ( pgno <= pPager -> dbOrigSize ) { 
line 35080: TESTONLY ( rc = ) sqlite3BitvecSet ( pPager -> pInJournal , pgno ) ; 
line 35081: testcase ( rc == SQLITE_NOMEM ) ; 
line 35082: } 
line 35083: TESTONLY ( rc = ) addToSavepointBitvecs ( pPager , pgno ) ; 
line 35084: testcase ( rc == SQLITE_NOMEM ) ; 
line 35085: sqlite3EndBenignMalloc ( ) ; 
line 35086: } 
line 35087: memset ( pPg -> pData , 0 , pPager -> pageSize ) ; 
line 35088: IOTRACE ( ( "ZERO %p %d\n" , pPager , pgno ) ) ; 
line 35089: } else { 
line 35090: assert ( pPg -> pPager == pPager ) ; 
line 35091: rc = readDbPage ( pPg ) ; 
line 35092: if ( rc != SQLITE_OK ) { 
line 35093: goto pager_acquire_err ; 
line 35094: } 
line 35095: } 
line 35096: # ifdef SQLITE_CHECK_PAGES 
line 35097: pPg -> pageHash = pager_pagehash ( pPg ) ; 
line 35098: # endif 
line 35099: } 
line 35101: return SQLITE_OK ; 
line 35103: pager_acquire_err : 
line 35104: assert ( rc != SQLITE_OK ) ; 
line 35105: if ( pPg ) { 
line 35106: sqlite3PcacheDrop ( pPg ) ; 
line 35107: } 
line 35108: pagerUnlockIfUnused ( pPager ) ; 
line 35110: * ppPage = 0 ; 
line 35111: return rc ; 
line 35112: } 
line 35127: SQLITE_PRIVATE DbPage * sqlite3PagerLookup ( Pager * pPager , Pgno pgno ) { 
line 35128: PgHdr * pPg = 0 ; 
line 35129: assert ( pPager != 0 ) ; 
line 35130: assert ( pgno != 0 ) ; 
line 35131: assert ( pPager -> pPCache != 0 ) ; 
line 35132: assert ( pPager -> state > PAGER_UNLOCK ) ; 
line 35133: sqlite3PcacheFetch ( pPager -> pPCache , pgno , 0 , & pPg ) ; 
line 35134: return pPg ; 
line 35135: } 
line 35145: SQLITE_PRIVATE void sqlite3PagerUnref ( DbPage * pPg ) { 
line 35146: if ( pPg ) { 
line 35147: Pager * pPager = pPg -> pPager ; 
line 35148: sqlite3PcacheRelease ( pPg ) ; 
line 35149: pagerUnlockIfUnused ( pPager ) ; 
line 35150: } 
line 35151: } 
line 35162: static int openSubJournal ( Pager * pPager ) { 
line 35163: int rc = SQLITE_OK ; 
line 35164: if ( isOpen ( pPager -> jfd ) && ! isOpen ( pPager -> sjfd ) ) { 
line 35165: if ( pPager -> journalMode == PAGER_JOURNALMODE_MEMORY || pPager -> subjInMemory ) { 
line 35166: sqlite3MemJournalOpen ( pPager -> sjfd ) ; 
line 35167: } else { 
line 35168: rc = pagerOpentemp ( pPager , pPager -> sjfd , SQLITE_OPEN_SUBJOURNAL ) ; 
line 35169: } 
line 35170: } 
line 35171: return rc ; 
line 35172: } 
line 35196: static int pager_open_journal ( Pager * pPager ) { 
line 35197: int rc = SQLITE_OK ; 
line 35198: sqlite3_vfs * const pVfs = pPager -> pVfs ; 
line 35200: assert ( pPager -> state >= PAGER_RESERVED ) ; 
line 35201: assert ( pPager -> useJournal ) ; 
line 35202: assert ( pPager -> journalMode != PAGER_JOURNALMODE_OFF ) ; 
line 35203: assert ( pPager -> pInJournal == 0 ) ; 
line 35208: if ( NEVER ( pPager -> errCode ) ) return pPager -> errCode ; 
line 35213: testcase ( pPager -> dbSizeValid == 0 ) ; 
line 35214: sqlite3PagerPagecount ( pPager , 0 ) ; 
line 35216: pPager -> pInJournal = sqlite3BitvecCreate ( pPager -> dbSize ) ; 
line 35217: if ( pPager -> pInJournal == 0 ) { 
line 35218: return SQLITE_NOMEM ; 
line 35219: } 
line 35222: if ( ! isOpen ( pPager -> jfd ) ) { 
line 35223: if ( pPager -> journalMode == PAGER_JOURNALMODE_MEMORY ) { 
line 35224: sqlite3MemJournalOpen ( pPager -> jfd ) ; 
line 35225: } else { 
line 35226: const int flags = 
line 35227: SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | 
line 35228: ( pPager -> tempFile ? 
line 35229: ( SQLITE_OPEN_DELETEONCLOSE | SQLITE_OPEN_TEMP_JOURNAL ) : 
line 35230: ( SQLITE_OPEN_MAIN_JOURNAL ) 
line 35231: ) ; 
line 35232: # ifdef SQLITE_ENABLE_ATOMIC_WRITE 
line 35233: rc = sqlite3JournalOpen ( 
line 35234: pVfs , pPager -> zJournal , pPager -> jfd , flags , jrnlBufferSize ( pPager ) 
line 35235: ) ; 
line 35236: # else 
line 35237: rc = sqlite3OsOpen ( pVfs , pPager -> zJournal , pPager -> jfd , flags , 0 ) ; 
line 35238: # endif 
line 35239: } 
line 35240: assert ( rc != SQLITE_OK || isOpen ( pPager -> jfd ) ) ; 
line 35241: } 
line 35247: if ( rc == SQLITE_OK ) { 
line 35249: pPager -> dbOrigSize = pPager -> dbSize ; 
line 35250: pPager -> journalStarted = 0 ; 
line 35251: pPager -> needSync = 0 ; 
line 35252: pPager -> nRec = 0 ; 
line 35253: pPager -> journalOff = 0 ; 
line 35254: pPager -> setMaster = 0 ; 
line 35255: pPager -> journalHdr = 0 ; 
line 35256: rc = writeJournalHdr ( pPager ) ; 
line 35257: } 
line 35258: if ( rc == SQLITE_OK && pPager -> nSavepoint ) { 
line 35259: rc = openSubJournal ( pPager ) ; 
line 35260: } 
line 35262: if ( rc != SQLITE_OK ) { 
line 35263: sqlite3BitvecDestroy ( pPager -> pInJournal ) ; 
line 35264: pPager -> pInJournal = 0 ; 
line 35265: } 
line 35266: return rc ; 
line 35267: } 
line 35294: SQLITE_PRIVATE int sqlite3PagerBegin ( Pager * pPager , int exFlag , int subjInMemory ) { 
line 35295: int rc = SQLITE_OK ; 
line 35296: assert ( pPager -> state != PAGER_UNLOCK ) ; 
line 35297: pPager -> subjInMemory = ( u8 ) subjInMemory ; 
line 35298: if ( pPager -> state == PAGER_SHARED ) { 
line 35299: assert ( pPager -> pInJournal == 0 ) ; 
line 35300: assert ( ! MEMDB && ! pPager -> tempFile ) ; 
line 35307: rc = sqlite3OsLock ( pPager -> fd , RESERVED_LOCK ) ; 
line 35308: if ( rc == SQLITE_OK ) { 
line 35309: pPager -> state = PAGER_RESERVED ; 
line 35310: if ( exFlag ) { 
line 35311: rc = pager_wait_on_lock ( pPager , EXCLUSIVE_LOCK ) ; 
line 35312: } 
line 35313: } 
line 35318: if ( rc == SQLITE_OK && pPager -> journalMode != PAGER_JOURNALMODE_OFF ) { 
line 35319: rc = pager_open_journal ( pPager ) ; 
line 35320: } 
line 35321: } else if ( isOpen ( pPager -> jfd ) && pPager -> journalOff == 0 ) { 
line 35328: assert ( pPager -> nRec == 0 ) ; 
line 35329: assert ( pPager -> dbOrigSize == 0 ) ; 
line 35330: assert ( pPager -> pInJournal == 0 ) ; 
line 35331: rc = pager_open_journal ( pPager ) ; 
line 35332: } 
line 35334: PAGERTRACE ( ( "TRANSACTION %d\n" , PAGERID ( pPager ) ) ) ; 
line 35335: assert ( ! isOpen ( pPager -> jfd ) || pPager -> journalOff > 0 || rc != SQLITE_OK ) ; 
line 35336: if ( rc != SQLITE_OK ) { 
line 35337: assert ( ! pPager -> dbModified ) ; 
line 35343: pager_end_transaction ( pPager , 0 ) ; 
line 35344: } 
line 35345: return rc ; 
line 35346: } 
line 35355: static int pager_write ( PgHdr * pPg ) { 
line 35356: void * pData = pPg -> pData ; 
line 35357: Pager * pPager = pPg -> pPager ; 
line 35358: int rc = SQLITE_OK ; 
line 35363: assert ( pPager -> state >= PAGER_RESERVED ) ; 
line 35368: if ( NEVER ( pPager -> errCode ) ) return pPager -> errCode ; 
line 35372: if ( NEVER ( pPager -> readOnly ) ) return SQLITE_PERM ; 
line 35374: assert ( ! pPager -> setMaster ) ; 
line 35376: CHECK_PAGE ( pPg ) ; 
line 35381: sqlite3PcacheMakeDirty ( pPg ) ; 
line 35382: if ( pageInJournal ( pPg ) && ! subjRequiresPage ( pPg ) ) { 
line 35383: pPager -> dbModified = 1 ; 
line 35384: } else { 
line 35394: rc = sqlite3PagerBegin ( pPager , 0 , pPager -> subjInMemory ) ; 
line 35395: if ( NEVER ( rc != SQLITE_OK ) ) { 
line 35396: return rc ; 
line 35397: } 
line 35398: if ( ! isOpen ( pPager -> jfd ) && pPager -> journalMode != PAGER_JOURNALMODE_OFF ) { 
line 35399: assert ( pPager -> useJournal ) ; 
line 35400: rc = pager_open_journal ( pPager ) ; 
line 35401: if ( rc != SQLITE_OK ) return rc ; 
line 35402: } 
line 35403: pPager -> dbModified = 1 ; 
line 35409: if ( ! pageInJournal ( pPg ) && isOpen ( pPager -> jfd ) ) { 
line 35410: if ( pPg -> pgno <= pPager -> dbOrigSize ) { 
line 35411: u32 cksum ; 
line 35412: char * pData2 ; 
line 35417: assert ( pPg -> pgno != PAGER_MJ_PGNO ( pPager ) ) ; 
line 35418: CODEC2 ( pPager , pData , pPg -> pgno , 7 , return SQLITE_NOMEM , pData2 ) ; 
line 35419: cksum = pager_cksum ( pPager , ( u8 * ) pData2 ) ; 
line 35420: rc = write32bits ( pPager -> jfd , pPager -> journalOff , pPg -> pgno ) ; 
line 35421: if ( rc == SQLITE_OK ) { 
line 35422: rc = sqlite3OsWrite ( pPager -> jfd , pData2 , pPager -> pageSize , 
line 35423: pPager -> journalOff + 4 ) ; 
line 35424: pPager -> journalOff += pPager -> pageSize + 4 ; 
line 35425: } 
line 35426: if ( rc == SQLITE_OK ) { 
line 35427: rc = write32bits ( pPager -> jfd , pPager -> journalOff , cksum ) ; 
line 35428: pPager -> journalOff += 4 ; 
line 35429: } 
line 35430: IOTRACE ( ( "JOUT %p %d %lld %d\n" , pPager , pPg -> pgno , 
line 35431: pPager -> journalOff , pPager -> pageSize ) ) ; 
line 35432: PAGER_INCR ( sqlite3_pager_writej_count ) ; 
line 35433: PAGERTRACE ( ( "JOURNAL %d page %d needSync=%d hash(%08x)\n" , 
line 35434: PAGERID ( pPager ) , pPg -> pgno , 
line 35435: ( ( pPg -> flags & PGHDR_NEED_SYNC ) ? 1 : 0 ) , pager_pagehash ( pPg ) ) ) ; 
line 35444: if ( ! pPager -> noSync ) { 
line 35445: pPg -> flags |= PGHDR_NEED_SYNC ; 
line 35446: pPager -> needSync = 1 ; 
line 35447: } 
line 35452: if ( rc != SQLITE_OK ) { 
line 35453: return rc ; 
line 35454: } 
line 35456: pPager -> nRec ++ ; 
line 35457: assert ( pPager -> pInJournal != 0 ) ; 
line 35458: rc = sqlite3BitvecSet ( pPager -> pInJournal , pPg -> pgno ) ; 
line 35459: testcase ( rc == SQLITE_NOMEM ) ; 
line 35460: assert ( rc == SQLITE_OK || rc == SQLITE_NOMEM ) ; 
line 35461: rc |= addToSavepointBitvecs ( pPager , pPg -> pgno ) ; 
line 35462: if ( rc != SQLITE_OK ) { 
line 35463: assert ( rc == SQLITE_NOMEM ) ; 
line 35464: return rc ; 
line 35465: } 
line 35466: } else { 
line 35467: if ( ! pPager -> journalStarted && ! pPager -> noSync ) { 
line 35468: pPg -> flags |= PGHDR_NEED_SYNC ; 
line 35469: pPager -> needSync = 1 ; 
line 35470: } 
line 35471: PAGERTRACE ( ( "APPEND %d page %d needSync=%d\n" , 
line 35472: PAGERID ( pPager ) , pPg -> pgno , 
line 35473: ( ( pPg -> flags & PGHDR_NEED_SYNC ) ? 1 : 0 ) ) ) ; 
line 35474: } 
line 35475: } 
line 35482: if ( subjRequiresPage ( pPg ) ) { 
line 35483: rc = subjournalPage ( pPg ) ; 
line 35484: } 
line 35485: } 
line 35489: assert ( pPager -> state >= PAGER_SHARED ) ; 
line 35490: if ( pPager -> dbSize < pPg -> pgno ) { 
line 35491: pPager -> dbSize = pPg -> pgno ; 
line 35492: } 
line 35493: return rc ; 
line 35494: } 
line 35510: SQLITE_PRIVATE int sqlite3PagerWrite ( DbPage * pDbPage ) { 
line 35511: int rc = SQLITE_OK ; 
line 35513: PgHdr * pPg = pDbPage ; 
line 35514: Pager * pPager = pPg -> pPager ; 
line 35515: Pgno nPagePerSector = ( pPager -> sectorSize / pPager -> pageSize ) ; 
line 35517: if ( nPagePerSector > 1 ) { 
line 35518: Pgno nPageCount ; 
line 35519: Pgno pg1 ; 
line 35520: int nPage ; 
line 35521: int ii ; 
line 35522: int needSync = 0 ; 
line 35527: assert ( ! MEMDB ) ; 
line 35528: assert ( pPager -> doNotSync == 0 ) ; 
line 35529: pPager -> doNotSync = 1 ; 
line 35535: pg1 = ( ( pPg -> pgno - 1 ) & ~ ( nPagePerSector - 1 ) ) + 1 ; 
line 35537: sqlite3PagerPagecount ( pPager , ( int * ) & nPageCount ) ; 
line 35538: if ( pPg -> pgno > nPageCount ) { 
line 35539: nPage = ( pPg -> pgno - pg1 ) + 1 ; 
line 35540: } else if ( ( pg1 + nPagePerSector - 1 ) > nPageCount ) { 
line 35541: nPage = nPageCount + 1 - pg1 ; 
line 35542: } else { 
line 35543: nPage = nPagePerSector ; 
line 35544: } 
line 35545: assert ( nPage > 0 ) ; 
line 35546: assert ( pg1 <= pPg -> pgno ) ; 
line 35547: assert ( ( pg1 + nPage ) > pPg -> pgno ) ; 
line 35549: for ( ii = 0 ; ii < nPage && rc == SQLITE_OK ; ii ++ ) { 
line 35550: Pgno pg = pg1 + ii ; 
line 35551: PgHdr * pPage ; 
line 35552: if ( pg == pPg -> pgno || ! sqlite3BitvecTest ( pPager -> pInJournal , pg ) ) { 
line 35553: if ( pg != PAGER_MJ_PGNO ( pPager ) ) { 
line 35554: rc = sqlite3PagerGet ( pPager , pg , & pPage ) ; 
line 35555: if ( rc == SQLITE_OK ) { 
line 35556: rc = pager_write ( pPage ) ; 
line 35557: if ( pPage -> flags & PGHDR_NEED_SYNC ) { 
line 35558: needSync = 1 ; 
line 35559: assert ( pPager -> needSync ) ; 
line 35560: } 
line 35561: sqlite3PagerUnref ( pPage ) ; 
line 35562: } 
line 35563: } 
line 35564: } else if ( ( pPage = pager_lookup ( pPager , pg ) ) != 0 ) { 
line 35565: if ( pPage -> flags & PGHDR_NEED_SYNC ) { 
line 35566: needSync = 1 ; 
line 35567: } 
line 35568: sqlite3PagerUnref ( pPage ) ; 
line 35569: } 
line 35570: } 
line 35578: if ( rc == SQLITE_OK && needSync ) { 
line 35579: assert ( ! MEMDB && pPager -> noSync == 0 ) ; 
line 35580: for ( ii = 0 ; ii < nPage ; ii ++ ) { 
line 35581: PgHdr * pPage = pager_lookup ( pPager , pg1 + ii ) ; 
line 35582: if ( pPage ) { 
line 35583: pPage -> flags |= PGHDR_NEED_SYNC ; 
line 35584: sqlite3PagerUnref ( pPage ) ; 
line 35585: } 
line 35586: } 
line 35587: assert ( pPager -> needSync ) ; 
line 35588: } 
line 35590: assert ( pPager -> doNotSync == 1 ) ; 
line 35591: pPager -> doNotSync = 0 ; 
line 35592: } else { 
line 35593: rc = pager_write ( pDbPage ) ; 
line 35594: } 
line 35595: return rc ; 
line 35596: } 
line 35603: # ifndef NDEBUG 
line 35604: SQLITE_PRIVATE int sqlite3PagerIswriteable ( DbPage * pPg ) { 
line 35605: return pPg -> flags & PGHDR_DIRTY ; 
line 35606: } 
line 35607: # endif 
line 35609: # ifndef SQLITE_SECURE_DELETE 
line 35624: SQLITE_PRIVATE void sqlite3PagerDontWrite ( PgHdr * pPg ) { 
line 35625: Pager * pPager = pPg -> pPager ; 
line 35626: if ( ( pPg -> flags & PGHDR_DIRTY ) && pPager -> nSavepoint == 0 ) { 
line 35627: PAGERTRACE ( ( "DONT_WRITE page %d of %d\n" , pPg -> pgno , PAGERID ( pPager ) ) ) ; 
line 35628: IOTRACE ( ( "CLEAN %p %d\n" , pPager , pPg -> pgno ) ) 
line 35629: pPg -> flags |= PGHDR_DONT_WRITE ; 
line 35630: # ifdef SQLITE_CHECK_PAGES 
line 35631: pPg -> pageHash = pager_pagehash ( pPg ) ; 
line 35632: # endif 
line 35633: } 
line 35634: } 
line 35635: # endif 
line 35653: static int pager_incr_changecounter ( Pager * pPager , int isDirectMode ) { 
line 35654: int rc = SQLITE_OK ; 
line 35666: # ifndef SQLITE_ENABLE_ATOMIC_WRITE 
line 35667: # define DIRECT_MODE 0 
line 35668: assert ( isDirectMode == 0 ) ; 
line 35669: UNUSED_PARAMETER ( isDirectMode ) ; 
line 35670: # else 
line 35671: # define DIRECT_MODE isDirectMode 
line 35672: # endif 
line 35674: assert ( pPager -> state >= PAGER_RESERVED ) ; 
line 35675: if ( ! pPager -> changeCountDone && pPager -> dbSize > 0 ) { 
line 35676: PgHdr * pPgHdr ; 
line 35677: u32 change_counter ; 
line 35679: assert ( ! pPager -> tempFile && isOpen ( pPager -> fd ) ) ; 
line 35682: rc = sqlite3PagerGet ( pPager , 1 , & pPgHdr ) ; 
line 35683: assert ( pPgHdr == 0 || rc == SQLITE_OK ) ; 
line 35690: if ( ! DIRECT_MODE && ALWAYS ( rc == SQLITE_OK ) ) { 
line 35691: rc = sqlite3PagerWrite ( pPgHdr ) ; 
line 35692: } 
line 35694: if ( rc == SQLITE_OK ) { 
line 35696: change_counter = sqlite3Get4byte ( ( u8 * ) pPager -> dbFileVers ) ; 
line 35697: change_counter ++ ; 
line 35698: put32bits ( ( ( char * ) pPgHdr -> pData ) + 24 , change_counter ) ; 
line 35701: if ( DIRECT_MODE ) { 
line 35702: const void * zBuf = pPgHdr -> pData ; 
line 35703: assert ( pPager -> dbFileSize > 0 ) ; 
line 35704: rc = sqlite3OsWrite ( pPager -> fd , zBuf , pPager -> pageSize , 0 ) ; 
line 35705: if ( rc == SQLITE_OK ) { 
line 35706: pPager -> changeCountDone = 1 ; 
line 35707: } 
line 35708: } else { 
line 35709: pPager -> changeCountDone = 1 ; 
line 35710: } 
line 35711: } 
line 35714: sqlite3PagerUnref ( pPgHdr ) ; 
line 35715: } 
line 35716: return rc ; 
line 35717: } 
line 35726: SQLITE_PRIVATE int sqlite3PagerSync ( Pager * pPager ) { 
line 35727: int rc ; 
line 35728: assert ( ! MEMDB ) ; 
line 35729: if ( pPager -> noSync ) { 
line 35730: rc = SQLITE_OK ; 
line 35731: } else { 
line 35732: rc = sqlite3OsSync ( pPager -> fd , pPager -> sync_flags ) ; 
line 35733: } 
line 35734: return rc ; 
line 35735: } 
line 35763: SQLITE_PRIVATE int sqlite3PagerCommitPhaseOne ( 
line 35764: Pager * pPager , 
line 35765: const char * zMaster , 
line 35766: int noSync 
line 35767: ) { 
line 35768: int rc = SQLITE_OK ; 
line 35771: assert ( pPager -> journalMode != PAGER_JOURNALMODE_OFF || pPager -> dbOrigSize == 0 ) ; 
line 35776: if ( NEVER ( pPager -> errCode ) ) return pPager -> errCode ; 
line 35778: PAGERTRACE ( ( "DATABASE SYNC: File=%s zMaster=%s nSize=%d\n" , 
line 35779: pPager -> zFilename , zMaster , pPager -> dbSize ) ) ; 
line 35781: if ( MEMDB && pPager -> dbModified ) { 
line 35786: sqlite3BackupRestart ( pPager -> pBackup ) ; 
line 35787: } else if ( pPager -> state != PAGER_SYNCED && pPager -> dbModified ) { 
line 35812: # ifdef SQLITE_ENABLE_ATOMIC_WRITE 
line 35813: PgHdr * pPg ; 
line 35814: assert ( isOpen ( pPager -> jfd ) || pPager -> journalMode == PAGER_JOURNALMODE_OFF ) ; 
line 35815: if ( ! zMaster && isOpen ( pPager -> jfd ) 
line 35816: && pPager -> journalOff == jrnlBufferSize ( pPager ) 
line 35817: && pPager -> dbSize >= pPager -> dbFileSize 
line 35818: && ( 0 == ( pPg = sqlite3PcacheDirtyList ( pPager -> pPCache ) ) || 0 == pPg -> pDirty ) 
line 35819: ) { 
line 35826: rc = pager_incr_changecounter ( pPager , 1 ) ; 
line 35827: } else { 
line 35828: rc = sqlite3JournalCreate ( pPager -> jfd ) ; 
line 35829: if ( rc == SQLITE_OK ) { 
line 35830: rc = pager_incr_changecounter ( pPager , 0 ) ; 
line 35831: } 
line 35832: } 
line 35833: # else 
line 35834: rc = pager_incr_changecounter ( pPager , 0 ) ; 
line 35835: # endif 
line 35836: if ( rc != SQLITE_OK ) goto commit_phase_one_exit ; 
line 35851: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 35852: if ( pPager -> dbSize < pPager -> dbOrigSize 
line 35853: && ALWAYS ( pPager -> journalMode != PAGER_JOURNALMODE_OFF ) 
line 35854: ) { 
line 35855: Pgno i ; 
line 35856: const Pgno iSkip = PAGER_MJ_PGNO ( pPager ) ; 
line 35857: const Pgno dbSize = pPager -> dbSize ; 
line 35858: pPager -> dbSize = pPager -> dbOrigSize ; 
line 35859: for ( i = dbSize + 1 ; i <= pPager -> dbOrigSize ; i ++ ) { 
line 35860: if ( ! sqlite3BitvecTest ( pPager -> pInJournal , i ) && i != iSkip ) { 
line 35861: PgHdr * pPage ; 
line 35862: rc = sqlite3PagerGet ( pPager , i , & pPage ) ; 
line 35863: if ( rc != SQLITE_OK ) goto commit_phase_one_exit ; 
line 35864: rc = sqlite3PagerWrite ( pPage ) ; 
line 35865: sqlite3PagerUnref ( pPage ) ; 
line 35866: if ( rc != SQLITE_OK ) goto commit_phase_one_exit ; 
line 35867: } 
line 35868: } 
line 35869: pPager -> dbSize = dbSize ; 
line 35870: } 
line 35871: # endif 
line 35877: rc = writeMasterJournal ( pPager , zMaster ) ; 
line 35878: if ( rc != SQLITE_OK ) goto commit_phase_one_exit ; 
line 35884: rc = syncJournal ( pPager ) ; 
line 35885: if ( rc != SQLITE_OK ) goto commit_phase_one_exit ; 
line 35888: rc = pager_write_pagelist ( sqlite3PcacheDirtyList ( pPager -> pPCache ) ) ; 
line 35889: if ( rc != SQLITE_OK ) { 
line 35890: assert ( rc != SQLITE_IOERR_BLOCKED ) ; 
line 35891: goto commit_phase_one_exit ; 
line 35892: } 
line 35893: sqlite3PcacheCleanAll ( pPager -> pPCache ) ; 
line 35898: if ( pPager -> dbSize != pPager -> dbFileSize ) { 
line 35899: Pgno nNew = pPager -> dbSize - ( pPager -> dbSize == PAGER_MJ_PGNO ( pPager ) ) ; 
line 35900: assert ( pPager -> state >= PAGER_EXCLUSIVE ) ; 
line 35901: rc = pager_truncate ( pPager , nNew ) ; 
line 35902: if ( rc != SQLITE_OK ) goto commit_phase_one_exit ; 
line 35903: } 
line 35906: if ( ! pPager -> noSync && ! noSync ) { 
line 35907: rc = sqlite3OsSync ( pPager -> fd , pPager -> sync_flags ) ; 
line 35908: } 
line 35909: IOTRACE ( ( "DBSYNC %p\n" , pPager ) ) 
line 35911: pPager -> state = PAGER_SYNCED ; 
line 35912: } 
line 35914: commit_phase_one_exit : 
line 35915: return rc ; 
line 35916: } 
line 35934: SQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo ( Pager * pPager ) { 
line 35935: int rc = SQLITE_OK ; 
line 35940: if ( NEVER ( pPager -> errCode ) ) return pPager -> errCode ; 
line 35946: if ( NEVER ( pPager -> state < PAGER_RESERVED ) ) return SQLITE_ERROR ; 
line 35959: if ( pPager -> dbModified == 0 && pPager -> exclusiveMode 
line 35960: && pPager -> journalMode == PAGER_JOURNALMODE_PERSIST 
line 35961: ) { 
line 35962: assert ( pPager -> journalOff == JOURNAL_HDR_SZ ( pPager ) ) ; 
line 35963: return SQLITE_OK ; 
line 35964: } 
line 35966: PAGERTRACE ( ( "COMMIT %d\n" , PAGERID ( pPager ) ) ) ; 
line 35967: assert ( pPager -> state == PAGER_SYNCED || MEMDB || ! pPager -> dbModified ) ; 
line 35968: rc = pager_end_transaction ( pPager , pPager -> setMaster ) ; 
line 35969: return pager_error ( pPager , rc ) ; 
line 35970: } 
line 36015: SQLITE_PRIVATE int sqlite3PagerRollback ( Pager * pPager ) { 
line 36016: int rc = SQLITE_OK ; 
line 36017: PAGERTRACE ( ( "ROLLBACK %d\n" , PAGERID ( pPager ) ) ) ; 
line 36018: if ( ! pPager -> dbModified || ! isOpen ( pPager -> jfd ) ) { 
line 36019: rc = pager_end_transaction ( pPager , pPager -> setMaster ) ; 
line 36020: } else if ( pPager -> errCode && pPager -> errCode != SQLITE_FULL ) { 
line 36021: if ( pPager -> state >= PAGER_EXCLUSIVE ) { 
line 36022: pager_playback ( pPager , 0 ) ; 
line 36023: } 
line 36024: rc = pPager -> errCode ; 
line 36025: } else { 
line 36026: if ( pPager -> state == PAGER_RESERVED ) { 
line 36027: int rc2 ; 
line 36028: rc = pager_playback ( pPager , 0 ) ; 
line 36029: rc2 = pager_end_transaction ( pPager , pPager -> setMaster ) ; 
line 36030: if ( rc == SQLITE_OK ) { 
line 36031: rc = rc2 ; 
line 36032: } 
line 36033: } else { 
line 36034: rc = pager_playback ( pPager , 0 ) ; 
line 36035: } 
line 36037: if ( ! MEMDB ) { 
line 36038: pPager -> dbSizeValid = 0 ; 
line 36039: } 
line 36045: rc = pager_error ( pPager , rc ) ; 
line 36046: } 
line 36047: return rc ; 
line 36048: } 
line 36054: SQLITE_PRIVATE u8 sqlite3PagerIsreadonly ( Pager * pPager ) { 
line 36055: return pPager -> readOnly ; 
line 36056: } 
line 36061: SQLITE_PRIVATE int sqlite3PagerRefcount ( Pager * pPager ) { 
line 36062: return sqlite3PcacheRefCount ( pPager -> pPCache ) ; 
line 36063: } 
line 36068: SQLITE_PRIVATE int sqlite3PagerPageRefcount ( DbPage * pPage ) { 
line 36069: return sqlite3PcachePageRefcount ( pPage ) ; 
line 36070: } 
line 36072: # ifdef SQLITE_TEST 
line 36076: SQLITE_PRIVATE int * sqlite3PagerStats ( Pager * pPager ) { 
line 36077: static int a [ 11 ] ; 
line 36078: a [ 0 ] = sqlite3PcacheRefCount ( pPager -> pPCache ) ; 
line 36079: a [ 1 ] = sqlite3PcachePagecount ( pPager -> pPCache ) ; 
line 36080: a [ 2 ] = sqlite3PcacheGetCachesize ( pPager -> pPCache ) ; 
line 36081: a [ 3 ] = pPager -> dbSizeValid ? ( int ) pPager -> dbSize : - 1 ; 
line 36082: a [ 4 ] = pPager -> state ; 
line 36083: a [ 5 ] = pPager -> errCode ; 
line 36084: a [ 6 ] = pPager -> nHit ; 
line 36085: a [ 7 ] = pPager -> nMiss ; 
line 36086: a [ 8 ] = 0 ; 
line 36087: a [ 9 ] = pPager -> nRead ; 
line 36088: a [ 10 ] = pPager -> nWrite ; 
line 36089: return a ; 
line 36090: } 
line 36091: # endif 
line 36096: SQLITE_PRIVATE int sqlite3PagerIsMemdb ( Pager * pPager ) { 
line 36097: return MEMDB ; 
line 36098: } 
line 36110: SQLITE_PRIVATE int sqlite3PagerOpenSavepoint ( Pager * pPager , int nSavepoint ) { 
line 36111: int rc = SQLITE_OK ; 
line 36112: int nCurrent = pPager -> nSavepoint ; 
line 36114: if ( nSavepoint > nCurrent && pPager -> useJournal ) { 
line 36115: int ii ; 
line 36116: PagerSavepoint * aNew ; 
line 36120: assert ( pPager -> nSavepoint == 0 || isOpen ( pPager -> sjfd ) || 
line 36121: pPager -> journalMode == PAGER_JOURNALMODE_MEMORY ) ; 
line 36127: aNew = ( PagerSavepoint * ) sqlite3Realloc ( 
line 36128: pPager -> aSavepoint , sizeof ( PagerSavepoint ) * nSavepoint 
line 36129: ) ; 
line 36130: if ( ! aNew ) { 
line 36131: return SQLITE_NOMEM ; 
line 36132: } 
line 36133: memset ( & aNew [ nCurrent ] , 0 , ( nSavepoint - nCurrent ) * sizeof ( PagerSavepoint ) ) ; 
line 36134: pPager -> aSavepoint = aNew ; 
line 36135: pPager -> nSavepoint = nSavepoint ; 
line 36138: for ( ii = nCurrent ; ii < nSavepoint ; ii ++ ) { 
line 36139: assert ( pPager -> dbSizeValid ) ; 
line 36140: aNew [ ii ] . nOrig = pPager -> dbSize ; 
line 36141: if ( isOpen ( pPager -> jfd ) && ALWAYS ( pPager -> journalOff > 0 ) ) { 
line 36142: aNew [ ii ] . iOffset = pPager -> journalOff ; 
line 36143: } else { 
line 36144: aNew [ ii ] . iOffset = JOURNAL_HDR_SZ ( pPager ) ; 
line 36145: } 
line 36146: aNew [ ii ] . iSubRec = pPager -> nSubRec ; 
line 36147: aNew [ ii ] . pInSavepoint = sqlite3BitvecCreate ( pPager -> dbSize ) ; 
line 36148: if ( ! aNew [ ii ] . pInSavepoint ) { 
line 36149: return SQLITE_NOMEM ; 
line 36150: } 
line 36151: } 
line 36154: rc = openSubJournal ( pPager ) ; 
line 36155: assertTruncateConstraint ( pPager ) ; 
line 36156: } 
line 36158: return rc ; 
line 36159: } 
line 36191: SQLITE_PRIVATE int sqlite3PagerSavepoint ( Pager * pPager , int op , int iSavepoint ) { 
line 36192: int rc = SQLITE_OK ; 
line 36194: assert ( op == SAVEPOINT_RELEASE || op == SAVEPOINT_ROLLBACK ) ; 
line 36195: assert ( iSavepoint >= 0 || op == SAVEPOINT_ROLLBACK ) ; 
line 36197: if ( iSavepoint < pPager -> nSavepoint ) { 
line 36198: int ii ; 
line 36199: int nNew ; 
line 36205: nNew = iSavepoint + ( op == SAVEPOINT_ROLLBACK ) ; 
line 36206: for ( ii = nNew ; ii < pPager -> nSavepoint ; ii ++ ) { 
line 36207: sqlite3BitvecDestroy ( pPager -> aSavepoint [ ii ] . pInSavepoint ) ; 
line 36208: } 
line 36209: pPager -> nSavepoint = nNew ; 
line 36216: if ( op == SAVEPOINT_ROLLBACK && isOpen ( pPager -> jfd ) ) { 
line 36217: PagerSavepoint * pSavepoint = ( nNew == 0 ) ? 0 : & pPager -> aSavepoint [ nNew - 1 ] ; 
line 36218: rc = pagerPlaybackSavepoint ( pPager , pSavepoint ) ; 
line 36219: assert ( rc != SQLITE_DONE ) ; 
line 36220: } 
line 36224: if ( nNew == 0 && op == SAVEPOINT_RELEASE && isOpen ( pPager -> sjfd ) ) { 
line 36225: assert ( rc == SQLITE_OK ) ; 
line 36226: rc = sqlite3OsTruncate ( pPager -> sjfd , 0 ) ; 
line 36227: pPager -> nSubRec = 0 ; 
line 36228: } 
line 36229: } 
line 36230: return rc ; 
line 36231: } 
line 36236: SQLITE_PRIVATE const char * sqlite3PagerFilename ( Pager * pPager ) { 
line 36237: return pPager -> zFilename ; 
line 36238: } 
line 36243: SQLITE_PRIVATE const sqlite3_vfs * sqlite3PagerVfs ( Pager * pPager ) { 
line 36244: return pPager -> pVfs ; 
line 36245: } 
line 36252: SQLITE_PRIVATE sqlite3_file * sqlite3PagerFile ( Pager * pPager ) { 
line 36253: return pPager -> fd ; 
line 36254: } 
line 36259: SQLITE_PRIVATE const char * sqlite3PagerJournalname ( Pager * pPager ) { 
line 36260: return pPager -> zJournal ; 
line 36261: } 
line 36267: SQLITE_PRIVATE int sqlite3PagerNosync ( Pager * pPager ) { 
line 36268: return pPager -> noSync ; 
line 36269: } 
line 36271: # ifdef SQLITE_HAS_CODEC 
line 36275: static void sqlite3PagerSetCodec ( 
line 36276: Pager * pPager , 
line 36277: void * ( * xCodec ) ( void * , void * , Pgno , int ) , 
line 36278: void ( * xCodecSizeChng ) ( void * , int , int ) , 
line 36279: void ( * xCodecFree ) ( void * ) , 
line 36280: void * pCodec 
line 36281: ) { 
line 36282: if ( pPager -> xCodecFree ) pPager -> xCodecFree ( pPager -> pCodec ) ; 
line 36283: pPager -> xCodec = pPager -> memDb ? 0 : xCodec ; 
line 36284: pPager -> xCodecSizeChng = xCodecSizeChng ; 
line 36285: pPager -> xCodecFree = xCodecFree ; 
line 36286: pPager -> pCodec = pCodec ; 
line 36287: pagerReportSize ( pPager ) ; 
line 36288: } 
line 36289: static void * sqlite3PagerGetCodec ( Pager * pPager ) { 
line 36290: return pPager -> pCodec ; 
line 36291: } 
line 36292: # endif 
line 36294: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 36320: SQLITE_PRIVATE int sqlite3PagerMovepage ( Pager * pPager , DbPage * pPg , Pgno pgno , int isCommit ) { 
line 36321: PgHdr * pPgOld ; 
line 36322: Pgno needSyncPgno = 0 ; 
line 36323: int rc ; 
line 36324: Pgno origPgno ; 
line 36326: assert ( pPg -> nRef > 0 ) ; 
line 36331: if ( MEMDB ) { 
line 36332: rc = sqlite3PagerWrite ( pPg ) ; 
line 36333: if ( rc ) return rc ; 
line 36334: } 
line 36354: if ( pPg -> flags & PGHDR_DIRTY 
line 36355: && subjRequiresPage ( pPg ) 
line 36356: && SQLITE_OK != ( rc = subjournalPage ( pPg ) ) 
line 36357: ) { 
line 36358: return rc ; 
line 36359: } 
line 36361: PAGERTRACE ( ( "MOVE %d page %d (needSync=%d) moves to %d\n" , 
line 36362: PAGERID ( pPager ) , pPg -> pgno , ( pPg -> flags & PGHDR_NEED_SYNC ) ? 1 : 0 , pgno ) ) ; 
line 36363: IOTRACE ( ( "MOVE %p %d %d\n" , pPager , pPg -> pgno , pgno ) ) 
line 36372: if ( ( pPg -> flags & PGHDR_NEED_SYNC ) && ! isCommit ) { 
line 36373: needSyncPgno = pPg -> pgno ; 
line 36374: assert ( pageInJournal ( pPg ) || pPg -> pgno > pPager -> dbOrigSize ) ; 
line 36375: assert ( pPg -> flags & PGHDR_DIRTY ) ; 
line 36376: assert ( pPager -> needSync ) ; 
line 36377: } 
line 36384: pPg -> flags &= ~ PGHDR_NEED_SYNC ; 
line 36385: pPgOld = pager_lookup ( pPager , pgno ) ; 
line 36386: assert ( ! pPgOld || pPgOld -> nRef == 1 ) ; 
line 36387: if ( pPgOld ) { 
line 36388: pPg -> flags |= ( pPgOld -> flags & PGHDR_NEED_SYNC ) ; 
line 36389: if ( MEMDB ) { 
line 36392: assert ( pPager -> dbSizeValid ) ; 
line 36393: sqlite3PcacheMove ( pPgOld , pPager -> dbSize + 1 ) ; 
line 36394: } else { 
line 36395: sqlite3PcacheDrop ( pPgOld ) ; 
line 36396: } 
line 36397: } 
line 36399: origPgno = pPg -> pgno ; 
line 36400: sqlite3PcacheMove ( pPg , pgno ) ; 
line 36401: sqlite3PcacheMakeDirty ( pPg ) ; 
line 36402: pPager -> dbModified = 1 ; 
line 36404: if ( needSyncPgno ) { 
line 36422: PgHdr * pPgHdr ; 
line 36423: assert ( pPager -> needSync ) ; 
line 36424: rc = sqlite3PagerGet ( pPager , needSyncPgno , & pPgHdr ) ; 
line 36425: if ( rc != SQLITE_OK ) { 
line 36426: if ( needSyncPgno <= pPager -> dbOrigSize ) { 
line 36427: assert ( pPager -> pTmpSpace != 0 ) ; 
line 36428: sqlite3BitvecClear ( pPager -> pInJournal , needSyncPgno , pPager -> pTmpSpace ) ; 
line 36429: } 
line 36430: return rc ; 
line 36431: } 
line 36432: pPager -> needSync = 1 ; 
line 36433: assert ( pPager -> noSync == 0 && ! MEMDB ) ; 
line 36434: pPgHdr -> flags |= PGHDR_NEED_SYNC ; 
line 36435: sqlite3PcacheMakeDirty ( pPgHdr ) ; 
line 36436: sqlite3PagerUnref ( pPgHdr ) ; 
line 36437: } 
line 36444: if ( MEMDB ) { 
line 36445: sqlite3PcacheMove ( pPgOld , origPgno ) ; 
line 36446: sqlite3PagerUnref ( pPgOld ) ; 
line 36447: } 
line 36449: return SQLITE_OK ; 
line 36450: } 
line 36451: # endif 
line 36456: SQLITE_PRIVATE void * sqlite3PagerGetData ( DbPage * pPg ) { 
line 36457: assert ( pPg -> nRef > 0 || pPg -> pPager -> memDb ) ; 
line 36458: return pPg -> pData ; 
line 36459: } 
line 36465: SQLITE_PRIVATE void * sqlite3PagerGetExtra ( DbPage * pPg ) { 
line 36466: return pPg -> pExtra ; 
line 36467: } 
line 36479: SQLITE_PRIVATE int sqlite3PagerLockingMode ( Pager * pPager , int eMode ) { 
line 36480: assert ( eMode == PAGER_LOCKINGMODE_QUERY 
line 36481: || eMode == PAGER_LOCKINGMODE_NORMAL 
line 36482: || eMode == PAGER_LOCKINGMODE_EXCLUSIVE ) ; 
line 36483: assert ( PAGER_LOCKINGMODE_QUERY < 0 ) ; 
line 36484: assert ( PAGER_LOCKINGMODE_NORMAL >= 0 && PAGER_LOCKINGMODE_EXCLUSIVE >= 0 ) ; 
line 36485: if ( eMode >= 0 && ! pPager -> tempFile ) { 
line 36486: pPager -> exclusiveMode = ( u8 ) eMode ; 
line 36487: } 
line 36488: return ( int ) pPager -> exclusiveMode ; 
line 36489: } 
line 36512: SQLITE_PRIVATE int sqlite3PagerJournalMode ( Pager * pPager , int eMode ) { 
line 36513: assert ( eMode == PAGER_JOURNALMODE_QUERY 
line 36514: || eMode == PAGER_JOURNALMODE_DELETE 
line 36515: || eMode == PAGER_JOURNALMODE_TRUNCATE 
line 36516: || eMode == PAGER_JOURNALMODE_PERSIST 
line 36517: || eMode == PAGER_JOURNALMODE_OFF 
line 36518: || eMode == PAGER_JOURNALMODE_MEMORY ) ; 
line 36519: assert ( PAGER_JOURNALMODE_QUERY < 0 ) ; 
line 36520: if ( eMode >= 0 
line 36521: && ( ! MEMDB || eMode == PAGER_JOURNALMODE_MEMORY 
line 36522: || eMode == PAGER_JOURNALMODE_OFF ) 
line 36523: && ! pPager -> dbModified 
line 36524: && ( ! isOpen ( pPager -> jfd ) || 0 == pPager -> journalOff ) 
line 36525: ) { 
line 36526: if ( isOpen ( pPager -> jfd ) ) { 
line 36527: sqlite3OsClose ( pPager -> jfd ) ; 
line 36528: } 
line 36529: pPager -> journalMode = ( u8 ) eMode ; 
line 36530: } 
line 36531: return ( int ) pPager -> journalMode ; 
line 36532: } 
line 36540: SQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit ( Pager * pPager , i64 iLimit ) { 
line 36541: if ( iLimit >= - 1 ) { 
line 36542: pPager -> journalSizeLimit = iLimit ; 
line 36543: } 
line 36544: return pPager -> journalSizeLimit ; 
line 36545: } 
line 36553: SQLITE_PRIVATE sqlite3_backup * * sqlite3PagerBackupPtr ( Pager * pPager ) { 
line 36554: return & pPager -> pBackup ; 
line 36555: } 
line 36557: # endif 
line 36799: # define MX_CELL_SIZE ( pBt ) ( pBt -> pageSize - 8 ) 
line 36806: # define MX_CELL ( pBt ) ( ( pBt -> pageSize - 8 ) / 6 ) 
line 36809: typedef struct MemPage MemPage ; 
line 36810: typedef struct BtLock BtLock ; 
line 36824: # ifndef SQLITE_FILE_HEADER 
line 36825: # define SQLITE_FILE_HEADER "SQLite format 3" 
line 36826: # endif 
line 36832: # define PTF_INTKEY 0x01 
line 36833: # define PTF_ZERODATA 0x02 
line 36834: # define PTF_LEAFDATA 0x04 
line 36835: # define PTF_LEAF 0x08 
line 36850: struct MemPage { 
line 36851: u8 isInit ; 
line 36852: u8 nOverflow ; 
line 36853: u8 intKey ; 
line 36854: u8 leaf ; 
line 36855: u8 hasData ; 
line 36856: u8 hdrOffset ; 
line 36857: u8 childPtrSize ; 
line 36858: u16 maxLocal ; 
line 36859: u16 minLocal ; 
line 36860: u16 cellOffset ; 
line 36861: u16 nFree ; 
line 36862: u16 nCell ; 
line 36863: u16 maskPage ; 
line 36864: struct _OvflCell { 
line 36865: u8 * pCell ; 
line 36866: u16 idx ; 
line 36867: } aOvfl [ 5 ] ; 
line 36868: BtShared * pBt ; 
line 36869: u8 * aData ; 
line 36870: DbPage * pDbPage ; 
line 36871: Pgno pgno ; 
line 36872: } ; 
line 36879: # define EXTRA_SIZE sizeof ( MemPage ) 
line 36888: struct BtLock { 
line 36889: Btree * pBtree ; 
line 36890: Pgno iTable ; 
line 36891: u8 eLock ; 
line 36892: BtLock * pNext ; 
line 36893: } ; 
line 36896: # define READ_LOCK 1 
line 36897: # define WRITE_LOCK 2 
line 36920: struct Btree { 
line 36921: sqlite3 * db ; 
line 36922: BtShared * pBt ; 
line 36923: u8 inTrans ; 
line 36924: u8 sharable ; 
line 36925: u8 locked ; 
line 36926: int wantToLock ; 
line 36927: int nBackup ; 
line 36928: Btree * pNext ; 
line 36929: Btree * pPrev ; 
line 36930: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 36931: BtLock lock ; 
line 36932: # endif 
line 36933: } ; 
line 36942: # define TRANS_NONE 0 
line 36943: # define TRANS_READ 1 
line 36944: # define TRANS_WRITE 2 
line 36981: struct BtShared { 
line 36982: Pager * pPager ; 
line 36983: sqlite3 * db ; 
line 36984: BtCursor * pCursor ; 
line 36985: MemPage * pPage1 ; 
line 36986: u8 readOnly ; 
line 36987: u8 pageSizeFixed ; 
line 36988: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 36989: u8 autoVacuum ; 
line 36990: u8 incrVacuum ; 
line 36991: # endif 
line 36992: u16 pageSize ; 
line 36993: u16 usableSize ; 
line 36994: u16 maxLocal ; 
line 36995: u16 minLocal ; 
line 36996: u16 maxLeaf ; 
line 36997: u16 minLeaf ; 
line 36998: u8 inTransaction ; 
line 36999: int nTransaction ; 
line 37000: void * pSchema ; 
line 37001: void ( * xFreeSchema ) ( void * ) ; 
line 37002: sqlite3_mutex * mutex ; 
line 37003: Bitvec * pHasContent ; 
line 37004: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 37005: int nRef ; 
line 37006: BtShared * pNext ; 
line 37007: BtLock * pLock ; 
line 37008: Btree * pWriter ; 
line 37009: u8 isExclusive ; 
line 37010: u8 isPending ; 
line 37011: # endif 
line 37012: u8 * pTmpSpace ; 
line 37013: } ; 
line 37020: typedef struct CellInfo CellInfo ; 
line 37021: struct CellInfo { 
line 37022: u8 * pCell ; 
line 37023: i64 nKey ; 
line 37024: u32 nData ; 
line 37025: u32 nPayload ; 
line 37026: u16 nHeader ; 
line 37027: u16 nLocal ; 
line 37028: u16 iOverflow ; 
line 37029: u16 nSize ; 
line 37030: } ; 
line 37041: # define BTCURSOR_MAX_DEPTH 20 
line 37057: struct BtCursor { 
line 37058: Btree * pBtree ; 
line 37059: BtShared * pBt ; 
line 37060: BtCursor * pNext , * pPrev ; 
line 37061: struct KeyInfo * pKeyInfo ; 
line 37062: Pgno pgnoRoot ; 
line 37063: sqlite3_int64 cachedRowid ; 
line 37064: CellInfo info ; 
line 37065: u8 wrFlag ; 
line 37066: u8 atLast ; 
line 37067: u8 validNKey ; 
line 37068: u8 eState ; 
line 37069: void * pKey ; 
line 37070: i64 nKey ; 
line 37071: int skipNext ; 
line 37072: # ifndef SQLITE_OMIT_INCRBLOB 
line 37073: u8 isIncrblobHandle ; 
line 37074: Pgno * aOverflow ; 
line 37075: # endif 
line 37076: i16 iPage ; 
line 37077: MemPage * apPage [ BTCURSOR_MAX_DEPTH ] ; 
line 37078: u16 aiIdx [ BTCURSOR_MAX_DEPTH ] ; 
line 37079: } ; 
line 37106: # define CURSOR_INVALID 0 
line 37107: # define CURSOR_VALID 1 
line 37108: # define CURSOR_REQUIRESEEK 2 
line 37109: # define CURSOR_FAULT 3 
line 37114: # define PENDING_BYTE_PAGE ( pBt ) PAGER_MJ_PGNO ( pBt ) 
line 37131: # define PTRMAP_PAGENO ( pBt , pgno ) ptrmapPageno ( pBt , pgno ) 
line 37132: # define PTRMAP_PTROFFSET ( pgptrmap , pgno ) ( 5 * ( pgno - pgptrmap - 1 ) ) 
line 37133: # define PTRMAP_ISPAGE ( pBt , pgno ) ( PTRMAP_PAGENO ( ( pBt ) , ( pgno ) ) == ( pgno ) ) 
line 37166: # define PTRMAP_ROOTPAGE 1 
line 37167: # define PTRMAP_FREEPAGE 2 
line 37168: # define PTRMAP_OVERFLOW1 3 
line 37169: # define PTRMAP_OVERFLOW2 4 
line 37170: # define PTRMAP_BTREE 5 
line 37175: # define btreeIntegrity ( p ) 
line 37176: assert ( p -> pBt -> inTransaction != TRANS_NONE || p -> pBt -> nTransaction == 0 ) ; 
line 37177: assert ( p -> pBt -> inTransaction >= p -> inTrans ) ; 
line 37187: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 37188: # define ISAUTOVACUUM ( pBt -> autoVacuum ) 
line 37189: # else 
line 37190: # define ISAUTOVACUUM 0 
line 37191: # endif 
line 37198: typedef struct IntegrityCk IntegrityCk ; 
line 37199: struct IntegrityCk { 
line 37200: BtShared * pBt ; 
line 37201: Pager * pPager ; 
line 37202: Pgno nPage ; 
line 37203: int * anRef ; 
line 37204: int mxErr ; 
line 37205: int nErr ; 
line 37206: int mallocFailed ; 
line 37207: StrAccum errMsg ; 
line 37208: } ; 
line 37213: # define get2byte ( x ) ( ( x ) [ 0 ] << 8 | ( x ) [ 1 ] ) 
line 37214: # define put2byte ( p , v ) ( ( p ) [ 0 ] = ( u8 ) ( ( v ) >> 8 ) , ( p ) [ 1 ] = ( u8 ) ( v ) ) 
line 37215: # define get4byte sqlite3Get4byte 
line 37216: # define put4byte sqlite3Put4byte 
line 37220: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 37221: # if SQLITE_THREADSAFE 
line 37228: static void lockBtreeMutex ( Btree * p ) { 
line 37229: assert ( p -> locked == 0 ) ; 
line 37230: assert ( sqlite3_mutex_notheld ( p -> pBt -> mutex ) ) ; 
line 37231: assert ( sqlite3_mutex_held ( p -> db -> mutex ) ) ; 
line 37233: sqlite3_mutex_enter ( p -> pBt -> mutex ) ; 
line 37234: p -> pBt -> db = p -> db ; 
line 37235: p -> locked = 1 ; 
line 37236: } 
line 37242: static void unlockBtreeMutex ( Btree * p ) { 
line 37243: assert ( p -> locked == 1 ) ; 
line 37244: assert ( sqlite3_mutex_held ( p -> pBt -> mutex ) ) ; 
line 37245: assert ( sqlite3_mutex_held ( p -> db -> mutex ) ) ; 
line 37246: assert ( p -> db == p -> pBt -> db ) ; 
line 37248: sqlite3_mutex_leave ( p -> pBt -> mutex ) ; 
line 37249: p -> locked = 0 ; 
line 37250: } 
line 37268: SQLITE_PRIVATE void sqlite3BtreeEnter ( Btree * p ) { 
line 37269: Btree * pLater ; 
line 37275: assert ( p -> pNext == 0 || p -> pNext -> pBt > p -> pBt ) ; 
line 37276: assert ( p -> pPrev == 0 || p -> pPrev -> pBt < p -> pBt ) ; 
line 37277: assert ( p -> pNext == 0 || p -> pNext -> db == p -> db ) ; 
line 37278: assert ( p -> pPrev == 0 || p -> pPrev -> db == p -> db ) ; 
line 37279: assert ( p -> sharable || ( p -> pNext == 0 && p -> pPrev == 0 ) ) ; 
line 37282: assert ( ! p -> locked || p -> wantToLock > 0 ) ; 
line 37283: assert ( p -> sharable || p -> wantToLock == 0 ) ; 
line 37286: assert ( sqlite3_mutex_held ( p -> db -> mutex ) ) ; 
line 37290: assert ( ( p -> locked == 0 && p -> sharable ) || p -> pBt -> db == p -> db ) ; 
line 37292: if ( ! p -> sharable ) return ; 
line 37293: p -> wantToLock ++ ; 
line 37294: if ( p -> locked ) return ; 
line 37300: if ( sqlite3_mutex_try ( p -> pBt -> mutex ) == SQLITE_OK ) { 
line 37301: p -> pBt -> db = p -> db ; 
line 37302: p -> locked = 1 ; 
line 37303: return ; 
line 37304: } 
line 37311: for ( pLater = p -> pNext ; pLater ; pLater = pLater -> pNext ) { 
line 37312: assert ( pLater -> sharable ) ; 
line 37313: assert ( pLater -> pNext == 0 || pLater -> pNext -> pBt > pLater -> pBt ) ; 
line 37314: assert ( ! pLater -> locked || pLater -> wantToLock > 0 ) ; 
line 37315: if ( pLater -> locked ) { 
line 37316: unlockBtreeMutex ( pLater ) ; 
line 37317: } 
line 37318: } 
line 37319: lockBtreeMutex ( p ) ; 
line 37320: for ( pLater = p -> pNext ; pLater ; pLater = pLater -> pNext ) { 
line 37321: if ( pLater -> wantToLock ) { 
line 37322: lockBtreeMutex ( pLater ) ; 
line 37323: } 
line 37324: } 
line 37325: } 
line 37330: SQLITE_PRIVATE void sqlite3BtreeLeave ( Btree * p ) { 
line 37331: if ( p -> sharable ) { 
line 37332: assert ( p -> wantToLock > 0 ) ; 
line 37333: p -> wantToLock -- ; 
line 37334: if ( p -> wantToLock == 0 ) { 
line 37335: unlockBtreeMutex ( p ) ; 
line 37336: } 
line 37337: } 
line 37338: } 
line 37340: # ifndef NDEBUG 
line 37347: SQLITE_PRIVATE int sqlite3BtreeHoldsMutex ( Btree * p ) { 
line 37348: assert ( p -> sharable == 0 || p -> locked == 0 || p -> wantToLock > 0 ) ; 
line 37349: assert ( p -> sharable == 0 || p -> locked == 0 || p -> db == p -> pBt -> db ) ; 
line 37350: assert ( p -> sharable == 0 || p -> locked == 0 || sqlite3_mutex_held ( p -> pBt -> mutex ) ) ; 
line 37351: assert ( p -> sharable == 0 || p -> locked == 0 || sqlite3_mutex_held ( p -> db -> mutex ) ) ; 
line 37353: return ( p -> sharable == 0 || p -> locked ) ; 
line 37354: } 
line 37355: # endif 
line 37358: # ifndef SQLITE_OMIT_INCRBLOB 
line 37364: SQLITE_PRIVATE void sqlite3BtreeEnterCursor ( BtCursor * pCur ) { 
line 37365: sqlite3BtreeEnter ( pCur -> pBtree ) ; 
line 37366: } 
line 37367: SQLITE_PRIVATE void sqlite3BtreeLeaveCursor ( BtCursor * pCur ) { 
line 37368: sqlite3BtreeLeave ( pCur -> pBtree ) ; 
line 37369: } 
line 37370: # endif 
line 37387: SQLITE_PRIVATE void sqlite3BtreeEnterAll ( sqlite3 * db ) { 
line 37388: int i ; 
line 37389: Btree * p , * pLater ; 
line 37390: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 37391: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 37392: p = db -> aDb [ i ] . pBt ; 
line 37393: assert ( ! p || ( p -> locked == 0 && p -> sharable ) || p -> pBt -> db == p -> db ) ; 
line 37394: if ( p && p -> sharable ) { 
line 37395: p -> wantToLock ++ ; 
line 37396: if ( ! p -> locked ) { 
line 37397: assert ( p -> wantToLock == 1 ) ; 
line 37398: while ( p -> pPrev ) p = p -> pPrev ; 
line 37401: while ( p -> locked && ALWAYS ( p -> pNext ) ) p = p -> pNext ; 
line 37402: for ( pLater = p -> pNext ; pLater ; pLater = pLater -> pNext ) { 
line 37403: if ( pLater -> locked ) { 
line 37404: unlockBtreeMutex ( pLater ) ; 
line 37405: } 
line 37406: } 
line 37407: while ( p ) { 
line 37408: lockBtreeMutex ( p ) ; 
line 37409: p = p -> pNext ; 
line 37410: } 
line 37411: } 
line 37412: } 
line 37413: } 
line 37414: } 
line 37415: SQLITE_PRIVATE void sqlite3BtreeLeaveAll ( sqlite3 * db ) { 
line 37416: int i ; 
line 37417: Btree * p ; 
line 37418: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 37419: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 37420: p = db -> aDb [ i ] . pBt ; 
line 37421: if ( p && p -> sharable ) { 
line 37422: assert ( p -> wantToLock > 0 ) ; 
line 37423: p -> wantToLock -- ; 
line 37424: if ( p -> wantToLock == 0 ) { 
line 37425: unlockBtreeMutex ( p ) ; 
line 37426: } 
line 37427: } 
line 37428: } 
line 37429: } 
line 37431: # ifndef NDEBUG 
line 37438: SQLITE_PRIVATE int sqlite3BtreeHoldsAllMutexes ( sqlite3 * db ) { 
line 37439: int i ; 
line 37440: if ( ! sqlite3_mutex_held ( db -> mutex ) ) { 
line 37441: return 0 ; 
line 37442: } 
line 37443: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 37444: Btree * p ; 
line 37445: p = db -> aDb [ i ] . pBt ; 
line 37446: if ( p && p -> sharable && 
line 37447: ( p -> wantToLock == 0 || ! sqlite3_mutex_held ( p -> pBt -> mutex ) ) ) { 
line 37448: return 0 ; 
line 37449: } 
line 37450: } 
line 37451: return 1 ; 
line 37452: } 
line 37453: # endif 
line 37468: SQLITE_PRIVATE void sqlite3BtreeMutexArrayInsert ( BtreeMutexArray * pArray , Btree * pBtree ) { 
line 37469: int i , j ; 
line 37470: BtShared * pBt ; 
line 37471: if ( pBtree == 0 || pBtree -> sharable == 0 ) return ; 
line 37472: # ifndef NDEBUG 
line 37473: { 
line 37474: for ( i = 0 ; i < pArray -> nMutex ; i ++ ) { 
line 37475: assert ( pArray -> aBtree [ i ] != pBtree ) ; 
line 37476: } 
line 37477: } 
line 37478: # endif 
line 37479: assert ( pArray -> nMutex >= 0 ) ; 
line 37480: assert ( pArray -> nMutex < ArraySize ( pArray -> aBtree ) - 1 ) ; 
line 37481: pBt = pBtree -> pBt ; 
line 37482: for ( i = 0 ; i < pArray -> nMutex ; i ++ ) { 
line 37483: assert ( pArray -> aBtree [ i ] != pBtree ) ; 
line 37484: if ( pArray -> aBtree [ i ] -> pBt > pBt ) { 
line 37485: for ( j = pArray -> nMutex ; j > i ; j -- ) { 
line 37486: pArray -> aBtree [ j ] = pArray -> aBtree [ j - 1 ] ; 
line 37487: } 
line 37488: pArray -> aBtree [ i ] = pBtree ; 
line 37489: pArray -> nMutex ++ ; 
line 37490: return ; 
line 37491: } 
line 37492: } 
line 37493: pArray -> aBtree [ pArray -> nMutex ++ ] = pBtree ; 
line 37494: } 
line 37501: SQLITE_PRIVATE void sqlite3BtreeMutexArrayEnter ( BtreeMutexArray * pArray ) { 
line 37502: int i ; 
line 37503: for ( i = 0 ; i < pArray -> nMutex ; i ++ ) { 
line 37504: Btree * p = pArray -> aBtree [ i ] ; 
line 37506: assert ( i == 0 || pArray -> aBtree [ i - 1 ] -> pBt < p -> pBt ) ; 
line 37507: assert ( ! p -> locked || p -> wantToLock > 0 ) ; 
line 37510: assert ( sqlite3_mutex_held ( p -> db -> mutex ) ) ; 
line 37514: assert ( p -> sharable ) ; 
line 37516: p -> wantToLock ++ ; 
line 37517: if ( ! p -> locked ) { 
line 37518: lockBtreeMutex ( p ) ; 
line 37519: } 
line 37520: } 
line 37521: } 
line 37526: SQLITE_PRIVATE void sqlite3BtreeMutexArrayLeave ( BtreeMutexArray * pArray ) { 
line 37527: int i ; 
line 37528: for ( i = 0 ; i < pArray -> nMutex ; i ++ ) { 
line 37529: Btree * p = pArray -> aBtree [ i ] ; 
line 37531: assert ( i == 0 || pArray -> aBtree [ i - 1 ] -> pBt < p -> pBt ) ; 
line 37532: assert ( p -> locked ) ; 
line 37533: assert ( p -> wantToLock > 0 ) ; 
line 37536: assert ( sqlite3_mutex_held ( p -> db -> mutex ) ) ; 
line 37538: p -> wantToLock -- ; 
line 37539: if ( p -> wantToLock == 0 ) { 
line 37540: unlockBtreeMutex ( p ) ; 
line 37541: } 
line 37542: } 
line 37543: } 
line 37545: # else 
line 37546: SQLITE_PRIVATE void sqlite3BtreeEnter ( Btree * p ) { 
line 37547: p -> pBt -> db = p -> db ; 
line 37548: } 
line 37549: SQLITE_PRIVATE void sqlite3BtreeEnterAll ( sqlite3 * db ) { 
line 37550: int i ; 
line 37551: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 37552: Btree * p = db -> aDb [ i ] . pBt ; 
line 37553: if ( p ) { 
line 37554: p -> pBt -> db = p -> db ; 
line 37555: } 
line 37556: } 
line 37557: } 
line 37558: # endif 
line 37559: # endif 
line 37583: static const char zMagicHeader [ ] = SQLITE_FILE_HEADER ; 
line 37589: # if 0 
line 37590: int sqlite3BtreeTrace = 1 ; 
line 37591: # define TRACE ( X ) if ( sqlite3BtreeTrace ) { printf X ; fflush ( stdout ) ; } 
line 37592: # else 
line 37593: # define TRACE ( X ) 
line 37594: # endif 
line 37598: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 37607: # ifdef SQLITE_TEST 
line 37608: SQLITE_PRIVATE BtShared * SQLITE_WSD sqlite3SharedCacheList = 0 ; 
line 37609: # else 
line 37610: static BtShared * SQLITE_WSD sqlite3SharedCacheList = 0 ; 
line 37611: # endif 
line 37612: # endif 
line 37614: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 37622: SQLITE_API int sqlite3_enable_shared_cache ( int enable ) { 
line 37623: sqlite3GlobalConfig . sharedCacheEnabled = enable ; 
line 37624: return SQLITE_OK ; 
line 37625: } 
line 37626: # endif 
line 37630: # ifdef SQLITE_OMIT_SHARED_CACHE 
line 37640: # define querySharedCacheTableLock ( a , b , c ) SQLITE_OK 
line 37641: # define setSharedCacheTableLock ( a , b , c ) SQLITE_OK 
line 37642: # define clearAllSharedCacheTableLocks ( a ) 
line 37643: # define downgradeAllSharedCacheTableLocks ( a ) 
line 37644: # define hasSharedCacheTableLock ( a , b , c , d ) 1 
line 37645: # define hasReadConflicts ( a , b ) 0 
line 37646: # endif 
line 37648: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 37650: # ifdef SQLITE_DEBUG 
line 37673: static int hasSharedCacheTableLock ( 
line 37674: Btree * pBtree , 
line 37675: Pgno iRoot , 
line 37676: int isIndex , 
line 37677: int eLockType 
line 37678: ) { 
line 37679: Schema * pSchema = ( Schema * ) pBtree -> pBt -> pSchema ; 
line 37680: Pgno iTab = 0 ; 
line 37681: BtLock * pLock ; 
line 37687: if ( ( pBtree -> sharable == 0 ) 
line 37688: || ( eLockType == READ_LOCK && ( pBtree -> db -> flags & SQLITE_ReadUncommitted ) ) 
line 37689: ) { 
line 37690: return 1 ; 
line 37691: } 
line 37698: if ( isIndex && ( ! pSchema || ( pSchema -> flags & DB_SchemaLoaded ) == 0 ) ) { 
line 37699: return 1 ; 
line 37700: } 
line 37706: if ( isIndex ) { 
line 37707: HashElem * p ; 
line 37708: for ( p = sqliteHashFirst ( & pSchema -> idxHash ) ; p ; p = sqliteHashNext ( p ) ) { 
line 37709: Index * pIdx = ( Index * ) sqliteHashData ( p ) ; 
line 37710: if ( pIdx -> tnum == ( int ) iRoot ) { 
line 37711: iTab = pIdx -> pTable -> tnum ; 
line 37712: } 
line 37713: } 
line 37714: } else { 
line 37715: iTab = iRoot ; 
line 37716: } 
line 37721: for ( pLock = pBtree -> pBt -> pLock ; pLock ; pLock = pLock -> pNext ) { 
line 37722: if ( pLock -> pBtree == pBtree 
line 37723: && ( pLock -> iTable == iTab || ( pLock -> eLock == WRITE_LOCK && pLock -> iTable == 1 ) ) 
line 37724: && pLock -> eLock >= eLockType 
line 37725: ) { 
line 37726: return 1 ; 
line 37727: } 
line 37728: } 
line 37731: return 0 ; 
line 37732: } 
line 37733: # endif 
line 37735: # ifdef SQLITE_DEBUG 
line 37754: static int hasReadConflicts ( Btree * pBtree , Pgno iRoot ) { 
line 37755: BtCursor * p ; 
line 37756: for ( p = pBtree -> pBt -> pCursor ; p ; p = p -> pNext ) { 
line 37757: if ( p -> pgnoRoot == iRoot 
line 37758: && p -> pBtree != pBtree 
line 37759: && 0 == ( p -> pBtree -> db -> flags & SQLITE_ReadUncommitted ) 
line 37760: ) { 
line 37761: return 1 ; 
line 37762: } 
line 37763: } 
line 37764: return 0 ; 
line 37765: } 
line 37766: # endif 
line 37774: static int querySharedCacheTableLock ( Btree * p , Pgno iTab , u8 eLock ) { 
line 37775: BtShared * pBt = p -> pBt ; 
line 37776: BtLock * pIter ; 
line 37778: assert ( sqlite3BtreeHoldsMutex ( p ) ) ; 
line 37779: assert ( eLock == READ_LOCK || eLock == WRITE_LOCK ) ; 
line 37780: assert ( p -> db != 0 ) ; 
line 37781: assert ( ! ( p -> db -> flags & SQLITE_ReadUncommitted ) || eLock == WRITE_LOCK || iTab == 1 ) ; 
line 37787: assert ( eLock == READ_LOCK || ( p == pBt -> pWriter && p -> inTrans == TRANS_WRITE ) ) ; 
line 37788: assert ( eLock == READ_LOCK || pBt -> inTransaction == TRANS_WRITE ) ; 
line 37791: if ( ! p -> sharable ) { 
line 37792: return SQLITE_OK ; 
line 37793: } 
line 37798: if ( pBt -> pWriter != p && pBt -> isExclusive ) { 
line 37799: sqlite3ConnectionBlocked ( p -> db , pBt -> pWriter -> db ) ; 
line 37800: return SQLITE_LOCKED_SHAREDCACHE ; 
line 37801: } 
line 37803: for ( pIter = pBt -> pLock ; pIter ; pIter = pIter -> pNext ) { 
line 37813: assert ( pIter -> eLock == READ_LOCK || pIter -> eLock == WRITE_LOCK ) ; 
line 37814: assert ( eLock == READ_LOCK || pIter -> pBtree == p || pIter -> eLock == READ_LOCK ) ; 
line 37815: if ( pIter -> pBtree != p && pIter -> iTable == iTab && pIter -> eLock != eLock ) { 
line 37816: sqlite3ConnectionBlocked ( p -> db , pIter -> pBtree -> db ) ; 
line 37817: if ( eLock == WRITE_LOCK ) { 
line 37818: assert ( p == pBt -> pWriter ) ; 
line 37819: pBt -> isPending = 1 ; 
line 37820: } 
line 37821: return SQLITE_LOCKED_SHAREDCACHE ; 
line 37822: } 
line 37823: } 
line 37824: return SQLITE_OK ; 
line 37825: } 
line 37826: # endif 
line 37828: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 37846: static int setSharedCacheTableLock ( Btree * p , Pgno iTable , u8 eLock ) { 
line 37847: BtShared * pBt = p -> pBt ; 
line 37848: BtLock * pLock = 0 ; 
line 37849: BtLock * pIter ; 
line 37851: assert ( sqlite3BtreeHoldsMutex ( p ) ) ; 
line 37852: assert ( eLock == READ_LOCK || eLock == WRITE_LOCK ) ; 
line 37853: assert ( p -> db != 0 ) ; 
line 37859: assert ( 0 == ( p -> db -> flags & SQLITE_ReadUncommitted ) || eLock == WRITE_LOCK ) ; 
line 37863: assert ( p -> sharable ) ; 
line 37864: assert ( SQLITE_OK == querySharedCacheTableLock ( p , iTable , eLock ) ) ; 
line 37867: for ( pIter = pBt -> pLock ; pIter ; pIter = pIter -> pNext ) { 
line 37868: if ( pIter -> iTable == iTable && pIter -> pBtree == p ) { 
line 37869: pLock = pIter ; 
line 37870: break ; 
line 37871: } 
line 37872: } 
line 37877: if ( ! pLock ) { 
line 37878: pLock = ( BtLock * ) sqlite3MallocZero ( sizeof ( BtLock ) ) ; 
line 37879: if ( ! pLock ) { 
line 37880: return SQLITE_NOMEM ; 
line 37881: } 
line 37882: pLock -> iTable = iTable ; 
line 37883: pLock -> pBtree = p ; 
line 37884: pLock -> pNext = pBt -> pLock ; 
line 37885: pBt -> pLock = pLock ; 
line 37886: } 
line 37892: assert ( WRITE_LOCK > READ_LOCK ) ; 
line 37893: if ( eLock > pLock -> eLock ) { 
line 37894: pLock -> eLock = eLock ; 
line 37895: } 
line 37897: return SQLITE_OK ; 
line 37898: } 
line 37899: # endif 
line 37901: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 37910: static void clearAllSharedCacheTableLocks ( Btree * p ) { 
line 37911: BtShared * pBt = p -> pBt ; 
line 37912: BtLock * * ppIter = & pBt -> pLock ; 
line 37914: assert ( sqlite3BtreeHoldsMutex ( p ) ) ; 
line 37915: assert ( p -> sharable || 0 == * ppIter ) ; 
line 37916: assert ( p -> inTrans > 0 ) ; 
line 37918: while ( * ppIter ) { 
line 37919: BtLock * pLock = * ppIter ; 
line 37920: assert ( pBt -> isExclusive == 0 || pBt -> pWriter == pLock -> pBtree ) ; 
line 37921: assert ( pLock -> pBtree -> inTrans >= pLock -> eLock ) ; 
line 37922: if ( pLock -> pBtree == p ) { 
line 37923: * ppIter = pLock -> pNext ; 
line 37924: assert ( pLock -> iTable != 1 || pLock == & p -> lock ) ; 
line 37925: if ( pLock -> iTable != 1 ) { 
line 37926: sqlite3_free ( pLock ) ; 
line 37927: } 
line 37928: } else { 
line 37929: ppIter = & pLock -> pNext ; 
line 37930: } 
line 37931: } 
line 37933: assert ( pBt -> isPending == 0 || pBt -> pWriter ) ; 
line 37934: if ( pBt -> pWriter == p ) { 
line 37935: pBt -> pWriter = 0 ; 
line 37936: pBt -> isExclusive = 0 ; 
line 37937: pBt -> isPending = 0 ; 
line 37938: } else if ( pBt -> nTransaction == 2 ) { 
line 37948: pBt -> isPending = 0 ; 
line 37949: } 
line 37950: } 
line 37955: static void downgradeAllSharedCacheTableLocks ( Btree * p ) { 
line 37956: BtShared * pBt = p -> pBt ; 
line 37957: if ( pBt -> pWriter == p ) { 
line 37958: BtLock * pLock ; 
line 37959: pBt -> pWriter = 0 ; 
line 37960: pBt -> isExclusive = 0 ; 
line 37961: pBt -> isPending = 0 ; 
line 37962: for ( pLock = pBt -> pLock ; pLock ; pLock = pLock -> pNext ) { 
line 37963: assert ( pLock -> eLock == READ_LOCK || pLock -> pBtree == p ) ; 
line 37964: pLock -> eLock = READ_LOCK ; 
line 37965: } 
line 37966: } 
line 37967: } 
line 37969: # endif 
line 37971: static void releasePage ( MemPage * pPage ) ; 
line 37978: # ifdef SQLITE_DEBUG 
line 37979: static int cursorHoldsMutex ( BtCursor * p ) { 
line 37980: return sqlite3_mutex_held ( p -> pBt -> mutex ) ; 
line 37981: } 
line 37982: # endif 
line 37985: # ifndef SQLITE_OMIT_INCRBLOB 
line 37989: static void invalidateOverflowCache ( BtCursor * pCur ) { 
line 37990: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 37991: sqlite3_free ( pCur -> aOverflow ) ; 
line 37992: pCur -> aOverflow = 0 ; 
line 37993: } 
line 37999: static void invalidateAllOverflowCache ( BtShared * pBt ) { 
line 38000: BtCursor * p ; 
line 38001: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 38002: for ( p = pBt -> pCursor ; p ; p = p -> pNext ) { 
line 38003: invalidateOverflowCache ( p ) ; 
line 38004: } 
line 38005: } 
line 38020: static void invalidateIncrblobCursors ( 
line 38021: Btree * pBtree , 
line 38022: i64 iRow , 
line 38023: int isClearTable 
line 38024: ) { 
line 38025: BtCursor * p ; 
line 38026: BtShared * pBt = pBtree -> pBt ; 
line 38027: assert ( sqlite3BtreeHoldsMutex ( pBtree ) ) ; 
line 38028: for ( p = pBt -> pCursor ; p ; p = p -> pNext ) { 
line 38029: if ( p -> isIncrblobHandle && ( isClearTable || p -> info . nKey == iRow ) ) { 
line 38030: p -> eState = CURSOR_INVALID ; 
line 38031: } 
line 38032: } 
line 38033: } 
line 38035: # else 
line 38037: # define invalidateOverflowCache ( x ) 
line 38038: # define invalidateAllOverflowCache ( x ) 
line 38039: # define invalidateIncrblobCursors ( x , y , z ) 
line 38040: # endif 
line 38077: static int btreeSetHasContent ( BtShared * pBt , Pgno pgno ) { 
line 38078: int rc = SQLITE_OK ; 
line 38079: if ( ! pBt -> pHasContent ) { 
line 38080: int nPage = 100 ; 
line 38081: sqlite3PagerPagecount ( pBt -> pPager , & nPage ) ; 
line 38084: pBt -> pHasContent = sqlite3BitvecCreate ( ( u32 ) nPage ) ; 
line 38085: if ( ! pBt -> pHasContent ) { 
line 38086: rc = SQLITE_NOMEM ; 
line 38087: } 
line 38088: } 
line 38089: if ( rc == SQLITE_OK && pgno <= sqlite3BitvecSize ( pBt -> pHasContent ) ) { 
line 38090: rc = sqlite3BitvecSet ( pBt -> pHasContent , pgno ) ; 
line 38091: } 
line 38092: return rc ; 
line 38093: } 
line 38102: static int btreeGetHasContent ( BtShared * pBt , Pgno pgno ) { 
line 38103: Bitvec * p = pBt -> pHasContent ; 
line 38104: return ( p && ( pgno > sqlite3BitvecSize ( p ) || sqlite3BitvecTest ( p , pgno ) ) ) ; 
line 38105: } 
line 38111: static void btreeClearHasContent ( BtShared * pBt ) { 
line 38112: sqlite3BitvecDestroy ( pBt -> pHasContent ) ; 
line 38113: pBt -> pHasContent = 0 ; 
line 38114: } 
line 38123: static int saveCursorPosition ( BtCursor * pCur ) { 
line 38124: int rc ; 
line 38126: assert ( CURSOR_VALID == pCur -> eState ) ; 
line 38127: assert ( 0 == pCur -> pKey ) ; 
line 38128: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 38130: rc = sqlite3BtreeKeySize ( pCur , & pCur -> nKey ) ; 
line 38131: assert ( rc == SQLITE_OK ) ; 
line 38139: if ( 0 == pCur -> apPage [ 0 ] -> intKey ) { 
line 38140: void * pKey = sqlite3Malloc ( ( int ) pCur -> nKey ) ; 
line 38141: if ( pKey ) { 
line 38142: rc = sqlite3BtreeKey ( pCur , 0 , ( int ) pCur -> nKey , pKey ) ; 
line 38143: if ( rc == SQLITE_OK ) { 
line 38144: pCur -> pKey = pKey ; 
line 38145: } else { 
line 38146: sqlite3_free ( pKey ) ; 
line 38147: } 
line 38148: } else { 
line 38149: rc = SQLITE_NOMEM ; 
line 38150: } 
line 38151: } 
line 38152: assert ( ! pCur -> apPage [ 0 ] -> intKey || ! pCur -> pKey ) ; 
line 38154: if ( rc == SQLITE_OK ) { 
line 38155: int i ; 
line 38156: for ( i = 0 ; i <= pCur -> iPage ; i ++ ) { 
line 38157: releasePage ( pCur -> apPage [ i ] ) ; 
line 38158: pCur -> apPage [ i ] = 0 ; 
line 38159: } 
line 38160: pCur -> iPage = - 1 ; 
line 38161: pCur -> eState = CURSOR_REQUIRESEEK ; 
line 38162: } 
line 38164: invalidateOverflowCache ( pCur ) ; 
line 38165: return rc ; 
line 38166: } 
line 38173: static int saveAllCursors ( BtShared * pBt , Pgno iRoot , BtCursor * pExcept ) { 
line 38174: BtCursor * p ; 
line 38175: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 38176: assert ( pExcept == 0 || pExcept -> pBt == pBt ) ; 
line 38177: for ( p = pBt -> pCursor ; p ; p = p -> pNext ) { 
line 38178: if ( p != pExcept && ( 0 == iRoot || p -> pgnoRoot == iRoot ) && 
line 38179: p -> eState == CURSOR_VALID ) { 
line 38180: int rc = saveCursorPosition ( p ) ; 
line 38181: if ( SQLITE_OK != rc ) { 
line 38182: return rc ; 
line 38183: } 
line 38184: } 
line 38185: } 
line 38186: return SQLITE_OK ; 
line 38187: } 
line 38192: SQLITE_PRIVATE void sqlite3BtreeClearCursor ( BtCursor * pCur ) { 
line 38193: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 38194: sqlite3_free ( pCur -> pKey ) ; 
line 38195: pCur -> pKey = 0 ; 
line 38196: pCur -> eState = CURSOR_INVALID ; 
line 38197: } 
line 38204: static int btreeMoveto ( 
line 38205: BtCursor * pCur , 
line 38206: const void * pKey , 
line 38207: i64 nKey , 
line 38208: int bias , 
line 38209: int * pRes 
line 38210: ) { 
line 38211: int rc ; 
line 38212: UnpackedRecord * pIdxKey ; 
line 38213: char aSpace [ 150 ] ; 
line 38215: if ( pKey ) { 
line 38216: assert ( nKey == ( i64 ) ( int ) nKey ) ; 
line 38217: pIdxKey = sqlite3VdbeRecordUnpack ( pCur -> pKeyInfo , ( int ) nKey , pKey , 
line 38218: aSpace , sizeof ( aSpace ) ) ; 
line 38219: if ( pIdxKey == 0 ) return SQLITE_NOMEM ; 
line 38220: } else { 
line 38221: pIdxKey = 0 ; 
line 38222: } 
line 38223: rc = sqlite3BtreeMovetoUnpacked ( pCur , pIdxKey , nKey , bias , pRes ) ; 
line 38224: if ( pKey ) { 
line 38225: sqlite3VdbeDeleteUnpackedRecord ( pIdxKey ) ; 
line 38226: } 
line 38227: return rc ; 
line 38228: } 
line 38237: static int btreeRestoreCursorPosition ( BtCursor * pCur ) { 
line 38238: int rc ; 
line 38239: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 38240: assert ( pCur -> eState >= CURSOR_REQUIRESEEK ) ; 
line 38241: if ( pCur -> eState == CURSOR_FAULT ) { 
line 38242: return pCur -> skipNext ; 
line 38243: } 
line 38244: pCur -> eState = CURSOR_INVALID ; 
line 38245: rc = btreeMoveto ( pCur , pCur -> pKey , pCur -> nKey , 0 , & pCur -> skipNext ) ; 
line 38246: if ( rc == SQLITE_OK ) { 
line 38247: sqlite3_free ( pCur -> pKey ) ; 
line 38248: pCur -> pKey = 0 ; 
line 38249: assert ( pCur -> eState == CURSOR_VALID || pCur -> eState == CURSOR_INVALID ) ; 
line 38250: } 
line 38251: return rc ; 
line 38252: } 
line 38254: # define restoreCursorPosition ( p ) 
line 38255: ( p -> eState >= CURSOR_REQUIRESEEK ? 
line 38256: btreeRestoreCursorPosition ( p ) : 
line 38257: SQLITE_OK ) 
line 38267: SQLITE_PRIVATE int sqlite3BtreeCursorHasMoved ( BtCursor * pCur , int * pHasMoved ) { 
line 38268: int rc ; 
line 38270: rc = restoreCursorPosition ( pCur ) ; 
line 38271: if ( rc ) { 
line 38272: * pHasMoved = 1 ; 
line 38273: return rc ; 
line 38274: } 
line 38275: if ( pCur -> eState != CURSOR_VALID || pCur -> skipNext != 0 ) { 
line 38276: * pHasMoved = 1 ; 
line 38277: } else { 
line 38278: * pHasMoved = 0 ; 
line 38279: } 
line 38280: return SQLITE_OK ; 
line 38281: } 
line 38283: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 38289: static Pgno ptrmapPageno ( BtShared * pBt , Pgno pgno ) { 
line 38290: int nPagesPerMapPage ; 
line 38291: Pgno iPtrMap , ret ; 
line 38292: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 38293: nPagesPerMapPage = ( pBt -> usableSize / 5 ) + 1 ; 
line 38294: iPtrMap = ( pgno - 2 ) / nPagesPerMapPage ; 
line 38295: ret = ( iPtrMap * nPagesPerMapPage ) + 2 ; 
line 38296: if ( ret == PENDING_BYTE_PAGE ( pBt ) ) { 
line 38297: ret ++ ; 
line 38298: } 
line 38299: return ret ; 
line 38300: } 
line 38312: static void ptrmapPut ( BtShared * pBt , Pgno key , u8 eType , Pgno parent , int * pRC ) { 
line 38313: DbPage * pDbPage ; 
line 38314: u8 * pPtrmap ; 
line 38315: Pgno iPtrmap ; 
line 38316: int offset ; 
line 38317: int rc ; 
line 38319: if ( * pRC ) return ; 
line 38321: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 38323: assert ( 0 == PTRMAP_ISPAGE ( pBt , PENDING_BYTE_PAGE ( pBt ) ) ) ; 
line 38325: assert ( pBt -> autoVacuum ) ; 
line 38326: if ( key == 0 ) { 
line 38327: * pRC = SQLITE_CORRUPT_BKPT ; 
line 38328: return ; 
line 38329: } 
line 38330: iPtrmap = PTRMAP_PAGENO ( pBt , key ) ; 
line 38331: rc = sqlite3PagerGet ( pBt -> pPager , iPtrmap , & pDbPage ) ; 
line 38332: if ( rc != SQLITE_OK ) { 
line 38333: * pRC = rc ; 
line 38334: return ; 
line 38335: } 
line 38336: offset = PTRMAP_PTROFFSET ( iPtrmap , key ) ; 
line 38337: if ( offset < 0 ) { 
line 38338: * pRC = SQLITE_CORRUPT_BKPT ; 
line 38339: goto ptrmap_exit ; 
line 38340: } 
line 38341: pPtrmap = ( u8 * ) sqlite3PagerGetData ( pDbPage ) ; 
line 38343: if ( eType != pPtrmap [ offset ] || get4byte ( & pPtrmap [ offset + 1 ] ) != parent ) { 
line 38344: TRACE ( ( "PTRMAP_UPDATE: %d->(%d,%d)\n" , key , eType , parent ) ) ; 
line 38345: * pRC = rc = sqlite3PagerWrite ( pDbPage ) ; 
line 38346: if ( rc == SQLITE_OK ) { 
line 38347: pPtrmap [ offset ] = eType ; 
line 38348: put4byte ( & pPtrmap [ offset + 1 ] , parent ) ; 
line 38349: } 
line 38350: } 
line 38352: ptrmap_exit : 
line 38353: sqlite3PagerUnref ( pDbPage ) ; 
line 38354: } 
line 38363: static int ptrmapGet ( BtShared * pBt , Pgno key , u8 * pEType , Pgno * pPgno ) { 
line 38364: DbPage * pDbPage ; 
line 38365: int iPtrmap ; 
line 38366: u8 * pPtrmap ; 
line 38367: int offset ; 
line 38368: int rc ; 
line 38370: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 38372: iPtrmap = PTRMAP_PAGENO ( pBt , key ) ; 
line 38373: rc = sqlite3PagerGet ( pBt -> pPager , iPtrmap , & pDbPage ) ; 
line 38374: if ( rc != 0 ) { 
line 38375: return rc ; 
line 38376: } 
line 38377: pPtrmap = ( u8 * ) sqlite3PagerGetData ( pDbPage ) ; 
line 38379: offset = PTRMAP_PTROFFSET ( iPtrmap , key ) ; 
line 38380: assert ( pEType != 0 ) ; 
line 38381: * pEType = pPtrmap [ offset ] ; 
line 38382: if ( pPgno ) * pPgno = get4byte ( & pPtrmap [ offset + 1 ] ) ; 
line 38384: sqlite3PagerUnref ( pDbPage ) ; 
line 38385: if ( * pEType < 1 || * pEType > 5 ) return SQLITE_CORRUPT_BKPT ; 
line 38386: return SQLITE_OK ; 
line 38387: } 
line 38389: # else 
line 38390: # define ptrmapPut ( w , x , y , z , rc ) 
line 38391: # define ptrmapGet ( w , x , y , z ) SQLITE_OK 
line 38392: # define ptrmapPutOvflPtr ( x , y , rc ) 
line 38393: # endif 
line 38402: # define findCell ( P , I ) 
line 38403: ( ( P ) -> aData + ( ( P ) -> maskPage & get2byte ( & ( P ) -> aData [ ( P ) -> cellOffset + 2 * ( I ) ] ) ) ) 
line 38409: static u8 * findOverflowCell ( MemPage * pPage , int iCell ) { 
line 38410: int i ; 
line 38411: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 38412: for ( i = pPage -> nOverflow - 1 ; i >= 0 ; i -- ) { 
line 38413: int k ; 
line 38414: struct _OvflCell * pOvfl ; 
line 38415: pOvfl = & pPage -> aOvfl [ i ] ; 
line 38416: k = pOvfl -> idx ; 
line 38417: if ( k <= iCell ) { 
line 38418: if ( k == iCell ) { 
line 38419: return pOvfl -> pCell ; 
line 38420: } 
line 38421: iCell -- ; 
line 38422: } 
line 38423: } 
line 38424: return findCell ( pPage , iCell ) ; 
line 38425: } 
line 38436: static void btreeParseCellPtr ( 
line 38437: MemPage * pPage , 
line 38438: u8 * pCell , 
line 38439: CellInfo * pInfo 
line 38440: ) { 
line 38441: u16 n ; 
line 38442: u32 nPayload ; 
line 38444: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 38446: pInfo -> pCell = pCell ; 
line 38447: assert ( pPage -> leaf == 0 || pPage -> leaf == 1 ) ; 
line 38448: n = pPage -> childPtrSize ; 
line 38449: assert ( n == 4 - 4 * pPage -> leaf ) ; 
line 38450: if ( pPage -> intKey ) { 
line 38451: if ( pPage -> hasData ) { 
line 38452: n += getVarint32 ( & pCell [ n ] , nPayload ) ; 
line 38453: } else { 
line 38454: nPayload = 0 ; 
line 38455: } 
line 38456: n += getVarint ( & pCell [ n ] , ( u64 * ) & pInfo -> nKey ) ; 
line 38457: pInfo -> nData = nPayload ; 
line 38458: } else { 
line 38459: pInfo -> nData = 0 ; 
line 38460: n += getVarint32 ( & pCell [ n ] , nPayload ) ; 
line 38461: pInfo -> nKey = nPayload ; 
line 38462: } 
line 38463: pInfo -> nPayload = nPayload ; 
line 38464: pInfo -> nHeader = n ; 
line 38465: testcase ( nPayload == pPage -> maxLocal ) ; 
line 38466: testcase ( nPayload == pPage -> maxLocal + 1 ) ; 
line 38467: if ( likely ( nPayload <= pPage -> maxLocal ) ) { 
line 38471: int nSize ; 
line 38472: nSize = nPayload + n ; 
line 38473: pInfo -> nLocal = ( u16 ) nPayload ; 
line 38474: pInfo -> iOverflow = 0 ; 
line 38475: if ( ( nSize & ~ 3 ) == 0 ) { 
line 38476: nSize = 4 ; 
line 38477: } 
line 38478: pInfo -> nSize = ( u16 ) nSize ; 
line 38479: } else { 
line 38489: int minLocal ; 
line 38490: int maxLocal ; 
line 38491: int surplus ; 
line 38493: minLocal = pPage -> minLocal ; 
line 38494: maxLocal = pPage -> maxLocal ; 
line 38495: surplus = minLocal + ( nPayload - minLocal ) % ( pPage -> pBt -> usableSize - 4 ) ; 
line 38496: testcase ( surplus == maxLocal ) ; 
line 38497: testcase ( surplus == maxLocal + 1 ) ; 
line 38498: if ( surplus <= maxLocal ) { 
line 38499: pInfo -> nLocal = ( u16 ) surplus ; 
line 38500: } else { 
line 38501: pInfo -> nLocal = ( u16 ) minLocal ; 
line 38502: } 
line 38503: pInfo -> iOverflow = ( u16 ) ( pInfo -> nLocal + n ) ; 
line 38504: pInfo -> nSize = pInfo -> iOverflow + 4 ; 
line 38505: } 
line 38506: } 
line 38507: # define parseCell ( pPage , iCell , pInfo ) 
line 38508: btreeParseCellPtr ( ( pPage ) , findCell ( ( pPage ) , ( iCell ) ) , ( pInfo ) ) 
line 38509: static void btreeParseCell ( 
line 38510: MemPage * pPage , 
line 38511: int iCell , 
line 38512: CellInfo * pInfo 
line 38513: ) { 
line 38514: parseCell ( pPage , iCell , pInfo ) ; 
line 38515: } 
line 38523: static u16 cellSizePtr ( MemPage * pPage , u8 * pCell ) { 
line 38524: u8 * pIter = & pCell [ pPage -> childPtrSize ] ; 
line 38525: u32 nSize ; 
line 38527: # ifdef SQLITE_DEBUG 
line 38532: CellInfo debuginfo ; 
line 38533: btreeParseCellPtr ( pPage , pCell , & debuginfo ) ; 
line 38534: # endif 
line 38536: if ( pPage -> intKey ) { 
line 38537: u8 * pEnd ; 
line 38538: if ( pPage -> hasData ) { 
line 38539: pIter += getVarint32 ( pIter , nSize ) ; 
line 38540: } else { 
line 38541: nSize = 0 ; 
line 38542: } 
line 38547: pEnd = & pIter [ 9 ] ; 
line 38548: while ( ( * pIter ++ ) & 0x80 && pIter < pEnd ) ; 
line 38549: } else { 
line 38550: pIter += getVarint32 ( pIter , nSize ) ; 
line 38551: } 
line 38553: testcase ( nSize == pPage -> maxLocal ) ; 
line 38554: testcase ( nSize == pPage -> maxLocal + 1 ) ; 
line 38555: if ( nSize > pPage -> maxLocal ) { 
line 38556: int minLocal = pPage -> minLocal ; 
line 38557: nSize = minLocal + ( nSize - minLocal ) % ( pPage -> pBt -> usableSize - 4 ) ; 
line 38558: testcase ( nSize == pPage -> maxLocal ) ; 
line 38559: testcase ( nSize == pPage -> maxLocal + 1 ) ; 
line 38560: if ( nSize > pPage -> maxLocal ) { 
line 38561: nSize = minLocal ; 
line 38562: } 
line 38563: nSize += 4 ; 
line 38564: } 
line 38565: nSize += ( u32 ) ( pIter - pCell ) ; 
line 38568: if ( nSize < 4 ) { 
line 38569: nSize = 4 ; 
line 38570: } 
line 38572: assert ( nSize == debuginfo . nSize ) ; 
line 38573: return ( u16 ) nSize ; 
line 38574: } 
line 38576: # ifdef SQLITE_DEBUG 
line 38579: static u16 cellSize ( MemPage * pPage , int iCell ) { 
line 38580: return cellSizePtr ( pPage , findCell ( pPage , iCell ) ) ; 
line 38581: } 
line 38582: # endif 
line 38584: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 38590: static void ptrmapPutOvflPtr ( MemPage * pPage , u8 * pCell , int * pRC ) { 
line 38591: CellInfo info ; 
line 38592: if ( * pRC ) return ; 
line 38593: assert ( pCell != 0 ) ; 
line 38594: btreeParseCellPtr ( pPage , pCell , & info ) ; 
line 38595: assert ( ( info . nData + ( pPage -> intKey ? 0 : info . nKey ) ) == info . nPayload ) ; 
line 38596: if ( info . iOverflow ) { 
line 38597: Pgno ovfl = get4byte ( & pCell [ info . iOverflow ] ) ; 
line 38598: ptrmapPut ( pPage -> pBt , ovfl , PTRMAP_OVERFLOW1 , pPage -> pgno , pRC ) ; 
line 38599: } 
line 38600: } 
line 38601: # endif 
line 38610: static int defragmentPage ( MemPage * pPage ) { 
line 38611: int i ; 
line 38612: int pc ; 
line 38613: int hdr ; 
line 38614: int size ; 
line 38615: int usableSize ; 
line 38616: int cellOffset ; 
line 38617: int cbrk ; 
line 38618: int nCell ; 
line 38619: unsigned char * data ; 
line 38620: unsigned char * temp ; 
line 38621: int iCellFirst ; 
line 38622: int iCellLast ; 
line 38625: assert ( sqlite3PagerIswriteable ( pPage -> pDbPage ) ) ; 
line 38626: assert ( pPage -> pBt != 0 ) ; 
line 38627: assert ( pPage -> pBt -> usableSize <= SQLITE_MAX_PAGE_SIZE ) ; 
line 38628: assert ( pPage -> nOverflow == 0 ) ; 
line 38629: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 38630: temp = sqlite3PagerTempSpace ( pPage -> pBt -> pPager ) ; 
line 38631: data = pPage -> aData ; 
line 38632: hdr = pPage -> hdrOffset ; 
line 38633: cellOffset = pPage -> cellOffset ; 
line 38634: nCell = pPage -> nCell ; 
line 38635: assert ( nCell == get2byte ( & data [ hdr + 3 ] ) ) ; 
line 38636: usableSize = pPage -> pBt -> usableSize ; 
line 38637: cbrk = get2byte ( & data [ hdr + 5 ] ) ; 
line 38638: memcpy ( & temp [ cbrk ] , & data [ cbrk ] , usableSize - cbrk ) ; 
line 38639: cbrk = usableSize ; 
line 38640: iCellFirst = cellOffset + 2 * nCell ; 
line 38641: iCellLast = usableSize - 4 ; 
line 38642: for ( i = 0 ; i < nCell ; i ++ ) { 
line 38643: u8 * pAddr ; 
line 38644: pAddr = & data [ cellOffset + i * 2 ] ; 
line 38645: pc = get2byte ( pAddr ) ; 
line 38646: testcase ( pc == iCellFirst ) ; 
line 38647: testcase ( pc == iCellLast ) ; 
line 38648: # if ! defined ( SQLITE_ENABLE_OVERSIZE_CELL_CHECK ) 
line 38652: if ( pc < iCellFirst || pc > iCellLast ) { 
line 38653: return SQLITE_CORRUPT_BKPT ; 
line 38654: } 
line 38655: # endif 
line 38656: assert ( pc >= iCellFirst && pc <= iCellLast ) ; 
line 38657: size = cellSizePtr ( pPage , & temp [ pc ] ) ; 
line 38658: cbrk -= size ; 
line 38659: # if defined ( SQLITE_ENABLE_OVERSIZE_CELL_CHECK ) 
line 38660: if ( cbrk < iCellFirst ) { 
line 38661: return SQLITE_CORRUPT_BKPT ; 
line 38662: } 
line 38663: # else 
line 38664: if ( cbrk < iCellFirst || pc + size > usableSize ) { 
line 38665: return SQLITE_CORRUPT_BKPT ; 
line 38666: } 
line 38667: # endif 
line 38668: assert ( cbrk + size <= usableSize && cbrk >= iCellFirst ) ; 
line 38669: testcase ( cbrk + size == usableSize ) ; 
line 38670: testcase ( pc + size == usableSize ) ; 
line 38671: memcpy ( & data [ cbrk ] , & temp [ pc ] , size ) ; 
line 38672: put2byte ( pAddr , cbrk ) ; 
line 38673: } 
line 38674: assert ( cbrk >= iCellFirst ) ; 
line 38675: put2byte ( & data [ hdr + 5 ] , cbrk ) ; 
line 38676: data [ hdr + 1 ] = 0 ; 
line 38677: data [ hdr + 2 ] = 0 ; 
line 38678: data [ hdr + 7 ] = 0 ; 
line 38679: memset ( & data [ iCellFirst ] , 0 , cbrk - iCellFirst ) ; 
line 38680: assert ( sqlite3PagerIswriteable ( pPage -> pDbPage ) ) ; 
line 38681: if ( cbrk - iCellFirst != pPage -> nFree ) { 
line 38682: return SQLITE_CORRUPT_BKPT ; 
line 38683: } 
line 38684: return SQLITE_OK ; 
line 38685: } 
line 38700: static int allocateSpace ( MemPage * pPage , int nByte , int * pIdx ) { 
line 38701: const int hdr = pPage -> hdrOffset ; 
line 38702: u8 * const data = pPage -> aData ; 
line 38703: int nFrag ; 
line 38704: int top ; 
line 38705: int gap ; 
line 38706: int rc ; 
line 38707: int usableSize ; 
line 38709: assert ( sqlite3PagerIswriteable ( pPage -> pDbPage ) ) ; 
line 38710: assert ( pPage -> pBt ) ; 
line 38711: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 38712: assert ( nByte >= 0 ) ; 
line 38713: assert ( pPage -> nFree >= nByte ) ; 
line 38714: assert ( pPage -> nOverflow == 0 ) ; 
line 38715: usableSize = pPage -> pBt -> usableSize ; 
line 38716: assert ( nByte < usableSize - 8 ) ; 
line 38718: nFrag = data [ hdr + 7 ] ; 
line 38719: assert ( pPage -> cellOffset == hdr + 12 - 4 * pPage -> leaf ) ; 
line 38720: gap = pPage -> cellOffset + 2 * pPage -> nCell ; 
line 38721: top = get2byte ( & data [ hdr + 5 ] ) ; 
line 38722: if ( gap > top ) return SQLITE_CORRUPT_BKPT ; 
line 38723: testcase ( gap + 2 == top ) ; 
line 38724: testcase ( gap + 1 == top ) ; 
line 38725: testcase ( gap == top ) ; 
line 38727: if ( nFrag >= 60 ) { 
line 38729: rc = defragmentPage ( pPage ) ; 
line 38730: if ( rc ) return rc ; 
line 38731: top = get2byte ( & data [ hdr + 5 ] ) ; 
line 38732: } else if ( gap + 2 <= top ) { 
line 38737: int pc , addr ; 
line 38738: for ( addr = hdr + 1 ; ( pc = get2byte ( & data [ addr ] ) ) > 0 ; addr = pc ) { 
line 38739: int size ; 
line 38740: if ( pc > usableSize - 4 || pc < addr + 4 ) { 
line 38741: return SQLITE_CORRUPT_BKPT ; 
line 38742: } 
line 38743: size = get2byte ( & data [ pc + 2 ] ) ; 
line 38744: if ( size >= nByte ) { 
line 38745: int x = size - nByte ; 
line 38746: testcase ( x == 4 ) ; 
line 38747: testcase ( x == 3 ) ; 
line 38748: if ( x < 4 ) { 
line 38751: memcpy ( & data [ addr ] , & data [ pc ] , 2 ) ; 
line 38752: data [ hdr + 7 ] = ( u8 ) ( nFrag + x ) ; 
line 38753: } else if ( size + pc > usableSize ) { 
line 38754: return SQLITE_CORRUPT_BKPT ; 
line 38755: } else { 
line 38758: put2byte ( & data [ pc + 2 ] , x ) ; 
line 38759: } 
line 38760: * pIdx = pc + x ; 
line 38761: return SQLITE_OK ; 
line 38762: } 
line 38763: } 
line 38764: } 
line 38769: testcase ( gap + 2 + nByte == top ) ; 
line 38770: if ( gap + 2 + nByte > top ) { 
line 38771: rc = defragmentPage ( pPage ) ; 
line 38772: if ( rc ) return rc ; 
line 38773: top = get2byte ( & data [ hdr + 5 ] ) ; 
line 38774: assert ( gap + nByte <= top ) ; 
line 38775: } 
line 38784: top -= nByte ; 
line 38785: put2byte ( & data [ hdr + 5 ] , top ) ; 
line 38786: assert ( top + nByte <= pPage -> pBt -> usableSize ) ; 
line 38787: * pIdx = top ; 
line 38788: return SQLITE_OK ; 
line 38789: } 
line 38799: static int freeSpace ( MemPage * pPage , int start , int size ) { 
line 38800: int addr , pbegin , hdr ; 
line 38801: int iLast ; 
line 38802: unsigned char * data = pPage -> aData ; 
line 38804: assert ( pPage -> pBt != 0 ) ; 
line 38805: assert ( sqlite3PagerIswriteable ( pPage -> pDbPage ) ) ; 
line 38806: assert ( start >= pPage -> hdrOffset + 6 + pPage -> childPtrSize ) ; 
line 38807: assert ( ( start + size ) <= pPage -> pBt -> usableSize ) ; 
line 38808: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 38809: assert ( size >= 0 ) ; 
line 38811: # ifdef SQLITE_SECURE_DELETE 
line 38814: memset ( & data [ start ] , 0 , size ) ; 
line 38815: # endif 
line 38826: hdr = pPage -> hdrOffset ; 
line 38827: addr = hdr + 1 ; 
line 38828: iLast = pPage -> pBt -> usableSize - 4 ; 
line 38829: assert ( start <= iLast ) ; 
line 38830: while ( ( pbegin = get2byte ( & data [ addr ] ) ) < start && pbegin > 0 ) { 
line 38831: if ( pbegin < addr + 4 ) { 
line 38832: return SQLITE_CORRUPT_BKPT ; 
line 38833: } 
line 38834: addr = pbegin ; 
line 38835: } 
line 38836: if ( pbegin > iLast ) { 
line 38837: return SQLITE_CORRUPT_BKPT ; 
line 38838: } 
line 38839: assert ( pbegin > addr || pbegin == 0 ) ; 
line 38840: put2byte ( & data [ addr ] , start ) ; 
line 38841: put2byte ( & data [ start ] , pbegin ) ; 
line 38842: put2byte ( & data [ start + 2 ] , size ) ; 
line 38843: pPage -> nFree = pPage -> nFree + ( u16 ) size ; 
line 38846: addr = hdr + 1 ; 
line 38847: while ( ( pbegin = get2byte ( & data [ addr ] ) ) > 0 ) { 
line 38848: int pnext , psize , x ; 
line 38849: assert ( pbegin > addr ) ; 
line 38850: assert ( pbegin <= pPage -> pBt -> usableSize - 4 ) ; 
line 38851: pnext = get2byte ( & data [ pbegin ] ) ; 
line 38852: psize = get2byte ( & data [ pbegin + 2 ] ) ; 
line 38853: if ( pbegin + psize + 3 >= pnext && pnext > 0 ) { 
line 38854: int frag = pnext - ( pbegin + psize ) ; 
line 38855: if ( ( frag < 0 ) || ( frag > ( int ) data [ hdr + 7 ] ) ) { 
line 38856: return SQLITE_CORRUPT_BKPT ; 
line 38857: } 
line 38858: data [ hdr + 7 ] -= ( u8 ) frag ; 
line 38859: x = get2byte ( & data [ pnext ] ) ; 
line 38860: put2byte ( & data [ pbegin ] , x ) ; 
line 38861: x = pnext + get2byte ( & data [ pnext + 2 ] ) - pbegin ; 
line 38862: put2byte ( & data [ pbegin + 2 ] , x ) ; 
line 38863: } else { 
line 38864: addr = pbegin ; 
line 38865: } 
line 38866: } 
line 38869: if ( data [ hdr + 1 ] == data [ hdr + 5 ] && data [ hdr + 2 ] == data [ hdr + 6 ] ) { 
line 38870: int top ; 
line 38871: pbegin = get2byte ( & data [ hdr + 1 ] ) ; 
line 38872: memcpy ( & data [ hdr + 1 ] , & data [ pbegin ] , 2 ) ; 
line 38873: top = get2byte ( & data [ hdr + 5 ] ) + get2byte ( & data [ pbegin + 2 ] ) ; 
line 38874: put2byte ( & data [ hdr + 5 ] , top ) ; 
line 38875: } 
line 38876: assert ( sqlite3PagerIswriteable ( pPage -> pDbPage ) ) ; 
line 38877: return SQLITE_OK ; 
line 38878: } 
line 38892: static int decodeFlags ( MemPage * pPage , int flagByte ) { 
line 38893: BtShared * pBt ; 
line 38895: assert ( pPage -> hdrOffset == ( pPage -> pgno == 1 ? 100 : 0 ) ) ; 
line 38896: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 38897: pPage -> leaf = ( u8 ) ( flagByte >> 3 ) ; assert ( PTF_LEAF == 1 << 3 ) ; 
line 38898: flagByte &= ~ PTF_LEAF ; 
line 38899: pPage -> childPtrSize = 4 - 4 * pPage -> leaf ; 
line 38900: pBt = pPage -> pBt ; 
line 38901: if ( flagByte == ( PTF_LEAFDATA | PTF_INTKEY ) ) { 
line 38902: pPage -> intKey = 1 ; 
line 38903: pPage -> hasData = pPage -> leaf ; 
line 38904: pPage -> maxLocal = pBt -> maxLeaf ; 
line 38905: pPage -> minLocal = pBt -> minLeaf ; 
line 38906: } else if ( flagByte == PTF_ZERODATA ) { 
line 38907: pPage -> intKey = 0 ; 
line 38908: pPage -> hasData = 0 ; 
line 38909: pPage -> maxLocal = pBt -> maxLocal ; 
line 38910: pPage -> minLocal = pBt -> minLocal ; 
line 38911: } else { 
line 38912: return SQLITE_CORRUPT_BKPT ; 
line 38913: } 
line 38914: return SQLITE_OK ; 
line 38915: } 
line 38926: static int btreeInitPage ( MemPage * pPage ) { 
line 38928: assert ( pPage -> pBt != 0 ) ; 
line 38929: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 38930: assert ( pPage -> pgno == sqlite3PagerPagenumber ( pPage -> pDbPage ) ) ; 
line 38931: assert ( pPage == sqlite3PagerGetExtra ( pPage -> pDbPage ) ) ; 
line 38932: assert ( pPage -> aData == sqlite3PagerGetData ( pPage -> pDbPage ) ) ; 
line 38934: if ( ! pPage -> isInit ) { 
line 38935: u16 pc ; 
line 38936: u8 hdr ; 
line 38937: u8 * data ; 
line 38938: BtShared * pBt ; 
line 38939: u16 usableSize ; 
line 38940: u16 cellOffset ; 
line 38941: u16 nFree ; 
line 38942: u16 top ; 
line 38943: int iCellFirst ; 
line 38944: int iCellLast ; 
line 38946: pBt = pPage -> pBt ; 
line 38948: hdr = pPage -> hdrOffset ; 
line 38949: data = pPage -> aData ; 
line 38950: if ( decodeFlags ( pPage , data [ hdr ] ) ) return SQLITE_CORRUPT_BKPT ; 
line 38951: assert ( pBt -> pageSize >= 512 && pBt -> pageSize <= 32768 ) ; 
line 38952: pPage -> maskPage = pBt -> pageSize - 1 ; 
line 38953: pPage -> nOverflow = 0 ; 
line 38954: usableSize = pBt -> usableSize ; 
line 38955: pPage -> cellOffset = cellOffset = hdr + 12 - 4 * pPage -> leaf ; 
line 38956: top = get2byte ( & data [ hdr + 5 ] ) ; 
line 38957: pPage -> nCell = get2byte ( & data [ hdr + 3 ] ) ; 
line 38958: if ( pPage -> nCell > MX_CELL ( pBt ) ) { 
line 38960: return SQLITE_CORRUPT_BKPT ; 
line 38961: } 
line 38962: testcase ( pPage -> nCell == MX_CELL ( pBt ) ) ; 
line 38971: iCellFirst = cellOffset + 2 * pPage -> nCell ; 
line 38972: iCellLast = usableSize - 4 ; 
line 38973: # if defined ( SQLITE_ENABLE_OVERSIZE_CELL_CHECK ) 
line 38974: { 
line 38975: int i ; 
line 38976: int sz ; 
line 38978: if ( ! pPage -> leaf ) iCellLast -- ; 
line 38979: for ( i = 0 ; i < pPage -> nCell ; i ++ ) { 
line 38980: pc = get2byte ( & data [ cellOffset + i * 2 ] ) ; 
line 38981: testcase ( pc == iCellFirst ) ; 
line 38982: testcase ( pc == iCellLast ) ; 
line 38983: if ( pc < iCellFirst || pc > iCellLast ) { 
line 38984: return SQLITE_CORRUPT_BKPT ; 
line 38985: } 
line 38986: sz = cellSizePtr ( pPage , & data [ pc ] ) ; 
line 38987: testcase ( pc + sz == usableSize ) ; 
line 38988: if ( pc + sz > usableSize ) { 
line 38989: return SQLITE_CORRUPT_BKPT ; 
line 38990: } 
line 38991: } 
line 38992: if ( ! pPage -> leaf ) iCellLast ++ ; 
line 38993: } 
line 38994: # endif 
line 38997: pc = get2byte ( & data [ hdr + 1 ] ) ; 
line 38998: nFree = data [ hdr + 7 ] + top ; 
line 38999: while ( pc > 0 ) { 
line 39000: u16 next , size ; 
line 39001: if ( pc < iCellFirst || pc > iCellLast ) { 
line 39003: return SQLITE_CORRUPT_BKPT ; 
line 39004: } 
line 39005: next = get2byte ( & data [ pc ] ) ; 
line 39006: size = get2byte ( & data [ pc + 2 ] ) ; 
line 39007: if ( ( next > 0 && next <= pc + size + 3 ) || pc + size > usableSize ) { 
line 39010: return SQLITE_CORRUPT_BKPT ; 
line 39011: } 
line 39012: nFree = nFree + size ; 
line 39013: pc = next ; 
line 39014: } 
line 39023: if ( nFree > usableSize ) { 
line 39024: return SQLITE_CORRUPT_BKPT ; 
line 39025: } 
line 39026: pPage -> nFree = ( u16 ) ( nFree - iCellFirst ) ; 
line 39027: pPage -> isInit = 1 ; 
line 39028: } 
line 39029: return SQLITE_OK ; 
line 39030: } 
line 39036: static void zeroPage ( MemPage * pPage , int flags ) { 
line 39037: unsigned char * data = pPage -> aData ; 
line 39038: BtShared * pBt = pPage -> pBt ; 
line 39039: u8 hdr = pPage -> hdrOffset ; 
line 39040: u16 first ; 
line 39042: assert ( sqlite3PagerPagenumber ( pPage -> pDbPage ) == pPage -> pgno ) ; 
line 39043: assert ( sqlite3PagerGetExtra ( pPage -> pDbPage ) == ( void * ) pPage ) ; 
line 39044: assert ( sqlite3PagerGetData ( pPage -> pDbPage ) == data ) ; 
line 39045: assert ( sqlite3PagerIswriteable ( pPage -> pDbPage ) ) ; 
line 39046: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 39047: # ifdef SQLITE_SECURE_DELETE 
line 39048: memset ( & data [ hdr ] , 0 , pBt -> usableSize - hdr ) ; 
line 39049: # endif 
line 39050: data [ hdr ] = ( char ) flags ; 
line 39051: first = hdr + 8 + 4 * ( ( flags & PTF_LEAF ) == 0 ? 1 : 0 ) ; 
line 39052: memset ( & data [ hdr + 1 ] , 0 , 4 ) ; 
line 39053: data [ hdr + 7 ] = 0 ; 
line 39054: put2byte ( & data [ hdr + 5 ] , pBt -> usableSize ) ; 
line 39055: pPage -> nFree = pBt -> usableSize - first ; 
line 39056: decodeFlags ( pPage , flags ) ; 
line 39057: pPage -> hdrOffset = hdr ; 
line 39058: pPage -> cellOffset = first ; 
line 39059: pPage -> nOverflow = 0 ; 
line 39060: assert ( pBt -> pageSize >= 512 && pBt -> pageSize <= 32768 ) ; 
line 39061: pPage -> maskPage = pBt -> pageSize - 1 ; 
line 39062: pPage -> nCell = 0 ; 
line 39063: pPage -> isInit = 1 ; 
line 39064: } 
line 39071: static MemPage * btreePageFromDbPage ( DbPage * pDbPage , Pgno pgno , BtShared * pBt ) { 
line 39072: MemPage * pPage = ( MemPage * ) sqlite3PagerGetExtra ( pDbPage ) ; 
line 39073: pPage -> aData = sqlite3PagerGetData ( pDbPage ) ; 
line 39074: pPage -> pDbPage = pDbPage ; 
line 39075: pPage -> pBt = pBt ; 
line 39076: pPage -> pgno = pgno ; 
line 39077: pPage -> hdrOffset = pPage -> pgno == 1 ? 100 : 0 ; 
line 39078: return pPage ; 
line 39079: } 
line 39092: static int btreeGetPage ( 
line 39093: BtShared * pBt , 
line 39094: Pgno pgno , 
line 39095: MemPage * * ppPage , 
line 39096: int noContent 
line 39097: ) { 
line 39098: int rc ; 
line 39099: DbPage * pDbPage ; 
line 39101: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 39102: rc = sqlite3PagerAcquire ( pBt -> pPager , pgno , ( DbPage * * ) & pDbPage , noContent ) ; 
line 39103: if ( rc ) return rc ; 
line 39104: * ppPage = btreePageFromDbPage ( pDbPage , pgno , pBt ) ; 
line 39105: return SQLITE_OK ; 
line 39106: } 
line 39113: static MemPage * btreePageLookup ( BtShared * pBt , Pgno pgno ) { 
line 39114: DbPage * pDbPage ; 
line 39115: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 39116: pDbPage = sqlite3PagerLookup ( pBt -> pPager , pgno ) ; 
line 39117: if ( pDbPage ) { 
line 39118: return btreePageFromDbPage ( pDbPage , pgno , pBt ) ; 
line 39119: } 
line 39120: return 0 ; 
line 39121: } 
line 39127: static Pgno pagerPagecount ( BtShared * pBt ) { 
line 39128: int nPage = - 1 ; 
line 39129: int rc ; 
line 39130: assert ( pBt -> pPage1 ) ; 
line 39131: rc = sqlite3PagerPagecount ( pBt -> pPager , & nPage ) ; 
line 39132: assert ( rc == SQLITE_OK || nPage == - 1 ) ; 
line 39133: return ( Pgno ) nPage ; 
line 39134: } 
line 39144: static int getAndInitPage ( 
line 39145: BtShared * pBt , 
line 39146: Pgno pgno , 
line 39147: MemPage * * ppPage 
line 39148: ) { 
line 39149: int rc ; 
line 39150: TESTONLY ( Pgno iLastPg = pagerPagecount ( pBt ) ; ) 
line 39151: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 39153: rc = btreeGetPage ( pBt , pgno , ppPage , 0 ) ; 
line 39154: if ( rc == SQLITE_OK ) { 
line 39155: rc = btreeInitPage ( * ppPage ) ; 
line 39156: if ( rc != SQLITE_OK ) { 
line 39157: releasePage ( * ppPage ) ; 
line 39158: } 
line 39159: } 
line 39165: assert ( ( pgno > 0 && pgno <= iLastPg ) || rc != SQLITE_OK ) ; 
line 39166: testcase ( pgno == 0 ) ; 
line 39167: testcase ( pgno == iLastPg ) ; 
line 39169: return rc ; 
line 39170: } 
line 39176: static void releasePage ( MemPage * pPage ) { 
line 39177: if ( pPage ) { 
line 39178: assert ( pPage -> aData ) ; 
line 39179: assert ( pPage -> pBt ) ; 
line 39180: assert ( sqlite3PagerGetExtra ( pPage -> pDbPage ) == ( void * ) pPage ) ; 
line 39181: assert ( sqlite3PagerGetData ( pPage -> pDbPage ) == pPage -> aData ) ; 
line 39182: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 39183: sqlite3PagerUnref ( pPage -> pDbPage ) ; 
line 39184: } 
line 39185: } 
line 39195: static void pageReinit ( DbPage * pData ) { 
line 39196: MemPage * pPage ; 
line 39197: pPage = ( MemPage * ) sqlite3PagerGetExtra ( pData ) ; 
line 39198: assert ( sqlite3PagerPageRefcount ( pData ) > 0 ) ; 
line 39199: if ( pPage -> isInit ) { 
line 39200: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 39201: pPage -> isInit = 0 ; 
line 39202: if ( sqlite3PagerPageRefcount ( pData ) > 1 ) { 
line 39209: btreeInitPage ( pPage ) ; 
line 39210: } 
line 39211: } 
line 39212: } 
line 39217: static int btreeInvokeBusyHandler ( void * pArg ) { 
line 39218: BtShared * pBt = ( BtShared * ) pArg ; 
line 39219: assert ( pBt -> db ) ; 
line 39220: assert ( sqlite3_mutex_held ( pBt -> db -> mutex ) ) ; 
line 39221: return sqlite3InvokeBusyHandler ( & pBt -> db -> busyHandler ) ; 
line 39222: } 
line 39239: SQLITE_PRIVATE int sqlite3BtreeOpen ( 
line 39240: const char * zFilename , 
line 39241: sqlite3 * db , 
line 39242: Btree * * ppBtree , 
line 39243: int flags , 
line 39244: int vfsFlags 
line 39245: ) { 
line 39246: sqlite3_vfs * pVfs ; 
line 39247: BtShared * pBt = 0 ; 
line 39248: Btree * p ; 
line 39249: sqlite3_mutex * mutexOpen = 0 ; 
line 39250: int rc = SQLITE_OK ; 
line 39251: u8 nReserve ; 
line 39252: unsigned char zDbHeader [ 100 ] ; 
line 39259: # if ! defined ( SQLITE_OMIT_SHARED_CACHE ) || ! defined ( SQLITE_OMIT_AUTOVACUUM ) 
line 39260: # ifdef SQLITE_OMIT_MEMORYDB 
line 39261: const int isMemdb = 0 ; 
line 39262: # else 
line 39263: const int isMemdb = zFilename && ! strcmp ( zFilename , ":memory:" ) ; 
line 39264: # endif 
line 39265: # endif 
line 39267: assert ( db != 0 ) ; 
line 39268: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 39270: pVfs = db -> pVfs ; 
line 39271: p = sqlite3MallocZero ( sizeof ( Btree ) ) ; 
line 39272: if ( ! p ) { 
line 39273: return SQLITE_NOMEM ; 
line 39274: } 
line 39275: p -> inTrans = TRANS_NONE ; 
line 39276: p -> db = db ; 
line 39277: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 39278: p -> lock . pBtree = p ; 
line 39279: p -> lock . iTable = 1 ; 
line 39280: # endif 
line 39282: # if ! defined ( SQLITE_OMIT_SHARED_CACHE ) && ! defined ( SQLITE_OMIT_DISKIO ) 
line 39287: if ( isMemdb == 0 && zFilename && zFilename [ 0 ] ) { 
line 39288: if ( vfsFlags & SQLITE_OPEN_SHAREDCACHE ) { 
line 39289: int nFullPathname = pVfs -> mxPathname + 1 ; 
line 39290: char * zFullPathname = sqlite3Malloc ( nFullPathname ) ; 
line 39291: sqlite3_mutex * mutexShared ; 
line 39292: p -> sharable = 1 ; 
line 39293: if ( ! zFullPathname ) { 
line 39294: sqlite3_free ( p ) ; 
line 39295: return SQLITE_NOMEM ; 
line 39296: } 
line 39297: sqlite3OsFullPathname ( pVfs , zFilename , nFullPathname , zFullPathname ) ; 
line 39298: mutexOpen = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_OPEN ) ; 
line 39299: sqlite3_mutex_enter ( mutexOpen ) ; 
line 39300: mutexShared = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ; 
line 39301: sqlite3_mutex_enter ( mutexShared ) ; 
line 39302: for ( pBt = GLOBAL ( BtShared * , sqlite3SharedCacheList ) ; pBt ; pBt = pBt -> pNext ) { 
line 39303: assert ( pBt -> nRef > 0 ) ; 
line 39304: if ( 0 == strcmp ( zFullPathname , sqlite3PagerFilename ( pBt -> pPager ) ) 
line 39305: && sqlite3PagerVfs ( pBt -> pPager ) == pVfs ) { 
line 39306: int iDb ; 
line 39307: for ( iDb = db -> nDb - 1 ; iDb >= 0 ; iDb -- ) { 
line 39308: Btree * pExisting = db -> aDb [ iDb ] . pBt ; 
line 39309: if ( pExisting && pExisting -> pBt == pBt ) { 
line 39310: sqlite3_mutex_leave ( mutexShared ) ; 
line 39311: sqlite3_mutex_leave ( mutexOpen ) ; 
line 39312: sqlite3_free ( zFullPathname ) ; 
line 39313: sqlite3_free ( p ) ; 
line 39314: return SQLITE_CONSTRAINT ; 
line 39315: } 
line 39316: } 
line 39317: p -> pBt = pBt ; 
line 39318: pBt -> nRef ++ ; 
line 39319: break ; 
line 39320: } 
line 39321: } 
line 39322: sqlite3_mutex_leave ( mutexShared ) ; 
line 39323: sqlite3_free ( zFullPathname ) ; 
line 39324: } 
line 39325: # ifdef SQLITE_DEBUG 
line 39326: else { 
line 39332: p -> sharable = 1 ; 
line 39333: } 
line 39334: # endif 
line 39335: } 
line 39336: # endif 
line 39337: if ( pBt == 0 ) { 
line 39343: assert ( sizeof ( i64 ) == 8 || sizeof ( i64 ) == 4 ) ; 
line 39344: assert ( sizeof ( u64 ) == 8 || sizeof ( u64 ) == 4 ) ; 
line 39345: assert ( sizeof ( u32 ) == 4 ) ; 
line 39346: assert ( sizeof ( u16 ) == 2 ) ; 
line 39347: assert ( sizeof ( Pgno ) == 4 ) ; 
line 39349: pBt = sqlite3MallocZero ( sizeof ( * pBt ) ) ; 
line 39350: if ( pBt == 0 ) { 
line 39351: rc = SQLITE_NOMEM ; 
line 39352: goto btree_open_out ; 
line 39353: } 
line 39354: rc = sqlite3PagerOpen ( pVfs , & pBt -> pPager , zFilename , 
line 39355: EXTRA_SIZE , flags , vfsFlags , pageReinit ) ; 
line 39356: if ( rc == SQLITE_OK ) { 
line 39357: rc = sqlite3PagerReadFileheader ( pBt -> pPager , sizeof ( zDbHeader ) , zDbHeader ) ; 
line 39358: } 
line 39359: if ( rc != SQLITE_OK ) { 
line 39360: goto btree_open_out ; 
line 39361: } 
line 39362: pBt -> db = db ; 
line 39363: sqlite3PagerSetBusyhandler ( pBt -> pPager , btreeInvokeBusyHandler , pBt ) ; 
line 39364: p -> pBt = pBt ; 
line 39366: pBt -> pCursor = 0 ; 
line 39367: pBt -> pPage1 = 0 ; 
line 39368: pBt -> readOnly = sqlite3PagerIsreadonly ( pBt -> pPager ) ; 
line 39369: pBt -> pageSize = get2byte ( & zDbHeader [ 16 ] ) ; 
line 39370: if ( pBt -> pageSize < 512 || pBt -> pageSize > SQLITE_MAX_PAGE_SIZE 
line 39371: || ( ( pBt -> pageSize - 1 ) & pBt -> pageSize ) != 0 ) { 
line 39372: pBt -> pageSize = 0 ; 
line 39373: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 39380: if ( zFilename && ! isMemdb ) { 
line 39381: pBt -> autoVacuum = ( SQLITE_DEFAULT_AUTOVACUUM ? 1 : 0 ) ; 
line 39382: pBt -> incrVacuum = ( SQLITE_DEFAULT_AUTOVACUUM == 2 ? 1 : 0 ) ; 
line 39383: } 
line 39384: # endif 
line 39385: nReserve = 0 ; 
line 39386: } else { 
line 39387: nReserve = zDbHeader [ 20 ] ; 
line 39388: pBt -> pageSizeFixed = 1 ; 
line 39389: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 39390: pBt -> autoVacuum = ( get4byte ( & zDbHeader [ 36 + 4 * 4 ] ) ? 1 : 0 ) ; 
line 39391: pBt -> incrVacuum = ( get4byte ( & zDbHeader [ 36 + 7 * 4 ] ) ? 1 : 0 ) ; 
line 39392: # endif 
line 39393: } 
line 39394: rc = sqlite3PagerSetPagesize ( pBt -> pPager , & pBt -> pageSize , nReserve ) ; 
line 39395: if ( rc ) goto btree_open_out ; 
line 39396: pBt -> usableSize = pBt -> pageSize - nReserve ; 
line 39397: assert ( ( pBt -> pageSize & 7 ) == 0 ) ; 
line 39399: # if ! defined ( SQLITE_OMIT_SHARED_CACHE ) && ! defined ( SQLITE_OMIT_DISKIO ) 
line 39402: if ( p -> sharable ) { 
line 39403: sqlite3_mutex * mutexShared ; 
line 39404: pBt -> nRef = 1 ; 
line 39405: mutexShared = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ; 
line 39406: if ( SQLITE_THREADSAFE && sqlite3GlobalConfig . bCoreMutex ) { 
line 39407: pBt -> mutex = sqlite3MutexAlloc ( SQLITE_MUTEX_FAST ) ; 
line 39408: if ( pBt -> mutex == 0 ) { 
line 39409: rc = SQLITE_NOMEM ; 
line 39410: db -> mallocFailed = 0 ; 
line 39411: goto btree_open_out ; 
line 39412: } 
line 39413: } 
line 39414: sqlite3_mutex_enter ( mutexShared ) ; 
line 39415: pBt -> pNext = GLOBAL ( BtShared * , sqlite3SharedCacheList ) ; 
line 39416: GLOBAL ( BtShared * , sqlite3SharedCacheList ) = pBt ; 
line 39417: sqlite3_mutex_leave ( mutexShared ) ; 
line 39418: } 
line 39419: # endif 
line 39420: } 
line 39422: # if ! defined ( SQLITE_OMIT_SHARED_CACHE ) && ! defined ( SQLITE_OMIT_DISKIO ) 
line 39427: if ( p -> sharable ) { 
line 39428: int i ; 
line 39429: Btree * pSib ; 
line 39430: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 39431: if ( ( pSib = db -> aDb [ i ] . pBt ) != 0 && pSib -> sharable ) { 
line 39432: while ( pSib -> pPrev ) { pSib = pSib -> pPrev ; } 
line 39433: if ( p -> pBt < pSib -> pBt ) { 
line 39434: p -> pNext = pSib ; 
line 39435: p -> pPrev = 0 ; 
line 39436: pSib -> pPrev = p ; 
line 39437: } else { 
line 39438: while ( pSib -> pNext && pSib -> pNext -> pBt < p -> pBt ) { 
line 39439: pSib = pSib -> pNext ; 
line 39440: } 
line 39441: p -> pNext = pSib -> pNext ; 
line 39442: p -> pPrev = pSib ; 
line 39443: if ( p -> pNext ) { 
line 39444: p -> pNext -> pPrev = p ; 
line 39445: } 
line 39446: pSib -> pNext = p ; 
line 39447: } 
line 39448: break ; 
line 39449: } 
line 39450: } 
line 39451: } 
line 39452: # endif 
line 39453: * ppBtree = p ; 
line 39455: btree_open_out : 
line 39456: if ( rc != SQLITE_OK ) { 
line 39457: if ( pBt && pBt -> pPager ) { 
line 39458: sqlite3PagerClose ( pBt -> pPager ) ; 
line 39459: } 
line 39460: sqlite3_free ( pBt ) ; 
line 39461: sqlite3_free ( p ) ; 
line 39462: * ppBtree = 0 ; 
line 39463: } 
line 39464: if ( mutexOpen ) { 
line 39465: assert ( sqlite3_mutex_held ( mutexOpen ) ) ; 
line 39466: sqlite3_mutex_leave ( mutexOpen ) ; 
line 39467: } 
line 39468: return rc ; 
line 39469: } 
line 39477: static int removeFromSharingList ( BtShared * pBt ) { 
line 39478: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 39479: sqlite3_mutex * pMaster ; 
line 39480: BtShared * pList ; 
line 39481: int removed = 0 ; 
line 39483: assert ( sqlite3_mutex_notheld ( pBt -> mutex ) ) ; 
line 39484: pMaster = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ; 
line 39485: sqlite3_mutex_enter ( pMaster ) ; 
line 39486: pBt -> nRef -- ; 
line 39487: if ( pBt -> nRef <= 0 ) { 
line 39488: if ( GLOBAL ( BtShared * , sqlite3SharedCacheList ) == pBt ) { 
line 39489: GLOBAL ( BtShared * , sqlite3SharedCacheList ) = pBt -> pNext ; 
line 39490: } else { 
line 39491: pList = GLOBAL ( BtShared * , sqlite3SharedCacheList ) ; 
line 39492: while ( ALWAYS ( pList ) && pList -> pNext != pBt ) { 
line 39493: pList = pList -> pNext ; 
line 39494: } 
line 39495: if ( ALWAYS ( pList ) ) { 
line 39496: pList -> pNext = pBt -> pNext ; 
line 39497: } 
line 39498: } 
line 39499: if ( SQLITE_THREADSAFE ) { 
line 39500: sqlite3_mutex_free ( pBt -> mutex ) ; 
line 39501: } 
line 39502: removed = 1 ; 
line 39503: } 
line 39504: sqlite3_mutex_leave ( pMaster ) ; 
line 39505: return removed ; 
line 39506: # else 
line 39507: return 1 ; 
line 39508: # endif 
line 39509: } 
line 39515: static void allocateTempSpace ( BtShared * pBt ) { 
line 39516: if ( ! pBt -> pTmpSpace ) { 
line 39517: pBt -> pTmpSpace = sqlite3PageMalloc ( pBt -> pageSize ) ; 
line 39518: } 
line 39519: } 
line 39524: static void freeTempSpace ( BtShared * pBt ) { 
line 39525: sqlite3PageFree ( pBt -> pTmpSpace ) ; 
line 39526: pBt -> pTmpSpace = 0 ; 
line 39527: } 
line 39532: SQLITE_PRIVATE int sqlite3BtreeClose ( Btree * p ) { 
line 39533: BtShared * pBt = p -> pBt ; 
line 39534: BtCursor * pCur ; 
line 39537: assert ( sqlite3_mutex_held ( p -> db -> mutex ) ) ; 
line 39538: sqlite3BtreeEnter ( p ) ; 
line 39539: pCur = pBt -> pCursor ; 
line 39540: while ( pCur ) { 
line 39541: BtCursor * pTmp = pCur ; 
line 39542: pCur = pCur -> pNext ; 
line 39543: if ( pTmp -> pBtree == p ) { 
line 39544: sqlite3BtreeCloseCursor ( pTmp ) ; 
line 39545: } 
line 39546: } 
line 39552: sqlite3BtreeRollback ( p ) ; 
line 39553: sqlite3BtreeLeave ( p ) ; 
line 39559: assert ( p -> wantToLock == 0 && p -> locked == 0 ) ; 
line 39560: if ( ! p -> sharable || removeFromSharingList ( pBt ) ) { 
line 39566: assert ( ! pBt -> pCursor ) ; 
line 39567: sqlite3PagerClose ( pBt -> pPager ) ; 
line 39568: if ( pBt -> xFreeSchema && pBt -> pSchema ) { 
line 39569: pBt -> xFreeSchema ( pBt -> pSchema ) ; 
line 39570: } 
line 39571: sqlite3_free ( pBt -> pSchema ) ; 
line 39572: freeTempSpace ( pBt ) ; 
line 39573: sqlite3_free ( pBt ) ; 
line 39574: } 
line 39576: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 39577: assert ( p -> wantToLock == 0 ) ; 
line 39578: assert ( p -> locked == 0 ) ; 
line 39579: if ( p -> pPrev ) p -> pPrev -> pNext = p -> pNext ; 
line 39580: if ( p -> pNext ) p -> pNext -> pPrev = p -> pPrev ; 
line 39581: # endif 
line 39583: sqlite3_free ( p ) ; 
line 39584: return SQLITE_OK ; 
line 39585: } 
line 39602: SQLITE_PRIVATE int sqlite3BtreeSetCacheSize ( Btree * p , int mxPage ) { 
line 39603: BtShared * pBt = p -> pBt ; 
line 39604: assert ( sqlite3_mutex_held ( p -> db -> mutex ) ) ; 
line 39605: sqlite3BtreeEnter ( p ) ; 
line 39606: sqlite3PagerSetCachesize ( pBt -> pPager , mxPage ) ; 
line 39607: sqlite3BtreeLeave ( p ) ; 
line 39608: return SQLITE_OK ; 
line 39609: } 
line 39619: # ifndef SQLITE_OMIT_PAGER_PRAGMAS 
line 39620: SQLITE_PRIVATE int sqlite3BtreeSetSafetyLevel ( Btree * p , int level , int fullSync ) { 
line 39621: BtShared * pBt = p -> pBt ; 
line 39622: assert ( sqlite3_mutex_held ( p -> db -> mutex ) ) ; 
line 39623: sqlite3BtreeEnter ( p ) ; 
line 39624: sqlite3PagerSetSafetyLevel ( pBt -> pPager , level , fullSync ) ; 
line 39625: sqlite3BtreeLeave ( p ) ; 
line 39626: return SQLITE_OK ; 
line 39627: } 
line 39628: # endif 
line 39634: SQLITE_PRIVATE int sqlite3BtreeSyncDisabled ( Btree * p ) { 
line 39635: BtShared * pBt = p -> pBt ; 
line 39636: int rc ; 
line 39637: assert ( sqlite3_mutex_held ( p -> db -> mutex ) ) ; 
line 39638: sqlite3BtreeEnter ( p ) ; 
line 39639: assert ( pBt && pBt -> pPager ) ; 
line 39640: rc = sqlite3PagerNosync ( pBt -> pPager ) ; 
line 39641: sqlite3BtreeLeave ( p ) ; 
line 39642: return rc ; 
line 39643: } 
line 39645: # if ! defined ( SQLITE_OMIT_PAGER_PRAGMAS ) || ! defined ( SQLITE_OMIT_VACUUM ) 
line 39666: SQLITE_PRIVATE int sqlite3BtreeSetPageSize ( Btree * p , int pageSize , int nReserve , int iFix ) { 
line 39667: int rc = SQLITE_OK ; 
line 39668: BtShared * pBt = p -> pBt ; 
line 39669: assert ( nReserve >= - 1 && nReserve <= 255 ) ; 
line 39670: sqlite3BtreeEnter ( p ) ; 
line 39671: if ( pBt -> pageSizeFixed ) { 
line 39672: sqlite3BtreeLeave ( p ) ; 
line 39673: return SQLITE_READONLY ; 
line 39674: } 
line 39675: if ( nReserve < 0 ) { 
line 39676: nReserve = pBt -> pageSize - pBt -> usableSize ; 
line 39677: } 
line 39678: assert ( nReserve >= 0 && nReserve <= 255 ) ; 
line 39679: if ( pageSize >= 512 && pageSize <= SQLITE_MAX_PAGE_SIZE && 
line 39680: ( ( pageSize - 1 ) & pageSize ) == 0 ) { 
line 39681: assert ( ( pageSize & 7 ) == 0 ) ; 
line 39682: assert ( ! pBt -> pPage1 && ! pBt -> pCursor ) ; 
line 39683: pBt -> pageSize = ( u16 ) pageSize ; 
line 39684: freeTempSpace ( pBt ) ; 
line 39685: } 
line 39686: rc = sqlite3PagerSetPagesize ( pBt -> pPager , & pBt -> pageSize , nReserve ) ; 
line 39687: pBt -> usableSize = pBt -> pageSize - ( u16 ) nReserve ; 
line 39688: if ( iFix ) pBt -> pageSizeFixed = 1 ; 
line 39689: sqlite3BtreeLeave ( p ) ; 
line 39690: return rc ; 
line 39691: } 
line 39696: SQLITE_PRIVATE int sqlite3BtreeGetPageSize ( Btree * p ) { 
line 39697: return p -> pBt -> pageSize ; 
line 39698: } 
line 39705: SQLITE_PRIVATE int sqlite3BtreeGetReserve ( Btree * p ) { 
line 39706: int n ; 
line 39707: sqlite3BtreeEnter ( p ) ; 
line 39708: n = p -> pBt -> pageSize - p -> pBt -> usableSize ; 
line 39709: sqlite3BtreeLeave ( p ) ; 
line 39710: return n ; 
line 39711: } 
line 39718: SQLITE_PRIVATE int sqlite3BtreeMaxPageCount ( Btree * p , int mxPage ) { 
line 39719: int n ; 
line 39720: sqlite3BtreeEnter ( p ) ; 
line 39721: n = sqlite3PagerMaxPageCount ( p -> pBt -> pPager , mxPage ) ; 
line 39722: sqlite3BtreeLeave ( p ) ; 
line 39723: return n ; 
line 39724: } 
line 39725: # endif 
line 39733: SQLITE_PRIVATE int sqlite3BtreeSetAutoVacuum ( Btree * p , int autoVacuum ) { 
line 39734: # ifdef SQLITE_OMIT_AUTOVACUUM 
line 39735: return SQLITE_READONLY ; 
line 39736: # else 
line 39737: BtShared * pBt = p -> pBt ; 
line 39738: int rc = SQLITE_OK ; 
line 39739: u8 av = ( u8 ) autoVacuum ; 
line 39741: sqlite3BtreeEnter ( p ) ; 
line 39742: if ( pBt -> pageSizeFixed && ( av ? 1 : 0 ) != pBt -> autoVacuum ) { 
line 39743: rc = SQLITE_READONLY ; 
line 39744: } else { 
line 39745: pBt -> autoVacuum = av ? 1 : 0 ; 
line 39746: pBt -> incrVacuum = av == 2 ? 1 : 0 ; 
line 39747: } 
line 39748: sqlite3BtreeLeave ( p ) ; 
line 39749: return rc ; 
line 39750: # endif 
line 39751: } 
line 39757: SQLITE_PRIVATE int sqlite3BtreeGetAutoVacuum ( Btree * p ) { 
line 39758: # ifdef SQLITE_OMIT_AUTOVACUUM 
line 39759: return BTREE_AUTOVACUUM_NONE ; 
line 39760: # else 
line 39761: int rc ; 
line 39762: sqlite3BtreeEnter ( p ) ; 
line 39763: rc = ( 
line 39764: ( ! p -> pBt -> autoVacuum ) ? BTREE_AUTOVACUUM_NONE : 
line 39765: ( ! p -> pBt -> incrVacuum ) ? BTREE_AUTOVACUUM_FULL : 
line 39766: BTREE_AUTOVACUUM_INCR 
line 39767: ) ; 
line 39768: sqlite3BtreeLeave ( p ) ; 
line 39769: return rc ; 
line 39770: # endif 
line 39771: } 
line 39783: static int lockBtree ( BtShared * pBt ) { 
line 39784: int rc ; 
line 39785: MemPage * pPage1 ; 
line 39786: int nPage ; 
line 39788: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 39789: assert ( pBt -> pPage1 == 0 ) ; 
line 39790: rc = sqlite3PagerSharedLock ( pBt -> pPager ) ; 
line 39791: if ( rc != SQLITE_OK ) return rc ; 
line 39792: rc = btreeGetPage ( pBt , 1 , & pPage1 , 0 ) ; 
line 39793: if ( rc != SQLITE_OK ) return rc ; 
line 39798: rc = sqlite3PagerPagecount ( pBt -> pPager , & nPage ) ; 
line 39799: if ( rc != SQLITE_OK ) { 
line 39800: goto page1_init_failed ; 
line 39801: } else if ( nPage > 0 ) { 
line 39802: int pageSize ; 
line 39803: int usableSize ; 
line 39804: u8 * page1 = pPage1 -> aData ; 
line 39805: rc = SQLITE_NOTADB ; 
line 39806: if ( memcmp ( page1 , zMagicHeader , 16 ) != 0 ) { 
line 39807: goto page1_init_failed ; 
line 39808: } 
line 39809: if ( page1 [ 18 ] > 1 ) { 
line 39810: pBt -> readOnly = 1 ; 
line 39811: } 
line 39812: if ( page1 [ 19 ] > 1 ) { 
line 39813: goto page1_init_failed ; 
line 39814: } 
line 39821: if ( memcmp ( & page1 [ 21 ] , "\100\040\040" , 3 ) != 0 ) { 
line 39822: goto page1_init_failed ; 
line 39823: } 
line 39824: pageSize = get2byte ( & page1 [ 16 ] ) ; 
line 39825: if ( ( ( pageSize - 1 ) & pageSize ) != 0 || pageSize < 512 || 
line 39826: ( SQLITE_MAX_PAGE_SIZE < 32768 && pageSize > SQLITE_MAX_PAGE_SIZE ) 
line 39827: ) { 
line 39828: goto page1_init_failed ; 
line 39829: } 
line 39830: assert ( ( pageSize & 7 ) == 0 ) ; 
line 39831: usableSize = pageSize - page1 [ 20 ] ; 
line 39832: if ( pageSize != pBt -> pageSize ) { 
line 39839: releasePage ( pPage1 ) ; 
line 39840: pBt -> usableSize = ( u16 ) usableSize ; 
line 39841: pBt -> pageSize = ( u16 ) pageSize ; 
line 39842: freeTempSpace ( pBt ) ; 
line 39843: rc = sqlite3PagerSetPagesize ( pBt -> pPager , & pBt -> pageSize , 
line 39844: pageSize - usableSize ) ; 
line 39845: return rc ; 
line 39846: } 
line 39847: if ( usableSize < 480 ) { 
line 39848: goto page1_init_failed ; 
line 39849: } 
line 39850: pBt -> pageSize = ( u16 ) pageSize ; 
line 39851: pBt -> usableSize = ( u16 ) usableSize ; 
line 39852: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 39853: pBt -> autoVacuum = ( get4byte ( & page1 [ 36 + 4 * 4 ] ) ? 1 : 0 ) ; 
line 39854: pBt -> incrVacuum = ( get4byte ( & page1 [ 36 + 7 * 4 ] ) ? 1 : 0 ) ; 
line 39855: # endif 
line 39856: } 
line 39871: pBt -> maxLocal = ( pBt -> usableSize - 12 ) * 64 / 255 - 23 ; 
line 39872: pBt -> minLocal = ( pBt -> usableSize - 12 ) * 32 / 255 - 23 ; 
line 39873: pBt -> maxLeaf = pBt -> usableSize - 35 ; 
line 39874: pBt -> minLeaf = ( pBt -> usableSize - 12 ) * 32 / 255 - 23 ; 
line 39875: assert ( pBt -> maxLeaf + 23 <= MX_CELL_SIZE ( pBt ) ) ; 
line 39876: pBt -> pPage1 = pPage1 ; 
line 39877: return SQLITE_OK ; 
line 39879: page1_init_failed : 
line 39880: releasePage ( pPage1 ) ; 
line 39881: pBt -> pPage1 = 0 ; 
line 39882: return rc ; 
line 39883: } 
line 39893: static void unlockBtreeIfUnused ( BtShared * pBt ) { 
line 39894: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 39895: assert ( pBt -> pCursor == 0 || pBt -> inTransaction > TRANS_NONE ) ; 
line 39896: if ( pBt -> inTransaction == TRANS_NONE && pBt -> pPage1 != 0 ) { 
line 39897: assert ( pBt -> pPage1 -> aData ) ; 
line 39898: assert ( sqlite3PagerRefcount ( pBt -> pPager ) == 1 ) ; 
line 39899: assert ( pBt -> pPage1 -> aData ) ; 
line 39900: releasePage ( pBt -> pPage1 ) ; 
line 39901: pBt -> pPage1 = 0 ; 
line 39902: } 
line 39903: } 
line 39910: static int newDatabase ( BtShared * pBt ) { 
line 39911: MemPage * pP1 ; 
line 39912: unsigned char * data ; 
line 39913: int rc ; 
line 39914: int nPage ; 
line 39916: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 39917: rc = sqlite3PagerPagecount ( pBt -> pPager , & nPage ) ; 
line 39918: if ( rc != SQLITE_OK || nPage > 0 ) { 
line 39919: return rc ; 
line 39920: } 
line 39921: pP1 = pBt -> pPage1 ; 
line 39922: assert ( pP1 != 0 ) ; 
line 39923: data = pP1 -> aData ; 
line 39924: rc = sqlite3PagerWrite ( pP1 -> pDbPage ) ; 
line 39925: if ( rc ) return rc ; 
line 39926: memcpy ( data , zMagicHeader , sizeof ( zMagicHeader ) ) ; 
line 39927: assert ( sizeof ( zMagicHeader ) == 16 ) ; 
line 39928: put2byte ( & data [ 16 ] , pBt -> pageSize ) ; 
line 39929: data [ 18 ] = 1 ; 
line 39930: data [ 19 ] = 1 ; 
line 39931: assert ( pBt -> usableSize <= pBt -> pageSize && pBt -> usableSize + 255 >= pBt -> pageSize ) ; 
line 39932: data [ 20 ] = ( u8 ) ( pBt -> pageSize - pBt -> usableSize ) ; 
line 39933: data [ 21 ] = 64 ; 
line 39934: data [ 22 ] = 32 ; 
line 39935: data [ 23 ] = 32 ; 
line 39936: memset ( & data [ 24 ] , 0 , 100 - 24 ) ; 
line 39937: zeroPage ( pP1 , PTF_INTKEY | PTF_LEAF | PTF_LEAFDATA ) ; 
line 39938: pBt -> pageSizeFixed = 1 ; 
line 39939: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 39940: assert ( pBt -> autoVacuum == 1 || pBt -> autoVacuum == 0 ) ; 
line 39941: assert ( pBt -> incrVacuum == 1 || pBt -> incrVacuum == 0 ) ; 
line 39942: put4byte ( & data [ 36 + 4 * 4 ] , pBt -> autoVacuum ) ; 
line 39943: put4byte ( & data [ 36 + 7 * 4 ] , pBt -> incrVacuum ) ; 
line 39944: # endif 
line 39945: return SQLITE_OK ; 
line 39946: } 
line 39983: SQLITE_PRIVATE int sqlite3BtreeBeginTrans ( Btree * p , int wrflag ) { 
line 39984: sqlite3 * pBlock = 0 ; 
line 39985: BtShared * pBt = p -> pBt ; 
line 39986: int rc = SQLITE_OK ; 
line 39988: sqlite3BtreeEnter ( p ) ; 
line 39989: btreeIntegrity ( p ) ; 
line 39995: if ( p -> inTrans == TRANS_WRITE || ( p -> inTrans == TRANS_READ && ! wrflag ) ) { 
line 39996: goto trans_begun ; 
line 39997: } 
line 40000: if ( pBt -> readOnly && wrflag ) { 
line 40001: rc = SQLITE_READONLY ; 
line 40002: goto trans_begun ; 
line 40003: } 
line 40005: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 40010: if ( ( wrflag && pBt -> inTransaction == TRANS_WRITE ) || pBt -> isPending ) { 
line 40011: pBlock = pBt -> pWriter -> db ; 
line 40012: } else if ( wrflag > 1 ) { 
line 40013: BtLock * pIter ; 
line 40014: for ( pIter = pBt -> pLock ; pIter ; pIter = pIter -> pNext ) { 
line 40015: if ( pIter -> pBtree != p ) { 
line 40016: pBlock = pIter -> pBtree -> db ; 
line 40017: break ; 
line 40018: } 
line 40019: } 
line 40020: } 
line 40021: if ( pBlock ) { 
line 40022: sqlite3ConnectionBlocked ( p -> db , pBlock ) ; 
line 40023: rc = SQLITE_LOCKED_SHAREDCACHE ; 
line 40024: goto trans_begun ; 
line 40025: } 
line 40026: # endif 
line 40031: rc = querySharedCacheTableLock ( p , MASTER_ROOT , READ_LOCK ) ; 
line 40032: if ( SQLITE_OK != rc ) goto trans_begun ; 
line 40034: do { 
line 40042: while ( pBt -> pPage1 == 0 && SQLITE_OK == ( rc = lockBtree ( pBt ) ) ) ; 
line 40044: if ( rc == SQLITE_OK && wrflag ) { 
line 40045: if ( pBt -> readOnly ) { 
line 40046: rc = SQLITE_READONLY ; 
line 40047: } else { 
line 40048: rc = sqlite3PagerBegin ( pBt -> pPager , wrflag > 1 , sqlite3TempInMemory ( p -> db ) ) ; 
line 40049: if ( rc == SQLITE_OK ) { 
line 40050: rc = newDatabase ( pBt ) ; 
line 40051: } 
line 40052: } 
line 40053: } 
line 40055: if ( rc != SQLITE_OK ) { 
line 40056: unlockBtreeIfUnused ( pBt ) ; 
line 40057: } 
line 40058: } while ( rc == SQLITE_BUSY && pBt -> inTransaction == TRANS_NONE && 
line 40059: btreeInvokeBusyHandler ( pBt ) ) ; 
line 40061: if ( rc == SQLITE_OK ) { 
line 40062: if ( p -> inTrans == TRANS_NONE ) { 
line 40063: pBt -> nTransaction ++ ; 
line 40064: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 40065: if ( p -> sharable ) { 
line 40066: assert ( p -> lock . pBtree == p && p -> lock . iTable == 1 ) ; 
line 40067: p -> lock . eLock = READ_LOCK ; 
line 40068: p -> lock . pNext = pBt -> pLock ; 
line 40069: pBt -> pLock = & p -> lock ; 
line 40070: } 
line 40071: # endif 
line 40072: } 
line 40073: p -> inTrans = ( wrflag ? TRANS_WRITE : TRANS_READ ) ; 
line 40074: if ( p -> inTrans > pBt -> inTransaction ) { 
line 40075: pBt -> inTransaction = p -> inTrans ; 
line 40076: } 
line 40077: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 40078: if ( wrflag ) { 
line 40079: assert ( ! pBt -> pWriter ) ; 
line 40080: pBt -> pWriter = p ; 
line 40081: pBt -> isExclusive = ( u8 ) ( wrflag > 1 ) ; 
line 40082: } 
line 40083: # endif 
line 40084: } 
line 40087: trans_begun : 
line 40088: if ( rc == SQLITE_OK && wrflag ) { 
line 40093: rc = sqlite3PagerOpenSavepoint ( pBt -> pPager , p -> db -> nSavepoint ) ; 
line 40094: } 
line 40096: btreeIntegrity ( p ) ; 
line 40097: sqlite3BtreeLeave ( p ) ; 
line 40098: return rc ; 
line 40099: } 
line 40101: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 40108: static int setChildPtrmaps ( MemPage * pPage ) { 
line 40109: int i ; 
line 40110: int nCell ; 
line 40111: int rc ; 
line 40112: BtShared * pBt = pPage -> pBt ; 
line 40113: u8 isInitOrig = pPage -> isInit ; 
line 40114: Pgno pgno = pPage -> pgno ; 
line 40116: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 40117: rc = btreeInitPage ( pPage ) ; 
line 40118: if ( rc != SQLITE_OK ) { 
line 40119: goto set_child_ptrmaps_out ; 
line 40120: } 
line 40121: nCell = pPage -> nCell ; 
line 40123: for ( i = 0 ; i < nCell ; i ++ ) { 
line 40124: u8 * pCell = findCell ( pPage , i ) ; 
line 40126: ptrmapPutOvflPtr ( pPage , pCell , & rc ) ; 
line 40128: if ( ! pPage -> leaf ) { 
line 40129: Pgno childPgno = get4byte ( pCell ) ; 
line 40130: ptrmapPut ( pBt , childPgno , PTRMAP_BTREE , pgno , & rc ) ; 
line 40131: } 
line 40132: } 
line 40134: if ( ! pPage -> leaf ) { 
line 40135: Pgno childPgno = get4byte ( & pPage -> aData [ pPage -> hdrOffset + 8 ] ) ; 
line 40136: ptrmapPut ( pBt , childPgno , PTRMAP_BTREE , pgno , & rc ) ; 
line 40137: } 
line 40139: set_child_ptrmaps_out : 
line 40140: pPage -> isInit = isInitOrig ; 
line 40141: return rc ; 
line 40142: } 
line 40158: static int modifyPagePointer ( MemPage * pPage , Pgno iFrom , Pgno iTo , u8 eType ) { 
line 40159: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 40160: assert ( sqlite3PagerIswriteable ( pPage -> pDbPage ) ) ; 
line 40161: if ( eType == PTRMAP_OVERFLOW2 ) { 
line 40163: if ( get4byte ( pPage -> aData ) != iFrom ) { 
line 40164: return SQLITE_CORRUPT_BKPT ; 
line 40165: } 
line 40166: put4byte ( pPage -> aData , iTo ) ; 
line 40167: } else { 
line 40168: u8 isInitOrig = pPage -> isInit ; 
line 40169: int i ; 
line 40170: int nCell ; 
line 40172: btreeInitPage ( pPage ) ; 
line 40173: nCell = pPage -> nCell ; 
line 40175: for ( i = 0 ; i < nCell ; i ++ ) { 
line 40176: u8 * pCell = findCell ( pPage , i ) ; 
line 40177: if ( eType == PTRMAP_OVERFLOW1 ) { 
line 40178: CellInfo info ; 
line 40179: btreeParseCellPtr ( pPage , pCell , & info ) ; 
line 40180: if ( info . iOverflow ) { 
line 40181: if ( iFrom == get4byte ( & pCell [ info . iOverflow ] ) ) { 
line 40182: put4byte ( & pCell [ info . iOverflow ] , iTo ) ; 
line 40183: break ; 
line 40184: } 
line 40185: } 
line 40186: } else { 
line 40187: if ( get4byte ( pCell ) == iFrom ) { 
line 40188: put4byte ( pCell , iTo ) ; 
line 40189: break ; 
line 40190: } 
line 40191: } 
line 40192: } 
line 40194: if ( i == nCell ) { 
line 40195: if ( eType != PTRMAP_BTREE || 
line 40196: get4byte ( & pPage -> aData [ pPage -> hdrOffset + 8 ] ) != iFrom ) { 
line 40197: return SQLITE_CORRUPT_BKPT ; 
line 40198: } 
line 40199: put4byte ( & pPage -> aData [ pPage -> hdrOffset + 8 ] , iTo ) ; 
line 40200: } 
line 40202: pPage -> isInit = isInitOrig ; 
line 40203: } 
line 40204: return SQLITE_OK ; 
line 40205: } 
line 40217: static int relocatePage ( 
line 40218: BtShared * pBt , 
line 40219: MemPage * pDbPage , 
line 40220: u8 eType , 
line 40221: Pgno iPtrPage , 
line 40222: Pgno iFreePage , 
line 40223: int isCommit 
line 40224: ) { 
line 40225: MemPage * pPtrPage ; 
line 40226: Pgno iDbPage = pDbPage -> pgno ; 
line 40227: Pager * pPager = pBt -> pPager ; 
line 40228: int rc ; 
line 40230: assert ( eType == PTRMAP_OVERFLOW2 || eType == PTRMAP_OVERFLOW1 || 
line 40231: eType == PTRMAP_BTREE || eType == PTRMAP_ROOTPAGE ) ; 
line 40232: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 40233: assert ( pDbPage -> pBt == pBt ) ; 
line 40236: TRACE ( ( "AUTOVACUUM: Moving %d to free page %d (ptr page %d type %d)\n" , 
line 40237: iDbPage , iFreePage , iPtrPage , eType ) ) ; 
line 40238: rc = sqlite3PagerMovepage ( pPager , pDbPage -> pDbPage , iFreePage , isCommit ) ; 
line 40239: if ( rc != SQLITE_OK ) { 
line 40240: return rc ; 
line 40241: } 
line 40242: pDbPage -> pgno = iFreePage ; 
line 40252: if ( eType == PTRMAP_BTREE || eType == PTRMAP_ROOTPAGE ) { 
line 40253: rc = setChildPtrmaps ( pDbPage ) ; 
line 40254: if ( rc != SQLITE_OK ) { 
line 40255: return rc ; 
line 40256: } 
line 40257: } else { 
line 40258: Pgno nextOvfl = get4byte ( pDbPage -> aData ) ; 
line 40259: if ( nextOvfl != 0 ) { 
line 40260: ptrmapPut ( pBt , nextOvfl , PTRMAP_OVERFLOW2 , iFreePage , & rc ) ; 
line 40261: if ( rc != SQLITE_OK ) { 
line 40262: return rc ; 
line 40263: } 
line 40264: } 
line 40265: } 
line 40271: if ( eType != PTRMAP_ROOTPAGE ) { 
line 40272: rc = btreeGetPage ( pBt , iPtrPage , & pPtrPage , 0 ) ; 
line 40273: if ( rc != SQLITE_OK ) { 
line 40274: return rc ; 
line 40275: } 
line 40276: rc = sqlite3PagerWrite ( pPtrPage -> pDbPage ) ; 
line 40277: if ( rc != SQLITE_OK ) { 
line 40278: releasePage ( pPtrPage ) ; 
line 40279: return rc ; 
line 40280: } 
line 40281: rc = modifyPagePointer ( pPtrPage , iDbPage , iFreePage , eType ) ; 
line 40282: releasePage ( pPtrPage ) ; 
line 40283: if ( rc == SQLITE_OK ) { 
line 40284: ptrmapPut ( pBt , iFreePage , eType , iPtrPage , & rc ) ; 
line 40285: } 
line 40286: } 
line 40287: return rc ; 
line 40288: } 
line 40291: static int allocateBtreePage ( BtShared * , MemPage * * , Pgno * , Pgno , u8 ) ; 
line 40311: static int incrVacuumStep ( BtShared * pBt , Pgno nFin , Pgno iLastPg ) { 
line 40312: Pgno nFreeList ; 
line 40314: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 40315: assert ( iLastPg > nFin ) ; 
line 40317: if ( ! PTRMAP_ISPAGE ( pBt , iLastPg ) && iLastPg != PENDING_BYTE_PAGE ( pBt ) ) { 
line 40318: int rc ; 
line 40319: u8 eType ; 
line 40320: Pgno iPtrPage ; 
line 40322: nFreeList = get4byte ( & pBt -> pPage1 -> aData [ 36 ] ) ; 
line 40323: if ( nFreeList == 0 ) { 
line 40324: return SQLITE_DONE ; 
line 40325: } 
line 40327: rc = ptrmapGet ( pBt , iLastPg , & eType , & iPtrPage ) ; 
line 40328: if ( rc != SQLITE_OK ) { 
line 40329: return rc ; 
line 40330: } 
line 40331: if ( eType == PTRMAP_ROOTPAGE ) { 
line 40332: return SQLITE_CORRUPT_BKPT ; 
line 40333: } 
line 40335: if ( eType == PTRMAP_FREEPAGE ) { 
line 40336: if ( nFin == 0 ) { 
line 40342: Pgno iFreePg ; 
line 40343: MemPage * pFreePg ; 
line 40344: rc = allocateBtreePage ( pBt , & pFreePg , & iFreePg , iLastPg , 1 ) ; 
line 40345: if ( rc != SQLITE_OK ) { 
line 40346: return rc ; 
line 40347: } 
line 40348: assert ( iFreePg == iLastPg ) ; 
line 40349: releasePage ( pFreePg ) ; 
line 40350: } 
line 40351: } else { 
line 40352: Pgno iFreePg ; 
line 40353: MemPage * pLastPg ; 
line 40355: rc = btreeGetPage ( pBt , iLastPg , & pLastPg , 0 ) ; 
line 40356: if ( rc != SQLITE_OK ) { 
line 40357: return rc ; 
line 40358: } 
line 40367: do { 
line 40368: MemPage * pFreePg ; 
line 40369: rc = allocateBtreePage ( pBt , & pFreePg , & iFreePg , 0 , 0 ) ; 
line 40370: if ( rc != SQLITE_OK ) { 
line 40371: releasePage ( pLastPg ) ; 
line 40372: return rc ; 
line 40373: } 
line 40374: releasePage ( pFreePg ) ; 
line 40375: } while ( nFin != 0 && iFreePg > nFin ) ; 
line 40376: assert ( iFreePg < iLastPg ) ; 
line 40378: rc = sqlite3PagerWrite ( pLastPg -> pDbPage ) ; 
line 40379: if ( rc == SQLITE_OK ) { 
line 40380: rc = relocatePage ( pBt , pLastPg , eType , iPtrPage , iFreePg , nFin != 0 ) ; 
line 40381: } 
line 40382: releasePage ( pLastPg ) ; 
line 40383: if ( rc != SQLITE_OK ) { 
line 40384: return rc ; 
line 40385: } 
line 40386: } 
line 40387: } 
line 40389: if ( nFin == 0 ) { 
line 40390: iLastPg -- ; 
line 40391: while ( iLastPg == PENDING_BYTE_PAGE ( pBt ) || PTRMAP_ISPAGE ( pBt , iLastPg ) ) { 
line 40392: if ( PTRMAP_ISPAGE ( pBt , iLastPg ) ) { 
line 40393: MemPage * pPg ; 
line 40394: int rc = btreeGetPage ( pBt , iLastPg , & pPg , 0 ) ; 
line 40395: if ( rc != SQLITE_OK ) { 
line 40396: return rc ; 
line 40397: } 
line 40398: rc = sqlite3PagerWrite ( pPg -> pDbPage ) ; 
line 40399: releasePage ( pPg ) ; 
line 40400: if ( rc != SQLITE_OK ) { 
line 40401: return rc ; 
line 40402: } 
line 40403: } 
line 40404: iLastPg -- ; 
line 40405: } 
line 40406: sqlite3PagerTruncateImage ( pBt -> pPager , iLastPg ) ; 
line 40407: } 
line 40408: return SQLITE_OK ; 
line 40409: } 
line 40419: SQLITE_PRIVATE int sqlite3BtreeIncrVacuum ( Btree * p ) { 
line 40420: int rc ; 
line 40421: BtShared * pBt = p -> pBt ; 
line 40423: sqlite3BtreeEnter ( p ) ; 
line 40424: assert ( pBt -> inTransaction == TRANS_WRITE && p -> inTrans == TRANS_WRITE ) ; 
line 40425: if ( ! pBt -> autoVacuum ) { 
line 40426: rc = SQLITE_DONE ; 
line 40427: } else { 
line 40428: invalidateAllOverflowCache ( pBt ) ; 
line 40429: rc = incrVacuumStep ( pBt , 0 , pagerPagecount ( pBt ) ) ; 
line 40430: } 
line 40431: sqlite3BtreeLeave ( p ) ; 
line 40432: return rc ; 
line 40433: } 
line 40444: static int autoVacuumCommit ( BtShared * pBt ) { 
line 40445: int rc = SQLITE_OK ; 
line 40446: Pager * pPager = pBt -> pPager ; 
line 40447: VVA_ONLY ( int nRef = sqlite3PagerRefcount ( pPager ) ) ; 
line 40449: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 40450: invalidateAllOverflowCache ( pBt ) ; 
line 40451: assert ( pBt -> autoVacuum ) ; 
line 40452: if ( ! pBt -> incrVacuum ) { 
line 40453: Pgno nFin ; 
line 40454: Pgno nFree ; 
line 40455: Pgno nPtrmap ; 
line 40456: Pgno iFree ; 
line 40457: int nEntry ; 
line 40458: Pgno nOrig ; 
line 40460: nOrig = pagerPagecount ( pBt ) ; 
line 40461: if ( PTRMAP_ISPAGE ( pBt , nOrig ) || nOrig == PENDING_BYTE_PAGE ( pBt ) ) { 
line 40466: return SQLITE_CORRUPT_BKPT ; 
line 40467: } 
line 40469: nFree = get4byte ( & pBt -> pPage1 -> aData [ 36 ] ) ; 
line 40470: nEntry = pBt -> usableSize / 5 ; 
line 40471: nPtrmap = ( nFree - nOrig + PTRMAP_PAGENO ( pBt , nOrig ) + nEntry ) / nEntry ; 
line 40472: nFin = nOrig - nFree - nPtrmap ; 
line 40473: if ( nOrig > PENDING_BYTE_PAGE ( pBt ) && nFin < PENDING_BYTE_PAGE ( pBt ) ) { 
line 40474: nFin -- ; 
line 40475: } 
line 40476: while ( PTRMAP_ISPAGE ( pBt , nFin ) || nFin == PENDING_BYTE_PAGE ( pBt ) ) { 
line 40477: nFin -- ; 
line 40478: } 
line 40479: if ( nFin > nOrig ) return SQLITE_CORRUPT_BKPT ; 
line 40481: for ( iFree = nOrig ; iFree > nFin && rc == SQLITE_OK ; iFree -- ) { 
line 40482: rc = incrVacuumStep ( pBt , nFin , iFree ) ; 
line 40483: } 
line 40484: if ( ( rc == SQLITE_DONE || rc == SQLITE_OK ) && nFree > 0 ) { 
line 40485: rc = SQLITE_OK ; 
line 40486: rc = sqlite3PagerWrite ( pBt -> pPage1 -> pDbPage ) ; 
line 40487: put4byte ( & pBt -> pPage1 -> aData [ 32 ] , 0 ) ; 
line 40488: put4byte ( & pBt -> pPage1 -> aData [ 36 ] , 0 ) ; 
line 40489: sqlite3PagerTruncateImage ( pBt -> pPager , nFin ) ; 
line 40490: } 
line 40491: if ( rc != SQLITE_OK ) { 
line 40492: sqlite3PagerRollback ( pPager ) ; 
line 40493: } 
line 40494: } 
line 40496: assert ( nRef == sqlite3PagerRefcount ( pPager ) ) ; 
line 40497: return rc ; 
line 40498: } 
line 40500: # else 
line 40501: # define setChildPtrmaps ( x ) SQLITE_OK 
line 40502: # endif 
line 40530: SQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne ( Btree * p , const char * zMaster ) { 
line 40531: int rc = SQLITE_OK ; 
line 40532: if ( p -> inTrans == TRANS_WRITE ) { 
line 40533: BtShared * pBt = p -> pBt ; 
line 40534: sqlite3BtreeEnter ( p ) ; 
line 40535: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 40536: if ( pBt -> autoVacuum ) { 
line 40537: rc = autoVacuumCommit ( pBt ) ; 
line 40538: if ( rc != SQLITE_OK ) { 
line 40539: sqlite3BtreeLeave ( p ) ; 
line 40540: return rc ; 
line 40541: } 
line 40542: } 
line 40543: # endif 
line 40544: rc = sqlite3PagerCommitPhaseOne ( pBt -> pPager , zMaster , 0 ) ; 
line 40545: sqlite3BtreeLeave ( p ) ; 
line 40546: } 
line 40547: return rc ; 
line 40548: } 
line 40554: static void btreeEndTransaction ( Btree * p ) { 
line 40555: BtShared * pBt = p -> pBt ; 
line 40556: assert ( sqlite3BtreeHoldsMutex ( p ) ) ; 
line 40558: btreeClearHasContent ( pBt ) ; 
line 40559: if ( p -> inTrans > TRANS_NONE && p -> db -> activeVdbeCnt > 1 ) { 
line 40563: downgradeAllSharedCacheTableLocks ( p ) ; 
line 40564: p -> inTrans = TRANS_READ ; 
line 40565: } else { 
line 40570: if ( p -> inTrans != TRANS_NONE ) { 
line 40571: clearAllSharedCacheTableLocks ( p ) ; 
line 40572: pBt -> nTransaction -- ; 
line 40573: if ( 0 == pBt -> nTransaction ) { 
line 40574: pBt -> inTransaction = TRANS_NONE ; 
line 40575: } 
line 40576: } 
line 40580: p -> inTrans = TRANS_NONE ; 
line 40581: unlockBtreeIfUnused ( pBt ) ; 
line 40582: } 
line 40584: btreeIntegrity ( p ) ; 
line 40585: } 
line 40602: SQLITE_PRIVATE int sqlite3BtreeCommitPhaseTwo ( Btree * p ) { 
line 40603: BtShared * pBt = p -> pBt ; 
line 40605: sqlite3BtreeEnter ( p ) ; 
line 40606: btreeIntegrity ( p ) ; 
line 40611: if ( p -> inTrans == TRANS_WRITE ) { 
line 40612: int rc ; 
line 40613: assert ( pBt -> inTransaction == TRANS_WRITE ) ; 
line 40614: assert ( pBt -> nTransaction > 0 ) ; 
line 40615: rc = sqlite3PagerCommitPhaseTwo ( pBt -> pPager ) ; 
line 40616: if ( rc != SQLITE_OK ) { 
line 40617: sqlite3BtreeLeave ( p ) ; 
line 40618: return rc ; 
line 40619: } 
line 40620: pBt -> inTransaction = TRANS_READ ; 
line 40621: } 
line 40623: btreeEndTransaction ( p ) ; 
line 40624: sqlite3BtreeLeave ( p ) ; 
line 40625: return SQLITE_OK ; 
line 40626: } 
line 40631: SQLITE_PRIVATE int sqlite3BtreeCommit ( Btree * p ) { 
line 40632: int rc ; 
line 40633: sqlite3BtreeEnter ( p ) ; 
line 40634: rc = sqlite3BtreeCommitPhaseOne ( p , 0 ) ; 
line 40635: if ( rc == SQLITE_OK ) { 
line 40636: rc = sqlite3BtreeCommitPhaseTwo ( p ) ; 
line 40637: } 
line 40638: sqlite3BtreeLeave ( p ) ; 
line 40639: return rc ; 
line 40640: } 
line 40642: # ifndef NDEBUG 
line 40653: static int countWriteCursors ( BtShared * pBt ) { 
line 40654: BtCursor * pCur ; 
line 40655: int r = 0 ; 
line 40656: for ( pCur = pBt -> pCursor ; pCur ; pCur = pCur -> pNext ) { 
line 40657: if ( pCur -> wrFlag && pCur -> eState != CURSOR_FAULT ) r ++ ; 
line 40658: } 
line 40659: return r ; 
line 40660: } 
line 40661: # endif 
line 40680: SQLITE_PRIVATE void sqlite3BtreeTripAllCursors ( Btree * pBtree , int errCode ) { 
line 40681: BtCursor * p ; 
line 40682: sqlite3BtreeEnter ( pBtree ) ; 
line 40683: for ( p = pBtree -> pBt -> pCursor ; p ; p = p -> pNext ) { 
line 40684: int i ; 
line 40685: sqlite3BtreeClearCursor ( p ) ; 
line 40686: p -> eState = CURSOR_FAULT ; 
line 40687: p -> skipNext = errCode ; 
line 40688: for ( i = 0 ; i <= p -> iPage ; i ++ ) { 
line 40689: releasePage ( p -> apPage [ i ] ) ; 
line 40690: p -> apPage [ i ] = 0 ; 
line 40691: } 
line 40692: } 
line 40693: sqlite3BtreeLeave ( pBtree ) ; 
line 40694: } 
line 40705: SQLITE_PRIVATE int sqlite3BtreeRollback ( Btree * p ) { 
line 40706: int rc ; 
line 40707: BtShared * pBt = p -> pBt ; 
line 40708: MemPage * pPage1 ; 
line 40710: sqlite3BtreeEnter ( p ) ; 
line 40711: rc = saveAllCursors ( pBt , 0 , 0 ) ; 
line 40712: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 40713: if ( rc != SQLITE_OK ) { 
line 40721: sqlite3BtreeTripAllCursors ( p , rc ) ; 
line 40722: } 
line 40723: # endif 
line 40724: btreeIntegrity ( p ) ; 
line 40726: if ( p -> inTrans == TRANS_WRITE ) { 
line 40727: int rc2 ; 
line 40729: assert ( TRANS_WRITE == pBt -> inTransaction ) ; 
line 40730: rc2 = sqlite3PagerRollback ( pBt -> pPager ) ; 
line 40731: if ( rc2 != SQLITE_OK ) { 
line 40732: rc = rc2 ; 
line 40733: } 
line 40738: if ( btreeGetPage ( pBt , 1 , & pPage1 , 0 ) == SQLITE_OK ) { 
line 40739: releasePage ( pPage1 ) ; 
line 40740: } 
line 40741: assert ( countWriteCursors ( pBt ) == 0 ) ; 
line 40742: pBt -> inTransaction = TRANS_READ ; 
line 40743: } 
line 40745: btreeEndTransaction ( p ) ; 
line 40746: sqlite3BtreeLeave ( p ) ; 
line 40747: return rc ; 
line 40748: } 
line 40768: SQLITE_PRIVATE int sqlite3BtreeBeginStmt ( Btree * p , int iStatement ) { 
line 40769: int rc ; 
line 40770: BtShared * pBt = p -> pBt ; 
line 40771: sqlite3BtreeEnter ( p ) ; 
line 40772: assert ( p -> inTrans == TRANS_WRITE ) ; 
line 40773: assert ( pBt -> readOnly == 0 ) ; 
line 40774: assert ( iStatement > 0 ) ; 
line 40775: assert ( iStatement > p -> db -> nSavepoint ) ; 
line 40776: if ( NEVER ( p -> inTrans != TRANS_WRITE || pBt -> readOnly ) ) { 
line 40777: rc = SQLITE_INTERNAL ; 
line 40778: } else { 
line 40779: assert ( pBt -> inTransaction == TRANS_WRITE ) ; 
line 40785: rc = sqlite3PagerOpenSavepoint ( pBt -> pPager , iStatement ) ; 
line 40786: } 
line 40787: sqlite3BtreeLeave ( p ) ; 
line 40788: return rc ; 
line 40789: } 
line 40803: SQLITE_PRIVATE int sqlite3BtreeSavepoint ( Btree * p , int op , int iSavepoint ) { 
line 40804: int rc = SQLITE_OK ; 
line 40805: if ( p && p -> inTrans == TRANS_WRITE ) { 
line 40806: BtShared * pBt = p -> pBt ; 
line 40807: assert ( op == SAVEPOINT_RELEASE || op == SAVEPOINT_ROLLBACK ) ; 
line 40808: assert ( iSavepoint >= 0 || ( iSavepoint == - 1 && op == SAVEPOINT_ROLLBACK ) ) ; 
line 40809: sqlite3BtreeEnter ( p ) ; 
line 40810: rc = sqlite3PagerSavepoint ( pBt -> pPager , op , iSavepoint ) ; 
line 40811: if ( rc == SQLITE_OK ) { 
line 40812: rc = newDatabase ( pBt ) ; 
line 40813: } 
line 40814: sqlite3BtreeLeave ( p ) ; 
line 40815: } 
line 40816: return rc ; 
line 40817: } 
line 40851: static int btreeCursor ( 
line 40852: Btree * p , 
line 40853: int iTable , 
line 40854: int wrFlag , 
line 40855: struct KeyInfo * pKeyInfo , 
line 40856: BtCursor * pCur 
line 40857: ) { 
line 40858: BtShared * pBt = p -> pBt ; 
line 40860: assert ( sqlite3BtreeHoldsMutex ( p ) ) ; 
line 40861: assert ( wrFlag == 0 || wrFlag == 1 ) ; 
line 40867: assert ( hasSharedCacheTableLock ( p , iTable , pKeyInfo != 0 , wrFlag + 1 ) ) ; 
line 40868: assert ( wrFlag == 0 || ! hasReadConflicts ( p , iTable ) ) ; 
line 40871: assert ( p -> inTrans > TRANS_NONE ) ; 
line 40872: assert ( wrFlag == 0 || p -> inTrans == TRANS_WRITE ) ; 
line 40873: assert ( pBt -> pPage1 && pBt -> pPage1 -> aData ) ; 
line 40875: if ( NEVER ( wrFlag && pBt -> readOnly ) ) { 
line 40876: return SQLITE_READONLY ; 
line 40877: } 
line 40878: if ( iTable == 1 && pagerPagecount ( pBt ) == 0 ) { 
line 40879: return SQLITE_EMPTY ; 
line 40880: } 
line 40884: pCur -> pgnoRoot = ( Pgno ) iTable ; 
line 40885: pCur -> iPage = - 1 ; 
line 40886: pCur -> pKeyInfo = pKeyInfo ; 
line 40887: pCur -> pBtree = p ; 
line 40888: pCur -> pBt = pBt ; 
line 40889: pCur -> wrFlag = ( u8 ) wrFlag ; 
line 40890: pCur -> pNext = pBt -> pCursor ; 
line 40891: if ( pCur -> pNext ) { 
line 40892: pCur -> pNext -> pPrev = pCur ; 
line 40893: } 
line 40894: pBt -> pCursor = pCur ; 
line 40895: pCur -> eState = CURSOR_INVALID ; 
line 40896: pCur -> cachedRowid = 0 ; 
line 40897: return SQLITE_OK ; 
line 40898: } 
line 40899: SQLITE_PRIVATE int sqlite3BtreeCursor ( 
line 40900: Btree * p , 
line 40901: int iTable , 
line 40902: int wrFlag , 
line 40903: struct KeyInfo * pKeyInfo , 
line 40904: BtCursor * pCur 
line 40905: ) { 
line 40906: int rc ; 
line 40907: sqlite3BtreeEnter ( p ) ; 
line 40908: rc = btreeCursor ( p , iTable , wrFlag , pKeyInfo , pCur ) ; 
line 40909: sqlite3BtreeLeave ( p ) ; 
line 40910: return rc ; 
line 40911: } 
line 40921: SQLITE_PRIVATE int sqlite3BtreeCursorSize ( void ) { 
line 40922: return ROUND8 ( sizeof ( BtCursor ) ) ; 
line 40923: } 
line 40933: SQLITE_PRIVATE void sqlite3BtreeCursorZero ( BtCursor * p ) { 
line 40934: memset ( p , 0 , offsetof ( BtCursor , iPage ) ) ; 
line 40935: } 
line 40949: SQLITE_PRIVATE void sqlite3BtreeSetCachedRowid ( BtCursor * pCur , sqlite3_int64 iRowid ) { 
line 40950: BtCursor * p ; 
line 40951: for ( p = pCur -> pBt -> pCursor ; p ; p = p -> pNext ) { 
line 40952: if ( p -> pgnoRoot == pCur -> pgnoRoot ) p -> cachedRowid = iRowid ; 
line 40953: } 
line 40954: assert ( pCur -> cachedRowid == iRowid ) ; 
line 40955: } 
line 40963: SQLITE_PRIVATE sqlite3_int64 sqlite3BtreeGetCachedRowid ( BtCursor * pCur ) { 
line 40964: return pCur -> cachedRowid ; 
line 40965: } 
line 40971: SQLITE_PRIVATE int sqlite3BtreeCloseCursor ( BtCursor * pCur ) { 
line 40972: Btree * pBtree = pCur -> pBtree ; 
line 40973: if ( pBtree ) { 
line 40974: int i ; 
line 40975: BtShared * pBt = pCur -> pBt ; 
line 40976: sqlite3BtreeEnter ( pBtree ) ; 
line 40977: sqlite3BtreeClearCursor ( pCur ) ; 
line 40978: if ( pCur -> pPrev ) { 
line 40979: pCur -> pPrev -> pNext = pCur -> pNext ; 
line 40980: } else { 
line 40981: pBt -> pCursor = pCur -> pNext ; 
line 40982: } 
line 40983: if ( pCur -> pNext ) { 
line 40984: pCur -> pNext -> pPrev = pCur -> pPrev ; 
line 40985: } 
line 40986: for ( i = 0 ; i <= pCur -> iPage ; i ++ ) { 
line 40987: releasePage ( pCur -> apPage [ i ] ) ; 
line 40988: } 
line 40989: unlockBtreeIfUnused ( pBt ) ; 
line 40990: invalidateOverflowCache ( pCur ) ; 
line 40992: sqlite3BtreeLeave ( pBtree ) ; 
line 40993: } 
line 40994: return SQLITE_OK ; 
line 40995: } 
line 41012: # ifndef NDEBUG 
line 41013: static void assertCellInfo ( BtCursor * pCur ) { 
line 41014: CellInfo info ; 
line 41015: int iPage = pCur -> iPage ; 
line 41016: memset ( & info , 0 , sizeof ( info ) ) ; 
line 41017: btreeParseCell ( pCur -> apPage [ iPage ] , pCur -> aiIdx [ iPage ] , & info ) ; 
line 41018: assert ( memcmp ( & info , & pCur -> info , sizeof ( info ) ) == 0 ) ; 
line 41019: } 
line 41020: # else 
line 41021: # define assertCellInfo ( x ) 
line 41022: # endif 
line 41023: # ifdef _MSC_VER 
line 41025: static void getCellInfo ( BtCursor * pCur ) { 
line 41026: if ( pCur -> info . nSize == 0 ) { 
line 41027: int iPage = pCur -> iPage ; 
line 41028: btreeParseCell ( pCur -> apPage [ iPage ] , pCur -> aiIdx [ iPage ] , & pCur -> info ) ; 
line 41029: pCur -> validNKey = 1 ; 
line 41030: } else { 
line 41031: assertCellInfo ( pCur ) ; 
line 41032: } 
line 41033: } 
line 41034: # else 
line 41036: # define getCellInfo ( pCur ) 
line 41037: if ( pCur -> info . nSize == 0 ) { 
line 41038: int iPage = pCur -> iPage ; 
line 41039: btreeParseCell ( pCur -> apPage [ iPage ] , pCur -> aiIdx [ iPage ] , & pCur -> info ) ; 
line 41040: pCur -> validNKey = 1 ; 
line 41041: } else { 
line 41042: assertCellInfo ( pCur ) ; 
line 41043: } 
line 41044: # endif 
line 41046: # ifndef NDEBUG 
line 41052: SQLITE_PRIVATE int sqlite3BtreeCursorIsValid ( BtCursor * pCur ) { 
line 41053: return pCur && pCur -> eState == CURSOR_VALID ; 
line 41054: } 
line 41055: # endif 
line 41069: SQLITE_PRIVATE int sqlite3BtreeKeySize ( BtCursor * pCur , i64 * pSize ) { 
line 41070: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41071: assert ( pCur -> eState == CURSOR_INVALID || pCur -> eState == CURSOR_VALID ) ; 
line 41072: if ( pCur -> eState != CURSOR_VALID ) { 
line 41073: * pSize = 0 ; 
line 41074: } else { 
line 41075: getCellInfo ( pCur ) ; 
line 41076: * pSize = pCur -> info . nKey ; 
line 41077: } 
line 41078: return SQLITE_OK ; 
line 41079: } 
line 41093: SQLITE_PRIVATE int sqlite3BtreeDataSize ( BtCursor * pCur , u32 * pSize ) { 
line 41094: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41095: assert ( pCur -> eState == CURSOR_VALID ) ; 
line 41096: getCellInfo ( pCur ) ; 
line 41097: * pSize = pCur -> info . nData ; 
line 41098: return SQLITE_OK ; 
line 41099: } 
line 41120: static int getOverflowPage ( 
line 41121: BtShared * pBt , 
line 41122: Pgno ovfl , 
line 41123: MemPage * * ppPage , 
line 41124: Pgno * pPgnoNext 
line 41125: ) { 
line 41126: Pgno next = 0 ; 
line 41127: MemPage * pPage = 0 ; 
line 41128: int rc = SQLITE_OK ; 
line 41130: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 41131: assert ( pPgnoNext ) ; 
line 41133: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 41140: if ( pBt -> autoVacuum ) { 
line 41141: Pgno pgno ; 
line 41142: Pgno iGuess = ovfl + 1 ; 
line 41143: u8 eType ; 
line 41145: while ( PTRMAP_ISPAGE ( pBt , iGuess ) || iGuess == PENDING_BYTE_PAGE ( pBt ) ) { 
line 41146: iGuess ++ ; 
line 41147: } 
line 41149: if ( iGuess <= pagerPagecount ( pBt ) ) { 
line 41150: rc = ptrmapGet ( pBt , iGuess , & eType , & pgno ) ; 
line 41151: if ( rc == SQLITE_OK && eType == PTRMAP_OVERFLOW2 && pgno == ovfl ) { 
line 41152: next = iGuess ; 
line 41153: rc = SQLITE_DONE ; 
line 41154: } 
line 41155: } 
line 41156: } 
line 41157: # endif 
line 41159: assert ( next == 0 || rc == SQLITE_DONE ) ; 
line 41160: if ( rc == SQLITE_OK ) { 
line 41161: rc = btreeGetPage ( pBt , ovfl , & pPage , 0 ) ; 
line 41162: assert ( rc == SQLITE_OK || pPage == 0 ) ; 
line 41163: if ( rc == SQLITE_OK ) { 
line 41164: next = get4byte ( pPage -> aData ) ; 
line 41165: } 
line 41166: } 
line 41168: * pPgnoNext = next ; 
line 41169: if ( ppPage ) { 
line 41170: * ppPage = pPage ; 
line 41171: } else { 
line 41172: releasePage ( pPage ) ; 
line 41173: } 
line 41174: return ( rc == SQLITE_DONE ? SQLITE_OK : rc ) ; 
line 41175: } 
line 41188: static int copyPayload ( 
line 41189: void * pPayload , 
line 41190: void * pBuf , 
line 41191: int nByte , 
line 41192: int eOp , 
line 41193: DbPage * pDbPage 
line 41194: ) { 
line 41195: if ( eOp ) { 
line 41197: int rc = sqlite3PagerWrite ( pDbPage ) ; 
line 41198: if ( rc != SQLITE_OK ) { 
line 41199: return rc ; 
line 41200: } 
line 41201: memcpy ( pPayload , pBuf , nByte ) ; 
line 41202: } else { 
line 41204: memcpy ( pBuf , pPayload , nByte ) ; 
line 41205: } 
line 41206: return SQLITE_OK ; 
line 41207: } 
line 41237: static int accessPayload ( 
line 41238: BtCursor * pCur , 
line 41239: u32 offset , 
line 41240: u32 amt , 
line 41241: unsigned char * pBuf , 
line 41242: int eOp 
line 41243: ) { 
line 41244: unsigned char * aPayload ; 
line 41245: int rc = SQLITE_OK ; 
line 41246: u32 nKey ; 
line 41247: int iIdx = 0 ; 
line 41248: MemPage * pPage = pCur -> apPage [ pCur -> iPage ] ; 
line 41249: BtShared * pBt = pCur -> pBt ; 
line 41251: assert ( pPage ) ; 
line 41252: assert ( pCur -> eState == CURSOR_VALID ) ; 
line 41253: assert ( pCur -> aiIdx [ pCur -> iPage ] < pPage -> nCell ) ; 
line 41254: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41256: getCellInfo ( pCur ) ; 
line 41257: aPayload = pCur -> info . pCell + pCur -> info . nHeader ; 
line 41258: nKey = ( pPage -> intKey ? 0 : ( int ) pCur -> info . nKey ) ; 
line 41260: if ( NEVER ( offset + amt > nKey + pCur -> info . nData ) 
line 41261: || & aPayload [ pCur -> info . nLocal ] > & pPage -> aData [ pBt -> usableSize ] 
line 41262: ) { 
line 41264: return SQLITE_CORRUPT_BKPT ; 
line 41265: } 
line 41268: if ( offset < pCur -> info . nLocal ) { 
line 41269: int a = amt ; 
line 41270: if ( a + offset > pCur -> info . nLocal ) { 
line 41271: a = pCur -> info . nLocal - offset ; 
line 41272: } 
line 41273: rc = copyPayload ( & aPayload [ offset ] , pBuf , a , eOp , pPage -> pDbPage ) ; 
line 41274: offset = 0 ; 
line 41275: pBuf += a ; 
line 41276: amt -= a ; 
line 41277: } else { 
line 41278: offset -= pCur -> info . nLocal ; 
line 41279: } 
line 41281: if ( rc == SQLITE_OK && amt > 0 ) { 
line 41282: const u32 ovflSize = pBt -> usableSize - 4 ; 
line 41283: Pgno nextPage ; 
line 41285: nextPage = get4byte ( & aPayload [ pCur -> info . nLocal ] ) ; 
line 41287: # ifndef SQLITE_OMIT_INCRBLOB 
line 41295: if ( pCur -> isIncrblobHandle && ! pCur -> aOverflow ) { 
line 41296: int nOvfl = ( pCur -> info . nPayload - pCur -> info . nLocal + ovflSize - 1 ) / ovflSize ; 
line 41297: pCur -> aOverflow = ( Pgno * ) sqlite3MallocZero ( sizeof ( Pgno ) * nOvfl ) ; 
line 41300: if ( ALWAYS ( nOvfl ) && ! pCur -> aOverflow ) { 
line 41301: rc = SQLITE_NOMEM ; 
line 41302: } 
line 41303: } 
line 41309: if ( pCur -> aOverflow && pCur -> aOverflow [ offset / ovflSize ] ) { 
line 41310: iIdx = ( offset / ovflSize ) ; 
line 41311: nextPage = pCur -> aOverflow [ iIdx ] ; 
line 41312: offset = ( offset % ovflSize ) ; 
line 41313: } 
line 41314: # endif 
line 41316: for ( ; rc == SQLITE_OK && amt > 0 && nextPage ; iIdx ++ ) { 
line 41318: # ifndef SQLITE_OMIT_INCRBLOB 
line 41320: if ( pCur -> aOverflow ) { 
line 41321: assert ( ! pCur -> aOverflow [ iIdx ] || pCur -> aOverflow [ iIdx ] == nextPage ) ; 
line 41322: pCur -> aOverflow [ iIdx ] = nextPage ; 
line 41323: } 
line 41324: # endif 
line 41326: if ( offset >= ovflSize ) { 
line 41333: # ifndef SQLITE_OMIT_INCRBLOB 
line 41334: if ( pCur -> aOverflow && pCur -> aOverflow [ iIdx + 1 ] ) { 
line 41335: nextPage = pCur -> aOverflow [ iIdx + 1 ] ; 
line 41336: } else 
line 41337: # endif 
line 41338: rc = getOverflowPage ( pBt , nextPage , 0 , & nextPage ) ; 
line 41339: offset -= ovflSize ; 
line 41340: } else { 
line 41344: DbPage * pDbPage ; 
line 41345: int a = amt ; 
line 41346: rc = sqlite3PagerGet ( pBt -> pPager , nextPage , & pDbPage ) ; 
line 41347: if ( rc == SQLITE_OK ) { 
line 41348: aPayload = sqlite3PagerGetData ( pDbPage ) ; 
line 41349: nextPage = get4byte ( aPayload ) ; 
line 41350: if ( a + offset > ovflSize ) { 
line 41351: a = ovflSize - offset ; 
line 41352: } 
line 41353: rc = copyPayload ( & aPayload [ offset + 4 ] , pBuf , a , eOp , pDbPage ) ; 
line 41354: sqlite3PagerUnref ( pDbPage ) ; 
line 41355: offset = 0 ; 
line 41356: amt -= a ; 
line 41357: pBuf += a ; 
line 41358: } 
line 41359: } 
line 41360: } 
line 41361: } 
line 41363: if ( rc == SQLITE_OK && amt > 0 ) { 
line 41364: return SQLITE_CORRUPT_BKPT ; 
line 41365: } 
line 41366: return rc ; 
line 41367: } 
line 41381: SQLITE_PRIVATE int sqlite3BtreeKey ( BtCursor * pCur , u32 offset , u32 amt , void * pBuf ) { 
line 41382: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41383: assert ( pCur -> eState == CURSOR_VALID ) ; 
line 41384: assert ( pCur -> iPage >= 0 && pCur -> apPage [ pCur -> iPage ] ) ; 
line 41385: assert ( pCur -> aiIdx [ pCur -> iPage ] < pCur -> apPage [ pCur -> iPage ] -> nCell ) ; 
line 41386: return accessPayload ( pCur , offset , amt , ( unsigned char * ) pBuf , 0 ) ; 
line 41387: } 
line 41398: SQLITE_PRIVATE int sqlite3BtreeData ( BtCursor * pCur , u32 offset , u32 amt , void * pBuf ) { 
line 41399: int rc ; 
line 41401: # ifndef SQLITE_OMIT_INCRBLOB 
line 41402: if ( pCur -> eState == CURSOR_INVALID ) { 
line 41403: return SQLITE_ABORT ; 
line 41404: } 
line 41405: # endif 
line 41407: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41408: rc = restoreCursorPosition ( pCur ) ; 
line 41409: if ( rc == SQLITE_OK ) { 
line 41410: assert ( pCur -> eState == CURSOR_VALID ) ; 
line 41411: assert ( pCur -> iPage >= 0 && pCur -> apPage [ pCur -> iPage ] ) ; 
line 41412: assert ( pCur -> aiIdx [ pCur -> iPage ] < pCur -> apPage [ pCur -> iPage ] -> nCell ) ; 
line 41413: rc = accessPayload ( pCur , offset , amt , pBuf , 0 ) ; 
line 41414: } 
line 41415: return rc ; 
line 41416: } 
line 41437: static const unsigned char * fetchPayload ( 
line 41438: BtCursor * pCur , 
line 41439: int * pAmt , 
line 41440: int skipKey 
line 41441: ) { 
line 41442: unsigned char * aPayload ; 
line 41443: MemPage * pPage ; 
line 41444: u32 nKey ; 
line 41445: u32 nLocal ; 
line 41447: assert ( pCur != 0 && pCur -> iPage >= 0 && pCur -> apPage [ pCur -> iPage ] ) ; 
line 41448: assert ( pCur -> eState == CURSOR_VALID ) ; 
line 41449: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41450: pPage = pCur -> apPage [ pCur -> iPage ] ; 
line 41451: assert ( pCur -> aiIdx [ pCur -> iPage ] < pPage -> nCell ) ; 
line 41452: if ( NEVER ( pCur -> info . nSize == 0 ) ) { 
line 41453: btreeParseCell ( pCur -> apPage [ pCur -> iPage ] , pCur -> aiIdx [ pCur -> iPage ] , 
line 41454: & pCur -> info ) ; 
line 41455: } 
line 41456: aPayload = pCur -> info . pCell ; 
line 41457: aPayload += pCur -> info . nHeader ; 
line 41458: if ( pPage -> intKey ) { 
line 41459: nKey = 0 ; 
line 41460: } else { 
line 41461: nKey = ( int ) pCur -> info . nKey ; 
line 41462: } 
line 41463: if ( skipKey ) { 
line 41464: aPayload += nKey ; 
line 41465: nLocal = pCur -> info . nLocal - nKey ; 
line 41466: } else { 
line 41467: nLocal = pCur -> info . nLocal ; 
line 41468: assert ( nLocal <= nKey ) ; 
line 41469: } 
line 41470: * pAmt = nLocal ; 
line 41471: return aPayload ; 
line 41472: } 
line 41489: SQLITE_PRIVATE const void * sqlite3BtreeKeyFetch ( BtCursor * pCur , int * pAmt ) { 
line 41490: const void * p = 0 ; 
line 41491: assert ( sqlite3_mutex_held ( pCur -> pBtree -> db -> mutex ) ) ; 
line 41492: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41493: if ( ALWAYS ( pCur -> eState == CURSOR_VALID ) ) { 
line 41494: p = ( const void * ) fetchPayload ( pCur , pAmt , 0 ) ; 
line 41495: } 
line 41496: return p ; 
line 41497: } 
line 41498: SQLITE_PRIVATE const void * sqlite3BtreeDataFetch ( BtCursor * pCur , int * pAmt ) { 
line 41499: const void * p = 0 ; 
line 41500: assert ( sqlite3_mutex_held ( pCur -> pBtree -> db -> mutex ) ) ; 
line 41501: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41502: if ( ALWAYS ( pCur -> eState == CURSOR_VALID ) ) { 
line 41503: p = ( const void * ) fetchPayload ( pCur , pAmt , 1 ) ; 
line 41504: } 
line 41505: return p ; 
line 41506: } 
line 41518: static int moveToChild ( BtCursor * pCur , u32 newPgno ) { 
line 41519: int rc ; 
line 41520: int i = pCur -> iPage ; 
line 41521: MemPage * pNewPage ; 
line 41522: BtShared * pBt = pCur -> pBt ; 
line 41524: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41525: assert ( pCur -> eState == CURSOR_VALID ) ; 
line 41526: assert ( pCur -> iPage < BTCURSOR_MAX_DEPTH ) ; 
line 41527: if ( pCur -> iPage >= ( BTCURSOR_MAX_DEPTH - 1 ) ) { 
line 41528: return SQLITE_CORRUPT_BKPT ; 
line 41529: } 
line 41530: rc = getAndInitPage ( pBt , newPgno , & pNewPage ) ; 
line 41531: if ( rc ) return rc ; 
line 41532: pCur -> apPage [ i + 1 ] = pNewPage ; 
line 41533: pCur -> aiIdx [ i + 1 ] = 0 ; 
line 41534: pCur -> iPage ++ ; 
line 41536: pCur -> info . nSize = 0 ; 
line 41537: pCur -> validNKey = 0 ; 
line 41538: if ( pNewPage -> nCell < 1 || pNewPage -> intKey != pCur -> apPage [ i ] -> intKey ) { 
line 41539: return SQLITE_CORRUPT_BKPT ; 
line 41540: } 
line 41541: return SQLITE_OK ; 
line 41542: } 
line 41544: # ifndef NDEBUG 
line 41552: static void assertParentIndex ( MemPage * pParent , int iIdx , Pgno iChild ) { 
line 41553: assert ( iIdx <= pParent -> nCell ) ; 
line 41554: if ( iIdx == pParent -> nCell ) { 
line 41555: assert ( get4byte ( & pParent -> aData [ pParent -> hdrOffset + 8 ] ) == iChild ) ; 
line 41556: } else { 
line 41557: assert ( get4byte ( findCell ( pParent , iIdx ) ) == iChild ) ; 
line 41558: } 
line 41559: } 
line 41560: # else 
line 41561: # define assertParentIndex ( x , y , z ) 
line 41562: # endif 
line 41572: static void moveToParent ( BtCursor * pCur ) { 
line 41573: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41574: assert ( pCur -> eState == CURSOR_VALID ) ; 
line 41575: assert ( pCur -> iPage > 0 ) ; 
line 41576: assert ( pCur -> apPage [ pCur -> iPage ] ) ; 
line 41577: assertParentIndex ( 
line 41578: pCur -> apPage [ pCur -> iPage - 1 ] , 
line 41579: pCur -> aiIdx [ pCur -> iPage - 1 ] , 
line 41580: pCur -> apPage [ pCur -> iPage ] -> pgno 
line 41581: ) ; 
line 41582: releasePage ( pCur -> apPage [ pCur -> iPage ] ) ; 
line 41583: pCur -> iPage -- ; 
line 41584: pCur -> info . nSize = 0 ; 
line 41585: pCur -> validNKey = 0 ; 
line 41586: } 
line 41609: static int moveToRoot ( BtCursor * pCur ) { 
line 41610: MemPage * pRoot ; 
line 41611: int rc = SQLITE_OK ; 
line 41612: Btree * p = pCur -> pBtree ; 
line 41613: BtShared * pBt = p -> pBt ; 
line 41615: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41616: assert ( CURSOR_INVALID < CURSOR_REQUIRESEEK ) ; 
line 41617: assert ( CURSOR_VALID < CURSOR_REQUIRESEEK ) ; 
line 41618: assert ( CURSOR_FAULT > CURSOR_REQUIRESEEK ) ; 
line 41619: if ( pCur -> eState >= CURSOR_REQUIRESEEK ) { 
line 41620: if ( pCur -> eState == CURSOR_FAULT ) { 
line 41621: assert ( pCur -> skipNext != SQLITE_OK ) ; 
line 41622: return pCur -> skipNext ; 
line 41623: } 
line 41624: sqlite3BtreeClearCursor ( pCur ) ; 
line 41625: } 
line 41627: if ( pCur -> iPage >= 0 ) { 
line 41628: int i ; 
line 41629: for ( i = 1 ; i <= pCur -> iPage ; i ++ ) { 
line 41630: releasePage ( pCur -> apPage [ i ] ) ; 
line 41631: } 
line 41632: pCur -> iPage = 0 ; 
line 41633: } else { 
line 41634: rc = getAndInitPage ( pBt , pCur -> pgnoRoot , & pCur -> apPage [ 0 ] ) ; 
line 41635: if ( rc != SQLITE_OK ) { 
line 41636: pCur -> eState = CURSOR_INVALID ; 
line 41637: return rc ; 
line 41638: } 
line 41639: pCur -> iPage = 0 ; 
line 41645: assert ( pCur -> apPage [ 0 ] -> intKey == 1 || pCur -> apPage [ 0 ] -> intKey == 0 ) ; 
line 41646: if ( ( pCur -> pKeyInfo == 0 ) != pCur -> apPage [ 0 ] -> intKey ) { 
line 41647: return SQLITE_CORRUPT_BKPT ; 
line 41648: } 
line 41649: } 
line 41657: pRoot = pCur -> apPage [ 0 ] ; 
line 41658: assert ( pRoot -> pgno == pCur -> pgnoRoot ) ; 
line 41659: assert ( pRoot -> isInit && ( pCur -> pKeyInfo == 0 ) == pRoot -> intKey ) ; 
line 41661: pCur -> aiIdx [ 0 ] = 0 ; 
line 41662: pCur -> info . nSize = 0 ; 
line 41663: pCur -> atLast = 0 ; 
line 41664: pCur -> validNKey = 0 ; 
line 41666: if ( pRoot -> nCell == 0 && ! pRoot -> leaf ) { 
line 41667: Pgno subpage ; 
line 41668: if ( pRoot -> pgno != 1 ) return SQLITE_CORRUPT_BKPT ; 
line 41669: subpage = get4byte ( & pRoot -> aData [ pRoot -> hdrOffset + 8 ] ) ; 
line 41670: pCur -> eState = CURSOR_VALID ; 
line 41671: rc = moveToChild ( pCur , subpage ) ; 
line 41672: } else { 
line 41673: pCur -> eState = ( ( pRoot -> nCell > 0 ) ? CURSOR_VALID : CURSOR_INVALID ) ; 
line 41674: } 
line 41675: return rc ; 
line 41676: } 
line 41685: static int moveToLeftmost ( BtCursor * pCur ) { 
line 41686: Pgno pgno ; 
line 41687: int rc = SQLITE_OK ; 
line 41688: MemPage * pPage ; 
line 41690: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41691: assert ( pCur -> eState == CURSOR_VALID ) ; 
line 41692: while ( rc == SQLITE_OK && ! ( pPage = pCur -> apPage [ pCur -> iPage ] ) -> leaf ) { 
line 41693: assert ( pCur -> aiIdx [ pCur -> iPage ] < pPage -> nCell ) ; 
line 41694: pgno = get4byte ( findCell ( pPage , pCur -> aiIdx [ pCur -> iPage ] ) ) ; 
line 41695: rc = moveToChild ( pCur , pgno ) ; 
line 41696: } 
line 41697: return rc ; 
line 41698: } 
line 41710: static int moveToRightmost ( BtCursor * pCur ) { 
line 41711: Pgno pgno ; 
line 41712: int rc = SQLITE_OK ; 
line 41713: MemPage * pPage = 0 ; 
line 41715: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41716: assert ( pCur -> eState == CURSOR_VALID ) ; 
line 41717: while ( rc == SQLITE_OK && ! ( pPage = pCur -> apPage [ pCur -> iPage ] ) -> leaf ) { 
line 41718: pgno = get4byte ( & pPage -> aData [ pPage -> hdrOffset + 8 ] ) ; 
line 41719: pCur -> aiIdx [ pCur -> iPage ] = pPage -> nCell ; 
line 41720: rc = moveToChild ( pCur , pgno ) ; 
line 41721: } 
line 41722: if ( rc == SQLITE_OK ) { 
line 41723: pCur -> aiIdx [ pCur -> iPage ] = pPage -> nCell - 1 ; 
line 41724: pCur -> info . nSize = 0 ; 
line 41725: pCur -> validNKey = 0 ; 
line 41726: } 
line 41727: return rc ; 
line 41728: } 
line 41734: SQLITE_PRIVATE int sqlite3BtreeFirst ( BtCursor * pCur , int * pRes ) { 
line 41735: int rc ; 
line 41737: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41738: assert ( sqlite3_mutex_held ( pCur -> pBtree -> db -> mutex ) ) ; 
line 41739: rc = moveToRoot ( pCur ) ; 
line 41740: if ( rc == SQLITE_OK ) { 
line 41741: if ( pCur -> eState == CURSOR_INVALID ) { 
line 41742: assert ( pCur -> apPage [ pCur -> iPage ] -> nCell == 0 ) ; 
line 41743: * pRes = 1 ; 
line 41744: rc = SQLITE_OK ; 
line 41745: } else { 
line 41746: assert ( pCur -> apPage [ pCur -> iPage ] -> nCell > 0 ) ; 
line 41747: * pRes = 0 ; 
line 41748: rc = moveToLeftmost ( pCur ) ; 
line 41749: } 
line 41750: } 
line 41751: return rc ; 
line 41752: } 
line 41758: SQLITE_PRIVATE int sqlite3BtreeLast ( BtCursor * pCur , int * pRes ) { 
line 41759: int rc ; 
line 41761: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41762: assert ( sqlite3_mutex_held ( pCur -> pBtree -> db -> mutex ) ) ; 
line 41765: if ( CURSOR_VALID == pCur -> eState && pCur -> atLast ) { 
line 41766: # ifdef SQLITE_DEBUG 
line 41769: int ii ; 
line 41770: for ( ii = 0 ; ii < pCur -> iPage ; ii ++ ) { 
line 41771: assert ( pCur -> aiIdx [ ii ] == pCur -> apPage [ ii ] -> nCell ) ; 
line 41772: } 
line 41773: assert ( pCur -> aiIdx [ pCur -> iPage ] == pCur -> apPage [ pCur -> iPage ] -> nCell - 1 ) ; 
line 41774: assert ( pCur -> apPage [ pCur -> iPage ] -> leaf ) ; 
line 41775: # endif 
line 41776: return SQLITE_OK ; 
line 41777: } 
line 41779: rc = moveToRoot ( pCur ) ; 
line 41780: if ( rc == SQLITE_OK ) { 
line 41781: if ( CURSOR_INVALID == pCur -> eState ) { 
line 41782: assert ( pCur -> apPage [ pCur -> iPage ] -> nCell == 0 ) ; 
line 41783: * pRes = 1 ; 
line 41784: } else { 
line 41785: assert ( pCur -> eState == CURSOR_VALID ) ; 
line 41786: * pRes = 0 ; 
line 41787: rc = moveToRightmost ( pCur ) ; 
line 41788: pCur -> atLast = rc == SQLITE_OK ? 1 : 0 ; 
line 41789: } 
line 41790: } 
line 41791: return rc ; 
line 41792: } 
line 41822: SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked ( 
line 41823: BtCursor * pCur , 
line 41824: UnpackedRecord * pIdxKey , 
line 41825: i64 intKey , 
line 41826: int biasRight , 
line 41827: int * pRes 
line 41828: ) { 
line 41829: int rc ; 
line 41831: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 41832: assert ( sqlite3_mutex_held ( pCur -> pBtree -> db -> mutex ) ) ; 
line 41833: assert ( pRes ) ; 
line 41834: assert ( ( pIdxKey == 0 ) == ( pCur -> pKeyInfo == 0 ) ) ; 
line 41838: if ( pCur -> eState == CURSOR_VALID && pCur -> validNKey 
line 41839: && pCur -> apPage [ 0 ] -> intKey 
line 41840: ) { 
line 41841: if ( pCur -> info . nKey == intKey ) { 
line 41842: * pRes = 0 ; 
line 41843: return SQLITE_OK ; 
line 41844: } 
line 41845: if ( pCur -> atLast && pCur -> info . nKey < intKey ) { 
line 41846: * pRes = - 1 ; 
line 41847: return SQLITE_OK ; 
line 41848: } 
line 41849: } 
line 41851: rc = moveToRoot ( pCur ) ; 
line 41852: if ( rc ) { 
line 41853: return rc ; 
line 41854: } 
line 41855: assert ( pCur -> apPage [ pCur -> iPage ] ) ; 
line 41856: assert ( pCur -> apPage [ pCur -> iPage ] -> isInit ) ; 
line 41857: assert ( pCur -> apPage [ pCur -> iPage ] -> nCell > 0 || pCur -> eState == CURSOR_INVALID ) ; 
line 41858: if ( pCur -> eState == CURSOR_INVALID ) { 
line 41859: * pRes = - 1 ; 
line 41860: assert ( pCur -> apPage [ pCur -> iPage ] -> nCell == 0 ) ; 
line 41861: return SQLITE_OK ; 
line 41862: } 
line 41863: assert ( pCur -> apPage [ 0 ] -> intKey || pIdxKey ) ; 
line 41864: for ( ; ; ) { 
line 41865: int lwr , upr ; 
line 41866: Pgno chldPg ; 
line 41867: MemPage * pPage = pCur -> apPage [ pCur -> iPage ] ; 
line 41868: int c ; 
line 41876: assert ( pPage -> nCell > 0 ) ; 
line 41877: assert ( pPage -> intKey == ( pIdxKey == 0 ) ) ; 
line 41878: lwr = 0 ; 
line 41879: upr = pPage -> nCell - 1 ; 
line 41880: if ( biasRight ) { 
line 41881: pCur -> aiIdx [ pCur -> iPage ] = ( u16 ) upr ; 
line 41882: } else { 
line 41883: pCur -> aiIdx [ pCur -> iPage ] = ( u16 ) ( ( upr + lwr ) / 2 ) ; 
line 41884: } 
line 41885: for ( ; ; ) { 
line 41886: int idx = pCur -> aiIdx [ pCur -> iPage ] ; 
line 41887: u8 * pCell ; 
line 41889: pCur -> info . nSize = 0 ; 
line 41890: pCell = findCell ( pPage , idx ) + pPage -> childPtrSize ; 
line 41891: if ( pPage -> intKey ) { 
line 41892: i64 nCellKey ; 
line 41893: if ( pPage -> hasData ) { 
line 41894: u32 dummy ; 
line 41895: pCell += getVarint32 ( pCell , dummy ) ; 
line 41896: } 
line 41897: getVarint ( pCell , ( u64 * ) & nCellKey ) ; 
line 41898: if ( nCellKey == intKey ) { 
line 41899: c = 0 ; 
line 41900: } else if ( nCellKey < intKey ) { 
line 41901: c = - 1 ; 
line 41902: } else { 
line 41903: assert ( nCellKey > intKey ) ; 
line 41904: c = + 1 ; 
line 41905: } 
line 41906: pCur -> validNKey = 1 ; 
line 41907: pCur -> info . nKey = nCellKey ; 
line 41908: } else { 
line 41917: int nCell = pCell [ 0 ] ; 
line 41918: if ( ! ( nCell & 0x80 ) && nCell <= pPage -> maxLocal ) { 
line 41922: c = sqlite3VdbeRecordCompare ( nCell , ( void * ) & pCell [ 1 ] , pIdxKey ) ; 
line 41923: } else if ( ! ( pCell [ 1 ] & 0x80 ) 
line 41924: && ( nCell = ( ( nCell & 0x7f ) << 7 ) + pCell [ 1 ] ) <= pPage -> maxLocal 
line 41925: ) { 
line 41928: c = sqlite3VdbeRecordCompare ( nCell , ( void * ) & pCell [ 2 ] , pIdxKey ) ; 
line 41929: } else { 
line 41934: void * pCellKey ; 
line 41935: u8 * const pCellBody = pCell - pPage -> childPtrSize ; 
line 41936: btreeParseCellPtr ( pPage , pCellBody , & pCur -> info ) ; 
line 41937: nCell = ( int ) pCur -> info . nKey ; 
line 41938: pCellKey = sqlite3Malloc ( nCell ) ; 
line 41939: if ( pCellKey == 0 ) { 
line 41940: rc = SQLITE_NOMEM ; 
line 41941: goto moveto_finish ; 
line 41942: } 
line 41943: rc = accessPayload ( pCur , 0 , nCell , ( unsigned char * ) pCellKey , 0 ) ; 
line 41944: if ( rc ) { 
line 41945: sqlite3_free ( pCellKey ) ; 
line 41946: goto moveto_finish ; 
line 41947: } 
line 41948: c = sqlite3VdbeRecordCompare ( nCell , pCellKey , pIdxKey ) ; 
line 41949: sqlite3_free ( pCellKey ) ; 
line 41950: } 
line 41951: } 
line 41952: if ( c == 0 ) { 
line 41953: if ( pPage -> intKey && ! pPage -> leaf ) { 
line 41954: lwr = idx ; 
line 41955: upr = lwr - 1 ; 
line 41956: break ; 
line 41957: } else { 
line 41958: * pRes = 0 ; 
line 41959: rc = SQLITE_OK ; 
line 41960: goto moveto_finish ; 
line 41961: } 
line 41962: } 
line 41963: if ( c < 0 ) { 
line 41964: lwr = idx + 1 ; 
line 41965: } else { 
line 41966: upr = idx - 1 ; 
line 41967: } 
line 41968: if ( lwr > upr ) { 
line 41969: break ; 
line 41970: } 
line 41971: pCur -> aiIdx [ pCur -> iPage ] = ( u16 ) ( ( lwr + upr ) / 2 ) ; 
line 41972: } 
line 41973: assert ( lwr == upr + 1 ) ; 
line 41974: assert ( pPage -> isInit ) ; 
line 41975: if ( pPage -> leaf ) { 
line 41976: chldPg = 0 ; 
line 41977: } else if ( lwr >= pPage -> nCell ) { 
line 41978: chldPg = get4byte ( & pPage -> aData [ pPage -> hdrOffset + 8 ] ) ; 
line 41979: } else { 
line 41980: chldPg = get4byte ( findCell ( pPage , lwr ) ) ; 
line 41981: } 
line 41982: if ( chldPg == 0 ) { 
line 41983: assert ( pCur -> aiIdx [ pCur -> iPage ] < pCur -> apPage [ pCur -> iPage ] -> nCell ) ; 
line 41984: * pRes = c ; 
line 41985: rc = SQLITE_OK ; 
line 41986: goto moveto_finish ; 
line 41987: } 
line 41988: pCur -> aiIdx [ pCur -> iPage ] = ( u16 ) lwr ; 
line 41989: pCur -> info . nSize = 0 ; 
line 41990: pCur -> validNKey = 0 ; 
line 41991: rc = moveToChild ( pCur , chldPg ) ; 
line 41992: if ( rc ) goto moveto_finish ; 
line 41993: } 
line 41994: moveto_finish : 
line 41995: return rc ; 
line 41996: } 
line 42006: SQLITE_PRIVATE int sqlite3BtreeEof ( BtCursor * pCur ) { 
line 42011: return ( CURSOR_VALID != pCur -> eState ) ; 
line 42012: } 
line 42020: SQLITE_PRIVATE int sqlite3BtreeNext ( BtCursor * pCur , int * pRes ) { 
line 42021: int rc ; 
line 42022: int idx ; 
line 42023: MemPage * pPage ; 
line 42025: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 42026: rc = restoreCursorPosition ( pCur ) ; 
line 42027: if ( rc != SQLITE_OK ) { 
line 42028: return rc ; 
line 42029: } 
line 42030: assert ( pRes != 0 ) ; 
line 42031: if ( CURSOR_INVALID == pCur -> eState ) { 
line 42032: * pRes = 1 ; 
line 42033: return SQLITE_OK ; 
line 42034: } 
line 42035: if ( pCur -> skipNext > 0 ) { 
line 42036: pCur -> skipNext = 0 ; 
line 42037: * pRes = 0 ; 
line 42038: return SQLITE_OK ; 
line 42039: } 
line 42040: pCur -> skipNext = 0 ; 
line 42042: pPage = pCur -> apPage [ pCur -> iPage ] ; 
line 42043: idx = ++ pCur -> aiIdx [ pCur -> iPage ] ; 
line 42044: assert ( pPage -> isInit ) ; 
line 42045: assert ( idx <= pPage -> nCell ) ; 
line 42047: pCur -> info . nSize = 0 ; 
line 42048: pCur -> validNKey = 0 ; 
line 42049: if ( idx >= pPage -> nCell ) { 
line 42050: if ( ! pPage -> leaf ) { 
line 42051: rc = moveToChild ( pCur , get4byte ( & pPage -> aData [ pPage -> hdrOffset + 8 ] ) ) ; 
line 42052: if ( rc ) return rc ; 
line 42053: rc = moveToLeftmost ( pCur ) ; 
line 42054: * pRes = 0 ; 
line 42055: return rc ; 
line 42056: } 
line 42057: do { 
line 42058: if ( pCur -> iPage == 0 ) { 
line 42059: * pRes = 1 ; 
line 42060: pCur -> eState = CURSOR_INVALID ; 
line 42061: return SQLITE_OK ; 
line 42062: } 
line 42063: moveToParent ( pCur ) ; 
line 42064: pPage = pCur -> apPage [ pCur -> iPage ] ; 
line 42065: } while ( pCur -> aiIdx [ pCur -> iPage ] >= pPage -> nCell ) ; 
line 42066: * pRes = 0 ; 
line 42067: if ( pPage -> intKey ) { 
line 42068: rc = sqlite3BtreeNext ( pCur , pRes ) ; 
line 42069: } else { 
line 42070: rc = SQLITE_OK ; 
line 42071: } 
line 42072: return rc ; 
line 42073: } 
line 42074: * pRes = 0 ; 
line 42075: if ( pPage -> leaf ) { 
line 42076: return SQLITE_OK ; 
line 42077: } 
line 42078: rc = moveToLeftmost ( pCur ) ; 
line 42079: return rc ; 
line 42080: } 
line 42089: SQLITE_PRIVATE int sqlite3BtreePrevious ( BtCursor * pCur , int * pRes ) { 
line 42090: int rc ; 
line 42091: MemPage * pPage ; 
line 42093: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 42094: rc = restoreCursorPosition ( pCur ) ; 
line 42095: if ( rc != SQLITE_OK ) { 
line 42096: return rc ; 
line 42097: } 
line 42098: pCur -> atLast = 0 ; 
line 42099: if ( CURSOR_INVALID == pCur -> eState ) { 
line 42100: * pRes = 1 ; 
line 42101: return SQLITE_OK ; 
line 42102: } 
line 42103: if ( pCur -> skipNext < 0 ) { 
line 42104: pCur -> skipNext = 0 ; 
line 42105: * pRes = 0 ; 
line 42106: return SQLITE_OK ; 
line 42107: } 
line 42108: pCur -> skipNext = 0 ; 
line 42110: pPage = pCur -> apPage [ pCur -> iPage ] ; 
line 42111: assert ( pPage -> isInit ) ; 
line 42112: if ( ! pPage -> leaf ) { 
line 42113: int idx = pCur -> aiIdx [ pCur -> iPage ] ; 
line 42114: rc = moveToChild ( pCur , get4byte ( findCell ( pPage , idx ) ) ) ; 
line 42115: if ( rc ) { 
line 42116: return rc ; 
line 42117: } 
line 42118: rc = moveToRightmost ( pCur ) ; 
line 42119: } else { 
line 42120: while ( pCur -> aiIdx [ pCur -> iPage ] == 0 ) { 
line 42121: if ( pCur -> iPage == 0 ) { 
line 42122: pCur -> eState = CURSOR_INVALID ; 
line 42123: * pRes = 1 ; 
line 42124: return SQLITE_OK ; 
line 42125: } 
line 42126: moveToParent ( pCur ) ; 
line 42127: } 
line 42128: pCur -> info . nSize = 0 ; 
line 42129: pCur -> validNKey = 0 ; 
line 42131: pCur -> aiIdx [ pCur -> iPage ] -- ; 
line 42132: pPage = pCur -> apPage [ pCur -> iPage ] ; 
line 42133: if ( pPage -> intKey && ! pPage -> leaf ) { 
line 42134: rc = sqlite3BtreePrevious ( pCur , pRes ) ; 
line 42135: } else { 
line 42136: rc = SQLITE_OK ; 
line 42137: } 
line 42138: } 
line 42139: * pRes = 0 ; 
line 42140: return rc ; 
line 42141: } 
line 42164: static int allocateBtreePage ( 
line 42165: BtShared * pBt , 
line 42166: MemPage * * ppPage , 
line 42167: Pgno * pPgno , 
line 42168: Pgno nearby , 
line 42169: u8 exact 
line 42170: ) { 
line 42171: MemPage * pPage1 ; 
line 42172: int rc ; 
line 42173: u32 n ; 
line 42174: u32 k ; 
line 42175: MemPage * pTrunk = 0 ; 
line 42176: MemPage * pPrevTrunk = 0 ; 
line 42177: Pgno mxPage ; 
line 42179: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 42180: pPage1 = pBt -> pPage1 ; 
line 42181: mxPage = pagerPagecount ( pBt ) ; 
line 42182: n = get4byte ( & pPage1 -> aData [ 36 ] ) ; 
line 42183: testcase ( n == mxPage - 1 ) ; 
line 42184: if ( n >= mxPage ) { 
line 42185: return SQLITE_CORRUPT_BKPT ; 
line 42186: } 
line 42187: if ( n > 0 ) { 
line 42189: Pgno iTrunk ; 
line 42190: u8 searchList = 0 ; 
line 42196: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 42197: if ( exact && nearby <= mxPage ) { 
line 42198: u8 eType ; 
line 42199: assert ( nearby > 0 ) ; 
line 42200: assert ( pBt -> autoVacuum ) ; 
line 42201: rc = ptrmapGet ( pBt , nearby , & eType , 0 ) ; 
line 42202: if ( rc ) return rc ; 
line 42203: if ( eType == PTRMAP_FREEPAGE ) { 
line 42204: searchList = 1 ; 
line 42205: } 
line 42206: * pPgno = nearby ; 
line 42207: } 
line 42208: # endif 
line 42213: rc = sqlite3PagerWrite ( pPage1 -> pDbPage ) ; 
line 42214: if ( rc ) return rc ; 
line 42215: put4byte ( & pPage1 -> aData [ 36 ] , n - 1 ) ; 
line 42221: do { 
line 42222: pPrevTrunk = pTrunk ; 
line 42223: if ( pPrevTrunk ) { 
line 42224: iTrunk = get4byte ( & pPrevTrunk -> aData [ 0 ] ) ; 
line 42225: } else { 
line 42226: iTrunk = get4byte ( & pPage1 -> aData [ 32 ] ) ; 
line 42227: } 
line 42228: testcase ( iTrunk == mxPage ) ; 
line 42229: if ( iTrunk > mxPage ) { 
line 42230: rc = SQLITE_CORRUPT_BKPT ; 
line 42231: } else { 
line 42232: rc = btreeGetPage ( pBt , iTrunk , & pTrunk , 0 ) ; 
line 42233: } 
line 42234: if ( rc ) { 
line 42235: pTrunk = 0 ; 
line 42236: goto end_allocate_page ; 
line 42237: } 
line 42239: k = get4byte ( & pTrunk -> aData [ 4 ] ) ; 
line 42240: if ( k == 0 && ! searchList ) { 
line 42244: assert ( pPrevTrunk == 0 ) ; 
line 42245: rc = sqlite3PagerWrite ( pTrunk -> pDbPage ) ; 
line 42246: if ( rc ) { 
line 42247: goto end_allocate_page ; 
line 42248: } 
line 42249: * pPgno = iTrunk ; 
line 42250: memcpy ( & pPage1 -> aData [ 32 ] , & pTrunk -> aData [ 0 ] , 4 ) ; 
line 42251: * ppPage = pTrunk ; 
line 42252: pTrunk = 0 ; 
line 42253: TRACE ( ( "ALLOCATE: %d trunk - %d free pages left\n" , * pPgno , n - 1 ) ) ; 
line 42254: } else if ( k > ( u32 ) ( pBt -> usableSize / 4 - 2 ) ) { 
line 42256: rc = SQLITE_CORRUPT_BKPT ; 
line 42257: goto end_allocate_page ; 
line 42258: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 42259: } else if ( searchList && nearby == iTrunk ) { 
line 42263: assert ( * pPgno == iTrunk ) ; 
line 42264: * ppPage = pTrunk ; 
line 42265: searchList = 0 ; 
line 42266: rc = sqlite3PagerWrite ( pTrunk -> pDbPage ) ; 
line 42267: if ( rc ) { 
line 42268: goto end_allocate_page ; 
line 42269: } 
line 42270: if ( k == 0 ) { 
line 42271: if ( ! pPrevTrunk ) { 
line 42272: memcpy ( & pPage1 -> aData [ 32 ] , & pTrunk -> aData [ 0 ] , 4 ) ; 
line 42273: } else { 
line 42274: memcpy ( & pPrevTrunk -> aData [ 0 ] , & pTrunk -> aData [ 0 ] , 4 ) ; 
line 42275: } 
line 42276: } else { 
line 42281: MemPage * pNewTrunk ; 
line 42282: Pgno iNewTrunk = get4byte ( & pTrunk -> aData [ 8 ] ) ; 
line 42283: if ( iNewTrunk > mxPage ) { 
line 42284: rc = SQLITE_CORRUPT_BKPT ; 
line 42285: goto end_allocate_page ; 
line 42286: } 
line 42287: testcase ( iNewTrunk == mxPage ) ; 
line 42288: rc = btreeGetPage ( pBt , iNewTrunk , & pNewTrunk , 0 ) ; 
line 42289: if ( rc != SQLITE_OK ) { 
line 42290: goto end_allocate_page ; 
line 42291: } 
line 42292: rc = sqlite3PagerWrite ( pNewTrunk -> pDbPage ) ; 
line 42293: if ( rc != SQLITE_OK ) { 
line 42294: releasePage ( pNewTrunk ) ; 
line 42295: goto end_allocate_page ; 
line 42296: } 
line 42297: memcpy ( & pNewTrunk -> aData [ 0 ] , & pTrunk -> aData [ 0 ] , 4 ) ; 
line 42298: put4byte ( & pNewTrunk -> aData [ 4 ] , k - 1 ) ; 
line 42299: memcpy ( & pNewTrunk -> aData [ 8 ] , & pTrunk -> aData [ 12 ] , ( k - 1 ) * 4 ) ; 
line 42300: releasePage ( pNewTrunk ) ; 
line 42301: if ( ! pPrevTrunk ) { 
line 42302: assert ( sqlite3PagerIswriteable ( pPage1 -> pDbPage ) ) ; 
line 42303: put4byte ( & pPage1 -> aData [ 32 ] , iNewTrunk ) ; 
line 42304: } else { 
line 42305: rc = sqlite3PagerWrite ( pPrevTrunk -> pDbPage ) ; 
line 42306: if ( rc ) { 
line 42307: goto end_allocate_page ; 
line 42308: } 
line 42309: put4byte ( & pPrevTrunk -> aData [ 0 ] , iNewTrunk ) ; 
line 42310: } 
line 42311: } 
line 42312: pTrunk = 0 ; 
line 42313: TRACE ( ( "ALLOCATE: %d trunk - %d free pages left\n" , * pPgno , n - 1 ) ) ; 
line 42314: # endif 
line 42315: } else if ( k > 0 ) { 
line 42317: u32 closest ; 
line 42318: Pgno iPage ; 
line 42319: unsigned char * aData = pTrunk -> aData ; 
line 42320: rc = sqlite3PagerWrite ( pTrunk -> pDbPage ) ; 
line 42321: if ( rc ) { 
line 42322: goto end_allocate_page ; 
line 42323: } 
line 42324: if ( nearby > 0 ) { 
line 42325: u32 i ; 
line 42326: int dist ; 
line 42327: closest = 0 ; 
line 42328: dist = get4byte ( & aData [ 8 ] ) - nearby ; 
line 42329: if ( dist < 0 ) dist = - dist ; 
line 42330: for ( i = 1 ; i < k ; i ++ ) { 
line 42331: int d2 = get4byte ( & aData [ 8 + i * 4 ] ) - nearby ; 
line 42332: if ( d2 < 0 ) d2 = - d2 ; 
line 42333: if ( d2 < dist ) { 
line 42334: closest = i ; 
line 42335: dist = d2 ; 
line 42336: } 
line 42337: } 
line 42338: } else { 
line 42339: closest = 0 ; 
line 42340: } 
line 42342: iPage = get4byte ( & aData [ 8 + closest * 4 ] ) ; 
line 42343: testcase ( iPage == mxPage ) ; 
line 42344: if ( iPage > mxPage ) { 
line 42345: rc = SQLITE_CORRUPT_BKPT ; 
line 42346: goto end_allocate_page ; 
line 42347: } 
line 42348: testcase ( iPage == mxPage ) ; 
line 42349: if ( ! searchList || iPage == nearby ) { 
line 42350: int noContent ; 
line 42351: * pPgno = iPage ; 
line 42352: TRACE ( ( "ALLOCATE: %d was leaf %d of %d on trunk %d" 
line 42353: ": %d more free pages\n" , 
line 42354: * pPgno , closest + 1 , k , pTrunk -> pgno , n - 1 ) ) ; 
line 42355: if ( closest < k - 1 ) { 
line 42356: memcpy ( & aData [ 8 + closest * 4 ] , & aData [ 4 + k * 4 ] , 4 ) ; 
line 42357: } 
line 42358: put4byte ( & aData [ 4 ] , k - 1 ) ; 
line 42359: assert ( sqlite3PagerIswriteable ( pTrunk -> pDbPage ) ) ; 
line 42360: noContent = ! btreeGetHasContent ( pBt , * pPgno ) ; 
line 42361: rc = btreeGetPage ( pBt , * pPgno , ppPage , noContent ) ; 
line 42362: if ( rc == SQLITE_OK ) { 
line 42363: rc = sqlite3PagerWrite ( ( * ppPage ) -> pDbPage ) ; 
line 42364: if ( rc != SQLITE_OK ) { 
line 42365: releasePage ( * ppPage ) ; 
line 42366: } 
line 42367: } 
line 42368: searchList = 0 ; 
line 42369: } 
line 42370: } 
line 42371: releasePage ( pPrevTrunk ) ; 
line 42372: pPrevTrunk = 0 ; 
line 42373: } while ( searchList ) ; 
line 42374: } else { 
line 42377: int nPage = pagerPagecount ( pBt ) ; 
line 42378: * pPgno = nPage + 1 ; 
line 42380: if ( * pPgno == PENDING_BYTE_PAGE ( pBt ) ) { 
line 42381: ( * pPgno ) ++ ; 
line 42382: } 
line 42384: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 42385: if ( pBt -> autoVacuum && PTRMAP_ISPAGE ( pBt , * pPgno ) ) { 
line 42390: MemPage * pPg = 0 ; 
line 42391: TRACE ( ( "ALLOCATE: %d from end of file (pointer-map page)\n" , * pPgno ) ) ; 
line 42392: assert ( * pPgno != PENDING_BYTE_PAGE ( pBt ) ) ; 
line 42393: rc = btreeGetPage ( pBt , * pPgno , & pPg , 0 ) ; 
line 42394: if ( rc == SQLITE_OK ) { 
line 42395: rc = sqlite3PagerWrite ( pPg -> pDbPage ) ; 
line 42396: releasePage ( pPg ) ; 
line 42397: } 
line 42398: if ( rc ) return rc ; 
line 42399: ( * pPgno ) ++ ; 
line 42400: if ( * pPgno == PENDING_BYTE_PAGE ( pBt ) ) { ( * pPgno ) ++ ; } 
line 42401: } 
line 42402: # endif 
line 42404: assert ( * pPgno != PENDING_BYTE_PAGE ( pBt ) ) ; 
line 42405: rc = btreeGetPage ( pBt , * pPgno , ppPage , 0 ) ; 
line 42406: if ( rc ) return rc ; 
line 42407: rc = sqlite3PagerWrite ( ( * ppPage ) -> pDbPage ) ; 
line 42408: if ( rc != SQLITE_OK ) { 
line 42409: releasePage ( * ppPage ) ; 
line 42410: } 
line 42411: TRACE ( ( "ALLOCATE: %d from end of file\n" , * pPgno ) ) ; 
line 42412: } 
line 42414: assert ( * pPgno != PENDING_BYTE_PAGE ( pBt ) ) ; 
line 42416: end_allocate_page : 
line 42417: releasePage ( pTrunk ) ; 
line 42418: releasePage ( pPrevTrunk ) ; 
line 42419: if ( rc == SQLITE_OK ) { 
line 42420: if ( sqlite3PagerPageRefcount ( ( * ppPage ) -> pDbPage ) > 1 ) { 
line 42421: releasePage ( * ppPage ) ; 
line 42422: return SQLITE_CORRUPT_BKPT ; 
line 42423: } 
line 42424: ( * ppPage ) -> isInit = 0 ; 
line 42425: } else { 
line 42426: * ppPage = 0 ; 
line 42427: } 
line 42428: return rc ; 
line 42429: } 
line 42443: static int freePage2 ( BtShared * pBt , MemPage * pMemPage , Pgno iPage ) { 
line 42444: MemPage * pTrunk = 0 ; 
line 42445: Pgno iTrunk = 0 ; 
line 42446: MemPage * pPage1 = pBt -> pPage1 ; 
line 42447: MemPage * pPage ; 
line 42448: int rc ; 
line 42449: int nFree ; 
line 42451: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 42452: assert ( iPage > 1 ) ; 
line 42453: assert ( ! pMemPage || pMemPage -> pgno == iPage ) ; 
line 42455: if ( pMemPage ) { 
line 42456: pPage = pMemPage ; 
line 42457: sqlite3PagerRef ( pPage -> pDbPage ) ; 
line 42458: } else { 
line 42459: pPage = btreePageLookup ( pBt , iPage ) ; 
line 42460: } 
line 42463: rc = sqlite3PagerWrite ( pPage1 -> pDbPage ) ; 
line 42464: if ( rc ) goto freepage_out ; 
line 42465: nFree = get4byte ( & pPage1 -> aData [ 36 ] ) ; 
line 42466: put4byte ( & pPage1 -> aData [ 36 ] , nFree + 1 ) ; 
line 42468: # ifdef SQLITE_SECURE_DELETE 
line 42472: if ( ( ! pPage && ( rc = btreeGetPage ( pBt , iPage , & pPage , 0 ) ) ) 
line 42473: || ( rc = sqlite3PagerWrite ( pPage -> pDbPage ) ) 
line 42474: ) { 
line 42475: goto freepage_out ; 
line 42476: } 
line 42477: memset ( pPage -> aData , 0 , pPage -> pBt -> pageSize ) ; 
line 42478: # endif 
line 42483: if ( ISAUTOVACUUM ) { 
line 42484: ptrmapPut ( pBt , iPage , PTRMAP_FREEPAGE , 0 , & rc ) ; 
line 42485: if ( rc ) goto freepage_out ; 
line 42486: } 
line 42495: if ( nFree != 0 ) { 
line 42496: u32 nLeaf ; 
line 42498: iTrunk = get4byte ( & pPage1 -> aData [ 32 ] ) ; 
line 42499: rc = btreeGetPage ( pBt , iTrunk , & pTrunk , 0 ) ; 
line 42500: if ( rc != SQLITE_OK ) { 
line 42501: goto freepage_out ; 
line 42502: } 
line 42504: nLeaf = get4byte ( & pTrunk -> aData [ 4 ] ) ; 
line 42505: assert ( pBt -> usableSize > 32 ) ; 
line 42506: if ( nLeaf > ( u32 ) pBt -> usableSize / 4 - 2 ) { 
line 42507: rc = SQLITE_CORRUPT_BKPT ; 
line 42508: goto freepage_out ; 
line 42509: } 
line 42510: if ( nLeaf < ( u32 ) pBt -> usableSize / 4 - 8 ) { 
line 42525: rc = sqlite3PagerWrite ( pTrunk -> pDbPage ) ; 
line 42526: if ( rc == SQLITE_OK ) { 
line 42527: put4byte ( & pTrunk -> aData [ 4 ] , nLeaf + 1 ) ; 
line 42528: put4byte ( & pTrunk -> aData [ 8 + nLeaf * 4 ] , iPage ) ; 
line 42529: # ifndef SQLITE_SECURE_DELETE 
line 42530: if ( pPage ) { 
line 42531: sqlite3PagerDontWrite ( pPage -> pDbPage ) ; 
line 42532: } 
line 42533: # endif 
line 42534: rc = btreeSetHasContent ( pBt , iPage ) ; 
line 42535: } 
line 42536: TRACE ( ( "FREE-PAGE: %d leaf on trunk page %d\n" , pPage -> pgno , pTrunk -> pgno ) ) ; 
line 42537: goto freepage_out ; 
line 42538: } 
line 42539: } 
line 42547: if ( pPage == 0 && SQLITE_OK != ( rc = btreeGetPage ( pBt , iPage , & pPage , 0 ) ) ) { 
line 42548: goto freepage_out ; 
line 42549: } 
line 42550: rc = sqlite3PagerWrite ( pPage -> pDbPage ) ; 
line 42551: if ( rc != SQLITE_OK ) { 
line 42552: goto freepage_out ; 
line 42553: } 
line 42554: put4byte ( pPage -> aData , iTrunk ) ; 
line 42555: put4byte ( & pPage -> aData [ 4 ] , 0 ) ; 
line 42556: put4byte ( & pPage1 -> aData [ 32 ] , iPage ) ; 
line 42557: TRACE ( ( "FREE-PAGE: %d new trunk page replacing %d\n" , pPage -> pgno , iTrunk ) ) ; 
line 42559: freepage_out : 
line 42560: if ( pPage ) { 
line 42561: pPage -> isInit = 0 ; 
line 42562: } 
line 42563: releasePage ( pPage ) ; 
line 42564: releasePage ( pTrunk ) ; 
line 42565: return rc ; 
line 42566: } 
line 42567: static void freePage ( MemPage * pPage , int * pRC ) { 
line 42568: if ( ( * pRC ) == SQLITE_OK ) { 
line 42569: * pRC = freePage2 ( pPage -> pBt , pPage , pPage -> pgno ) ; 
line 42570: } 
line 42571: } 
line 42576: static int clearCell ( MemPage * pPage , unsigned char * pCell ) { 
line 42577: BtShared * pBt = pPage -> pBt ; 
line 42578: CellInfo info ; 
line 42579: Pgno ovflPgno ; 
line 42580: int rc ; 
line 42581: int nOvfl ; 
line 42582: u16 ovflPageSize ; 
line 42584: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 42585: btreeParseCellPtr ( pPage , pCell , & info ) ; 
line 42586: if ( info . iOverflow == 0 ) { 
line 42587: return SQLITE_OK ; 
line 42588: } 
line 42589: ovflPgno = get4byte ( & pCell [ info . iOverflow ] ) ; 
line 42590: assert ( pBt -> usableSize > 4 ) ; 
line 42591: ovflPageSize = pBt -> usableSize - 4 ; 
line 42592: nOvfl = ( info . nPayload - info . nLocal + ovflPageSize - 1 ) / ovflPageSize ; 
line 42593: assert ( ovflPgno == 0 || nOvfl > 0 ) ; 
line 42594: while ( nOvfl -- ) { 
line 42595: Pgno iNext = 0 ; 
line 42596: MemPage * pOvfl = 0 ; 
line 42597: if ( ovflPgno < 2 || ovflPgno > pagerPagecount ( pBt ) ) { 
line 42601: return SQLITE_CORRUPT_BKPT ; 
line 42602: } 
line 42603: if ( nOvfl ) { 
line 42604: rc = getOverflowPage ( pBt , ovflPgno , & pOvfl , & iNext ) ; 
line 42605: if ( rc ) return rc ; 
line 42606: } 
line 42607: rc = freePage2 ( pBt , pOvfl , ovflPgno ) ; 
line 42608: if ( pOvfl ) { 
line 42609: sqlite3PagerUnref ( pOvfl -> pDbPage ) ; 
line 42610: } 
line 42611: if ( rc ) return rc ; 
line 42612: ovflPgno = iNext ; 
line 42613: } 
line 42614: return SQLITE_OK ; 
line 42615: } 
line 42629: static int fillInCell ( 
line 42630: MemPage * pPage , 
line 42631: unsigned char * pCell , 
line 42632: const void * pKey , i64 nKey , 
line 42633: const void * pData , int nData , 
line 42634: int nZero , 
line 42635: int * pnSize 
line 42636: ) { 
line 42637: int nPayload ; 
line 42638: const u8 * pSrc ; 
line 42639: int nSrc , n , rc ; 
line 42640: int spaceLeft ; 
line 42641: MemPage * pOvfl = 0 ; 
line 42642: MemPage * pToRelease = 0 ; 
line 42643: unsigned char * pPrior ; 
line 42644: unsigned char * pPayload ; 
line 42645: BtShared * pBt = pPage -> pBt ; 
line 42646: Pgno pgnoOvfl = 0 ; 
line 42647: int nHeader ; 
line 42648: CellInfo info ; 
line 42650: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 42654: assert ( pCell < pPage -> aData || pCell >= & pPage -> aData [ pBt -> pageSize ] 
line 42655: || sqlite3PagerIswriteable ( pPage -> pDbPage ) ) ; 
line 42658: nHeader = 0 ; 
line 42659: if ( ! pPage -> leaf ) { 
line 42660: nHeader += 4 ; 
line 42661: } 
line 42662: if ( pPage -> hasData ) { 
line 42663: nHeader += putVarint ( & pCell [ nHeader ] , nData + nZero ) ; 
line 42664: } else { 
line 42665: nData = nZero = 0 ; 
line 42666: } 
line 42667: nHeader += putVarint ( & pCell [ nHeader ] , * ( u64 * ) & nKey ) ; 
line 42668: btreeParseCellPtr ( pPage , pCell , & info ) ; 
line 42669: assert ( info . nHeader == nHeader ) ; 
line 42670: assert ( info . nKey == nKey ) ; 
line 42671: assert ( info . nData == ( u32 ) ( nData + nZero ) ) ; 
line 42674: nPayload = nData + nZero ; 
line 42675: if ( pPage -> intKey ) { 
line 42676: pSrc = pData ; 
line 42677: nSrc = nData ; 
line 42678: nData = 0 ; 
line 42679: } else { 
line 42680: if ( NEVER ( nKey > 0x7fffffff || pKey == 0 ) ) { 
line 42681: return SQLITE_CORRUPT_BKPT ; 
line 42682: } 
line 42683: nPayload += ( int ) nKey ; 
line 42684: pSrc = pKey ; 
line 42685: nSrc = ( int ) nKey ; 
line 42686: } 
line 42687: * pnSize = info . nSize ; 
line 42688: spaceLeft = info . nLocal ; 
line 42689: pPayload = & pCell [ nHeader ] ; 
line 42690: pPrior = & pCell [ info . iOverflow ] ; 
line 42692: while ( nPayload > 0 ) { 
line 42693: if ( spaceLeft == 0 ) { 
line 42694: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 42695: Pgno pgnoPtrmap = pgnoOvfl ; 
line 42696: if ( pBt -> autoVacuum ) { 
line 42697: do { 
line 42698: pgnoOvfl ++ ; 
line 42699: } while ( 
line 42700: PTRMAP_ISPAGE ( pBt , pgnoOvfl ) || pgnoOvfl == PENDING_BYTE_PAGE ( pBt ) 
line 42701: ) ; 
line 42702: } 
line 42703: # endif 
line 42704: rc = allocateBtreePage ( pBt , & pOvfl , & pgnoOvfl , pgnoOvfl , 0 ) ; 
line 42705: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 42716: if ( pBt -> autoVacuum && rc == SQLITE_OK ) { 
line 42717: u8 eType = ( pgnoPtrmap ? PTRMAP_OVERFLOW2 : PTRMAP_OVERFLOW1 ) ; 
line 42718: ptrmapPut ( pBt , pgnoOvfl , eType , pgnoPtrmap , & rc ) ; 
line 42719: if ( rc ) { 
line 42720: releasePage ( pOvfl ) ; 
line 42721: } 
line 42722: } 
line 42723: # endif 
line 42724: if ( rc ) { 
line 42725: releasePage ( pToRelease ) ; 
line 42726: return rc ; 
line 42727: } 
line 42731: assert ( pToRelease == 0 || sqlite3PagerIswriteable ( pToRelease -> pDbPage ) ) ; 
line 42735: assert ( pPrior < pPage -> aData || pPrior >= & pPage -> aData [ pBt -> pageSize ] 
line 42736: || sqlite3PagerIswriteable ( pPage -> pDbPage ) ) ; 
line 42738: put4byte ( pPrior , pgnoOvfl ) ; 
line 42739: releasePage ( pToRelease ) ; 
line 42740: pToRelease = pOvfl ; 
line 42741: pPrior = pOvfl -> aData ; 
line 42742: put4byte ( pPrior , 0 ) ; 
line 42743: pPayload = & pOvfl -> aData [ 4 ] ; 
line 42744: spaceLeft = pBt -> usableSize - 4 ; 
line 42745: } 
line 42746: n = nPayload ; 
line 42747: if ( n > spaceLeft ) n = spaceLeft ; 
line 42751: assert ( pToRelease == 0 || sqlite3PagerIswriteable ( pToRelease -> pDbPage ) ) ; 
line 42755: assert ( pPayload < pPage -> aData || pPayload >= & pPage -> aData [ pBt -> pageSize ] 
line 42756: || sqlite3PagerIswriteable ( pPage -> pDbPage ) ) ; 
line 42758: if ( nSrc > 0 ) { 
line 42759: if ( n > nSrc ) n = nSrc ; 
line 42760: assert ( pSrc ) ; 
line 42761: memcpy ( pPayload , pSrc , n ) ; 
line 42762: } else { 
line 42763: memset ( pPayload , 0 , n ) ; 
line 42764: } 
line 42765: nPayload -= n ; 
line 42766: pPayload += n ; 
line 42767: pSrc += n ; 
line 42768: nSrc -= n ; 
line 42769: spaceLeft -= n ; 
line 42770: if ( nSrc == 0 ) { 
line 42771: nSrc = nData ; 
line 42772: pSrc = pData ; 
line 42773: } 
line 42774: } 
line 42775: releasePage ( pToRelease ) ; 
line 42776: return SQLITE_OK ; 
line 42777: } 
line 42787: static void dropCell ( MemPage * pPage , int idx , int sz , int * pRC ) { 
line 42788: int i ; 
line 42789: int pc ; 
line 42790: u8 * data ; 
line 42791: u8 * ptr ; 
line 42792: int rc ; 
line 42793: int hdr ; 
line 42795: if ( * pRC ) return ; 
line 42797: assert ( idx >= 0 && idx < pPage -> nCell ) ; 
line 42798: assert ( sz == cellSize ( pPage , idx ) ) ; 
line 42799: assert ( sqlite3PagerIswriteable ( pPage -> pDbPage ) ) ; 
line 42800: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 42801: data = pPage -> aData ; 
line 42802: ptr = & data [ pPage -> cellOffset + 2 * idx ] ; 
line 42803: pc = get2byte ( ptr ) ; 
line 42804: hdr = pPage -> hdrOffset ; 
line 42805: testcase ( pc == get2byte ( & data [ hdr + 5 ] ) ) ; 
line 42806: testcase ( pc + sz == pPage -> pBt -> usableSize ) ; 
line 42807: if ( pc < get2byte ( & data [ hdr + 5 ] ) || pc + sz > pPage -> pBt -> usableSize ) { 
line 42808: * pRC = SQLITE_CORRUPT_BKPT ; 
line 42809: return ; 
line 42810: } 
line 42811: rc = freeSpace ( pPage , pc , sz ) ; 
line 42812: if ( rc ) { 
line 42813: * pRC = rc ; 
line 42814: return ; 
line 42815: } 
line 42816: for ( i = idx + 1 ; i < pPage -> nCell ; i ++ , ptr += 2 ) { 
line 42817: ptr [ 0 ] = ptr [ 2 ] ; 
line 42818: ptr [ 1 ] = ptr [ 3 ] ; 
line 42819: } 
line 42820: pPage -> nCell -- ; 
line 42821: put2byte ( & data [ hdr + 3 ] , pPage -> nCell ) ; 
line 42822: pPage -> nFree += 2 ; 
line 42823: } 
line 42842: static void insertCell ( 
line 42843: MemPage * pPage , 
line 42844: int i , 
line 42845: u8 * pCell , 
line 42846: int sz , 
line 42847: u8 * pTemp , 
line 42848: Pgno iChild , 
line 42849: int * pRC 
line 42850: ) { 
line 42851: int idx ; 
line 42852: int j ; 
line 42853: int end ; 
line 42854: int ins ; 
line 42855: int cellOffset ; 
line 42856: u8 * data ; 
line 42857: u8 * ptr ; 
line 42859: int nSkip = ( iChild ? 4 : 0 ) ; 
line 42861: if ( * pRC ) return ; 
line 42863: assert ( i >= 0 && i <= pPage -> nCell + pPage -> nOverflow ) ; 
line 42864: assert ( pPage -> nCell <= MX_CELL ( pPage -> pBt ) && MX_CELL ( pPage -> pBt ) <= 5460 ) ; 
line 42865: assert ( pPage -> nOverflow <= ArraySize ( pPage -> aOvfl ) ) ; 
line 42866: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 42872: assert ( sz == cellSizePtr ( pPage , pCell ) || ( sz == 8 && iChild > 0 ) ) ; 
line 42873: if ( pPage -> nOverflow || sz + 2 > pPage -> nFree ) { 
line 42874: if ( pTemp ) { 
line 42875: memcpy ( pTemp + nSkip , pCell + nSkip , sz - nSkip ) ; 
line 42876: pCell = pTemp ; 
line 42877: } 
line 42878: if ( iChild ) { 
line 42879: put4byte ( pCell , iChild ) ; 
line 42880: } 
line 42881: j = pPage -> nOverflow ++ ; 
line 42882: assert ( j < ( int ) ( sizeof ( pPage -> aOvfl ) / sizeof ( pPage -> aOvfl [ 0 ] ) ) ) ; 
line 42883: pPage -> aOvfl [ j ] . pCell = pCell ; 
line 42884: pPage -> aOvfl [ j ] . idx = ( u16 ) i ; 
line 42885: } else { 
line 42886: int rc = sqlite3PagerWrite ( pPage -> pDbPage ) ; 
line 42887: if ( rc != SQLITE_OK ) { 
line 42888: * pRC = rc ; 
line 42889: return ; 
line 42890: } 
line 42891: assert ( sqlite3PagerIswriteable ( pPage -> pDbPage ) ) ; 
line 42892: data = pPage -> aData ; 
line 42893: cellOffset = pPage -> cellOffset ; 
line 42894: end = cellOffset + 2 * pPage -> nCell ; 
line 42895: ins = cellOffset + 2 * i ; 
line 42896: rc = allocateSpace ( pPage , sz , & idx ) ; 
line 42897: if ( rc ) { * pRC = rc ; return ; } 
line 42900: assert ( idx >= end + 2 ) ; 
line 42901: assert ( idx + sz <= pPage -> pBt -> usableSize ) ; 
line 42902: pPage -> nCell ++ ; 
line 42903: pPage -> nFree -= ( u16 ) ( 2 + sz ) ; 
line 42904: memcpy ( & data [ idx + nSkip ] , pCell + nSkip , sz - nSkip ) ; 
line 42905: if ( iChild ) { 
line 42906: put4byte ( & data [ idx ] , iChild ) ; 
line 42907: } 
line 42908: for ( j = end , ptr = & data [ j ] ; j > ins ; j -= 2 , ptr -= 2 ) { 
line 42909: ptr [ 0 ] = ptr [ - 2 ] ; 
line 42910: ptr [ 1 ] = ptr [ - 1 ] ; 
line 42911: } 
line 42912: put2byte ( & data [ ins ] , idx ) ; 
line 42913: put2byte ( & data [ pPage -> hdrOffset + 3 ] , pPage -> nCell ) ; 
line 42914: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 42915: if ( pPage -> pBt -> autoVacuum ) { 
line 42919: ptrmapPutOvflPtr ( pPage , pCell , pRC ) ; 
line 42920: } 
line 42921: # endif 
line 42922: } 
line 42923: } 
line 42929: static void assemblePage ( 
line 42930: MemPage * pPage , 
line 42931: int nCell , 
line 42932: u8 * * apCell , 
line 42933: u16 * aSize 
line 42934: ) { 
line 42935: int i ; 
line 42936: u8 * pCellptr ; 
line 42937: int cellbody ; 
line 42938: u8 * const data = pPage -> aData ; 
line 42939: const int hdr = pPage -> hdrOffset ; 
line 42940: const int nUsable = pPage -> pBt -> usableSize ; 
line 42942: assert ( pPage -> nOverflow == 0 ) ; 
line 42943: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 42944: assert ( nCell >= 0 && nCell <= MX_CELL ( pPage -> pBt ) && MX_CELL ( pPage -> pBt ) <= 5460 ) ; 
line 42945: assert ( sqlite3PagerIswriteable ( pPage -> pDbPage ) ) ; 
line 42948: assert ( pPage -> nCell == 0 ) ; 
line 42949: assert ( get2byte ( & data [ hdr + 5 ] ) == nUsable ) ; 
line 42951: pCellptr = & data [ pPage -> cellOffset + nCell * 2 ] ; 
line 42952: cellbody = nUsable ; 
line 42953: for ( i = nCell - 1 ; i >= 0 ; i -- ) { 
line 42954: pCellptr -= 2 ; 
line 42955: cellbody -= aSize [ i ] ; 
line 42956: put2byte ( pCellptr , cellbody ) ; 
line 42957: memcpy ( & data [ cellbody ] , apCell [ i ] , aSize [ i ] ) ; 
line 42958: } 
line 42959: put2byte ( & data [ hdr + 3 ] , nCell ) ; 
line 42960: put2byte ( & data [ hdr + 5 ] , cellbody ) ; 
line 42961: pPage -> nFree -= ( nCell * 2 + nUsable - cellbody ) ; 
line 42962: pPage -> nCell = ( u16 ) nCell ; 
line 42963: } 
line 42977: # define NN 1 
line 42978: # define NB ( NN * 2 + 1 ) 
line 42981: # ifndef SQLITE_OMIT_QUICKBALANCE 
line 43005: static int balance_quick ( MemPage * pParent , MemPage * pPage , u8 * pSpace ) { 
line 43006: BtShared * const pBt = pPage -> pBt ; 
line 43007: MemPage * pNew ; 
line 43008: int rc ; 
line 43009: Pgno pgnoNew ; 
line 43011: assert ( sqlite3_mutex_held ( pPage -> pBt -> mutex ) ) ; 
line 43012: assert ( sqlite3PagerIswriteable ( pParent -> pDbPage ) ) ; 
line 43013: assert ( pPage -> nOverflow == 1 ) ; 
line 43015: if ( pPage -> nCell <= 0 ) return SQLITE_CORRUPT_BKPT ; 
line 43021: rc = allocateBtreePage ( pBt , & pNew , & pgnoNew , 0 , 0 ) ; 
line 43023: if ( rc == SQLITE_OK ) { 
line 43025: u8 * pOut = & pSpace [ 4 ] ; 
line 43026: u8 * pCell = pPage -> aOvfl [ 0 ] . pCell ; 
line 43027: u16 szCell = cellSizePtr ( pPage , pCell ) ; 
line 43028: u8 * pStop ; 
line 43030: assert ( sqlite3PagerIswriteable ( pNew -> pDbPage ) ) ; 
line 43031: assert ( pPage -> aData [ 0 ] == ( PTF_INTKEY | PTF_LEAFDATA | PTF_LEAF ) ) ; 
line 43032: zeroPage ( pNew , PTF_INTKEY | PTF_LEAFDATA | PTF_LEAF ) ; 
line 43033: assemblePage ( pNew , 1 , & pCell , & szCell ) ; 
line 43044: if ( ISAUTOVACUUM ) { 
line 43045: ptrmapPut ( pBt , pgnoNew , PTRMAP_BTREE , pParent -> pgno , & rc ) ; 
line 43046: if ( szCell > pNew -> minLocal ) { 
line 43047: ptrmapPutOvflPtr ( pNew , pCell , & rc ) ; 
line 43048: } 
line 43049: } 
line 43064: pCell = findCell ( pPage , pPage -> nCell - 1 ) ; 
line 43065: pStop = & pCell [ 9 ] ; 
line 43066: while ( ( * ( pCell ++ ) & 0x80 ) && pCell < pStop ) ; 
line 43067: pStop = & pCell [ 9 ] ; 
line 43068: while ( ( ( * ( pOut ++ ) = * ( pCell ++ ) ) & 0x80 ) && pCell < pStop ) ; 
line 43071: insertCell ( pParent , pParent -> nCell , pSpace , ( int ) ( pOut - pSpace ) , 
line 43072: 0 , pPage -> pgno , & rc ) ; 
line 43075: put4byte ( & pParent -> aData [ pParent -> hdrOffset + 8 ] , pgnoNew ) ; 
line 43078: releasePage ( pNew ) ; 
line 43079: } 
line 43081: return rc ; 
line 43082: } 
line 43083: # endif 
line 43085: # if 0 
line 43091: static int ptrmapCheckPages ( MemPage * * apPage , int nPage ) { 
line 43092: int i , j ; 
line 43093: for ( i = 0 ; i < nPage ; i ++ ) { 
line 43094: Pgno n ; 
line 43095: u8 e ; 
line 43096: MemPage * pPage = apPage [ i ] ; 
line 43097: BtShared * pBt = pPage -> pBt ; 
line 43098: assert ( pPage -> isInit ) ; 
line 43100: for ( j = 0 ; j < pPage -> nCell ; j ++ ) { 
line 43101: CellInfo info ; 
line 43102: u8 * z ; 
line 43104: z = findCell ( pPage , j ) ; 
line 43105: btreeParseCellPtr ( pPage , z , & info ) ; 
line 43106: if ( info . iOverflow ) { 
line 43107: Pgno ovfl = get4byte ( & z [ info . iOverflow ] ) ; 
line 43108: ptrmapGet ( pBt , ovfl , & e , & n ) ; 
line 43109: assert ( n == pPage -> pgno && e == PTRMAP_OVERFLOW1 ) ; 
line 43110: } 
line 43111: if ( ! pPage -> leaf ) { 
line 43112: Pgno child = get4byte ( z ) ; 
line 43113: ptrmapGet ( pBt , child , & e , & n ) ; 
line 43114: assert ( n == pPage -> pgno && e == PTRMAP_BTREE ) ; 
line 43115: } 
line 43116: } 
line 43117: if ( ! pPage -> leaf ) { 
line 43118: Pgno child = get4byte ( & pPage -> aData [ pPage -> hdrOffset + 8 ] ) ; 
line 43119: ptrmapGet ( pBt , child , & e , & n ) ; 
line 43120: assert ( n == pPage -> pgno && e == PTRMAP_BTREE ) ; 
line 43121: } 
line 43122: } 
line 43123: return 1 ; 
line 43124: } 
line 43125: # endif 
line 43144: static void copyNodeContent ( MemPage * pFrom , MemPage * pTo , int * pRC ) { 
line 43145: if ( ( * pRC ) == SQLITE_OK ) { 
line 43146: BtShared * const pBt = pFrom -> pBt ; 
line 43147: u8 * const aFrom = pFrom -> aData ; 
line 43148: u8 * const aTo = pTo -> aData ; 
line 43149: int const iFromHdr = pFrom -> hdrOffset ; 
line 43150: int const iToHdr = ( ( pTo -> pgno == 1 ) ? 100 : 0 ) ; 
line 43151: int rc ; 
line 43152: int iData ; 
line 43155: assert ( pFrom -> isInit ) ; 
line 43156: assert ( pFrom -> nFree >= iToHdr ) ; 
line 43157: assert ( get2byte ( & aFrom [ iFromHdr + 5 ] ) <= pBt -> usableSize ) ; 
line 43160: iData = get2byte ( & aFrom [ iFromHdr + 5 ] ) ; 
line 43161: memcpy ( & aTo [ iData ] , & aFrom [ iData ] , pBt -> usableSize - iData ) ; 
line 43162: memcpy ( & aTo [ iToHdr ] , & aFrom [ iFromHdr ] , pFrom -> cellOffset + 2 * pFrom -> nCell ) ; 
line 43169: pTo -> isInit = 0 ; 
line 43170: rc = btreeInitPage ( pTo ) ; 
line 43171: if ( rc != SQLITE_OK ) { 
line 43172: * pRC = rc ; 
line 43173: return ; 
line 43174: } 
line 43179: if ( ISAUTOVACUUM ) { 
line 43180: * pRC = setChildPtrmaps ( pTo ) ; 
line 43181: } 
line 43182: } 
line 43183: } 
line 43225: static int balance_nonroot ( 
line 43226: MemPage * pParent , 
line 43227: int iParentIdx , 
line 43228: u8 * aOvflSpace , 
line 43229: int isRoot 
line 43230: ) { 
line 43231: BtShared * pBt ; 
line 43232: int nCell = 0 ; 
line 43233: int nMaxCells = 0 ; 
line 43234: int nNew = 0 ; 
line 43235: int nOld ; 
line 43236: int i , j , k ; 
line 43237: int nxDiv ; 
line 43238: int rc = SQLITE_OK ; 
line 43239: u16 leafCorrection ; 
line 43240: int leafData ; 
line 43241: int usableSpace ; 
line 43242: int pageFlags ; 
line 43243: int subtotal ; 
line 43244: int iSpace1 = 0 ; 
line 43245: int iOvflSpace = 0 ; 
line 43246: int szScratch ; 
line 43247: MemPage * apOld [ NB ] ; 
line 43248: MemPage * apCopy [ NB ] ; 
line 43249: MemPage * apNew [ NB + 2 ] ; 
line 43250: u8 * pRight ; 
line 43251: u8 * apDiv [ NB - 1 ] ; 
line 43252: int cntNew [ NB + 2 ] ; 
line 43253: int szNew [ NB + 2 ] ; 
line 43254: u8 * * apCell = 0 ; 
line 43255: u16 * szCell ; 
line 43256: u8 * aSpace1 ; 
line 43257: Pgno pgno ; 
line 43259: pBt = pParent -> pBt ; 
line 43260: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 43261: assert ( sqlite3PagerIswriteable ( pParent -> pDbPage ) ) ; 
line 43263: # if 0 
line 43264: TRACE ( ( "BALANCE: begin page %d child of %d\n" , pPage -> pgno , pParent -> pgno ) ) ; 
line 43265: # endif 
line 43272: assert ( pParent -> nOverflow == 0 || pParent -> nOverflow == 1 ) ; 
line 43273: assert ( pParent -> nOverflow == 0 || pParent -> aOvfl [ 0 ] . idx == iParentIdx ) ; 
line 43275: if ( ! aOvflSpace ) { 
line 43276: return SQLITE_NOMEM ; 
line 43277: } 
line 43290: i = pParent -> nOverflow + pParent -> nCell ; 
line 43291: if ( i < 2 ) { 
line 43292: nxDiv = 0 ; 
line 43293: nOld = i + 1 ; 
line 43294: } else { 
line 43295: nOld = 3 ; 
line 43296: if ( iParentIdx == 0 ) { 
line 43297: nxDiv = 0 ; 
line 43298: } else if ( iParentIdx == i ) { 
line 43299: nxDiv = i - 2 ; 
line 43300: } else { 
line 43301: nxDiv = iParentIdx - 1 ; 
line 43302: } 
line 43303: i = 2 ; 
line 43304: } 
line 43305: if ( ( i + nxDiv - pParent -> nOverflow ) == pParent -> nCell ) { 
line 43306: pRight = & pParent -> aData [ pParent -> hdrOffset + 8 ] ; 
line 43307: } else { 
line 43308: pRight = findCell ( pParent , i + nxDiv - pParent -> nOverflow ) ; 
line 43309: } 
line 43310: pgno = get4byte ( pRight ) ; 
line 43311: while ( 1 ) { 
line 43312: rc = getAndInitPage ( pBt , pgno , & apOld [ i ] ) ; 
line 43313: if ( rc ) { 
line 43314: memset ( apOld , 0 , ( i + 1 ) * sizeof ( MemPage * ) ) ; 
line 43315: goto balance_cleanup ; 
line 43316: } 
line 43317: nMaxCells += 1 + apOld [ i ] -> nCell + apOld [ i ] -> nOverflow ; 
line 43318: if ( ( i -- ) == 0 ) break ; 
line 43320: if ( i + nxDiv == pParent -> aOvfl [ 0 ] . idx && pParent -> nOverflow ) { 
line 43321: apDiv [ i ] = pParent -> aOvfl [ 0 ] . pCell ; 
line 43322: pgno = get4byte ( apDiv [ i ] ) ; 
line 43323: szNew [ i ] = cellSizePtr ( pParent , apDiv [ i ] ) ; 
line 43324: pParent -> nOverflow = 0 ; 
line 43325: } else { 
line 43326: apDiv [ i ] = findCell ( pParent , i + nxDiv - pParent -> nOverflow ) ; 
line 43327: pgno = get4byte ( apDiv [ i ] ) ; 
line 43328: szNew [ i ] = cellSizePtr ( pParent , apDiv [ i ] ) ; 
line 43342: # ifdef SQLITE_SECURE_DELETE 
line 43343: memcpy ( & aOvflSpace [ apDiv [ i ] - pParent -> aData ] , apDiv [ i ] , szNew [ i ] ) ; 
line 43344: apDiv [ i ] = & aOvflSpace [ apDiv [ i ] - pParent -> aData ] ; 
line 43345: # endif 
line 43346: dropCell ( pParent , i + nxDiv - pParent -> nOverflow , szNew [ i ] , & rc ) ; 
line 43347: } 
line 43348: } 
line 43352: nMaxCells = ( nMaxCells + 3 ) & ~ 3 ; 
line 43357: k = pBt -> pageSize + ROUND8 ( sizeof ( MemPage ) ) ; 
line 43358: szScratch = 
line 43359: nMaxCells * sizeof ( u8 * ) 
line 43360: + nMaxCells * sizeof ( u16 ) 
line 43361: + pBt -> pageSize 
line 43362: + k * nOld ; 
line 43363: apCell = sqlite3ScratchMalloc ( szScratch ) ; 
line 43364: if ( apCell == 0 ) { 
line 43365: rc = SQLITE_NOMEM ; 
line 43366: goto balance_cleanup ; 
line 43367: } 
line 43368: szCell = ( u16 * ) & apCell [ nMaxCells ] ; 
line 43369: aSpace1 = ( u8 * ) & szCell [ nMaxCells ] ; 
line 43370: assert ( EIGHT_BYTE_ALIGNMENT ( aSpace1 ) ) ; 
line 43388: leafCorrection = apOld [ 0 ] -> leaf * 4 ; 
line 43389: leafData = apOld [ 0 ] -> hasData ; 
line 43390: for ( i = 0 ; i < nOld ; i ++ ) { 
line 43391: int limit ; 
line 43397: MemPage * pOld = apCopy [ i ] = ( MemPage * ) & aSpace1 [ pBt -> pageSize + k * i ] ; 
line 43398: memcpy ( pOld , apOld [ i ] , sizeof ( MemPage ) ) ; 
line 43399: pOld -> aData = ( void * ) & pOld [ 1 ] ; 
line 43400: memcpy ( pOld -> aData , apOld [ i ] -> aData , pBt -> pageSize ) ; 
line 43402: limit = pOld -> nCell + pOld -> nOverflow ; 
line 43403: for ( j = 0 ; j < limit ; j ++ ) { 
line 43404: assert ( nCell < nMaxCells ) ; 
line 43405: apCell [ nCell ] = findOverflowCell ( pOld , j ) ; 
line 43406: szCell [ nCell ] = cellSizePtr ( pOld , apCell [ nCell ] ) ; 
line 43407: nCell ++ ; 
line 43408: } 
line 43409: if ( i < nOld - 1 && ! leafData ) { 
line 43410: u16 sz = ( u16 ) szNew [ i ] ; 
line 43411: u8 * pTemp ; 
line 43412: assert ( nCell < nMaxCells ) ; 
line 43413: szCell [ nCell ] = sz ; 
line 43414: pTemp = & aSpace1 [ iSpace1 ] ; 
line 43415: iSpace1 += sz ; 
line 43416: assert ( sz <= pBt -> pageSize / 4 ) ; 
line 43417: assert ( iSpace1 <= pBt -> pageSize ) ; 
line 43418: memcpy ( pTemp , apDiv [ i ] , sz ) ; 
line 43419: apCell [ nCell ] = pTemp + leafCorrection ; 
line 43420: assert ( leafCorrection == 0 || leafCorrection == 4 ) ; 
line 43421: szCell [ nCell ] = szCell [ nCell ] - leafCorrection ; 
line 43422: if ( ! pOld -> leaf ) { 
line 43423: assert ( leafCorrection == 0 ) ; 
line 43424: assert ( pOld -> hdrOffset == 0 ) ; 
line 43427: memcpy ( apCell [ nCell ] , & pOld -> aData [ 8 ] , 4 ) ; 
line 43428: } else { 
line 43429: assert ( leafCorrection == 4 ) ; 
line 43430: if ( szCell [ nCell ] < 4 ) { 
line 43432: szCell [ nCell ] = 4 ; 
line 43433: } 
line 43434: } 
line 43435: nCell ++ ; 
line 43436: } 
line 43437: } 
line 43455: usableSpace = pBt -> usableSize - 12 + leafCorrection ; 
line 43456: for ( subtotal = k = i = 0 ; i < nCell ; i ++ ) { 
line 43457: assert ( i < nMaxCells ) ; 
line 43458: subtotal += szCell [ i ] + 2 ; 
line 43459: if ( subtotal > usableSpace ) { 
line 43460: szNew [ k ] = subtotal - szCell [ i ] ; 
line 43461: cntNew [ k ] = i ; 
line 43462: if ( leafData ) { i -- ; } 
line 43463: subtotal = 0 ; 
line 43464: k ++ ; 
line 43465: if ( k > NB + 1 ) { rc = SQLITE_CORRUPT ; goto balance_cleanup ; } 
line 43466: } 
line 43467: } 
line 43468: szNew [ k ] = subtotal ; 
line 43469: cntNew [ k ] = nCell ; 
line 43470: k ++ ; 
line 43482: for ( i = k - 1 ; i > 0 ; i -- ) { 
line 43483: int szRight = szNew [ i ] ; 
line 43484: int szLeft = szNew [ i - 1 ] ; 
line 43485: int r ; 
line 43486: int d ; 
line 43488: r = cntNew [ i - 1 ] - 1 ; 
line 43489: d = r + 1 - leafData ; 
line 43490: assert ( d < nMaxCells ) ; 
line 43491: assert ( r < nMaxCells ) ; 
line 43492: while ( szRight == 0 || szRight + szCell [ d ] + 2 <= szLeft - ( szCell [ r ] + 2 ) ) { 
line 43493: szRight += szCell [ d ] + 2 ; 
line 43494: szLeft -= szCell [ r ] + 2 ; 
line 43495: cntNew [ i - 1 ] -- ; 
line 43496: r = cntNew [ i - 1 ] - 1 ; 
line 43497: d = r + 1 - leafData ; 
line 43498: } 
line 43499: szNew [ i ] = szRight ; 
line 43500: szNew [ i - 1 ] = szLeft ; 
line 43501: } 
line 43507: assert ( cntNew [ 0 ] > 0 || ( pParent -> pgno == 1 && pParent -> nCell == 0 ) ) ; 
line 43509: TRACE ( ( "BALANCE: old: %d %d %d  " , 
line 43510: apOld [ 0 ] -> pgno , 
line 43511: nOld >= 2 ? apOld [ 1 ] -> pgno : 0 , 
line 43512: nOld >= 3 ? apOld [ 2 ] -> pgno : 0 
line 43513: ) ) ; 
line 43518: if ( apOld [ 0 ] -> pgno <= 1 ) { 
line 43519: rc = SQLITE_CORRUPT ; 
line 43520: goto balance_cleanup ; 
line 43521: } 
line 43522: pageFlags = apOld [ 0 ] -> aData [ 0 ] ; 
line 43523: for ( i = 0 ; i < k ; i ++ ) { 
line 43524: MemPage * pNew ; 
line 43525: if ( i < nOld ) { 
line 43526: pNew = apNew [ i ] = apOld [ i ] ; 
line 43527: apOld [ i ] = 0 ; 
line 43528: rc = sqlite3PagerWrite ( pNew -> pDbPage ) ; 
line 43529: nNew ++ ; 
line 43530: if ( rc ) goto balance_cleanup ; 
line 43531: } else { 
line 43532: assert ( i > 0 ) ; 
line 43533: rc = allocateBtreePage ( pBt , & pNew , & pgno , pgno , 0 ) ; 
line 43534: if ( rc ) goto balance_cleanup ; 
line 43535: apNew [ i ] = pNew ; 
line 43536: nNew ++ ; 
line 43539: if ( ISAUTOVACUUM ) { 
line 43540: ptrmapPut ( pBt , pNew -> pgno , PTRMAP_BTREE , pParent -> pgno , & rc ) ; 
line 43541: if ( rc != SQLITE_OK ) { 
line 43542: goto balance_cleanup ; 
line 43543: } 
line 43544: } 
line 43545: } 
line 43546: } 
line 43550: while ( i < nOld ) { 
line 43551: freePage ( apOld [ i ] , & rc ) ; 
line 43552: if ( rc ) goto balance_cleanup ; 
line 43553: releasePage ( apOld [ i ] ) ; 
line 43554: apOld [ i ] = 0 ; 
line 43555: i ++ ; 
line 43556: } 
line 43572: for ( i = 0 ; i < k - 1 ; i ++ ) { 
line 43573: int minV = apNew [ i ] -> pgno ; 
line 43574: int minI = i ; 
line 43575: for ( j = i + 1 ; j < k ; j ++ ) { 
line 43576: if ( apNew [ j ] -> pgno < ( unsigned ) minV ) { 
line 43577: minI = j ; 
line 43578: minV = apNew [ j ] -> pgno ; 
line 43579: } 
line 43580: } 
line 43581: if ( minI > i ) { 
line 43582: int t ; 
line 43583: MemPage * pT ; 
line 43584: t = apNew [ i ] -> pgno ; 
line 43585: pT = apNew [ i ] ; 
line 43586: apNew [ i ] = apNew [ minI ] ; 
line 43587: apNew [ minI ] = pT ; 
line 43588: } 
line 43589: } 
line 43590: TRACE ( ( "new: %d(%d) %d(%d) %d(%d) %d(%d) %d(%d)\n" , 
line 43591: apNew [ 0 ] -> pgno , szNew [ 0 ] , 
line 43592: nNew >= 2 ? apNew [ 1 ] -> pgno : 0 , nNew >= 2 ? szNew [ 1 ] : 0 , 
line 43593: nNew >= 3 ? apNew [ 2 ] -> pgno : 0 , nNew >= 3 ? szNew [ 2 ] : 0 , 
line 43594: nNew >= 4 ? apNew [ 3 ] -> pgno : 0 , nNew >= 4 ? szNew [ 3 ] : 0 , 
line 43595: nNew >= 5 ? apNew [ 4 ] -> pgno : 0 , nNew >= 5 ? szNew [ 4 ] : 0 ) ) ; 
line 43597: assert ( sqlite3PagerIswriteable ( pParent -> pDbPage ) ) ; 
line 43598: put4byte ( pRight , apNew [ nNew - 1 ] -> pgno ) ; 
line 43604: j = 0 ; 
line 43605: for ( i = 0 ; i < nNew ; i ++ ) { 
line 43607: MemPage * pNew = apNew [ i ] ; 
line 43608: assert ( j < nMaxCells ) ; 
line 43609: zeroPage ( pNew , pageFlags ) ; 
line 43610: assemblePage ( pNew , cntNew [ i ] - j , & apCell [ j ] , & szCell [ j ] ) ; 
line 43611: assert ( pNew -> nCell > 0 || ( nNew == 1 && cntNew [ 0 ] == 0 ) ) ; 
line 43612: assert ( pNew -> nOverflow == 0 ) ; 
line 43614: j = cntNew [ i ] ; 
line 43619: assert ( i < nNew - 1 || j == nCell ) ; 
line 43620: if ( j < nCell ) { 
line 43621: u8 * pCell ; 
line 43622: u8 * pTemp ; 
line 43623: int sz ; 
line 43625: assert ( j < nMaxCells ) ; 
line 43626: pCell = apCell [ j ] ; 
line 43627: sz = szCell [ j ] + leafCorrection ; 
line 43628: pTemp = & aOvflSpace [ iOvflSpace ] ; 
line 43629: if ( ! pNew -> leaf ) { 
line 43630: memcpy ( & pNew -> aData [ 8 ] , pCell , 4 ) ; 
line 43631: } else if ( leafData ) { 
line 43637: CellInfo info ; 
line 43638: j -- ; 
line 43639: btreeParseCellPtr ( pNew , apCell [ j ] , & info ) ; 
line 43640: pCell = pTemp ; 
line 43641: sz = 4 + putVarint ( & pCell [ 4 ] , info . nKey ) ; 
line 43642: pTemp = 0 ; 
line 43643: } else { 
line 43644: pCell -= 4 ; 
line 43656: if ( szCell [ j ] == 4 ) { 
line 43657: assert ( leafCorrection == 4 ) ; 
line 43658: sz = cellSizePtr ( pParent , pCell ) ; 
line 43659: } 
line 43660: } 
line 43661: iOvflSpace += sz ; 
line 43662: assert ( sz <= pBt -> pageSize / 4 ) ; 
line 43663: assert ( iOvflSpace <= pBt -> pageSize ) ; 
line 43664: insertCell ( pParent , nxDiv , pCell , sz , pTemp , pNew -> pgno , & rc ) ; 
line 43665: if ( rc != SQLITE_OK ) goto balance_cleanup ; 
line 43666: assert ( sqlite3PagerIswriteable ( pParent -> pDbPage ) ) ; 
line 43668: j ++ ; 
line 43669: nxDiv ++ ; 
line 43670: } 
line 43671: } 
line 43672: assert ( j == nCell ) ; 
line 43673: assert ( nOld > 0 ) ; 
line 43674: assert ( nNew > 0 ) ; 
line 43675: if ( ( pageFlags & PTF_LEAF ) == 0 ) { 
line 43676: u8 * zChild = & apCopy [ nOld - 1 ] -> aData [ 8 ] ; 
line 43677: memcpy ( & apNew [ nNew - 1 ] -> aData [ 8 ] , zChild , 4 ) ; 
line 43678: } 
line 43680: if ( isRoot && pParent -> nCell == 0 && pParent -> hdrOffset <= apNew [ 0 ] -> nFree ) { 
line 43695: assert ( nNew == 1 ) ; 
line 43696: assert ( apNew [ 0 ] -> nFree == 
line 43697: ( get2byte ( & apNew [ 0 ] -> aData [ 5 ] ) - apNew [ 0 ] -> cellOffset - apNew [ 0 ] -> nCell * 2 ) 
line 43698: ) ; 
line 43699: copyNodeContent ( apNew [ 0 ] , pParent , & rc ) ; 
line 43700: freePage ( apNew [ 0 ] , & rc ) ; 
line 43701: } else if ( ISAUTOVACUUM ) { 
line 43733: MemPage * pNew = apNew [ 0 ] ; 
line 43734: MemPage * pOld = apCopy [ 0 ] ; 
line 43735: int nOverflow = pOld -> nOverflow ; 
line 43736: int iNextOld = pOld -> nCell + nOverflow ; 
line 43737: int iOverflow = ( nOverflow ? pOld -> aOvfl [ 0 ] . idx : - 1 ) ; 
line 43738: j = 0 ; 
line 43739: k = 0 ; 
line 43740: for ( i = 0 ; i < nCell ; i ++ ) { 
line 43741: int isDivider = 0 ; 
line 43742: while ( i == iNextOld ) { 
line 43746: pOld = apCopy [ ++ j ] ; 
line 43747: iNextOld = i + ! leafData + pOld -> nCell + pOld -> nOverflow ; 
line 43748: if ( pOld -> nOverflow ) { 
line 43749: nOverflow = pOld -> nOverflow ; 
line 43750: iOverflow = i + ! leafData + pOld -> aOvfl [ 0 ] . idx ; 
line 43751: } 
line 43752: isDivider = ! leafData ; 
line 43753: } 
line 43755: assert ( nOverflow > 0 || iOverflow < i ) ; 
line 43756: assert ( nOverflow < 2 || pOld -> aOvfl [ 0 ] . idx == pOld -> aOvfl [ 1 ] . idx - 1 ) ; 
line 43757: assert ( nOverflow < 3 || pOld -> aOvfl [ 1 ] . idx == pOld -> aOvfl [ 2 ] . idx - 1 ) ; 
line 43758: if ( i == iOverflow ) { 
line 43759: isDivider = 1 ; 
line 43760: if ( ( -- nOverflow ) > 0 ) { 
line 43761: iOverflow ++ ; 
line 43762: } 
line 43763: } 
line 43765: if ( i == cntNew [ k ] ) { 
line 43769: pNew = apNew [ ++ k ] ; 
line 43770: if ( ! leafData ) continue ; 
line 43771: } 
line 43772: assert ( j < nOld ) ; 
line 43773: assert ( k < nNew ) ; 
line 43779: if ( isDivider || pOld -> pgno != pNew -> pgno ) { 
line 43780: if ( ! leafCorrection ) { 
line 43781: ptrmapPut ( pBt , get4byte ( apCell [ i ] ) , PTRMAP_BTREE , pNew -> pgno , & rc ) ; 
line 43782: } 
line 43783: if ( szCell [ i ] > pNew -> minLocal ) { 
line 43784: ptrmapPutOvflPtr ( pNew , apCell [ i ] , & rc ) ; 
line 43785: } 
line 43786: } 
line 43787: } 
line 43789: if ( ! leafCorrection ) { 
line 43790: for ( i = 0 ; i < nNew ; i ++ ) { 
line 43791: u32 key = get4byte ( & apNew [ i ] -> aData [ 8 ] ) ; 
line 43792: ptrmapPut ( pBt , key , PTRMAP_BTREE , apNew [ i ] -> pgno , & rc ) ; 
line 43793: } 
line 43794: } 
line 43796: # if 0 
line 43801: ptrmapCheckPages ( apNew , nNew ) ; 
line 43802: ptrmapCheckPages ( & pParent , 1 ) ; 
line 43803: # endif 
line 43804: } 
line 43806: assert ( pParent -> isInit ) ; 
line 43807: TRACE ( ( "BALANCE: finished: old=%d new=%d cells=%d\n" , 
line 43808: nOld , nNew , nCell ) ) ; 
line 43813: balance_cleanup : 
line 43814: sqlite3ScratchFree ( apCell ) ; 
line 43815: for ( i = 0 ; i < nOld ; i ++ ) { 
line 43816: releasePage ( apOld [ i ] ) ; 
line 43817: } 
line 43818: for ( i = 0 ; i < nNew ; i ++ ) { 
line 43819: releasePage ( apNew [ i ] ) ; 
line 43820: } 
line 43822: return rc ; 
line 43823: } 
line 43845: static int balance_deeper ( MemPage * pRoot , MemPage * * ppChild ) { 
line 43846: int rc ; 
line 43847: MemPage * pChild = 0 ; 
line 43848: Pgno pgnoChild = 0 ; 
line 43849: BtShared * pBt = pRoot -> pBt ; 
line 43851: assert ( pRoot -> nOverflow > 0 ) ; 
line 43852: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 43858: rc = sqlite3PagerWrite ( pRoot -> pDbPage ) ; 
line 43859: if ( rc == SQLITE_OK ) { 
line 43860: rc = allocateBtreePage ( pBt , & pChild , & pgnoChild , pRoot -> pgno , 0 ) ; 
line 43861: copyNodeContent ( pRoot , pChild , & rc ) ; 
line 43862: if ( ISAUTOVACUUM ) { 
line 43863: ptrmapPut ( pBt , pgnoChild , PTRMAP_BTREE , pRoot -> pgno , & rc ) ; 
line 43864: } 
line 43865: } 
line 43866: if ( rc ) { 
line 43867: * ppChild = 0 ; 
line 43868: releasePage ( pChild ) ; 
line 43869: return rc ; 
line 43870: } 
line 43871: assert ( sqlite3PagerIswriteable ( pChild -> pDbPage ) ) ; 
line 43872: assert ( sqlite3PagerIswriteable ( pRoot -> pDbPage ) ) ; 
line 43873: assert ( pChild -> nCell == pRoot -> nCell ) ; 
line 43875: TRACE ( ( "BALANCE: copy root %d into %d\n" , pRoot -> pgno , pChild -> pgno ) ) ; 
line 43878: memcpy ( pChild -> aOvfl , pRoot -> aOvfl , pRoot -> nOverflow * sizeof ( pRoot -> aOvfl [ 0 ] ) ) ; 
line 43879: pChild -> nOverflow = pRoot -> nOverflow ; 
line 43882: zeroPage ( pRoot , pChild -> aData [ 0 ] & ~ PTF_LEAF ) ; 
line 43883: put4byte ( & pRoot -> aData [ pRoot -> hdrOffset + 8 ] , pgnoChild ) ; 
line 43885: * ppChild = pChild ; 
line 43886: return SQLITE_OK ; 
line 43887: } 
line 43899: static int balance ( BtCursor * pCur ) { 
line 43900: int rc = SQLITE_OK ; 
line 43901: const int nMin = pCur -> pBt -> usableSize * 2 / 3 ; 
line 43902: u8 aBalanceQuickSpace [ 13 ] ; 
line 43903: u8 * pFree = 0 ; 
line 43905: TESTONLY ( int balance_quick_called = 0 ) ; 
line 43906: TESTONLY ( int balance_deeper_called = 0 ) ; 
line 43908: do { 
line 43909: int iPage = pCur -> iPage ; 
line 43910: MemPage * pPage = pCur -> apPage [ iPage ] ; 
line 43912: if ( iPage == 0 ) { 
line 43913: if ( pPage -> nOverflow ) { 
line 43919: assert ( ( balance_deeper_called ++ ) == 0 ) ; 
line 43920: rc = balance_deeper ( pPage , & pCur -> apPage [ 1 ] ) ; 
line 43921: if ( rc == SQLITE_OK ) { 
line 43922: pCur -> iPage = 1 ; 
line 43923: pCur -> aiIdx [ 0 ] = 0 ; 
line 43924: pCur -> aiIdx [ 1 ] = 0 ; 
line 43925: assert ( pCur -> apPage [ 1 ] -> nOverflow ) ; 
line 43926: } 
line 43927: } else { 
line 43928: break ; 
line 43929: } 
line 43930: } else if ( pPage -> nOverflow == 0 && pPage -> nFree <= nMin ) { 
line 43931: break ; 
line 43932: } else { 
line 43933: MemPage * const pParent = pCur -> apPage [ iPage - 1 ] ; 
line 43934: int const iIdx = pCur -> aiIdx [ iPage - 1 ] ; 
line 43936: rc = sqlite3PagerWrite ( pParent -> pDbPage ) ; 
line 43937: if ( rc == SQLITE_OK ) { 
line 43938: # ifndef SQLITE_OMIT_QUICKBALANCE 
line 43939: if ( pPage -> hasData 
line 43940: && pPage -> nOverflow == 1 
line 43941: && pPage -> aOvfl [ 0 ] . idx == pPage -> nCell 
line 43942: && pParent -> pgno != 1 
line 43943: && pParent -> nCell == iIdx 
line 43944: ) { 
line 43958: assert ( ( balance_quick_called ++ ) == 0 ) ; 
line 43959: rc = balance_quick ( pParent , pPage , aBalanceQuickSpace ) ; 
line 43960: } else 
line 43961: # endif 
line 43962: { 
line 43980: u8 * pSpace = sqlite3PageMalloc ( pCur -> pBt -> pageSize ) ; 
line 43981: rc = balance_nonroot ( pParent , iIdx , pSpace , iPage == 1 ) ; 
line 43982: if ( pFree ) { 
line 43987: sqlite3PageFree ( pFree ) ; 
line 43988: } 
line 43993: pFree = pSpace ; 
line 43994: } 
line 43995: } 
line 43997: pPage -> nOverflow = 0 ; 
line 44000: releasePage ( pPage ) ; 
line 44001: pCur -> iPage -- ; 
line 44002: } 
line 44003: } while ( rc == SQLITE_OK ) ; 
line 44005: if ( pFree ) { 
line 44006: sqlite3PageFree ( pFree ) ; 
line 44007: } 
line 44008: return rc ; 
line 44009: } 
line 44034: SQLITE_PRIVATE int sqlite3BtreeInsert ( 
line 44035: BtCursor * pCur , 
line 44036: const void * pKey , i64 nKey , 
line 44037: const void * pData , int nData , 
line 44038: int nZero , 
line 44039: int appendBias , 
line 44040: int seekResult 
line 44041: ) { 
line 44042: int rc ; 
line 44043: int loc = seekResult ; 
line 44044: int szNew = 0 ; 
line 44045: int idx ; 
line 44046: MemPage * pPage ; 
line 44047: Btree * p = pCur -> pBtree ; 
line 44048: BtShared * pBt = p -> pBt ; 
line 44049: unsigned char * oldCell ; 
line 44050: unsigned char * newCell = 0 ; 
line 44052: if ( pCur -> eState == CURSOR_FAULT ) { 
line 44053: assert ( pCur -> skipNext != SQLITE_OK ) ; 
line 44054: return pCur -> skipNext ; 
line 44055: } 
line 44057: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 44058: assert ( pCur -> wrFlag && pBt -> inTransaction == TRANS_WRITE && ! pBt -> readOnly ) ; 
line 44059: assert ( hasSharedCacheTableLock ( p , pCur -> pgnoRoot , pCur -> pKeyInfo != 0 , 2 ) ) ; 
line 44066: assert ( ( pKey == 0 ) == ( pCur -> pKeyInfo == 0 ) ) ; 
line 44071: if ( pCur -> pKeyInfo == 0 ) { 
line 44072: invalidateIncrblobCursors ( p , nKey , 0 ) ; 
line 44073: } 
line 44086: rc = saveAllCursors ( pBt , pCur -> pgnoRoot , pCur ) ; 
line 44087: if ( rc ) return rc ; 
line 44088: if ( ! loc ) { 
line 44089: rc = btreeMoveto ( pCur , pKey , nKey , appendBias , & loc ) ; 
line 44090: if ( rc ) return rc ; 
line 44091: } 
line 44092: assert ( pCur -> eState == CURSOR_VALID || ( pCur -> eState == CURSOR_INVALID && loc ) ) ; 
line 44094: pPage = pCur -> apPage [ pCur -> iPage ] ; 
line 44095: assert ( pPage -> intKey || nKey >= 0 ) ; 
line 44096: assert ( pPage -> leaf || ! pPage -> intKey ) ; 
line 44098: TRACE ( ( "INSERT: table=%d nkey=%lld ndata=%d page=%d %s\n" , 
line 44099: pCur -> pgnoRoot , nKey , nData , pPage -> pgno , 
line 44100: loc == 0 ? "overwrite" : "new entry" ) ) ; 
line 44101: assert ( pPage -> isInit ) ; 
line 44102: allocateTempSpace ( pBt ) ; 
line 44103: newCell = pBt -> pTmpSpace ; 
line 44104: if ( newCell == 0 ) return SQLITE_NOMEM ; 
line 44105: rc = fillInCell ( pPage , newCell , pKey , nKey , pData , nData , nZero , & szNew ) ; 
line 44106: if ( rc ) goto end_insert ; 
line 44107: assert ( szNew == cellSizePtr ( pPage , newCell ) ) ; 
line 44108: assert ( szNew <= MX_CELL_SIZE ( pBt ) ) ; 
line 44109: idx = pCur -> aiIdx [ pCur -> iPage ] ; 
line 44110: if ( loc == 0 ) { 
line 44111: u16 szOld ; 
line 44112: assert ( idx < pPage -> nCell ) ; 
line 44113: rc = sqlite3PagerWrite ( pPage -> pDbPage ) ; 
line 44114: if ( rc ) { 
line 44115: goto end_insert ; 
line 44116: } 
line 44117: oldCell = findCell ( pPage , idx ) ; 
line 44118: if ( ! pPage -> leaf ) { 
line 44119: memcpy ( newCell , oldCell , 4 ) ; 
line 44120: } 
line 44121: szOld = cellSizePtr ( pPage , oldCell ) ; 
line 44122: rc = clearCell ( pPage , oldCell ) ; 
line 44123: dropCell ( pPage , idx , szOld , & rc ) ; 
line 44124: if ( rc ) goto end_insert ; 
line 44125: } else if ( loc < 0 && pPage -> nCell > 0 ) { 
line 44126: assert ( pPage -> leaf ) ; 
line 44127: idx = ++ pCur -> aiIdx [ pCur -> iPage ] ; 
line 44128: } else { 
line 44129: assert ( pPage -> leaf ) ; 
line 44130: } 
line 44131: insertCell ( pPage , idx , newCell , szNew , 0 , 0 , & rc ) ; 
line 44132: assert ( rc != SQLITE_OK || pPage -> nCell > 0 || pPage -> nOverflow > 0 ) ; 
line 44154: pCur -> info . nSize = 0 ; 
line 44155: pCur -> validNKey = 0 ; 
line 44156: if ( rc == SQLITE_OK && pPage -> nOverflow ) { 
line 44157: rc = balance ( pCur ) ; 
line 44163: pCur -> apPage [ pCur -> iPage ] -> nOverflow = 0 ; 
line 44164: pCur -> eState = CURSOR_INVALID ; 
line 44165: } 
line 44166: assert ( pCur -> apPage [ pCur -> iPage ] -> nOverflow == 0 ) ; 
line 44168: end_insert : 
line 44169: return rc ; 
line 44170: } 
line 44176: SQLITE_PRIVATE int sqlite3BtreeDelete ( BtCursor * pCur ) { 
line 44177: Btree * p = pCur -> pBtree ; 
line 44178: BtShared * pBt = p -> pBt ; 
line 44179: int rc ; 
line 44180: MemPage * pPage ; 
line 44181: unsigned char * pCell ; 
line 44182: int iCellIdx ; 
line 44183: int iCellDepth ; 
line 44185: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 44186: assert ( pBt -> inTransaction == TRANS_WRITE ) ; 
line 44187: assert ( ! pBt -> readOnly ) ; 
line 44188: assert ( pCur -> wrFlag ) ; 
line 44189: assert ( hasSharedCacheTableLock ( p , pCur -> pgnoRoot , pCur -> pKeyInfo != 0 , 2 ) ) ; 
line 44190: assert ( ! hasReadConflicts ( p , pCur -> pgnoRoot ) ) ; 
line 44192: if ( NEVER ( pCur -> aiIdx [ pCur -> iPage ] >= pCur -> apPage [ pCur -> iPage ] -> nCell ) 
line 44193: || NEVER ( pCur -> eState != CURSOR_VALID ) 
line 44194: ) { 
line 44195: return SQLITE_ERROR ; 
line 44196: } 
line 44200: if ( pCur -> pKeyInfo == 0 ) { 
line 44201: invalidateIncrblobCursors ( p , pCur -> info . nKey , 0 ) ; 
line 44202: } 
line 44204: iCellDepth = pCur -> iPage ; 
line 44205: iCellIdx = pCur -> aiIdx [ iCellDepth ] ; 
line 44206: pPage = pCur -> apPage [ iCellDepth ] ; 
line 44207: pCell = findCell ( pPage , iCellIdx ) ; 
line 44216: if ( ! pPage -> leaf ) { 
line 44217: int notUsed ; 
line 44218: rc = sqlite3BtreePrevious ( pCur , & notUsed ) ; 
line 44219: if ( rc ) return rc ; 
line 44220: } 
line 44227: rc = saveAllCursors ( pBt , pCur -> pgnoRoot , pCur ) ; 
line 44228: if ( rc ) return rc ; 
line 44229: rc = sqlite3PagerWrite ( pPage -> pDbPage ) ; 
line 44230: if ( rc ) return rc ; 
line 44231: rc = clearCell ( pPage , pCell ) ; 
line 44232: dropCell ( pPage , iCellIdx , cellSizePtr ( pPage , pCell ) , & rc ) ; 
line 44233: if ( rc ) return rc ; 
line 44240: if ( ! pPage -> leaf ) { 
line 44241: MemPage * pLeaf = pCur -> apPage [ pCur -> iPage ] ; 
line 44242: int nCell ; 
line 44243: Pgno n = pCur -> apPage [ iCellDepth + 1 ] -> pgno ; 
line 44244: unsigned char * pTmp ; 
line 44246: pCell = findCell ( pLeaf , pLeaf -> nCell - 1 ) ; 
line 44247: nCell = cellSizePtr ( pLeaf , pCell ) ; 
line 44248: assert ( MX_CELL_SIZE ( pBt ) >= nCell ) ; 
line 44250: allocateTempSpace ( pBt ) ; 
line 44251: pTmp = pBt -> pTmpSpace ; 
line 44253: rc = sqlite3PagerWrite ( pLeaf -> pDbPage ) ; 
line 44254: insertCell ( pPage , iCellIdx , pCell - 4 , nCell + 4 , pTmp , n , & rc ) ; 
line 44255: dropCell ( pLeaf , pLeaf -> nCell - 1 , nCell , & rc ) ; 
line 44256: if ( rc ) return rc ; 
line 44257: } 
line 44274: rc = balance ( pCur ) ; 
line 44275: if ( rc == SQLITE_OK && pCur -> iPage > iCellDepth ) { 
line 44276: while ( pCur -> iPage > iCellDepth ) { 
line 44277: releasePage ( pCur -> apPage [ pCur -> iPage -- ] ) ; 
line 44278: } 
line 44279: rc = balance ( pCur ) ; 
line 44280: } 
line 44282: if ( rc == SQLITE_OK ) { 
line 44283: moveToRoot ( pCur ) ; 
line 44284: } 
line 44285: return rc ; 
line 44286: } 
line 44299: static int btreeCreateTable ( Btree * p , int * piTable , int flags ) { 
line 44300: BtShared * pBt = p -> pBt ; 
line 44301: MemPage * pRoot ; 
line 44302: Pgno pgnoRoot ; 
line 44303: int rc ; 
line 44305: assert ( sqlite3BtreeHoldsMutex ( p ) ) ; 
line 44306: assert ( pBt -> inTransaction == TRANS_WRITE ) ; 
line 44307: assert ( ! pBt -> readOnly ) ; 
line 44309: # ifdef SQLITE_OMIT_AUTOVACUUM 
line 44310: rc = allocateBtreePage ( pBt , & pRoot , & pgnoRoot , 1 , 0 ) ; 
line 44311: if ( rc ) { 
line 44312: return rc ; 
line 44313: } 
line 44314: # else 
line 44315: if ( pBt -> autoVacuum ) { 
line 44316: Pgno pgnoMove ; 
line 44317: MemPage * pPageMove ; 
line 44324: invalidateAllOverflowCache ( pBt ) ; 
line 44330: sqlite3BtreeGetMeta ( p , BTREE_LARGEST_ROOT_PAGE , & pgnoRoot ) ; 
line 44331: pgnoRoot ++ ; 
line 44336: while ( pgnoRoot == PTRMAP_PAGENO ( pBt , pgnoRoot ) || 
line 44337: pgnoRoot == PENDING_BYTE_PAGE ( pBt ) ) { 
line 44338: pgnoRoot ++ ; 
line 44339: } 
line 44340: assert ( pgnoRoot >= 3 ) ; 
line 44346: rc = allocateBtreePage ( pBt , & pPageMove , & pgnoMove , pgnoRoot , 1 ) ; 
line 44347: if ( rc != SQLITE_OK ) { 
line 44348: return rc ; 
line 44349: } 
line 44351: if ( pgnoMove != pgnoRoot ) { 
line 44358: u8 eType = 0 ; 
line 44359: Pgno iPtrPage = 0 ; 
line 44361: releasePage ( pPageMove ) ; 
line 44364: rc = btreeGetPage ( pBt , pgnoRoot , & pRoot , 0 ) ; 
line 44365: if ( rc != SQLITE_OK ) { 
line 44366: return rc ; 
line 44367: } 
line 44368: rc = ptrmapGet ( pBt , pgnoRoot , & eType , & iPtrPage ) ; 
line 44369: if ( eType == PTRMAP_ROOTPAGE || eType == PTRMAP_FREEPAGE ) { 
line 44370: rc = SQLITE_CORRUPT_BKPT ; 
line 44371: } 
line 44372: if ( rc != SQLITE_OK ) { 
line 44373: releasePage ( pRoot ) ; 
line 44374: return rc ; 
line 44375: } 
line 44376: assert ( eType != PTRMAP_ROOTPAGE ) ; 
line 44377: assert ( eType != PTRMAP_FREEPAGE ) ; 
line 44378: rc = relocatePage ( pBt , pRoot , eType , iPtrPage , pgnoMove , 0 ) ; 
line 44379: releasePage ( pRoot ) ; 
line 44382: if ( rc != SQLITE_OK ) { 
line 44383: return rc ; 
line 44384: } 
line 44385: rc = btreeGetPage ( pBt , pgnoRoot , & pRoot , 0 ) ; 
line 44386: if ( rc != SQLITE_OK ) { 
line 44387: return rc ; 
line 44388: } 
line 44389: rc = sqlite3PagerWrite ( pRoot -> pDbPage ) ; 
line 44390: if ( rc != SQLITE_OK ) { 
line 44391: releasePage ( pRoot ) ; 
line 44392: return rc ; 
line 44393: } 
line 44394: } else { 
line 44395: pRoot = pPageMove ; 
line 44396: } 
line 44399: ptrmapPut ( pBt , pgnoRoot , PTRMAP_ROOTPAGE , 0 , & rc ) ; 
line 44400: if ( rc ) { 
line 44401: releasePage ( pRoot ) ; 
line 44402: return rc ; 
line 44403: } 
line 44404: rc = sqlite3BtreeUpdateMeta ( p , 4 , pgnoRoot ) ; 
line 44405: if ( rc ) { 
line 44406: releasePage ( pRoot ) ; 
line 44407: return rc ; 
line 44408: } 
line 44410: } else { 
line 44411: rc = allocateBtreePage ( pBt , & pRoot , & pgnoRoot , 1 , 0 ) ; 
line 44412: if ( rc ) return rc ; 
line 44413: } 
line 44414: # endif 
line 44415: assert ( sqlite3PagerIswriteable ( pRoot -> pDbPage ) ) ; 
line 44416: zeroPage ( pRoot , flags | PTF_LEAF ) ; 
line 44417: sqlite3PagerUnref ( pRoot -> pDbPage ) ; 
line 44418: * piTable = ( int ) pgnoRoot ; 
line 44419: return SQLITE_OK ; 
line 44420: } 
line 44421: SQLITE_PRIVATE int sqlite3BtreeCreateTable ( Btree * p , int * piTable , int flags ) { 
line 44422: int rc ; 
line 44423: sqlite3BtreeEnter ( p ) ; 
line 44424: rc = btreeCreateTable ( p , piTable , flags ) ; 
line 44425: sqlite3BtreeLeave ( p ) ; 
line 44426: return rc ; 
line 44427: } 
line 44433: static int clearDatabasePage ( 
line 44434: BtShared * pBt , 
line 44435: Pgno pgno , 
line 44436: int freePageFlag , 
line 44437: int * pnChange 
line 44438: ) { 
line 44439: MemPage * pPage ; 
line 44440: int rc ; 
line 44441: unsigned char * pCell ; 
line 44442: int i ; 
line 44444: assert ( sqlite3_mutex_held ( pBt -> mutex ) ) ; 
line 44445: if ( pgno > pagerPagecount ( pBt ) ) { 
line 44446: return SQLITE_CORRUPT_BKPT ; 
line 44447: } 
line 44449: rc = getAndInitPage ( pBt , pgno , & pPage ) ; 
line 44450: if ( rc ) return rc ; 
line 44451: for ( i = 0 ; i < pPage -> nCell ; i ++ ) { 
line 44452: pCell = findCell ( pPage , i ) ; 
line 44453: if ( ! pPage -> leaf ) { 
line 44454: rc = clearDatabasePage ( pBt , get4byte ( pCell ) , 1 , pnChange ) ; 
line 44455: if ( rc ) goto cleardatabasepage_out ; 
line 44456: } 
line 44457: rc = clearCell ( pPage , pCell ) ; 
line 44458: if ( rc ) goto cleardatabasepage_out ; 
line 44459: } 
line 44460: if ( ! pPage -> leaf ) { 
line 44461: rc = clearDatabasePage ( pBt , get4byte ( & pPage -> aData [ 8 ] ) , 1 , pnChange ) ; 
line 44462: if ( rc ) goto cleardatabasepage_out ; 
line 44463: } else if ( pnChange ) { 
line 44464: assert ( pPage -> intKey ) ; 
line 44465: * pnChange += pPage -> nCell ; 
line 44466: } 
line 44467: if ( freePageFlag ) { 
line 44468: freePage ( pPage , & rc ) ; 
line 44469: } else if ( ( rc = sqlite3PagerWrite ( pPage -> pDbPage ) ) == 0 ) { 
line 44470: zeroPage ( pPage , pPage -> aData [ 0 ] | PTF_LEAF ) ; 
line 44471: } 
line 44473: cleardatabasepage_out : 
line 44474: releasePage ( pPage ) ; 
line 44475: return rc ; 
line 44476: } 
line 44491: SQLITE_PRIVATE int sqlite3BtreeClearTable ( Btree * p , int iTable , int * pnChange ) { 
line 44492: int rc ; 
line 44493: BtShared * pBt = p -> pBt ; 
line 44494: sqlite3BtreeEnter ( p ) ; 
line 44495: assert ( p -> inTrans == TRANS_WRITE ) ; 
line 44500: invalidateIncrblobCursors ( p , 0 , 1 ) ; 
line 44502: rc = saveAllCursors ( pBt , ( Pgno ) iTable , 0 ) ; 
line 44503: if ( SQLITE_OK == rc ) { 
line 44504: rc = clearDatabasePage ( pBt , ( Pgno ) iTable , 0 , pnChange ) ; 
line 44505: } 
line 44506: sqlite3BtreeLeave ( p ) ; 
line 44507: return rc ; 
line 44508: } 
line 44530: static int btreeDropTable ( Btree * p , Pgno iTable , int * piMoved ) { 
line 44531: int rc ; 
line 44532: MemPage * pPage = 0 ; 
line 44533: BtShared * pBt = p -> pBt ; 
line 44535: assert ( sqlite3BtreeHoldsMutex ( p ) ) ; 
line 44536: assert ( p -> inTrans == TRANS_WRITE ) ; 
line 44546: if ( NEVER ( pBt -> pCursor ) ) { 
line 44547: sqlite3ConnectionBlocked ( p -> db , pBt -> pCursor -> pBtree -> db ) ; 
line 44548: return SQLITE_LOCKED_SHAREDCACHE ; 
line 44549: } 
line 44551: rc = btreeGetPage ( pBt , ( Pgno ) iTable , & pPage , 0 ) ; 
line 44552: if ( rc ) return rc ; 
line 44553: rc = sqlite3BtreeClearTable ( p , iTable , 0 ) ; 
line 44554: if ( rc ) { 
line 44555: releasePage ( pPage ) ; 
line 44556: return rc ; 
line 44557: } 
line 44559: * piMoved = 0 ; 
line 44561: if ( iTable > 1 ) { 
line 44562: # ifdef SQLITE_OMIT_AUTOVACUUM 
line 44563: freePage ( pPage , & rc ) ; 
line 44564: releasePage ( pPage ) ; 
line 44565: # else 
line 44566: if ( pBt -> autoVacuum ) { 
line 44567: Pgno maxRootPgno ; 
line 44568: sqlite3BtreeGetMeta ( p , BTREE_LARGEST_ROOT_PAGE , & maxRootPgno ) ; 
line 44570: if ( iTable == maxRootPgno ) { 
line 44574: freePage ( pPage , & rc ) ; 
line 44575: releasePage ( pPage ) ; 
line 44576: if ( rc != SQLITE_OK ) { 
line 44577: return rc ; 
line 44578: } 
line 44579: } else { 
line 44584: MemPage * pMove ; 
line 44585: releasePage ( pPage ) ; 
line 44586: rc = btreeGetPage ( pBt , maxRootPgno , & pMove , 0 ) ; 
line 44587: if ( rc != SQLITE_OK ) { 
line 44588: return rc ; 
line 44589: } 
line 44590: rc = relocatePage ( pBt , pMove , PTRMAP_ROOTPAGE , 0 , iTable , 0 ) ; 
line 44591: releasePage ( pMove ) ; 
line 44592: if ( rc != SQLITE_OK ) { 
line 44593: return rc ; 
line 44594: } 
line 44595: pMove = 0 ; 
line 44596: rc = btreeGetPage ( pBt , maxRootPgno , & pMove , 0 ) ; 
line 44597: freePage ( pMove , & rc ) ; 
line 44598: releasePage ( pMove ) ; 
line 44599: if ( rc != SQLITE_OK ) { 
line 44600: return rc ; 
line 44601: } 
line 44602: * piMoved = maxRootPgno ; 
line 44603: } 
line 44610: maxRootPgno -- ; 
line 44611: while ( maxRootPgno == PENDING_BYTE_PAGE ( pBt ) 
line 44612: || PTRMAP_ISPAGE ( pBt , maxRootPgno ) ) { 
line 44613: maxRootPgno -- ; 
line 44614: } 
line 44615: assert ( maxRootPgno != PENDING_BYTE_PAGE ( pBt ) ) ; 
line 44617: rc = sqlite3BtreeUpdateMeta ( p , 4 , maxRootPgno ) ; 
line 44618: } else { 
line 44619: freePage ( pPage , & rc ) ; 
line 44620: releasePage ( pPage ) ; 
line 44621: } 
line 44622: # endif 
line 44623: } else { 
line 44628: zeroPage ( pPage , PTF_INTKEY | PTF_LEAF ) ; 
line 44629: releasePage ( pPage ) ; 
line 44630: } 
line 44631: return rc ; 
line 44632: } 
line 44633: SQLITE_PRIVATE int sqlite3BtreeDropTable ( Btree * p , int iTable , int * piMoved ) { 
line 44634: int rc ; 
line 44635: sqlite3BtreeEnter ( p ) ; 
line 44636: rc = btreeDropTable ( p , iTable , piMoved ) ; 
line 44637: sqlite3BtreeLeave ( p ) ; 
line 44638: return rc ; 
line 44639: } 
line 44655: SQLITE_PRIVATE void sqlite3BtreeGetMeta ( Btree * p , int idx , u32 * pMeta ) { 
line 44656: BtShared * pBt = p -> pBt ; 
line 44658: sqlite3BtreeEnter ( p ) ; 
line 44659: assert ( p -> inTrans > TRANS_NONE ) ; 
line 44660: assert ( SQLITE_OK == querySharedCacheTableLock ( p , MASTER_ROOT , READ_LOCK ) ) ; 
line 44661: assert ( pBt -> pPage1 ) ; 
line 44662: assert ( idx >= 0 && idx <= 15 ) ; 
line 44664: * pMeta = get4byte ( & pBt -> pPage1 -> aData [ 36 + idx * 4 ] ) ; 
line 44668: # ifdef SQLITE_OMIT_AUTOVACUUM 
line 44669: if ( idx == BTREE_LARGEST_ROOT_PAGE && * pMeta > 0 ) pBt -> readOnly = 1 ; 
line 44670: # endif 
line 44672: sqlite3BtreeLeave ( p ) ; 
line 44673: } 
line 44679: SQLITE_PRIVATE int sqlite3BtreeUpdateMeta ( Btree * p , int idx , u32 iMeta ) { 
line 44680: BtShared * pBt = p -> pBt ; 
line 44681: unsigned char * pP1 ; 
line 44682: int rc ; 
line 44683: assert ( idx >= 1 && idx <= 15 ) ; 
line 44684: sqlite3BtreeEnter ( p ) ; 
line 44685: assert ( p -> inTrans == TRANS_WRITE ) ; 
line 44686: assert ( pBt -> pPage1 != 0 ) ; 
line 44687: pP1 = pBt -> pPage1 -> aData ; 
line 44688: rc = sqlite3PagerWrite ( pBt -> pPage1 -> pDbPage ) ; 
line 44689: if ( rc == SQLITE_OK ) { 
line 44690: put4byte ( & pP1 [ 36 + idx * 4 ] , iMeta ) ; 
line 44691: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 44692: if ( idx == BTREE_INCR_VACUUM ) { 
line 44693: assert ( pBt -> autoVacuum || iMeta == 0 ) ; 
line 44694: assert ( iMeta == 0 || iMeta == 1 ) ; 
line 44695: pBt -> incrVacuum = ( u8 ) iMeta ; 
line 44696: } 
line 44697: # endif 
line 44698: } 
line 44699: sqlite3BtreeLeave ( p ) ; 
line 44700: return rc ; 
line 44701: } 
line 44703: # ifndef SQLITE_OMIT_BTREECOUNT 
line 44712: SQLITE_PRIVATE int sqlite3BtreeCount ( BtCursor * pCur , i64 * pnEntry ) { 
line 44713: i64 nEntry = 0 ; 
line 44714: int rc ; 
line 44715: rc = moveToRoot ( pCur ) ; 
line 44720: while ( rc == SQLITE_OK ) { 
line 44721: int iIdx ; 
line 44722: MemPage * pPage ; 
line 44728: pPage = pCur -> apPage [ pCur -> iPage ] ; 
line 44729: if ( pPage -> leaf || ! pPage -> intKey ) { 
line 44730: nEntry += pPage -> nCell ; 
line 44731: } 
line 44743: if ( pPage -> leaf ) { 
line 44744: do { 
line 44745: if ( pCur -> iPage == 0 ) { 
line 44747: * pnEntry = nEntry ; 
line 44748: return SQLITE_OK ; 
line 44749: } 
line 44750: moveToParent ( pCur ) ; 
line 44751: } while ( pCur -> aiIdx [ pCur -> iPage ] >= pCur -> apPage [ pCur -> iPage ] -> nCell ) ; 
line 44753: pCur -> aiIdx [ pCur -> iPage ] ++ ; 
line 44754: pPage = pCur -> apPage [ pCur -> iPage ] ; 
line 44755: } 
line 44760: iIdx = pCur -> aiIdx [ pCur -> iPage ] ; 
line 44761: if ( iIdx == pPage -> nCell ) { 
line 44762: rc = moveToChild ( pCur , get4byte ( & pPage -> aData [ pPage -> hdrOffset + 8 ] ) ) ; 
line 44763: } else { 
line 44764: rc = moveToChild ( pCur , get4byte ( findCell ( pPage , iIdx ) ) ) ; 
line 44765: } 
line 44766: } 
line 44769: return rc ; 
line 44770: } 
line 44771: # endif 
line 44777: SQLITE_PRIVATE Pager * sqlite3BtreePager ( Btree * p ) { 
line 44778: return p -> pBt -> pPager ; 
line 44779: } 
line 44781: # ifndef SQLITE_OMIT_INTEGRITY_CHECK 
line 44785: static void checkAppendMsg ( 
line 44786: IntegrityCk * pCheck , 
line 44787: char * zMsg1 , 
line 44788: const char * zFormat , 
line 44789: ... 
line 44790: ) { 
line 44791: va_list ap ; 
line 44792: if ( ! pCheck -> mxErr ) return ; 
line 44793: pCheck -> mxErr -- ; 
line 44794: pCheck -> nErr ++ ; 
line 44795: va_start ( ap , zFormat ) ; 
line 44796: if ( pCheck -> errMsg . nChar ) { 
line 44797: sqlite3StrAccumAppend ( & pCheck -> errMsg , "\n" , 1 ) ; 
line 44798: } 
line 44799: if ( zMsg1 ) { 
line 44800: sqlite3StrAccumAppend ( & pCheck -> errMsg , zMsg1 , - 1 ) ; 
line 44801: } 
line 44802: sqlite3VXPrintf ( & pCheck -> errMsg , 1 , zFormat , ap ) ; 
line 44803: va_end ( ap ) ; 
line 44804: if ( pCheck -> errMsg . mallocFailed ) { 
line 44805: pCheck -> mallocFailed = 1 ; 
line 44806: } 
line 44807: } 
line 44808: # endif 
line 44810: # ifndef SQLITE_OMIT_INTEGRITY_CHECK 
line 44819: static int checkRef ( IntegrityCk * pCheck , Pgno iPage , char * zContext ) { 
line 44820: if ( iPage == 0 ) return 1 ; 
line 44821: if ( iPage > pCheck -> nPage ) { 
line 44822: checkAppendMsg ( pCheck , zContext , "invalid page number %d" , iPage ) ; 
line 44823: return 1 ; 
line 44824: } 
line 44825: if ( pCheck -> anRef [ iPage ] == 1 ) { 
line 44826: checkAppendMsg ( pCheck , zContext , "2nd reference to page %d" , iPage ) ; 
line 44827: return 1 ; 
line 44828: } 
line 44829: return ( pCheck -> anRef [ iPage ] ++ ) > 1 ; 
line 44830: } 
line 44832: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 44838: static void checkPtrmap ( 
line 44839: IntegrityCk * pCheck , 
line 44840: Pgno iChild , 
line 44841: u8 eType , 
line 44842: Pgno iParent , 
line 44843: char * zContext 
line 44844: ) { 
line 44845: int rc ; 
line 44846: u8 ePtrmapType ; 
line 44847: Pgno iPtrmapParent ; 
line 44849: rc = ptrmapGet ( pCheck -> pBt , iChild , & ePtrmapType , & iPtrmapParent ) ; 
line 44850: if ( rc != SQLITE_OK ) { 
line 44851: if ( rc == SQLITE_NOMEM || rc == SQLITE_IOERR_NOMEM ) pCheck -> mallocFailed = 1 ; 
line 44852: checkAppendMsg ( pCheck , zContext , "Failed to read ptrmap key=%d" , iChild ) ; 
line 44853: return ; 
line 44854: } 
line 44856: if ( ePtrmapType != eType || iPtrmapParent != iParent ) { 
line 44857: checkAppendMsg ( pCheck , zContext , 
line 44858: "Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)" , 
line 44859: iChild , eType , iParent , ePtrmapType , iPtrmapParent ) ; 
line 44860: } 
line 44861: } 
line 44862: # endif 
line 44868: static void checkList ( 
line 44869: IntegrityCk * pCheck , 
line 44870: int isFreeList , 
line 44871: int iPage , 
line 44872: int N , 
line 44873: char * zContext 
line 44874: ) { 
line 44875: int i ; 
line 44876: int expected = N ; 
line 44877: int iFirst = iPage ; 
line 44878: while ( N -- > 0 && pCheck -> mxErr ) { 
line 44879: DbPage * pOvflPage ; 
line 44880: unsigned char * pOvflData ; 
line 44881: if ( iPage < 1 ) { 
line 44882: checkAppendMsg ( pCheck , zContext , 
line 44883: "%d of %d pages missing from overflow list starting at %d" , 
line 44884: N + 1 , expected , iFirst ) ; 
line 44885: break ; 
line 44886: } 
line 44887: if ( checkRef ( pCheck , iPage , zContext ) ) break ; 
line 44888: if ( sqlite3PagerGet ( pCheck -> pPager , ( Pgno ) iPage , & pOvflPage ) ) { 
line 44889: checkAppendMsg ( pCheck , zContext , "failed to get page %d" , iPage ) ; 
line 44890: break ; 
line 44891: } 
line 44892: pOvflData = ( unsigned char * ) sqlite3PagerGetData ( pOvflPage ) ; 
line 44893: if ( isFreeList ) { 
line 44894: int n = get4byte ( & pOvflData [ 4 ] ) ; 
line 44895: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 44896: if ( pCheck -> pBt -> autoVacuum ) { 
line 44897: checkPtrmap ( pCheck , iPage , PTRMAP_FREEPAGE , 0 , zContext ) ; 
line 44898: } 
line 44899: # endif 
line 44900: if ( n > pCheck -> pBt -> usableSize / 4 - 2 ) { 
line 44901: checkAppendMsg ( pCheck , zContext , 
line 44902: "freelist leaf count too big on page %d" , iPage ) ; 
line 44903: N -- ; 
line 44904: } else { 
line 44905: for ( i = 0 ; i < n ; i ++ ) { 
line 44906: Pgno iFreePage = get4byte ( & pOvflData [ 8 + i * 4 ] ) ; 
line 44907: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 44908: if ( pCheck -> pBt -> autoVacuum ) { 
line 44909: checkPtrmap ( pCheck , iFreePage , PTRMAP_FREEPAGE , 0 , zContext ) ; 
line 44910: } 
line 44911: # endif 
line 44912: checkRef ( pCheck , iFreePage , zContext ) ; 
line 44913: } 
line 44914: N -= n ; 
line 44915: } 
line 44916: } 
line 44917: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 44918: else { 
line 44923: if ( pCheck -> pBt -> autoVacuum && N > 0 ) { 
line 44924: i = get4byte ( pOvflData ) ; 
line 44925: checkPtrmap ( pCheck , i , PTRMAP_OVERFLOW2 , iPage , zContext ) ; 
line 44926: } 
line 44927: } 
line 44928: # endif 
line 44929: iPage = get4byte ( pOvflData ) ; 
line 44930: sqlite3PagerUnref ( pOvflPage ) ; 
line 44931: } 
line 44932: } 
line 44933: # endif 
line 44935: # ifndef SQLITE_OMIT_INTEGRITY_CHECK 
line 44954: static int checkTreePage ( 
line 44955: IntegrityCk * pCheck , 
line 44956: int iPage , 
line 44957: char * zParentContext 
line 44958: ) { 
line 44959: MemPage * pPage ; 
line 44960: int i , rc , depth , d2 , pgno , cnt ; 
line 44961: int hdr , cellStart ; 
line 44962: int nCell ; 
line 44963: u8 * data ; 
line 44964: BtShared * pBt ; 
line 44965: int usableSize ; 
line 44966: char zContext [ 100 ] ; 
line 44967: char * hit = 0 ; 
line 44969: sqlite3_snprintf ( sizeof ( zContext ) , zContext , "Page %d: " , iPage ) ; 
line 44973: pBt = pCheck -> pBt ; 
line 44974: usableSize = pBt -> usableSize ; 
line 44975: if ( iPage == 0 ) return 0 ; 
line 44976: if ( checkRef ( pCheck , iPage , zParentContext ) ) return 0 ; 
line 44977: if ( ( rc = btreeGetPage ( pBt , ( Pgno ) iPage , & pPage , 0 ) ) != 0 ) { 
line 44978: checkAppendMsg ( pCheck , zContext , 
line 44979: "unable to get the page. error code=%d" , rc ) ; 
line 44980: return 0 ; 
line 44981: } 
line 44985: pPage -> isInit = 0 ; 
line 44986: if ( ( rc = btreeInitPage ( pPage ) ) != 0 ) { 
line 44987: assert ( rc == SQLITE_CORRUPT ) ; 
line 44988: checkAppendMsg ( pCheck , zContext , 
line 44989: "btreeInitPage() returns error code %d" , rc ) ; 
line 44990: releasePage ( pPage ) ; 
line 44991: return 0 ; 
line 44992: } 
line 44996: depth = 0 ; 
line 44997: for ( i = 0 ; i < pPage -> nCell && pCheck -> mxErr ; i ++ ) { 
line 44998: u8 * pCell ; 
line 44999: u32 sz ; 
line 45000: CellInfo info ; 
line 45004: sqlite3_snprintf ( sizeof ( zContext ) , zContext , 
line 45005: "On tree page %d cell %d: " , iPage , i ) ; 
line 45006: pCell = findCell ( pPage , i ) ; 
line 45007: btreeParseCellPtr ( pPage , pCell , & info ) ; 
line 45008: sz = info . nData ; 
line 45009: if ( ! pPage -> intKey ) sz += ( int ) info . nKey ; 
line 45010: assert ( sz == info . nPayload ) ; 
line 45011: if ( ( sz > info . nLocal ) 
line 45012: && ( & pCell [ info . iOverflow ] <= & pPage -> aData [ pBt -> usableSize ] ) 
line 45013: ) { 
line 45014: int nPage = ( sz - info . nLocal + usableSize - 5 ) / ( usableSize - 4 ) ; 
line 45015: Pgno pgnoOvfl = get4byte ( & pCell [ info . iOverflow ] ) ; 
line 45016: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 45017: if ( pBt -> autoVacuum ) { 
line 45018: checkPtrmap ( pCheck , pgnoOvfl , PTRMAP_OVERFLOW1 , iPage , zContext ) ; 
line 45019: } 
line 45020: # endif 
line 45021: checkList ( pCheck , 0 , pgnoOvfl , nPage , zContext ) ; 
line 45022: } 
line 45026: if ( ! pPage -> leaf ) { 
line 45027: pgno = get4byte ( pCell ) ; 
line 45028: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 45029: if ( pBt -> autoVacuum ) { 
line 45030: checkPtrmap ( pCheck , pgno , PTRMAP_BTREE , iPage , zContext ) ; 
line 45031: } 
line 45032: # endif 
line 45033: d2 = checkTreePage ( pCheck , pgno , zContext ) ; 
line 45034: if ( i > 0 && d2 != depth ) { 
line 45035: checkAppendMsg ( pCheck , zContext , "Child page depth differs" ) ; 
line 45036: } 
line 45037: depth = d2 ; 
line 45038: } 
line 45039: } 
line 45040: if ( ! pPage -> leaf ) { 
line 45041: pgno = get4byte ( & pPage -> aData [ pPage -> hdrOffset + 8 ] ) ; 
line 45042: sqlite3_snprintf ( sizeof ( zContext ) , zContext , 
line 45043: "On page %d at right child: " , iPage ) ; 
line 45044: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 45045: if ( pBt -> autoVacuum ) { 
line 45046: checkPtrmap ( pCheck , pgno , PTRMAP_BTREE , iPage , 0 ) ; 
line 45047: } 
line 45048: # endif 
line 45049: checkTreePage ( pCheck , pgno , zContext ) ; 
line 45050: } 
line 45054: data = pPage -> aData ; 
line 45055: hdr = pPage -> hdrOffset ; 
line 45056: hit = sqlite3PageMalloc ( pBt -> pageSize ) ; 
line 45057: if ( hit == 0 ) { 
line 45058: pCheck -> mallocFailed = 1 ; 
line 45059: } else { 
line 45060: u16 contentOffset = get2byte ( & data [ hdr + 5 ] ) ; 
line 45061: assert ( contentOffset <= usableSize ) ; 
line 45062: memset ( hit + contentOffset , 0 , usableSize - contentOffset ) ; 
line 45063: memset ( hit , 1 , contentOffset ) ; 
line 45064: nCell = get2byte ( & data [ hdr + 3 ] ) ; 
line 45065: cellStart = hdr + 12 - 4 * pPage -> leaf ; 
line 45066: for ( i = 0 ; i < nCell ; i ++ ) { 
line 45067: int pc = get2byte ( & data [ cellStart + i * 2 ] ) ; 
line 45068: u16 size = 1024 ; 
line 45069: int j ; 
line 45070: if ( pc <= usableSize - 4 ) { 
line 45071: size = cellSizePtr ( pPage , & data [ pc ] ) ; 
line 45072: } 
line 45073: if ( ( pc + size - 1 ) >= usableSize ) { 
line 45074: checkAppendMsg ( pCheck , 0 , 
line 45075: "Corruption detected in cell %d on page %d" , i , iPage , 0 ) ; 
line 45076: } else { 
line 45077: for ( j = pc + size - 1 ; j >= pc ; j -- ) hit [ j ] ++ ; 
line 45078: } 
line 45079: } 
line 45080: i = get2byte ( & data [ hdr + 1 ] ) ; 
line 45081: while ( i > 0 ) { 
line 45082: int size , j ; 
line 45083: assert ( i <= usableSize - 4 ) ; 
line 45084: size = get2byte ( & data [ i + 2 ] ) ; 
line 45085: assert ( i + size <= usableSize ) ; 
line 45086: for ( j = i + size - 1 ; j >= i ; j -- ) hit [ j ] ++ ; 
line 45087: j = get2byte ( & data [ i ] ) ; 
line 45088: assert ( j == 0 || j > i + size ) ; 
line 45089: assert ( j <= usableSize - 4 ) ; 
line 45090: i = j ; 
line 45091: } 
line 45092: for ( i = cnt = 0 ; i < usableSize ; i ++ ) { 
line 45093: if ( hit [ i ] == 0 ) { 
line 45094: cnt ++ ; 
line 45095: } else if ( hit [ i ] > 1 ) { 
line 45096: checkAppendMsg ( pCheck , 0 , 
line 45097: "Multiple uses for byte %d of page %d" , i , iPage ) ; 
line 45098: break ; 
line 45099: } 
line 45100: } 
line 45101: if ( cnt != data [ hdr + 7 ] ) { 
line 45102: checkAppendMsg ( pCheck , 0 , 
line 45103: "Fragmentation of %d bytes reported as %d on page %d" , 
line 45104: cnt , data [ hdr + 7 ] , iPage ) ; 
line 45105: } 
line 45106: } 
line 45107: sqlite3PageFree ( hit ) ; 
line 45108: releasePage ( pPage ) ; 
line 45109: return depth + 1 ; 
line 45110: } 
line 45111: # endif 
line 45113: # ifndef SQLITE_OMIT_INTEGRITY_CHECK 
line 45127: SQLITE_PRIVATE char * sqlite3BtreeIntegrityCheck ( 
line 45128: Btree * p , 
line 45129: int * aRoot , 
line 45130: int nRoot , 
line 45131: int mxErr , 
line 45132: int * pnErr 
line 45133: ) { 
line 45134: Pgno i ; 
line 45135: int nRef ; 
line 45136: IntegrityCk sCheck ; 
line 45137: BtShared * pBt = p -> pBt ; 
line 45138: char zErr [ 100 ] ; 
line 45140: sqlite3BtreeEnter ( p ) ; 
line 45141: assert ( p -> inTrans > TRANS_NONE && pBt -> inTransaction > TRANS_NONE ) ; 
line 45142: nRef = sqlite3PagerRefcount ( pBt -> pPager ) ; 
line 45143: sCheck . pBt = pBt ; 
line 45144: sCheck . pPager = pBt -> pPager ; 
line 45145: sCheck . nPage = pagerPagecount ( sCheck . pBt ) ; 
line 45146: sCheck . mxErr = mxErr ; 
line 45147: sCheck . nErr = 0 ; 
line 45148: sCheck . mallocFailed = 0 ; 
line 45149: * pnErr = 0 ; 
line 45150: if ( sCheck . nPage == 0 ) { 
line 45151: sqlite3BtreeLeave ( p ) ; 
line 45152: return 0 ; 
line 45153: } 
line 45154: sCheck . anRef = sqlite3Malloc ( ( sCheck . nPage + 1 ) * sizeof ( sCheck . anRef [ 0 ] ) ) ; 
line 45155: if ( ! sCheck . anRef ) { 
line 45156: * pnErr = 1 ; 
line 45157: sqlite3BtreeLeave ( p ) ; 
line 45158: return 0 ; 
line 45159: } 
line 45160: for ( i = 0 ; i <= sCheck . nPage ; i ++ ) { sCheck . anRef [ i ] = 0 ; } 
line 45161: i = PENDING_BYTE_PAGE ( pBt ) ; 
line 45162: if ( i <= sCheck . nPage ) { 
line 45163: sCheck . anRef [ i ] = 1 ; 
line 45164: } 
line 45165: sqlite3StrAccumInit ( & sCheck . errMsg , zErr , sizeof ( zErr ) , 20000 ) ; 
line 45169: checkList ( & sCheck , 1 , get4byte ( & pBt -> pPage1 -> aData [ 32 ] ) , 
line 45170: get4byte ( & pBt -> pPage1 -> aData [ 36 ] ) , "Main freelist: " ) ; 
line 45174: for ( i = 0 ; ( int ) i < nRoot && sCheck . mxErr ; i ++ ) { 
line 45175: if ( aRoot [ i ] == 0 ) continue ; 
line 45176: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 45177: if ( pBt -> autoVacuum && aRoot [ i ] > 1 ) { 
line 45178: checkPtrmap ( & sCheck , aRoot [ i ] , PTRMAP_ROOTPAGE , 0 , 0 ) ; 
line 45179: } 
line 45180: # endif 
line 45181: checkTreePage ( & sCheck , aRoot [ i ] , "List of tree roots: " ) ; 
line 45182: } 
line 45186: for ( i = 1 ; i <= sCheck . nPage && sCheck . mxErr ; i ++ ) { 
line 45187: # ifdef SQLITE_OMIT_AUTOVACUUM 
line 45188: if ( sCheck . anRef [ i ] == 0 ) { 
line 45189: checkAppendMsg ( & sCheck , 0 , "Page %d is never used" , i ) ; 
line 45190: } 
line 45191: # else 
line 45195: if ( sCheck . anRef [ i ] == 0 && 
line 45196: ( PTRMAP_PAGENO ( pBt , i ) != i || ! pBt -> autoVacuum ) ) { 
line 45197: checkAppendMsg ( & sCheck , 0 , "Page %d is never used" , i ) ; 
line 45198: } 
line 45199: if ( sCheck . anRef [ i ] != 0 && 
line 45200: ( PTRMAP_PAGENO ( pBt , i ) == i && pBt -> autoVacuum ) ) { 
line 45201: checkAppendMsg ( & sCheck , 0 , "Pointer map page %d is referenced" , i ) ; 
line 45202: } 
line 45203: # endif 
line 45204: } 
line 45210: if ( NEVER ( nRef != sqlite3PagerRefcount ( pBt -> pPager ) ) ) { 
line 45211: checkAppendMsg ( & sCheck , 0 , 
line 45212: "Outstanding page count goes from %d to %d during this analysis" , 
line 45213: nRef , sqlite3PagerRefcount ( pBt -> pPager ) 
line 45214: ) ; 
line 45215: } 
line 45219: sqlite3BtreeLeave ( p ) ; 
line 45220: sqlite3_free ( sCheck . anRef ) ; 
line 45221: if ( sCheck . mallocFailed ) { 
line 45222: sqlite3StrAccumReset ( & sCheck . errMsg ) ; 
line 45223: * pnErr = sCheck . nErr + 1 ; 
line 45224: return 0 ; 
line 45225: } 
line 45226: * pnErr = sCheck . nErr ; 
line 45227: if ( sCheck . nErr == 0 ) sqlite3StrAccumReset ( & sCheck . errMsg ) ; 
line 45228: return sqlite3StrAccumFinish ( & sCheck . errMsg ) ; 
line 45229: } 
line 45230: # endif 
line 45238: SQLITE_PRIVATE const char * sqlite3BtreeGetFilename ( Btree * p ) { 
line 45239: assert ( p -> pBt -> pPager != 0 ) ; 
line 45240: return sqlite3PagerFilename ( p -> pBt -> pPager ) ; 
line 45241: } 
line 45251: SQLITE_PRIVATE const char * sqlite3BtreeGetJournalname ( Btree * p ) { 
line 45252: assert ( p -> pBt -> pPager != 0 ) ; 
line 45253: return sqlite3PagerJournalname ( p -> pBt -> pPager ) ; 
line 45254: } 
line 45259: SQLITE_PRIVATE int sqlite3BtreeIsInTrans ( Btree * p ) { 
line 45260: assert ( p == 0 || sqlite3_mutex_held ( p -> db -> mutex ) ) ; 
line 45261: return ( p && ( p -> inTrans == TRANS_WRITE ) ) ; 
line 45262: } 
line 45267: SQLITE_PRIVATE int sqlite3BtreeIsInReadTrans ( Btree * p ) { 
line 45268: assert ( p ) ; 
line 45269: assert ( sqlite3_mutex_held ( p -> db -> mutex ) ) ; 
line 45270: return p -> inTrans != TRANS_NONE ; 
line 45271: } 
line 45273: SQLITE_PRIVATE int sqlite3BtreeIsInBackup ( Btree * p ) { 
line 45274: assert ( p ) ; 
line 45275: assert ( sqlite3_mutex_held ( p -> db -> mutex ) ) ; 
line 45276: return p -> nBackup != 0 ; 
line 45277: } 
line 45299: SQLITE_PRIVATE void * sqlite3BtreeSchema ( Btree * p , int nBytes , void ( * xFree ) ( void * ) ) { 
line 45300: BtShared * pBt = p -> pBt ; 
line 45301: sqlite3BtreeEnter ( p ) ; 
line 45302: if ( ! pBt -> pSchema && nBytes ) { 
line 45303: pBt -> pSchema = sqlite3MallocZero ( nBytes ) ; 
line 45304: pBt -> xFreeSchema = xFree ; 
line 45305: } 
line 45306: sqlite3BtreeLeave ( p ) ; 
line 45307: return pBt -> pSchema ; 
line 45308: } 
line 45315: SQLITE_PRIVATE int sqlite3BtreeSchemaLocked ( Btree * p ) { 
line 45316: int rc ; 
line 45317: assert ( sqlite3_mutex_held ( p -> db -> mutex ) ) ; 
line 45318: sqlite3BtreeEnter ( p ) ; 
line 45319: rc = querySharedCacheTableLock ( p , MASTER_ROOT , READ_LOCK ) ; 
line 45320: assert ( rc == SQLITE_OK || rc == SQLITE_LOCKED_SHAREDCACHE ) ; 
line 45321: sqlite3BtreeLeave ( p ) ; 
line 45322: return rc ; 
line 45323: } 
line 45326: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 45332: SQLITE_PRIVATE int sqlite3BtreeLockTable ( Btree * p , int iTab , u8 isWriteLock ) { 
line 45333: int rc = SQLITE_OK ; 
line 45334: assert ( p -> inTrans != TRANS_NONE ) ; 
line 45335: if ( p -> sharable ) { 
line 45336: u8 lockType = READ_LOCK + isWriteLock ; 
line 45337: assert ( READ_LOCK + 1 == WRITE_LOCK ) ; 
line 45338: assert ( isWriteLock == 0 || isWriteLock == 1 ) ; 
line 45340: sqlite3BtreeEnter ( p ) ; 
line 45341: rc = querySharedCacheTableLock ( p , iTab , lockType ) ; 
line 45342: if ( rc == SQLITE_OK ) { 
line 45343: rc = setSharedCacheTableLock ( p , iTab , lockType ) ; 
line 45344: } 
line 45345: sqlite3BtreeLeave ( p ) ; 
line 45346: } 
line 45347: return rc ; 
line 45348: } 
line 45349: # endif 
line 45351: # ifndef SQLITE_OMIT_INCRBLOB 
line 45362: SQLITE_PRIVATE int sqlite3BtreePutData ( BtCursor * pCsr , u32 offset , u32 amt , void * z ) { 
line 45363: int rc ; 
line 45364: assert ( cursorHoldsMutex ( pCsr ) ) ; 
line 45365: assert ( sqlite3_mutex_held ( pCsr -> pBtree -> db -> mutex ) ) ; 
line 45366: assert ( pCsr -> isIncrblobHandle ) ; 
line 45368: rc = restoreCursorPosition ( pCsr ) ; 
line 45369: if ( rc != SQLITE_OK ) { 
line 45370: return rc ; 
line 45371: } 
line 45372: assert ( pCsr -> eState != CURSOR_REQUIRESEEK ) ; 
line 45373: if ( pCsr -> eState != CURSOR_VALID ) { 
line 45374: return SQLITE_ABORT ; 
line 45375: } 
line 45384: if ( ! pCsr -> wrFlag ) { 
line 45385: return SQLITE_READONLY ; 
line 45386: } 
line 45387: assert ( ! pCsr -> pBt -> readOnly && pCsr -> pBt -> inTransaction == TRANS_WRITE ) ; 
line 45388: assert ( hasSharedCacheTableLock ( pCsr -> pBtree , pCsr -> pgnoRoot , 0 , 2 ) ) ; 
line 45389: assert ( ! hasReadConflicts ( pCsr -> pBtree , pCsr -> pgnoRoot ) ) ; 
line 45390: assert ( pCsr -> apPage [ pCsr -> iPage ] -> intKey ) ; 
line 45392: return accessPayload ( pCsr , offset , amt , ( unsigned char * ) z , 1 ) ; 
line 45393: } 
line 45405: SQLITE_PRIVATE void sqlite3BtreeCacheOverflow ( BtCursor * pCur ) { 
line 45406: assert ( cursorHoldsMutex ( pCur ) ) ; 
line 45407: assert ( sqlite3_mutex_held ( pCur -> pBtree -> db -> mutex ) ) ; 
line 45408: assert ( ! pCur -> isIncrblobHandle ) ; 
line 45409: assert ( ! pCur -> aOverflow ) ; 
line 45410: pCur -> isIncrblobHandle = 1 ; 
line 45411: } 
line 45412: # endif 
line 45433: # ifndef MIN 
line 45434: # define MIN ( x , y ) ( ( x ) < ( y ) ? ( x ) : ( y ) ) 
line 45435: # endif 
line 45440: struct sqlite3_backup { 
line 45441: sqlite3 * pDestDb ; 
line 45442: Btree * pDest ; 
line 45443: u32 iDestSchema ; 
line 45444: int bDestLocked ; 
line 45446: Pgno iNext ; 
line 45447: sqlite3 * pSrcDb ; 
line 45448: Btree * pSrc ; 
line 45450: int rc ; 
line 45455: Pgno nRemaining ; 
line 45456: Pgno nPagecount ; 
line 45458: int isAttached ; 
line 45459: sqlite3_backup * pNext ; 
line 45460: } ; 
line 45501: static Btree * findBtree ( sqlite3 * pErrorDb , sqlite3 * pDb , const char * zDb ) { 
line 45502: int i = sqlite3FindDbName ( pDb , zDb ) ; 
line 45504: if ( i == 1 ) { 
line 45505: Parse * pParse ; 
line 45506: int rc = 0 ; 
line 45507: pParse = sqlite3StackAllocZero ( pErrorDb , sizeof ( * pParse ) ) ; 
line 45508: if ( pParse == 0 ) { 
line 45509: sqlite3Error ( pErrorDb , SQLITE_NOMEM , "out of memory" ) ; 
line 45510: rc = SQLITE_NOMEM ; 
line 45511: } else { 
line 45512: pParse -> db = pDb ; 
line 45513: if ( sqlite3OpenTempDatabase ( pParse ) ) { 
line 45514: sqlite3ErrorClear ( pParse ) ; 
line 45515: sqlite3Error ( pErrorDb , pParse -> rc , "%s" , pParse -> zErrMsg ) ; 
line 45516: rc = SQLITE_ERROR ; 
line 45517: } 
line 45518: sqlite3StackFree ( pErrorDb , pParse ) ; 
line 45519: } 
line 45520: if ( rc ) { 
line 45521: return 0 ; 
line 45522: } 
line 45523: } 
line 45525: if ( i < 0 ) { 
line 45526: sqlite3Error ( pErrorDb , SQLITE_ERROR , "unknown database %s" , zDb ) ; 
line 45527: return 0 ; 
line 45528: } 
line 45530: return pDb -> aDb [ i ] . pBt ; 
line 45531: } 
line 45541: SQLITE_API sqlite3_backup * sqlite3_backup_init ( 
line 45542: sqlite3 * pDestDb , 
line 45543: const char * zDestDb , 
line 45544: sqlite3 * pSrcDb , 
line 45545: const char * zSrcDb 
line 45546: ) { 
line 45547: sqlite3_backup * p ; 
line 45557: sqlite3_mutex_enter ( pSrcDb -> mutex ) ; 
line 45558: sqlite3_mutex_enter ( pDestDb -> mutex ) ; 
line 45560: if ( pSrcDb == pDestDb ) { 
line 45561: sqlite3Error ( 
line 45562: pDestDb , SQLITE_ERROR , "source and destination must be distinct" 
line 45563: ) ; 
line 45564: p = 0 ; 
line 45565: } else { 
line 45567: p = ( sqlite3_backup * ) sqlite3_malloc ( sizeof ( sqlite3_backup ) ) ; 
line 45568: if ( ! p ) { 
line 45569: sqlite3Error ( pDestDb , SQLITE_NOMEM , 0 ) ; 
line 45570: } 
line 45571: } 
line 45574: if ( p ) { 
line 45575: memset ( p , 0 , sizeof ( sqlite3_backup ) ) ; 
line 45576: p -> pSrc = findBtree ( pDestDb , pSrcDb , zSrcDb ) ; 
line 45577: p -> pDest = findBtree ( pDestDb , pDestDb , zDestDb ) ; 
line 45578: p -> pDestDb = pDestDb ; 
line 45579: p -> pSrcDb = pSrcDb ; 
line 45580: p -> iNext = 1 ; 
line 45581: p -> isAttached = 0 ; 
line 45583: if ( 0 == p -> pSrc || 0 == p -> pDest ) { 
line 45588: sqlite3_free ( p ) ; 
line 45589: p = 0 ; 
line 45590: } 
line 45591: } 
line 45592: if ( p ) { 
line 45593: p -> pSrc -> nBackup ++ ; 
line 45594: } 
line 45596: sqlite3_mutex_leave ( pDestDb -> mutex ) ; 
line 45597: sqlite3_mutex_leave ( pSrcDb -> mutex ) ; 
line 45598: return p ; 
line 45599: } 
line 45606: static int isFatalError ( int rc ) { 
line 45607: return ( rc != SQLITE_OK && rc != SQLITE_BUSY && ALWAYS ( rc != SQLITE_LOCKED ) ) ; 
line 45608: } 
line 45615: static int backupOnePage ( sqlite3_backup * p , Pgno iSrcPg , const u8 * zSrcData ) { 
line 45616: Pager * const pDestPager = sqlite3BtreePager ( p -> pDest ) ; 
line 45617: const int nSrcPgsz = sqlite3BtreeGetPageSize ( p -> pSrc ) ; 
line 45618: int nDestPgsz = sqlite3BtreeGetPageSize ( p -> pDest ) ; 
line 45619: const int nCopy = MIN ( nSrcPgsz , nDestPgsz ) ; 
line 45620: const i64 iEnd = ( i64 ) iSrcPg * ( i64 ) nSrcPgsz ; 
line 45622: int rc = SQLITE_OK ; 
line 45623: i64 iOff ; 
line 45625: assert ( p -> bDestLocked ) ; 
line 45626: assert ( ! isFatalError ( p -> rc ) ) ; 
line 45627: assert ( iSrcPg != PENDING_BYTE_PAGE ( p -> pSrc -> pBt ) ) ; 
line 45628: assert ( zSrcData ) ; 
line 45633: if ( nSrcPgsz != nDestPgsz && sqlite3PagerIsMemdb ( sqlite3BtreePager ( p -> pDest ) ) ) { 
line 45634: rc = SQLITE_READONLY ; 
line 45635: } 
line 45641: for ( iOff = iEnd - ( i64 ) nSrcPgsz ; rc == SQLITE_OK && iOff < iEnd ; iOff += nDestPgsz ) { 
line 45642: DbPage * pDestPg = 0 ; 
line 45643: Pgno iDest = ( Pgno ) ( iOff / nDestPgsz ) + 1 ; 
line 45644: if ( iDest == PENDING_BYTE_PAGE ( p -> pDest -> pBt ) ) continue ; 
line 45645: if ( SQLITE_OK == ( rc = sqlite3PagerGet ( pDestPager , iDest , & pDestPg ) ) 
line 45646: && SQLITE_OK == ( rc = sqlite3PagerWrite ( pDestPg ) ) 
line 45647: ) { 
line 45648: const u8 * zIn = & zSrcData [ iOff % nSrcPgsz ] ; 
line 45649: u8 * zDestData = sqlite3PagerGetData ( pDestPg ) ; 
line 45650: u8 * zOut = & zDestData [ iOff % nDestPgsz ] ; 
line 45659: memcpy ( zOut , zIn , nCopy ) ; 
line 45660: ( ( u8 * ) sqlite3PagerGetExtra ( pDestPg ) ) [ 0 ] = 0 ; 
line 45661: } 
line 45662: sqlite3PagerUnref ( pDestPg ) ; 
line 45663: } 
line 45665: return rc ; 
line 45666: } 
line 45676: static int backupTruncateFile ( sqlite3_file * pFile , i64 iSize ) { 
line 45677: i64 iCurrent ; 
line 45678: int rc = sqlite3OsFileSize ( pFile , & iCurrent ) ; 
line 45679: if ( rc == SQLITE_OK && iCurrent > iSize ) { 
line 45680: rc = sqlite3OsTruncate ( pFile , iSize ) ; 
line 45681: } 
line 45682: return rc ; 
line 45683: } 
line 45689: static void attachBackupObject ( sqlite3_backup * p ) { 
line 45690: sqlite3_backup * * pp ; 
line 45691: assert ( sqlite3BtreeHoldsMutex ( p -> pSrc ) ) ; 
line 45692: pp = sqlite3PagerBackupPtr ( sqlite3BtreePager ( p -> pSrc ) ) ; 
line 45693: p -> pNext = * pp ; 
line 45694: * pp = p ; 
line 45695: p -> isAttached = 1 ; 
line 45696: } 
line 45701: SQLITE_API int sqlite3_backup_step ( sqlite3_backup * p , int nPage ) { 
line 45702: int rc ; 
line 45704: sqlite3_mutex_enter ( p -> pSrcDb -> mutex ) ; 
line 45705: sqlite3BtreeEnter ( p -> pSrc ) ; 
line 45706: if ( p -> pDestDb ) { 
line 45707: sqlite3_mutex_enter ( p -> pDestDb -> mutex ) ; 
line 45708: } 
line 45710: rc = p -> rc ; 
line 45711: if ( ! isFatalError ( rc ) ) { 
line 45712: Pager * const pSrcPager = sqlite3BtreePager ( p -> pSrc ) ; 
line 45713: Pager * const pDestPager = sqlite3BtreePager ( p -> pDest ) ; 
line 45714: int ii ; 
line 45715: int nSrcPage = - 1 ; 
line 45716: int bCloseTrans = 0 ; 
line 45721: if ( p -> pDestDb && p -> pSrc -> pBt -> inTransaction == TRANS_WRITE ) { 
line 45722: rc = SQLITE_BUSY ; 
line 45723: } else { 
line 45724: rc = SQLITE_OK ; 
line 45725: } 
line 45728: if ( SQLITE_OK == rc && p -> bDestLocked == 0 
line 45729: && SQLITE_OK == ( rc = sqlite3BtreeBeginTrans ( p -> pDest , 2 ) ) 
line 45730: ) { 
line 45731: p -> bDestLocked = 1 ; 
line 45732: sqlite3BtreeGetMeta ( p -> pDest , BTREE_SCHEMA_VERSION , & p -> iDestSchema ) ; 
line 45733: } 
line 45739: if ( rc == SQLITE_OK && 0 == sqlite3BtreeIsInReadTrans ( p -> pSrc ) ) { 
line 45740: rc = sqlite3BtreeBeginTrans ( p -> pSrc , 0 ) ; 
line 45741: bCloseTrans = 1 ; 
line 45742: } 
line 45747: if ( rc == SQLITE_OK ) { 
line 45748: rc = sqlite3PagerPagecount ( pSrcPager , & nSrcPage ) ; 
line 45749: } 
line 45750: for ( ii = 0 ; ( nPage < 0 || ii < nPage ) && p -> iNext <= ( Pgno ) nSrcPage && ! rc ; ii ++ ) { 
line 45751: const Pgno iSrcPg = p -> iNext ; 
line 45752: if ( iSrcPg != PENDING_BYTE_PAGE ( p -> pSrc -> pBt ) ) { 
line 45753: DbPage * pSrcPg ; 
line 45754: rc = sqlite3PagerGet ( pSrcPager , iSrcPg , & pSrcPg ) ; 
line 45755: if ( rc == SQLITE_OK ) { 
line 45756: rc = backupOnePage ( p , iSrcPg , sqlite3PagerGetData ( pSrcPg ) ) ; 
line 45757: sqlite3PagerUnref ( pSrcPg ) ; 
line 45758: } 
line 45759: } 
line 45760: p -> iNext ++ ; 
line 45761: } 
line 45762: if ( rc == SQLITE_OK ) { 
line 45763: p -> nPagecount = nSrcPage ; 
line 45764: p -> nRemaining = nSrcPage + 1 - p -> iNext ; 
line 45765: if ( p -> iNext > ( Pgno ) nSrcPage ) { 
line 45766: rc = SQLITE_DONE ; 
line 45767: } else if ( ! p -> isAttached ) { 
line 45768: attachBackupObject ( p ) ; 
line 45769: } 
line 45770: } 
line 45777: if ( rc == SQLITE_DONE 
line 45778: && ( rc = sqlite3BtreeUpdateMeta ( p -> pDest , 1 , p -> iDestSchema + 1 ) ) == SQLITE_OK 
line 45779: ) { 
line 45780: const int nSrcPagesize = sqlite3BtreeGetPageSize ( p -> pSrc ) ; 
line 45781: const int nDestPagesize = sqlite3BtreeGetPageSize ( p -> pDest ) ; 
line 45782: int nDestTruncate ; 
line 45784: if ( p -> pDestDb ) { 
line 45785: sqlite3ResetInternalSchema ( p -> pDestDb , 0 ) ; 
line 45786: } 
line 45800: if ( nSrcPagesize < nDestPagesize ) { 
line 45801: int ratio = nDestPagesize / nSrcPagesize ; 
line 45802: nDestTruncate = ( nSrcPage + ratio - 1 ) / ratio ; 
line 45803: if ( nDestTruncate == ( int ) PENDING_BYTE_PAGE ( p -> pDest -> pBt ) ) { 
line 45804: nDestTruncate -- ; 
line 45805: } 
line 45806: } else { 
line 45807: nDestTruncate = nSrcPage * ( nSrcPagesize / nDestPagesize ) ; 
line 45808: } 
line 45809: sqlite3PagerTruncateImage ( pDestPager , nDestTruncate ) ; 
line 45811: if ( nSrcPagesize < nDestPagesize ) { 
line 45821: const i64 iSize = ( i64 ) nSrcPagesize * ( i64 ) nSrcPage ; 
line 45822: sqlite3_file * const pFile = sqlite3PagerFile ( pDestPager ) ; 
line 45824: assert ( pFile ) ; 
line 45825: assert ( ( i64 ) nDestTruncate * ( i64 ) nDestPagesize >= iSize || ( 
line 45826: nDestTruncate == ( int ) ( PENDING_BYTE_PAGE ( p -> pDest -> pBt ) - 1 ) 
line 45827: && iSize >= PENDING_BYTE && iSize <= PENDING_BYTE + nDestPagesize 
line 45828: ) ) ; 
line 45829: if ( SQLITE_OK == ( rc = sqlite3PagerCommitPhaseOne ( pDestPager , 0 , 1 ) ) 
line 45830: && SQLITE_OK == ( rc = backupTruncateFile ( pFile , iSize ) ) 
line 45831: && SQLITE_OK == ( rc = sqlite3PagerSync ( pDestPager ) ) 
line 45832: ) { 
line 45833: i64 iOff ; 
line 45834: i64 iEnd = MIN ( PENDING_BYTE + nDestPagesize , iSize ) ; 
line 45835: for ( 
line 45836: iOff = PENDING_BYTE + nSrcPagesize ; 
line 45837: rc == SQLITE_OK && iOff < iEnd ; 
line 45838: iOff += nSrcPagesize 
line 45839: ) { 
line 45840: PgHdr * pSrcPg = 0 ; 
line 45841: const Pgno iSrcPg = ( Pgno ) ( ( iOff / nSrcPagesize ) + 1 ) ; 
line 45842: rc = sqlite3PagerGet ( pSrcPager , iSrcPg , & pSrcPg ) ; 
line 45843: if ( rc == SQLITE_OK ) { 
line 45844: u8 * zData = sqlite3PagerGetData ( pSrcPg ) ; 
line 45845: rc = sqlite3OsWrite ( pFile , zData , nSrcPagesize , iOff ) ; 
line 45846: } 
line 45847: sqlite3PagerUnref ( pSrcPg ) ; 
line 45848: } 
line 45849: } 
line 45850: } else { 
line 45851: rc = sqlite3PagerCommitPhaseOne ( pDestPager , 0 , 0 ) ; 
line 45852: } 
line 45855: if ( SQLITE_OK == rc 
line 45856: && SQLITE_OK == ( rc = sqlite3BtreeCommitPhaseTwo ( p -> pDest ) ) 
line 45857: ) { 
line 45858: rc = SQLITE_DONE ; 
line 45859: } 
line 45860: } 
line 45867: if ( bCloseTrans ) { 
line 45868: TESTONLY ( int rc2 ) ; 
line 45869: TESTONLY ( rc2 = ) sqlite3BtreeCommitPhaseOne ( p -> pSrc , 0 ) ; 
line 45870: TESTONLY ( rc2 |= ) sqlite3BtreeCommitPhaseTwo ( p -> pSrc ) ; 
line 45871: assert ( rc2 == SQLITE_OK ) ; 
line 45872: } 
line 45874: p -> rc = rc ; 
line 45875: } 
line 45876: if ( p -> pDestDb ) { 
line 45877: sqlite3_mutex_leave ( p -> pDestDb -> mutex ) ; 
line 45878: } 
line 45879: sqlite3BtreeLeave ( p -> pSrc ) ; 
line 45880: sqlite3_mutex_leave ( p -> pSrcDb -> mutex ) ; 
line 45881: return rc ; 
line 45882: } 
line 45887: SQLITE_API int sqlite3_backup_finish ( sqlite3_backup * p ) { 
line 45888: sqlite3_backup * * pp ; 
line 45889: sqlite3_mutex * mutex ; 
line 45890: int rc ; 
line 45893: if ( p == 0 ) return SQLITE_OK ; 
line 45894: sqlite3_mutex_enter ( p -> pSrcDb -> mutex ) ; 
line 45895: sqlite3BtreeEnter ( p -> pSrc ) ; 
line 45896: mutex = p -> pSrcDb -> mutex ; 
line 45897: if ( p -> pDestDb ) { 
line 45898: sqlite3_mutex_enter ( p -> pDestDb -> mutex ) ; 
line 45899: } 
line 45902: if ( p -> pDestDb ) { 
line 45903: p -> pSrc -> nBackup -- ; 
line 45904: } 
line 45905: if ( p -> isAttached ) { 
line 45906: pp = sqlite3PagerBackupPtr ( sqlite3BtreePager ( p -> pSrc ) ) ; 
line 45907: while ( * pp != p ) { 
line 45908: pp = & ( * pp ) -> pNext ; 
line 45909: } 
line 45910: * pp = p -> pNext ; 
line 45911: } 
line 45914: sqlite3BtreeRollback ( p -> pDest ) ; 
line 45917: rc = ( p -> rc == SQLITE_DONE ) ? SQLITE_OK : p -> rc ; 
line 45918: sqlite3Error ( p -> pDestDb , rc , 0 ) ; 
line 45921: if ( p -> pDestDb ) { 
line 45922: sqlite3_mutex_leave ( p -> pDestDb -> mutex ) ; 
line 45923: } 
line 45924: sqlite3BtreeLeave ( p -> pSrc ) ; 
line 45925: if ( p -> pDestDb ) { 
line 45926: sqlite3_free ( p ) ; 
line 45927: } 
line 45928: sqlite3_mutex_leave ( mutex ) ; 
line 45929: return rc ; 
line 45930: } 
line 45936: SQLITE_API int sqlite3_backup_remaining ( sqlite3_backup * p ) { 
line 45937: return p -> nRemaining ; 
line 45938: } 
line 45944: SQLITE_API int sqlite3_backup_pagecount ( sqlite3_backup * p ) { 
line 45945: return p -> nPagecount ; 
line 45946: } 
line 45960: SQLITE_PRIVATE void sqlite3BackupUpdate ( sqlite3_backup * pBackup , Pgno iPage , const u8 * aData ) { 
line 45961: sqlite3_backup * p ; 
line 45962: for ( p = pBackup ; p ; p = p -> pNext ) { 
line 45963: assert ( sqlite3_mutex_held ( p -> pSrc -> pBt -> mutex ) ) ; 
line 45964: if ( ! isFatalError ( p -> rc ) && iPage < p -> iNext ) { 
line 45969: int rc = backupOnePage ( p , iPage , aData ) ; 
line 45970: assert ( rc != SQLITE_BUSY && rc != SQLITE_LOCKED ) ; 
line 45971: if ( rc != SQLITE_OK ) { 
line 45972: p -> rc = rc ; 
line 45973: } 
line 45974: } 
line 45975: } 
line 45976: } 
line 45989: SQLITE_PRIVATE void sqlite3BackupRestart ( sqlite3_backup * pBackup ) { 
line 45990: sqlite3_backup * p ; 
line 45991: for ( p = pBackup ; p ; p = p -> pNext ) { 
line 45992: assert ( sqlite3_mutex_held ( p -> pSrc -> pBt -> mutex ) ) ; 
line 45993: p -> iNext = 1 ; 
line 45994: } 
line 45995: } 
line 45997: # ifndef SQLITE_OMIT_VACUUM 
line 46006: SQLITE_PRIVATE int sqlite3BtreeCopyFile ( Btree * pTo , Btree * pFrom ) { 
line 46007: int rc ; 
line 46008: sqlite3_backup b ; 
line 46009: sqlite3BtreeEnter ( pTo ) ; 
line 46010: sqlite3BtreeEnter ( pFrom ) ; 
line 46017: memset ( & b , 0 , sizeof ( b ) ) ; 
line 46018: b . pSrcDb = pFrom -> db ; 
line 46019: b . pSrc = pFrom ; 
line 46020: b . pDest = pTo ; 
line 46021: b . iNext = 1 ; 
line 46030: sqlite3_backup_step ( & b , 0x7FFFFFFF ) ; 
line 46031: assert ( b . rc != SQLITE_OK ) ; 
line 46032: rc = sqlite3_backup_finish ( & b ) ; 
line 46033: if ( rc == SQLITE_OK ) { 
line 46034: pTo -> pBt -> pageSizeFixed = 0 ; 
line 46035: } 
line 46037: sqlite3BtreeLeave ( pFrom ) ; 
line 46038: sqlite3BtreeLeave ( pTo ) ; 
line 46039: return rc ; 
line 46040: } 
line 46041: # endif 
line 46067: # define expandBlob ( P ) ( ( ( P ) -> flags & MEM_Zero ) ? sqlite3VdbeMemExpandBlob ( P ) : 0 ) 
line 46082: SQLITE_PRIVATE int sqlite3VdbeChangeEncoding ( Mem * pMem , int desiredEnc ) { 
line 46083: int rc ; 
line 46084: assert ( ( pMem -> flags & MEM_RowSet ) == 0 ) ; 
line 46085: assert ( desiredEnc == SQLITE_UTF8 || desiredEnc == SQLITE_UTF16LE 
line 46086: || desiredEnc == SQLITE_UTF16BE ) ; 
line 46087: if ( ! ( pMem -> flags & MEM_Str ) || pMem -> enc == desiredEnc ) { 
line 46088: return SQLITE_OK ; 
line 46089: } 
line 46090: assert ( pMem -> db == 0 || sqlite3_mutex_held ( pMem -> db -> mutex ) ) ; 
line 46091: # ifdef SQLITE_OMIT_UTF16 
line 46092: return SQLITE_ERROR ; 
line 46093: # else 
line 46098: rc = sqlite3VdbeMemTranslate ( pMem , ( u8 ) desiredEnc ) ; 
line 46099: assert ( rc == SQLITE_OK || rc == SQLITE_NOMEM ) ; 
line 46100: assert ( rc == SQLITE_OK || pMem -> enc != desiredEnc ) ; 
line 46101: assert ( rc == SQLITE_NOMEM || pMem -> enc == desiredEnc ) ; 
line 46102: return rc ; 
line 46103: # endif 
line 46104: } 
line 46119: SQLITE_PRIVATE int sqlite3VdbeMemGrow ( Mem * pMem , int n , int preserve ) { 
line 46120: assert ( 1 >= 
line 46121: ( ( pMem -> zMalloc && pMem -> zMalloc == pMem -> z ) ? 1 : 0 ) + 
line 46122: ( ( ( pMem -> flags & MEM_Dyn ) && pMem -> xDel ) ? 1 : 0 ) + 
line 46123: ( ( pMem -> flags & MEM_Ephem ) ? 1 : 0 ) + 
line 46124: ( ( pMem -> flags & MEM_Static ) ? 1 : 0 ) 
line 46125: ) ; 
line 46126: assert ( ( pMem -> flags & MEM_RowSet ) == 0 ) ; 
line 46128: if ( n < 32 ) n = 32 ; 
line 46129: if ( sqlite3DbMallocSize ( pMem -> db , pMem -> zMalloc ) < n ) { 
line 46130: if ( preserve && pMem -> z == pMem -> zMalloc ) { 
line 46131: pMem -> z = pMem -> zMalloc = sqlite3DbReallocOrFree ( pMem -> db , pMem -> z , n ) ; 
line 46132: preserve = 0 ; 
line 46133: } else { 
line 46134: sqlite3DbFree ( pMem -> db , pMem -> zMalloc ) ; 
line 46135: pMem -> zMalloc = sqlite3DbMallocRaw ( pMem -> db , n ) ; 
line 46136: } 
line 46137: } 
line 46139: if ( pMem -> z && preserve && pMem -> zMalloc && pMem -> z != pMem -> zMalloc ) { 
line 46140: memcpy ( pMem -> zMalloc , pMem -> z , pMem -> n ) ; 
line 46141: } 
line 46142: if ( pMem -> flags & MEM_Dyn && pMem -> xDel ) { 
line 46143: pMem -> xDel ( ( void * ) ( pMem -> z ) ) ; 
line 46144: } 
line 46146: pMem -> z = pMem -> zMalloc ; 
line 46147: if ( pMem -> z == 0 ) { 
line 46148: pMem -> flags = MEM_Null ; 
line 46149: } else { 
line 46150: pMem -> flags &= ~ ( MEM_Ephem | MEM_Static ) ; 
line 46151: } 
line 46152: pMem -> xDel = 0 ; 
line 46153: return ( pMem -> z ? SQLITE_OK : SQLITE_NOMEM ) ; 
line 46154: } 
line 46164: SQLITE_PRIVATE int sqlite3VdbeMemMakeWriteable ( Mem * pMem ) { 
line 46165: int f ; 
line 46166: assert ( pMem -> db == 0 || sqlite3_mutex_held ( pMem -> db -> mutex ) ) ; 
line 46167: assert ( ( pMem -> flags & MEM_RowSet ) == 0 ) ; 
line 46168: expandBlob ( pMem ) ; 
line 46169: f = pMem -> flags ; 
line 46170: if ( ( f & ( MEM_Str | MEM_Blob ) ) && pMem -> z != pMem -> zMalloc ) { 
line 46171: if ( sqlite3VdbeMemGrow ( pMem , pMem -> n + 2 , 1 ) ) { 
line 46172: return SQLITE_NOMEM ; 
line 46173: } 
line 46174: pMem -> z [ pMem -> n ] = 0 ; 
line 46175: pMem -> z [ pMem -> n + 1 ] = 0 ; 
line 46176: pMem -> flags |= MEM_Term ; 
line 46177: } 
line 46179: return SQLITE_OK ; 
line 46180: } 
line 46186: # ifndef SQLITE_OMIT_INCRBLOB 
line 46187: SQLITE_PRIVATE int sqlite3VdbeMemExpandBlob ( Mem * pMem ) { 
line 46188: if ( pMem -> flags & MEM_Zero ) { 
line 46189: int nByte ; 
line 46190: assert ( pMem -> flags & MEM_Blob ) ; 
line 46191: assert ( ( pMem -> flags & MEM_RowSet ) == 0 ) ; 
line 46192: assert ( pMem -> db == 0 || sqlite3_mutex_held ( pMem -> db -> mutex ) ) ; 
line 46195: nByte = pMem -> n + pMem -> u . nZero ; 
line 46196: if ( nByte <= 0 ) { 
line 46197: nByte = 1 ; 
line 46198: } 
line 46199: if ( sqlite3VdbeMemGrow ( pMem , nByte , 1 ) ) { 
line 46200: return SQLITE_NOMEM ; 
line 46201: } 
line 46203: memset ( & pMem -> z [ pMem -> n ] , 0 , pMem -> u . nZero ) ; 
line 46204: pMem -> n += pMem -> u . nZero ; 
line 46205: pMem -> flags &= ~ ( MEM_Zero | MEM_Term ) ; 
line 46206: } 
line 46207: return SQLITE_OK ; 
line 46208: } 
line 46209: # endif 
line 46215: SQLITE_PRIVATE int sqlite3VdbeMemNulTerminate ( Mem * pMem ) { 
line 46216: assert ( pMem -> db == 0 || sqlite3_mutex_held ( pMem -> db -> mutex ) ) ; 
line 46217: if ( ( pMem -> flags & MEM_Term ) != 0 || ( pMem -> flags & MEM_Str ) == 0 ) { 
line 46218: return SQLITE_OK ; 
line 46219: } 
line 46220: if ( sqlite3VdbeMemGrow ( pMem , pMem -> n + 2 , 1 ) ) { 
line 46221: return SQLITE_NOMEM ; 
line 46222: } 
line 46223: pMem -> z [ pMem -> n ] = 0 ; 
line 46224: pMem -> z [ pMem -> n + 1 ] = 0 ; 
line 46225: pMem -> flags |= MEM_Term ; 
line 46226: return SQLITE_OK ; 
line 46227: } 
line 46242: SQLITE_PRIVATE int sqlite3VdbeMemStringify ( Mem * pMem , int enc ) { 
line 46243: int rc = SQLITE_OK ; 
line 46244: int fg = pMem -> flags ; 
line 46245: const int nByte = 32 ; 
line 46247: assert ( pMem -> db == 0 || sqlite3_mutex_held ( pMem -> db -> mutex ) ) ; 
line 46248: assert ( ! ( fg & MEM_Zero ) ) ; 
line 46249: assert ( ! ( fg & ( MEM_Str | MEM_Blob ) ) ) ; 
line 46250: assert ( fg & ( MEM_Int | MEM_Real ) ) ; 
line 46251: assert ( ( pMem -> flags & MEM_RowSet ) == 0 ) ; 
line 46252: assert ( EIGHT_BYTE_ALIGNMENT ( pMem ) ) ; 
line 46255: if ( sqlite3VdbeMemGrow ( pMem , nByte , 0 ) ) { 
line 46256: return SQLITE_NOMEM ; 
line 46257: } 
line 46265: if ( fg & MEM_Int ) { 
line 46266: sqlite3_snprintf ( nByte , pMem -> z , "%lld" , pMem -> u . i ) ; 
line 46267: } else { 
line 46268: assert ( fg & MEM_Real ) ; 
line 46269: sqlite3_snprintf ( nByte , pMem -> z , "%!.15g" , pMem -> r ) ; 
line 46270: } 
line 46271: pMem -> n = sqlite3Strlen30 ( pMem -> z ) ; 
line 46272: pMem -> enc = SQLITE_UTF8 ; 
line 46273: pMem -> flags |= MEM_Str | MEM_Term ; 
line 46274: sqlite3VdbeChangeEncoding ( pMem , enc ) ; 
line 46275: return rc ; 
line 46276: } 
line 46286: SQLITE_PRIVATE int sqlite3VdbeMemFinalize ( Mem * pMem , FuncDef * pFunc ) { 
line 46287: int rc = SQLITE_OK ; 
line 46288: if ( ALWAYS ( pFunc && pFunc -> xFinalize ) ) { 
line 46289: sqlite3_context ctx ; 
line 46290: assert ( ( pMem -> flags & MEM_Null ) != 0 || pFunc == pMem -> u . pDef ) ; 
line 46291: assert ( pMem -> db == 0 || sqlite3_mutex_held ( pMem -> db -> mutex ) ) ; 
line 46292: memset ( & ctx , 0 , sizeof ( ctx ) ) ; 
line 46293: ctx . s . flags = MEM_Null ; 
line 46294: ctx . s . db = pMem -> db ; 
line 46295: ctx . pMem = pMem ; 
line 46296: ctx . pFunc = pFunc ; 
line 46297: pFunc -> xFinalize ( & ctx ) ; 
line 46298: assert ( 0 == ( pMem -> flags & MEM_Dyn ) && ! pMem -> xDel ) ; 
line 46299: sqlite3DbFree ( pMem -> db , pMem -> zMalloc ) ; 
line 46300: memcpy ( pMem , & ctx . s , sizeof ( ctx . s ) ) ; 
line 46301: rc = ctx . isError ; 
line 46302: } 
line 46303: return rc ; 
line 46304: } 
line 46311: SQLITE_PRIVATE void sqlite3VdbeMemReleaseExternal ( Mem * p ) { 
line 46312: assert ( p -> db == 0 || sqlite3_mutex_held ( p -> db -> mutex ) ) ; 
line 46313: testcase ( p -> flags & MEM_Agg ) ; 
line 46314: testcase ( p -> flags & MEM_Dyn ) ; 
line 46315: testcase ( p -> flags & MEM_RowSet ) ; 
line 46316: testcase ( p -> flags & MEM_Frame ) ; 
line 46317: if ( p -> flags & ( MEM_Agg | MEM_Dyn | MEM_RowSet | MEM_Frame ) ) { 
line 46318: if ( p -> flags & MEM_Agg ) { 
line 46319: sqlite3VdbeMemFinalize ( p , p -> u . pDef ) ; 
line 46320: assert ( ( p -> flags & MEM_Agg ) == 0 ) ; 
line 46321: sqlite3VdbeMemRelease ( p ) ; 
line 46322: } else if ( p -> flags & MEM_Dyn && p -> xDel ) { 
line 46323: assert ( ( p -> flags & MEM_RowSet ) == 0 ) ; 
line 46324: p -> xDel ( ( void * ) p -> z ) ; 
line 46325: p -> xDel = 0 ; 
line 46326: } else if ( p -> flags & MEM_RowSet ) { 
line 46327: sqlite3RowSetClear ( p -> u . pRowSet ) ; 
line 46328: } else if ( p -> flags & MEM_Frame ) { 
line 46329: sqlite3VdbeMemSetNull ( p ) ; 
line 46330: } 
line 46331: } 
line 46332: } 
line 46339: SQLITE_PRIVATE void sqlite3VdbeMemRelease ( Mem * p ) { 
line 46340: sqlite3VdbeMemReleaseExternal ( p ) ; 
line 46341: sqlite3DbFree ( p -> db , p -> zMalloc ) ; 
line 46342: p -> z = 0 ; 
line 46343: p -> zMalloc = 0 ; 
line 46344: p -> xDel = 0 ; 
line 46345: } 
line 46359: static i64 doubleToInt64 ( double r ) { 
line 46367: static const i64 maxInt = LARGEST_INT64 ; 
line 46368: static const i64 minInt = SMALLEST_INT64 ; 
line 46370: if ( r < ( double ) minInt ) { 
line 46371: return minInt ; 
line 46372: } else if ( r > ( double ) maxInt ) { 
line 46377: return minInt ; 
line 46378: } else { 
line 46379: return ( i64 ) r ; 
line 46380: } 
line 46381: } 
line 46394: SQLITE_PRIVATE i64 sqlite3VdbeIntValue ( Mem * pMem ) { 
line 46395: int flags ; 
line 46396: assert ( pMem -> db == 0 || sqlite3_mutex_held ( pMem -> db -> mutex ) ) ; 
line 46397: assert ( EIGHT_BYTE_ALIGNMENT ( pMem ) ) ; 
line 46398: flags = pMem -> flags ; 
line 46399: if ( flags & MEM_Int ) { 
line 46400: return pMem -> u . i ; 
line 46401: } else if ( flags & MEM_Real ) { 
line 46402: return doubleToInt64 ( pMem -> r ) ; 
line 46403: } else if ( flags & ( MEM_Str | MEM_Blob ) ) { 
line 46404: i64 value ; 
line 46405: pMem -> flags |= MEM_Str ; 
line 46406: if ( sqlite3VdbeChangeEncoding ( pMem , SQLITE_UTF8 ) 
line 46407: || sqlite3VdbeMemNulTerminate ( pMem ) ) { 
line 46408: return 0 ; 
line 46409: } 
line 46410: assert ( pMem -> z ) ; 
line 46411: sqlite3Atoi64 ( pMem -> z , & value ) ; 
line 46412: return value ; 
line 46413: } else { 
line 46414: return 0 ; 
line 46415: } 
line 46416: } 
line 46424: SQLITE_PRIVATE double sqlite3VdbeRealValue ( Mem * pMem ) { 
line 46425: assert ( pMem -> db == 0 || sqlite3_mutex_held ( pMem -> db -> mutex ) ) ; 
line 46426: assert ( EIGHT_BYTE_ALIGNMENT ( pMem ) ) ; 
line 46427: if ( pMem -> flags & MEM_Real ) { 
line 46428: return pMem -> r ; 
line 46429: } else if ( pMem -> flags & MEM_Int ) { 
line 46430: return ( double ) pMem -> u . i ; 
line 46431: } else if ( pMem -> flags & ( MEM_Str | MEM_Blob ) ) { 
line 46433: double val = ( double ) 0 ; 
line 46434: pMem -> flags |= MEM_Str ; 
line 46435: if ( sqlite3VdbeChangeEncoding ( pMem , SQLITE_UTF8 ) 
line 46436: || sqlite3VdbeMemNulTerminate ( pMem ) ) { 
line 46438: return ( double ) 0 ; 
line 46439: } 
line 46440: assert ( pMem -> z ) ; 
line 46441: sqlite3AtoF ( pMem -> z , & val ) ; 
line 46442: return val ; 
line 46443: } else { 
line 46445: return ( double ) 0 ; 
line 46446: } 
line 46447: } 
line 46453: SQLITE_PRIVATE void sqlite3VdbeIntegerAffinity ( Mem * pMem ) { 
line 46454: assert ( pMem -> flags & MEM_Real ) ; 
line 46455: assert ( ( pMem -> flags & MEM_RowSet ) == 0 ) ; 
line 46456: assert ( pMem -> db == 0 || sqlite3_mutex_held ( pMem -> db -> mutex ) ) ; 
line 46457: assert ( EIGHT_BYTE_ALIGNMENT ( pMem ) ) ; 
line 46459: pMem -> u . i = doubleToInt64 ( pMem -> r ) ; 
line 46473: if ( pMem -> r == ( double ) pMem -> u . i && pMem -> u . i > SMALLEST_INT64 
line 46474: && ALWAYS ( pMem -> u . i < LARGEST_INT64 ) ) { 
line 46475: pMem -> flags |= MEM_Int ; 
line 46476: } 
line 46477: } 
line 46482: SQLITE_PRIVATE int sqlite3VdbeMemIntegerify ( Mem * pMem ) { 
line 46483: assert ( pMem -> db == 0 || sqlite3_mutex_held ( pMem -> db -> mutex ) ) ; 
line 46484: assert ( ( pMem -> flags & MEM_RowSet ) == 0 ) ; 
line 46485: assert ( EIGHT_BYTE_ALIGNMENT ( pMem ) ) ; 
line 46487: pMem -> u . i = sqlite3VdbeIntValue ( pMem ) ; 
line 46488: MemSetTypeFlag ( pMem , MEM_Int ) ; 
line 46489: return SQLITE_OK ; 
line 46490: } 
line 46496: SQLITE_PRIVATE int sqlite3VdbeMemRealify ( Mem * pMem ) { 
line 46497: assert ( pMem -> db == 0 || sqlite3_mutex_held ( pMem -> db -> mutex ) ) ; 
line 46498: assert ( EIGHT_BYTE_ALIGNMENT ( pMem ) ) ; 
line 46500: pMem -> r = sqlite3VdbeRealValue ( pMem ) ; 
line 46501: MemSetTypeFlag ( pMem , MEM_Real ) ; 
line 46502: return SQLITE_OK ; 
line 46503: } 
line 46509: SQLITE_PRIVATE int sqlite3VdbeMemNumerify ( Mem * pMem ) { 
line 46510: double r1 , r2 ; 
line 46511: i64 i ; 
line 46512: assert ( ( pMem -> flags & ( MEM_Int | MEM_Real | MEM_Null ) ) == 0 ) ; 
line 46513: assert ( ( pMem -> flags & ( MEM_Blob | MEM_Str ) ) != 0 ) ; 
line 46514: assert ( pMem -> db == 0 || sqlite3_mutex_held ( pMem -> db -> mutex ) ) ; 
line 46515: r1 = sqlite3VdbeRealValue ( pMem ) ; 
line 46516: i = doubleToInt64 ( r1 ) ; 
line 46517: r2 = ( double ) i ; 
line 46518: if ( r1 == r2 ) { 
line 46519: sqlite3VdbeMemIntegerify ( pMem ) ; 
line 46520: } else { 
line 46521: pMem -> r = r1 ; 
line 46522: MemSetTypeFlag ( pMem , MEM_Real ) ; 
line 46523: } 
line 46524: return SQLITE_OK ; 
line 46525: } 
line 46530: SQLITE_PRIVATE void sqlite3VdbeMemSetNull ( Mem * pMem ) { 
line 46531: if ( pMem -> flags & MEM_Frame ) { 
line 46532: sqlite3VdbeFrameDelete ( pMem -> u . pFrame ) ; 
line 46533: } 
line 46534: if ( pMem -> flags & MEM_RowSet ) { 
line 46535: sqlite3RowSetClear ( pMem -> u . pRowSet ) ; 
line 46536: } 
line 46537: MemSetTypeFlag ( pMem , MEM_Null ) ; 
line 46538: pMem -> type = SQLITE_NULL ; 
line 46539: } 
line 46545: SQLITE_PRIVATE void sqlite3VdbeMemSetZeroBlob ( Mem * pMem , int n ) { 
line 46546: sqlite3VdbeMemRelease ( pMem ) ; 
line 46547: pMem -> flags = MEM_Blob | MEM_Zero ; 
line 46548: pMem -> type = SQLITE_BLOB ; 
line 46549: pMem -> n = 0 ; 
line 46550: if ( n < 0 ) n = 0 ; 
line 46551: pMem -> u . nZero = n ; 
line 46552: pMem -> enc = SQLITE_UTF8 ; 
line 46554: # ifdef SQLITE_OMIT_INCRBLOB 
line 46555: sqlite3VdbeMemGrow ( pMem , n , 0 ) ; 
line 46556: if ( pMem -> z ) { 
line 46557: pMem -> n = n ; 
line 46558: memset ( pMem -> z , 0 , n ) ; 
line 46559: } 
line 46560: # endif 
line 46561: } 
line 46567: SQLITE_PRIVATE void sqlite3VdbeMemSetInt64 ( Mem * pMem , i64 val ) { 
line 46568: sqlite3VdbeMemRelease ( pMem ) ; 
line 46569: pMem -> u . i = val ; 
line 46570: pMem -> flags = MEM_Int ; 
line 46571: pMem -> type = SQLITE_INTEGER ; 
line 46572: } 
line 46578: SQLITE_PRIVATE void sqlite3VdbeMemSetDouble ( Mem * pMem , double val ) { 
line 46579: if ( sqlite3IsNaN ( val ) ) { 
line 46580: sqlite3VdbeMemSetNull ( pMem ) ; 
line 46581: } else { 
line 46582: sqlite3VdbeMemRelease ( pMem ) ; 
line 46583: pMem -> r = val ; 
line 46584: pMem -> flags = MEM_Real ; 
line 46585: pMem -> type = SQLITE_FLOAT ; 
line 46586: } 
line 46587: } 
line 46593: SQLITE_PRIVATE void sqlite3VdbeMemSetRowSet ( Mem * pMem ) { 
line 46594: sqlite3 * db = pMem -> db ; 
line 46595: assert ( db != 0 ) ; 
line 46596: assert ( ( pMem -> flags & MEM_RowSet ) == 0 ) ; 
line 46597: sqlite3VdbeMemRelease ( pMem ) ; 
line 46598: pMem -> zMalloc = sqlite3DbMallocRaw ( db , 64 ) ; 
line 46599: if ( db -> mallocFailed ) { 
line 46600: pMem -> flags = MEM_Null ; 
line 46601: } else { 
line 46602: assert ( pMem -> zMalloc ) ; 
line 46603: pMem -> u . pRowSet = sqlite3RowSetInit ( db , pMem -> zMalloc , 
line 46604: sqlite3DbMallocSize ( db , pMem -> zMalloc ) ) ; 
line 46605: assert ( pMem -> u . pRowSet != 0 ) ; 
line 46606: pMem -> flags = MEM_RowSet ; 
line 46607: } 
line 46608: } 
line 46614: SQLITE_PRIVATE int sqlite3VdbeMemTooBig ( Mem * p ) { 
line 46615: assert ( p -> db != 0 ) ; 
line 46616: if ( p -> flags & ( MEM_Str | MEM_Blob ) ) { 
line 46617: int n = p -> n ; 
line 46618: if ( p -> flags & MEM_Zero ) { 
line 46619: n += p -> u . nZero ; 
line 46620: } 
line 46621: return n > p -> db -> aLimit [ SQLITE_LIMIT_LENGTH ] ; 
line 46622: } 
line 46623: return 0 ; 
line 46624: } 
line 46629: # define MEMCELLSIZE ( size_t ) ( & ( ( ( Mem * ) 0 ) -> zMalloc ) ) 
line 46637: SQLITE_PRIVATE void sqlite3VdbeMemShallowCopy ( Mem * pTo , const Mem * pFrom , int srcType ) { 
line 46638: assert ( ( pFrom -> flags & MEM_RowSet ) == 0 ) ; 
line 46639: sqlite3VdbeMemReleaseExternal ( pTo ) ; 
line 46640: memcpy ( pTo , pFrom , MEMCELLSIZE ) ; 
line 46641: pTo -> xDel = 0 ; 
line 46642: if ( ( pFrom -> flags & MEM_Dyn ) != 0 || pFrom -> z == pFrom -> zMalloc ) { 
line 46643: pTo -> flags &= ~ ( MEM_Dyn | MEM_Static | MEM_Ephem ) ; 
line 46644: assert ( srcType == MEM_Ephem || srcType == MEM_Static ) ; 
line 46645: pTo -> flags |= srcType ; 
line 46646: } 
line 46647: } 
line 46653: SQLITE_PRIVATE int sqlite3VdbeMemCopy ( Mem * pTo , const Mem * pFrom ) { 
line 46654: int rc = SQLITE_OK ; 
line 46656: assert ( ( pFrom -> flags & MEM_RowSet ) == 0 ) ; 
line 46657: sqlite3VdbeMemReleaseExternal ( pTo ) ; 
line 46658: memcpy ( pTo , pFrom , MEMCELLSIZE ) ; 
line 46659: pTo -> flags &= ~ MEM_Dyn ; 
line 46661: if ( pTo -> flags & ( MEM_Str | MEM_Blob ) ) { 
line 46662: if ( 0 == ( pFrom -> flags & MEM_Static ) ) { 
line 46663: pTo -> flags |= MEM_Ephem ; 
line 46664: rc = sqlite3VdbeMemMakeWriteable ( pTo ) ; 
line 46665: } 
line 46666: } 
line 46668: return rc ; 
line 46669: } 
line 46677: SQLITE_PRIVATE void sqlite3VdbeMemMove ( Mem * pTo , Mem * pFrom ) { 
line 46678: assert ( pFrom -> db == 0 || sqlite3_mutex_held ( pFrom -> db -> mutex ) ) ; 
line 46679: assert ( pTo -> db == 0 || sqlite3_mutex_held ( pTo -> db -> mutex ) ) ; 
line 46680: assert ( pFrom -> db == 0 || pTo -> db == 0 || pFrom -> db == pTo -> db ) ; 
line 46682: sqlite3VdbeMemRelease ( pTo ) ; 
line 46683: memcpy ( pTo , pFrom , sizeof ( Mem ) ) ; 
line 46684: pFrom -> flags = MEM_Null ; 
line 46685: pFrom -> xDel = 0 ; 
line 46686: pFrom -> zMalloc = 0 ; 
line 46687: } 
line 46704: SQLITE_PRIVATE int sqlite3VdbeMemSetStr ( 
line 46705: Mem * pMem , 
line 46706: const char * z , 
line 46707: int n , 
line 46708: u8 enc , 
line 46709: void ( * xDel ) ( void * ) 
line 46710: ) { 
line 46711: int nByte = n ; 
line 46712: int iLimit ; 
line 46713: u16 flags = 0 ; 
line 46715: assert ( pMem -> db == 0 || sqlite3_mutex_held ( pMem -> db -> mutex ) ) ; 
line 46716: assert ( ( pMem -> flags & MEM_RowSet ) == 0 ) ; 
line 46719: if ( ! z ) { 
line 46720: sqlite3VdbeMemSetNull ( pMem ) ; 
line 46721: return SQLITE_OK ; 
line 46722: } 
line 46724: if ( pMem -> db ) { 
line 46725: iLimit = pMem -> db -> aLimit [ SQLITE_LIMIT_LENGTH ] ; 
line 46726: } else { 
line 46727: iLimit = SQLITE_MAX_LENGTH ; 
line 46728: } 
line 46729: flags = ( enc == 0 ? MEM_Blob : MEM_Str ) ; 
line 46730: if ( nByte < 0 ) { 
line 46731: assert ( enc != 0 ) ; 
line 46732: if ( enc == SQLITE_UTF8 ) { 
line 46733: for ( nByte = 0 ; nByte <= iLimit && z [ nByte ] ; nByte ++ ) { } 
line 46734: } else { 
line 46735: for ( nByte = 0 ; nByte <= iLimit && ( z [ nByte ] | z [ nByte + 1 ] ) ; nByte += 2 ) { } 
line 46736: } 
line 46737: flags |= MEM_Term ; 
line 46738: } 
line 46744: if ( xDel == SQLITE_TRANSIENT ) { 
line 46745: int nAlloc = nByte ; 
line 46746: if ( flags & MEM_Term ) { 
line 46747: nAlloc += ( enc == SQLITE_UTF8 ? 1 : 2 ) ; 
line 46748: } 
line 46749: if ( nByte > iLimit ) { 
line 46750: return SQLITE_TOOBIG ; 
line 46751: } 
line 46752: if ( sqlite3VdbeMemGrow ( pMem , nAlloc , 0 ) ) { 
line 46753: return SQLITE_NOMEM ; 
line 46754: } 
line 46755: memcpy ( pMem -> z , z , nAlloc ) ; 
line 46756: } else if ( xDel == SQLITE_DYNAMIC ) { 
line 46757: sqlite3VdbeMemRelease ( pMem ) ; 
line 46758: pMem -> zMalloc = pMem -> z = ( char * ) z ; 
line 46759: pMem -> xDel = 0 ; 
line 46760: } else { 
line 46761: sqlite3VdbeMemRelease ( pMem ) ; 
line 46762: pMem -> z = ( char * ) z ; 
line 46763: pMem -> xDel = xDel ; 
line 46764: flags |= ( ( xDel == SQLITE_STATIC ) ? MEM_Static : MEM_Dyn ) ; 
line 46765: } 
line 46767: pMem -> n = nByte ; 
line 46768: pMem -> flags = flags ; 
line 46769: pMem -> enc = ( enc == 0 ? SQLITE_UTF8 : enc ) ; 
line 46770: pMem -> type = ( enc == 0 ? SQLITE_BLOB : SQLITE_TEXT ) ; 
line 46772: # ifndef SQLITE_OMIT_UTF16 
line 46773: if ( pMem -> enc != SQLITE_UTF8 && sqlite3VdbeMemHandleBom ( pMem ) ) { 
line 46774: return SQLITE_NOMEM ; 
line 46775: } 
line 46776: # endif 
line 46778: if ( nByte > iLimit ) { 
line 46779: return SQLITE_TOOBIG ; 
line 46780: } 
line 46782: return SQLITE_OK ; 
line 46783: } 
line 46794: SQLITE_PRIVATE int sqlite3MemCompare ( const Mem * pMem1 , const Mem * pMem2 , const CollSeq * pColl ) { 
line 46795: int rc ; 
line 46796: int f1 , f2 ; 
line 46797: int combined_flags ; 
line 46799: f1 = pMem1 -> flags ; 
line 46800: f2 = pMem2 -> flags ; 
line 46801: combined_flags = f1 | f2 ; 
line 46802: assert ( ( combined_flags & MEM_RowSet ) == 0 ) ; 
line 46807: if ( combined_flags & MEM_Null ) { 
line 46808: return ( f2 & MEM_Null ) - ( f1 & MEM_Null ) ; 
line 46809: } 
line 46815: if ( combined_flags & ( MEM_Int | MEM_Real ) ) { 
line 46816: if ( ! ( f1 & ( MEM_Int | MEM_Real ) ) ) { 
line 46817: return 1 ; 
line 46818: } 
line 46819: if ( ! ( f2 & ( MEM_Int | MEM_Real ) ) ) { 
line 46820: return - 1 ; 
line 46821: } 
line 46822: if ( ( f1 & f2 & MEM_Int ) == 0 ) { 
line 46823: double r1 , r2 ; 
line 46824: if ( ( f1 & MEM_Real ) == 0 ) { 
line 46825: r1 = ( double ) pMem1 -> u . i ; 
line 46826: } else { 
line 46827: r1 = pMem1 -> r ; 
line 46828: } 
line 46829: if ( ( f2 & MEM_Real ) == 0 ) { 
line 46830: r2 = ( double ) pMem2 -> u . i ; 
line 46831: } else { 
line 46832: r2 = pMem2 -> r ; 
line 46833: } 
line 46834: if ( r1 < r2 ) return - 1 ; 
line 46835: if ( r1 > r2 ) return 1 ; 
line 46836: return 0 ; 
line 46837: } else { 
line 46838: assert ( f1 & MEM_Int ) ; 
line 46839: assert ( f2 & MEM_Int ) ; 
line 46840: if ( pMem1 -> u . i < pMem2 -> u . i ) return - 1 ; 
line 46841: if ( pMem1 -> u . i > pMem2 -> u . i ) return 1 ; 
line 46842: return 0 ; 
line 46843: } 
line 46844: } 
line 46849: if ( combined_flags & MEM_Str ) { 
line 46850: if ( ( f1 & MEM_Str ) == 0 ) { 
line 46851: return 1 ; 
line 46852: } 
line 46853: if ( ( f2 & MEM_Str ) == 0 ) { 
line 46854: return - 1 ; 
line 46855: } 
line 46857: assert ( pMem1 -> enc == pMem2 -> enc ) ; 
line 46858: assert ( pMem1 -> enc == SQLITE_UTF8 || 
line 46859: pMem1 -> enc == SQLITE_UTF16LE || pMem1 -> enc == SQLITE_UTF16BE ) ; 
line 46865: assert ( ! pColl || pColl -> xCmp ) ; 
line 46867: if ( pColl ) { 
line 46868: if ( pMem1 -> enc == pColl -> enc ) { 
line 46871: return pColl -> xCmp ( pColl -> pUser , pMem1 -> n , pMem1 -> z , pMem2 -> n , pMem2 -> z ) ; 
line 46872: } else { 
line 46873: const void * v1 , * v2 ; 
line 46874: int n1 , n2 ; 
line 46875: Mem c1 ; 
line 46876: Mem c2 ; 
line 46877: memset ( & c1 , 0 , sizeof ( c1 ) ) ; 
line 46878: memset ( & c2 , 0 , sizeof ( c2 ) ) ; 
line 46879: sqlite3VdbeMemShallowCopy ( & c1 , pMem1 , MEM_Ephem ) ; 
line 46880: sqlite3VdbeMemShallowCopy ( & c2 , pMem2 , MEM_Ephem ) ; 
line 46881: v1 = sqlite3ValueText ( ( sqlite3_value * ) & c1 , pColl -> enc ) ; 
line 46882: n1 = v1 == 0 ? 0 : c1 . n ; 
line 46883: v2 = sqlite3ValueText ( ( sqlite3_value * ) & c2 , pColl -> enc ) ; 
line 46884: n2 = v2 == 0 ? 0 : c2 . n ; 
line 46885: rc = pColl -> xCmp ( pColl -> pUser , n1 , v1 , n2 , v2 ) ; 
line 46886: sqlite3VdbeMemRelease ( & c1 ) ; 
line 46887: sqlite3VdbeMemRelease ( & c2 ) ; 
line 46888: return rc ; 
line 46889: } 
line 46890: } 
line 46893: } 
line 46896: rc = memcmp ( pMem1 -> z , pMem2 -> z , ( pMem1 -> n > pMem2 -> n ) ? pMem2 -> n : pMem1 -> n ) ; 
line 46897: if ( rc == 0 ) { 
line 46898: rc = pMem1 -> n - pMem2 -> n ; 
line 46899: } 
line 46900: return rc ; 
line 46901: } 
line 46916: SQLITE_PRIVATE int sqlite3VdbeMemFromBtree ( 
line 46917: BtCursor * pCur , 
line 46918: int offset , 
line 46919: int amt , 
line 46920: int key , 
line 46921: Mem * pMem 
line 46922: ) { 
line 46923: char * zData ; 
line 46924: int available = 0 ; 
line 46925: int rc = SQLITE_OK ; 
line 46927: assert ( sqlite3BtreeCursorIsValid ( pCur ) ) ; 
line 46931: assert ( ( pMem -> flags & MEM_RowSet ) == 0 ) ; 
line 46932: if ( key ) { 
line 46933: zData = ( char * ) sqlite3BtreeKeyFetch ( pCur , & available ) ; 
line 46934: } else { 
line 46935: zData = ( char * ) sqlite3BtreeDataFetch ( pCur , & available ) ; 
line 46936: } 
line 46937: assert ( zData != 0 ) ; 
line 46939: if ( offset + amt <= available && ( pMem -> flags & MEM_Dyn ) == 0 ) { 
line 46940: sqlite3VdbeMemRelease ( pMem ) ; 
line 46941: pMem -> z = & zData [ offset ] ; 
line 46942: pMem -> flags = MEM_Blob | MEM_Ephem ; 
line 46943: } else if ( SQLITE_OK == ( rc = sqlite3VdbeMemGrow ( pMem , amt + 2 , 0 ) ) ) { 
line 46944: pMem -> flags = MEM_Blob | MEM_Dyn | MEM_Term ; 
line 46945: pMem -> enc = 0 ; 
line 46946: pMem -> type = SQLITE_BLOB ; 
line 46947: if ( key ) { 
line 46948: rc = sqlite3BtreeKey ( pCur , offset , amt , pMem -> z ) ; 
line 46949: } else { 
line 46950: rc = sqlite3BtreeData ( pCur , offset , amt , pMem -> z ) ; 
line 46951: } 
line 46952: pMem -> z [ amt ] = 0 ; 
line 46953: pMem -> z [ amt + 1 ] = 0 ; 
line 46954: if ( rc != SQLITE_OK ) { 
line 46955: sqlite3VdbeMemRelease ( pMem ) ; 
line 46956: } 
line 46957: } 
line 46958: pMem -> n = amt ; 
line 46960: return rc ; 
line 46961: } 
line 46973: SQLITE_PRIVATE const void * sqlite3ValueText ( sqlite3_value * pVal , u8 enc ) { 
line 46974: if ( ! pVal ) return 0 ; 
line 46976: assert ( pVal -> db == 0 || sqlite3_mutex_held ( pVal -> db -> mutex ) ) ; 
line 46977: assert ( ( enc & 3 ) == ( enc & ~ SQLITE_UTF16_ALIGNED ) ) ; 
line 46978: assert ( ( pVal -> flags & MEM_RowSet ) == 0 ) ; 
line 46980: if ( pVal -> flags & MEM_Null ) { 
line 46981: return 0 ; 
line 46982: } 
line 46983: assert ( ( MEM_Blob >> 3 ) == MEM_Str ) ; 
line 46984: pVal -> flags |= ( pVal -> flags & MEM_Blob ) >> 3 ; 
line 46985: expandBlob ( pVal ) ; 
line 46986: if ( pVal -> flags & MEM_Str ) { 
line 46987: sqlite3VdbeChangeEncoding ( pVal , enc & ~ SQLITE_UTF16_ALIGNED ) ; 
line 46988: if ( ( enc & SQLITE_UTF16_ALIGNED ) != 0 && 1 == ( 1 & SQLITE_PTR_TO_INT ( pVal -> z ) ) ) { 
line 46989: assert ( ( pVal -> flags & ( MEM_Ephem | MEM_Static ) ) != 0 ) ; 
line 46990: if ( sqlite3VdbeMemMakeWriteable ( pVal ) != SQLITE_OK ) { 
line 46991: return 0 ; 
line 46992: } 
line 46993: } 
line 46994: sqlite3VdbeMemNulTerminate ( pVal ) ; 
line 46995: } else { 
line 46996: assert ( ( pVal -> flags & MEM_Blob ) == 0 ) ; 
line 46997: sqlite3VdbeMemStringify ( pVal , enc ) ; 
line 46998: assert ( 0 == ( 1 & SQLITE_PTR_TO_INT ( pVal -> z ) ) ) ; 
line 46999: } 
line 47000: assert ( pVal -> enc == ( enc & ~ SQLITE_UTF16_ALIGNED ) || pVal -> db == 0 
line 47001: || pVal -> db -> mallocFailed ) ; 
line 47002: if ( pVal -> enc == ( enc & ~ SQLITE_UTF16_ALIGNED ) ) { 
line 47003: return pVal -> z ; 
line 47004: } else { 
line 47005: return 0 ; 
line 47006: } 
line 47007: } 
line 47012: SQLITE_PRIVATE sqlite3_value * sqlite3ValueNew ( sqlite3 * db ) { 
line 47013: Mem * p = sqlite3DbMallocZero ( db , sizeof ( * p ) ) ; 
line 47014: if ( p ) { 
line 47015: p -> flags = MEM_Null ; 
line 47016: p -> type = SQLITE_NULL ; 
line 47017: p -> db = db ; 
line 47018: } 
line 47019: return p ; 
line 47020: } 
line 47032: SQLITE_PRIVATE int sqlite3ValueFromExpr ( 
line 47033: sqlite3 * db , 
line 47034: Expr * pExpr , 
line 47035: u8 enc , 
line 47036: u8 affinity , 
line 47037: sqlite3_value * * ppVal 
line 47038: ) { 
line 47039: int op ; 
line 47040: char * zVal = 0 ; 
line 47041: sqlite3_value * pVal = 0 ; 
line 47043: if ( ! pExpr ) { 
line 47044: * ppVal = 0 ; 
line 47045: return SQLITE_OK ; 
line 47046: } 
line 47047: op = pExpr -> op ; 
line 47048: if ( op == TK_REGISTER ) { 
line 47049: op = pExpr -> op2 ; 
line 47050: } 
line 47052: if ( op == TK_STRING || op == TK_FLOAT || op == TK_INTEGER ) { 
line 47053: pVal = sqlite3ValueNew ( db ) ; 
line 47054: if ( pVal == 0 ) goto no_mem ; 
line 47055: if ( ExprHasProperty ( pExpr , EP_IntValue ) ) { 
line 47056: sqlite3VdbeMemSetInt64 ( pVal , ( i64 ) pExpr -> u . iValue ) ; 
line 47057: } else { 
line 47058: zVal = sqlite3DbStrDup ( db , pExpr -> u . zToken ) ; 
line 47059: if ( zVal == 0 ) goto no_mem ; 
line 47060: sqlite3ValueSetStr ( pVal , - 1 , zVal , SQLITE_UTF8 , SQLITE_DYNAMIC ) ; 
line 47061: if ( op == TK_FLOAT ) pVal -> type = SQLITE_FLOAT ; 
line 47062: } 
line 47063: if ( ( op == TK_INTEGER || op == TK_FLOAT ) && affinity == SQLITE_AFF_NONE ) { 
line 47064: sqlite3ValueApplyAffinity ( pVal , SQLITE_AFF_NUMERIC , SQLITE_UTF8 ) ; 
line 47065: } else { 
line 47066: sqlite3ValueApplyAffinity ( pVal , affinity , SQLITE_UTF8 ) ; 
line 47067: } 
line 47068: if ( enc != SQLITE_UTF8 ) { 
line 47069: sqlite3VdbeChangeEncoding ( pVal , enc ) ; 
line 47070: } 
line 47071: } else if ( op == TK_UMINUS ) { 
line 47072: if ( SQLITE_OK == sqlite3ValueFromExpr ( db , pExpr -> pLeft , enc , affinity , & pVal ) ) { 
line 47073: pVal -> u . i = - 1 * pVal -> u . i ; 
line 47075: pVal -> r = ( double ) - 1 * pVal -> r ; 
line 47076: } 
line 47077: } 
line 47078: # ifndef SQLITE_OMIT_BLOB_LITERAL 
line 47079: else if ( op == TK_BLOB ) { 
line 47080: int nVal ; 
line 47081: assert ( pExpr -> u . zToken [ 0 ] == 'x' || pExpr -> u . zToken [ 0 ] == 'X' ) ; 
line 47082: assert ( pExpr -> u . zToken [ 1 ] == '\'' ) ; 
line 47083: pVal = sqlite3ValueNew ( db ) ; 
line 47084: if ( ! pVal ) goto no_mem ; 
line 47085: zVal = & pExpr -> u . zToken [ 2 ] ; 
line 47086: nVal = sqlite3Strlen30 ( zVal ) - 1 ; 
line 47087: assert ( zVal [ nVal ] == '\'' ) ; 
line 47088: sqlite3VdbeMemSetStr ( pVal , sqlite3HexToBlob ( db , zVal , nVal ) , nVal / 2 , 
line 47089: 0 , SQLITE_DYNAMIC ) ; 
line 47090: } 
line 47091: # endif 
line 47093: if ( pVal ) { 
line 47094: sqlite3VdbeMemStoreType ( pVal ) ; 
line 47095: } 
line 47096: * ppVal = pVal ; 
line 47097: return SQLITE_OK ; 
line 47099: no_mem : 
line 47100: db -> mallocFailed = 1 ; 
line 47101: sqlite3DbFree ( db , zVal ) ; 
line 47102: sqlite3ValueFree ( pVal ) ; 
line 47103: * ppVal = 0 ; 
line 47104: return SQLITE_NOMEM ; 
line 47105: } 
line 47110: SQLITE_PRIVATE void sqlite3ValueSetStr ( 
line 47111: sqlite3_value * v , 
line 47112: int n , 
line 47113: const void * z , 
line 47114: u8 enc , 
line 47115: void ( * xDel ) ( void * ) 
line 47116: ) { 
line 47117: if ( v ) sqlite3VdbeMemSetStr ( ( Mem * ) v , z , n , enc , xDel ) ; 
line 47118: } 
line 47123: SQLITE_PRIVATE void sqlite3ValueFree ( sqlite3_value * v ) { 
line 47124: if ( ! v ) return ; 
line 47125: sqlite3VdbeMemRelease ( ( Mem * ) v ) ; 
line 47126: sqlite3DbFree ( ( ( Mem * ) v ) -> db , v ) ; 
line 47127: } 
line 47133: SQLITE_PRIVATE int sqlite3ValueBytes ( sqlite3_value * pVal , u8 enc ) { 
line 47134: Mem * p = ( Mem * ) pVal ; 
line 47135: if ( ( p -> flags & MEM_Blob ) != 0 || sqlite3ValueText ( pVal , enc ) ) { 
line 47136: if ( p -> flags & MEM_Zero ) { 
line 47137: return p -> n + p -> u . nZero ; 
line 47138: } else { 
line 47139: return p -> n ; 
line 47140: } 
line 47141: } 
line 47142: return 0 ; 
line 47143: } 
line 47171: # ifdef SQLITE_DEBUG 
line 47172: SQLITE_PRIVATE int sqlite3VdbeAddopTrace = 0 ; 
line 47173: # endif 
line 47179: SQLITE_PRIVATE Vdbe * sqlite3VdbeCreate ( sqlite3 * db ) { 
line 47180: Vdbe * p ; 
line 47181: p = sqlite3DbMallocZero ( db , sizeof ( Vdbe ) ) ; 
line 47182: if ( p == 0 ) return 0 ; 
line 47183: p -> db = db ; 
line 47184: if ( db -> pVdbe ) { 
line 47185: db -> pVdbe -> pPrev = p ; 
line 47186: } 
line 47187: p -> pNext = db -> pVdbe ; 
line 47188: p -> pPrev = 0 ; 
line 47189: db -> pVdbe = p ; 
line 47190: p -> magic = VDBE_MAGIC_INIT ; 
line 47191: return p ; 
line 47192: } 
line 47197: SQLITE_PRIVATE void sqlite3VdbeSetSql ( Vdbe * p , const char * z , int n , int isPrepareV2 ) { 
line 47198: assert ( isPrepareV2 == 1 || isPrepareV2 == 0 ) ; 
line 47199: if ( p == 0 ) return ; 
line 47200: # ifdef SQLITE_OMIT_TRACE 
line 47201: if ( ! isPrepareV2 ) return ; 
line 47202: # endif 
line 47203: assert ( p -> zSql == 0 ) ; 
line 47204: p -> zSql = sqlite3DbStrNDup ( p -> db , z , n ) ; 
line 47205: p -> isPrepareV2 = ( u8 ) isPrepareV2 ; 
line 47206: } 
line 47211: SQLITE_API const char * sqlite3_sql ( sqlite3_stmt * pStmt ) { 
line 47212: Vdbe * p = ( Vdbe * ) pStmt ; 
line 47213: return ( p -> isPrepareV2 ? p -> zSql : 0 ) ; 
line 47214: } 
line 47219: SQLITE_PRIVATE void sqlite3VdbeSwap ( Vdbe * pA , Vdbe * pB ) { 
line 47220: Vdbe tmp , * pTmp ; 
line 47221: char * zTmp ; 
line 47222: tmp = * pA ; 
line 47223: * pA = * pB ; 
line 47224: * pB = tmp ; 
line 47225: pTmp = pA -> pNext ; 
line 47226: pA -> pNext = pB -> pNext ; 
line 47227: pB -> pNext = pTmp ; 
line 47228: pTmp = pA -> pPrev ; 
line 47229: pA -> pPrev = pB -> pPrev ; 
line 47230: pB -> pPrev = pTmp ; 
line 47231: zTmp = pA -> zSql ; 
line 47232: pA -> zSql = pB -> zSql ; 
line 47233: pB -> zSql = zTmp ; 
line 47234: pB -> isPrepareV2 = pA -> isPrepareV2 ; 
line 47235: } 
line 47237: # ifdef SQLITE_DEBUG 
line 47241: SQLITE_PRIVATE void sqlite3VdbeTrace ( Vdbe * p , FILE * trace ) { 
line 47242: p -> trace = trace ; 
line 47243: } 
line 47244: # endif 
line 47255: static int growOpArray ( Vdbe * p ) { 
line 47256: VdbeOp * pNew ; 
line 47257: int nNew = ( p -> nOpAlloc ? p -> nOpAlloc * 2 : ( int ) ( 1024 / sizeof ( Op ) ) ) ; 
line 47258: pNew = sqlite3DbRealloc ( p -> db , p -> aOp , nNew * sizeof ( Op ) ) ; 
line 47259: if ( pNew ) { 
line 47260: p -> nOpAlloc = sqlite3DbMallocSize ( p -> db , pNew ) / sizeof ( Op ) ; 
line 47261: p -> aOp = pNew ; 
line 47262: } 
line 47263: return ( pNew ? SQLITE_OK : SQLITE_NOMEM ) ; 
line 47264: } 
line 47282: SQLITE_PRIVATE int sqlite3VdbeAddOp3 ( Vdbe * p , int op , int p1 , int p2 , int p3 ) { 
line 47283: int i ; 
line 47284: VdbeOp * pOp ; 
line 47286: i = p -> nOp ; 
line 47287: assert ( p -> magic == VDBE_MAGIC_INIT ) ; 
line 47288: assert ( op > 0 && op < 0xff ) ; 
line 47289: if ( p -> nOpAlloc <= i ) { 
line 47290: if ( growOpArray ( p ) ) { 
line 47291: return 1 ; 
line 47292: } 
line 47293: } 
line 47294: p -> nOp ++ ; 
line 47295: pOp = & p -> aOp [ i ] ; 
line 47296: pOp -> opcode = ( u8 ) op ; 
line 47297: pOp -> p5 = 0 ; 
line 47298: pOp -> p1 = p1 ; 
line 47299: pOp -> p2 = p2 ; 
line 47300: pOp -> p3 = p3 ; 
line 47301: pOp -> p4 . p = 0 ; 
line 47302: pOp -> p4type = P4_NOTUSED ; 
line 47303: p -> expired = 0 ; 
line 47304: # ifdef SQLITE_DEBUG 
line 47305: pOp -> zComment = 0 ; 
line 47306: if ( sqlite3VdbeAddopTrace ) sqlite3VdbePrintOp ( 0 , i , & p -> aOp [ i ] ) ; 
line 47307: # endif 
line 47308: # ifdef VDBE_PROFILE 
line 47309: pOp -> cycles = 0 ; 
line 47310: pOp -> cnt = 0 ; 
line 47311: # endif 
line 47312: return i ; 
line 47313: } 
line 47314: SQLITE_PRIVATE int sqlite3VdbeAddOp0 ( Vdbe * p , int op ) { 
line 47315: return sqlite3VdbeAddOp3 ( p , op , 0 , 0 , 0 ) ; 
line 47316: } 
line 47317: SQLITE_PRIVATE int sqlite3VdbeAddOp1 ( Vdbe * p , int op , int p1 ) { 
line 47318: return sqlite3VdbeAddOp3 ( p , op , p1 , 0 , 0 ) ; 
line 47319: } 
line 47320: SQLITE_PRIVATE int sqlite3VdbeAddOp2 ( Vdbe * p , int op , int p1 , int p2 ) { 
line 47321: return sqlite3VdbeAddOp3 ( p , op , p1 , p2 , 0 ) ; 
line 47322: } 
line 47328: SQLITE_PRIVATE int sqlite3VdbeAddOp4 ( 
line 47329: Vdbe * p , 
line 47330: int op , 
line 47331: int p1 , 
line 47332: int p2 , 
line 47333: int p3 , 
line 47334: const char * zP4 , 
line 47335: int p4type 
line 47336: ) { 
line 47337: int addr = sqlite3VdbeAddOp3 ( p , op , p1 , p2 , p3 ) ; 
line 47338: sqlite3VdbeChangeP4 ( p , addr , zP4 , p4type ) ; 
line 47339: return addr ; 
line 47340: } 
line 47345: SQLITE_PRIVATE int sqlite3VdbeAddOp4Int ( 
line 47346: Vdbe * p , 
line 47347: int op , 
line 47348: int p1 , 
line 47349: int p2 , 
line 47350: int p3 , 
line 47351: int p4 
line 47352: ) { 
line 47353: int addr = sqlite3VdbeAddOp3 ( p , op , p1 , p2 , p3 ) ; 
line 47354: sqlite3VdbeChangeP4 ( p , addr , SQLITE_INT_TO_PTR ( p4 ) , P4_INT32 ) ; 
line 47355: return addr ; 
line 47356: } 
line 47372: SQLITE_PRIVATE int sqlite3VdbeMakeLabel ( Vdbe * p ) { 
line 47373: int i ; 
line 47374: i = p -> nLabel ++ ; 
line 47375: assert ( p -> magic == VDBE_MAGIC_INIT ) ; 
line 47376: if ( i >= p -> nLabelAlloc ) { 
line 47377: int n = p -> nLabelAlloc * 2 + 5 ; 
line 47378: p -> aLabel = sqlite3DbReallocOrFree ( p -> db , p -> aLabel , 
line 47379: n * sizeof ( p -> aLabel [ 0 ] ) ) ; 
line 47380: p -> nLabelAlloc = sqlite3DbMallocSize ( p -> db , p -> aLabel ) / sizeof ( p -> aLabel [ 0 ] ) ; 
line 47381: } 
line 47382: if ( p -> aLabel ) { 
line 47383: p -> aLabel [ i ] = - 1 ; 
line 47384: } 
line 47385: return - 1 - i ; 
line 47386: } 
line 47393: SQLITE_PRIVATE void sqlite3VdbeResolveLabel ( Vdbe * p , int x ) { 
line 47394: int j = - 1 - x ; 
line 47395: assert ( p -> magic == VDBE_MAGIC_INIT ) ; 
line 47396: assert ( j >= 0 && j < p -> nLabel ) ; 
line 47397: if ( p -> aLabel ) { 
line 47398: p -> aLabel [ j ] = p -> nOp ; 
line 47399: } 
line 47400: } 
line 47402: # ifdef SQLITE_DEBUG 
line 47420: typedef struct VdbeOpIter VdbeOpIter ; 
line 47421: struct VdbeOpIter { 
line 47422: Vdbe * v ; 
line 47423: SubProgram * * apSub ; 
line 47424: int nSub ; 
line 47425: int iAddr ; 
line 47426: int iSub ; 
line 47427: } ; 
line 47428: static Op * opIterNext ( VdbeOpIter * p ) { 
line 47429: Vdbe * v = p -> v ; 
line 47430: Op * pRet = 0 ; 
line 47431: Op * aOp ; 
line 47432: int nOp ; 
line 47434: if ( p -> iSub <= p -> nSub ) { 
line 47436: if ( p -> iSub == 0 ) { 
line 47437: aOp = v -> aOp ; 
line 47438: nOp = v -> nOp ; 
line 47439: } else { 
line 47440: aOp = p -> apSub [ p -> iSub - 1 ] -> aOp ; 
line 47441: nOp = p -> apSub [ p -> iSub - 1 ] -> nOp ; 
line 47442: } 
line 47443: assert ( p -> iAddr < nOp ) ; 
line 47445: pRet = & aOp [ p -> iAddr ] ; 
line 47446: p -> iAddr ++ ; 
line 47447: if ( p -> iAddr == nOp ) { 
line 47448: p -> iSub ++ ; 
line 47449: p -> iAddr = 0 ; 
line 47450: } 
line 47452: if ( pRet -> p4type == P4_SUBPROGRAM ) { 
line 47453: int nByte = ( p -> nSub + 1 ) * sizeof ( SubProgram * ) ; 
line 47454: int j ; 
line 47455: for ( j = 0 ; j < p -> nSub ; j ++ ) { 
line 47456: if ( p -> apSub [ j ] == pRet -> p4 . pProgram ) break ; 
line 47457: } 
line 47458: if ( j == p -> nSub ) { 
line 47459: p -> apSub = sqlite3DbReallocOrFree ( v -> db , p -> apSub , nByte ) ; 
line 47460: if ( ! p -> apSub ) { 
line 47461: pRet = 0 ; 
line 47462: } else { 
line 47463: p -> apSub [ p -> nSub ++ ] = pRet -> p4 . pProgram ; 
line 47464: } 
line 47465: } 
line 47466: } 
line 47467: } 
line 47469: return pRet ; 
line 47470: } 
line 47492: SQLITE_PRIVATE int sqlite3VdbeAssertMayAbort ( Vdbe * v , int mayAbort ) { 
line 47493: int hasAbort = 0 ; 
line 47494: Op * pOp ; 
line 47495: VdbeOpIter sIter ; 
line 47496: memset ( & sIter , 0 , sizeof ( sIter ) ) ; 
line 47497: sIter . v = v ; 
line 47499: while ( ( pOp = opIterNext ( & sIter ) ) != 0 ) { 
line 47500: int opcode = pOp -> opcode ; 
line 47501: if ( opcode == OP_Destroy || opcode == OP_VUpdate || opcode == OP_VRename 
line 47502: # ifndef SQLITE_OMIT_FOREIGN_KEY 
line 47503: || ( opcode == OP_FkCounter && pOp -> p1 == 0 && pOp -> p2 == 1 ) 
line 47504: # endif 
line 47505: || ( ( opcode == OP_Halt || opcode == OP_HaltIfNull ) 
line 47506: && ( pOp -> p1 == SQLITE_CONSTRAINT && pOp -> p2 == OE_Abort ) ) 
line 47507: ) { 
line 47508: hasAbort = 1 ; 
line 47509: break ; 
line 47510: } 
line 47511: } 
line 47512: sqlite3DbFree ( v -> db , sIter . apSub ) ; 
line 47519: return ( v -> db -> mallocFailed || hasAbort == mayAbort ) ; 
line 47520: } 
line 47521: # endif 
line 47536: static void resolveP2Values ( Vdbe * p , int * pMaxFuncArgs ) { 
line 47537: int i ; 
line 47538: int nMaxArgs = * pMaxFuncArgs ; 
line 47539: Op * pOp ; 
line 47540: int * aLabel = p -> aLabel ; 
line 47541: p -> readOnly = 1 ; 
line 47542: for ( pOp = p -> aOp , i = p -> nOp - 1 ; i >= 0 ; i -- , pOp ++ ) { 
line 47543: u8 opcode = pOp -> opcode ; 
line 47545: pOp -> opflags = sqlite3OpcodeProperty [ opcode ] ; 
line 47546: if ( opcode == OP_Function || opcode == OP_AggStep ) { 
line 47547: if ( pOp -> p5 > nMaxArgs ) nMaxArgs = pOp -> p5 ; 
line 47548: } else if ( opcode == OP_Transaction && pOp -> p2 != 0 ) { 
line 47549: p -> readOnly = 0 ; 
line 47550: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 47551: } else if ( opcode == OP_VUpdate ) { 
line 47552: if ( pOp -> p2 > nMaxArgs ) nMaxArgs = pOp -> p2 ; 
line 47553: } else if ( opcode == OP_VFilter ) { 
line 47554: int n ; 
line 47555: assert ( p -> nOp - i >= 3 ) ; 
line 47556: assert ( pOp [ - 1 ] . opcode == OP_Integer ) ; 
line 47557: n = pOp [ - 1 ] . p1 ; 
line 47558: if ( n > nMaxArgs ) nMaxArgs = n ; 
line 47559: # endif 
line 47560: } 
line 47562: if ( ( pOp -> opflags & OPFLG_JUMP ) != 0 && pOp -> p2 < 0 ) { 
line 47563: assert ( - 1 - pOp -> p2 < p -> nLabel ) ; 
line 47564: pOp -> p2 = aLabel [ - 1 - pOp -> p2 ] ; 
line 47565: } 
line 47566: } 
line 47567: sqlite3DbFree ( p -> db , p -> aLabel ) ; 
line 47568: p -> aLabel = 0 ; 
line 47570: * pMaxFuncArgs = nMaxArgs ; 
line 47571: } 
line 47576: SQLITE_PRIVATE int sqlite3VdbeCurrentAddr ( Vdbe * p ) { 
line 47577: assert ( p -> magic == VDBE_MAGIC_INIT ) ; 
line 47578: return p -> nOp ; 
line 47579: } 
line 47592: SQLITE_PRIVATE VdbeOp * sqlite3VdbeTakeOpArray ( Vdbe * p , int * pnOp , int * pnMaxArg ) { 
line 47593: VdbeOp * aOp = p -> aOp ; 
line 47594: assert ( aOp && ! p -> db -> mallocFailed ) ; 
line 47597: assert ( p -> aMutex . nMutex == 0 ) ; 
line 47599: resolveP2Values ( p , pnMaxArg ) ; 
line 47600: * pnOp = p -> nOp ; 
line 47601: p -> aOp = 0 ; 
line 47602: return aOp ; 
line 47603: } 
line 47609: SQLITE_PRIVATE int sqlite3VdbeAddOpList ( Vdbe * p , int nOp , VdbeOpList const * aOp ) { 
line 47610: int addr ; 
line 47611: assert ( p -> magic == VDBE_MAGIC_INIT ) ; 
line 47612: if ( p -> nOp + nOp > p -> nOpAlloc && growOpArray ( p ) ) { 
line 47613: return 0 ; 
line 47614: } 
line 47615: addr = p -> nOp ; 
line 47616: if ( ALWAYS ( nOp > 0 ) ) { 
line 47617: int i ; 
line 47618: VdbeOpList const * pIn = aOp ; 
line 47619: for ( i = 0 ; i < nOp ; i ++ , pIn ++ ) { 
line 47620: int p2 = pIn -> p2 ; 
line 47621: VdbeOp * pOut = & p -> aOp [ i + addr ] ; 
line 47622: pOut -> opcode = pIn -> opcode ; 
line 47623: pOut -> p1 = pIn -> p1 ; 
line 47624: if ( p2 < 0 && ( sqlite3OpcodeProperty [ pOut -> opcode ] & OPFLG_JUMP ) != 0 ) { 
line 47625: pOut -> p2 = addr + ADDR ( p2 ) ; 
line 47626: } else { 
line 47627: pOut -> p2 = p2 ; 
line 47628: } 
line 47629: pOut -> p3 = pIn -> p3 ; 
line 47630: pOut -> p4type = P4_NOTUSED ; 
line 47631: pOut -> p4 . p = 0 ; 
line 47632: pOut -> p5 = 0 ; 
line 47633: # ifdef SQLITE_DEBUG 
line 47634: pOut -> zComment = 0 ; 
line 47635: if ( sqlite3VdbeAddopTrace ) { 
line 47636: sqlite3VdbePrintOp ( 0 , i + addr , & p -> aOp [ i + addr ] ) ; 
line 47637: } 
line 47638: # endif 
line 47639: } 
line 47640: p -> nOp += nOp ; 
line 47641: } 
line 47642: return addr ; 
line 47643: } 
line 47651: SQLITE_PRIVATE void sqlite3VdbeChangeP1 ( Vdbe * p , int addr , int val ) { 
line 47652: assert ( p != 0 ) ; 
line 47653: assert ( addr >= 0 ) ; 
line 47654: if ( p -> nOp > addr ) { 
line 47655: p -> aOp [ addr ] . p1 = val ; 
line 47656: } 
line 47657: } 
line 47663: SQLITE_PRIVATE void sqlite3VdbeChangeP2 ( Vdbe * p , int addr , int val ) { 
line 47664: assert ( p != 0 ) ; 
line 47665: assert ( addr >= 0 ) ; 
line 47666: if ( p -> nOp > addr ) { 
line 47667: p -> aOp [ addr ] . p2 = val ; 
line 47668: } 
line 47669: } 
line 47674: SQLITE_PRIVATE void sqlite3VdbeChangeP3 ( Vdbe * p , int addr , int val ) { 
line 47675: assert ( p != 0 ) ; 
line 47676: assert ( addr >= 0 ) ; 
line 47677: if ( p -> nOp > addr ) { 
line 47678: p -> aOp [ addr ] . p3 = val ; 
line 47679: } 
line 47680: } 
line 47686: SQLITE_PRIVATE void sqlite3VdbeChangeP5 ( Vdbe * p , u8 val ) { 
line 47687: assert ( p != 0 ) ; 
line 47688: if ( p -> aOp ) { 
line 47689: assert ( p -> nOp > 0 ) ; 
line 47690: p -> aOp [ p -> nOp - 1 ] . p5 = val ; 
line 47691: } 
line 47692: } 
line 47698: SQLITE_PRIVATE void sqlite3VdbeJumpHere ( Vdbe * p , int addr ) { 
line 47699: sqlite3VdbeChangeP2 ( p , addr , p -> nOp ) ; 
line 47700: } 
line 47707: static void freeEphemeralFunction ( sqlite3 * db , FuncDef * pDef ) { 
line 47708: if ( ALWAYS ( pDef ) && ( pDef -> flags & SQLITE_FUNC_EPHEM ) != 0 ) { 
line 47709: sqlite3DbFree ( db , pDef ) ; 
line 47710: } 
line 47711: } 
line 47716: static void freeP4 ( sqlite3 * db , int p4type , void * p4 ) { 
line 47717: if ( p4 ) { 
line 47718: switch ( p4type ) { 
line 47719: case P4_REAL : 
line 47720: case P4_INT64 : 
line 47721: case P4_MPRINTF : 
line 47722: case P4_DYNAMIC : 
line 47723: case P4_KEYINFO : 
line 47724: case P4_INTARRAY : 
line 47725: case P4_KEYINFO_HANDOFF : { 
line 47726: sqlite3DbFree ( db , p4 ) ; 
line 47727: break ; 
line 47728: } 
line 47729: case P4_VDBEFUNC : { 
line 47730: VdbeFunc * pVdbeFunc = ( VdbeFunc * ) p4 ; 
line 47731: freeEphemeralFunction ( db , pVdbeFunc -> pFunc ) ; 
line 47732: sqlite3VdbeDeleteAuxData ( pVdbeFunc , 0 ) ; 
line 47733: sqlite3DbFree ( db , pVdbeFunc ) ; 
line 47734: break ; 
line 47735: } 
line 47736: case P4_FUNCDEF : { 
line 47737: freeEphemeralFunction ( db , ( FuncDef * ) p4 ) ; 
line 47738: break ; 
line 47739: } 
line 47740: case P4_MEM : { 
line 47741: sqlite3ValueFree ( ( sqlite3_value * ) p4 ) ; 
line 47742: break ; 
line 47743: } 
line 47744: case P4_VTAB : { 
line 47745: sqlite3VtabUnlock ( ( VTable * ) p4 ) ; 
line 47746: break ; 
line 47747: } 
line 47748: case P4_SUBPROGRAM : { 
line 47749: sqlite3VdbeProgramDelete ( db , ( SubProgram * ) p4 , 1 ) ; 
line 47750: break ; 
line 47751: } 
line 47752: } 
line 47753: } 
line 47754: } 
line 47761: static void vdbeFreeOpArray ( sqlite3 * db , Op * aOp , int nOp ) { 
line 47762: if ( aOp ) { 
line 47763: Op * pOp ; 
line 47764: for ( pOp = aOp ; pOp < & aOp [ nOp ] ; pOp ++ ) { 
line 47765: freeP4 ( db , pOp -> p4type , pOp -> p4 . p ) ; 
line 47766: # ifdef SQLITE_DEBUG 
line 47767: sqlite3DbFree ( db , pOp -> zComment ) ; 
line 47768: # endif 
line 47769: } 
line 47770: } 
line 47771: sqlite3DbFree ( db , aOp ) ; 
line 47772: } 
line 47787: SQLITE_PRIVATE void sqlite3VdbeProgramDelete ( sqlite3 * db , SubProgram * p , int freeop ) { 
line 47788: if ( p ) { 
line 47789: assert ( p -> nRef > 0 ) ; 
line 47790: if ( freeop || p -> nRef == 1 ) { 
line 47791: Op * aOp = p -> aOp ; 
line 47792: p -> aOp = 0 ; 
line 47793: vdbeFreeOpArray ( db , aOp , p -> nOp ) ; 
line 47794: p -> nOp = 0 ; 
line 47795: } 
line 47796: p -> nRef -- ; 
line 47797: if ( p -> nRef == 0 ) { 
line 47798: sqlite3DbFree ( db , p ) ; 
line 47799: } 
line 47800: } 
line 47801: } 
line 47807: SQLITE_PRIVATE void sqlite3VdbeChangeToNoop ( Vdbe * p , int addr , int N ) { 
line 47808: if ( p -> aOp ) { 
line 47809: VdbeOp * pOp = & p -> aOp [ addr ] ; 
line 47810: sqlite3 * db = p -> db ; 
line 47811: while ( N -- ) { 
line 47812: freeP4 ( db , pOp -> p4type , pOp -> p4 . p ) ; 
line 47813: memset ( pOp , 0 , sizeof ( pOp [ 0 ] ) ) ; 
line 47814: pOp -> opcode = OP_Noop ; 
line 47815: pOp ++ ; 
line 47816: } 
line 47817: } 
line 47818: } 
line 47845: SQLITE_PRIVATE void sqlite3VdbeChangeP4 ( Vdbe * p , int addr , const char * zP4 , int n ) { 
line 47846: Op * pOp ; 
line 47847: sqlite3 * db ; 
line 47848: assert ( p != 0 ) ; 
line 47849: db = p -> db ; 
line 47850: assert ( p -> magic == VDBE_MAGIC_INIT ) ; 
line 47851: if ( p -> aOp == 0 || db -> mallocFailed ) { 
line 47852: if ( n != P4_KEYINFO && n != P4_VTAB ) { 
line 47853: freeP4 ( db , n , ( void * ) * ( char * * ) & zP4 ) ; 
line 47854: } 
line 47855: return ; 
line 47856: } 
line 47857: assert ( p -> nOp > 0 ) ; 
line 47858: assert ( addr < p -> nOp ) ; 
line 47859: if ( addr < 0 ) { 
line 47860: addr = p -> nOp - 1 ; 
line 47861: } 
line 47862: pOp = & p -> aOp [ addr ] ; 
line 47863: freeP4 ( db , pOp -> p4type , pOp -> p4 . p ) ; 
line 47864: pOp -> p4 . p = 0 ; 
line 47865: if ( n == P4_INT32 ) { 
line 47868: pOp -> p4 . i = SQLITE_PTR_TO_INT ( zP4 ) ; 
line 47869: pOp -> p4type = P4_INT32 ; 
line 47870: } else if ( zP4 == 0 ) { 
line 47871: pOp -> p4 . p = 0 ; 
line 47872: pOp -> p4type = P4_NOTUSED ; 
line 47873: } else if ( n == P4_KEYINFO ) { 
line 47874: KeyInfo * pKeyInfo ; 
line 47875: int nField , nByte ; 
line 47877: nField = ( ( KeyInfo * ) zP4 ) -> nField ; 
line 47878: nByte = sizeof ( * pKeyInfo ) + ( nField - 1 ) * sizeof ( pKeyInfo -> aColl [ 0 ] ) + nField ; 
line 47879: pKeyInfo = sqlite3Malloc ( nByte ) ; 
line 47880: pOp -> p4 . pKeyInfo = pKeyInfo ; 
line 47881: if ( pKeyInfo ) { 
line 47882: u8 * aSortOrder ; 
line 47883: memcpy ( pKeyInfo , zP4 , nByte ) ; 
line 47884: aSortOrder = pKeyInfo -> aSortOrder ; 
line 47885: if ( aSortOrder ) { 
line 47886: pKeyInfo -> aSortOrder = ( unsigned char * ) & pKeyInfo -> aColl [ nField ] ; 
line 47887: memcpy ( pKeyInfo -> aSortOrder , aSortOrder , nField ) ; 
line 47888: } 
line 47889: pOp -> p4type = P4_KEYINFO ; 
line 47890: } else { 
line 47891: p -> db -> mallocFailed = 1 ; 
line 47892: pOp -> p4type = P4_NOTUSED ; 
line 47893: } 
line 47894: } else if ( n == P4_KEYINFO_HANDOFF ) { 
line 47895: pOp -> p4 . p = ( void * ) zP4 ; 
line 47896: pOp -> p4type = P4_KEYINFO ; 
line 47897: } else if ( n == P4_VTAB ) { 
line 47898: pOp -> p4 . p = ( void * ) zP4 ; 
line 47899: pOp -> p4type = P4_VTAB ; 
line 47900: sqlite3VtabLock ( ( VTable * ) zP4 ) ; 
line 47901: assert ( ( ( VTable * ) zP4 ) -> db == p -> db ) ; 
line 47902: } else if ( n < 0 ) { 
line 47903: pOp -> p4 . p = ( void * ) zP4 ; 
line 47904: pOp -> p4type = ( signed char ) n ; 
line 47905: } else { 
line 47906: if ( n == 0 ) n = sqlite3Strlen30 ( zP4 ) ; 
line 47907: pOp -> p4 . z = sqlite3DbStrNDup ( p -> db , zP4 , n ) ; 
line 47908: pOp -> p4type = P4_DYNAMIC ; 
line 47909: } 
line 47910: } 
line 47912: # ifndef NDEBUG 
line 47919: SQLITE_PRIVATE void sqlite3VdbeComment ( Vdbe * p , const char * zFormat , ... ) { 
line 47920: va_list ap ; 
line 47921: if ( ! p ) return ; 
line 47922: assert ( p -> nOp > 0 || p -> aOp == 0 ) ; 
line 47923: assert ( p -> aOp == 0 || p -> aOp [ p -> nOp - 1 ] . zComment == 0 || p -> db -> mallocFailed ) ; 
line 47924: if ( p -> nOp ) { 
line 47925: char * * pz = & p -> aOp [ p -> nOp - 1 ] . zComment ; 
line 47926: va_start ( ap , zFormat ) ; 
line 47927: sqlite3DbFree ( p -> db , * pz ) ; 
line 47928: * pz = sqlite3VMPrintf ( p -> db , zFormat , ap ) ; 
line 47929: va_end ( ap ) ; 
line 47930: } 
line 47931: } 
line 47932: SQLITE_PRIVATE void sqlite3VdbeNoopComment ( Vdbe * p , const char * zFormat , ... ) { 
line 47933: va_list ap ; 
line 47934: if ( ! p ) return ; 
line 47935: sqlite3VdbeAddOp0 ( p , OP_Noop ) ; 
line 47936: assert ( p -> nOp > 0 || p -> aOp == 0 ) ; 
line 47937: assert ( p -> aOp == 0 || p -> aOp [ p -> nOp - 1 ] . zComment == 0 || p -> db -> mallocFailed ) ; 
line 47938: if ( p -> nOp ) { 
line 47939: char * * pz = & p -> aOp [ p -> nOp - 1 ] . zComment ; 
line 47940: va_start ( ap , zFormat ) ; 
line 47941: sqlite3DbFree ( p -> db , * pz ) ; 
line 47942: * pz = sqlite3VMPrintf ( p -> db , zFormat , ap ) ; 
line 47943: va_end ( ap ) ; 
line 47944: } 
line 47945: } 
line 47946: # endif 
line 47966: SQLITE_PRIVATE VdbeOp * sqlite3VdbeGetOp ( Vdbe * p , int addr ) { 
line 47967: static VdbeOp dummy ; 
line 47968: assert ( p -> magic == VDBE_MAGIC_INIT ) ; 
line 47969: if ( addr < 0 ) { 
line 47970: # ifdef SQLITE_OMIT_TRACE 
line 47971: if ( p -> nOp == 0 ) return & dummy ; 
line 47972: # endif 
line 47973: addr = p -> nOp - 1 ; 
line 47974: } 
line 47975: assert ( ( addr >= 0 && addr < p -> nOp ) || p -> db -> mallocFailed ) ; 
line 47976: if ( p -> db -> mallocFailed ) { 
line 47977: return & dummy ; 
line 47978: } else { 
line 47979: return & p -> aOp [ addr ] ; 
line 47980: } 
line 47981: } 
line 47983: # if ! defined ( SQLITE_OMIT_EXPLAIN ) || ! defined ( NDEBUG ) 
line 47984: || defined ( VDBE_PROFILE ) || defined ( SQLITE_DEBUG ) 
line 47989: static char * displayP4 ( Op * pOp , char * zTemp , int nTemp ) { 
line 47990: char * zP4 = zTemp ; 
line 47991: assert ( nTemp >= 20 ) ; 
line 47992: switch ( pOp -> p4type ) { 
line 47993: case P4_KEYINFO_STATIC : 
line 47994: case P4_KEYINFO : { 
line 47995: int i , j ; 
line 47996: KeyInfo * pKeyInfo = pOp -> p4 . pKeyInfo ; 
line 47997: sqlite3_snprintf ( nTemp , zTemp , "keyinfo(%d" , pKeyInfo -> nField ) ; 
line 47998: i = sqlite3Strlen30 ( zTemp ) ; 
line 47999: for ( j = 0 ; j < pKeyInfo -> nField ; j ++ ) { 
line 48000: CollSeq * pColl = pKeyInfo -> aColl [ j ] ; 
line 48001: if ( pColl ) { 
line 48002: int n = sqlite3Strlen30 ( pColl -> zName ) ; 
line 48003: if ( i + n > nTemp - 6 ) { 
line 48004: memcpy ( & zTemp [ i ] , ",..." , 4 ) ; 
line 48005: break ; 
line 48006: } 
line 48007: zTemp [ i ++ ] = ',' ; 
line 48008: if ( pKeyInfo -> aSortOrder && pKeyInfo -> aSortOrder [ j ] ) { 
line 48009: zTemp [ i ++ ] = '-' ; 
line 48010: } 
line 48011: memcpy ( & zTemp [ i ] , pColl -> zName , n + 1 ) ; 
line 48012: i += n ; 
line 48013: } else if ( i + 4 < nTemp - 6 ) { 
line 48014: memcpy ( & zTemp [ i ] , ",nil" , 4 ) ; 
line 48015: i += 4 ; 
line 48016: } 
line 48017: } 
line 48018: zTemp [ i ++ ] = ')' ; 
line 48019: zTemp [ i ] = 0 ; 
line 48020: assert ( i < nTemp ) ; 
line 48021: break ; 
line 48022: } 
line 48023: case P4_COLLSEQ : { 
line 48024: CollSeq * pColl = pOp -> p4 . pColl ; 
line 48025: sqlite3_snprintf ( nTemp , zTemp , "collseq(%.20s)" , pColl -> zName ) ; 
line 48026: break ; 
line 48027: } 
line 48028: case P4_FUNCDEF : { 
line 48029: FuncDef * pDef = pOp -> p4 . pFunc ; 
line 48030: sqlite3_snprintf ( nTemp , zTemp , "%s(%d)" , pDef -> zName , pDef -> nArg ) ; 
line 48031: break ; 
line 48032: } 
line 48033: case P4_INT64 : { 
line 48034: sqlite3_snprintf ( nTemp , zTemp , "%lld" , * pOp -> p4 . pI64 ) ; 
line 48035: break ; 
line 48036: } 
line 48037: case P4_INT32 : { 
line 48038: sqlite3_snprintf ( nTemp , zTemp , "%d" , pOp -> p4 . i ) ; 
line 48039: break ; 
line 48040: } 
line 48041: case P4_REAL : { 
line 48042: sqlite3_snprintf ( nTemp , zTemp , "%.16g" , * pOp -> p4 . pReal ) ; 
line 48043: break ; 
line 48044: } 
line 48045: case P4_MEM : { 
line 48046: Mem * pMem = pOp -> p4 . pMem ; 
line 48047: assert ( ( pMem -> flags & MEM_Null ) == 0 ) ; 
line 48048: if ( pMem -> flags & MEM_Str ) { 
line 48049: zP4 = pMem -> z ; 
line 48050: } else if ( pMem -> flags & MEM_Int ) { 
line 48051: sqlite3_snprintf ( nTemp , zTemp , "%lld" , pMem -> u . i ) ; 
line 48052: } else if ( pMem -> flags & MEM_Real ) { 
line 48053: sqlite3_snprintf ( nTemp , zTemp , "%.16g" , pMem -> r ) ; 
line 48054: } else { 
line 48055: assert ( pMem -> flags & MEM_Blob ) ; 
line 48056: zP4 = "(blob)" ; 
line 48057: } 
line 48058: break ; 
line 48059: } 
line 48060: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 48061: case P4_VTAB : { 
line 48062: sqlite3_vtab * pVtab = pOp -> p4 . pVtab -> pVtab ; 
line 48063: sqlite3_snprintf ( nTemp , zTemp , "vtab:%p:%p" , pVtab , pVtab -> pModule ) ; 
line 48064: break ; 
line 48065: } 
line 48066: # endif 
line 48067: case P4_INTARRAY : { 
line 48068: sqlite3_snprintf ( nTemp , zTemp , "intarray" ) ; 
line 48069: break ; 
line 48070: } 
line 48071: case P4_SUBPROGRAM : { 
line 48072: sqlite3_snprintf ( nTemp , zTemp , "program" ) ; 
line 48073: break ; 
line 48074: } 
line 48075: default : { 
line 48076: zP4 = pOp -> p4 . z ; 
line 48077: if ( zP4 == 0 ) { 
line 48078: zP4 = zTemp ; 
line 48079: zTemp [ 0 ] = 0 ; 
line 48080: } 
line 48081: } 
line 48082: } 
line 48083: assert ( zP4 != 0 ) ; 
line 48084: return zP4 ; 
line 48085: } 
line 48086: # endif 
line 48091: SQLITE_PRIVATE void sqlite3VdbeUsesBtree ( Vdbe * p , int i ) { 
line 48092: int mask ; 
line 48093: assert ( i >= 0 && i < p -> db -> nDb && i < sizeof ( u32 ) * 8 ) ; 
line 48094: assert ( i < ( int ) sizeof ( p -> btreeMask ) * 8 ) ; 
line 48095: mask = ( ( u32 ) 1 ) << i ; 
line 48096: if ( ( p -> btreeMask & mask ) == 0 ) { 
line 48097: p -> btreeMask |= mask ; 
line 48098: sqlite3BtreeMutexArrayInsert ( & p -> aMutex , p -> db -> aDb [ i ] . pBt ) ; 
line 48099: } 
line 48100: } 
line 48103: # if defined ( VDBE_PROFILE ) || defined ( SQLITE_DEBUG ) 
line 48107: SQLITE_PRIVATE void sqlite3VdbePrintOp ( FILE * pOut , int pc , Op * pOp ) { 
line 48108: char * zP4 ; 
line 48109: char zPtr [ 50 ] ; 
line 48110: static const char * zFormat1 = "%4d %-13s %4d %4d %4d %-4s %.2X %s\n" ; 
line 48111: if ( pOut == 0 ) pOut = stdout ; 
line 48112: zP4 = displayP4 ( pOp , zPtr , sizeof ( zPtr ) ) ; 
line 48113: fprintf ( pOut , zFormat1 , pc , 
line 48114: sqlite3OpcodeName ( pOp -> opcode ) , pOp -> p1 , pOp -> p2 , pOp -> p3 , zP4 , pOp -> p5 , 
line 48115: # ifdef SQLITE_DEBUG 
line 48116: pOp -> zComment ? pOp -> zComment : "" 
line 48117: # else 
line 48118: "" 
line 48119: # endif 
line 48120: ) ; 
line 48121: fflush ( pOut ) ; 
line 48122: } 
line 48123: # endif 
line 48128: static void releaseMemArray ( Mem * p , int N ) { 
line 48129: if ( p && N ) { 
line 48130: Mem * pEnd ; 
line 48131: sqlite3 * db = p -> db ; 
line 48132: u8 malloc_failed = db -> mallocFailed ; 
line 48133: for ( pEnd = & p [ N ] ; p < pEnd ; p ++ ) { 
line 48134: assert ( ( & p [ 1 ] ) == pEnd || p [ 0 ] . db == p [ 1 ] . db ) ; 
line 48148: if ( p -> flags & ( MEM_Agg | MEM_Dyn | MEM_Frame | MEM_RowSet ) ) { 
line 48149: sqlite3VdbeMemRelease ( p ) ; 
line 48150: } else if ( p -> zMalloc ) { 
line 48151: sqlite3DbFree ( db , p -> zMalloc ) ; 
line 48152: p -> zMalloc = 0 ; 
line 48153: } 
line 48155: p -> flags = MEM_Null ; 
line 48156: } 
line 48157: db -> mallocFailed = malloc_failed ; 
line 48158: } 
line 48159: } 
line 48165: SQLITE_PRIVATE void sqlite3VdbeFrameDelete ( VdbeFrame * p ) { 
line 48166: int i ; 
line 48167: Mem * aMem = VdbeFrameMem ( p ) ; 
line 48168: VdbeCursor * * apCsr = ( VdbeCursor * * ) & aMem [ p -> nChildMem ] ; 
line 48169: for ( i = 0 ; i < p -> nChildCsr ; i ++ ) { 
line 48170: sqlite3VdbeFreeCursor ( p -> v , apCsr [ i ] ) ; 
line 48171: } 
line 48172: releaseMemArray ( aMem , p -> nChildMem ) ; 
line 48173: sqlite3DbFree ( p -> v -> db , p ) ; 
line 48174: } 
line 48176: # ifndef SQLITE_OMIT_EXPLAIN 
line 48192: SQLITE_PRIVATE int sqlite3VdbeList ( 
line 48193: Vdbe * p 
line 48194: ) { 
line 48195: int nRow ; 
line 48196: int nSub = 0 ; 
line 48197: SubProgram * * apSub = 0 ; 
line 48198: Mem * pSub = 0 ; 
line 48199: sqlite3 * db = p -> db ; 
line 48200: int i ; 
line 48201: int rc = SQLITE_OK ; 
line 48202: Mem * pMem = p -> pResultSet = & p -> aMem [ 1 ] ; 
line 48204: assert ( p -> explain ) ; 
line 48205: assert ( p -> magic == VDBE_MAGIC_RUN ) ; 
line 48206: assert ( db -> magic == SQLITE_MAGIC_BUSY ) ; 
line 48207: assert ( p -> rc == SQLITE_OK || p -> rc == SQLITE_BUSY || p -> rc == SQLITE_NOMEM ) ; 
line 48213: releaseMemArray ( pMem , 8 ) ; 
line 48215: if ( p -> rc == SQLITE_NOMEM ) { 
line 48218: db -> mallocFailed = 1 ; 
line 48219: return SQLITE_ERROR ; 
line 48220: } 
line 48229: nRow = p -> nOp ; 
line 48230: if ( p -> explain == 1 ) { 
line 48235: assert ( p -> nMem > 9 ) ; 
line 48236: pSub = & p -> aMem [ 9 ] ; 
line 48237: if ( pSub -> flags & MEM_Blob ) { 
line 48240: nSub = pSub -> n / sizeof ( Vdbe * ) ; 
line 48241: apSub = ( SubProgram * * ) pSub -> z ; 
line 48242: } 
line 48243: for ( i = 0 ; i < nSub ; i ++ ) { 
line 48244: nRow += apSub [ i ] -> nOp ; 
line 48245: } 
line 48246: } 
line 48248: do { 
line 48249: i = p -> pc ++ ; 
line 48250: } while ( i < nRow && p -> explain == 2 && p -> aOp [ i ] . opcode != OP_Explain ) ; 
line 48251: if ( i >= nRow ) { 
line 48252: p -> rc = SQLITE_OK ; 
line 48253: rc = SQLITE_DONE ; 
line 48254: } else if ( db -> u1 . isInterrupted ) { 
line 48255: p -> rc = SQLITE_INTERRUPT ; 
line 48256: rc = SQLITE_ERROR ; 
line 48257: sqlite3SetString ( & p -> zErrMsg , db , "%s" , sqlite3ErrStr ( p -> rc ) ) ; 
line 48258: } else { 
line 48259: char * z ; 
line 48260: Op * pOp ; 
line 48261: if ( i < p -> nOp ) { 
line 48264: pOp = & p -> aOp [ i ] ; 
line 48265: } else { 
line 48268: int j ; 
line 48269: i -= p -> nOp ; 
line 48270: for ( j = 0 ; i >= apSub [ j ] -> nOp ; j ++ ) { 
line 48271: i -= apSub [ j ] -> nOp ; 
line 48272: } 
line 48273: pOp = & apSub [ j ] -> aOp [ i ] ; 
line 48274: } 
line 48275: if ( p -> explain == 1 ) { 
line 48276: pMem -> flags = MEM_Int ; 
line 48277: pMem -> type = SQLITE_INTEGER ; 
line 48278: pMem -> u . i = i ; 
line 48279: pMem ++ ; 
line 48281: pMem -> flags = MEM_Static | MEM_Str | MEM_Term ; 
line 48282: pMem -> z = ( char * ) sqlite3OpcodeName ( pOp -> opcode ) ; 
line 48283: assert ( pMem -> z != 0 ) ; 
line 48284: pMem -> n = sqlite3Strlen30 ( pMem -> z ) ; 
line 48285: pMem -> type = SQLITE_TEXT ; 
line 48286: pMem -> enc = SQLITE_UTF8 ; 
line 48287: pMem ++ ; 
line 48294: if ( pOp -> p4type == P4_SUBPROGRAM ) { 
line 48295: int nByte = ( nSub + 1 ) * sizeof ( SubProgram * ) ; 
line 48296: int j ; 
line 48297: for ( j = 0 ; j < nSub ; j ++ ) { 
line 48298: if ( apSub [ j ] == pOp -> p4 . pProgram ) break ; 
line 48299: } 
line 48300: if ( j == nSub && SQLITE_OK == sqlite3VdbeMemGrow ( pSub , nByte , 1 ) ) { 
line 48301: apSub = ( SubProgram * * ) pSub -> z ; 
line 48302: apSub [ nSub ++ ] = pOp -> p4 . pProgram ; 
line 48303: pSub -> flags |= MEM_Blob ; 
line 48304: pSub -> n = nSub * sizeof ( SubProgram * ) ; 
line 48305: } 
line 48306: } 
line 48307: } 
line 48309: pMem -> flags = MEM_Int ; 
line 48310: pMem -> u . i = pOp -> p1 ; 
line 48311: pMem -> type = SQLITE_INTEGER ; 
line 48312: pMem ++ ; 
line 48314: pMem -> flags = MEM_Int ; 
line 48315: pMem -> u . i = pOp -> p2 ; 
line 48316: pMem -> type = SQLITE_INTEGER ; 
line 48317: pMem ++ ; 
line 48319: if ( p -> explain == 1 ) { 
line 48320: pMem -> flags = MEM_Int ; 
line 48321: pMem -> u . i = pOp -> p3 ; 
line 48322: pMem -> type = SQLITE_INTEGER ; 
line 48323: pMem ++ ; 
line 48324: } 
line 48326: if ( sqlite3VdbeMemGrow ( pMem , 32 , 0 ) ) { 
line 48327: assert ( p -> db -> mallocFailed ) ; 
line 48328: return SQLITE_ERROR ; 
line 48329: } 
line 48330: pMem -> flags = MEM_Dyn | MEM_Str | MEM_Term ; 
line 48331: z = displayP4 ( pOp , pMem -> z , 32 ) ; 
line 48332: if ( z != pMem -> z ) { 
line 48333: sqlite3VdbeMemSetStr ( pMem , z , - 1 , SQLITE_UTF8 , 0 ) ; 
line 48334: } else { 
line 48335: assert ( pMem -> z != 0 ) ; 
line 48336: pMem -> n = sqlite3Strlen30 ( pMem -> z ) ; 
line 48337: pMem -> enc = SQLITE_UTF8 ; 
line 48338: } 
line 48339: pMem -> type = SQLITE_TEXT ; 
line 48340: pMem ++ ; 
line 48342: if ( p -> explain == 1 ) { 
line 48343: if ( sqlite3VdbeMemGrow ( pMem , 4 , 0 ) ) { 
line 48344: assert ( p -> db -> mallocFailed ) ; 
line 48345: return SQLITE_ERROR ; 
line 48346: } 
line 48347: pMem -> flags = MEM_Dyn | MEM_Str | MEM_Term ; 
line 48348: pMem -> n = 2 ; 
line 48349: sqlite3_snprintf ( 3 , pMem -> z , "%.2x" , pOp -> p5 ) ; 
line 48350: pMem -> type = SQLITE_TEXT ; 
line 48351: pMem -> enc = SQLITE_UTF8 ; 
line 48352: pMem ++ ; 
line 48354: # ifdef SQLITE_DEBUG 
line 48355: if ( pOp -> zComment ) { 
line 48356: pMem -> flags = MEM_Str | MEM_Term ; 
line 48357: pMem -> z = pOp -> zComment ; 
line 48358: pMem -> n = sqlite3Strlen30 ( pMem -> z ) ; 
line 48359: pMem -> enc = SQLITE_UTF8 ; 
line 48360: pMem -> type = SQLITE_TEXT ; 
line 48361: } else 
line 48362: # endif 
line 48363: { 
line 48364: pMem -> flags = MEM_Null ; 
line 48365: pMem -> type = SQLITE_NULL ; 
line 48366: } 
line 48367: } 
line 48369: p -> nResColumn = 8 - 5 * ( p -> explain - 1 ) ; 
line 48370: p -> rc = SQLITE_OK ; 
line 48371: rc = SQLITE_ROW ; 
line 48372: } 
line 48373: return rc ; 
line 48374: } 
line 48375: # endif 
line 48377: # ifdef SQLITE_DEBUG 
line 48381: SQLITE_PRIVATE void sqlite3VdbePrintSql ( Vdbe * p ) { 
line 48382: int nOp = p -> nOp ; 
line 48383: VdbeOp * pOp ; 
line 48384: if ( nOp < 1 ) return ; 
line 48385: pOp = & p -> aOp [ 0 ] ; 
line 48386: if ( pOp -> opcode == OP_Trace && pOp -> p4 . z != 0 ) { 
line 48387: const char * z = pOp -> p4 . z ; 
line 48388: while ( sqlite3Isspace ( * z ) ) z ++ ; 
line 48389: printf ( "SQL: [%s]\n" , z ) ; 
line 48390: } 
line 48391: } 
line 48392: # endif 
line 48394: # if ! defined ( SQLITE_OMIT_TRACE ) && defined ( SQLITE_ENABLE_IOTRACE ) 
line 48398: SQLITE_PRIVATE void sqlite3VdbeIOTraceSql ( Vdbe * p ) { 
line 48399: int nOp = p -> nOp ; 
line 48400: VdbeOp * pOp ; 
line 48401: if ( sqlite3IoTrace == 0 ) return ; 
line 48402: if ( nOp < 1 ) return ; 
line 48403: pOp = & p -> aOp [ 0 ] ; 
line 48404: if ( pOp -> opcode == OP_Trace && pOp -> p4 . z != 0 ) { 
line 48405: int i , j ; 
line 48406: char z [ 1000 ] ; 
line 48407: sqlite3_snprintf ( sizeof ( z ) , z , "%s" , pOp -> p4 . z ) ; 
line 48408: for ( i = 0 ; sqlite3Isspace ( z [ i ] ) ; i ++ ) { } 
line 48409: for ( j = 0 ; z [ i ] ; i ++ ) { 
line 48410: if ( sqlite3Isspace ( z [ i ] ) ) { 
line 48411: if ( z [ i - 1 ] != ' ' ) { 
line 48412: z [ j ++ ] = ' ' ; 
line 48413: } 
line 48414: } else { 
line 48415: z [ j ++ ] = z [ i ] ; 
line 48416: } 
line 48417: } 
line 48418: z [ j ] = 0 ; 
line 48419: sqlite3IoTrace ( "SQL %s\n" , z ) ; 
line 48420: } 
line 48421: } 
line 48422: # endif 
line 48445: static void * allocSpace ( 
line 48446: void * pBuf , 
line 48447: int nByte , 
line 48448: u8 * * ppFrom , 
line 48449: u8 * pEnd , 
line 48450: int * pnByte 
line 48451: ) { 
line 48452: assert ( EIGHT_BYTE_ALIGNMENT ( * ppFrom ) ) ; 
line 48453: if ( pBuf ) return pBuf ; 
line 48454: nByte = ROUND8 ( nByte ) ; 
line 48455: if ( & ( * ppFrom ) [ nByte ] <= pEnd ) { 
line 48456: pBuf = ( void * ) * ppFrom ; 
line 48457: * ppFrom += nByte ; 
line 48458: } else { 
line 48459: * pnByte += nByte ; 
line 48460: } 
line 48461: return pBuf ; 
line 48462: } 
line 48481: SQLITE_PRIVATE void sqlite3VdbeMakeReady ( 
line 48482: Vdbe * p , 
line 48483: int nVar , 
line 48484: int nMem , 
line 48485: int nCursor , 
line 48486: int nArg , 
line 48487: int isExplain , 
line 48488: int usesStmtJournal 
line 48489: ) { 
line 48490: int n ; 
line 48491: sqlite3 * db = p -> db ; 
line 48493: assert ( p != 0 ) ; 
line 48494: assert ( p -> magic == VDBE_MAGIC_INIT ) ; 
line 48498: assert ( p -> nOp > 0 ) ; 
line 48501: p -> magic = VDBE_MAGIC_RUN ; 
line 48512: nMem += nCursor ; 
line 48519: if ( nVar >= 0 && ALWAYS ( db -> mallocFailed == 0 ) ) { 
line 48520: u8 * zCsr = ( u8 * ) & p -> aOp [ p -> nOp ] ; 
line 48521: u8 * zEnd = ( u8 * ) & p -> aOp [ p -> nOpAlloc ] ; 
line 48522: int nByte ; 
line 48524: resolveP2Values ( p , & nArg ) ; 
line 48525: p -> usesStmtJournal = ( u8 ) usesStmtJournal ; 
line 48526: if ( isExplain && nMem < 10 ) { 
line 48527: nMem = 10 ; 
line 48528: } 
line 48529: memset ( zCsr , 0 , zEnd - zCsr ) ; 
line 48530: zCsr += ( zCsr - ( u8 * ) 0 ) & 7 ; 
line 48531: assert ( EIGHT_BYTE_ALIGNMENT ( zCsr ) ) ; 
line 48543: do { 
line 48544: nByte = 0 ; 
line 48545: p -> aMem = allocSpace ( p -> aMem , nMem * sizeof ( Mem ) , & zCsr , zEnd , & nByte ) ; 
line 48546: p -> aVar = allocSpace ( p -> aVar , nVar * sizeof ( Mem ) , & zCsr , zEnd , & nByte ) ; 
line 48547: p -> apArg = allocSpace ( p -> apArg , nArg * sizeof ( Mem * ) , & zCsr , zEnd , & nByte ) ; 
line 48548: p -> azVar = allocSpace ( p -> azVar , nVar * sizeof ( char * ) , & zCsr , zEnd , & nByte ) ; 
line 48549: p -> apCsr = allocSpace ( p -> apCsr , nCursor * sizeof ( VdbeCursor * ) , 
line 48550: & zCsr , zEnd , & nByte ) ; 
line 48551: if ( nByte ) { 
line 48552: p -> pFree = sqlite3DbMallocZero ( db , nByte ) ; 
line 48553: } 
line 48554: zCsr = p -> pFree ; 
line 48555: zEnd = & zCsr [ nByte ] ; 
line 48556: } while ( nByte && ! db -> mallocFailed ) ; 
line 48558: p -> nCursor = ( u16 ) nCursor ; 
line 48559: if ( p -> aVar ) { 
line 48560: p -> nVar = ( ynVar ) nVar ; 
line 48561: for ( n = 0 ; n < nVar ; n ++ ) { 
line 48562: p -> aVar [ n ] . flags = MEM_Null ; 
line 48563: p -> aVar [ n ] . db = db ; 
line 48564: } 
line 48565: } 
line 48566: if ( p -> aMem ) { 
line 48567: p -> aMem -- ; 
line 48568: p -> nMem = nMem ; 
line 48569: for ( n = 1 ; n <= nMem ; n ++ ) { 
line 48570: p -> aMem [ n ] . flags = MEM_Null ; 
line 48571: p -> aMem [ n ] . db = db ; 
line 48572: } 
line 48573: } 
line 48574: } 
line 48575: # ifdef SQLITE_DEBUG 
line 48576: for ( n = 1 ; n < p -> nMem ; n ++ ) { 
line 48577: assert ( p -> aMem [ n ] . db == db ) ; 
line 48578: } 
line 48579: # endif 
line 48581: p -> pc = - 1 ; 
line 48582: p -> rc = SQLITE_OK ; 
line 48583: p -> errorAction = OE_Abort ; 
line 48584: p -> explain |= isExplain ; 
line 48585: p -> magic = VDBE_MAGIC_RUN ; 
line 48586: p -> nChange = 0 ; 
line 48587: p -> cacheCtr = 1 ; 
line 48588: p -> minWriteFileFormat = 255 ; 
line 48589: p -> iStatement = 0 ; 
line 48590: # ifdef VDBE_PROFILE 
line 48591: { 
line 48592: int i ; 
line 48593: for ( i = 0 ; i < p -> nOp ; i ++ ) { 
line 48594: p -> aOp [ i ] . cnt = 0 ; 
line 48595: p -> aOp [ i ] . cycles = 0 ; 
line 48596: } 
line 48597: } 
line 48598: # endif 
line 48599: } 
line 48605: SQLITE_PRIVATE void sqlite3VdbeFreeCursor ( Vdbe * p , VdbeCursor * pCx ) { 
line 48606: if ( pCx == 0 ) { 
line 48607: return ; 
line 48608: } 
line 48609: if ( pCx -> pBt ) { 
line 48610: sqlite3BtreeClose ( pCx -> pBt ) ; 
line 48613: } else if ( pCx -> pCursor ) { 
line 48614: sqlite3BtreeCloseCursor ( pCx -> pCursor ) ; 
line 48615: } 
line 48616: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 48617: if ( pCx -> pVtabCursor ) { 
line 48618: sqlite3_vtab_cursor * pVtabCursor = pCx -> pVtabCursor ; 
line 48619: const sqlite3_module * pModule = pCx -> pModule ; 
line 48620: p -> inVtabMethod = 1 ; 
line 48621: ( void ) sqlite3SafetyOff ( p -> db ) ; 
line 48622: pModule -> xClose ( pVtabCursor ) ; 
line 48623: ( void ) sqlite3SafetyOn ( p -> db ) ; 
line 48624: p -> inVtabMethod = 0 ; 
line 48625: } 
line 48626: # endif 
line 48627: } 
line 48634: SQLITE_PRIVATE int sqlite3VdbeFrameRestore ( VdbeFrame * pFrame ) { 
line 48635: Vdbe * v = pFrame -> v ; 
line 48636: v -> aOp = pFrame -> aOp ; 
line 48637: v -> nOp = pFrame -> nOp ; 
line 48638: v -> aMem = pFrame -> aMem ; 
line 48639: v -> nMem = pFrame -> nMem ; 
line 48640: v -> apCsr = pFrame -> apCsr ; 
line 48641: v -> nCursor = pFrame -> nCursor ; 
line 48642: v -> db -> lastRowid = pFrame -> lastRowid ; 
line 48643: v -> nChange = pFrame -> nChange ; 
line 48644: return pFrame -> pc ; 
line 48645: } 
line 48655: static void closeAllCursors ( Vdbe * p ) { 
line 48656: if ( p -> pFrame ) { 
line 48657: VdbeFrame * pFrame = p -> pFrame ; 
line 48658: for ( pFrame = p -> pFrame ; pFrame -> pParent ; pFrame = pFrame -> pParent ) ; 
line 48659: sqlite3VdbeFrameRestore ( pFrame ) ; 
line 48660: } 
line 48661: p -> pFrame = 0 ; 
line 48662: p -> nFrame = 0 ; 
line 48664: if ( p -> apCsr ) { 
line 48665: int i ; 
line 48666: for ( i = 0 ; i < p -> nCursor ; i ++ ) { 
line 48667: VdbeCursor * pC = p -> apCsr [ i ] ; 
line 48668: if ( pC ) { 
line 48669: sqlite3VdbeFreeCursor ( p , pC ) ; 
line 48670: p -> apCsr [ i ] = 0 ; 
line 48671: } 
line 48672: } 
line 48673: } 
line 48674: if ( p -> aMem ) { 
line 48675: releaseMemArray ( & p -> aMem [ 1 ] , p -> nMem ) ; 
line 48676: } 
line 48677: } 
line 48686: static void Cleanup ( Vdbe * p ) { 
line 48687: sqlite3 * db = p -> db ; 
line 48689: # ifdef SQLITE_DEBUG 
line 48692: int i ; 
line 48693: for ( i = 0 ; i < p -> nCursor ; i ++ ) assert ( p -> apCsr == 0 || p -> apCsr [ i ] == 0 ) ; 
line 48694: for ( i = 1 ; i <= p -> nMem ; i ++ ) assert ( p -> aMem == 0 || p -> aMem [ i ] . flags == MEM_Null ) ; 
line 48695: # endif 
line 48697: sqlite3DbFree ( db , p -> zErrMsg ) ; 
line 48698: p -> zErrMsg = 0 ; 
line 48699: p -> pResultSet = 0 ; 
line 48700: } 
line 48708: SQLITE_PRIVATE void sqlite3VdbeSetNumCols ( Vdbe * p , int nResColumn ) { 
line 48709: Mem * pColName ; 
line 48710: int n ; 
line 48711: sqlite3 * db = p -> db ; 
line 48713: releaseMemArray ( p -> aColName , p -> nResColumn * COLNAME_N ) ; 
line 48714: sqlite3DbFree ( db , p -> aColName ) ; 
line 48715: n = nResColumn * COLNAME_N ; 
line 48716: p -> nResColumn = ( u16 ) nResColumn ; 
line 48717: p -> aColName = pColName = ( Mem * ) sqlite3DbMallocZero ( db , sizeof ( Mem ) * n ) ; 
line 48718: if ( p -> aColName == 0 ) return ; 
line 48719: while ( n -- > 0 ) { 
line 48720: pColName -> flags = MEM_Null ; 
line 48721: pColName -> db = p -> db ; 
line 48722: pColName ++ ; 
line 48723: } 
line 48724: } 
line 48736: SQLITE_PRIVATE int sqlite3VdbeSetColName ( 
line 48737: Vdbe * p , 
line 48738: int idx , 
line 48739: int var , 
line 48740: const char * zName , 
line 48741: void ( * xDel ) ( void * ) 
line 48742: ) { 
line 48743: int rc ; 
line 48744: Mem * pColName ; 
line 48745: assert ( idx < p -> nResColumn ) ; 
line 48746: assert ( var < COLNAME_N ) ; 
line 48747: if ( p -> db -> mallocFailed ) { 
line 48748: assert ( ! zName || xDel != SQLITE_DYNAMIC ) ; 
line 48749: return SQLITE_NOMEM ; 
line 48750: } 
line 48751: assert ( p -> aColName != 0 ) ; 
line 48752: pColName = & ( p -> aColName [ idx + var * p -> nResColumn ] ) ; 
line 48753: rc = sqlite3VdbeMemSetStr ( pColName , zName , - 1 , SQLITE_UTF8 , xDel ) ; 
line 48754: assert ( rc != 0 || ! zName || ( pColName -> flags & MEM_Term ) != 0 ) ; 
line 48755: return rc ; 
line 48756: } 
line 48764: static int vdbeCommit ( sqlite3 * db , Vdbe * p ) { 
line 48765: int i ; 
line 48766: int nTrans = 0 ; 
line 48767: int rc = SQLITE_OK ; 
line 48768: int needXcommit = 0 ; 
line 48770: # ifdef SQLITE_OMIT_VIRTUALTABLE 
line 48774: UNUSED_PARAMETER ( p ) ; 
line 48775: # endif 
line 48783: rc = sqlite3VtabSync ( db , & p -> zErrMsg ) ; 
line 48784: if ( rc != SQLITE_OK ) { 
line 48785: return rc ; 
line 48786: } 
line 48794: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 48795: Btree * pBt = db -> aDb [ i ] . pBt ; 
line 48796: if ( sqlite3BtreeIsInTrans ( pBt ) ) { 
line 48797: needXcommit = 1 ; 
line 48798: if ( i != 1 ) nTrans ++ ; 
line 48799: } 
line 48800: } 
line 48803: if ( needXcommit && db -> xCommitCallback ) { 
line 48804: ( void ) sqlite3SafetyOff ( db ) ; 
line 48805: rc = db -> xCommitCallback ( db -> pCommitArg ) ; 
line 48806: ( void ) sqlite3SafetyOn ( db ) ; 
line 48807: if ( rc ) { 
line 48808: return SQLITE_CONSTRAINT ; 
line 48809: } 
line 48810: } 
line 48821: if ( 0 == sqlite3Strlen30 ( sqlite3BtreeGetFilename ( db -> aDb [ 0 ] . pBt ) ) 
line 48822: || nTrans <= 1 
line 48823: ) { 
line 48824: for ( i = 0 ; rc == SQLITE_OK && i < db -> nDb ; i ++ ) { 
line 48825: Btree * pBt = db -> aDb [ i ] . pBt ; 
line 48826: if ( pBt ) { 
line 48827: rc = sqlite3BtreeCommitPhaseOne ( pBt , 0 ) ; 
line 48828: } 
line 48829: } 
line 48836: for ( i = 0 ; rc == SQLITE_OK && i < db -> nDb ; i ++ ) { 
line 48837: Btree * pBt = db -> aDb [ i ] . pBt ; 
line 48838: if ( pBt ) { 
line 48839: rc = sqlite3BtreeCommitPhaseTwo ( pBt ) ; 
line 48840: } 
line 48841: } 
line 48842: if ( rc == SQLITE_OK ) { 
line 48843: sqlite3VtabCommit ( db ) ; 
line 48844: } 
line 48845: } 
line 48851: # ifndef SQLITE_OMIT_DISKIO 
line 48852: else { 
line 48853: sqlite3_vfs * pVfs = db -> pVfs ; 
line 48854: int needSync = 0 ; 
line 48855: char * zMaster = 0 ; 
line 48856: char const * zMainFile = sqlite3BtreeGetFilename ( db -> aDb [ 0 ] . pBt ) ; 
line 48857: sqlite3_file * pMaster = 0 ; 
line 48858: i64 offset = 0 ; 
line 48859: int res ; 
line 48862: do { 
line 48863: u32 iRandom ; 
line 48864: sqlite3DbFree ( db , zMaster ) ; 
line 48865: sqlite3_randomness ( sizeof ( iRandom ) , & iRandom ) ; 
line 48866: zMaster = sqlite3MPrintf ( db , "%s-mj%08X" , zMainFile , iRandom & 0x7fffffff ) ; 
line 48867: if ( ! zMaster ) { 
line 48868: return SQLITE_NOMEM ; 
line 48869: } 
line 48870: rc = sqlite3OsAccess ( pVfs , zMaster , SQLITE_ACCESS_EXISTS , & res ) ; 
line 48871: } while ( rc == SQLITE_OK && res ) ; 
line 48872: if ( rc == SQLITE_OK ) { 
line 48874: rc = sqlite3OsOpenMalloc ( pVfs , zMaster , & pMaster , 
line 48875: SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | 
line 48876: SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_MASTER_JOURNAL , 0 
line 48877: ) ; 
line 48878: } 
line 48879: if ( rc != SQLITE_OK ) { 
line 48880: sqlite3DbFree ( db , zMaster ) ; 
line 48881: return rc ; 
line 48882: } 
line 48890: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 48891: Btree * pBt = db -> aDb [ i ] . pBt ; 
line 48892: if ( sqlite3BtreeIsInTrans ( pBt ) ) { 
line 48893: char const * zFile = sqlite3BtreeGetJournalname ( pBt ) ; 
line 48894: if ( zFile == 0 || zFile [ 0 ] == 0 ) { 
line 48895: continue ; 
line 48896: } 
line 48897: if ( ! needSync && ! sqlite3BtreeSyncDisabled ( pBt ) ) { 
line 48898: needSync = 1 ; 
line 48899: } 
line 48900: rc = sqlite3OsWrite ( pMaster , zFile , sqlite3Strlen30 ( zFile ) + 1 , offset ) ; 
line 48901: offset += sqlite3Strlen30 ( zFile ) + 1 ; 
line 48902: if ( rc != SQLITE_OK ) { 
line 48903: sqlite3OsCloseFree ( pMaster ) ; 
line 48904: sqlite3OsDelete ( pVfs , zMaster , 0 ) ; 
line 48905: sqlite3DbFree ( db , zMaster ) ; 
line 48906: return rc ; 
line 48907: } 
line 48908: } 
line 48909: } 
line 48914: if ( needSync 
line 48915: && 0 == ( sqlite3OsDeviceCharacteristics ( pMaster ) & SQLITE_IOCAP_SEQUENTIAL ) 
line 48916: && SQLITE_OK != ( rc = sqlite3OsSync ( pMaster , SQLITE_SYNC_NORMAL ) ) 
line 48917: ) { 
line 48918: sqlite3OsCloseFree ( pMaster ) ; 
line 48919: sqlite3OsDelete ( pVfs , zMaster , 0 ) ; 
line 48920: sqlite3DbFree ( db , zMaster ) ; 
line 48921: return rc ; 
line 48922: } 
line 48934: for ( i = 0 ; rc == SQLITE_OK && i < db -> nDb ; i ++ ) { 
line 48935: Btree * pBt = db -> aDb [ i ] . pBt ; 
line 48936: if ( pBt ) { 
line 48937: rc = sqlite3BtreeCommitPhaseOne ( pBt , zMaster ) ; 
line 48938: } 
line 48939: } 
line 48940: sqlite3OsCloseFree ( pMaster ) ; 
line 48941: if ( rc != SQLITE_OK ) { 
line 48942: sqlite3DbFree ( db , zMaster ) ; 
line 48943: return rc ; 
line 48944: } 
line 48950: rc = sqlite3OsDelete ( pVfs , zMaster , 1 ) ; 
line 48951: sqlite3DbFree ( db , zMaster ) ; 
line 48952: zMaster = 0 ; 
line 48953: if ( rc ) { 
line 48954: return rc ; 
line 48955: } 
line 48964: disable_simulated_io_errors ( ) ; 
line 48965: sqlite3BeginBenignMalloc ( ) ; 
line 48966: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 48967: Btree * pBt = db -> aDb [ i ] . pBt ; 
line 48968: if ( pBt ) { 
line 48969: sqlite3BtreeCommitPhaseTwo ( pBt ) ; 
line 48970: } 
line 48971: } 
line 48972: sqlite3EndBenignMalloc ( ) ; 
line 48973: enable_simulated_io_errors ( ) ; 
line 48975: sqlite3VtabCommit ( db ) ; 
line 48976: } 
line 48977: # endif 
line 48979: return rc ; 
line 48980: } 
line 48991: # ifndef NDEBUG 
line 48992: static void checkActiveVdbeCnt ( sqlite3 * db ) { 
line 48993: Vdbe * p ; 
line 48994: int cnt = 0 ; 
line 48995: int nWrite = 0 ; 
line 48996: p = db -> pVdbe ; 
line 48997: while ( p ) { 
line 48998: if ( p -> magic == VDBE_MAGIC_RUN && p -> pc >= 0 ) { 
line 48999: cnt ++ ; 
line 49000: if ( p -> readOnly == 0 ) nWrite ++ ; 
line 49001: } 
line 49002: p = p -> pNext ; 
line 49003: } 
line 49004: assert ( cnt == db -> activeVdbeCnt ) ; 
line 49005: assert ( nWrite == db -> writeVdbeCnt ) ; 
line 49006: } 
line 49007: # else 
line 49008: # define checkActiveVdbeCnt ( x ) 
line 49009: # endif 
line 49027: static void invalidateCursorsOnModifiedBtrees ( sqlite3 * db ) { 
line 49028: int i ; 
line 49029: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 49030: Btree * p = db -> aDb [ i ] . pBt ; 
line 49031: if ( p && sqlite3BtreeIsInTrans ( p ) ) { 
line 49032: sqlite3BtreeTripAllCursors ( p , SQLITE_ABORT ) ; 
line 49033: } 
line 49034: } 
line 49035: } 
line 49047: SQLITE_PRIVATE int sqlite3VdbeCloseStatement ( Vdbe * p , int eOp ) { 
line 49048: sqlite3 * const db = p -> db ; 
line 49049: int rc = SQLITE_OK ; 
line 49056: if ( db -> nStatement && p -> iStatement ) { 
line 49057: int i ; 
line 49058: const int iSavepoint = p -> iStatement - 1 ; 
line 49060: assert ( eOp == SAVEPOINT_ROLLBACK || eOp == SAVEPOINT_RELEASE ) ; 
line 49061: assert ( db -> nStatement > 0 ) ; 
line 49062: assert ( p -> iStatement == ( db -> nStatement + db -> nSavepoint ) ) ; 
line 49064: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 49065: int rc2 = SQLITE_OK ; 
line 49066: Btree * pBt = db -> aDb [ i ] . pBt ; 
line 49067: if ( pBt ) { 
line 49068: if ( eOp == SAVEPOINT_ROLLBACK ) { 
line 49069: rc2 = sqlite3BtreeSavepoint ( pBt , SAVEPOINT_ROLLBACK , iSavepoint ) ; 
line 49070: } 
line 49071: if ( rc2 == SQLITE_OK ) { 
line 49072: rc2 = sqlite3BtreeSavepoint ( pBt , SAVEPOINT_RELEASE , iSavepoint ) ; 
line 49073: } 
line 49074: if ( rc == SQLITE_OK ) { 
line 49075: rc = rc2 ; 
line 49076: } 
line 49077: } 
line 49078: } 
line 49079: db -> nStatement -- ; 
line 49080: p -> iStatement = 0 ; 
line 49085: if ( eOp == SAVEPOINT_ROLLBACK ) { 
line 49086: db -> nDeferredCons = p -> nStmtDefCons ; 
line 49087: } 
line 49088: } 
line 49089: return rc ; 
line 49090: } 
line 49109: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 49110: SQLITE_PRIVATE void sqlite3VdbeMutexArrayEnter ( Vdbe * p ) { 
line 49111: # if SQLITE_THREADSAFE 
line 49112: sqlite3BtreeMutexArrayEnter ( & p -> aMutex ) ; 
line 49113: # else 
line 49114: sqlite3BtreeEnterAll ( p -> db ) ; 
line 49115: # endif 
line 49116: } 
line 49117: # endif 
line 49129: # ifndef SQLITE_OMIT_FOREIGN_KEY 
line 49130: SQLITE_PRIVATE int sqlite3VdbeCheckFk ( Vdbe * p , int deferred ) { 
line 49131: sqlite3 * db = p -> db ; 
line 49132: if ( ( deferred && db -> nDeferredCons > 0 ) || ( ! deferred && p -> nFkConstraint > 0 ) ) { 
line 49133: p -> rc = SQLITE_CONSTRAINT ; 
line 49134: p -> errorAction = OE_Abort ; 
line 49135: sqlite3SetString ( & p -> zErrMsg , db , "foreign key constraint failed" ) ; 
line 49136: return SQLITE_ERROR ; 
line 49137: } 
line 49138: return SQLITE_OK ; 
line 49139: } 
line 49140: # endif 
line 49155: SQLITE_PRIVATE int sqlite3VdbeHalt ( Vdbe * p ) { 
line 49156: int rc ; 
line 49157: sqlite3 * db = p -> db ; 
line 49175: if ( p -> db -> mallocFailed ) { 
line 49176: p -> rc = SQLITE_NOMEM ; 
line 49177: } 
line 49178: closeAllCursors ( p ) ; 
line 49179: if ( p -> magic != VDBE_MAGIC_RUN ) { 
line 49180: return SQLITE_OK ; 
line 49181: } 
line 49182: checkActiveVdbeCnt ( db ) ; 
line 49185: if ( p -> pc >= 0 ) { 
line 49186: int mrc ; 
line 49187: int eStatementOp = 0 ; 
line 49188: int isSpecialError ; 
line 49191: sqlite3VdbeMutexArrayEnter ( p ) ; 
line 49194: mrc = p -> rc & 0xff ; 
line 49195: assert ( p -> rc != SQLITE_IOERR_BLOCKED ) ; 
line 49196: isSpecialError = mrc == SQLITE_NOMEM || mrc == SQLITE_IOERR 
line 49197: || mrc == SQLITE_INTERRUPT || mrc == SQLITE_FULL ; 
line 49198: if ( isSpecialError ) { 
line 49202: if ( ! p -> readOnly || mrc != SQLITE_INTERRUPT ) { 
line 49203: if ( ( mrc == SQLITE_NOMEM || mrc == SQLITE_FULL ) && p -> usesStmtJournal ) { 
line 49204: eStatementOp = SAVEPOINT_ROLLBACK ; 
line 49205: } else { 
line 49209: invalidateCursorsOnModifiedBtrees ( db ) ; 
line 49210: sqlite3RollbackAll ( db ) ; 
line 49211: sqlite3CloseSavepoints ( db ) ; 
line 49212: db -> autoCommit = 1 ; 
line 49213: } 
line 49214: } 
line 49215: } 
line 49218: if ( p -> rc == SQLITE_OK ) { 
line 49219: sqlite3VdbeCheckFk ( p , 0 ) ; 
line 49220: } 
line 49228: if ( ! sqlite3VtabInSync ( db ) 
line 49229: && db -> autoCommit 
line 49230: && db -> writeVdbeCnt == ( p -> readOnly == 0 ) 
line 49231: ) { 
line 49232: if ( p -> rc == SQLITE_OK || ( p -> errorAction == OE_Fail && ! isSpecialError ) ) { 
line 49233: if ( sqlite3VdbeCheckFk ( p , 1 ) ) { 
line 49234: sqlite3BtreeMutexArrayLeave ( & p -> aMutex ) ; 
line 49235: return SQLITE_ERROR ; 
line 49236: } 
line 49241: rc = vdbeCommit ( db , p ) ; 
line 49242: if ( rc == SQLITE_BUSY ) { 
line 49243: sqlite3BtreeMutexArrayLeave ( & p -> aMutex ) ; 
line 49244: return SQLITE_BUSY ; 
line 49245: } else if ( rc != SQLITE_OK ) { 
line 49246: p -> rc = rc ; 
line 49247: sqlite3RollbackAll ( db ) ; 
line 49248: } else { 
line 49249: db -> nDeferredCons = 0 ; 
line 49250: sqlite3CommitInternalChanges ( db ) ; 
line 49251: } 
line 49252: } else { 
line 49253: sqlite3RollbackAll ( db ) ; 
line 49254: } 
line 49255: db -> nStatement = 0 ; 
line 49256: } else if ( eStatementOp == 0 ) { 
line 49257: if ( p -> rc == SQLITE_OK || p -> errorAction == OE_Fail ) { 
line 49258: eStatementOp = SAVEPOINT_RELEASE ; 
line 49259: } else if ( p -> errorAction == OE_Abort ) { 
line 49260: eStatementOp = SAVEPOINT_ROLLBACK ; 
line 49261: } else { 
line 49262: invalidateCursorsOnModifiedBtrees ( db ) ; 
line 49263: sqlite3RollbackAll ( db ) ; 
line 49264: sqlite3CloseSavepoints ( db ) ; 
line 49265: db -> autoCommit = 1 ; 
line 49266: } 
line 49267: } 
line 49275: if ( eStatementOp ) { 
line 49276: rc = sqlite3VdbeCloseStatement ( p , eStatementOp ) ; 
line 49277: if ( rc && ( p -> rc == SQLITE_OK || p -> rc == SQLITE_CONSTRAINT ) ) { 
line 49278: p -> rc = rc ; 
line 49279: sqlite3DbFree ( db , p -> zErrMsg ) ; 
line 49280: p -> zErrMsg = 0 ; 
line 49281: } 
line 49282: } 
line 49287: if ( p -> changeCntOn ) { 
line 49288: if ( eStatementOp != SAVEPOINT_ROLLBACK ) { 
line 49289: sqlite3VdbeSetChanges ( db , p -> nChange ) ; 
line 49290: } else { 
line 49291: sqlite3VdbeSetChanges ( db , 0 ) ; 
line 49292: } 
line 49293: p -> nChange = 0 ; 
line 49294: } 
line 49297: if ( p -> rc != SQLITE_OK && db -> flags & SQLITE_InternChanges ) { 
line 49298: sqlite3ResetInternalSchema ( db , 0 ) ; 
line 49299: db -> flags = ( db -> flags | SQLITE_InternChanges ) ; 
line 49300: } 
line 49303: sqlite3BtreeMutexArrayLeave ( & p -> aMutex ) ; 
line 49304: } 
line 49307: if ( p -> pc >= 0 ) { 
line 49308: db -> activeVdbeCnt -- ; 
line 49309: if ( ! p -> readOnly ) { 
line 49310: db -> writeVdbeCnt -- ; 
line 49311: } 
line 49312: assert ( db -> activeVdbeCnt >= db -> writeVdbeCnt ) ; 
line 49313: } 
line 49314: p -> magic = VDBE_MAGIC_HALT ; 
line 49315: checkActiveVdbeCnt ( db ) ; 
line 49316: if ( p -> db -> mallocFailed ) { 
line 49317: p -> rc = SQLITE_NOMEM ; 
line 49318: } 
line 49324: if ( db -> autoCommit ) { 
line 49325: sqlite3ConnectionUnlocked ( db ) ; 
line 49326: } 
line 49328: assert ( db -> activeVdbeCnt > 0 || db -> autoCommit == 0 || db -> nStatement == 0 ) ; 
line 49329: return SQLITE_OK ; 
line 49330: } 
line 49337: SQLITE_PRIVATE void sqlite3VdbeResetStepResult ( Vdbe * p ) { 
line 49338: p -> rc = SQLITE_OK ; 
line 49339: } 
line 49352: SQLITE_PRIVATE int sqlite3VdbeReset ( Vdbe * p ) { 
line 49353: sqlite3 * db ; 
line 49354: db = p -> db ; 
line 49360: ( void ) sqlite3SafetyOn ( db ) ; 
line 49361: sqlite3VdbeHalt ( p ) ; 
line 49362: ( void ) sqlite3SafetyOff ( db ) ; 
line 49369: if ( p -> pc >= 0 ) { 
line 49370: if ( p -> zErrMsg ) { 
line 49371: sqlite3BeginBenignMalloc ( ) ; 
line 49372: sqlite3ValueSetStr ( db -> pErr , - 1 , p -> zErrMsg , SQLITE_UTF8 , SQLITE_TRANSIENT ) ; 
line 49373: sqlite3EndBenignMalloc ( ) ; 
line 49374: db -> errCode = p -> rc ; 
line 49375: sqlite3DbFree ( db , p -> zErrMsg ) ; 
line 49376: p -> zErrMsg = 0 ; 
line 49377: } else if ( p -> rc ) { 
line 49378: sqlite3Error ( db , p -> rc , 0 ) ; 
line 49379: } else { 
line 49380: sqlite3Error ( db , SQLITE_OK , 0 ) ; 
line 49381: } 
line 49382: } else if ( p -> rc && p -> expired ) { 
line 49387: sqlite3Error ( db , p -> rc , 0 ) ; 
line 49388: sqlite3ValueSetStr ( db -> pErr , - 1 , p -> zErrMsg , SQLITE_UTF8 , SQLITE_TRANSIENT ) ; 
line 49389: sqlite3DbFree ( db , p -> zErrMsg ) ; 
line 49390: p -> zErrMsg = 0 ; 
line 49391: } 
line 49395: Cleanup ( p ) ; 
line 49399: # ifdef VDBE_PROFILE 
line 49400: { 
line 49401: FILE * out = fopen ( "vdbe_profile.out" , "a" ) ; 
line 49402: if ( out ) { 
line 49403: int i ; 
line 49404: fprintf ( out , "---- " ) ; 
line 49405: for ( i = 0 ; i < p -> nOp ; i ++ ) { 
line 49406: fprintf ( out , "%02x" , p -> aOp [ i ] . opcode ) ; 
line 49407: } 
line 49408: fprintf ( out , "\n" ) ; 
line 49409: for ( i = 0 ; i < p -> nOp ; i ++ ) { 
line 49410: fprintf ( out , "%6d %10lld %8lld " , 
line 49411: p -> aOp [ i ] . cnt , 
line 49412: p -> aOp [ i ] . cycles , 
line 49413: p -> aOp [ i ] . cnt > 0 ? p -> aOp [ i ] . cycles / p -> aOp [ i ] . cnt : 0 
line 49414: ) ; 
line 49415: sqlite3VdbePrintOp ( out , i , & p -> aOp [ i ] ) ; 
line 49416: } 
line 49417: fclose ( out ) ; 
line 49418: } 
line 49419: } 
line 49420: # endif 
line 49421: p -> magic = VDBE_MAGIC_INIT ; 
line 49422: return p -> rc & db -> errMask ; 
line 49423: } 
line 49429: SQLITE_PRIVATE int sqlite3VdbeFinalize ( Vdbe * p ) { 
line 49430: int rc = SQLITE_OK ; 
line 49431: if ( p -> magic == VDBE_MAGIC_RUN || p -> magic == VDBE_MAGIC_HALT ) { 
line 49432: rc = sqlite3VdbeReset ( p ) ; 
line 49433: assert ( ( rc & p -> db -> errMask ) == rc ) ; 
line 49434: } 
line 49435: sqlite3VdbeDelete ( p ) ; 
line 49436: return rc ; 
line 49437: } 
line 49445: SQLITE_PRIVATE void sqlite3VdbeDeleteAuxData ( VdbeFunc * pVdbeFunc , int mask ) { 
line 49446: int i ; 
line 49447: for ( i = 0 ; i < pVdbeFunc -> nAux ; i ++ ) { 
line 49448: struct AuxData * pAux = & pVdbeFunc -> apAux [ i ] ; 
line 49449: if ( ( i > 31 || ! ( mask & ( ( ( u32 ) 1 ) << i ) ) ) && pAux -> pAux ) { 
line 49450: if ( pAux -> xDelete ) { 
line 49451: pAux -> xDelete ( pAux -> pAux ) ; 
line 49452: } 
line 49453: pAux -> pAux = 0 ; 
line 49454: } 
line 49455: } 
line 49456: } 
line 49461: SQLITE_PRIVATE void sqlite3VdbeDelete ( Vdbe * p ) { 
line 49462: sqlite3 * db ; 
line 49464: if ( NEVER ( p == 0 ) ) return ; 
line 49465: db = p -> db ; 
line 49466: if ( p -> pPrev ) { 
line 49467: p -> pPrev -> pNext = p -> pNext ; 
line 49468: } else { 
line 49469: assert ( db -> pVdbe == p ) ; 
line 49470: db -> pVdbe = p -> pNext ; 
line 49471: } 
line 49472: if ( p -> pNext ) { 
line 49473: p -> pNext -> pPrev = p -> pPrev ; 
line 49474: } 
line 49475: releaseMemArray ( p -> aVar , p -> nVar ) ; 
line 49476: releaseMemArray ( p -> aColName , p -> nResColumn * COLNAME_N ) ; 
line 49477: vdbeFreeOpArray ( db , p -> aOp , p -> nOp ) ; 
line 49478: sqlite3DbFree ( db , p -> aLabel ) ; 
line 49479: sqlite3DbFree ( db , p -> aColName ) ; 
line 49480: sqlite3DbFree ( db , p -> zSql ) ; 
line 49481: p -> magic = VDBE_MAGIC_DEAD ; 
line 49482: sqlite3DbFree ( db , p -> pFree ) ; 
line 49483: sqlite3DbFree ( db , p ) ; 
line 49484: } 
line 49499: SQLITE_PRIVATE int sqlite3VdbeCursorMoveto ( VdbeCursor * p ) { 
line 49500: if ( p -> deferredMoveto ) { 
line 49501: int res , rc ; 
line 49502: # ifdef SQLITE_TEST 
line 49503: extern int sqlite3_search_count ; 
line 49504: # endif 
line 49505: assert ( p -> isTable ) ; 
line 49506: rc = sqlite3BtreeMovetoUnpacked ( p -> pCursor , 0 , p -> movetoTarget , 0 , & res ) ; 
line 49507: if ( rc ) return rc ; 
line 49508: p -> lastRowid = p -> movetoTarget ; 
line 49509: p -> rowidIsValid = ALWAYS ( res == 0 ) ? 1 : 0 ; 
line 49510: if ( NEVER ( res < 0 ) ) { 
line 49511: rc = sqlite3BtreeNext ( p -> pCursor , & res ) ; 
line 49512: if ( rc ) return rc ; 
line 49513: } 
line 49514: # ifdef SQLITE_TEST 
line 49515: sqlite3_search_count ++ ; 
line 49516: # endif 
line 49517: p -> deferredMoveto = 0 ; 
line 49518: p -> cacheStatus = CACHE_STALE ; 
line 49519: } else if ( ALWAYS ( p -> pCursor ) ) { 
line 49520: int hasMoved ; 
line 49521: int rc = sqlite3BtreeCursorHasMoved ( p -> pCursor , & hasMoved ) ; 
line 49522: if ( rc ) return rc ; 
line 49523: if ( hasMoved ) { 
line 49524: p -> cacheStatus = CACHE_STALE ; 
line 49525: p -> nullRow = 1 ; 
line 49526: } 
line 49527: } 
line 49528: return SQLITE_OK ; 
line 49529: } 
line 49576: SQLITE_PRIVATE u32 sqlite3VdbeSerialType ( Mem * pMem , int file_format ) { 
line 49577: int flags = pMem -> flags ; 
line 49578: int n ; 
line 49580: if ( flags & MEM_Null ) { 
line 49581: return 0 ; 
line 49582: } 
line 49583: if ( flags & MEM_Int ) { 
line 49585: # define MAX_6BYTE ( ( ( ( i64 ) 0x00008000 ) << 32 ) - 1 ) 
line 49586: i64 i = pMem -> u . i ; 
line 49587: u64 u ; 
line 49588: if ( file_format >= 4 && ( i & 1 ) == i ) { 
line 49589: return 8 + ( u32 ) i ; 
line 49590: } 
line 49591: u = i < 0 ? - i : i ; 
line 49592: if ( u <= 127 ) return 1 ; 
line 49593: if ( u <= 32767 ) return 2 ; 
line 49594: if ( u <= 8388607 ) return 3 ; 
line 49595: if ( u <= 2147483647 ) return 4 ; 
line 49596: if ( u <= MAX_6BYTE ) return 5 ; 
line 49597: return 6 ; 
line 49598: } 
line 49599: if ( flags & MEM_Real ) { 
line 49600: return 7 ; 
line 49601: } 
line 49602: assert ( pMem -> db -> mallocFailed || flags & ( MEM_Str | MEM_Blob ) ) ; 
line 49603: n = pMem -> n ; 
line 49604: if ( flags & MEM_Zero ) { 
line 49605: n += pMem -> u . nZero ; 
line 49606: } 
line 49607: assert ( n >= 0 ) ; 
line 49608: return ( ( n * 2 ) + 12 + ( ( flags & MEM_Str ) != 0 ) ) ; 
line 49609: } 
line 49614: SQLITE_PRIVATE u32 sqlite3VdbeSerialTypeLen ( u32 serial_type ) { 
line 49615: if ( serial_type >= 12 ) { 
line 49616: return ( serial_type - 12 ) / 2 ; 
line 49617: } else { 
line 49618: static const u8 aSize [ ] = { 0 , 1 , 2 , 3 , 4 , 6 , 8 , 8 , 0 , 0 , 0 , 0 } ; 
line 49619: return aSize [ serial_type ] ; 
line 49620: } 
line 49621: } 
line 49657: # ifdef SQLITE_MIXED_ENDIAN_64BIT_FLOAT 
line 49658: static u64 floatSwap ( u64 in ) { 
line 49659: union { 
line 49660: u64 r ; 
line 49661: u32 i [ 2 ] ; 
line 49662: } u ; 
line 49663: u32 t ; 
line 49665: u . r = in ; 
line 49666: t = u . i [ 0 ] ; 
line 49667: u . i [ 0 ] = u . i [ 1 ] ; 
line 49668: u . i [ 1 ] = t ; 
line 49669: return u . r ; 
line 49670: } 
line 49671: # define swapMixedEndianFloat ( X ) X = floatSwap ( X ) 
line 49672: # else 
line 49673: # define swapMixedEndianFloat ( X ) 
line 49674: # endif 
line 49694: SQLITE_PRIVATE u32 sqlite3VdbeSerialPut ( u8 * buf , int nBuf , Mem * pMem , int file_format ) { 
line 49695: u32 serial_type = sqlite3VdbeSerialType ( pMem , file_format ) ; 
line 49696: u32 len ; 
line 49699: if ( serial_type <= 7 && serial_type > 0 ) { 
line 49700: u64 v ; 
line 49701: u32 i ; 
line 49702: if ( serial_type == 7 ) { 
line 49703: assert ( sizeof ( v ) == sizeof ( pMem -> r ) ) ; 
line 49704: memcpy ( & v , & pMem -> r , sizeof ( v ) ) ; 
line 49705: swapMixedEndianFloat ( v ) ; 
line 49706: } else { 
line 49707: v = pMem -> u . i ; 
line 49708: } 
line 49709: len = i = sqlite3VdbeSerialTypeLen ( serial_type ) ; 
line 49710: assert ( len <= ( u32 ) nBuf ) ; 
line 49711: while ( i -- ) { 
line 49712: buf [ i ] = ( u8 ) ( v & 0xFF ) ; 
line 49713: v >>= 8 ; 
line 49714: } 
line 49715: return len ; 
line 49716: } 
line 49719: if ( serial_type >= 12 ) { 
line 49720: assert ( pMem -> n + ( ( pMem -> flags & MEM_Zero ) ? pMem -> u . nZero : 0 ) 
line 49721: == ( int ) sqlite3VdbeSerialTypeLen ( serial_type ) ) ; 
line 49722: assert ( pMem -> n <= nBuf ) ; 
line 49723: len = pMem -> n ; 
line 49724: memcpy ( buf , pMem -> z , len ) ; 
line 49725: if ( pMem -> flags & MEM_Zero ) { 
line 49726: len += pMem -> u . nZero ; 
line 49727: assert ( nBuf >= 0 ) ; 
line 49728: if ( len > ( u32 ) nBuf ) { 
line 49729: len = ( u32 ) nBuf ; 
line 49730: } 
line 49731: memset ( & buf [ pMem -> n ] , 0 , len - pMem -> n ) ; 
line 49732: } 
line 49733: return len ; 
line 49734: } 
line 49737: return 0 ; 
line 49738: } 
line 49744: SQLITE_PRIVATE u32 sqlite3VdbeSerialGet ( 
line 49745: const unsigned char * buf , 
line 49746: u32 serial_type , 
line 49747: Mem * pMem 
line 49748: ) { 
line 49749: switch ( serial_type ) { 
line 49750: case 10 : 
line 49751: case 11 : 
line 49752: case 0 : { 
line 49753: pMem -> flags = MEM_Null ; 
line 49754: break ; 
line 49755: } 
line 49756: case 1 : { 
line 49757: pMem -> u . i = ( signed char ) buf [ 0 ] ; 
line 49758: pMem -> flags = MEM_Int ; 
line 49759: return 1 ; 
line 49760: } 
line 49761: case 2 : { 
line 49762: pMem -> u . i = ( ( ( signed char ) buf [ 0 ] ) << 8 ) | buf [ 1 ] ; 
line 49763: pMem -> flags = MEM_Int ; 
line 49764: return 2 ; 
line 49765: } 
line 49766: case 3 : { 
line 49767: pMem -> u . i = ( ( ( signed char ) buf [ 0 ] ) << 16 ) | ( buf [ 1 ] << 8 ) | buf [ 2 ] ; 
line 49768: pMem -> flags = MEM_Int ; 
line 49769: return 3 ; 
line 49770: } 
line 49771: case 4 : { 
line 49772: pMem -> u . i = ( buf [ 0 ] << 24 ) | ( buf [ 1 ] << 16 ) | ( buf [ 2 ] << 8 ) | buf [ 3 ] ; 
line 49773: pMem -> flags = MEM_Int ; 
line 49774: return 4 ; 
line 49775: } 
line 49776: case 5 : { 
line 49777: u64 x = ( ( ( signed char ) buf [ 0 ] ) << 8 ) | buf [ 1 ] ; 
line 49778: u32 y = ( buf [ 2 ] << 24 ) | ( buf [ 3 ] << 16 ) | ( buf [ 4 ] << 8 ) | buf [ 5 ] ; 
line 49779: x = ( x << 32 ) | y ; 
line 49780: pMem -> u . i = * ( i64 * ) & x ; 
line 49781: pMem -> flags = MEM_Int ; 
line 49782: return 6 ; 
line 49783: } 
line 49784: case 6 : 
line 49785: case 7 : { 
line 49786: u64 x ; 
line 49787: u32 y ; 
line 49788: # if ! defined ( NDEBUG ) && ! defined ( SQLITE_OMIT_FLOATING_POINT ) 
line 49794: static const u64 t1 = ( ( u64 ) 0x3ff00000 ) << 32 ; 
line 49795: static const double r1 = 1.0 ; 
line 49796: u64 t2 = t1 ; 
line 49797: swapMixedEndianFloat ( t2 ) ; 
line 49798: assert ( sizeof ( r1 ) == sizeof ( t2 ) && memcmp ( & r1 , & t2 , sizeof ( r1 ) ) == 0 ) ; 
line 49799: # endif 
line 49801: x = ( buf [ 0 ] << 24 ) | ( buf [ 1 ] << 16 ) | ( buf [ 2 ] << 8 ) | buf [ 3 ] ; 
line 49802: y = ( buf [ 4 ] << 24 ) | ( buf [ 5 ] << 16 ) | ( buf [ 6 ] << 8 ) | buf [ 7 ] ; 
line 49803: x = ( x << 32 ) | y ; 
line 49804: if ( serial_type == 6 ) { 
line 49805: pMem -> u . i = * ( i64 * ) & x ; 
line 49806: pMem -> flags = MEM_Int ; 
line 49807: } else { 
line 49808: assert ( sizeof ( x ) == 8 && sizeof ( pMem -> r ) == 8 ) ; 
line 49809: swapMixedEndianFloat ( x ) ; 
line 49810: memcpy ( & pMem -> r , & x , sizeof ( x ) ) ; 
line 49811: pMem -> flags = sqlite3IsNaN ( pMem -> r ) ? MEM_Null : MEM_Real ; 
line 49812: } 
line 49813: return 8 ; 
line 49814: } 
line 49815: case 8 : 
line 49816: case 9 : { 
line 49817: pMem -> u . i = serial_type - 8 ; 
line 49818: pMem -> flags = MEM_Int ; 
line 49819: return 0 ; 
line 49820: } 
line 49821: default : { 
line 49822: u32 len = ( serial_type - 12 ) / 2 ; 
line 49823: pMem -> z = ( char * ) buf ; 
line 49824: pMem -> n = len ; 
line 49825: pMem -> xDel = 0 ; 
line 49826: if ( serial_type & 0x01 ) { 
line 49827: pMem -> flags = MEM_Str | MEM_Ephem ; 
line 49828: } else { 
line 49829: pMem -> flags = MEM_Blob | MEM_Ephem ; 
line 49830: } 
line 49831: return len ; 
line 49832: } 
line 49833: } 
line 49834: return 0 ; 
line 49835: } 
line 49851: SQLITE_PRIVATE UnpackedRecord * sqlite3VdbeRecordUnpack ( 
line 49852: KeyInfo * pKeyInfo , 
line 49853: int nKey , 
line 49854: const void * pKey , 
line 49855: char * pSpace , 
line 49856: int szSpace 
line 49857: ) { 
line 49858: const unsigned char * aKey = ( const unsigned char * ) pKey ; 
line 49859: UnpackedRecord * p ; 
line 49860: int nByte ; 
line 49861: int d ; 
line 49862: u32 idx ; 
line 49863: u16 u ; 
line 49864: u32 szHdr ; 
line 49865: Mem * pMem ; 
line 49866: int nOff ; 
line 49873: nOff = ( 8 - ( SQLITE_PTR_TO_INT ( pSpace ) & 7 ) ) & 7 ; 
line 49874: pSpace += nOff ; 
line 49875: szSpace -= nOff ; 
line 49876: nByte = ROUND8 ( sizeof ( UnpackedRecord ) ) + sizeof ( Mem ) * ( pKeyInfo -> nField + 1 ) ; 
line 49877: if ( nByte > szSpace ) { 
line 49878: p = sqlite3DbMallocRaw ( pKeyInfo -> db , nByte ) ; 
line 49879: if ( p == 0 ) return 0 ; 
line 49880: p -> flags = UNPACKED_NEED_FREE | UNPACKED_NEED_DESTROY ; 
line 49881: } else { 
line 49882: p = ( UnpackedRecord * ) pSpace ; 
line 49883: p -> flags = UNPACKED_NEED_DESTROY ; 
line 49884: } 
line 49885: p -> pKeyInfo = pKeyInfo ; 
line 49886: p -> nField = pKeyInfo -> nField + 1 ; 
line 49887: p -> aMem = pMem = ( Mem * ) & ( ( char * ) p ) [ ROUND8 ( sizeof ( UnpackedRecord ) ) ] ; 
line 49888: assert ( EIGHT_BYTE_ALIGNMENT ( pMem ) ) ; 
line 49889: idx = getVarint32 ( aKey , szHdr ) ; 
line 49890: d = szHdr ; 
line 49891: u = 0 ; 
line 49892: while ( idx < szHdr && u < p -> nField && d <= nKey ) { 
line 49893: u32 serial_type ; 
line 49895: idx += getVarint32 ( & aKey [ idx ] , serial_type ) ; 
line 49896: pMem -> enc = pKeyInfo -> enc ; 
line 49897: pMem -> db = pKeyInfo -> db ; 
line 49898: pMem -> flags = 0 ; 
line 49899: pMem -> zMalloc = 0 ; 
line 49900: d += sqlite3VdbeSerialGet ( & aKey [ d ] , serial_type , pMem ) ; 
line 49901: pMem ++ ; 
line 49902: u ++ ; 
line 49903: } 
line 49904: assert ( u <= pKeyInfo -> nField + 1 ) ; 
line 49905: p -> nField = u ; 
line 49906: return ( void * ) p ; 
line 49907: } 
line 49912: SQLITE_PRIVATE void sqlite3VdbeDeleteUnpackedRecord ( UnpackedRecord * p ) { 
line 49913: int i ; 
line 49914: Mem * pMem ; 
line 49916: assert ( p != 0 ) ; 
line 49917: assert ( p -> flags & UNPACKED_NEED_DESTROY ) ; 
line 49918: for ( i = 0 , pMem = p -> aMem ; i < p -> nField ; i ++ , pMem ++ ) { 
line 49924: if ( NEVER ( pMem -> zMalloc ) ) sqlite3VdbeMemRelease ( pMem ) ; 
line 49925: } 
line 49926: if ( p -> flags & UNPACKED_NEED_FREE ) { 
line 49927: sqlite3DbFree ( p -> pKeyInfo -> db , p ) ; 
line 49928: } 
line 49929: } 
line 49957: SQLITE_PRIVATE int sqlite3VdbeRecordCompare ( 
line 49958: int nKey1 , const void * pKey1 , 
line 49959: UnpackedRecord * pPKey2 
line 49960: ) { 
line 49961: int d1 ; 
line 49962: u32 idx1 ; 
line 49963: u32 szHdr1 ; 
line 49964: int i = 0 ; 
line 49965: int nField ; 
line 49966: int rc = 0 ; 
line 49967: const unsigned char * aKey1 = ( const unsigned char * ) pKey1 ; 
line 49968: KeyInfo * pKeyInfo ; 
line 49969: Mem mem1 ; 
line 49971: pKeyInfo = pPKey2 -> pKeyInfo ; 
line 49972: mem1 . enc = pKeyInfo -> enc ; 
line 49973: mem1 . db = pKeyInfo -> db ; 
line 49975: VVA_ONLY ( mem1 . zMalloc = 0 ; ) 
line 49986: idx1 = getVarint32 ( aKey1 , szHdr1 ) ; 
line 49987: d1 = szHdr1 ; 
line 49988: if ( pPKey2 -> flags & UNPACKED_IGNORE_ROWID ) { 
line 49989: szHdr1 -- ; 
line 49990: } 
line 49991: nField = pKeyInfo -> nField ; 
line 49992: while ( idx1 < szHdr1 && i < pPKey2 -> nField ) { 
line 49993: u32 serial_type1 ; 
line 49996: idx1 += getVarint32 ( aKey1 + idx1 , serial_type1 ) ; 
line 49997: if ( d1 >= nKey1 && sqlite3VdbeSerialTypeLen ( serial_type1 ) > 0 ) break ; 
line 50001: d1 += sqlite3VdbeSerialGet ( & aKey1 [ d1 ] , serial_type1 , & mem1 ) ; 
line 50005: rc = sqlite3MemCompare ( & mem1 , & pPKey2 -> aMem [ i ] , 
line 50006: i < nField ? pKeyInfo -> aColl [ i ] : 0 ) ; 
line 50007: if ( rc != 0 ) { 
line 50008: assert ( mem1 . zMalloc == 0 ) ; 
line 50011: if ( pKeyInfo -> aSortOrder && i < nField && pKeyInfo -> aSortOrder [ i ] ) { 
line 50012: rc = - rc ; 
line 50013: } 
line 50020: if ( ( pPKey2 -> flags & UNPACKED_PREFIX_SEARCH ) && i == ( pPKey2 -> nField - 1 ) ) { 
line 50021: assert ( idx1 == szHdr1 && rc ) ; 
line 50022: assert ( mem1 . flags & MEM_Int ) ; 
line 50023: pPKey2 -> flags &= ~ UNPACKED_PREFIX_SEARCH ; 
line 50024: pPKey2 -> rowid = mem1 . u . i ; 
line 50025: } 
line 50027: return rc ; 
line 50028: } 
line 50029: i ++ ; 
line 50030: } 
line 50036: assert ( mem1 . zMalloc == 0 ) ; 
line 50046: assert ( rc == 0 ) ; 
line 50047: if ( pPKey2 -> flags & UNPACKED_INCRKEY ) { 
line 50048: rc = - 1 ; 
line 50049: } else if ( pPKey2 -> flags & UNPACKED_PREFIX_MATCH ) { 
line 50051: } else if ( idx1 < szHdr1 ) { 
line 50052: rc = 1 ; 
line 50053: } 
line 50054: return rc ; 
line 50055: } 
line 50066: SQLITE_PRIVATE int sqlite3VdbeIdxRowid ( sqlite3 * db , BtCursor * pCur , i64 * rowid ) { 
line 50067: i64 nCellKey = 0 ; 
line 50068: int rc ; 
line 50069: u32 szHdr ; 
line 50070: u32 typeRowid ; 
line 50071: u32 lenRowid ; 
line 50072: Mem m , v ; 
line 50074: UNUSED_PARAMETER ( db ) ; 
line 50081: assert ( sqlite3BtreeCursorIsValid ( pCur ) ) ; 
line 50082: rc = sqlite3BtreeKeySize ( pCur , & nCellKey ) ; 
line 50083: assert ( rc == SQLITE_OK ) ; 
line 50084: assert ( ( nCellKey & SQLITE_MAX_U32 ) == ( u64 ) nCellKey ) ; 
line 50087: memset ( & m , 0 , sizeof ( m ) ) ; 
line 50088: rc = sqlite3VdbeMemFromBtree ( pCur , 0 , ( int ) nCellKey , 1 , & m ) ; 
line 50089: if ( rc ) { 
line 50090: return rc ; 
line 50091: } 
line 50094: ( void ) getVarint32 ( ( u8 * ) m . z , szHdr ) ; 
line 50095: testcase ( szHdr == 3 ) ; 
line 50096: testcase ( szHdr == m . n ) ; 
line 50097: if ( unlikely ( szHdr < 3 || ( int ) szHdr > m . n ) ) { 
line 50098: goto idx_rowid_corruption ; 
line 50099: } 
line 50103: ( void ) getVarint32 ( ( u8 * ) & m . z [ szHdr - 1 ] , typeRowid ) ; 
line 50104: testcase ( typeRowid == 1 ) ; 
line 50105: testcase ( typeRowid == 2 ) ; 
line 50106: testcase ( typeRowid == 3 ) ; 
line 50107: testcase ( typeRowid == 4 ) ; 
line 50108: testcase ( typeRowid == 5 ) ; 
line 50109: testcase ( typeRowid == 6 ) ; 
line 50110: testcase ( typeRowid == 8 ) ; 
line 50111: testcase ( typeRowid == 9 ) ; 
line 50112: if ( unlikely ( typeRowid < 1 || typeRowid > 9 || typeRowid == 7 ) ) { 
line 50113: goto idx_rowid_corruption ; 
line 50114: } 
line 50115: lenRowid = sqlite3VdbeSerialTypeLen ( typeRowid ) ; 
line 50116: testcase ( ( u32 ) m . n == szHdr + lenRowid ) ; 
line 50117: if ( unlikely ( ( u32 ) m . n < szHdr + lenRowid ) ) { 
line 50118: goto idx_rowid_corruption ; 
line 50119: } 
line 50122: sqlite3VdbeSerialGet ( ( u8 * ) & m . z [ m . n - lenRowid ] , typeRowid , & v ) ; 
line 50123: * rowid = v . u . i ; 
line 50124: sqlite3VdbeMemRelease ( & m ) ; 
line 50125: return SQLITE_OK ; 
line 50129: idx_rowid_corruption : 
line 50130: testcase ( m . zMalloc != 0 ) ; 
line 50131: sqlite3VdbeMemRelease ( & m ) ; 
line 50132: return SQLITE_CORRUPT_BKPT ; 
line 50133: } 
line 50146: SQLITE_PRIVATE int sqlite3VdbeIdxKeyCompare ( 
line 50147: VdbeCursor * pC , 
line 50148: UnpackedRecord * pUnpacked , 
line 50149: int * res 
line 50150: ) { 
line 50151: i64 nCellKey = 0 ; 
line 50152: int rc ; 
line 50153: BtCursor * pCur = pC -> pCursor ; 
line 50154: Mem m ; 
line 50156: assert ( sqlite3BtreeCursorIsValid ( pCur ) ) ; 
line 50157: rc = sqlite3BtreeKeySize ( pCur , & nCellKey ) ; 
line 50158: assert ( rc == SQLITE_OK ) ; 
line 50161: if ( nCellKey <= 0 || nCellKey > 0x7fffffff ) { 
line 50162: * res = 0 ; 
line 50163: return SQLITE_CORRUPT ; 
line 50164: } 
line 50165: memset ( & m , 0 , sizeof ( m ) ) ; 
line 50166: rc = sqlite3VdbeMemFromBtree ( pC -> pCursor , 0 , ( int ) nCellKey , 1 , & m ) ; 
line 50167: if ( rc ) { 
line 50168: return rc ; 
line 50169: } 
line 50170: assert ( pUnpacked -> flags & UNPACKED_IGNORE_ROWID ) ; 
line 50171: * res = sqlite3VdbeRecordCompare ( m . n , m . z , pUnpacked ) ; 
line 50172: sqlite3VdbeMemRelease ( & m ) ; 
line 50173: return SQLITE_OK ; 
line 50174: } 
line 50180: SQLITE_PRIVATE void sqlite3VdbeSetChanges ( sqlite3 * db , int nChange ) { 
line 50181: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 50182: db -> nChange = nChange ; 
line 50183: db -> nTotalChange += nChange ; 
line 50184: } 
line 50190: SQLITE_PRIVATE void sqlite3VdbeCountChanges ( Vdbe * v ) { 
line 50191: v -> changeCntOn = 1 ; 
line 50192: } 
line 50204: SQLITE_PRIVATE void sqlite3ExpirePreparedStatements ( sqlite3 * db ) { 
line 50205: Vdbe * p ; 
line 50206: for ( p = db -> pVdbe ; p ; p = p -> pNext ) { 
line 50207: p -> expired = 1 ; 
line 50208: } 
line 50209: } 
line 50214: SQLITE_PRIVATE sqlite3 * sqlite3VdbeDb ( Vdbe * v ) { 
line 50215: return v -> db ; 
line 50216: } 
line 50226: SQLITE_PRIVATE sqlite3_value * sqlite3VdbeGetValue ( Vdbe * v , int iVar , u8 aff ) { 
line 50227: assert ( iVar > 0 ) ; 
line 50228: if ( v ) { 
line 50229: Mem * pMem = & v -> aVar [ iVar - 1 ] ; 
line 50230: if ( 0 == ( pMem -> flags & MEM_Null ) ) { 
line 50231: sqlite3_value * pRet = sqlite3ValueNew ( v -> db ) ; 
line 50232: if ( pRet ) { 
line 50233: sqlite3VdbeMemCopy ( ( Mem * ) pRet , pMem ) ; 
line 50234: sqlite3ValueApplyAffinity ( pRet , aff , SQLITE_UTF8 ) ; 
line 50235: sqlite3VdbeMemStoreType ( ( Mem * ) pRet ) ; 
line 50236: } 
line 50237: return pRet ; 
line 50238: } 
line 50239: } 
line 50240: return 0 ; 
line 50241: } 
line 50248: SQLITE_PRIVATE void sqlite3VdbeSetVarmask ( Vdbe * v , int iVar ) { 
line 50249: assert ( iVar > 0 ) ; 
line 50250: if ( iVar > 32 ) { 
line 50251: v -> expmask = 0xffffffff ; 
line 50252: } else { 
line 50253: v -> expmask |= ( ( u32 ) 1 << ( iVar - 1 ) ) ; 
line 50254: } 
line 50255: } 
line 50275: # ifndef SQLITE_OMIT_DEPRECATED 
line 50284: SQLITE_API int sqlite3_expired ( sqlite3_stmt * pStmt ) { 
line 50285: Vdbe * p = ( Vdbe * ) pStmt ; 
line 50286: return p == 0 || p -> expired ; 
line 50287: } 
line 50288: # endif 
line 50299: SQLITE_API int sqlite3_finalize ( sqlite3_stmt * pStmt ) { 
line 50300: int rc ; 
line 50301: if ( pStmt == 0 ) { 
line 50302: rc = SQLITE_OK ; 
line 50303: } else { 
line 50304: Vdbe * v = ( Vdbe * ) pStmt ; 
line 50305: sqlite3 * db = v -> db ; 
line 50306: # if SQLITE_THREADSAFE 
line 50307: sqlite3_mutex * mutex = v -> db -> mutex ; 
line 50308: # endif 
line 50309: sqlite3_mutex_enter ( mutex ) ; 
line 50310: rc = sqlite3VdbeFinalize ( v ) ; 
line 50311: rc = sqlite3ApiExit ( db , rc ) ; 
line 50312: sqlite3_mutex_leave ( mutex ) ; 
line 50313: } 
line 50314: return rc ; 
line 50315: } 
line 50325: SQLITE_API int sqlite3_reset ( sqlite3_stmt * pStmt ) { 
line 50326: int rc ; 
line 50327: if ( pStmt == 0 ) { 
line 50328: rc = SQLITE_OK ; 
line 50329: } else { 
line 50330: Vdbe * v = ( Vdbe * ) pStmt ; 
line 50331: sqlite3_mutex_enter ( v -> db -> mutex ) ; 
line 50332: rc = sqlite3VdbeReset ( v ) ; 
line 50333: sqlite3VdbeMakeReady ( v , - 1 , 0 , 0 , 0 , 0 , 0 ) ; 
line 50334: assert ( ( rc & ( v -> db -> errMask ) ) == rc ) ; 
line 50335: rc = sqlite3ApiExit ( v -> db , rc ) ; 
line 50336: sqlite3_mutex_leave ( v -> db -> mutex ) ; 
line 50337: } 
line 50338: return rc ; 
line 50339: } 
line 50344: SQLITE_API int sqlite3_clear_bindings ( sqlite3_stmt * pStmt ) { 
line 50345: int i ; 
line 50346: int rc = SQLITE_OK ; 
line 50347: Vdbe * p = ( Vdbe * ) pStmt ; 
line 50348: # if SQLITE_THREADSAFE 
line 50349: sqlite3_mutex * mutex = ( ( Vdbe * ) pStmt ) -> db -> mutex ; 
line 50350: # endif 
line 50351: sqlite3_mutex_enter ( mutex ) ; 
line 50352: for ( i = 0 ; i < p -> nVar ; i ++ ) { 
line 50353: sqlite3VdbeMemRelease ( & p -> aVar [ i ] ) ; 
line 50354: p -> aVar [ i ] . flags = MEM_Null ; 
line 50355: } 
line 50356: if ( p -> isPrepareV2 && p -> expmask ) { 
line 50357: p -> expired = 1 ; 
line 50358: } 
line 50359: sqlite3_mutex_leave ( mutex ) ; 
line 50360: return rc ; 
line 50361: } 
line 50368: SQLITE_API const void * sqlite3_value_blob ( sqlite3_value * pVal ) { 
line 50369: Mem * p = ( Mem * ) pVal ; 
line 50370: if ( p -> flags & ( MEM_Blob | MEM_Str ) ) { 
line 50371: sqlite3VdbeMemExpandBlob ( p ) ; 
line 50372: p -> flags &= ~ MEM_Str ; 
line 50373: p -> flags |= MEM_Blob ; 
line 50374: return p -> z ; 
line 50375: } else { 
line 50376: return sqlite3_value_text ( pVal ) ; 
line 50377: } 
line 50378: } 
line 50379: SQLITE_API int sqlite3_value_bytes ( sqlite3_value * pVal ) { 
line 50380: return sqlite3ValueBytes ( pVal , SQLITE_UTF8 ) ; 
line 50381: } 
line 50382: SQLITE_API int sqlite3_value_bytes16 ( sqlite3_value * pVal ) { 
line 50383: return sqlite3ValueBytes ( pVal , SQLITE_UTF16NATIVE ) ; 
line 50384: } 
line 50385: SQLITE_API double sqlite3_value_double ( sqlite3_value * pVal ) { 
line 50386: return sqlite3VdbeRealValue ( ( Mem * ) pVal ) ; 
line 50387: } 
line 50388: SQLITE_API int sqlite3_value_int ( sqlite3_value * pVal ) { 
line 50389: return ( int ) sqlite3VdbeIntValue ( ( Mem * ) pVal ) ; 
line 50390: } 
line 50391: SQLITE_API sqlite_int64 sqlite3_value_int64 ( sqlite3_value * pVal ) { 
line 50392: return sqlite3VdbeIntValue ( ( Mem * ) pVal ) ; 
line 50393: } 
line 50394: SQLITE_API const unsigned char * sqlite3_value_text ( sqlite3_value * pVal ) { 
line 50395: return ( const unsigned char * ) sqlite3ValueText ( pVal , SQLITE_UTF8 ) ; 
line 50396: } 
line 50397: # ifndef SQLITE_OMIT_UTF16 
line 50398: SQLITE_API const void * sqlite3_value_text16 ( sqlite3_value * pVal ) { 
line 50399: return sqlite3ValueText ( pVal , SQLITE_UTF16NATIVE ) ; 
line 50400: } 
line 50401: SQLITE_API const void * sqlite3_value_text16be ( sqlite3_value * pVal ) { 
line 50402: return sqlite3ValueText ( pVal , SQLITE_UTF16BE ) ; 
line 50403: } 
line 50404: SQLITE_API const void * sqlite3_value_text16le ( sqlite3_value * pVal ) { 
line 50405: return sqlite3ValueText ( pVal , SQLITE_UTF16LE ) ; 
line 50406: } 
line 50407: # endif 
line 50408: SQLITE_API int sqlite3_value_type ( sqlite3_value * pVal ) { 
line 50409: return pVal -> type ; 
line 50410: } 
line 50420: static void setResultStrOrError ( 
line 50421: sqlite3_context * pCtx , 
line 50422: const char * z , 
line 50423: int n , 
line 50424: u8 enc , 
line 50425: void ( * xDel ) ( void * ) 
line 50426: ) { 
line 50427: if ( sqlite3VdbeMemSetStr ( & pCtx -> s , z , n , enc , xDel ) == SQLITE_TOOBIG ) { 
line 50428: sqlite3_result_error_toobig ( pCtx ) ; 
line 50429: } 
line 50430: } 
line 50431: SQLITE_API void sqlite3_result_blob ( 
line 50432: sqlite3_context * pCtx , 
line 50433: const void * z , 
line 50434: int n , 
line 50435: void ( * xDel ) ( void * ) 
line 50436: ) { 
line 50437: assert ( n >= 0 ) ; 
line 50438: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50439: setResultStrOrError ( pCtx , z , n , 0 , xDel ) ; 
line 50440: } 
line 50441: SQLITE_API void sqlite3_result_double ( sqlite3_context * pCtx , double rVal ) { 
line 50442: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50443: sqlite3VdbeMemSetDouble ( & pCtx -> s , rVal ) ; 
line 50444: } 
line 50445: SQLITE_API void sqlite3_result_error ( sqlite3_context * pCtx , const char * z , int n ) { 
line 50446: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50447: pCtx -> isError = SQLITE_ERROR ; 
line 50448: sqlite3VdbeMemSetStr ( & pCtx -> s , z , n , SQLITE_UTF8 , SQLITE_TRANSIENT ) ; 
line 50449: } 
line 50450: # ifndef SQLITE_OMIT_UTF16 
line 50451: SQLITE_API void sqlite3_result_error16 ( sqlite3_context * pCtx , const void * z , int n ) { 
line 50452: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50453: pCtx -> isError = SQLITE_ERROR ; 
line 50454: sqlite3VdbeMemSetStr ( & pCtx -> s , z , n , SQLITE_UTF16NATIVE , SQLITE_TRANSIENT ) ; 
line 50455: } 
line 50456: # endif 
line 50457: SQLITE_API void sqlite3_result_int ( sqlite3_context * pCtx , int iVal ) { 
line 50458: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50459: sqlite3VdbeMemSetInt64 ( & pCtx -> s , ( i64 ) iVal ) ; 
line 50460: } 
line 50461: SQLITE_API void sqlite3_result_int64 ( sqlite3_context * pCtx , i64 iVal ) { 
line 50462: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50463: sqlite3VdbeMemSetInt64 ( & pCtx -> s , iVal ) ; 
line 50464: } 
line 50465: SQLITE_API void sqlite3_result_null ( sqlite3_context * pCtx ) { 
line 50466: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50467: sqlite3VdbeMemSetNull ( & pCtx -> s ) ; 
line 50468: } 
line 50469: SQLITE_API void sqlite3_result_text ( 
line 50470: sqlite3_context * pCtx , 
line 50471: const char * z , 
line 50472: int n , 
line 50473: void ( * xDel ) ( void * ) 
line 50474: ) { 
line 50475: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50476: setResultStrOrError ( pCtx , z , n , SQLITE_UTF8 , xDel ) ; 
line 50477: } 
line 50478: # ifndef SQLITE_OMIT_UTF16 
line 50479: SQLITE_API void sqlite3_result_text16 ( 
line 50480: sqlite3_context * pCtx , 
line 50481: const void * z , 
line 50482: int n , 
line 50483: void ( * xDel ) ( void * ) 
line 50484: ) { 
line 50485: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50486: setResultStrOrError ( pCtx , z , n , SQLITE_UTF16NATIVE , xDel ) ; 
line 50487: } 
line 50488: SQLITE_API void sqlite3_result_text16be ( 
line 50489: sqlite3_context * pCtx , 
line 50490: const void * z , 
line 50491: int n , 
line 50492: void ( * xDel ) ( void * ) 
line 50493: ) { 
line 50494: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50495: setResultStrOrError ( pCtx , z , n , SQLITE_UTF16BE , xDel ) ; 
line 50496: } 
line 50497: SQLITE_API void sqlite3_result_text16le ( 
line 50498: sqlite3_context * pCtx , 
line 50499: const void * z , 
line 50500: int n , 
line 50501: void ( * xDel ) ( void * ) 
line 50502: ) { 
line 50503: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50504: setResultStrOrError ( pCtx , z , n , SQLITE_UTF16LE , xDel ) ; 
line 50505: } 
line 50506: # endif 
line 50507: SQLITE_API void sqlite3_result_value ( sqlite3_context * pCtx , sqlite3_value * pValue ) { 
line 50508: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50509: sqlite3VdbeMemCopy ( & pCtx -> s , pValue ) ; 
line 50510: } 
line 50511: SQLITE_API void sqlite3_result_zeroblob ( sqlite3_context * pCtx , int n ) { 
line 50512: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50513: sqlite3VdbeMemSetZeroBlob ( & pCtx -> s , n ) ; 
line 50514: } 
line 50515: SQLITE_API void sqlite3_result_error_code ( sqlite3_context * pCtx , int errCode ) { 
line 50516: pCtx -> isError = errCode ; 
line 50517: if ( pCtx -> s . flags & MEM_Null ) { 
line 50518: sqlite3VdbeMemSetStr ( & pCtx -> s , sqlite3ErrStr ( errCode ) , - 1 , 
line 50519: SQLITE_UTF8 , SQLITE_STATIC ) ; 
line 50520: } 
line 50521: } 
line 50524: SQLITE_API void sqlite3_result_error_toobig ( sqlite3_context * pCtx ) { 
line 50525: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50526: pCtx -> isError = SQLITE_TOOBIG ; 
line 50527: sqlite3VdbeMemSetStr ( & pCtx -> s , "string or blob too big" , - 1 , 
line 50528: SQLITE_UTF8 , SQLITE_STATIC ) ; 
line 50529: } 
line 50532: SQLITE_API void sqlite3_result_error_nomem ( sqlite3_context * pCtx ) { 
line 50533: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50534: sqlite3VdbeMemSetNull ( & pCtx -> s ) ; 
line 50535: pCtx -> isError = SQLITE_NOMEM ; 
line 50536: pCtx -> s . db -> mallocFailed = 1 ; 
line 50537: } 
line 50548: static int sqlite3Step ( Vdbe * p ) { 
line 50549: sqlite3 * db ; 
line 50550: int rc ; 
line 50552: assert ( p ) ; 
line 50553: if ( p -> magic != VDBE_MAGIC_RUN ) { 
line 50554: return SQLITE_MISUSE ; 
line 50555: } 
line 50558: db = p -> db ; 
line 50559: if ( db -> mallocFailed ) { 
line 50560: return SQLITE_NOMEM ; 
line 50561: } 
line 50563: if ( p -> pc <= 0 && p -> expired ) { 
line 50564: if ( ALWAYS ( p -> rc == SQLITE_OK || p -> rc == SQLITE_SCHEMA ) ) { 
line 50565: p -> rc = SQLITE_SCHEMA ; 
line 50566: } 
line 50567: rc = SQLITE_ERROR ; 
line 50568: goto end_of_step ; 
line 50569: } 
line 50570: if ( sqlite3SafetyOn ( db ) ) { 
line 50571: p -> rc = SQLITE_MISUSE ; 
line 50572: return SQLITE_MISUSE ; 
line 50573: } 
line 50574: if ( p -> pc < 0 ) { 
line 50579: if ( db -> activeVdbeCnt == 0 ) { 
line 50580: db -> u1 . isInterrupted = 0 ; 
line 50581: } 
line 50583: assert ( db -> writeVdbeCnt > 0 || db -> autoCommit == 0 || db -> nDeferredCons == 0 ) ; 
line 50585: # ifndef SQLITE_OMIT_TRACE 
line 50586: if ( db -> xProfile && ! db -> init . busy ) { 
line 50587: double rNow ; 
line 50588: sqlite3OsCurrentTime ( db -> pVfs , & rNow ) ; 
line 50589: p -> startTime = ( u64 ) ( ( rNow - ( int ) rNow ) * 3600.0 * 24.0 * 1000000000.0 ) ; 
line 50590: } 
line 50591: # endif 
line 50593: db -> activeVdbeCnt ++ ; 
line 50594: if ( p -> readOnly == 0 ) db -> writeVdbeCnt ++ ; 
line 50595: p -> pc = 0 ; 
line 50596: } 
line 50597: # ifndef SQLITE_OMIT_EXPLAIN 
line 50598: if ( p -> explain ) { 
line 50599: rc = sqlite3VdbeList ( p ) ; 
line 50600: } else 
line 50601: # endif 
line 50602: { 
line 50603: rc = sqlite3VdbeExec ( p ) ; 
line 50604: } 
line 50606: if ( sqlite3SafetyOff ( db ) ) { 
line 50607: rc = SQLITE_MISUSE ; 
line 50608: } 
line 50610: # ifndef SQLITE_OMIT_TRACE 
line 50613: if ( rc != SQLITE_ROW && db -> xProfile && ! db -> init . busy && p -> zSql ) { 
line 50614: double rNow ; 
line 50615: u64 elapseTime ; 
line 50617: sqlite3OsCurrentTime ( db -> pVfs , & rNow ) ; 
line 50618: elapseTime = ( u64 ) ( ( rNow - ( int ) rNow ) * 3600.0 * 24.0 * 1000000000.0 ) ; 
line 50619: elapseTime -= p -> startTime ; 
line 50620: db -> xProfile ( db -> pProfileArg , p -> zSql , elapseTime ) ; 
line 50621: } 
line 50622: # endif 
line 50624: db -> errCode = rc ; 
line 50625: if ( SQLITE_NOMEM == sqlite3ApiExit ( p -> db , p -> rc ) ) { 
line 50626: p -> rc = SQLITE_NOMEM ; 
line 50627: } 
line 50628: end_of_step : 
line 50636: assert ( rc == SQLITE_ROW || rc == SQLITE_DONE || rc == SQLITE_ERROR 
line 50637: || rc == SQLITE_BUSY || rc == SQLITE_MISUSE 
line 50638: ) ; 
line 50639: assert ( p -> rc != SQLITE_ROW && p -> rc != SQLITE_DONE ) ; 
line 50640: if ( p -> isPrepareV2 && rc != SQLITE_ROW && rc != SQLITE_DONE ) { 
line 50645: rc = db -> errCode = p -> rc ; 
line 50646: } 
line 50647: return ( rc & db -> errMask ) ; 
line 50648: } 
line 50655: SQLITE_API int sqlite3_step ( sqlite3_stmt * pStmt ) { 
line 50656: int rc = SQLITE_MISUSE ; 
line 50657: if ( pStmt ) { 
line 50658: int cnt = 0 ; 
line 50659: Vdbe * v = ( Vdbe * ) pStmt ; 
line 50660: sqlite3 * db = v -> db ; 
line 50661: sqlite3_mutex_enter ( db -> mutex ) ; 
line 50662: while ( ( rc = sqlite3Step ( v ) ) == SQLITE_SCHEMA 
line 50663: && cnt ++ < 5 
line 50664: && ( rc = sqlite3Reprepare ( v ) ) == SQLITE_OK ) { 
line 50665: sqlite3_reset ( pStmt ) ; 
line 50666: v -> expired = 0 ; 
line 50667: } 
line 50668: if ( rc == SQLITE_SCHEMA && ALWAYS ( v -> isPrepareV2 ) && ALWAYS ( db -> pErr ) ) { 
line 50677: const char * zErr = ( const char * ) sqlite3_value_text ( db -> pErr ) ; 
line 50678: sqlite3DbFree ( db , v -> zErrMsg ) ; 
line 50679: if ( ! db -> mallocFailed ) { 
line 50680: v -> zErrMsg = sqlite3DbStrDup ( db , zErr ) ; 
line 50681: } else { 
line 50682: v -> zErrMsg = 0 ; 
line 50683: v -> rc = SQLITE_NOMEM ; 
line 50684: } 
line 50685: } 
line 50686: rc = sqlite3ApiExit ( db , rc ) ; 
line 50687: sqlite3_mutex_leave ( db -> mutex ) ; 
line 50688: } 
line 50689: return rc ; 
line 50690: } 
line 50696: SQLITE_API void * sqlite3_user_data ( sqlite3_context * p ) { 
line 50697: assert ( p && p -> pFunc ) ; 
line 50698: return p -> pFunc -> pUserData ; 
line 50699: } 
line 50705: SQLITE_API sqlite3 * sqlite3_context_db_handle ( sqlite3_context * p ) { 
line 50706: assert ( p && p -> pFunc ) ; 
line 50707: return p -> s . db ; 
line 50708: } 
line 50718: SQLITE_PRIVATE void sqlite3InvalidFunction ( 
line 50719: sqlite3_context * context , 
line 50720: int NotUsed , 
line 50721: sqlite3_value * * NotUsed2 
line 50722: ) { 
line 50723: const char * zName = context -> pFunc -> zName ; 
line 50724: char * zErr ; 
line 50725: UNUSED_PARAMETER2 ( NotUsed , NotUsed2 ) ; 
line 50726: zErr = sqlite3_mprintf ( 
line 50727: "unable to use function %s in the requested context" , zName ) ; 
line 50728: sqlite3_result_error ( context , zErr , - 1 ) ; 
line 50729: sqlite3_free ( zErr ) ; 
line 50730: } 
line 50737: SQLITE_API void * sqlite3_aggregate_context ( sqlite3_context * p , int nByte ) { 
line 50738: Mem * pMem ; 
line 50739: assert ( p && p -> pFunc && p -> pFunc -> xStep ) ; 
line 50740: assert ( sqlite3_mutex_held ( p -> s . db -> mutex ) ) ; 
line 50741: pMem = p -> pMem ; 
line 50742: testcase ( nByte < 0 ) ; 
line 50743: if ( ( pMem -> flags & MEM_Agg ) == 0 ) { 
line 50744: if ( nByte <= 0 ) { 
line 50745: sqlite3VdbeMemReleaseExternal ( pMem ) ; 
line 50746: pMem -> flags = MEM_Null ; 
line 50747: pMem -> z = 0 ; 
line 50748: } else { 
line 50749: sqlite3VdbeMemGrow ( pMem , nByte , 0 ) ; 
line 50750: pMem -> flags = MEM_Agg ; 
line 50751: pMem -> u . pDef = p -> pFunc ; 
line 50752: if ( pMem -> z ) { 
line 50753: memset ( pMem -> z , 0 , nByte ) ; 
line 50754: } 
line 50755: } 
line 50756: } 
line 50757: return ( void * ) pMem -> z ; 
line 50758: } 
line 50764: SQLITE_API void * sqlite3_get_auxdata ( sqlite3_context * pCtx , int iArg ) { 
line 50765: VdbeFunc * pVdbeFunc ; 
line 50767: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50768: pVdbeFunc = pCtx -> pVdbeFunc ; 
line 50769: if ( ! pVdbeFunc || iArg >= pVdbeFunc -> nAux || iArg < 0 ) { 
line 50770: return 0 ; 
line 50771: } 
line 50772: return pVdbeFunc -> apAux [ iArg ] . pAux ; 
line 50773: } 
line 50780: SQLITE_API void sqlite3_set_auxdata ( 
line 50781: sqlite3_context * pCtx , 
line 50782: int iArg , 
line 50783: void * pAux , 
line 50784: void ( * xDelete ) ( void * ) 
line 50785: ) { 
line 50786: struct AuxData * pAuxData ; 
line 50787: VdbeFunc * pVdbeFunc ; 
line 50788: if ( iArg < 0 ) goto failed ; 
line 50790: assert ( sqlite3_mutex_held ( pCtx -> s . db -> mutex ) ) ; 
line 50791: pVdbeFunc = pCtx -> pVdbeFunc ; 
line 50792: if ( ! pVdbeFunc || pVdbeFunc -> nAux <= iArg ) { 
line 50793: int nAux = ( pVdbeFunc ? pVdbeFunc -> nAux : 0 ) ; 
line 50794: int nMalloc = sizeof ( VdbeFunc ) + sizeof ( struct AuxData ) * iArg ; 
line 50795: pVdbeFunc = sqlite3DbRealloc ( pCtx -> s . db , pVdbeFunc , nMalloc ) ; 
line 50796: if ( ! pVdbeFunc ) { 
line 50797: goto failed ; 
line 50798: } 
line 50799: pCtx -> pVdbeFunc = pVdbeFunc ; 
line 50800: memset ( & pVdbeFunc -> apAux [ nAux ] , 0 , sizeof ( struct AuxData ) * ( iArg + 1 - nAux ) ) ; 
line 50801: pVdbeFunc -> nAux = iArg + 1 ; 
line 50802: pVdbeFunc -> pFunc = pCtx -> pFunc ; 
line 50803: } 
line 50805: pAuxData = & pVdbeFunc -> apAux [ iArg ] ; 
line 50806: if ( pAuxData -> pAux && pAuxData -> xDelete ) { 
line 50807: pAuxData -> xDelete ( pAuxData -> pAux ) ; 
line 50808: } 
line 50809: pAuxData -> pAux = pAux ; 
line 50810: pAuxData -> xDelete = xDelete ; 
line 50811: return ; 
line 50813: failed : 
line 50814: if ( xDelete ) { 
line 50815: xDelete ( pAux ) ; 
line 50816: } 
line 50817: } 
line 50819: # ifndef SQLITE_OMIT_DEPRECATED 
line 50829: SQLITE_API int sqlite3_aggregate_count ( sqlite3_context * p ) { 
line 50830: assert ( p && p -> pMem && p -> pFunc && p -> pFunc -> xStep ) ; 
line 50831: return p -> pMem -> n ; 
line 50832: } 
line 50833: # endif 
line 50838: SQLITE_API int sqlite3_column_count ( sqlite3_stmt * pStmt ) { 
line 50839: Vdbe * pVm = ( Vdbe * ) pStmt ; 
line 50840: return pVm ? pVm -> nResColumn : 0 ; 
line 50841: } 
line 50847: SQLITE_API int sqlite3_data_count ( sqlite3_stmt * pStmt ) { 
line 50848: Vdbe * pVm = ( Vdbe * ) pStmt ; 
line 50849: if ( pVm == 0 || pVm -> pResultSet == 0 ) return 0 ; 
line 50850: return pVm -> nResColumn ; 
line 50851: } 
line 50860: static Mem * columnMem ( sqlite3_stmt * pStmt , int i ) { 
line 50861: Vdbe * pVm ; 
line 50862: int vals ; 
line 50863: Mem * pOut ; 
line 50865: pVm = ( Vdbe * ) pStmt ; 
line 50866: if ( pVm && pVm -> pResultSet != 0 && i < pVm -> nResColumn && i >= 0 ) { 
line 50867: sqlite3_mutex_enter ( pVm -> db -> mutex ) ; 
line 50868: vals = sqlite3_data_count ( pStmt ) ; 
line 50869: pOut = & pVm -> pResultSet [ i ] ; 
line 50870: } else { 
line 50882: static const Mem nullMem 
line 50883: # if defined ( SQLITE_DEBUG ) && defined ( __GNUC__ ) 
line 50884: __attribute__ ( ( aligned ( 8 ) ) ) 
line 50885: # endif 
line 50886: = { { 0 } , ( double ) 0 , 0 , "" , 0 , MEM_Null , SQLITE_NULL , 0 , 0 , 0 } ; 
line 50888: if ( pVm && ALWAYS ( pVm -> db ) ) { 
line 50889: sqlite3_mutex_enter ( pVm -> db -> mutex ) ; 
line 50890: sqlite3Error ( pVm -> db , SQLITE_RANGE , 0 ) ; 
line 50891: } 
line 50892: pOut = ( Mem * ) & nullMem ; 
line 50893: } 
line 50894: return pOut ; 
line 50895: } 
line 50916: static void columnMallocFailure ( sqlite3_stmt * pStmt ) 
line 50917: { 
line 50923: Vdbe * p = ( Vdbe * ) pStmt ; 
line 50924: if ( p ) { 
line 50925: p -> rc = sqlite3ApiExit ( p -> db , p -> rc ) ; 
line 50926: sqlite3_mutex_leave ( p -> db -> mutex ) ; 
line 50927: } 
line 50928: } 
line 50934: SQLITE_API const void * sqlite3_column_blob ( sqlite3_stmt * pStmt , int i ) { 
line 50935: const void * val ; 
line 50936: val = sqlite3_value_blob ( columnMem ( pStmt , i ) ) ; 
line 50941: columnMallocFailure ( pStmt ) ; 
line 50942: return val ; 
line 50943: } 
line 50944: SQLITE_API int sqlite3_column_bytes ( sqlite3_stmt * pStmt , int i ) { 
line 50945: int val = sqlite3_value_bytes ( columnMem ( pStmt , i ) ) ; 
line 50946: columnMallocFailure ( pStmt ) ; 
line 50947: return val ; 
line 50948: } 
line 50949: SQLITE_API int sqlite3_column_bytes16 ( sqlite3_stmt * pStmt , int i ) { 
line 50950: int val = sqlite3_value_bytes16 ( columnMem ( pStmt , i ) ) ; 
line 50951: columnMallocFailure ( pStmt ) ; 
line 50952: return val ; 
line 50953: } 
line 50954: SQLITE_API double sqlite3_column_double ( sqlite3_stmt * pStmt , int i ) { 
line 50955: double val = sqlite3_value_double ( columnMem ( pStmt , i ) ) ; 
line 50956: columnMallocFailure ( pStmt ) ; 
line 50957: return val ; 
line 50958: } 
line 50959: SQLITE_API int sqlite3_column_int ( sqlite3_stmt * pStmt , int i ) { 
line 50960: int val = sqlite3_value_int ( columnMem ( pStmt , i ) ) ; 
line 50961: columnMallocFailure ( pStmt ) ; 
line 50962: return val ; 
line 50963: } 
line 50964: SQLITE_API sqlite_int64 sqlite3_column_int64 ( sqlite3_stmt * pStmt , int i ) { 
line 50965: sqlite_int64 val = sqlite3_value_int64 ( columnMem ( pStmt , i ) ) ; 
line 50966: columnMallocFailure ( pStmt ) ; 
line 50967: return val ; 
line 50968: } 
line 50969: SQLITE_API const unsigned char * sqlite3_column_text ( sqlite3_stmt * pStmt , int i ) { 
line 50970: const unsigned char * val = sqlite3_value_text ( columnMem ( pStmt , i ) ) ; 
line 50971: columnMallocFailure ( pStmt ) ; 
line 50972: return val ; 
line 50973: } 
line 50974: SQLITE_API sqlite3_value * sqlite3_column_value ( sqlite3_stmt * pStmt , int i ) { 
line 50975: Mem * pOut = columnMem ( pStmt , i ) ; 
line 50976: if ( pOut -> flags & MEM_Static ) { 
line 50977: pOut -> flags &= ~ MEM_Static ; 
line 50978: pOut -> flags |= MEM_Ephem ; 
line 50979: } 
line 50980: columnMallocFailure ( pStmt ) ; 
line 50981: return ( sqlite3_value * ) pOut ; 
line 50982: } 
line 50983: # ifndef SQLITE_OMIT_UTF16 
line 50984: SQLITE_API const void * sqlite3_column_text16 ( sqlite3_stmt * pStmt , int i ) { 
line 50985: const void * val = sqlite3_value_text16 ( columnMem ( pStmt , i ) ) ; 
line 50986: columnMallocFailure ( pStmt ) ; 
line 50987: return val ; 
line 50988: } 
line 50989: # endif 
line 50990: SQLITE_API int sqlite3_column_type ( sqlite3_stmt * pStmt , int i ) { 
line 50991: int iType = sqlite3_value_type ( columnMem ( pStmt , i ) ) ; 
line 50992: columnMallocFailure ( pStmt ) ; 
line 50993: return iType ; 
line 50994: } 
line 51019: static const void * columnName ( 
line 51020: sqlite3_stmt * pStmt , 
line 51021: int N , 
line 51022: const void * ( * xFunc ) ( Mem * ) , 
line 51023: int useType 
line 51024: ) { 
line 51025: const void * ret = 0 ; 
line 51026: Vdbe * p = ( Vdbe * ) pStmt ; 
line 51027: int n ; 
line 51028: sqlite3 * db = p -> db ; 
line 51030: assert ( db != 0 ) ; 
line 51031: n = sqlite3_column_count ( pStmt ) ; 
line 51032: if ( N < n && N >= 0 ) { 
line 51033: N += useType * n ; 
line 51034: sqlite3_mutex_enter ( db -> mutex ) ; 
line 51035: assert ( db -> mallocFailed == 0 ) ; 
line 51036: ret = xFunc ( & p -> aColName [ N ] ) ; 
line 51040: if ( db -> mallocFailed ) { 
line 51041: db -> mallocFailed = 0 ; 
line 51042: ret = 0 ; 
line 51043: } 
line 51044: sqlite3_mutex_leave ( db -> mutex ) ; 
line 51045: } 
line 51046: return ret ; 
line 51047: } 
line 51053: SQLITE_API const char * sqlite3_column_name ( sqlite3_stmt * pStmt , int N ) { 
line 51054: return columnName ( 
line 51055: pStmt , N , ( const void * ( * ) ( Mem * ) ) sqlite3_value_text , COLNAME_NAME ) ; 
line 51056: } 
line 51057: # ifndef SQLITE_OMIT_UTF16 
line 51058: SQLITE_API const void * sqlite3_column_name16 ( sqlite3_stmt * pStmt , int N ) { 
line 51059: return columnName ( 
line 51060: pStmt , N , ( const void * ( * ) ( Mem * ) ) sqlite3_value_text16 , COLNAME_NAME ) ; 
line 51061: } 
line 51062: # endif 
line 51068: # if defined ( SQLITE_OMIT_DECLTYPE ) && defined ( SQLITE_ENABLE_COLUMN_METADATA ) 
line 51069: # error 
line 51070: "Must not define both SQLITE_OMIT_DECLTYPE \
 and SQLITE_ENABLE_COLUMN_METADATA 
line 51071: "
 # endif 
line 51073: # ifndef SQLITE_OMIT_DECLTYPE 
line 51078: SQLITE_API const char * sqlite3_column_decltype ( sqlite3_stmt * pStmt , int N ) { 
line 51079: return columnName ( 
line 51080: pStmt , N , ( const void * ( * ) ( Mem * ) ) sqlite3_value_text , COLNAME_DECLTYPE ) ; 
line 51081: } 
line 51082: # ifndef SQLITE_OMIT_UTF16 
line 51083: SQLITE_API const void * sqlite3_column_decltype16 ( sqlite3_stmt * pStmt , int N ) { 
line 51084: return columnName ( 
line 51085: pStmt , N , ( const void * ( * ) ( Mem * ) ) sqlite3_value_text16 , COLNAME_DECLTYPE ) ; 
line 51086: } 
line 51087: # endif 
line 51088: # endif 
line 51090: # ifdef SQLITE_ENABLE_COLUMN_METADATA 
line 51096: SQLITE_API const char * sqlite3_column_database_name ( sqlite3_stmt * pStmt , int N ) { 
line 51097: return columnName ( 
line 51098: pStmt , N , ( const void * ( * ) ( Mem * ) ) sqlite3_value_text , COLNAME_DATABASE ) ; 
line 51099: } 
line 51100: # ifndef SQLITE_OMIT_UTF16 
line 51101: SQLITE_API const void * sqlite3_column_database_name16 ( sqlite3_stmt * pStmt , int N ) { 
line 51102: return columnName ( 
line 51103: pStmt , N , ( const void * ( * ) ( Mem * ) ) sqlite3_value_text16 , COLNAME_DATABASE ) ; 
line 51104: } 
line 51105: # endif 
line 51112: SQLITE_API const char * sqlite3_column_table_name ( sqlite3_stmt * pStmt , int N ) { 
line 51113: return columnName ( 
line 51114: pStmt , N , ( const void * ( * ) ( Mem * ) ) sqlite3_value_text , COLNAME_TABLE ) ; 
line 51115: } 
line 51116: # ifndef SQLITE_OMIT_UTF16 
line 51117: SQLITE_API const void * sqlite3_column_table_name16 ( sqlite3_stmt * pStmt , int N ) { 
line 51118: return columnName ( 
line 51119: pStmt , N , ( const void * ( * ) ( Mem * ) ) sqlite3_value_text16 , COLNAME_TABLE ) ; 
line 51120: } 
line 51121: # endif 
line 51128: SQLITE_API const char * sqlite3_column_origin_name ( sqlite3_stmt * pStmt , int N ) { 
line 51129: return columnName ( 
line 51130: pStmt , N , ( const void * ( * ) ( Mem * ) ) sqlite3_value_text , COLNAME_COLUMN ) ; 
line 51131: } 
line 51132: # ifndef SQLITE_OMIT_UTF16 
line 51133: SQLITE_API const void * sqlite3_column_origin_name16 ( sqlite3_stmt * pStmt , int N ) { 
line 51134: return columnName ( 
line 51135: pStmt , N , ( const void * ( * ) ( Mem * ) ) sqlite3_value_text16 , COLNAME_COLUMN ) ; 
line 51136: } 
line 51137: # endif 
line 51138: # endif 
line 51156: static int vdbeUnbind ( Vdbe * p , int i ) { 
line 51157: Mem * pVar ; 
line 51158: if ( p == 0 ) return SQLITE_MISUSE ; 
line 51159: sqlite3_mutex_enter ( p -> db -> mutex ) ; 
line 51160: if ( p -> magic != VDBE_MAGIC_RUN || p -> pc >= 0 ) { 
line 51161: sqlite3Error ( p -> db , SQLITE_MISUSE , 0 ) ; 
line 51162: sqlite3_mutex_leave ( p -> db -> mutex ) ; 
line 51163: return SQLITE_MISUSE ; 
line 51164: } 
line 51165: if ( i < 1 || i > p -> nVar ) { 
line 51166: sqlite3Error ( p -> db , SQLITE_RANGE , 0 ) ; 
line 51167: sqlite3_mutex_leave ( p -> db -> mutex ) ; 
line 51168: return SQLITE_RANGE ; 
line 51169: } 
line 51170: i -- ; 
line 51171: pVar = & p -> aVar [ i ] ; 
line 51172: sqlite3VdbeMemRelease ( pVar ) ; 
line 51173: pVar -> flags = MEM_Null ; 
line 51174: sqlite3Error ( p -> db , SQLITE_OK , 0 ) ; 
line 51179: if ( p -> isPrepareV2 && 
line 51180: ( ( i < 32 && p -> expmask & ( ( u32 ) 1 << i ) ) || p -> expmask == 0xffffffff ) 
line 51181: ) { 
line 51182: p -> expired = 1 ; 
line 51183: } 
line 51184: return SQLITE_OK ; 
line 51185: } 
line 51190: static int bindText ( 
line 51191: sqlite3_stmt * pStmt , 
line 51192: int i , 
line 51193: const void * zData , 
line 51194: int nData , 
line 51195: void ( * xDel ) ( void * ) , 
line 51196: u8 encoding 
line 51197: ) { 
line 51198: Vdbe * p = ( Vdbe * ) pStmt ; 
line 51199: Mem * pVar ; 
line 51200: int rc ; 
line 51202: rc = vdbeUnbind ( p , i ) ; 
line 51203: if ( rc == SQLITE_OK ) { 
line 51204: if ( zData != 0 ) { 
line 51205: pVar = & p -> aVar [ i - 1 ] ; 
line 51206: rc = sqlite3VdbeMemSetStr ( pVar , zData , nData , encoding , xDel ) ; 
line 51207: if ( rc == SQLITE_OK && encoding != 0 ) { 
line 51208: rc = sqlite3VdbeChangeEncoding ( pVar , ENC ( p -> db ) ) ; 
line 51209: } 
line 51210: sqlite3Error ( p -> db , rc , 0 ) ; 
line 51211: rc = sqlite3ApiExit ( p -> db , rc ) ; 
line 51212: } 
line 51213: sqlite3_mutex_leave ( p -> db -> mutex ) ; 
line 51214: } 
line 51215: return rc ; 
line 51216: } 
line 51222: SQLITE_API int sqlite3_bind_blob ( 
line 51223: sqlite3_stmt * pStmt , 
line 51224: int i , 
line 51225: const void * zData , 
line 51226: int nData , 
line 51227: void ( * xDel ) ( void * ) 
line 51228: ) { 
line 51229: return bindText ( pStmt , i , zData , nData , xDel , 0 ) ; 
line 51230: } 
line 51231: SQLITE_API int sqlite3_bind_double ( sqlite3_stmt * pStmt , int i , double rValue ) { 
line 51232: int rc ; 
line 51233: Vdbe * p = ( Vdbe * ) pStmt ; 
line 51234: rc = vdbeUnbind ( p , i ) ; 
line 51235: if ( rc == SQLITE_OK ) { 
line 51236: sqlite3VdbeMemSetDouble ( & p -> aVar [ i - 1 ] , rValue ) ; 
line 51237: sqlite3_mutex_leave ( p -> db -> mutex ) ; 
line 51238: } 
line 51239: return rc ; 
line 51240: } 
line 51241: SQLITE_API int sqlite3_bind_int ( sqlite3_stmt * p , int i , int iValue ) { 
line 51242: return sqlite3_bind_int64 ( p , i , ( i64 ) iValue ) ; 
line 51243: } 
line 51244: SQLITE_API int sqlite3_bind_int64 ( sqlite3_stmt * pStmt , int i , sqlite_int64 iValue ) { 
line 51245: int rc ; 
line 51246: Vdbe * p = ( Vdbe * ) pStmt ; 
line 51247: rc = vdbeUnbind ( p , i ) ; 
line 51248: if ( rc == SQLITE_OK ) { 
line 51249: sqlite3VdbeMemSetInt64 ( & p -> aVar [ i - 1 ] , iValue ) ; 
line 51250: sqlite3_mutex_leave ( p -> db -> mutex ) ; 
line 51251: } 
line 51252: return rc ; 
line 51253: } 
line 51254: SQLITE_API int sqlite3_bind_null ( sqlite3_stmt * pStmt , int i ) { 
line 51255: int rc ; 
line 51256: Vdbe * p = ( Vdbe * ) pStmt ; 
line 51257: rc = vdbeUnbind ( p , i ) ; 
line 51258: if ( rc == SQLITE_OK ) { 
line 51259: sqlite3_mutex_leave ( p -> db -> mutex ) ; 
line 51260: } 
line 51261: return rc ; 
line 51262: } 
line 51263: SQLITE_API int sqlite3_bind_text ( 
line 51264: sqlite3_stmt * pStmt , 
line 51265: int i , 
line 51266: const char * zData , 
line 51267: int nData , 
line 51268: void ( * xDel ) ( void * ) 
line 51269: ) { 
line 51270: return bindText ( pStmt , i , zData , nData , xDel , SQLITE_UTF8 ) ; 
line 51271: } 
line 51272: # ifndef SQLITE_OMIT_UTF16 
line 51273: SQLITE_API int sqlite3_bind_text16 ( 
line 51274: sqlite3_stmt * pStmt , 
line 51275: int i , 
line 51276: const void * zData , 
line 51277: int nData , 
line 51278: void ( * xDel ) ( void * ) 
line 51279: ) { 
line 51280: return bindText ( pStmt , i , zData , nData , xDel , SQLITE_UTF16NATIVE ) ; 
line 51281: } 
line 51282: # endif 
line 51283: SQLITE_API int sqlite3_bind_value ( sqlite3_stmt * pStmt , int i , const sqlite3_value * pValue ) { 
line 51284: int rc ; 
line 51285: switch ( pValue -> type ) { 
line 51286: case SQLITE_INTEGER : { 
line 51287: rc = sqlite3_bind_int64 ( pStmt , i , pValue -> u . i ) ; 
line 51288: break ; 
line 51289: } 
line 51290: case SQLITE_FLOAT : { 
line 51291: rc = sqlite3_bind_double ( pStmt , i , pValue -> r ) ; 
line 51292: break ; 
line 51293: } 
line 51294: case SQLITE_BLOB : { 
line 51295: if ( pValue -> flags & MEM_Zero ) { 
line 51296: rc = sqlite3_bind_zeroblob ( pStmt , i , pValue -> u . nZero ) ; 
line 51297: } else { 
line 51298: rc = sqlite3_bind_blob ( pStmt , i , pValue -> z , pValue -> n , SQLITE_TRANSIENT ) ; 
line 51299: } 
line 51300: break ; 
line 51301: } 
line 51302: case SQLITE_TEXT : { 
line 51303: rc = bindText ( pStmt , i , pValue -> z , pValue -> n , SQLITE_TRANSIENT , 
line 51304: pValue -> enc ) ; 
line 51305: break ; 
line 51306: } 
line 51307: default : { 
line 51308: rc = sqlite3_bind_null ( pStmt , i ) ; 
line 51309: break ; 
line 51310: } 
line 51311: } 
line 51312: return rc ; 
line 51313: } 
line 51314: SQLITE_API int sqlite3_bind_zeroblob ( sqlite3_stmt * pStmt , int i , int n ) { 
line 51315: int rc ; 
line 51316: Vdbe * p = ( Vdbe * ) pStmt ; 
line 51317: rc = vdbeUnbind ( p , i ) ; 
line 51318: if ( rc == SQLITE_OK ) { 
line 51319: sqlite3VdbeMemSetZeroBlob ( & p -> aVar [ i - 1 ] , n ) ; 
line 51320: sqlite3_mutex_leave ( p -> db -> mutex ) ; 
line 51321: } 
line 51322: return rc ; 
line 51323: } 
line 51329: SQLITE_API int sqlite3_bind_parameter_count ( sqlite3_stmt * pStmt ) { 
line 51330: Vdbe * p = ( Vdbe * ) pStmt ; 
line 51331: return p ? p -> nVar : 0 ; 
line 51332: } 
line 51339: static void createVarMap ( Vdbe * p ) { 
line 51340: if ( ! p -> okVar ) { 
line 51341: int j ; 
line 51342: Op * pOp ; 
line 51343: sqlite3_mutex_enter ( p -> db -> mutex ) ; 
line 51349: for ( j = 0 , pOp = p -> aOp ; j < p -> nOp ; j ++ , pOp ++ ) { 
line 51350: if ( pOp -> opcode == OP_Variable ) { 
line 51351: assert ( pOp -> p1 > 0 && pOp -> p1 <= p -> nVar ) ; 
line 51352: p -> azVar [ pOp -> p1 - 1 ] = pOp -> p4 . z ; 
line 51353: } 
line 51354: } 
line 51355: p -> okVar = 1 ; 
line 51356: sqlite3_mutex_leave ( p -> db -> mutex ) ; 
line 51357: } 
line 51358: } 
line 51366: SQLITE_API const char * sqlite3_bind_parameter_name ( sqlite3_stmt * pStmt , int i ) { 
line 51367: Vdbe * p = ( Vdbe * ) pStmt ; 
line 51368: if ( p == 0 || i < 1 || i > p -> nVar ) { 
line 51369: return 0 ; 
line 51370: } 
line 51371: createVarMap ( p ) ; 
line 51372: return p -> azVar [ i - 1 ] ; 
line 51373: } 
line 51380: SQLITE_PRIVATE int sqlite3VdbeParameterIndex ( Vdbe * p , const char * zName , int nName ) { 
line 51381: int i ; 
line 51382: if ( p == 0 ) { 
line 51383: return 0 ; 
line 51384: } 
line 51385: createVarMap ( p ) ; 
line 51386: if ( zName ) { 
line 51387: for ( i = 0 ; i < p -> nVar ; i ++ ) { 
line 51388: const char * z = p -> azVar [ i ] ; 
line 51389: if ( z && memcmp ( z , zName , nName ) == 0 && z [ nName ] == 0 ) { 
line 51390: return i + 1 ; 
line 51391: } 
line 51392: } 
line 51393: } 
line 51394: return 0 ; 
line 51395: } 
line 51396: SQLITE_API int sqlite3_bind_parameter_index ( sqlite3_stmt * pStmt , const char * zName ) { 
line 51397: return sqlite3VdbeParameterIndex ( ( Vdbe * ) pStmt , zName , sqlite3Strlen30 ( zName ) ) ; 
line 51398: } 
line 51403: SQLITE_PRIVATE int sqlite3TransferBindings ( sqlite3_stmt * pFromStmt , sqlite3_stmt * pToStmt ) { 
line 51404: Vdbe * pFrom = ( Vdbe * ) pFromStmt ; 
line 51405: Vdbe * pTo = ( Vdbe * ) pToStmt ; 
line 51406: int i ; 
line 51407: assert ( pTo -> db == pFrom -> db ) ; 
line 51408: assert ( pTo -> nVar == pFrom -> nVar ) ; 
line 51409: sqlite3_mutex_enter ( pTo -> db -> mutex ) ; 
line 51410: for ( i = 0 ; i < pFrom -> nVar ; i ++ ) { 
line 51411: sqlite3VdbeMemMove ( & pTo -> aVar [ i ] , & pFrom -> aVar [ i ] ) ; 
line 51412: } 
line 51413: sqlite3_mutex_leave ( pTo -> db -> mutex ) ; 
line 51414: return SQLITE_OK ; 
line 51415: } 
line 51417: # ifndef SQLITE_OMIT_DEPRECATED 
line 51430: SQLITE_API int sqlite3_transfer_bindings ( sqlite3_stmt * pFromStmt , sqlite3_stmt * pToStmt ) { 
line 51431: Vdbe * pFrom = ( Vdbe * ) pFromStmt ; 
line 51432: Vdbe * pTo = ( Vdbe * ) pToStmt ; 
line 51433: if ( pFrom -> nVar != pTo -> nVar ) { 
line 51434: return SQLITE_ERROR ; 
line 51435: } 
line 51436: if ( pTo -> isPrepareV2 && pTo -> expmask ) { 
line 51437: pTo -> expired = 1 ; 
line 51438: } 
line 51439: if ( pFrom -> isPrepareV2 && pFrom -> expmask ) { 
line 51440: pFrom -> expired = 1 ; 
line 51441: } 
line 51442: return sqlite3TransferBindings ( pFromStmt , pToStmt ) ; 
line 51443: } 
line 51444: # endif 
line 51452: SQLITE_API sqlite3 * sqlite3_db_handle ( sqlite3_stmt * pStmt ) { 
line 51453: return pStmt ? ( ( Vdbe * ) pStmt ) -> db : 0 ; 
line 51454: } 
line 51462: SQLITE_API sqlite3_stmt * sqlite3_next_stmt ( sqlite3 * pDb , sqlite3_stmt * pStmt ) { 
line 51463: sqlite3_stmt * pNext ; 
line 51464: sqlite3_mutex_enter ( pDb -> mutex ) ; 
line 51465: if ( pStmt == 0 ) { 
line 51466: pNext = ( sqlite3_stmt * ) pDb -> pVdbe ; 
line 51467: } else { 
line 51468: pNext = ( sqlite3_stmt * ) ( ( Vdbe * ) pStmt ) -> pNext ; 
line 51469: } 
line 51470: sqlite3_mutex_leave ( pDb -> mutex ) ; 
line 51471: return pNext ; 
line 51472: } 
line 51477: SQLITE_API int sqlite3_stmt_status ( sqlite3_stmt * pStmt , int op , int resetFlag ) { 
line 51478: Vdbe * pVdbe = ( Vdbe * ) pStmt ; 
line 51479: int v = pVdbe -> aCounter [ op - 1 ] ; 
line 51480: if ( resetFlag ) pVdbe -> aCounter [ op - 1 ] = 0 ; 
line 51481: return v ; 
line 51482: } 
line 51502: # ifndef SQLITE_OMIT_TRACE 
line 51510: static int findNextHostParameter ( const char * zSql , int * pnToken ) { 
line 51511: int tokenType ; 
line 51512: int nTotal = 0 ; 
line 51513: int n ; 
line 51515: * pnToken = 0 ; 
line 51516: while ( zSql [ 0 ] ) { 
line 51517: n = sqlite3GetToken ( ( u8 * ) zSql , & tokenType ) ; 
line 51518: assert ( n > 0 && tokenType != TK_ILLEGAL ) ; 
line 51519: if ( tokenType == TK_VARIABLE ) { 
line 51520: * pnToken = n ; 
line 51521: break ; 
line 51522: } 
line 51523: nTotal += n ; 
line 51524: zSql += n ; 
line 51525: } 
line 51526: return nTotal ; 
line 51527: } 
line 51545: SQLITE_PRIVATE char * sqlite3VdbeExpandSql ( 
line 51546: Vdbe * p , 
line 51547: const char * zRawSql 
line 51548: ) { 
line 51549: sqlite3 * db ; 
line 51550: int idx = 0 ; 
line 51551: int nextIndex = 1 ; 
line 51552: int n ; 
line 51553: int nToken ; 
line 51554: int i ; 
line 51555: Mem * pVar ; 
line 51556: StrAccum out ; 
line 51557: char zBase [ 100 ] ; 
line 51559: db = p -> db ; 
line 51560: sqlite3StrAccumInit ( & out , zBase , sizeof ( zBase ) , 
line 51561: db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) ; 
line 51562: out . db = db ; 
line 51563: while ( zRawSql [ 0 ] ) { 
line 51564: n = findNextHostParameter ( zRawSql , & nToken ) ; 
line 51565: assert ( n > 0 ) ; 
line 51566: sqlite3StrAccumAppend ( & out , zRawSql , n ) ; 
line 51567: zRawSql += n ; 
line 51568: assert ( zRawSql [ 0 ] || nToken == 0 ) ; 
line 51569: if ( nToken == 0 ) break ; 
line 51570: if ( zRawSql [ 0 ] == '?' ) { 
line 51571: if ( nToken > 1 ) { 
line 51572: assert ( sqlite3Isdigit ( zRawSql [ 1 ] ) ) ; 
line 51573: sqlite3GetInt32 ( & zRawSql [ 1 ] , & idx ) ; 
line 51574: } else { 
line 51575: idx = nextIndex ; 
line 51576: } 
line 51577: } else { 
line 51578: assert ( zRawSql [ 0 ] == ':' || zRawSql [ 0 ] == '$' || zRawSql [ 0 ] == '@' ) ; 
line 51579: testcase ( zRawSql [ 0 ] == ':' ) ; 
line 51580: testcase ( zRawSql [ 0 ] == '$' ) ; 
line 51581: testcase ( zRawSql [ 0 ] == '@' ) ; 
line 51582: idx = sqlite3VdbeParameterIndex ( p , zRawSql , nToken ) ; 
line 51583: assert ( idx > 0 ) ; 
line 51584: } 
line 51585: zRawSql += nToken ; 
line 51586: nextIndex = idx + 1 ; 
line 51587: assert ( idx > 0 && idx <= p -> nVar ) ; 
line 51588: pVar = & p -> aVar [ idx - 1 ] ; 
line 51589: if ( pVar -> flags & MEM_Null ) { 
line 51590: sqlite3StrAccumAppend ( & out , "NULL" , 4 ) ; 
line 51591: } else if ( pVar -> flags & MEM_Int ) { 
line 51592: sqlite3XPrintf ( & out , "%lld" , pVar -> u . i ) ; 
line 51593: } else if ( pVar -> flags & MEM_Real ) { 
line 51594: sqlite3XPrintf ( & out , "%!.15g" , pVar -> r ) ; 
line 51595: } else if ( pVar -> flags & MEM_Str ) { 
line 51596: # ifndef SQLITE_OMIT_UTF16 
line 51597: u8 enc = ENC ( db ) ; 
line 51598: if ( enc != SQLITE_UTF8 ) { 
line 51599: Mem utf8 ; 
line 51600: memset ( & utf8 , 0 , sizeof ( utf8 ) ) ; 
line 51601: utf8 . db = db ; 
line 51602: sqlite3VdbeMemSetStr ( & utf8 , pVar -> z , pVar -> n , enc , SQLITE_STATIC ) ; 
line 51603: sqlite3VdbeChangeEncoding ( & utf8 , SQLITE_UTF8 ) ; 
line 51604: sqlite3XPrintf ( & out , "'%.*q'" , utf8 . n , utf8 . z ) ; 
line 51605: sqlite3VdbeMemRelease ( & utf8 ) ; 
line 51606: } else 
line 51607: # endif 
line 51608: { 
line 51609: sqlite3XPrintf ( & out , "'%.*q'" , pVar -> n , pVar -> z ) ; 
line 51610: } 
line 51611: } else if ( pVar -> flags & MEM_Zero ) { 
line 51612: sqlite3XPrintf ( & out , "zeroblob(%d)" , pVar -> u . nZero ) ; 
line 51613: } else { 
line 51614: assert ( pVar -> flags & MEM_Blob ) ; 
line 51615: sqlite3StrAccumAppend ( & out , "x'" , 2 ) ; 
line 51616: for ( i = 0 ; i < pVar -> n ; i ++ ) { 
line 51617: sqlite3XPrintf ( & out , "%02x" , pVar -> z [ i ] & 0xff ) ; 
line 51618: } 
line 51619: sqlite3StrAccumAppend ( & out , "'" , 1 ) ; 
line 51620: } 
line 51621: } 
line 51622: return sqlite3StrAccumFinish ( & out ) ; 
line 51623: } 
line 51625: # endif 
line 51682: # ifdef SQLITE_TEST 
line 51683: SQLITE_API int sqlite3_search_count = 0 ; 
line 51684: # endif 
line 51694: # ifdef SQLITE_TEST 
line 51695: SQLITE_API int sqlite3_interrupt_count = 0 ; 
line 51696: # endif 
line 51705: # ifdef SQLITE_TEST 
line 51706: SQLITE_API int sqlite3_sort_count = 0 ; 
line 51707: # endif 
line 51716: # ifdef SQLITE_TEST 
line 51717: SQLITE_API int sqlite3_max_blobsize = 0 ; 
line 51718: static void updateMaxBlobsize ( Mem * p ) { 
line 51719: if ( ( p -> flags & ( MEM_Str | MEM_Blob ) ) != 0 && p -> n > sqlite3_max_blobsize ) { 
line 51720: sqlite3_max_blobsize = p -> n ; 
line 51721: } 
line 51722: } 
line 51723: # endif 
line 51732: # ifdef SQLITE_TEST 
line 51733: SQLITE_API int sqlite3_found_count = 0 ; 
line 51734: # endif 
line 51740: # if defined ( SQLITE_TEST ) && ! defined ( SQLITE_OMIT_BUILTIN_TEST ) 
line 51741: # define UPDATE_MAX_BLOBSIZE ( P ) updateMaxBlobsize ( P ) 
line 51742: # else 
line 51743: # define UPDATE_MAX_BLOBSIZE ( P ) 
line 51744: # endif 
line 51750: # define Stringify ( P , enc ) 
line 51751: if ( ( ( P ) -> flags & ( MEM_Str | MEM_Blob ) ) == 0 && sqlite3VdbeMemStringify ( P , enc ) ) 
line 51752: { goto no_mem ; } 
line 51765: # define Deephemeralize ( P ) 
line 51766: if ( ( ( P ) -> flags & MEM_Ephem ) != 0 
line 51767: && sqlite3VdbeMemMakeWriteable ( P ) ) { goto no_mem ; } 
line 51773: # define ExpandBlob ( P ) ( ( ( P ) -> flags & MEM_Zero ) ? sqlite3VdbeMemExpandBlob ( P ) : 0 ) 
line 51781: SQLITE_PRIVATE void sqlite3VdbeMemStoreType ( Mem * pMem ) { 
line 51782: int flags = pMem -> flags ; 
line 51783: if ( flags & MEM_Null ) { 
line 51784: pMem -> type = SQLITE_NULL ; 
line 51785: } 
line 51786: else if ( flags & MEM_Int ) { 
line 51787: pMem -> type = SQLITE_INTEGER ; 
line 51788: } 
line 51789: else if ( flags & MEM_Real ) { 
line 51790: pMem -> type = SQLITE_FLOAT ; 
line 51791: } 
line 51792: else if ( flags & MEM_Str ) { 
line 51793: pMem -> type = SQLITE_TEXT ; 
line 51794: } else { 
line 51795: pMem -> type = SQLITE_BLOB ; 
line 51796: } 
line 51797: } 
line 51803: static VdbeCursor * allocateCursor ( 
line 51804: Vdbe * p , 
line 51805: int iCur , 
line 51806: int nField , 
line 51807: int iDb , 
line 51808: int isBtreeCursor 
line 51809: ) { 
line 51828: Mem * pMem = & p -> aMem [ p -> nMem - iCur ] ; 
line 51830: int nByte ; 
line 51831: VdbeCursor * pCx = 0 ; 
line 51832: nByte = 
line 51833: ROUND8 ( sizeof ( VdbeCursor ) ) + 
line 51834: ( isBtreeCursor ? sqlite3BtreeCursorSize ( ) : 0 ) + 
line 51835: 2 * nField * sizeof ( u32 ) ; 
line 51837: assert ( iCur < p -> nCursor ) ; 
line 51838: if ( p -> apCsr [ iCur ] ) { 
line 51839: sqlite3VdbeFreeCursor ( p , p -> apCsr [ iCur ] ) ; 
line 51840: p -> apCsr [ iCur ] = 0 ; 
line 51841: } 
line 51842: if ( SQLITE_OK == sqlite3VdbeMemGrow ( pMem , nByte , 0 ) ) { 
line 51843: p -> apCsr [ iCur ] = pCx = ( VdbeCursor * ) pMem -> z ; 
line 51844: memset ( pCx , 0 , sizeof ( VdbeCursor ) ) ; 
line 51845: pCx -> iDb = iDb ; 
line 51846: pCx -> nField = nField ; 
line 51847: if ( nField ) { 
line 51848: pCx -> aType = ( u32 * ) & pMem -> z [ ROUND8 ( sizeof ( VdbeCursor ) ) ] ; 
line 51849: } 
line 51850: if ( isBtreeCursor ) { 
line 51851: pCx -> pCursor = ( BtCursor * ) 
line 51852: & pMem -> z [ ROUND8 ( sizeof ( VdbeCursor ) ) + 2 * nField * sizeof ( u32 ) ] ; 
line 51853: sqlite3BtreeCursorZero ( pCx -> pCursor ) ; 
line 51854: } 
line 51855: } 
line 51856: return pCx ; 
line 51857: } 
line 51865: static void applyNumericAffinity ( Mem * pRec ) { 
line 51866: if ( ( pRec -> flags & ( MEM_Real | MEM_Int ) ) == 0 ) { 
line 51867: int realnum ; 
line 51868: sqlite3VdbeMemNulTerminate ( pRec ) ; 
line 51869: if ( ( pRec -> flags & MEM_Str ) 
line 51870: && sqlite3IsNumber ( pRec -> z , & realnum , pRec -> enc ) ) { 
line 51871: i64 value ; 
line 51872: sqlite3VdbeChangeEncoding ( pRec , SQLITE_UTF8 ) ; 
line 51873: if ( ! realnum && sqlite3Atoi64 ( pRec -> z , & value ) ) { 
line 51874: pRec -> u . i = value ; 
line 51875: MemSetTypeFlag ( pRec , MEM_Int ) ; 
line 51876: } else { 
line 51877: sqlite3VdbeMemRealify ( pRec ) ; 
line 51878: } 
line 51879: } 
line 51880: } 
line 51881: } 
line 51901: static void applyAffinity ( 
line 51902: Mem * pRec , 
line 51903: char affinity , 
line 51904: u8 enc 
line 51905: ) { 
line 51906: if ( affinity == SQLITE_AFF_TEXT ) { 
line 51911: if ( 0 == ( pRec -> flags & MEM_Str ) && ( pRec -> flags & ( MEM_Real | MEM_Int ) ) ) { 
line 51912: sqlite3VdbeMemStringify ( pRec , enc ) ; 
line 51913: } 
line 51914: pRec -> flags &= ~ ( MEM_Real | MEM_Int ) ; 
line 51915: } else if ( affinity != SQLITE_AFF_NONE ) { 
line 51916: assert ( affinity == SQLITE_AFF_INTEGER || affinity == SQLITE_AFF_REAL 
line 51917: || affinity == SQLITE_AFF_NUMERIC ) ; 
line 51918: applyNumericAffinity ( pRec ) ; 
line 51919: if ( pRec -> flags & MEM_Real ) { 
line 51920: sqlite3VdbeIntegerAffinity ( pRec ) ; 
line 51921: } 
line 51922: } 
line 51923: } 
line 51933: SQLITE_API int sqlite3_value_numeric_type ( sqlite3_value * pVal ) { 
line 51934: Mem * pMem = ( Mem * ) pVal ; 
line 51935: applyNumericAffinity ( pMem ) ; 
line 51936: sqlite3VdbeMemStoreType ( pMem ) ; 
line 51937: return pMem -> type ; 
line 51938: } 
line 51944: SQLITE_PRIVATE void sqlite3ValueApplyAffinity ( 
line 51945: sqlite3_value * pVal , 
line 51946: u8 affinity , 
line 51947: u8 enc 
line 51948: ) { 
line 51949: applyAffinity ( ( Mem * ) pVal , affinity , enc ) ; 
line 51950: } 
line 51952: # ifdef SQLITE_DEBUG 
line 51957: SQLITE_PRIVATE void sqlite3VdbeMemPrettyPrint ( Mem * pMem , char * zBuf ) { 
line 51958: char * zCsr = zBuf ; 
line 51959: int f = pMem -> flags ; 
line 51961: static const char * const encnames [ ] = { "(X)" , "(8)" , "(16LE)" , "(16BE)" } ; 
line 51963: if ( f & MEM_Blob ) { 
line 51964: int i ; 
line 51965: char c ; 
line 51966: if ( f & MEM_Dyn ) { 
line 51967: c = 'z' ; 
line 51968: assert ( ( f & ( MEM_Static | MEM_Ephem ) ) == 0 ) ; 
line 51969: } else if ( f & MEM_Static ) { 
line 51970: c = 't' ; 
line 51971: assert ( ( f & ( MEM_Dyn | MEM_Ephem ) ) == 0 ) ; 
line 51972: } else if ( f & MEM_Ephem ) { 
line 51973: c = 'e' ; 
line 51974: assert ( ( f & ( MEM_Static | MEM_Dyn ) ) == 0 ) ; 
line 51975: } else { 
line 51976: c = 's' ; 
line 51977: } 
line 51979: sqlite3_snprintf ( 100 , zCsr , "%c" , c ) ; 
line 51980: zCsr += sqlite3Strlen30 ( zCsr ) ; 
line 51981: sqlite3_snprintf ( 100 , zCsr , "%d[" , pMem -> n ) ; 
line 51982: zCsr += sqlite3Strlen30 ( zCsr ) ; 
line 51983: for ( i = 0 ; i < 16 && i < pMem -> n ; i ++ ) { 
line 51984: sqlite3_snprintf ( 100 , zCsr , "%02X" , ( ( int ) pMem -> z [ i ] & 0xFF ) ) ; 
line 51985: zCsr += sqlite3Strlen30 ( zCsr ) ; 
line 51986: } 
line 51987: for ( i = 0 ; i < 16 && i < pMem -> n ; i ++ ) { 
line 51988: char z = pMem -> z [ i ] ; 
line 51989: if ( z < 32 || z > 126 ) * zCsr ++ = '.' ; 
line 51990: else * zCsr ++ = z ; 
line 51991: } 
line 51993: sqlite3_snprintf ( 100 , zCsr , "]%s" , encnames [ pMem -> enc ] ) ; 
line 51994: zCsr += sqlite3Strlen30 ( zCsr ) ; 
line 51995: if ( f & MEM_Zero ) { 
line 51996: sqlite3_snprintf ( 100 , zCsr , "+%dz" , pMem -> u . nZero ) ; 
line 51997: zCsr += sqlite3Strlen30 ( zCsr ) ; 
line 51998: } 
line 51999: * zCsr = '\0' ; 
line 52000: } else if ( f & MEM_Str ) { 
line 52001: int j , k ; 
line 52002: zBuf [ 0 ] = ' ' ; 
line 52003: if ( f & MEM_Dyn ) { 
line 52004: zBuf [ 1 ] = 'z' ; 
line 52005: assert ( ( f & ( MEM_Static | MEM_Ephem ) ) == 0 ) ; 
line 52006: } else if ( f & MEM_Static ) { 
line 52007: zBuf [ 1 ] = 't' ; 
line 52008: assert ( ( f & ( MEM_Dyn | MEM_Ephem ) ) == 0 ) ; 
line 52009: } else if ( f & MEM_Ephem ) { 
line 52010: zBuf [ 1 ] = 'e' ; 
line 52011: assert ( ( f & ( MEM_Static | MEM_Dyn ) ) == 0 ) ; 
line 52012: } else { 
line 52013: zBuf [ 1 ] = 's' ; 
line 52014: } 
line 52015: k = 2 ; 
line 52016: sqlite3_snprintf ( 100 , & zBuf [ k ] , "%d" , pMem -> n ) ; 
line 52017: k += sqlite3Strlen30 ( & zBuf [ k ] ) ; 
line 52018: zBuf [ k ++ ] = '[' ; 
line 52019: for ( j = 0 ; j < 15 && j < pMem -> n ; j ++ ) { 
line 52020: u8 c = pMem -> z [ j ] ; 
line 52021: if ( c >= 0x20 && c < 0x7f ) { 
line 52022: zBuf [ k ++ ] = c ; 
line 52023: } else { 
line 52024: zBuf [ k ++ ] = '.' ; 
line 52025: } 
line 52026: } 
line 52027: zBuf [ k ++ ] = ']' ; 
line 52028: sqlite3_snprintf ( 100 , & zBuf [ k ] , encnames [ pMem -> enc ] ) ; 
line 52029: k += sqlite3Strlen30 ( & zBuf [ k ] ) ; 
line 52030: zBuf [ k ++ ] = 0 ; 
line 52031: } 
line 52032: } 
line 52033: # endif 
line 52035: # ifdef SQLITE_DEBUG 
line 52039: static void memTracePrint ( FILE * out , Mem * p ) { 
line 52040: if ( p -> flags & MEM_Null ) { 
line 52041: fprintf ( out , " NULL" ) ; 
line 52042: } else if ( ( p -> flags & ( MEM_Int | MEM_Str ) ) == ( MEM_Int | MEM_Str ) ) { 
line 52043: fprintf ( out , " si:%lld" , p -> u . i ) ; 
line 52044: } else if ( p -> flags & MEM_Int ) { 
line 52045: fprintf ( out , " i:%lld" , p -> u . i ) ; 
line 52046: # ifndef SQLITE_OMIT_FLOATING_POINT 
line 52047: } else if ( p -> flags & MEM_Real ) { 
line 52048: fprintf ( out , " r:%g" , p -> r ) ; 
line 52049: # endif 
line 52050: } else if ( p -> flags & MEM_RowSet ) { 
line 52051: fprintf ( out , " (rowset)" ) ; 
line 52052: } else { 
line 52053: char zBuf [ 200 ] ; 
line 52054: sqlite3VdbeMemPrettyPrint ( p , zBuf ) ; 
line 52055: fprintf ( out , " " ) ; 
line 52056: fprintf ( out , "%s" , zBuf ) ; 
line 52057: } 
line 52058: } 
line 52059: static void registerTrace ( FILE * out , int iReg , Mem * p ) { 
line 52060: fprintf ( out , "REG[%d] = " , iReg ) ; 
line 52061: memTracePrint ( out , p ) ; 
line 52062: fprintf ( out , "\n" ) ; 
line 52063: } 
line 52064: # endif 
line 52066: # ifdef SQLITE_DEBUG 
line 52067: # define REGISTER_TRACE ( R , M ) if ( p -> trace ) registerTrace ( p -> trace , R , M ) 
line 52068: # else 
line 52069: # define REGISTER_TRACE ( R , M ) 
line 52070: # endif 
line 52073: # ifdef VDBE_PROFILE 
line 52096: # ifndef _HWTIME_H_ 
line 52097: # define _HWTIME_H_ 
line 52105: # if ( defined ( __GNUC__ ) || defined ( _MSC_VER ) ) && 
line 52106: ( defined ( i386 ) || defined ( __i386__ ) || defined ( _M_IX86 ) ) 
line 52108: # if defined ( __GNUC__ ) 
line 52110: __inline__ sqlite_uint64 sqlite3Hwtime ( void ) { 
line 52111: unsigned int lo , hi ; 
line 52112: __asm__ __volatile__ ( "rdtsc" : "=a" ( lo ) , "=d" ( hi ) ) ; 
line 52113: return ( sqlite_uint64 ) hi << 32 | lo ; 
line 52114: } 
line 52116: # elif defined ( _MSC_VER ) 
line 52118: __declspec ( naked ) __inline sqlite_uint64 __cdecl sqlite3Hwtime ( void ) { 
line 52119: __asm { 
line 52120: rdtsc 
line 52121: ret ; return value at EDX : EAX 
line 52122: } 
line 52123: } 
line 52125: # endif 
line 52127: # elif ( defined ( __GNUC__ ) && defined ( __x86_64__ ) ) 
line 52129: __inline__ sqlite_uint64 sqlite3Hwtime ( void ) { 
line 52130: unsigned long val ; 
line 52131: __asm__ __volatile__ ( "rdtsc" : "=A" ( val ) ) ; 
line 52132: return val ; 
line 52133: } 
line 52135: # elif ( defined ( __GNUC__ ) && defined ( __ppc__ ) ) 
line 52137: __inline__ sqlite_uint64 sqlite3Hwtime ( void ) { 
line 52138: unsigned long long retval ; 
line 52139: unsigned long junk ; 
line 52140: __asm__ __volatile__ ( 
line 52141: "\n\
 1 : mftbu % 1 \ 
line 52142: n mftb % L0 \ 
line 52143: n mftbu % 0 \ 
line 52144: n cmpw % 0 , % 1 \ 
line 52145: n bne 1b 
line 52146: "
 : "=r" ( retval ) , "=r" ( junk ) ) ; 
line 52147: return retval ; 
line 52148: } 
line 52150: # else 
line 52152: # error Need implementation of sqlite3Hwtime ( ) for your platform . 
line 52161: SQLITE_PRIVATE sqlite_uint64 sqlite3Hwtime ( void ) { return ( ( sqlite_uint64 ) 0 ) ; } 
line 52163: # endif 
line 52165: # endif 
line 52170: # endif 
line 52182: # define CHECK_FOR_INTERRUPT 
line 52183: if ( db -> u1 . isInterrupted ) goto abort_due_to_interrupt ; 
line 52185: # ifdef SQLITE_DEBUG 
line 52186: static int fileExists ( sqlite3 * db , const char * zFile ) { 
line 52187: int res = 0 ; 
line 52188: int rc = SQLITE_OK ; 
line 52189: # ifdef SQLITE_TEST 
line 52194: extern int sqlite3_io_error_pending ; 
line 52195: if ( sqlite3_io_error_pending <= 0 ) 
line 52196: # endif 
line 52197: rc = sqlite3OsAccess ( db -> pVfs , zFile , SQLITE_ACCESS_EXISTS , & res ) ; 
line 52198: return ( res && rc == SQLITE_OK ) ; 
line 52199: } 
line 52200: # endif 
line 52202: # ifndef NDEBUG 
line 52213: static int checkSavepointCount ( sqlite3 * db ) { 
line 52214: int n = 0 ; 
line 52215: Savepoint * p ; 
line 52216: for ( p = db -> pSavepoint ; p ; p = p -> pNext ) n ++ ; 
line 52217: assert ( n == ( db -> nSavepoint + db -> isTransactionSavepoint ) ) ; 
line 52218: return 1 ; 
line 52219: } 
line 52220: # endif 
line 52253: SQLITE_PRIVATE int sqlite3VdbeExec ( 
line 52254: Vdbe * p 
line 52255: ) { 
line 52256: int pc ; 
line 52257: Op * aOp = p -> aOp ; 
line 52258: Op * pOp ; 
line 52259: int rc = SQLITE_OK ; 
line 52260: sqlite3 * db = p -> db ; 
line 52261: u8 resetSchemaOnFault = 0 ; 
line 52262: u8 encoding = ENC ( db ) ; 
line 52263: # ifndef SQLITE_OMIT_PROGRESS_CALLBACK 
line 52264: int checkProgress ; 
line 52265: int nProgressOps = 0 ; 
line 52266: # endif 
line 52267: Mem * aMem = p -> aMem ; 
line 52268: Mem * pIn1 = 0 ; 
line 52269: Mem * pIn2 = 0 ; 
line 52270: Mem * pIn3 = 0 ; 
line 52271: Mem * pOut = 0 ; 
line 52272: int iCompare = 0 ; 
line 52273: int * aPermute = 0 ; 
line 52274: # ifdef VDBE_PROFILE 
line 52275: u64 start ; 
line 52276: int origPc ; 
line 52277: # endif 
line 52286: union vdbeExecUnion { 
line 52287: struct OP_Yield_stack_vars { 
line 52288: int pcDest ; 
line 52289: } aa ; 
line 52290: struct OP_Variable_stack_vars { 
line 52291: int p1 ; 
line 52292: int p2 ; 
line 52293: int n ; 
line 52294: Mem * pVar ; 
line 52295: } ab ; 
line 52296: struct OP_Move_stack_vars { 
line 52297: char * zMalloc ; 
line 52298: int n ; 
line 52299: int p1 ; 
line 52300: int p2 ; 
line 52301: } ac ; 
line 52302: struct OP_ResultRow_stack_vars { 
line 52303: Mem * pMem ; 
line 52304: int i ; 
line 52305: } ad ; 
line 52306: struct OP_Concat_stack_vars { 
line 52307: i64 nByte ; 
line 52308: } ae ; 
line 52309: struct OP_Remainder_stack_vars { 
line 52310: int flags ; 
line 52311: i64 iA ; 
line 52312: i64 iB ; 
line 52313: double rA ; 
line 52314: double rB ; 
line 52315: } af ; 
line 52316: struct OP_Function_stack_vars { 
line 52317: int i ; 
line 52318: Mem * pArg ; 
line 52319: sqlite3_context ctx ; 
line 52320: sqlite3_value * * apVal ; 
line 52321: int n ; 
line 52322: } ag ; 
line 52323: struct OP_ShiftRight_stack_vars { 
line 52324: i64 a ; 
line 52325: i64 b ; 
line 52326: } ah ; 
line 52327: struct OP_Ge_stack_vars { 
line 52328: int res ; 
line 52329: char affinity ; 
line 52330: } ai ; 
line 52331: struct OP_Compare_stack_vars { 
line 52332: int n ; 
line 52333: int i ; 
line 52334: int p1 ; 
line 52335: int p2 ; 
line 52336: const KeyInfo * pKeyInfo ; 
line 52337: int idx ; 
line 52338: CollSeq * pColl ; 
line 52339: int bRev ; 
line 52340: } aj ; 
line 52341: struct OP_Or_stack_vars { 
line 52342: int v1 ; 
line 52343: int v2 ; 
line 52344: } ak ; 
line 52345: struct OP_IfNot_stack_vars { 
line 52346: int c ; 
line 52347: } al ; 
line 52348: struct OP_Column_stack_vars { 
line 52349: u32 payloadSize ; 
line 52350: i64 payloadSize64 ; 
line 52351: int p1 ; 
line 52352: int p2 ; 
line 52353: VdbeCursor * pC ; 
line 52354: char * zRec ; 
line 52355: BtCursor * pCrsr ; 
line 52356: u32 * aType ; 
line 52357: u32 * aOffset ; 
line 52358: int nField ; 
line 52359: int len ; 
line 52360: int i ; 
line 52361: char * zData ; 
line 52362: Mem * pDest ; 
line 52363: Mem sMem ; 
line 52364: u8 * zIdx ; 
line 52365: u8 * zEndHdr ; 
line 52366: u32 offset ; 
line 52367: u64 offset64 ; 
line 52368: int szHdr ; 
line 52369: int avail ; 
line 52370: Mem * pReg ; 
line 52371: } am ; 
line 52372: struct OP_Affinity_stack_vars { 
line 52373: const char * zAffinity ; 
line 52374: char cAff ; 
line 52375: } an ; 
line 52376: struct OP_MakeRecord_stack_vars { 
line 52377: u8 * zNewRecord ; 
line 52378: Mem * pRec ; 
line 52379: u64 nData ; 
line 52380: int nHdr ; 
line 52381: i64 nByte ; 
line 52382: int nZero ; 
line 52383: int nVarint ; 
line 52384: u32 serial_type ; 
line 52385: Mem * pData0 ; 
line 52386: Mem * pLast ; 
line 52387: int nField ; 
line 52388: char * zAffinity ; 
line 52389: int file_format ; 
line 52390: int i ; 
line 52391: int len ; 
line 52392: } ao ; 
line 52393: struct OP_Count_stack_vars { 
line 52394: i64 nEntry ; 
line 52395: BtCursor * pCrsr ; 
line 52396: } ap ; 
line 52397: struct OP_Savepoint_stack_vars { 
line 52398: int p1 ; 
line 52399: char * zName ; 
line 52400: int nName ; 
line 52401: Savepoint * pNew ; 
line 52402: Savepoint * pSavepoint ; 
line 52403: Savepoint * pTmp ; 
line 52404: int iSavepoint ; 
line 52405: int ii ; 
line 52406: } aq ; 
line 52407: struct OP_AutoCommit_stack_vars { 
line 52408: int desiredAutoCommit ; 
line 52409: int iRollback ; 
line 52410: int turnOnAC ; 
line 52411: } ar ; 
line 52412: struct OP_Transaction_stack_vars { 
line 52413: Btree * pBt ; 
line 52414: } as ; 
line 52415: struct OP_ReadCookie_stack_vars { 
line 52416: int iMeta ; 
line 52417: int iDb ; 
line 52418: int iCookie ; 
line 52419: } at ; 
line 52420: struct OP_SetCookie_stack_vars { 
line 52421: Db * pDb ; 
line 52422: } au ; 
line 52423: struct OP_VerifyCookie_stack_vars { 
line 52424: int iMeta ; 
line 52425: Btree * pBt ; 
line 52426: } av ; 
line 52427: struct OP_OpenWrite_stack_vars { 
line 52428: int nField ; 
line 52429: KeyInfo * pKeyInfo ; 
line 52430: int p2 ; 
line 52431: int iDb ; 
line 52432: int wrFlag ; 
line 52433: Btree * pX ; 
line 52434: VdbeCursor * pCur ; 
line 52435: Db * pDb ; 
line 52436: } aw ; 
line 52437: struct OP_OpenEphemeral_stack_vars { 
line 52438: VdbeCursor * pCx ; 
line 52439: } ax ; 
line 52440: struct OP_OpenPseudo_stack_vars { 
line 52441: VdbeCursor * pCx ; 
line 52442: } ay ; 
line 52443: struct OP_SeekGt_stack_vars { 
line 52444: int res ; 
line 52445: int oc ; 
line 52446: VdbeCursor * pC ; 
line 52447: UnpackedRecord r ; 
line 52448: int nField ; 
line 52449: i64 iKey ; 
line 52450: } az ; 
line 52451: struct OP_Seek_stack_vars { 
line 52452: VdbeCursor * pC ; 
line 52453: } ba ; 
line 52454: struct OP_Found_stack_vars { 
line 52455: int alreadyExists ; 
line 52456: VdbeCursor * pC ; 
line 52457: int res ; 
line 52458: UnpackedRecord * pIdxKey ; 
line 52459: UnpackedRecord r ; 
line 52460: char aTempRec [ ROUND8 ( sizeof ( UnpackedRecord ) ) + sizeof ( Mem ) * 3 + 7 ] ; 
line 52461: } bb ; 
line 52462: struct OP_IsUnique_stack_vars { 
line 52463: u16 ii ; 
line 52464: VdbeCursor * pCx ; 
line 52465: BtCursor * pCrsr ; 
line 52466: u16 nField ; 
line 52467: Mem * aMx ; 
line 52468: UnpackedRecord r ; 
line 52469: i64 R ; 
line 52470: } bc ; 
line 52471: struct OP_NotExists_stack_vars { 
line 52472: VdbeCursor * pC ; 
line 52473: BtCursor * pCrsr ; 
line 52474: int res ; 
line 52475: u64 iKey ; 
line 52476: } bd ; 
line 52477: struct OP_NewRowid_stack_vars { 
line 52478: i64 v ; 
line 52479: VdbeCursor * pC ; 
line 52480: int res ; 
line 52481: int cnt ; 
line 52482: Mem * pMem ; 
line 52483: VdbeFrame * pFrame ; 
line 52484: } be ; 
line 52485: struct OP_InsertInt_stack_vars { 
line 52486: Mem * pData ; 
line 52487: Mem * pKey ; 
line 52488: i64 iKey ; 
line 52489: VdbeCursor * pC ; 
line 52490: int nZero ; 
line 52491: int seekResult ; 
line 52492: const char * zDb ; 
line 52493: const char * zTbl ; 
line 52494: int op ; 
line 52495: } bf ; 
line 52496: struct OP_Delete_stack_vars { 
line 52497: i64 iKey ; 
line 52498: VdbeCursor * pC ; 
line 52499: } bg ; 
line 52500: struct OP_RowData_stack_vars { 
line 52501: VdbeCursor * pC ; 
line 52502: BtCursor * pCrsr ; 
line 52503: u32 n ; 
line 52504: i64 n64 ; 
line 52505: } bh ; 
line 52506: struct OP_Rowid_stack_vars { 
line 52507: VdbeCursor * pC ; 
line 52508: i64 v ; 
line 52509: sqlite3_vtab * pVtab ; 
line 52510: const sqlite3_module * pModule ; 
line 52511: } bi ; 
line 52512: struct OP_NullRow_stack_vars { 
line 52513: VdbeCursor * pC ; 
line 52514: } bj ; 
line 52515: struct OP_Last_stack_vars { 
line 52516: VdbeCursor * pC ; 
line 52517: BtCursor * pCrsr ; 
line 52518: int res ; 
line 52519: } bk ; 
line 52520: struct OP_Rewind_stack_vars { 
line 52521: VdbeCursor * pC ; 
line 52522: BtCursor * pCrsr ; 
line 52523: int res ; 
line 52524: } bl ; 
line 52525: struct OP_Next_stack_vars { 
line 52526: VdbeCursor * pC ; 
line 52527: BtCursor * pCrsr ; 
line 52528: int res ; 
line 52529: } bm ; 
line 52530: struct OP_IdxInsert_stack_vars { 
line 52531: VdbeCursor * pC ; 
line 52532: BtCursor * pCrsr ; 
line 52533: int nKey ; 
line 52534: const char * zKey ; 
line 52535: } bn ; 
line 52536: struct OP_IdxDelete_stack_vars { 
line 52537: VdbeCursor * pC ; 
line 52538: BtCursor * pCrsr ; 
line 52539: int res ; 
line 52540: UnpackedRecord r ; 
line 52541: } bo ; 
line 52542: struct OP_IdxRowid_stack_vars { 
line 52543: BtCursor * pCrsr ; 
line 52544: VdbeCursor * pC ; 
line 52545: i64 rowid ; 
line 52546: } bp ; 
line 52547: struct OP_IdxGE_stack_vars { 
line 52548: VdbeCursor * pC ; 
line 52549: int res ; 
line 52550: UnpackedRecord r ; 
line 52551: } bq ; 
line 52552: struct OP_Destroy_stack_vars { 
line 52553: int iMoved ; 
line 52554: int iCnt ; 
line 52555: Vdbe * pVdbe ; 
line 52556: int iDb ; 
line 52557: } br ; 
line 52558: struct OP_Clear_stack_vars { 
line 52559: int nChange ; 
line 52560: } bs ; 
line 52561: struct OP_CreateTable_stack_vars { 
line 52562: int pgno ; 
line 52563: int flags ; 
line 52564: Db * pDb ; 
line 52565: } bt ; 
line 52566: struct OP_ParseSchema_stack_vars { 
line 52567: int iDb ; 
line 52568: const char * zMaster ; 
line 52569: char * zSql ; 
line 52570: InitData initData ; 
line 52571: } bu ; 
line 52572: struct OP_IntegrityCk_stack_vars { 
line 52573: int nRoot ; 
line 52574: int * aRoot ; 
line 52575: int j ; 
line 52576: int nErr ; 
line 52577: char * z ; 
line 52578: Mem * pnErr ; 
line 52579: } bv ; 
line 52580: struct OP_RowSetRead_stack_vars { 
line 52581: i64 val ; 
line 52582: } bw ; 
line 52583: struct OP_RowSetTest_stack_vars { 
line 52584: int iSet ; 
line 52585: int exists ; 
line 52586: } bx ; 
line 52587: struct OP_Program_stack_vars { 
line 52588: int nMem ; 
line 52589: int nByte ; 
line 52590: Mem * pRt ; 
line 52591: Mem * pMem ; 
line 52592: Mem * pEnd ; 
line 52593: VdbeFrame * pFrame ; 
line 52594: SubProgram * pProgram ; 
line 52595: void * t ; 
line 52596: } by ; 
line 52597: struct OP_Param_stack_vars { 
line 52598: VdbeFrame * pFrame ; 
line 52599: Mem * pIn ; 
line 52600: } bz ; 
line 52601: struct OP_MemMax_stack_vars { 
line 52602: Mem * pIn1 ; 
line 52603: VdbeFrame * pFrame ; 
line 52604: } ca ; 
line 52605: struct OP_AggStep_stack_vars { 
line 52606: int n ; 
line 52607: int i ; 
line 52608: Mem * pMem ; 
line 52609: Mem * pRec ; 
line 52610: sqlite3_context ctx ; 
line 52611: sqlite3_value * * apVal ; 
line 52612: } cb ; 
line 52613: struct OP_AggFinal_stack_vars { 
line 52614: Mem * pMem ; 
line 52615: } cc ; 
line 52616: struct OP_IncrVacuum_stack_vars { 
line 52617: Btree * pBt ; 
line 52618: } cd ; 
line 52619: struct OP_VBegin_stack_vars { 
line 52620: VTable * pVTab ; 
line 52621: } ce ; 
line 52622: struct OP_VOpen_stack_vars { 
line 52623: VdbeCursor * pCur ; 
line 52624: sqlite3_vtab_cursor * pVtabCursor ; 
line 52625: sqlite3_vtab * pVtab ; 
line 52626: sqlite3_module * pModule ; 
line 52627: } cf ; 
line 52628: struct OP_VFilter_stack_vars { 
line 52629: int nArg ; 
line 52630: int iQuery ; 
line 52631: const sqlite3_module * pModule ; 
line 52632: Mem * pQuery ; 
line 52633: Mem * pArgc ; 
line 52634: sqlite3_vtab_cursor * pVtabCursor ; 
line 52635: sqlite3_vtab * pVtab ; 
line 52636: VdbeCursor * pCur ; 
line 52637: int res ; 
line 52638: int i ; 
line 52639: Mem * * apArg ; 
line 52640: } cg ; 
line 52641: struct OP_VColumn_stack_vars { 
line 52642: sqlite3_vtab * pVtab ; 
line 52643: const sqlite3_module * pModule ; 
line 52644: Mem * pDest ; 
line 52645: sqlite3_context sContext ; 
line 52646: } ch ; 
line 52647: struct OP_VNext_stack_vars { 
line 52648: sqlite3_vtab * pVtab ; 
line 52649: const sqlite3_module * pModule ; 
line 52650: int res ; 
line 52651: VdbeCursor * pCur ; 
line 52652: } ci ; 
line 52653: struct OP_VRename_stack_vars { 
line 52654: sqlite3_vtab * pVtab ; 
line 52655: Mem * pName ; 
line 52656: } cj ; 
line 52657: struct OP_VUpdate_stack_vars { 
line 52658: sqlite3_vtab * pVtab ; 
line 52659: sqlite3_module * pModule ; 
line 52660: int nArg ; 
line 52661: int i ; 
line 52662: sqlite_int64 rowid ; 
line 52663: Mem * * apArg ; 
line 52664: Mem * pX ; 
line 52665: } ck ; 
line 52666: struct OP_Pagecount_stack_vars { 
line 52667: int p1 ; 
line 52668: int nPage ; 
line 52669: Pager * pPager ; 
line 52670: } cl ; 
line 52671: struct OP_Trace_stack_vars { 
line 52672: char * zTrace ; 
line 52673: } cm ; 
line 52674: } u ; 
line 52678: assert ( p -> magic == VDBE_MAGIC_RUN ) ; 
line 52679: assert ( db -> magic == SQLITE_MAGIC_BUSY ) ; 
line 52680: sqlite3VdbeMutexArrayEnter ( p ) ; 
line 52681: if ( p -> rc == SQLITE_NOMEM ) { 
line 52684: goto no_mem ; 
line 52685: } 
line 52686: assert ( p -> rc == SQLITE_OK || p -> rc == SQLITE_BUSY ) ; 
line 52687: p -> rc = SQLITE_OK ; 
line 52688: assert ( p -> explain == 0 ) ; 
line 52689: p -> pResultSet = 0 ; 
line 52690: db -> busyHandler . nBusy = 0 ; 
line 52691: CHECK_FOR_INTERRUPT ; 
line 52692: sqlite3VdbeIOTraceSql ( p ) ; 
line 52693: # ifndef SQLITE_OMIT_PROGRESS_CALLBACK 
line 52694: checkProgress = db -> xProgress != 0 ; 
line 52695: # endif 
line 52696: # ifdef SQLITE_DEBUG 
line 52697: sqlite3BeginBenignMalloc ( ) ; 
line 52698: if ( p -> pc == 0 
line 52699: && ( ( p -> db -> flags & SQLITE_VdbeListing ) || fileExists ( db , "vdbe_explain" ) ) 
line 52700: ) { 
line 52701: int i ; 
line 52702: printf ( "VDBE Program Listing:\n" ) ; 
line 52703: sqlite3VdbePrintSql ( p ) ; 
line 52704: for ( i = 0 ; i < p -> nOp ; i ++ ) { 
line 52705: sqlite3VdbePrintOp ( stdout , i , & aOp [ i ] ) ; 
line 52706: } 
line 52707: } 
line 52708: if ( fileExists ( db , "vdbe_trace" ) ) { 
line 52709: p -> trace = stdout ; 
line 52710: } 
line 52711: sqlite3EndBenignMalloc ( ) ; 
line 52712: # endif 
line 52713: for ( pc = p -> pc ; rc == SQLITE_OK ; pc ++ ) { 
line 52714: assert ( pc >= 0 && pc < p -> nOp ) ; 
line 52715: if ( db -> mallocFailed ) goto no_mem ; 
line 52716: # ifdef VDBE_PROFILE 
line 52717: origPc = pc ; 
line 52718: start = sqlite3Hwtime ( ) ; 
line 52719: # endif 
line 52720: pOp = & aOp [ pc ] ; 
line 52724: # ifdef SQLITE_DEBUG 
line 52725: if ( p -> trace ) { 
line 52726: if ( pc == 0 ) { 
line 52727: printf ( "VDBE Execution Trace:\n" ) ; 
line 52728: sqlite3VdbePrintSql ( p ) ; 
line 52729: } 
line 52730: sqlite3VdbePrintOp ( p -> trace , pc , pOp ) ; 
line 52731: } 
line 52732: if ( p -> trace == 0 && pc == 0 ) { 
line 52733: sqlite3BeginBenignMalloc ( ) ; 
line 52734: if ( fileExists ( db , "vdbe_sqltrace" ) ) { 
line 52735: sqlite3VdbePrintSql ( p ) ; 
line 52736: } 
line 52737: sqlite3EndBenignMalloc ( ) ; 
line 52738: } 
line 52739: # endif 
line 52745: # ifdef SQLITE_TEST 
line 52746: if ( sqlite3_interrupt_count > 0 ) { 
line 52747: sqlite3_interrupt_count -- ; 
line 52748: if ( sqlite3_interrupt_count == 0 ) { 
line 52749: sqlite3_interrupt ( db ) ; 
line 52750: } 
line 52751: } 
line 52752: # endif 
line 52754: # ifndef SQLITE_OMIT_PROGRESS_CALLBACK 
line 52761: if ( checkProgress ) { 
line 52762: if ( db -> nProgressOps == nProgressOps ) { 
line 52763: int prc ; 
line 52764: if ( sqlite3SafetyOff ( db ) ) goto abort_due_to_misuse ; 
line 52765: prc = db -> xProgress ( db -> pProgressArg ) ; 
line 52766: if ( sqlite3SafetyOn ( db ) ) goto abort_due_to_misuse ; 
line 52767: if ( prc != 0 ) { 
line 52768: rc = SQLITE_INTERRUPT ; 
line 52769: goto vdbe_error_halt ; 
line 52770: } 
line 52771: nProgressOps = 0 ; 
line 52772: } 
line 52773: nProgressOps ++ ; 
line 52774: } 
line 52775: # endif 
line 52782: assert ( pOp -> opflags == sqlite3OpcodeProperty [ pOp -> opcode ] ) ; 
line 52783: if ( pOp -> opflags & OPFLG_OUT2_PRERELEASE ) { 
line 52784: assert ( pOp -> p2 > 0 ) ; 
line 52785: assert ( pOp -> p2 <= p -> nMem ) ; 
line 52786: pOut = & aMem [ pOp -> p2 ] ; 
line 52787: sqlite3VdbeMemReleaseExternal ( pOut ) ; 
line 52788: pOut -> flags = MEM_Int ; 
line 52789: } 
line 52792: # ifdef SQLITE_DEBUG 
line 52793: if ( ( pOp -> opflags & OPFLG_IN1 ) != 0 ) { 
line 52794: assert ( pOp -> p1 > 0 ) ; 
line 52795: assert ( pOp -> p1 <= p -> nMem ) ; 
line 52796: REGISTER_TRACE ( pOp -> p1 , & aMem [ pOp -> p1 ] ) ; 
line 52797: } 
line 52798: if ( ( pOp -> opflags & OPFLG_IN2 ) != 0 ) { 
line 52799: assert ( pOp -> p2 > 0 ) ; 
line 52800: assert ( pOp -> p2 <= p -> nMem ) ; 
line 52801: REGISTER_TRACE ( pOp -> p2 , & aMem [ pOp -> p2 ] ) ; 
line 52802: } 
line 52803: if ( ( pOp -> opflags & OPFLG_IN3 ) != 0 ) { 
line 52804: assert ( pOp -> p3 > 0 ) ; 
line 52805: assert ( pOp -> p3 <= p -> nMem ) ; 
line 52806: REGISTER_TRACE ( pOp -> p3 , & aMem [ pOp -> p3 ] ) ; 
line 52807: } 
line 52808: if ( ( pOp -> opflags & OPFLG_OUT2 ) != 0 ) { 
line 52809: assert ( pOp -> p2 > 0 ) ; 
line 52810: assert ( pOp -> p2 <= p -> nMem ) ; 
line 52811: } 
line 52812: if ( ( pOp -> opflags & OPFLG_OUT3 ) != 0 ) { 
line 52813: assert ( pOp -> p3 > 0 ) ; 
line 52814: assert ( pOp -> p3 <= p -> nMem ) ; 
line 52815: } 
line 52816: # endif 
line 52818: switch ( pOp -> opcode ) { 
line 52862: case OP_Goto : { 
line 52863: CHECK_FOR_INTERRUPT ; 
line 52864: pc = pOp -> p2 - 1 ; 
line 52865: break ; 
line 52866: } 
line 52873: case OP_Gosub : { 
line 52874: pIn1 = & aMem [ pOp -> p1 ] ; 
line 52875: assert ( ( pIn1 -> flags & MEM_Dyn ) == 0 ) ; 
line 52876: pIn1 -> flags = MEM_Int ; 
line 52877: pIn1 -> u . i = pc ; 
line 52878: REGISTER_TRACE ( pOp -> p1 , pIn1 ) ; 
line 52879: pc = pOp -> p2 - 1 ; 
line 52880: break ; 
line 52881: } 
line 52887: case OP_Return : { 
line 52888: pIn1 = & aMem [ pOp -> p1 ] ; 
line 52889: assert ( pIn1 -> flags & MEM_Int ) ; 
line 52890: pc = ( int ) pIn1 -> u . i ; 
line 52891: break ; 
line 52892: } 
line 52898: case OP_Yield : { 
line 52899: # if 0 
line 52900: int pcDest ; 
line 52901: # endif 
line 52902: pIn1 = & aMem [ pOp -> p1 ] ; 
line 52903: assert ( ( pIn1 -> flags & MEM_Dyn ) == 0 ) ; 
line 52904: pIn1 -> flags = MEM_Int ; 
line 52905: u . aa . pcDest = ( int ) pIn1 -> u . i ; 
line 52906: pIn1 -> u . i = pc ; 
line 52907: REGISTER_TRACE ( pOp -> p1 , pIn1 ) ; 
line 52908: pc = u . aa . pcDest ; 
line 52909: break ; 
line 52910: } 
line 52918: case OP_HaltIfNull : { 
line 52919: pIn3 = & aMem [ pOp -> p3 ] ; 
line 52920: if ( ( pIn3 -> flags & MEM_Null ) == 0 ) break ; 
line 52922: } 
line 52943: case OP_Halt : { 
line 52944: if ( pOp -> p1 == SQLITE_OK && p -> pFrame ) { 
line 52946: VdbeFrame * pFrame = p -> pFrame ; 
line 52947: p -> pFrame = pFrame -> pParent ; 
line 52948: p -> nFrame -- ; 
line 52949: sqlite3VdbeSetChanges ( db , p -> nChange ) ; 
line 52950: pc = sqlite3VdbeFrameRestore ( pFrame ) ; 
line 52951: if ( pOp -> p2 == OE_Ignore ) { 
line 52957: pc = p -> aOp [ pc ] . p2 - 1 ; 
line 52958: } 
line 52959: aOp = p -> aOp ; 
line 52960: aMem = p -> aMem ; 
line 52961: break ; 
line 52962: } 
line 52964: p -> rc = pOp -> p1 ; 
line 52965: p -> errorAction = ( u8 ) pOp -> p2 ; 
line 52966: p -> pc = pc ; 
line 52967: if ( pOp -> p4 . z ) { 
line 52968: sqlite3SetString ( & p -> zErrMsg , db , "%s" , pOp -> p4 . z ) ; 
line 52969: } 
line 52970: rc = sqlite3VdbeHalt ( p ) ; 
line 52971: assert ( rc == SQLITE_BUSY || rc == SQLITE_OK || rc == SQLITE_ERROR ) ; 
line 52972: if ( rc == SQLITE_BUSY ) { 
line 52973: p -> rc = rc = SQLITE_BUSY ; 
line 52974: } else { 
line 52975: assert ( rc == SQLITE_OK || p -> rc == SQLITE_CONSTRAINT ) ; 
line 52976: assert ( rc == SQLITE_OK || db -> nDeferredCons > 0 ) ; 
line 52977: rc = p -> rc ? SQLITE_ERROR : SQLITE_DONE ; 
line 52978: } 
line 52979: goto vdbe_return ; 
line 52980: } 
line 52986: case OP_Integer : { 
line 52987: pOut -> u . i = pOp -> p1 ; 
line 52988: break ; 
line 52989: } 
line 52996: case OP_Int64 : { 
line 52997: assert ( pOp -> p4 . pI64 != 0 ) ; 
line 52998: pOut -> u . i = * pOp -> p4 . pI64 ; 
line 52999: break ; 
line 53000: } 
line 53007: case OP_Real : { 
line 53008: pOut -> flags = MEM_Real ; 
line 53009: assert ( ! sqlite3IsNaN ( * pOp -> p4 . pReal ) ) ; 
line 53010: pOut -> r = * pOp -> p4 . pReal ; 
line 53011: break ; 
line 53012: } 
line 53019: case OP_String8 : { 
line 53020: assert ( pOp -> p4 . z != 0 ) ; 
line 53021: pOp -> opcode = OP_String ; 
line 53022: pOp -> p1 = sqlite3Strlen30 ( pOp -> p4 . z ) ; 
line 53024: # ifndef SQLITE_OMIT_UTF16 
line 53025: if ( encoding != SQLITE_UTF8 ) { 
line 53026: rc = sqlite3VdbeMemSetStr ( pOut , pOp -> p4 . z , - 1 , SQLITE_UTF8 , SQLITE_STATIC ) ; 
line 53027: if ( rc == SQLITE_TOOBIG ) goto too_big ; 
line 53028: if ( SQLITE_OK != sqlite3VdbeChangeEncoding ( pOut , encoding ) ) goto no_mem ; 
line 53029: assert ( pOut -> zMalloc == pOut -> z ) ; 
line 53030: assert ( pOut -> flags & MEM_Dyn ) ; 
line 53031: pOut -> zMalloc = 0 ; 
line 53032: pOut -> flags |= MEM_Static ; 
line 53033: pOut -> flags &= ~ MEM_Dyn ; 
line 53034: if ( pOp -> p4type == P4_DYNAMIC ) { 
line 53035: sqlite3DbFree ( db , pOp -> p4 . z ) ; 
line 53036: } 
line 53037: pOp -> p4type = P4_DYNAMIC ; 
line 53038: pOp -> p4 . z = pOut -> z ; 
line 53039: pOp -> p1 = pOut -> n ; 
line 53040: } 
line 53041: # endif 
line 53042: if ( pOp -> p1 > db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) { 
line 53043: goto too_big ; 
line 53044: } 
line 53046: } 
line 53052: case OP_String : { 
line 53053: assert ( pOp -> p4 . z != 0 ) ; 
line 53054: pOut -> flags = MEM_Str | MEM_Static | MEM_Term ; 
line 53055: pOut -> z = pOp -> p4 . z ; 
line 53056: pOut -> n = pOp -> p1 ; 
line 53057: pOut -> enc = encoding ; 
line 53058: UPDATE_MAX_BLOBSIZE ( pOut ) ; 
line 53059: break ; 
line 53060: } 
line 53066: case OP_Null : { 
line 53067: pOut -> flags = MEM_Null ; 
line 53068: break ; 
line 53069: } 
line 53081: case OP_Blob : { 
line 53082: assert ( pOp -> p1 <= SQLITE_MAX_LENGTH ) ; 
line 53083: sqlite3VdbeMemSetStr ( pOut , pOp -> p4 . z , pOp -> p1 , 0 , 0 ) ; 
line 53084: pOut -> enc = encoding ; 
line 53085: UPDATE_MAX_BLOBSIZE ( pOut ) ; 
line 53086: break ; 
line 53087: } 
line 53097: case OP_Variable : { 
line 53098: # if 0 
line 53099: int p1 ; 
line 53100: int p2 ; 
line 53101: int n ; 
line 53102: Mem * pVar ; 
line 53103: # endif 
line 53105: u . ab . p1 = pOp -> p1 - 1 ; 
line 53106: u . ab . p2 = pOp -> p2 ; 
line 53107: u . ab . n = pOp -> p3 ; 
line 53108: assert ( u . ab . p1 >= 0 && u . ab . p1 + u . ab . n <= p -> nVar ) ; 
line 53109: assert ( u . ab . p2 >= 1 && u . ab . p2 + u . ab . n - 1 <= p -> nMem ) ; 
line 53110: assert ( pOp -> p4 . z == 0 || pOp -> p3 == 1 || pOp -> p3 == 0 ) ; 
line 53112: while ( u . ab . n -- > 0 ) { 
line 53113: u . ab . pVar = & p -> aVar [ u . ab . p1 ++ ] ; 
line 53114: if ( sqlite3VdbeMemTooBig ( u . ab . pVar ) ) { 
line 53115: goto too_big ; 
line 53116: } 
line 53117: pOut = & aMem [ u . ab . p2 ++ ] ; 
line 53118: sqlite3VdbeMemReleaseExternal ( pOut ) ; 
line 53119: pOut -> flags = MEM_Null ; 
line 53120: sqlite3VdbeMemShallowCopy ( pOut , u . ab . pVar , MEM_Static ) ; 
line 53121: UPDATE_MAX_BLOBSIZE ( pOut ) ; 
line 53122: } 
line 53123: break ; 
line 53124: } 
line 53133: case OP_Move : { 
line 53134: # if 0 
line 53135: char * zMalloc ; 
line 53136: int n ; 
line 53137: int p1 ; 
line 53138: int p2 ; 
line 53139: # endif 
line 53141: u . ac . n = pOp -> p3 ; 
line 53142: u . ac . p1 = pOp -> p1 ; 
line 53143: u . ac . p2 = pOp -> p2 ; 
line 53144: assert ( u . ac . n > 0 && u . ac . p1 > 0 && u . ac . p2 > 0 ) ; 
line 53145: assert ( u . ac . p1 + u . ac . n <= u . ac . p2 || u . ac . p2 + u . ac . n <= u . ac . p1 ) ; 
line 53147: pIn1 = & aMem [ u . ac . p1 ] ; 
line 53148: pOut = & aMem [ u . ac . p2 ] ; 
line 53149: while ( u . ac . n -- ) { 
line 53150: assert ( pOut <= & aMem [ p -> nMem ] ) ; 
line 53151: assert ( pIn1 <= & aMem [ p -> nMem ] ) ; 
line 53152: u . ac . zMalloc = pOut -> zMalloc ; 
line 53153: pOut -> zMalloc = 0 ; 
line 53154: sqlite3VdbeMemMove ( pOut , pIn1 ) ; 
line 53155: pIn1 -> zMalloc = u . ac . zMalloc ; 
line 53156: REGISTER_TRACE ( u . ac . p2 ++ , pOut ) ; 
line 53157: pIn1 ++ ; 
line 53158: pOut ++ ; 
line 53159: } 
line 53160: break ; 
line 53161: } 
line 53170: case OP_Copy : { 
line 53171: pIn1 = & aMem [ pOp -> p1 ] ; 
line 53172: pOut = & aMem [ pOp -> p2 ] ; 
line 53173: assert ( pOut != pIn1 ) ; 
line 53174: sqlite3VdbeMemShallowCopy ( pOut , pIn1 , MEM_Ephem ) ; 
line 53175: Deephemeralize ( pOut ) ; 
line 53176: REGISTER_TRACE ( pOp -> p2 , pOut ) ; 
line 53177: break ; 
line 53178: } 
line 53192: case OP_SCopy : { 
line 53193: pIn1 = & aMem [ pOp -> p1 ] ; 
line 53194: pOut = & aMem [ pOp -> p2 ] ; 
line 53195: assert ( pOut != pIn1 ) ; 
line 53196: sqlite3VdbeMemShallowCopy ( pOut , pIn1 , MEM_Ephem ) ; 
line 53197: REGISTER_TRACE ( pOp -> p2 , pOut ) ; 
line 53198: break ; 
line 53199: } 
line 53209: case OP_ResultRow : { 
line 53210: # if 0 
line 53211: Mem * pMem ; 
line 53212: int i ; 
line 53213: # endif 
line 53214: assert ( p -> nResColumn == pOp -> p2 ) ; 
line 53215: assert ( pOp -> p1 > 0 ) ; 
line 53216: assert ( pOp -> p1 + pOp -> p2 <= p -> nMem + 1 ) ; 
line 53221: if ( SQLITE_OK != ( rc = sqlite3VdbeCheckFk ( p , 0 ) ) ) { 
line 53222: assert ( db -> flags & SQLITE_CountRows ) ; 
line 53223: assert ( p -> usesStmtJournal ) ; 
line 53224: break ; 
line 53225: } 
line 53242: assert ( p -> iStatement == 0 || db -> flags & SQLITE_CountRows ) ; 
line 53243: rc = sqlite3VdbeCloseStatement ( p , SAVEPOINT_RELEASE ) ; 
line 53244: if ( NEVER ( rc != SQLITE_OK ) ) { 
line 53245: break ; 
line 53246: } 
line 53249: p -> cacheCtr = ( p -> cacheCtr + 2 ) | 1 ; 
line 53255: u . ad . pMem = p -> pResultSet = & aMem [ pOp -> p1 ] ; 
line 53256: for ( u . ad . i = 0 ; u . ad . i < pOp -> p2 ; u . ad . i ++ ) { 
line 53257: sqlite3VdbeMemNulTerminate ( & u . ad . pMem [ u . ad . i ] ) ; 
line 53258: sqlite3VdbeMemStoreType ( & u . ad . pMem [ u . ad . i ] ) ; 
line 53259: REGISTER_TRACE ( pOp -> p1 + u . ad . i , & u . ad . pMem [ u . ad . i ] ) ; 
line 53260: } 
line 53261: if ( db -> mallocFailed ) goto no_mem ; 
line 53265: p -> pc = pc + 1 ; 
line 53266: rc = SQLITE_ROW ; 
line 53267: goto vdbe_return ; 
line 53268: } 
line 53282: case OP_Concat : { 
line 53283: # if 0 
line 53284: i64 nByte ; 
line 53285: # endif 
line 53287: pIn1 = & aMem [ pOp -> p1 ] ; 
line 53288: pIn2 = & aMem [ pOp -> p2 ] ; 
line 53289: pOut = & aMem [ pOp -> p3 ] ; 
line 53290: assert ( pIn1 != pOut ) ; 
line 53291: if ( ( pIn1 -> flags | pIn2 -> flags ) & MEM_Null ) { 
line 53292: sqlite3VdbeMemSetNull ( pOut ) ; 
line 53293: break ; 
line 53294: } 
line 53295: if ( ExpandBlob ( pIn1 ) || ExpandBlob ( pIn2 ) ) goto no_mem ; 
line 53296: Stringify ( pIn1 , encoding ) ; 
line 53297: Stringify ( pIn2 , encoding ) ; 
line 53298: u . ae . nByte = pIn1 -> n + pIn2 -> n ; 
line 53299: if ( u . ae . nByte > db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) { 
line 53300: goto too_big ; 
line 53301: } 
line 53302: MemSetTypeFlag ( pOut , MEM_Str ) ; 
line 53303: if ( sqlite3VdbeMemGrow ( pOut , ( int ) u . ae . nByte + 2 , pOut == pIn2 ) ) { 
line 53304: goto no_mem ; 
line 53305: } 
line 53306: if ( pOut != pIn2 ) { 
line 53307: memcpy ( pOut -> z , pIn2 -> z , pIn2 -> n ) ; 
line 53308: } 
line 53309: memcpy ( & pOut -> z [ pIn2 -> n ] , pIn1 -> z , pIn1 -> n ) ; 
line 53310: pOut -> z [ u . ae . nByte ] = 0 ; 
line 53311: pOut -> z [ u . ae . nByte + 1 ] = 0 ; 
line 53312: pOut -> flags |= MEM_Term ; 
line 53313: pOut -> n = ( int ) u . ae . nByte ; 
line 53314: pOut -> enc = encoding ; 
line 53315: UPDATE_MAX_BLOBSIZE ( pOut ) ; 
line 53316: break ; 
line 53317: } 
line 53352: case OP_Add : 
line 53353: case OP_Subtract : 
line 53354: case OP_Multiply : 
line 53355: case OP_Divide : 
line 53356: case OP_Remainder : { 
line 53357: # if 0 
line 53358: int flags ; 
line 53359: i64 iA ; 
line 53360: i64 iB ; 
line 53361: double rA ; 
line 53362: double rB ; 
line 53363: # endif 
line 53365: pIn1 = & aMem [ pOp -> p1 ] ; 
line 53366: applyNumericAffinity ( pIn1 ) ; 
line 53367: pIn2 = & aMem [ pOp -> p2 ] ; 
line 53368: applyNumericAffinity ( pIn2 ) ; 
line 53369: pOut = & aMem [ pOp -> p3 ] ; 
line 53370: u . af . flags = pIn1 -> flags | pIn2 -> flags ; 
line 53371: if ( ( u . af . flags & MEM_Null ) != 0 ) goto arithmetic_result_is_null ; 
line 53372: if ( ( pIn1 -> flags & pIn2 -> flags & MEM_Int ) == MEM_Int ) { 
line 53373: u . af . iA = pIn1 -> u . i ; 
line 53374: u . af . iB = pIn2 -> u . i ; 
line 53375: switch ( pOp -> opcode ) { 
line 53376: case OP_Add : u . af . iB += u . af . iA ; break ; 
line 53377: case OP_Subtract : u . af . iB -= u . af . iA ; break ; 
line 53378: case OP_Multiply : u . af . iB *= u . af . iA ; break ; 
line 53379: case OP_Divide : { 
line 53380: if ( u . af . iA == 0 ) goto arithmetic_result_is_null ; 
line 53388: if ( u . af . iA == - 1 && u . af . iB == SMALLEST_INT64 ) u . af . iA = 1 ; 
line 53389: u . af . iB /= u . af . iA ; 
line 53390: break ; 
line 53391: } 
line 53392: default : { 
line 53393: if ( u . af . iA == 0 ) goto arithmetic_result_is_null ; 
line 53394: if ( u . af . iA == - 1 ) u . af . iA = 1 ; 
line 53395: u . af . iB %= u . af . iA ; 
line 53396: break ; 
line 53397: } 
line 53398: } 
line 53399: pOut -> u . i = u . af . iB ; 
line 53400: MemSetTypeFlag ( pOut , MEM_Int ) ; 
line 53401: } else { 
line 53402: u . af . rA = sqlite3VdbeRealValue ( pIn1 ) ; 
line 53403: u . af . rB = sqlite3VdbeRealValue ( pIn2 ) ; 
line 53404: switch ( pOp -> opcode ) { 
line 53405: case OP_Add : u . af . rB += u . af . rA ; break ; 
line 53406: case OP_Subtract : u . af . rB -= u . af . rA ; break ; 
line 53407: case OP_Multiply : u . af . rB *= u . af . rA ; break ; 
line 53408: case OP_Divide : { 
line 53410: if ( u . af . rA == ( double ) 0 ) goto arithmetic_result_is_null ; 
line 53411: u . af . rB /= u . af . rA ; 
line 53412: break ; 
line 53413: } 
line 53414: default : { 
line 53415: u . af . iA = ( i64 ) u . af . rA ; 
line 53416: u . af . iB = ( i64 ) u . af . rB ; 
line 53417: if ( u . af . iA == 0 ) goto arithmetic_result_is_null ; 
line 53418: if ( u . af . iA == - 1 ) u . af . iA = 1 ; 
line 53419: u . af . rB = ( double ) ( u . af . iB % u . af . iA ) ; 
line 53420: break ; 
line 53421: } 
line 53422: } 
line 53423: if ( sqlite3IsNaN ( u . af . rB ) ) { 
line 53424: goto arithmetic_result_is_null ; 
line 53425: } 
line 53426: pOut -> r = u . af . rB ; 
line 53427: MemSetTypeFlag ( pOut , MEM_Real ) ; 
line 53428: if ( ( u . af . flags & MEM_Real ) == 0 ) { 
line 53429: sqlite3VdbeIntegerAffinity ( pOut ) ; 
line 53430: } 
line 53431: } 
line 53432: break ; 
line 53434: arithmetic_result_is_null : 
line 53435: sqlite3VdbeMemSetNull ( pOut ) ; 
line 53436: break ; 
line 53437: } 
line 53450: case OP_CollSeq : { 
line 53451: assert ( pOp -> p4type == P4_COLLSEQ ) ; 
line 53452: break ; 
line 53453: } 
line 53471: case OP_Function : { 
line 53472: # if 0 
line 53473: int i ; 
line 53474: Mem * pArg ; 
line 53475: sqlite3_context ctx ; 
line 53476: sqlite3_value * * apVal ; 
line 53477: int n ; 
line 53478: # endif 
line 53480: u . ag . n = pOp -> p5 ; 
line 53481: u . ag . apVal = p -> apArg ; 
line 53482: assert ( u . ag . apVal || u . ag . n == 0 ) ; 
line 53484: assert ( u . ag . n == 0 || ( pOp -> p2 > 0 && pOp -> p2 + u . ag . n <= p -> nMem + 1 ) ) ; 
line 53485: assert ( pOp -> p3 < pOp -> p2 || pOp -> p3 >= pOp -> p2 + u . ag . n ) ; 
line 53486: u . ag . pArg = & aMem [ pOp -> p2 ] ; 
line 53487: for ( u . ag . i = 0 ; u . ag . i < u . ag . n ; u . ag . i ++ , u . ag . pArg ++ ) { 
line 53488: u . ag . apVal [ u . ag . i ] = u . ag . pArg ; 
line 53489: sqlite3VdbeMemStoreType ( u . ag . pArg ) ; 
line 53490: REGISTER_TRACE ( pOp -> p2 , u . ag . pArg ) ; 
line 53491: } 
line 53493: assert ( pOp -> p4type == P4_FUNCDEF || pOp -> p4type == P4_VDBEFUNC ) ; 
line 53494: if ( pOp -> p4type == P4_FUNCDEF ) { 
line 53495: u . ag . ctx . pFunc = pOp -> p4 . pFunc ; 
line 53496: u . ag . ctx . pVdbeFunc = 0 ; 
line 53497: } else { 
line 53498: u . ag . ctx . pVdbeFunc = ( VdbeFunc * ) pOp -> p4 . pVdbeFunc ; 
line 53499: u . ag . ctx . pFunc = u . ag . ctx . pVdbeFunc -> pFunc ; 
line 53500: } 
line 53502: assert ( pOp -> p3 > 0 && pOp -> p3 <= p -> nMem ) ; 
line 53503: pOut = & aMem [ pOp -> p3 ] ; 
line 53504: u . ag . ctx . s . flags = MEM_Null ; 
line 53505: u . ag . ctx . s . db = db ; 
line 53506: u . ag . ctx . s . xDel = 0 ; 
line 53507: u . ag . ctx . s . zMalloc = 0 ; 
line 53513: sqlite3VdbeMemMove ( & u . ag . ctx . s , pOut ) ; 
line 53514: MemSetTypeFlag ( & u . ag . ctx . s , MEM_Null ) ; 
line 53516: u . ag . ctx . isError = 0 ; 
line 53517: if ( u . ag . ctx . pFunc -> flags & SQLITE_FUNC_NEEDCOLL ) { 
line 53518: assert ( pOp > aOp ) ; 
line 53519: assert ( pOp [ - 1 ] . p4type == P4_COLLSEQ ) ; 
line 53520: assert ( pOp [ - 1 ] . opcode == OP_CollSeq ) ; 
line 53521: u . ag . ctx . pColl = pOp [ - 1 ] . p4 . pColl ; 
line 53522: } 
line 53523: if ( sqlite3SafetyOff ( db ) ) goto abort_due_to_misuse ; 
line 53524: ( * u . ag . ctx . pFunc -> xFunc ) ( & u . ag . ctx , u . ag . n , u . ag . apVal ) ; 
line 53525: if ( sqlite3SafetyOn ( db ) ) { 
line 53526: sqlite3VdbeMemRelease ( & u . ag . ctx . s ) ; 
line 53527: goto abort_due_to_misuse ; 
line 53528: } 
line 53529: if ( db -> mallocFailed ) { 
line 53539: sqlite3VdbeMemRelease ( & u . ag . ctx . s ) ; 
line 53540: goto no_mem ; 
line 53541: } 
line 53546: if ( u . ag . ctx . pVdbeFunc ) { 
line 53547: sqlite3VdbeDeleteAuxData ( u . ag . ctx . pVdbeFunc , pOp -> p1 ) ; 
line 53548: pOp -> p4 . pVdbeFunc = u . ag . ctx . pVdbeFunc ; 
line 53549: pOp -> p4type = P4_VDBEFUNC ; 
line 53550: } 
line 53553: if ( u . ag . ctx . isError ) { 
line 53554: sqlite3SetString ( & p -> zErrMsg , db , "%s" , sqlite3_value_text ( & u . ag . ctx . s ) ) ; 
line 53555: rc = u . ag . ctx . isError ; 
line 53556: } 
line 53559: sqlite3VdbeChangeEncoding ( & u . ag . ctx . s , encoding ) ; 
line 53560: sqlite3VdbeMemMove ( pOut , & u . ag . ctx . s ) ; 
line 53561: if ( sqlite3VdbeMemTooBig ( pOut ) ) { 
line 53562: goto too_big ; 
line 53563: } 
line 53564: REGISTER_TRACE ( pOp -> p3 , pOut ) ; 
line 53565: UPDATE_MAX_BLOBSIZE ( pOut ) ; 
line 53566: break ; 
line 53567: } 
line 53595: case OP_BitAnd : 
line 53596: case OP_BitOr : 
line 53597: case OP_ShiftLeft : 
line 53598: case OP_ShiftRight : { 
line 53599: # if 0 
line 53600: i64 a ; 
line 53601: i64 b ; 
line 53602: # endif 
line 53604: pIn1 = & aMem [ pOp -> p1 ] ; 
line 53605: pIn2 = & aMem [ pOp -> p2 ] ; 
line 53606: pOut = & aMem [ pOp -> p3 ] ; 
line 53607: if ( ( pIn1 -> flags | pIn2 -> flags ) & MEM_Null ) { 
line 53608: sqlite3VdbeMemSetNull ( pOut ) ; 
line 53609: break ; 
line 53610: } 
line 53611: u . ah . a = sqlite3VdbeIntValue ( pIn2 ) ; 
line 53612: u . ah . b = sqlite3VdbeIntValue ( pIn1 ) ; 
line 53613: switch ( pOp -> opcode ) { 
line 53614: case OP_BitAnd : u . ah . a &= u . ah . b ; break ; 
line 53615: case OP_BitOr : u . ah . a |= u . ah . b ; break ; 
line 53616: case OP_ShiftLeft : u . ah . a <<= u . ah . b ; break ; 
line 53617: default : assert ( pOp -> opcode == OP_ShiftRight ) ; 
line 53618: u . ah . a >>= u . ah . b ; break ; 
line 53619: } 
line 53620: pOut -> u . i = u . ah . a ; 
line 53621: MemSetTypeFlag ( pOut , MEM_Int ) ; 
line 53622: break ; 
line 53623: } 
line 53632: case OP_AddImm : { 
line 53633: pIn1 = & aMem [ pOp -> p1 ] ; 
line 53634: sqlite3VdbeMemIntegerify ( pIn1 ) ; 
line 53635: pIn1 -> u . i += pOp -> p2 ; 
line 53636: break ; 
line 53637: } 
line 53646: case OP_MustBeInt : { 
line 53647: pIn1 = & aMem [ pOp -> p1 ] ; 
line 53648: applyAffinity ( pIn1 , SQLITE_AFF_NUMERIC , encoding ) ; 
line 53649: if ( ( pIn1 -> flags & MEM_Int ) == 0 ) { 
line 53650: if ( pOp -> p2 == 0 ) { 
line 53651: rc = SQLITE_MISMATCH ; 
line 53652: goto abort_due_to_error ; 
line 53653: } else { 
line 53654: pc = pOp -> p2 - 1 ; 
line 53655: } 
line 53656: } else { 
line 53657: MemSetTypeFlag ( pIn1 , MEM_Int ) ; 
line 53658: } 
line 53659: break ; 
line 53660: } 
line 53671: case OP_RealAffinity : { 
line 53672: pIn1 = & aMem [ pOp -> p1 ] ; 
line 53673: if ( pIn1 -> flags & MEM_Int ) { 
line 53674: sqlite3VdbeMemRealify ( pIn1 ) ; 
line 53675: } 
line 53676: break ; 
line 53677: } 
line 53679: # ifndef SQLITE_OMIT_CAST 
line 53689: case OP_ToText : { 
line 53690: pIn1 = & aMem [ pOp -> p1 ] ; 
line 53691: if ( pIn1 -> flags & MEM_Null ) break ; 
line 53692: assert ( MEM_Str == ( MEM_Blob >> 3 ) ) ; 
line 53693: pIn1 -> flags |= ( pIn1 -> flags & MEM_Blob ) >> 3 ; 
line 53694: applyAffinity ( pIn1 , SQLITE_AFF_TEXT , encoding ) ; 
line 53695: rc = ExpandBlob ( pIn1 ) ; 
line 53696: assert ( pIn1 -> flags & MEM_Str || db -> mallocFailed ) ; 
line 53697: pIn1 -> flags &= ~ ( MEM_Int | MEM_Real | MEM_Blob | MEM_Zero ) ; 
line 53698: UPDATE_MAX_BLOBSIZE ( pIn1 ) ; 
line 53699: break ; 
line 53700: } 
line 53711: case OP_ToBlob : { 
line 53712: pIn1 = & aMem [ pOp -> p1 ] ; 
line 53713: if ( pIn1 -> flags & MEM_Null ) break ; 
line 53714: if ( ( pIn1 -> flags & MEM_Blob ) == 0 ) { 
line 53715: applyAffinity ( pIn1 , SQLITE_AFF_TEXT , encoding ) ; 
line 53716: assert ( pIn1 -> flags & MEM_Str || db -> mallocFailed ) ; 
line 53717: MemSetTypeFlag ( pIn1 , MEM_Blob ) ; 
line 53718: } else { 
line 53719: pIn1 -> flags &= ~ ( MEM_TypeMask & ~ MEM_Blob ) ; 
line 53720: } 
line 53721: UPDATE_MAX_BLOBSIZE ( pIn1 ) ; 
line 53722: break ; 
line 53723: } 
line 53735: case OP_ToNumeric : { 
line 53736: pIn1 = & aMem [ pOp -> p1 ] ; 
line 53737: if ( ( pIn1 -> flags & ( MEM_Null | MEM_Int | MEM_Real ) ) == 0 ) { 
line 53738: sqlite3VdbeMemNumerify ( pIn1 ) ; 
line 53739: } 
line 53740: break ; 
line 53741: } 
line 53742: # endif 
line 53753: case OP_ToInt : { 
line 53754: pIn1 = & aMem [ pOp -> p1 ] ; 
line 53755: if ( ( pIn1 -> flags & MEM_Null ) == 0 ) { 
line 53756: sqlite3VdbeMemIntegerify ( pIn1 ) ; 
line 53757: } 
line 53758: break ; 
line 53759: } 
line 53761: # ifndef SQLITE_OMIT_CAST 
line 53771: case OP_ToReal : { 
line 53772: pIn1 = & aMem [ pOp -> p1 ] ; 
line 53773: if ( ( pIn1 -> flags & MEM_Null ) == 0 ) { 
line 53774: sqlite3VdbeMemRealify ( pIn1 ) ; 
line 53775: } 
line 53776: break ; 
line 53777: } 
line 53778: # endif 
line 53852: case OP_Eq : 
line 53853: case OP_Ne : 
line 53854: case OP_Lt : 
line 53855: case OP_Le : 
line 53856: case OP_Gt : 
line 53857: case OP_Ge : { 
line 53858: # if 0 
line 53859: int res ; 
line 53860: char affinity ; 
line 53861: # endif 
line 53863: pIn1 = & aMem [ pOp -> p1 ] ; 
line 53864: pIn3 = & aMem [ pOp -> p3 ] ; 
line 53865: if ( ( pIn1 -> flags | pIn3 -> flags ) & MEM_Null ) { 
line 53867: if ( pOp -> p5 & SQLITE_NULLEQ ) { 
line 53872: assert ( pOp -> opcode == OP_Eq || pOp -> opcode == OP_Ne ) ; 
line 53873: u . ai . res = ( pIn1 -> flags & pIn3 -> flags & MEM_Null ) == 0 ; 
line 53874: } else { 
line 53879: if ( pOp -> p5 & SQLITE_STOREP2 ) { 
line 53880: pOut = & aMem [ pOp -> p2 ] ; 
line 53881: MemSetTypeFlag ( pOut , MEM_Null ) ; 
line 53882: REGISTER_TRACE ( pOp -> p2 , pOut ) ; 
line 53883: } else if ( pOp -> p5 & SQLITE_JUMPIFNULL ) { 
line 53884: pc = pOp -> p2 - 1 ; 
line 53885: } 
line 53886: break ; 
line 53887: } 
line 53888: } else { 
line 53890: u . ai . affinity = pOp -> p5 & SQLITE_AFF_MASK ; 
line 53891: if ( u . ai . affinity ) { 
line 53892: applyAffinity ( pIn1 , u . ai . affinity , encoding ) ; 
line 53893: applyAffinity ( pIn3 , u . ai . affinity , encoding ) ; 
line 53894: if ( db -> mallocFailed ) goto no_mem ; 
line 53895: } 
line 53897: assert ( pOp -> p4type == P4_COLLSEQ || pOp -> p4 . pColl == 0 ) ; 
line 53898: ExpandBlob ( pIn1 ) ; 
line 53899: ExpandBlob ( pIn3 ) ; 
line 53900: u . ai . res = sqlite3MemCompare ( pIn3 , pIn1 , pOp -> p4 . pColl ) ; 
line 53901: } 
line 53902: switch ( pOp -> opcode ) { 
line 53903: case OP_Eq : u . ai . res = u . ai . res == 0 ; break ; 
line 53904: case OP_Ne : u . ai . res = u . ai . res != 0 ; break ; 
line 53905: case OP_Lt : u . ai . res = u . ai . res < 0 ; break ; 
line 53906: case OP_Le : u . ai . res = u . ai . res <= 0 ; break ; 
line 53907: case OP_Gt : u . ai . res = u . ai . res > 0 ; break ; 
line 53908: default : u . ai . res = u . ai . res >= 0 ; break ; 
line 53909: } 
line 53911: if ( pOp -> p5 & SQLITE_STOREP2 ) { 
line 53912: pOut = & aMem [ pOp -> p2 ] ; 
line 53913: MemSetTypeFlag ( pOut , MEM_Int ) ; 
line 53914: pOut -> u . i = u . ai . res ; 
line 53915: REGISTER_TRACE ( pOp -> p2 , pOut ) ; 
line 53916: } else if ( u . ai . res ) { 
line 53917: pc = pOp -> p2 - 1 ; 
line 53918: } 
line 53919: break ; 
line 53920: } 
line 53931: case OP_Permutation : { 
line 53932: assert ( pOp -> p4type == P4_INTARRAY ) ; 
line 53933: assert ( pOp -> p4 . ai ) ; 
line 53934: aPermute = pOp -> p4 . ai ; 
line 53935: break ; 
line 53936: } 
line 53952: case OP_Compare : { 
line 53953: # if 0 
line 53954: int n ; 
line 53955: int i ; 
line 53956: int p1 ; 
line 53957: int p2 ; 
line 53958: const KeyInfo * pKeyInfo ; 
line 53959: int idx ; 
line 53960: CollSeq * pColl ; 
line 53961: int bRev ; 
line 53962: # endif 
line 53964: u . aj . n = pOp -> p3 ; 
line 53965: u . aj . pKeyInfo = pOp -> p4 . pKeyInfo ; 
line 53966: assert ( u . aj . n > 0 ) ; 
line 53967: assert ( u . aj . pKeyInfo != 0 ) ; 
line 53968: u . aj . p1 = pOp -> p1 ; 
line 53969: u . aj . p2 = pOp -> p2 ; 
line 53970: # if SQLITE_DEBUG 
line 53971: if ( aPermute ) { 
line 53972: int k , mx = 0 ; 
line 53973: for ( k = 0 ; k < u . aj . n ; k ++ ) if ( aPermute [ k ] > mx ) mx = aPermute [ k ] ; 
line 53974: assert ( u . aj . p1 > 0 && u . aj . p1 + mx <= p -> nMem + 1 ) ; 
line 53975: assert ( u . aj . p2 > 0 && u . aj . p2 + mx <= p -> nMem + 1 ) ; 
line 53976: } else { 
line 53977: assert ( u . aj . p1 > 0 && u . aj . p1 + u . aj . n <= p -> nMem + 1 ) ; 
line 53978: assert ( u . aj . p2 > 0 && u . aj . p2 + u . aj . n <= p -> nMem + 1 ) ; 
line 53979: } 
line 53980: # endif 
line 53981: for ( u . aj . i = 0 ; u . aj . i < u . aj . n ; u . aj . i ++ ) { 
line 53982: u . aj . idx = aPermute ? aPermute [ u . aj . i ] : u . aj . i ; 
line 53983: REGISTER_TRACE ( u . aj . p1 + u . aj . idx , & aMem [ u . aj . p1 + u . aj . idx ] ) ; 
line 53984: REGISTER_TRACE ( u . aj . p2 + u . aj . idx , & aMem [ u . aj . p2 + u . aj . idx ] ) ; 
line 53985: assert ( u . aj . i < u . aj . pKeyInfo -> nField ) ; 
line 53986: u . aj . pColl = u . aj . pKeyInfo -> aColl [ u . aj . i ] ; 
line 53987: u . aj . bRev = u . aj . pKeyInfo -> aSortOrder [ u . aj . i ] ; 
line 53988: iCompare = sqlite3MemCompare ( & aMem [ u . aj . p1 + u . aj . idx ] , & aMem [ u . aj . p2 + u . aj . idx ] , u . aj . pColl ) ; 
line 53989: if ( iCompare ) { 
line 53990: if ( u . aj . bRev ) iCompare = - iCompare ; 
line 53991: break ; 
line 53992: } 
line 53993: } 
line 53994: aPermute = 0 ; 
line 53995: break ; 
line 53996: } 
line 54004: case OP_Jump : { 
line 54005: if ( iCompare < 0 ) { 
line 54006: pc = pOp -> p1 - 1 ; 
line 54007: } else if ( iCompare == 0 ) { 
line 54008: pc = pOp -> p2 - 1 ; 
line 54009: } else { 
line 54010: pc = pOp -> p3 - 1 ; 
line 54011: } 
line 54012: break ; 
line 54013: } 
line 54033: case OP_And : 
line 54034: case OP_Or : { 
line 54035: # if 0 
line 54036: int v1 ; 
line 54037: int v2 ; 
line 54038: # endif 
line 54040: pIn1 = & aMem [ pOp -> p1 ] ; 
line 54041: if ( pIn1 -> flags & MEM_Null ) { 
line 54042: u . ak . v1 = 2 ; 
line 54043: } else { 
line 54044: u . ak . v1 = sqlite3VdbeIntValue ( pIn1 ) != 0 ; 
line 54045: } 
line 54046: pIn2 = & aMem [ pOp -> p2 ] ; 
line 54047: if ( pIn2 -> flags & MEM_Null ) { 
line 54048: u . ak . v2 = 2 ; 
line 54049: } else { 
line 54050: u . ak . v2 = sqlite3VdbeIntValue ( pIn2 ) != 0 ; 
line 54051: } 
line 54052: if ( pOp -> opcode == OP_And ) { 
line 54053: static const unsigned char and_logic [ ] = { 0 , 0 , 0 , 0 , 1 , 2 , 0 , 2 , 2 } ; 
line 54054: u . ak . v1 = and_logic [ u . ak . v1 * 3 + u . ak . v2 ] ; 
line 54055: } else { 
line 54056: static const unsigned char or_logic [ ] = { 0 , 1 , 2 , 1 , 1 , 1 , 2 , 1 , 2 } ; 
line 54057: u . ak . v1 = or_logic [ u . ak . v1 * 3 + u . ak . v2 ] ; 
line 54058: } 
line 54059: pOut = & aMem [ pOp -> p3 ] ; 
line 54060: if ( u . ak . v1 == 2 ) { 
line 54061: MemSetTypeFlag ( pOut , MEM_Null ) ; 
line 54062: } else { 
line 54063: pOut -> u . i = u . ak . v1 ; 
line 54064: MemSetTypeFlag ( pOut , MEM_Int ) ; 
line 54065: } 
line 54066: break ; 
line 54067: } 
line 54075: case OP_Not : { 
line 54076: pIn1 = & aMem [ pOp -> p1 ] ; 
line 54077: pOut = & aMem [ pOp -> p2 ] ; 
line 54078: if ( pIn1 -> flags & MEM_Null ) { 
line 54079: sqlite3VdbeMemSetNull ( pOut ) ; 
line 54080: } else { 
line 54081: sqlite3VdbeMemSetInt64 ( pOut , ! sqlite3VdbeIntValue ( pIn1 ) ) ; 
line 54082: } 
line 54083: break ; 
line 54084: } 
line 54092: case OP_BitNot : { 
line 54093: pIn1 = & aMem [ pOp -> p1 ] ; 
line 54094: pOut = & aMem [ pOp -> p2 ] ; 
line 54095: if ( pIn1 -> flags & MEM_Null ) { 
line 54096: sqlite3VdbeMemSetNull ( pOut ) ; 
line 54097: } else { 
line 54098: sqlite3VdbeMemSetInt64 ( pOut , ~ sqlite3VdbeIntValue ( pIn1 ) ) ; 
line 54099: } 
line 54100: break ; 
line 54101: } 
line 54115: case OP_If : 
line 54116: case OP_IfNot : { 
line 54117: # if 0 
line 54118: int c ; 
line 54119: # endif 
line 54120: pIn1 = & aMem [ pOp -> p1 ] ; 
line 54121: if ( pIn1 -> flags & MEM_Null ) { 
line 54122: u . al . c = pOp -> p3 ; 
line 54123: } else { 
line 54124: # ifdef SQLITE_OMIT_FLOATING_POINT 
line 54125: u . al . c = sqlite3VdbeIntValue ( pIn1 ) != 0 ; 
line 54126: # else 
line 54127: u . al . c = sqlite3VdbeRealValue ( pIn1 ) != 0.0 ; 
line 54128: # endif 
line 54129: if ( pOp -> opcode == OP_IfNot ) u . al . c = ! u . al . c ; 
line 54130: } 
line 54131: if ( u . al . c ) { 
line 54132: pc = pOp -> p2 - 1 ; 
line 54133: } 
line 54134: break ; 
line 54135: } 
line 54141: case OP_IsNull : { 
line 54142: pIn1 = & aMem [ pOp -> p1 ] ; 
line 54143: if ( ( pIn1 -> flags & MEM_Null ) != 0 ) { 
line 54144: pc = pOp -> p2 - 1 ; 
line 54145: } 
line 54146: break ; 
line 54147: } 
line 54153: case OP_NotNull : { 
line 54154: pIn1 = & aMem [ pOp -> p1 ] ; 
line 54155: if ( ( pIn1 -> flags & MEM_Null ) == 0 ) { 
line 54156: pc = pOp -> p2 - 1 ; 
line 54157: } 
line 54158: break ; 
line 54159: } 
line 54180: case OP_Column : { 
line 54181: # if 0 
line 54182: u32 payloadSize ; 
line 54183: i64 payloadSize64 ; 
line 54184: int p1 ; 
line 54185: int p2 ; 
line 54186: VdbeCursor * pC ; 
line 54187: char * zRec ; 
line 54188: BtCursor * pCrsr ; 
line 54189: u32 * aType ; 
line 54190: u32 * aOffset ; 
line 54191: int nField ; 
line 54192: int len ; 
line 54193: int i ; 
line 54194: char * zData ; 
line 54195: Mem * pDest ; 
line 54196: Mem sMem ; 
line 54197: u8 * zIdx ; 
line 54198: u8 * zEndHdr ; 
line 54199: u32 offset ; 
line 54200: u64 offset64 ; 
line 54201: int szHdr ; 
line 54202: int avail ; 
line 54203: Mem * pReg ; 
line 54204: # endif 
line 54207: u . am . p1 = pOp -> p1 ; 
line 54208: u . am . p2 = pOp -> p2 ; 
line 54209: u . am . pC = 0 ; 
line 54210: memset ( & u . am . sMem , 0 , sizeof ( u . am . sMem ) ) ; 
line 54211: assert ( u . am . p1 < p -> nCursor ) ; 
line 54212: assert ( pOp -> p3 > 0 && pOp -> p3 <= p -> nMem ) ; 
line 54213: u . am . pDest = & aMem [ pOp -> p3 ] ; 
line 54214: MemSetTypeFlag ( u . am . pDest , MEM_Null ) ; 
line 54215: u . am . zRec = 0 ; 
line 54229: u . am . pC = p -> apCsr [ u . am . p1 ] ; 
line 54230: assert ( u . am . pC != 0 ) ; 
line 54231: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 54232: assert ( u . am . pC -> pVtabCursor == 0 ) ; 
line 54233: # endif 
line 54234: u . am . pCrsr = u . am . pC -> pCursor ; 
line 54235: if ( u . am . pCrsr != 0 ) { 
line 54237: rc = sqlite3VdbeCursorMoveto ( u . am . pC ) ; 
line 54238: if ( rc ) goto abort_due_to_error ; 
line 54239: if ( u . am . pC -> nullRow ) { 
line 54240: u . am . payloadSize = 0 ; 
line 54241: } else if ( u . am . pC -> cacheStatus == p -> cacheCtr ) { 
line 54242: u . am . payloadSize = u . am . pC -> payloadSize ; 
line 54243: u . am . zRec = ( char * ) u . am . pC -> aRow ; 
line 54244: } else if ( u . am . pC -> isIndex ) { 
line 54245: assert ( sqlite3BtreeCursorIsValid ( u . am . pCrsr ) ) ; 
line 54246: rc = sqlite3BtreeKeySize ( u . am . pCrsr , & u . am . payloadSize64 ) ; 
line 54247: assert ( rc == SQLITE_OK ) ; 
line 54251: assert ( ( u . am . payloadSize64 & SQLITE_MAX_U32 ) == ( u64 ) u . am . payloadSize64 ) ; 
line 54252: u . am . payloadSize = ( u32 ) u . am . payloadSize64 ; 
line 54253: } else { 
line 54254: assert ( sqlite3BtreeCursorIsValid ( u . am . pCrsr ) ) ; 
line 54255: rc = sqlite3BtreeDataSize ( u . am . pCrsr , & u . am . payloadSize ) ; 
line 54256: assert ( rc == SQLITE_OK ) ; 
line 54257: } 
line 54258: } else if ( u . am . pC -> pseudoTableReg > 0 ) { 
line 54259: u . am . pReg = & aMem [ u . am . pC -> pseudoTableReg ] ; 
line 54260: assert ( u . am . pReg -> flags & MEM_Blob ) ; 
line 54261: u . am . payloadSize = u . am . pReg -> n ; 
line 54262: u . am . zRec = u . am . pReg -> z ; 
line 54263: u . am . pC -> cacheStatus = ( pOp -> p5 & OPFLAG_CLEARCACHE ) ? CACHE_STALE : p -> cacheCtr ; 
line 54264: assert ( u . am . payloadSize == 0 || u . am . zRec != 0 ) ; 
line 54265: } else { 
line 54267: u . am . payloadSize = 0 ; 
line 54268: } 
line 54271: if ( u . am . payloadSize == 0 ) { 
line 54272: assert ( u . am . pDest -> flags & MEM_Null ) ; 
line 54273: goto op_column_out ; 
line 54274: } 
line 54275: assert ( db -> aLimit [ SQLITE_LIMIT_LENGTH ] >= 0 ) ; 
line 54276: if ( u . am . payloadSize > ( u32 ) db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) { 
line 54277: goto too_big ; 
line 54278: } 
line 54280: u . am . nField = u . am . pC -> nField ; 
line 54281: assert ( u . am . p2 < u . am . nField ) ; 
line 54286: u . am . aType = u . am . pC -> aType ; 
line 54287: if ( u . am . pC -> cacheStatus == p -> cacheCtr ) { 
line 54288: u . am . aOffset = u . am . pC -> aOffset ; 
line 54289: } else { 
line 54290: assert ( u . am . aType ) ; 
line 54291: u . am . avail = 0 ; 
line 54292: u . am . pC -> aOffset = u . am . aOffset = & u . am . aType [ u . am . nField ] ; 
line 54293: u . am . pC -> payloadSize = u . am . payloadSize ; 
line 54294: u . am . pC -> cacheStatus = p -> cacheCtr ; 
line 54297: if ( u . am . zRec ) { 
line 54298: u . am . zData = u . am . zRec ; 
line 54299: } else { 
line 54300: if ( u . am . pC -> isIndex ) { 
line 54301: u . am . zData = ( char * ) sqlite3BtreeKeyFetch ( u . am . pCrsr , & u . am . avail ) ; 
line 54302: } else { 
line 54303: u . am . zData = ( char * ) sqlite3BtreeDataFetch ( u . am . pCrsr , & u . am . avail ) ; 
line 54304: } 
line 54310: assert ( u . am . avail >= 0 ) ; 
line 54311: if ( u . am . payloadSize <= ( u32 ) u . am . avail ) { 
line 54312: u . am . zRec = u . am . zData ; 
line 54313: u . am . pC -> aRow = ( u8 * ) u . am . zData ; 
line 54314: } else { 
line 54315: u . am . pC -> aRow = 0 ; 
line 54316: } 
line 54317: } 
line 54321: u . am . szHdr = getVarint32 ( ( u8 * ) u . am . zData , u . am . offset ) ; 
line 54332: if ( u . am . offset > 98307 ) { 
line 54333: rc = SQLITE_CORRUPT_BKPT ; 
line 54334: goto op_column_out ; 
line 54335: } 
line 54350: u . am . len = u . am . nField * 5 + 3 ; 
line 54351: if ( u . am . len > ( int ) u . am . offset ) u . am . len = ( int ) u . am . offset ; 
line 54359: if ( ! u . am . zRec && u . am . avail < u . am . len ) { 
line 54360: u . am . sMem . flags = 0 ; 
line 54361: u . am . sMem . db = 0 ; 
line 54362: rc = sqlite3VdbeMemFromBtree ( u . am . pCrsr , 0 , u . am . len , u . am . pC -> isIndex , & u . am . sMem ) ; 
line 54363: if ( rc != SQLITE_OK ) { 
line 54364: goto op_column_out ; 
line 54365: } 
line 54366: u . am . zData = u . am . sMem . z ; 
line 54367: } 
line 54368: u . am . zEndHdr = ( u8 * ) & u . am . zData [ u . am . len ] ; 
line 54369: u . am . zIdx = ( u8 * ) & u . am . zData [ u . am . szHdr ] ; 
line 54376: u . am . offset64 = u . am . offset ; 
line 54377: for ( u . am . i = 0 ; u . am . i < u . am . nField ; u . am . i ++ ) { 
line 54378: if ( u . am . zIdx < u . am . zEndHdr ) { 
line 54379: u . am . aOffset [ u . am . i ] = ( u32 ) u . am . offset64 ; 
line 54380: u . am . zIdx += getVarint32 ( u . am . zIdx , u . am . aType [ u . am . i ] ) ; 
line 54381: u . am . offset64 += sqlite3VdbeSerialTypeLen ( u . am . aType [ u . am . i ] ) ; 
line 54382: } else { 
line 54389: u . am . aOffset [ u . am . i ] = 0 ; 
line 54390: } 
line 54391: } 
line 54392: sqlite3VdbeMemRelease ( & u . am . sMem ) ; 
line 54393: u . am . sMem . flags = MEM_Null ; 
line 54401: if ( ( u . am . zIdx > u . am . zEndHdr ) || ( u . am . offset64 > u . am . payloadSize ) 
line 54402: || ( u . am . zIdx == u . am . zEndHdr && u . am . offset64 != ( u64 ) u . am . payloadSize ) ) { 
line 54403: rc = SQLITE_CORRUPT_BKPT ; 
line 54404: goto op_column_out ; 
line 54405: } 
line 54406: } 
line 54414: if ( u . am . aOffset [ u . am . p2 ] ) { 
line 54415: assert ( rc == SQLITE_OK ) ; 
line 54416: if ( u . am . zRec ) { 
line 54417: sqlite3VdbeMemReleaseExternal ( u . am . pDest ) ; 
line 54418: sqlite3VdbeSerialGet ( ( u8 * ) & u . am . zRec [ u . am . aOffset [ u . am . p2 ] ] , u . am . aType [ u . am . p2 ] , u . am . pDest ) ; 
line 54419: } else { 
line 54420: u . am . len = sqlite3VdbeSerialTypeLen ( u . am . aType [ u . am . p2 ] ) ; 
line 54421: sqlite3VdbeMemMove ( & u . am . sMem , u . am . pDest ) ; 
line 54422: rc = sqlite3VdbeMemFromBtree ( u . am . pCrsr , u . am . aOffset [ u . am . p2 ] , u . am . len , u . am . pC -> isIndex , & u . am . sMem ) ; 
line 54423: if ( rc != SQLITE_OK ) { 
line 54424: goto op_column_out ; 
line 54425: } 
line 54426: u . am . zData = u . am . sMem . z ; 
line 54427: sqlite3VdbeSerialGet ( ( u8 * ) u . am . zData , u . am . aType [ u . am . p2 ] , u . am . pDest ) ; 
line 54428: } 
line 54429: u . am . pDest -> enc = encoding ; 
line 54430: } else { 
line 54431: if ( pOp -> p4type == P4_MEM ) { 
line 54432: sqlite3VdbeMemShallowCopy ( u . am . pDest , pOp -> p4 . pMem , MEM_Static ) ; 
line 54433: } else { 
line 54434: assert ( u . am . pDest -> flags & MEM_Null ) ; 
line 54435: } 
line 54436: } 
line 54443: if ( u . am . sMem . zMalloc ) { 
line 54444: assert ( u . am . sMem . z == u . am . sMem . zMalloc ) ; 
line 54445: assert ( ! ( u . am . pDest -> flags & MEM_Dyn ) ) ; 
line 54446: assert ( ! ( u . am . pDest -> flags & ( MEM_Blob | MEM_Str ) ) || u . am . pDest -> z == u . am . sMem . z ) ; 
line 54447: u . am . pDest -> flags &= ~ ( MEM_Ephem | MEM_Static ) ; 
line 54448: u . am . pDest -> flags |= MEM_Term ; 
line 54449: u . am . pDest -> z = u . am . sMem . z ; 
line 54450: u . am . pDest -> zMalloc = u . am . sMem . zMalloc ; 
line 54451: } 
line 54453: rc = sqlite3VdbeMemMakeWriteable ( u . am . pDest ) ; 
line 54455: op_column_out : 
line 54456: UPDATE_MAX_BLOBSIZE ( u . am . pDest ) ; 
line 54457: REGISTER_TRACE ( pOp -> p3 , u . am . pDest ) ; 
line 54458: break ; 
line 54459: } 
line 54469: case OP_Affinity : { 
line 54470: # if 0 
line 54471: const char * zAffinity ; 
line 54472: char cAff ; 
line 54473: # endif 
line 54475: u . an . zAffinity = pOp -> p4 . z ; 
line 54476: assert ( u . an . zAffinity != 0 ) ; 
line 54477: assert ( u . an . zAffinity [ pOp -> p2 ] == 0 ) ; 
line 54478: pIn1 = & aMem [ pOp -> p1 ] ; 
line 54479: while ( ( u . an . cAff = * ( u . an . zAffinity ++ ) ) != 0 ) { 
line 54480: assert ( pIn1 <= & p -> aMem [ p -> nMem ] ) ; 
line 54481: ExpandBlob ( pIn1 ) ; 
line 54482: applyAffinity ( pIn1 , u . an . cAff , encoding ) ; 
line 54483: pIn1 ++ ; 
line 54484: } 
line 54485: break ; 
line 54486: } 
line 54506: case OP_MakeRecord : { 
line 54507: # if 0 
line 54508: u8 * zNewRecord ; 
line 54509: Mem * pRec ; 
line 54510: u64 nData ; 
line 54511: int nHdr ; 
line 54512: i64 nByte ; 
line 54513: int nZero ; 
line 54514: int nVarint ; 
line 54515: u32 serial_type ; 
line 54516: Mem * pData0 ; 
line 54517: Mem * pLast ; 
line 54518: int nField ; 
line 54519: char * zAffinity ; 
line 54520: int file_format ; 
line 54521: int i ; 
line 54522: int len ; 
line 54523: # endif 
line 54540: u . ao . nData = 0 ; 
line 54541: u . ao . nHdr = 0 ; 
line 54542: u . ao . nByte = 0 ; 
line 54543: u . ao . nZero = 0 ; 
line 54544: u . ao . nField = pOp -> p1 ; 
line 54545: u . ao . zAffinity = pOp -> p4 . z ; 
line 54546: assert ( u . ao . nField > 0 && pOp -> p2 > 0 && pOp -> p2 + u . ao . nField <= p -> nMem + 1 ) ; 
line 54547: u . ao . pData0 = & aMem [ u . ao . nField ] ; 
line 54548: u . ao . nField = pOp -> p2 ; 
line 54549: u . ao . pLast = & u . ao . pData0 [ u . ao . nField - 1 ] ; 
line 54550: u . ao . file_format = p -> minWriteFileFormat ; 
line 54555: for ( u . ao . pRec = u . ao . pData0 ; u . ao . pRec <= u . ao . pLast ; u . ao . pRec ++ ) { 
line 54556: if ( u . ao . zAffinity ) { 
line 54557: applyAffinity ( u . ao . pRec , u . ao . zAffinity [ u . ao . pRec - u . ao . pData0 ] , encoding ) ; 
line 54558: } 
line 54559: if ( u . ao . pRec -> flags & MEM_Zero && u . ao . pRec -> n > 0 ) { 
line 54560: sqlite3VdbeMemExpandBlob ( u . ao . pRec ) ; 
line 54561: } 
line 54562: u . ao . serial_type = sqlite3VdbeSerialType ( u . ao . pRec , u . ao . file_format ) ; 
line 54563: u . ao . len = sqlite3VdbeSerialTypeLen ( u . ao . serial_type ) ; 
line 54564: u . ao . nData += u . ao . len ; 
line 54565: u . ao . nHdr += sqlite3VarintLen ( u . ao . serial_type ) ; 
line 54566: if ( u . ao . pRec -> flags & MEM_Zero ) { 
line 54569: u . ao . nZero += u . ao . pRec -> u . nZero ; 
line 54570: } else if ( u . ao . len ) { 
line 54571: u . ao . nZero = 0 ; 
line 54572: } 
line 54573: } 
line 54576: u . ao . nHdr += u . ao . nVarint = sqlite3VarintLen ( u . ao . nHdr ) ; 
line 54577: if ( u . ao . nVarint < sqlite3VarintLen ( u . ao . nHdr ) ) { 
line 54578: u . ao . nHdr ++ ; 
line 54579: } 
line 54580: u . ao . nByte = u . ao . nHdr + u . ao . nData - u . ao . nZero ; 
line 54581: if ( u . ao . nByte > db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) { 
line 54582: goto too_big ; 
line 54583: } 
line 54590: assert ( pOp -> p3 < pOp -> p1 || pOp -> p3 >= pOp -> p1 + pOp -> p2 ) ; 
line 54591: pOut = & aMem [ pOp -> p3 ] ; 
line 54592: if ( sqlite3VdbeMemGrow ( pOut , ( int ) u . ao . nByte , 0 ) ) { 
line 54593: goto no_mem ; 
line 54594: } 
line 54595: u . ao . zNewRecord = ( u8 * ) pOut -> z ; 
line 54598: u . ao . i = putVarint32 ( u . ao . zNewRecord , u . ao . nHdr ) ; 
line 54599: for ( u . ao . pRec = u . ao . pData0 ; u . ao . pRec <= u . ao . pLast ; u . ao . pRec ++ ) { 
line 54600: u . ao . serial_type = sqlite3VdbeSerialType ( u . ao . pRec , u . ao . file_format ) ; 
line 54601: u . ao . i += putVarint32 ( & u . ao . zNewRecord [ u . ao . i ] , u . ao . serial_type ) ; 
line 54602: } 
line 54603: for ( u . ao . pRec = u . ao . pData0 ; u . ao . pRec <= u . ao . pLast ; u . ao . pRec ++ ) { 
line 54604: u . ao . i += sqlite3VdbeSerialPut ( & u . ao . zNewRecord [ u . ao . i ] , ( int ) ( u . ao . nByte - u . ao . i ) , u . ao . pRec , u . ao . file_format ) ; 
line 54605: } 
line 54606: assert ( u . ao . i == u . ao . nByte ) ; 
line 54608: assert ( pOp -> p3 > 0 && pOp -> p3 <= p -> nMem ) ; 
line 54609: pOut -> n = ( int ) u . ao . nByte ; 
line 54610: pOut -> flags = MEM_Blob | MEM_Dyn ; 
line 54611: pOut -> xDel = 0 ; 
line 54612: if ( u . ao . nZero ) { 
line 54613: pOut -> u . nZero = u . ao . nZero ; 
line 54614: pOut -> flags |= MEM_Zero ; 
line 54615: } 
line 54616: pOut -> enc = SQLITE_UTF8 ; 
line 54617: REGISTER_TRACE ( pOp -> p3 , pOut ) ; 
line 54618: UPDATE_MAX_BLOBSIZE ( pOut ) ; 
line 54619: break ; 
line 54620: } 
line 54627: # ifndef SQLITE_OMIT_BTREECOUNT 
line 54628: case OP_Count : { 
line 54629: # if 0 
line 54630: i64 nEntry ; 
line 54631: BtCursor * pCrsr ; 
line 54632: # endif 
line 54634: u . ap . pCrsr = p -> apCsr [ pOp -> p1 ] -> pCursor ; 
line 54635: if ( u . ap . pCrsr ) { 
line 54636: rc = sqlite3BtreeCount ( u . ap . pCrsr , & u . ap . nEntry ) ; 
line 54637: } else { 
line 54638: u . ap . nEntry = 0 ; 
line 54639: } 
line 54640: pOut -> u . i = u . ap . nEntry ; 
line 54641: break ; 
line 54642: } 
line 54643: # endif 
line 54651: case OP_Savepoint : { 
line 54652: # if 0 
line 54653: int p1 ; 
line 54654: char * zName ; 
line 54655: int nName ; 
line 54656: Savepoint * pNew ; 
line 54657: Savepoint * pSavepoint ; 
line 54658: Savepoint * pTmp ; 
line 54659: int iSavepoint ; 
line 54660: int ii ; 
line 54661: # endif 
line 54663: u . aq . p1 = pOp -> p1 ; 
line 54664: u . aq . zName = pOp -> p4 . z ; 
line 54669: assert ( db -> pSavepoint == 0 || db -> autoCommit == 0 ) ; 
line 54670: assert ( u . aq . p1 == SAVEPOINT_BEGIN || u . aq . p1 == SAVEPOINT_RELEASE || u . aq . p1 == SAVEPOINT_ROLLBACK ) ; 
line 54671: assert ( db -> pSavepoint || db -> isTransactionSavepoint == 0 ) ; 
line 54672: assert ( checkSavepointCount ( db ) ) ; 
line 54674: if ( u . aq . p1 == SAVEPOINT_BEGIN ) { 
line 54675: if ( db -> writeVdbeCnt > 0 ) { 
line 54679: sqlite3SetString ( & p -> zErrMsg , db , "cannot open savepoint - " 
line 54680: "SQL statements in progress" ) ; 
line 54681: rc = SQLITE_BUSY ; 
line 54682: } else { 
line 54683: u . aq . nName = sqlite3Strlen30 ( u . aq . zName ) ; 
line 54686: u . aq . pNew = sqlite3DbMallocRaw ( db , sizeof ( Savepoint ) + u . aq . nName + 1 ) ; 
line 54687: if ( u . aq . pNew ) { 
line 54688: u . aq . pNew -> zName = ( char * ) & u . aq . pNew [ 1 ] ; 
line 54689: memcpy ( u . aq . pNew -> zName , u . aq . zName , u . aq . nName + 1 ) ; 
line 54693: if ( db -> autoCommit ) { 
line 54694: db -> autoCommit = 0 ; 
line 54695: db -> isTransactionSavepoint = 1 ; 
line 54696: } else { 
line 54697: db -> nSavepoint ++ ; 
line 54698: } 
line 54701: u . aq . pNew -> pNext = db -> pSavepoint ; 
line 54702: db -> pSavepoint = u . aq . pNew ; 
line 54703: u . aq . pNew -> nDeferredCons = db -> nDeferredCons ; 
line 54704: } 
line 54705: } 
line 54706: } else { 
line 54707: u . aq . iSavepoint = 0 ; 
line 54711: for ( 
line 54712: u . aq . pSavepoint = db -> pSavepoint ; 
line 54713: u . aq . pSavepoint && sqlite3StrICmp ( u . aq . pSavepoint -> zName , u . aq . zName ) ; 
line 54714: u . aq . pSavepoint = u . aq . pSavepoint -> pNext 
line 54715: ) { 
line 54716: u . aq . iSavepoint ++ ; 
line 54717: } 
line 54718: if ( ! u . aq . pSavepoint ) { 
line 54719: sqlite3SetString ( & p -> zErrMsg , db , "no such savepoint: %s" , u . aq . zName ) ; 
line 54720: rc = SQLITE_ERROR ; 
line 54721: } else if ( 
line 54722: db -> writeVdbeCnt > 0 || ( u . aq . p1 == SAVEPOINT_ROLLBACK && db -> activeVdbeCnt > 1 ) 
line 54723: ) { 
line 54728: sqlite3SetString ( & p -> zErrMsg , db , 
line 54729: "cannot %s savepoint - SQL statements in progress" , 
line 54730: ( u . aq . p1 == SAVEPOINT_ROLLBACK ? "rollback" : "release" ) 
line 54731: ) ; 
line 54732: rc = SQLITE_BUSY ; 
line 54733: } else { 
line 54739: int isTransaction = u . aq . pSavepoint -> pNext == 0 && db -> isTransactionSavepoint ; 
line 54740: if ( isTransaction && u . aq . p1 == SAVEPOINT_RELEASE ) { 
line 54741: if ( ( rc = sqlite3VdbeCheckFk ( p , 1 ) ) != SQLITE_OK ) { 
line 54742: goto vdbe_return ; 
line 54743: } 
line 54744: db -> autoCommit = 1 ; 
line 54745: if ( sqlite3VdbeHalt ( p ) == SQLITE_BUSY ) { 
line 54746: p -> pc = pc ; 
line 54747: db -> autoCommit = 0 ; 
line 54748: p -> rc = rc = SQLITE_BUSY ; 
line 54749: goto vdbe_return ; 
line 54750: } 
line 54751: db -> isTransactionSavepoint = 0 ; 
line 54752: rc = p -> rc ; 
line 54753: } else { 
line 54754: u . aq . iSavepoint = db -> nSavepoint - u . aq . iSavepoint - 1 ; 
line 54755: for ( u . aq . ii = 0 ; u . aq . ii < db -> nDb ; u . aq . ii ++ ) { 
line 54756: rc = sqlite3BtreeSavepoint ( db -> aDb [ u . aq . ii ] . pBt , u . aq . p1 , u . aq . iSavepoint ) ; 
line 54757: if ( rc != SQLITE_OK ) { 
line 54758: goto abort_due_to_error ; 
line 54759: } 
line 54760: } 
line 54761: if ( u . aq . p1 == SAVEPOINT_ROLLBACK && ( db -> flags & SQLITE_InternChanges ) != 0 ) { 
line 54762: sqlite3ExpirePreparedStatements ( db ) ; 
line 54763: sqlite3ResetInternalSchema ( db , 0 ) ; 
line 54764: } 
line 54765: } 
line 54769: while ( db -> pSavepoint != u . aq . pSavepoint ) { 
line 54770: u . aq . pTmp = db -> pSavepoint ; 
line 54771: db -> pSavepoint = u . aq . pTmp -> pNext ; 
line 54772: sqlite3DbFree ( db , u . aq . pTmp ) ; 
line 54773: db -> nSavepoint -- ; 
line 54774: } 
line 54780: if ( u . aq . p1 == SAVEPOINT_RELEASE ) { 
line 54781: assert ( u . aq . pSavepoint == db -> pSavepoint ) ; 
line 54782: db -> pSavepoint = u . aq . pSavepoint -> pNext ; 
line 54783: sqlite3DbFree ( db , u . aq . pSavepoint ) ; 
line 54784: if ( ! isTransaction ) { 
line 54785: db -> nSavepoint -- ; 
line 54786: } 
line 54787: } else { 
line 54788: db -> nDeferredCons = u . aq . pSavepoint -> nDeferredCons ; 
line 54789: } 
line 54790: } 
line 54791: } 
line 54793: break ; 
line 54794: } 
line 54805: case OP_AutoCommit : { 
line 54806: # if 0 
line 54807: int desiredAutoCommit ; 
line 54808: int iRollback ; 
line 54809: int turnOnAC ; 
line 54810: # endif 
line 54812: u . ar . desiredAutoCommit = pOp -> p1 ; 
line 54813: u . ar . iRollback = pOp -> p2 ; 
line 54814: u . ar . turnOnAC = u . ar . desiredAutoCommit && ! db -> autoCommit ; 
line 54815: assert ( u . ar . desiredAutoCommit == 1 || u . ar . desiredAutoCommit == 0 ) ; 
line 54816: assert ( u . ar . desiredAutoCommit == 1 || u . ar . iRollback == 0 ) ; 
line 54817: assert ( db -> activeVdbeCnt > 0 ) ; 
line 54819: if ( u . ar . turnOnAC && u . ar . iRollback && db -> activeVdbeCnt > 1 ) { 
line 54824: sqlite3SetString ( & p -> zErrMsg , db , "cannot rollback transaction - " 
line 54825: "SQL statements in progress" ) ; 
line 54826: rc = SQLITE_BUSY ; 
line 54827: } else if ( u . ar . turnOnAC && ! u . ar . iRollback && db -> writeVdbeCnt > 0 ) { 
line 54831: sqlite3SetString ( & p -> zErrMsg , db , "cannot commit transaction - " 
line 54832: "SQL statements in progress" ) ; 
line 54833: rc = SQLITE_BUSY ; 
line 54834: } else if ( u . ar . desiredAutoCommit != db -> autoCommit ) { 
line 54835: if ( u . ar . iRollback ) { 
line 54836: assert ( u . ar . desiredAutoCommit == 1 ) ; 
line 54837: sqlite3RollbackAll ( db ) ; 
line 54838: db -> autoCommit = 1 ; 
line 54839: } else if ( ( rc = sqlite3VdbeCheckFk ( p , 1 ) ) != SQLITE_OK ) { 
line 54840: goto vdbe_return ; 
line 54841: } else { 
line 54842: db -> autoCommit = ( u8 ) u . ar . desiredAutoCommit ; 
line 54843: if ( sqlite3VdbeHalt ( p ) == SQLITE_BUSY ) { 
line 54844: p -> pc = pc ; 
line 54845: db -> autoCommit = ( u8 ) ( 1 - u . ar . desiredAutoCommit ) ; 
line 54846: p -> rc = rc = SQLITE_BUSY ; 
line 54847: goto vdbe_return ; 
line 54848: } 
line 54849: } 
line 54850: assert ( db -> nStatement == 0 ) ; 
line 54851: sqlite3CloseSavepoints ( db ) ; 
line 54852: if ( p -> rc == SQLITE_OK ) { 
line 54853: rc = SQLITE_DONE ; 
line 54854: } else { 
line 54855: rc = SQLITE_ERROR ; 
line 54856: } 
line 54857: goto vdbe_return ; 
line 54858: } else { 
line 54859: sqlite3SetString ( & p -> zErrMsg , db , 
line 54860: ( ! u . ar . desiredAutoCommit ) ? "cannot start a transaction within a transaction" : ( 
line 54861: ( u . ar . iRollback ) ? "cannot rollback - no transaction is active" : 
line 54862: "cannot commit - no transaction is active" ) ) ; 
line 54864: rc = SQLITE_ERROR ; 
line 54865: } 
line 54866: break ; 
line 54867: } 
line 54900: case OP_Transaction : { 
line 54901: # if 0 
line 54902: Btree * pBt ; 
line 54903: # endif 
line 54905: assert ( pOp -> p1 >= 0 && pOp -> p1 < db -> nDb ) ; 
line 54906: assert ( ( p -> btreeMask & ( 1 << pOp -> p1 ) ) != 0 ) ; 
line 54907: u . as . pBt = db -> aDb [ pOp -> p1 ] . pBt ; 
line 54909: if ( u . as . pBt ) { 
line 54910: rc = sqlite3BtreeBeginTrans ( u . as . pBt , pOp -> p2 ) ; 
line 54911: if ( rc == SQLITE_BUSY ) { 
line 54912: p -> pc = pc ; 
line 54913: p -> rc = rc = SQLITE_BUSY ; 
line 54914: goto vdbe_return ; 
line 54915: } 
line 54916: if ( rc != SQLITE_OK ) { 
line 54917: goto abort_due_to_error ; 
line 54918: } 
line 54920: if ( pOp -> p2 && p -> usesStmtJournal 
line 54921: && ( db -> autoCommit == 0 || db -> activeVdbeCnt > 1 ) 
line 54922: ) { 
line 54923: assert ( sqlite3BtreeIsInTrans ( u . as . pBt ) ) ; 
line 54924: if ( p -> iStatement == 0 ) { 
line 54925: assert ( db -> nStatement >= 0 && db -> nSavepoint >= 0 ) ; 
line 54926: db -> nStatement ++ ; 
line 54927: p -> iStatement = db -> nSavepoint + db -> nStatement ; 
line 54928: } 
line 54929: rc = sqlite3BtreeBeginStmt ( u . as . pBt , p -> iStatement ) ; 
line 54934: p -> nStmtDefCons = db -> nDeferredCons ; 
line 54935: } 
line 54936: } 
line 54937: break ; 
line 54938: } 
line 54952: case OP_ReadCookie : { 
line 54953: # if 0 
line 54954: int iMeta ; 
line 54955: int iDb ; 
line 54956: int iCookie ; 
line 54957: # endif 
line 54959: u . at . iDb = pOp -> p1 ; 
line 54960: u . at . iCookie = pOp -> p3 ; 
line 54961: assert ( pOp -> p3 < SQLITE_N_BTREE_META ) ; 
line 54962: assert ( u . at . iDb >= 0 && u . at . iDb < db -> nDb ) ; 
line 54963: assert ( db -> aDb [ u . at . iDb ] . pBt != 0 ) ; 
line 54964: assert ( ( p -> btreeMask & ( 1 << u . at . iDb ) ) != 0 ) ; 
line 54966: sqlite3BtreeGetMeta ( db -> aDb [ u . at . iDb ] . pBt , u . at . iCookie , ( u32 * ) & u . at . iMeta ) ; 
line 54967: pOut -> u . i = u . at . iMeta ; 
line 54968: break ; 
line 54969: } 
line 54981: case OP_SetCookie : { 
line 54982: # if 0 
line 54983: Db * pDb ; 
line 54984: # endif 
line 54985: assert ( pOp -> p2 < SQLITE_N_BTREE_META ) ; 
line 54986: assert ( pOp -> p1 >= 0 && pOp -> p1 < db -> nDb ) ; 
line 54987: assert ( ( p -> btreeMask & ( 1 << pOp -> p1 ) ) != 0 ) ; 
line 54988: u . au . pDb = & db -> aDb [ pOp -> p1 ] ; 
line 54989: assert ( u . au . pDb -> pBt != 0 ) ; 
line 54990: pIn3 = & aMem [ pOp -> p3 ] ; 
line 54991: sqlite3VdbeMemIntegerify ( pIn3 ) ; 
line 54993: rc = sqlite3BtreeUpdateMeta ( u . au . pDb -> pBt , pOp -> p2 , ( int ) pIn3 -> u . i ) ; 
line 54994: if ( pOp -> p2 == BTREE_SCHEMA_VERSION ) { 
line 54996: u . au . pDb -> pSchema -> schema_cookie = ( int ) pIn3 -> u . i ; 
line 54997: db -> flags |= SQLITE_InternChanges ; 
line 54998: } else if ( pOp -> p2 == BTREE_FILE_FORMAT ) { 
line 55000: u . au . pDb -> pSchema -> file_format = ( u8 ) pIn3 -> u . i ; 
line 55001: } 
line 55002: if ( pOp -> p1 == 1 ) { 
line 55005: sqlite3ExpirePreparedStatements ( db ) ; 
line 55006: p -> expired = 0 ; 
line 55007: } 
line 55008: break ; 
line 55009: } 
line 55027: case OP_VerifyCookie : { 
line 55028: # if 0 
line 55029: int iMeta ; 
line 55030: Btree * pBt ; 
line 55031: # endif 
line 55032: assert ( pOp -> p1 >= 0 && pOp -> p1 < db -> nDb ) ; 
line 55033: assert ( ( p -> btreeMask & ( 1 << pOp -> p1 ) ) != 0 ) ; 
line 55034: u . av . pBt = db -> aDb [ pOp -> p1 ] . pBt ; 
line 55035: if ( u . av . pBt ) { 
line 55036: sqlite3BtreeGetMeta ( u . av . pBt , BTREE_SCHEMA_VERSION , ( u32 * ) & u . av . iMeta ) ; 
line 55037: } else { 
line 55038: u . av . iMeta = 0 ; 
line 55039: } 
line 55040: if ( u . av . iMeta != pOp -> p2 ) { 
line 55041: sqlite3DbFree ( db , p -> zErrMsg ) ; 
line 55042: p -> zErrMsg = sqlite3DbStrDup ( db , "database schema has changed" ) ; 
line 55056: if ( db -> aDb [ pOp -> p1 ] . pSchema -> schema_cookie != u . av . iMeta ) { 
line 55057: sqlite3ResetInternalSchema ( db , pOp -> p1 ) ; 
line 55058: } 
line 55060: sqlite3ExpirePreparedStatements ( db ) ; 
line 55061: rc = SQLITE_SCHEMA ; 
line 55062: } 
line 55063: break ; 
line 55064: } 
line 55115: case OP_OpenRead : 
line 55116: case OP_OpenWrite : { 
line 55117: # if 0 
line 55118: int nField ; 
line 55119: KeyInfo * pKeyInfo ; 
line 55120: int p2 ; 
line 55121: int iDb ; 
line 55122: int wrFlag ; 
line 55123: Btree * pX ; 
line 55124: VdbeCursor * pCur ; 
line 55125: Db * pDb ; 
line 55126: # endif 
line 55128: if ( p -> expired ) { 
line 55129: rc = SQLITE_ABORT ; 
line 55130: break ; 
line 55131: } 
line 55133: u . aw . nField = 0 ; 
line 55134: u . aw . pKeyInfo = 0 ; 
line 55135: u . aw . p2 = pOp -> p2 ; 
line 55136: u . aw . iDb = pOp -> p3 ; 
line 55137: assert ( u . aw . iDb >= 0 && u . aw . iDb < db -> nDb ) ; 
line 55138: assert ( ( p -> btreeMask & ( 1 << u . aw . iDb ) ) != 0 ) ; 
line 55139: u . aw . pDb = & db -> aDb [ u . aw . iDb ] ; 
line 55140: u . aw . pX = u . aw . pDb -> pBt ; 
line 55141: assert ( u . aw . pX != 0 ) ; 
line 55142: if ( pOp -> opcode == OP_OpenWrite ) { 
line 55143: u . aw . wrFlag = 1 ; 
line 55144: if ( u . aw . pDb -> pSchema -> file_format < p -> minWriteFileFormat ) { 
line 55145: p -> minWriteFileFormat = u . aw . pDb -> pSchema -> file_format ; 
line 55146: } 
line 55147: } else { 
line 55148: u . aw . wrFlag = 0 ; 
line 55149: } 
line 55150: if ( pOp -> p5 ) { 
line 55151: assert ( u . aw . p2 > 0 ) ; 
line 55152: assert ( u . aw . p2 <= p -> nMem ) ; 
line 55153: pIn2 = & aMem [ u . aw . p2 ] ; 
line 55154: sqlite3VdbeMemIntegerify ( pIn2 ) ; 
line 55155: u . aw . p2 = ( int ) pIn2 -> u . i ; 
line 55160: if ( NEVER ( u . aw . p2 < 2 ) ) { 
line 55161: rc = SQLITE_CORRUPT_BKPT ; 
line 55162: goto abort_due_to_error ; 
line 55163: } 
line 55164: } 
line 55165: if ( pOp -> p4type == P4_KEYINFO ) { 
line 55166: u . aw . pKeyInfo = pOp -> p4 . pKeyInfo ; 
line 55167: u . aw . pKeyInfo -> enc = ENC ( p -> db ) ; 
line 55168: u . aw . nField = u . aw . pKeyInfo -> nField + 1 ; 
line 55169: } else if ( pOp -> p4type == P4_INT32 ) { 
line 55170: u . aw . nField = pOp -> p4 . i ; 
line 55171: } 
line 55172: assert ( pOp -> p1 >= 0 ) ; 
line 55173: u . aw . pCur = allocateCursor ( p , pOp -> p1 , u . aw . nField , u . aw . iDb , 1 ) ; 
line 55174: if ( u . aw . pCur == 0 ) goto no_mem ; 
line 55175: u . aw . pCur -> nullRow = 1 ; 
line 55176: rc = sqlite3BtreeCursor ( u . aw . pX , u . aw . p2 , u . aw . wrFlag , u . aw . pKeyInfo , u . aw . pCur -> pCursor ) ; 
line 55177: u . aw . pCur -> pKeyInfo = u . aw . pKeyInfo ; 
line 55183: assert ( rc == SQLITE_EMPTY || rc == SQLITE_OK ) ; 
line 55184: if ( rc == SQLITE_EMPTY ) { 
line 55185: u . aw . pCur -> pCursor = 0 ; 
line 55186: rc = SQLITE_OK ; 
line 55187: } 
line 55193: u . aw . pCur -> isTable = pOp -> p4type != P4_KEYINFO ; 
line 55194: u . aw . pCur -> isIndex = ! u . aw . pCur -> isTable ; 
line 55195: break ; 
line 55196: } 
line 55216: case OP_OpenEphemeral : { 
line 55217: # if 0 
line 55218: VdbeCursor * pCx ; 
line 55219: # endif 
line 55220: static const int openFlags = 
line 55221: SQLITE_OPEN_READWRITE | 
line 55222: SQLITE_OPEN_CREATE | 
line 55223: SQLITE_OPEN_EXCLUSIVE | 
line 55224: SQLITE_OPEN_DELETEONCLOSE | 
line 55225: SQLITE_OPEN_TRANSIENT_DB ; 
line 55227: assert ( pOp -> p1 >= 0 ) ; 
line 55228: u . ax . pCx = allocateCursor ( p , pOp -> p1 , pOp -> p2 , - 1 , 1 ) ; 
line 55229: if ( u . ax . pCx == 0 ) goto no_mem ; 
line 55230: u . ax . pCx -> nullRow = 1 ; 
line 55231: rc = sqlite3BtreeFactory ( db , 0 , 1 , SQLITE_DEFAULT_TEMP_CACHE_SIZE , openFlags , 
line 55232: & u . ax . pCx -> pBt ) ; 
line 55233: if ( rc == SQLITE_OK ) { 
line 55234: rc = sqlite3BtreeBeginTrans ( u . ax . pCx -> pBt , 1 ) ; 
line 55235: } 
line 55236: if ( rc == SQLITE_OK ) { 
line 55242: if ( pOp -> p4 . pKeyInfo ) { 
line 55243: int pgno ; 
line 55244: assert ( pOp -> p4type == P4_KEYINFO ) ; 
line 55245: rc = sqlite3BtreeCreateTable ( u . ax . pCx -> pBt , & pgno , BTREE_ZERODATA ) ; 
line 55246: if ( rc == SQLITE_OK ) { 
line 55247: assert ( pgno == MASTER_ROOT + 1 ) ; 
line 55248: rc = sqlite3BtreeCursor ( u . ax . pCx -> pBt , pgno , 1 , 
line 55249: ( KeyInfo * ) pOp -> p4 . z , u . ax . pCx -> pCursor ) ; 
line 55250: u . ax . pCx -> pKeyInfo = pOp -> p4 . pKeyInfo ; 
line 55251: u . ax . pCx -> pKeyInfo -> enc = ENC ( p -> db ) ; 
line 55252: } 
line 55253: u . ax . pCx -> isTable = 0 ; 
line 55254: } else { 
line 55255: rc = sqlite3BtreeCursor ( u . ax . pCx -> pBt , MASTER_ROOT , 1 , 0 , u . ax . pCx -> pCursor ) ; 
line 55256: u . ax . pCx -> isTable = 1 ; 
line 55257: } 
line 55258: } 
line 55259: u . ax . pCx -> isIndex = ! u . ax . pCx -> isTable ; 
line 55260: break ; 
line 55261: } 
line 55278: case OP_OpenPseudo : { 
line 55279: # if 0 
line 55280: VdbeCursor * pCx ; 
line 55281: # endif 
line 55283: assert ( pOp -> p1 >= 0 ) ; 
line 55284: u . ay . pCx = allocateCursor ( p , pOp -> p1 , pOp -> p3 , - 1 , 0 ) ; 
line 55285: if ( u . ay . pCx == 0 ) goto no_mem ; 
line 55286: u . ay . pCx -> nullRow = 1 ; 
line 55287: u . ay . pCx -> pseudoTableReg = pOp -> p2 ; 
line 55288: u . ay . pCx -> isTable = 1 ; 
line 55289: u . ay . pCx -> isIndex = 0 ; 
line 55290: break ; 
line 55291: } 
line 55298: case OP_Close : { 
line 55299: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 55300: sqlite3VdbeFreeCursor ( p , p -> apCsr [ pOp -> p1 ] ) ; 
line 55301: p -> apCsr [ pOp -> p1 ] = 0 ; 
line 55302: break ; 
line 55303: } 
line 55357: case OP_SeekLt : 
line 55358: case OP_SeekLe : 
line 55359: case OP_SeekGe : 
line 55360: case OP_SeekGt : { 
line 55361: # if 0 
line 55362: int res ; 
line 55363: int oc ; 
line 55364: VdbeCursor * pC ; 
line 55365: UnpackedRecord r ; 
line 55366: int nField ; 
line 55367: i64 iKey ; 
line 55368: # endif 
line 55370: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 55371: assert ( pOp -> p2 != 0 ) ; 
line 55372: u . az . pC = p -> apCsr [ pOp -> p1 ] ; 
line 55373: assert ( u . az . pC != 0 ) ; 
line 55374: assert ( u . az . pC -> pseudoTableReg == 0 ) ; 
line 55375: assert ( OP_SeekLe == OP_SeekLt + 1 ) ; 
line 55376: assert ( OP_SeekGe == OP_SeekLt + 2 ) ; 
line 55377: assert ( OP_SeekGt == OP_SeekLt + 3 ) ; 
line 55378: if ( u . az . pC -> pCursor != 0 ) { 
line 55379: u . az . oc = pOp -> opcode ; 
line 55380: u . az . pC -> nullRow = 0 ; 
line 55381: if ( u . az . pC -> isTable ) { 
line 55385: pIn3 = & aMem [ pOp -> p3 ] ; 
line 55386: applyNumericAffinity ( pIn3 ) ; 
line 55387: u . az . iKey = sqlite3VdbeIntValue ( pIn3 ) ; 
line 55388: u . az . pC -> rowidIsValid = 0 ; 
line 55392: if ( ( pIn3 -> flags & MEM_Int ) == 0 ) { 
line 55393: if ( ( pIn3 -> flags & MEM_Real ) == 0 ) { 
line 55396: pc = pOp -> p2 - 1 ; 
line 55397: break ; 
line 55398: } 
line 55401: assert ( ( pIn3 -> flags & MEM_Real ) != 0 ) ; 
line 55403: if ( u . az . iKey == SMALLEST_INT64 && ( pIn3 -> r < ( double ) u . az . iKey || pIn3 -> r > 0 ) ) { 
line 55406: u . az . res = 1 ; 
line 55407: if ( pIn3 -> r < 0 ) { 
line 55408: if ( u . az . oc >= OP_SeekGe ) { assert ( u . az . oc == OP_SeekGe || u . az . oc == OP_SeekGt ) ; 
line 55409: rc = sqlite3BtreeFirst ( u . az . pC -> pCursor , & u . az . res ) ; 
line 55410: if ( rc != SQLITE_OK ) goto abort_due_to_error ; 
line 55411: } 
line 55412: } else { 
line 55413: if ( u . az . oc <= OP_SeekLe ) { assert ( u . az . oc == OP_SeekLt || u . az . oc == OP_SeekLe ) ; 
line 55414: rc = sqlite3BtreeLast ( u . az . pC -> pCursor , & u . az . res ) ; 
line 55415: if ( rc != SQLITE_OK ) goto abort_due_to_error ; 
line 55416: } 
line 55417: } 
line 55418: if ( u . az . res ) { 
line 55419: pc = pOp -> p2 - 1 ; 
line 55420: } 
line 55421: break ; 
line 55422: } else if ( u . az . oc == OP_SeekLt || u . az . oc == OP_SeekGe ) { 
line 55424: if ( pIn3 -> r > ( double ) u . az . iKey ) u . az . iKey ++ ; 
line 55425: } else { 
line 55427: assert ( u . az . oc == OP_SeekLe || u . az . oc == OP_SeekGt ) ; 
line 55428: if ( pIn3 -> r < ( double ) u . az . iKey ) u . az . iKey -- ; 
line 55429: } 
line 55430: } 
line 55431: rc = sqlite3BtreeMovetoUnpacked ( u . az . pC -> pCursor , 0 , ( u64 ) u . az . iKey , 0 , & u . az . res ) ; 
line 55432: if ( rc != SQLITE_OK ) { 
line 55433: goto abort_due_to_error ; 
line 55434: } 
line 55435: if ( u . az . res == 0 ) { 
line 55436: u . az . pC -> rowidIsValid = 1 ; 
line 55437: u . az . pC -> lastRowid = u . az . iKey ; 
line 55438: } 
line 55439: } else { 
line 55440: u . az . nField = pOp -> p4 . i ; 
line 55441: assert ( pOp -> p4type == P4_INT32 ) ; 
line 55442: assert ( u . az . nField > 0 ) ; 
line 55443: u . az . r . pKeyInfo = u . az . pC -> pKeyInfo ; 
line 55444: u . az . r . nField = ( u16 ) u . az . nField ; 
line 55453: u . az . r . flags = ( u16 ) ( UNPACKED_INCRKEY * ( 1 & ( u . az . oc - OP_SeekLt ) ) ) ; 
line 55454: assert ( u . az . oc != OP_SeekGt || u . az . r . flags == UNPACKED_INCRKEY ) ; 
line 55455: assert ( u . az . oc != OP_SeekLe || u . az . r . flags == UNPACKED_INCRKEY ) ; 
line 55456: assert ( u . az . oc != OP_SeekGe || u . az . r . flags == 0 ) ; 
line 55457: assert ( u . az . oc != OP_SeekLt || u . az . r . flags == 0 ) ; 
line 55459: u . az . r . aMem = & aMem [ pOp -> p3 ] ; 
line 55460: ExpandBlob ( u . az . r . aMem ) ; 
line 55461: rc = sqlite3BtreeMovetoUnpacked ( u . az . pC -> pCursor , & u . az . r , 0 , 0 , & u . az . res ) ; 
line 55462: if ( rc != SQLITE_OK ) { 
line 55463: goto abort_due_to_error ; 
line 55464: } 
line 55465: u . az . pC -> rowidIsValid = 0 ; 
line 55466: } 
line 55467: u . az . pC -> deferredMoveto = 0 ; 
line 55468: u . az . pC -> cacheStatus = CACHE_STALE ; 
line 55469: # ifdef SQLITE_TEST 
line 55470: sqlite3_search_count ++ ; 
line 55471: # endif 
line 55472: if ( u . az . oc >= OP_SeekGe ) { assert ( u . az . oc == OP_SeekGe || u . az . oc == OP_SeekGt ) ; 
line 55473: if ( u . az . res < 0 || ( u . az . res == 0 && u . az . oc == OP_SeekGt ) ) { 
line 55474: rc = sqlite3BtreeNext ( u . az . pC -> pCursor , & u . az . res ) ; 
line 55475: if ( rc != SQLITE_OK ) goto abort_due_to_error ; 
line 55476: u . az . pC -> rowidIsValid = 0 ; 
line 55477: } else { 
line 55478: u . az . res = 0 ; 
line 55479: } 
line 55480: } else { 
line 55481: assert ( u . az . oc == OP_SeekLt || u . az . oc == OP_SeekLe ) ; 
line 55482: if ( u . az . res > 0 || ( u . az . res == 0 && u . az . oc == OP_SeekLt ) ) { 
line 55483: rc = sqlite3BtreePrevious ( u . az . pC -> pCursor , & u . az . res ) ; 
line 55484: if ( rc != SQLITE_OK ) goto abort_due_to_error ; 
line 55485: u . az . pC -> rowidIsValid = 0 ; 
line 55486: } else { 
line 55490: u . az . res = sqlite3BtreeEof ( u . az . pC -> pCursor ) ; 
line 55491: } 
line 55492: } 
line 55493: assert ( pOp -> p2 > 0 ) ; 
line 55494: if ( u . az . res ) { 
line 55495: pc = pOp -> p2 - 1 ; 
line 55496: } 
line 55497: } else { 
line 55502: pc = pOp -> p2 - 1 ; 
line 55503: } 
line 55504: break ; 
line 55505: } 
line 55516: case OP_Seek : { 
line 55517: # if 0 
line 55518: VdbeCursor * pC ; 
line 55519: # endif 
line 55521: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 55522: u . ba . pC = p -> apCsr [ pOp -> p1 ] ; 
line 55523: assert ( u . ba . pC != 0 ) ; 
line 55524: if ( ALWAYS ( u . ba . pC -> pCursor != 0 ) ) { 
line 55525: assert ( u . ba . pC -> isTable ) ; 
line 55526: u . ba . pC -> nullRow = 0 ; 
line 55527: pIn2 = & aMem [ pOp -> p2 ] ; 
line 55528: u . ba . pC -> movetoTarget = sqlite3VdbeIntValue ( pIn2 ) ; 
line 55529: u . ba . pC -> rowidIsValid = 0 ; 
line 55530: u . ba . pC -> deferredMoveto = 1 ; 
line 55531: } 
line 55532: break ; 
line 55533: } 
line 55560: case OP_NotFound : 
line 55561: case OP_Found : { 
line 55562: # if 0 
line 55563: int alreadyExists ; 
line 55564: VdbeCursor * pC ; 
line 55565: int res ; 
line 55566: UnpackedRecord * pIdxKey ; 
line 55567: UnpackedRecord r ; 
line 55568: char aTempRec [ ROUND8 ( sizeof ( UnpackedRecord ) ) + sizeof ( Mem ) * 3 + 7 ] ; 
line 55569: # endif 
line 55571: # ifdef SQLITE_TEST 
line 55572: sqlite3_found_count ++ ; 
line 55573: # endif 
line 55575: u . bb . alreadyExists = 0 ; 
line 55576: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 55577: assert ( pOp -> p4type == P4_INT32 ) ; 
line 55578: u . bb . pC = p -> apCsr [ pOp -> p1 ] ; 
line 55579: assert ( u . bb . pC != 0 ) ; 
line 55580: pIn3 = & aMem [ pOp -> p3 ] ; 
line 55581: if ( ALWAYS ( u . bb . pC -> pCursor != 0 ) ) { 
line 55583: assert ( u . bb . pC -> isTable == 0 ) ; 
line 55584: if ( pOp -> p4 . i > 0 ) { 
line 55585: u . bb . r . pKeyInfo = u . bb . pC -> pKeyInfo ; 
line 55586: u . bb . r . nField = ( u16 ) pOp -> p4 . i ; 
line 55587: u . bb . r . aMem = pIn3 ; 
line 55588: u . bb . r . flags = UNPACKED_PREFIX_MATCH ; 
line 55589: u . bb . pIdxKey = & u . bb . r ; 
line 55590: } else { 
line 55591: assert ( pIn3 -> flags & MEM_Blob ) ; 
line 55592: ExpandBlob ( pIn3 ) ; 
line 55593: u . bb . pIdxKey = sqlite3VdbeRecordUnpack ( u . bb . pC -> pKeyInfo , pIn3 -> n , pIn3 -> z , 
line 55594: u . bb . aTempRec , sizeof ( u . bb . aTempRec ) ) ; 
line 55595: if ( u . bb . pIdxKey == 0 ) { 
line 55596: goto no_mem ; 
line 55597: } 
line 55598: u . bb . pIdxKey -> flags |= UNPACKED_PREFIX_MATCH ; 
line 55599: } 
line 55600: rc = sqlite3BtreeMovetoUnpacked ( u . bb . pC -> pCursor , u . bb . pIdxKey , 0 , 0 , & u . bb . res ) ; 
line 55601: if ( pOp -> p4 . i == 0 ) { 
line 55602: sqlite3VdbeDeleteUnpackedRecord ( u . bb . pIdxKey ) ; 
line 55603: } 
line 55604: if ( rc != SQLITE_OK ) { 
line 55605: break ; 
line 55606: } 
line 55607: u . bb . alreadyExists = ( u . bb . res == 0 ) ; 
line 55608: u . bb . pC -> deferredMoveto = 0 ; 
line 55609: u . bb . pC -> cacheStatus = CACHE_STALE ; 
line 55610: } 
line 55611: if ( pOp -> opcode == OP_Found ) { 
line 55612: if ( u . bb . alreadyExists ) pc = pOp -> p2 - 1 ; 
line 55613: } else { 
line 55614: if ( ! u . bb . alreadyExists ) pc = pOp -> p2 - 1 ; 
line 55615: } 
line 55616: break ; 
line 55617: } 
line 55645: case OP_IsUnique : { 
line 55646: # if 0 
line 55647: u16 ii ; 
line 55648: VdbeCursor * pCx ; 
line 55649: BtCursor * pCrsr ; 
line 55650: u16 nField ; 
line 55651: Mem * aMx ; 
line 55652: UnpackedRecord r ; 
line 55653: i64 R ; 
line 55654: # endif 
line 55656: pIn3 = & aMem [ pOp -> p3 ] ; 
line 55657: u . bc . aMx = & aMem [ pOp -> p4 . i ] ; 
line 55659: assert ( pOp -> p4type == P4_INT32 ) ; 
line 55660: assert ( pOp -> p4 . i > 0 && pOp -> p4 . i <= p -> nMem ) ; 
line 55661: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 55664: u . bc . pCx = p -> apCsr [ pOp -> p1 ] ; 
line 55665: assert ( u . bc . pCx -> deferredMoveto == 0 ) ; 
line 55666: u . bc . pCx -> seekResult = 0 ; 
line 55667: u . bc . pCx -> cacheStatus = CACHE_STALE ; 
line 55668: u . bc . pCrsr = u . bc . pCx -> pCursor ; 
line 55671: u . bc . nField = u . bc . pCx -> pKeyInfo -> nField ; 
line 55672: for ( u . bc . ii = 0 ; u . bc . ii < u . bc . nField ; u . bc . ii ++ ) { 
line 55673: if ( u . bc . aMx [ u . bc . ii ] . flags & MEM_Null ) { 
line 55674: pc = pOp -> p2 - 1 ; 
line 55675: u . bc . pCrsr = 0 ; 
line 55676: break ; 
line 55677: } 
line 55678: } 
line 55679: assert ( ( u . bc . aMx [ u . bc . nField ] . flags & MEM_Null ) == 0 ) ; 
line 55681: if ( u . bc . pCrsr != 0 ) { 
line 55683: u . bc . r . pKeyInfo = u . bc . pCx -> pKeyInfo ; 
line 55684: u . bc . r . nField = u . bc . nField + 1 ; 
line 55685: u . bc . r . flags = UNPACKED_PREFIX_SEARCH ; 
line 55686: u . bc . r . aMem = u . bc . aMx ; 
line 55689: sqlite3VdbeMemIntegerify ( pIn3 ) ; 
line 55690: u . bc . R = pIn3 -> u . i ; 
line 55695: rc = sqlite3BtreeMovetoUnpacked ( u . bc . pCrsr , & u . bc . r , 0 , 0 , & u . bc . pCx -> seekResult ) ; 
line 55696: if ( ( u . bc . r . flags & UNPACKED_PREFIX_SEARCH ) || u . bc . r . rowid == u . bc . R ) { 
line 55697: pc = pOp -> p2 - 1 ; 
line 55698: } else { 
line 55699: pIn3 -> u . i = u . bc . r . rowid ; 
line 55700: } 
line 55701: } 
line 55702: break ; 
line 55703: } 
line 55719: case OP_NotExists : { 
line 55720: # if 0 
line 55721: VdbeCursor * pC ; 
line 55722: BtCursor * pCrsr ; 
line 55723: int res ; 
line 55724: u64 iKey ; 
line 55725: # endif 
line 55727: pIn3 = & aMem [ pOp -> p3 ] ; 
line 55728: assert ( pIn3 -> flags & MEM_Int ) ; 
line 55729: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 55730: u . bd . pC = p -> apCsr [ pOp -> p1 ] ; 
line 55731: assert ( u . bd . pC != 0 ) ; 
line 55732: assert ( u . bd . pC -> isTable ) ; 
line 55733: assert ( u . bd . pC -> pseudoTableReg == 0 ) ; 
line 55734: u . bd . pCrsr = u . bd . pC -> pCursor ; 
line 55735: if ( u . bd . pCrsr != 0 ) { 
line 55736: u . bd . res = 0 ; 
line 55737: u . bd . iKey = pIn3 -> u . i ; 
line 55738: rc = sqlite3BtreeMovetoUnpacked ( u . bd . pCrsr , 0 , u . bd . iKey , 0 , & u . bd . res ) ; 
line 55739: u . bd . pC -> lastRowid = pIn3 -> u . i ; 
line 55740: u . bd . pC -> rowidIsValid = u . bd . res == 0 ? 1 : 0 ; 
line 55741: u . bd . pC -> nullRow = 0 ; 
line 55742: u . bd . pC -> cacheStatus = CACHE_STALE ; 
line 55743: u . bd . pC -> deferredMoveto = 0 ; 
line 55744: if ( u . bd . res != 0 ) { 
line 55745: pc = pOp -> p2 - 1 ; 
line 55746: assert ( u . bd . pC -> rowidIsValid == 0 ) ; 
line 55747: } 
line 55748: u . bd . pC -> seekResult = u . bd . res ; 
line 55749: } else { 
line 55753: pc = pOp -> p2 - 1 ; 
line 55754: assert ( u . bd . pC -> rowidIsValid == 0 ) ; 
line 55755: u . bd . pC -> seekResult = 0 ; 
line 55756: } 
line 55757: break ; 
line 55758: } 
line 55767: case OP_Sequence : { 
line 55768: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 55769: assert ( p -> apCsr [ pOp -> p1 ] != 0 ) ; 
line 55770: pOut -> u . i = p -> apCsr [ pOp -> p1 ] -> seqCount ++ ; 
line 55771: break ; 
line 55772: } 
line 55789: case OP_NewRowid : { 
line 55790: # if 0 
line 55791: i64 v ; 
line 55792: VdbeCursor * pC ; 
line 55793: int res ; 
line 55794: int cnt ; 
line 55795: Mem * pMem ; 
line 55796: VdbeFrame * pFrame ; 
line 55797: # endif 
line 55799: u . be . v = 0 ; 
line 55800: u . be . res = 0 ; 
line 55801: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 55802: u . be . pC = p -> apCsr [ pOp -> p1 ] ; 
line 55803: assert ( u . be . pC != 0 ) ; 
line 55804: if ( NEVER ( u . be . pC -> pCursor == 0 ) ) { 
line 55806: } else { 
line 55820: assert ( u . be . pC -> isTable ) ; 
line 55821: u . be . cnt = 0 ; 
line 55823: # ifdef SQLITE_32BIT_ROWID 
line 55824: # define MAX_ROWID 0x7fffffff 
line 55825: # else 
line 55830: # define MAX_ROWID ( i64 ) ( ( ( ( u64 ) 0x7fffffff ) << 32 ) | ( u64 ) 0xffffffff ) 
line 55831: # endif 
line 55833: if ( ! u . be . pC -> useRandomRowid ) { 
line 55834: u . be . v = sqlite3BtreeGetCachedRowid ( u . be . pC -> pCursor ) ; 
line 55835: if ( u . be . v == 0 ) { 
line 55836: rc = sqlite3BtreeLast ( u . be . pC -> pCursor , & u . be . res ) ; 
line 55837: if ( rc != SQLITE_OK ) { 
line 55838: goto abort_due_to_error ; 
line 55839: } 
line 55840: if ( u . be . res ) { 
line 55841: u . be . v = 1 ; 
line 55842: } else { 
line 55843: assert ( sqlite3BtreeCursorIsValid ( u . be . pC -> pCursor ) ) ; 
line 55844: rc = sqlite3BtreeKeySize ( u . be . pC -> pCursor , & u . be . v ) ; 
line 55845: assert ( rc == SQLITE_OK ) ; 
line 55846: if ( u . be . v == MAX_ROWID ) { 
line 55847: u . be . pC -> useRandomRowid = 1 ; 
line 55848: } else { 
line 55849: u . be . v ++ ; 
line 55850: } 
line 55851: } 
line 55852: } 
line 55854: # ifndef SQLITE_OMIT_AUTOINCREMENT 
line 55855: if ( pOp -> p3 ) { 
line 55857: assert ( pOp -> p3 > 0 ) ; 
line 55858: if ( p -> pFrame ) { 
line 55859: for ( u . be . pFrame = p -> pFrame ; u . be . pFrame -> pParent ; u . be . pFrame = u . be . pFrame -> pParent ) ; 
line 55861: assert ( pOp -> p3 <= u . be . pFrame -> nMem ) ; 
line 55862: u . be . pMem = & u . be . pFrame -> aMem [ pOp -> p3 ] ; 
line 55863: } else { 
line 55865: assert ( pOp -> p3 <= p -> nMem ) ; 
line 55866: u . be . pMem = & aMem [ pOp -> p3 ] ; 
line 55867: } 
line 55869: REGISTER_TRACE ( pOp -> p3 , u . be . pMem ) ; 
line 55870: sqlite3VdbeMemIntegerify ( u . be . pMem ) ; 
line 55871: assert ( ( u . be . pMem -> flags & MEM_Int ) != 0 ) ; 
line 55872: if ( u . be . pMem -> u . i == MAX_ROWID || u . be . pC -> useRandomRowid ) { 
line 55873: rc = SQLITE_FULL ; 
line 55874: goto abort_due_to_error ; 
line 55875: } 
line 55876: if ( u . be . v < u . be . pMem -> u . i + 1 ) { 
line 55877: u . be . v = u . be . pMem -> u . i + 1 ; 
line 55878: } 
line 55879: u . be . pMem -> u . i = u . be . v ; 
line 55880: } 
line 55881: # endif 
line 55883: sqlite3BtreeSetCachedRowid ( u . be . pC -> pCursor , u . be . v < MAX_ROWID ? u . be . v + 1 : 0 ) ; 
line 55884: } 
line 55885: if ( u . be . pC -> useRandomRowid ) { 
line 55891: assert ( pOp -> p3 == 0 ) ; 
line 55893: u . be . v = db -> lastRowid ; 
line 55894: u . be . cnt = 0 ; 
line 55895: do { 
line 55896: if ( u . be . cnt == 0 && ( u . be . v & 0xffffff ) == u . be . v ) { 
line 55897: u . be . v ++ ; 
line 55898: } else { 
line 55899: sqlite3_randomness ( sizeof ( u . be . v ) , & u . be . v ) ; 
line 55900: if ( u . be . cnt < 5 ) u . be . v &= 0xffffff ; 
line 55901: } 
line 55902: rc = sqlite3BtreeMovetoUnpacked ( u . be . pC -> pCursor , 0 , ( u64 ) u . be . v , 0 , & u . be . res ) ; 
line 55903: u . be . cnt ++ ; 
line 55904: } while ( u . be . cnt < 100 && rc == SQLITE_OK && u . be . res == 0 ) ; 
line 55905: if ( rc == SQLITE_OK && u . be . res == 0 ) { 
line 55906: rc = SQLITE_FULL ; 
line 55907: goto abort_due_to_error ; 
line 55908: } 
line 55909: } 
line 55910: u . be . pC -> rowidIsValid = 0 ; 
line 55911: u . be . pC -> deferredMoveto = 0 ; 
line 55912: u . be . pC -> cacheStatus = CACHE_STALE ; 
line 55913: } 
line 55914: pOut -> u . i = u . be . v ; 
line 55915: break ; 
line 55916: } 
line 55962: case OP_Insert : 
line 55963: case OP_InsertInt : { 
line 55964: # if 0 
line 55965: Mem * pData ; 
line 55966: Mem * pKey ; 
line 55967: i64 iKey ; 
line 55968: VdbeCursor * pC ; 
line 55969: int nZero ; 
line 55970: int seekResult ; 
line 55971: const char * zDb ; 
line 55972: const char * zTbl ; 
line 55973: int op ; 
line 55974: # endif 
line 55976: u . bf . pData = & aMem [ pOp -> p2 ] ; 
line 55977: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 55978: u . bf . pC = p -> apCsr [ pOp -> p1 ] ; 
line 55979: assert ( u . bf . pC != 0 ) ; 
line 55980: assert ( u . bf . pC -> pCursor != 0 ) ; 
line 55981: assert ( u . bf . pC -> pseudoTableReg == 0 ) ; 
line 55982: assert ( u . bf . pC -> isTable ) ; 
line 55983: REGISTER_TRACE ( pOp -> p2 , u . bf . pData ) ; 
line 55985: if ( pOp -> opcode == OP_Insert ) { 
line 55986: u . bf . pKey = & aMem [ pOp -> p3 ] ; 
line 55987: assert ( u . bf . pKey -> flags & MEM_Int ) ; 
line 55988: REGISTER_TRACE ( pOp -> p3 , u . bf . pKey ) ; 
line 55989: u . bf . iKey = u . bf . pKey -> u . i ; 
line 55990: } else { 
line 55991: assert ( pOp -> opcode == OP_InsertInt ) ; 
line 55992: u . bf . iKey = pOp -> p3 ; 
line 55993: } 
line 55995: if ( pOp -> p5 & OPFLAG_NCHANGE ) p -> nChange ++ ; 
line 55996: if ( pOp -> p5 & OPFLAG_LASTROWID ) db -> lastRowid = u . bf . iKey ; 
line 55997: if ( u . bf . pData -> flags & MEM_Null ) { 
line 55998: u . bf . pData -> z = 0 ; 
line 55999: u . bf . pData -> n = 0 ; 
line 56000: } else { 
line 56001: assert ( u . bf . pData -> flags & ( MEM_Blob | MEM_Str ) ) ; 
line 56002: } 
line 56003: u . bf . seekResult = ( ( pOp -> p5 & OPFLAG_USESEEKRESULT ) ? u . bf . pC -> seekResult : 0 ) ; 
line 56004: if ( u . bf . pData -> flags & MEM_Zero ) { 
line 56005: u . bf . nZero = u . bf . pData -> u . nZero ; 
line 56006: } else { 
line 56007: u . bf . nZero = 0 ; 
line 56008: } 
line 56009: sqlite3BtreeSetCachedRowid ( u . bf . pC -> pCursor , 0 ) ; 
line 56010: rc = sqlite3BtreeInsert ( u . bf . pC -> pCursor , 0 , u . bf . iKey , 
line 56011: u . bf . pData -> z , u . bf . pData -> n , u . bf . nZero , 
line 56012: pOp -> p5 & OPFLAG_APPEND , u . bf . seekResult 
line 56013: ) ; 
line 56014: u . bf . pC -> rowidIsValid = 0 ; 
line 56015: u . bf . pC -> deferredMoveto = 0 ; 
line 56016: u . bf . pC -> cacheStatus = CACHE_STALE ; 
line 56019: if ( rc == SQLITE_OK && db -> xUpdateCallback && pOp -> p4 . z ) { 
line 56020: u . bf . zDb = db -> aDb [ u . bf . pC -> iDb ] . zName ; 
line 56021: u . bf . zTbl = pOp -> p4 . z ; 
line 56022: u . bf . op = ( ( pOp -> p5 & OPFLAG_ISUPDATE ) ? SQLITE_UPDATE : SQLITE_INSERT ) ; 
line 56023: assert ( u . bf . pC -> isTable ) ; 
line 56024: db -> xUpdateCallback ( db -> pUpdateArg , u . bf . op , u . bf . zDb , u . bf . zTbl , u . bf . iKey ) ; 
line 56025: assert ( u . bf . pC -> iDb >= 0 ) ; 
line 56026: } 
line 56027: break ; 
line 56028: } 
line 56050: case OP_Delete : { 
line 56051: # if 0 
line 56052: i64 iKey ; 
line 56053: VdbeCursor * pC ; 
line 56054: # endif 
line 56056: u . bg . iKey = 0 ; 
line 56057: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 56058: u . bg . pC = p -> apCsr [ pOp -> p1 ] ; 
line 56059: assert ( u . bg . pC != 0 ) ; 
line 56060: assert ( u . bg . pC -> pCursor != 0 ) ; 
line 56065: if ( db -> xUpdateCallback && pOp -> p4 . z ) { 
line 56066: assert ( u . bg . pC -> isTable ) ; 
line 56067: assert ( u . bg . pC -> rowidIsValid ) ; 
line 56068: u . bg . iKey = u . bg . pC -> lastRowid ; 
line 56069: } 
line 56078: assert ( u . bg . pC -> deferredMoveto == 0 ) ; 
line 56079: rc = sqlite3VdbeCursorMoveto ( u . bg . pC ) ; 
line 56080: if ( NEVER ( rc != SQLITE_OK ) ) goto abort_due_to_error ; 
line 56082: sqlite3BtreeSetCachedRowid ( u . bg . pC -> pCursor , 0 ) ; 
line 56083: rc = sqlite3BtreeDelete ( u . bg . pC -> pCursor ) ; 
line 56084: u . bg . pC -> cacheStatus = CACHE_STALE ; 
line 56087: if ( rc == SQLITE_OK && db -> xUpdateCallback && pOp -> p4 . z ) { 
line 56088: const char * zDb = db -> aDb [ u . bg . pC -> iDb ] . zName ; 
line 56089: const char * zTbl = pOp -> p4 . z ; 
line 56090: db -> xUpdateCallback ( db -> pUpdateArg , SQLITE_DELETE , zDb , zTbl , u . bg . iKey ) ; 
line 56091: assert ( u . bg . pC -> iDb >= 0 ) ; 
line 56092: } 
line 56093: if ( pOp -> p2 & OPFLAG_NCHANGE ) p -> nChange ++ ; 
line 56094: break ; 
line 56095: } 
line 56103: case OP_ResetCount : { 
line 56104: sqlite3VdbeSetChanges ( db , p -> nChange ) ; 
line 56105: p -> nChange = 0 ; 
line 56106: break ; 
line 56107: } 
line 56129: case OP_RowKey : 
line 56130: case OP_RowData : { 
line 56131: # if 0 
line 56132: VdbeCursor * pC ; 
line 56133: BtCursor * pCrsr ; 
line 56134: u32 n ; 
line 56135: i64 n64 ; 
line 56136: # endif 
line 56138: pOut = & aMem [ pOp -> p2 ] ; 
line 56141: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 56142: u . bh . pC = p -> apCsr [ pOp -> p1 ] ; 
line 56143: assert ( u . bh . pC -> isTable || pOp -> opcode == OP_RowKey ) ; 
line 56144: assert ( u . bh . pC -> isIndex || pOp -> opcode == OP_RowData ) ; 
line 56145: assert ( u . bh . pC != 0 ) ; 
line 56146: assert ( u . bh . pC -> nullRow == 0 ) ; 
line 56147: assert ( u . bh . pC -> pseudoTableReg == 0 ) ; 
line 56148: assert ( u . bh . pC -> pCursor != 0 ) ; 
line 56149: u . bh . pCrsr = u . bh . pC -> pCursor ; 
line 56150: assert ( sqlite3BtreeCursorIsValid ( u . bh . pCrsr ) ) ; 
line 56157: assert ( u . bh . pC -> deferredMoveto == 0 ) ; 
line 56158: rc = sqlite3VdbeCursorMoveto ( u . bh . pC ) ; 
line 56159: if ( NEVER ( rc != SQLITE_OK ) ) goto abort_due_to_error ; 
line 56161: if ( u . bh . pC -> isIndex ) { 
line 56162: assert ( ! u . bh . pC -> isTable ) ; 
line 56163: rc = sqlite3BtreeKeySize ( u . bh . pCrsr , & u . bh . n64 ) ; 
line 56164: assert ( rc == SQLITE_OK ) ; 
line 56165: if ( u . bh . n64 > db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) { 
line 56166: goto too_big ; 
line 56167: } 
line 56168: u . bh . n = ( u32 ) u . bh . n64 ; 
line 56169: } else { 
line 56170: rc = sqlite3BtreeDataSize ( u . bh . pCrsr , & u . bh . n ) ; 
line 56171: assert ( rc == SQLITE_OK ) ; 
line 56172: if ( u . bh . n > ( u32 ) db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) { 
line 56173: goto too_big ; 
line 56174: } 
line 56175: } 
line 56176: if ( sqlite3VdbeMemGrow ( pOut , u . bh . n , 0 ) ) { 
line 56177: goto no_mem ; 
line 56178: } 
line 56179: pOut -> n = u . bh . n ; 
line 56180: MemSetTypeFlag ( pOut , MEM_Blob ) ; 
line 56181: if ( u . bh . pC -> isIndex ) { 
line 56182: rc = sqlite3BtreeKey ( u . bh . pCrsr , 0 , u . bh . n , pOut -> z ) ; 
line 56183: } else { 
line 56184: rc = sqlite3BtreeData ( u . bh . pCrsr , 0 , u . bh . n , pOut -> z ) ; 
line 56185: } 
line 56186: pOut -> enc = SQLITE_UTF8 ; 
line 56187: UPDATE_MAX_BLOBSIZE ( pOut ) ; 
line 56188: break ; 
line 56189: } 
line 56200: case OP_Rowid : { 
line 56201: # if 0 
line 56202: VdbeCursor * pC ; 
line 56203: i64 v ; 
line 56204: sqlite3_vtab * pVtab ; 
line 56205: const sqlite3_module * pModule ; 
line 56206: # endif 
line 56208: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 56209: u . bi . pC = p -> apCsr [ pOp -> p1 ] ; 
line 56210: assert ( u . bi . pC != 0 ) ; 
line 56211: assert ( u . bi . pC -> pseudoTableReg == 0 ) ; 
line 56212: if ( u . bi . pC -> nullRow ) { 
line 56213: pOut -> flags = MEM_Null ; 
line 56214: break ; 
line 56215: } else if ( u . bi . pC -> deferredMoveto ) { 
line 56216: u . bi . v = u . bi . pC -> movetoTarget ; 
line 56217: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 56218: } else if ( u . bi . pC -> pVtabCursor ) { 
line 56219: u . bi . pVtab = u . bi . pC -> pVtabCursor -> pVtab ; 
line 56220: u . bi . pModule = u . bi . pVtab -> pModule ; 
line 56221: assert ( u . bi . pModule -> xRowid ) ; 
line 56222: if ( sqlite3SafetyOff ( db ) ) goto abort_due_to_misuse ; 
line 56223: rc = u . bi . pModule -> xRowid ( u . bi . pC -> pVtabCursor , & u . bi . v ) ; 
line 56224: sqlite3DbFree ( db , p -> zErrMsg ) ; 
line 56225: p -> zErrMsg = u . bi . pVtab -> zErrMsg ; 
line 56226: u . bi . pVtab -> zErrMsg = 0 ; 
line 56227: if ( sqlite3SafetyOn ( db ) ) goto abort_due_to_misuse ; 
line 56228: # endif 
line 56229: } else { 
line 56230: assert ( u . bi . pC -> pCursor != 0 ) ; 
line 56231: rc = sqlite3VdbeCursorMoveto ( u . bi . pC ) ; 
line 56232: if ( rc ) goto abort_due_to_error ; 
line 56233: if ( u . bi . pC -> rowidIsValid ) { 
line 56234: u . bi . v = u . bi . pC -> lastRowid ; 
line 56235: } else { 
line 56236: rc = sqlite3BtreeKeySize ( u . bi . pC -> pCursor , & u . bi . v ) ; 
line 56237: assert ( rc == SQLITE_OK ) ; 
line 56238: } 
line 56239: } 
line 56240: pOut -> u . i = u . bi . v ; 
line 56241: break ; 
line 56242: } 
line 56250: case OP_NullRow : { 
line 56251: # if 0 
line 56252: VdbeCursor * pC ; 
line 56253: # endif 
line 56255: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 56256: u . bj . pC = p -> apCsr [ pOp -> p1 ] ; 
line 56257: assert ( u . bj . pC != 0 ) ; 
line 56258: u . bj . pC -> nullRow = 1 ; 
line 56259: u . bj . pC -> rowidIsValid = 0 ; 
line 56260: if ( u . bj . pC -> pCursor ) { 
line 56261: sqlite3BtreeClearCursor ( u . bj . pC -> pCursor ) ; 
line 56262: } 
line 56263: break ; 
line 56264: } 
line 56274: case OP_Last : { 
line 56275: # if 0 
line 56276: VdbeCursor * pC ; 
line 56277: BtCursor * pCrsr ; 
line 56278: int res ; 
line 56279: # endif 
line 56281: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 56282: u . bk . pC = p -> apCsr [ pOp -> p1 ] ; 
line 56283: assert ( u . bk . pC != 0 ) ; 
line 56284: u . bk . pCrsr = u . bk . pC -> pCursor ; 
line 56285: if ( u . bk . pCrsr == 0 ) { 
line 56286: u . bk . res = 1 ; 
line 56287: } else { 
line 56288: rc = sqlite3BtreeLast ( u . bk . pCrsr , & u . bk . res ) ; 
line 56289: } 
line 56290: u . bk . pC -> nullRow = ( u8 ) u . bk . res ; 
line 56291: u . bk . pC -> deferredMoveto = 0 ; 
line 56292: u . bk . pC -> rowidIsValid = 0 ; 
line 56293: u . bk . pC -> cacheStatus = CACHE_STALE ; 
line 56294: if ( pOp -> p2 > 0 && u . bk . res ) { 
line 56295: pc = pOp -> p2 - 1 ; 
line 56296: } 
line 56297: break ; 
line 56298: } 
line 56313: case OP_Sort : { 
line 56314: # ifdef SQLITE_TEST 
line 56315: sqlite3_sort_count ++ ; 
line 56316: sqlite3_search_count -- ; 
line 56317: # endif 
line 56318: p -> aCounter [ SQLITE_STMTSTATUS_SORT - 1 ] ++ ; 
line 56320: } 
line 56329: case OP_Rewind : { 
line 56330: # if 0 
line 56331: VdbeCursor * pC ; 
line 56332: BtCursor * pCrsr ; 
line 56333: int res ; 
line 56334: # endif 
line 56336: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 56337: u . bl . pC = p -> apCsr [ pOp -> p1 ] ; 
line 56338: assert ( u . bl . pC != 0 ) ; 
line 56339: if ( ( u . bl . pCrsr = u . bl . pC -> pCursor ) != 0 ) { 
line 56340: rc = sqlite3BtreeFirst ( u . bl . pCrsr , & u . bl . res ) ; 
line 56341: u . bl . pC -> atFirst = u . bl . res == 0 ? 1 : 0 ; 
line 56342: u . bl . pC -> deferredMoveto = 0 ; 
line 56343: u . bl . pC -> cacheStatus = CACHE_STALE ; 
line 56344: u . bl . pC -> rowidIsValid = 0 ; 
line 56345: } else { 
line 56346: u . bl . res = 1 ; 
line 56347: } 
line 56348: u . bl . pC -> nullRow = ( u8 ) u . bl . res ; 
line 56349: assert ( pOp -> p2 > 0 && pOp -> p2 < p -> nOp ) ; 
line 56350: if ( u . bl . res ) { 
line 56351: pc = pOp -> p2 - 1 ; 
line 56352: } 
line 56353: break ; 
line 56354: } 
line 56376: case OP_Prev : 
line 56377: case OP_Next : { 
line 56378: # if 0 
line 56379: VdbeCursor * pC ; 
line 56380: BtCursor * pCrsr ; 
line 56381: int res ; 
line 56382: # endif 
line 56384: CHECK_FOR_INTERRUPT ; 
line 56385: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 56386: u . bm . pC = p -> apCsr [ pOp -> p1 ] ; 
line 56387: if ( u . bm . pC == 0 ) { 
line 56388: break ; 
line 56389: } 
line 56390: u . bm . pCrsr = u . bm . pC -> pCursor ; 
line 56391: if ( u . bm . pCrsr == 0 ) { 
line 56392: u . bm . pC -> nullRow = 1 ; 
line 56393: break ; 
line 56394: } 
line 56395: u . bm . res = 1 ; 
line 56396: assert ( u . bm . pC -> deferredMoveto == 0 ) ; 
line 56397: rc = pOp -> opcode == OP_Next ? sqlite3BtreeNext ( u . bm . pCrsr , & u . bm . res ) : 
line 56398: sqlite3BtreePrevious ( u . bm . pCrsr , & u . bm . res ) ; 
line 56399: u . bm . pC -> nullRow = ( u8 ) u . bm . res ; 
line 56400: u . bm . pC -> cacheStatus = CACHE_STALE ; 
line 56401: if ( u . bm . res == 0 ) { 
line 56402: pc = pOp -> p2 - 1 ; 
line 56403: if ( pOp -> p5 ) p -> aCounter [ pOp -> p5 - 1 ] ++ ; 
line 56404: # ifdef SQLITE_TEST 
line 56405: sqlite3_search_count ++ ; 
line 56406: # endif 
line 56407: } 
line 56408: u . bm . pC -> rowidIsValid = 0 ; 
line 56409: break ; 
line 56410: } 
line 56424: case OP_IdxInsert : { 
line 56425: # if 0 
line 56426: VdbeCursor * pC ; 
line 56427: BtCursor * pCrsr ; 
line 56428: int nKey ; 
line 56429: const char * zKey ; 
line 56430: # endif 
line 56432: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 56433: u . bn . pC = p -> apCsr [ pOp -> p1 ] ; 
line 56434: assert ( u . bn . pC != 0 ) ; 
line 56435: pIn2 = & aMem [ pOp -> p2 ] ; 
line 56436: assert ( pIn2 -> flags & MEM_Blob ) ; 
line 56437: u . bn . pCrsr = u . bn . pC -> pCursor ; 
line 56438: if ( ALWAYS ( u . bn . pCrsr != 0 ) ) { 
line 56439: assert ( u . bn . pC -> isTable == 0 ) ; 
line 56440: rc = ExpandBlob ( pIn2 ) ; 
line 56441: if ( rc == SQLITE_OK ) { 
line 56442: u . bn . nKey = pIn2 -> n ; 
line 56443: u . bn . zKey = pIn2 -> z ; 
line 56444: rc = sqlite3BtreeInsert ( u . bn . pCrsr , u . bn . zKey , u . bn . nKey , "" , 0 , 0 , pOp -> p3 , 
line 56445: ( ( pOp -> p5 & OPFLAG_USESEEKRESULT ) ? u . bn . pC -> seekResult : 0 ) 
line 56446: ) ; 
line 56447: assert ( u . bn . pC -> deferredMoveto == 0 ) ; 
line 56448: u . bn . pC -> cacheStatus = CACHE_STALE ; 
line 56449: } 
line 56450: } 
line 56451: break ; 
line 56452: } 
line 56460: case OP_IdxDelete : { 
line 56461: # if 0 
line 56462: VdbeCursor * pC ; 
line 56463: BtCursor * pCrsr ; 
line 56464: int res ; 
line 56465: UnpackedRecord r ; 
line 56466: # endif 
line 56468: assert ( pOp -> p3 > 0 ) ; 
line 56469: assert ( pOp -> p2 > 0 && pOp -> p2 + pOp -> p3 <= p -> nMem + 1 ) ; 
line 56470: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 56471: u . bo . pC = p -> apCsr [ pOp -> p1 ] ; 
line 56472: assert ( u . bo . pC != 0 ) ; 
line 56473: u . bo . pCrsr = u . bo . pC -> pCursor ; 
line 56474: if ( ALWAYS ( u . bo . pCrsr != 0 ) ) { 
line 56475: u . bo . r . pKeyInfo = u . bo . pC -> pKeyInfo ; 
line 56476: u . bo . r . nField = ( u16 ) pOp -> p3 ; 
line 56477: u . bo . r . flags = 0 ; 
line 56478: u . bo . r . aMem = & aMem [ pOp -> p2 ] ; 
line 56479: rc = sqlite3BtreeMovetoUnpacked ( u . bo . pCrsr , & u . bo . r , 0 , 0 , & u . bo . res ) ; 
line 56480: if ( rc == SQLITE_OK && u . bo . res == 0 ) { 
line 56481: rc = sqlite3BtreeDelete ( u . bo . pCrsr ) ; 
line 56482: } 
line 56483: assert ( u . bo . pC -> deferredMoveto == 0 ) ; 
line 56484: u . bo . pC -> cacheStatus = CACHE_STALE ; 
line 56485: } 
line 56486: break ; 
line 56487: } 
line 56497: case OP_IdxRowid : { 
line 56498: # if 0 
line 56499: BtCursor * pCrsr ; 
line 56500: VdbeCursor * pC ; 
line 56501: i64 rowid ; 
line 56502: # endif 
line 56504: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 56505: u . bp . pC = p -> apCsr [ pOp -> p1 ] ; 
line 56506: assert ( u . bp . pC != 0 ) ; 
line 56507: u . bp . pCrsr = u . bp . pC -> pCursor ; 
line 56508: pOut -> flags = MEM_Null ; 
line 56509: if ( ALWAYS ( u . bp . pCrsr != 0 ) ) { 
line 56510: rc = sqlite3VdbeCursorMoveto ( u . bp . pC ) ; 
line 56511: if ( NEVER ( rc ) ) goto abort_due_to_error ; 
line 56512: assert ( u . bp . pC -> deferredMoveto == 0 ) ; 
line 56513: assert ( u . bp . pC -> isTable == 0 ) ; 
line 56514: if ( ! u . bp . pC -> nullRow ) { 
line 56515: rc = sqlite3VdbeIdxRowid ( db , u . bp . pCrsr , & u . bp . rowid ) ; 
line 56516: if ( rc != SQLITE_OK ) { 
line 56517: goto abort_due_to_error ; 
line 56518: } 
line 56519: pOut -> u . i = u . bp . rowid ; 
line 56520: pOut -> flags = MEM_Int ; 
line 56521: } 
line 56522: } 
line 56523: break ; 
line 56524: } 
line 56552: case OP_IdxLT : 
line 56553: case OP_IdxGE : { 
line 56554: # if 0 
line 56555: VdbeCursor * pC ; 
line 56556: int res ; 
line 56557: UnpackedRecord r ; 
line 56558: # endif 
line 56560: assert ( pOp -> p1 >= 0 && pOp -> p1 < p -> nCursor ) ; 
line 56561: u . bq . pC = p -> apCsr [ pOp -> p1 ] ; 
line 56562: assert ( u . bq . pC != 0 ) ; 
line 56563: if ( ALWAYS ( u . bq . pC -> pCursor != 0 ) ) { 
line 56564: assert ( u . bq . pC -> deferredMoveto == 0 ) ; 
line 56565: assert ( pOp -> p5 == 0 || pOp -> p5 == 1 ) ; 
line 56566: assert ( pOp -> p4type == P4_INT32 ) ; 
line 56567: u . bq . r . pKeyInfo = u . bq . pC -> pKeyInfo ; 
line 56568: u . bq . r . nField = ( u16 ) pOp -> p4 . i ; 
line 56569: if ( pOp -> p5 ) { 
line 56570: u . bq . r . flags = UNPACKED_INCRKEY | UNPACKED_IGNORE_ROWID ; 
line 56571: } else { 
line 56572: u . bq . r . flags = UNPACKED_IGNORE_ROWID ; 
line 56573: } 
line 56574: u . bq . r . aMem = & aMem [ pOp -> p3 ] ; 
line 56575: rc = sqlite3VdbeIdxKeyCompare ( u . bq . pC , & u . bq . r , & u . bq . res ) ; 
line 56576: if ( pOp -> opcode == OP_IdxLT ) { 
line 56577: u . bq . res = - u . bq . res ; 
line 56578: } else { 
line 56579: assert ( pOp -> opcode == OP_IdxGE ) ; 
line 56580: u . bq . res ++ ; 
line 56581: } 
line 56582: if ( u . bq . res > 0 ) { 
line 56583: pc = pOp -> p2 - 1 ; 
line 56584: } 
line 56585: } 
line 56586: break ; 
line 56587: } 
line 56609: case OP_Destroy : { 
line 56610: # if 0 
line 56611: int iMoved ; 
line 56612: int iCnt ; 
line 56613: Vdbe * pVdbe ; 
line 56614: int iDb ; 
line 56615: # endif 
line 56616: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 56617: u . br . iCnt = 0 ; 
line 56618: for ( u . br . pVdbe = db -> pVdbe ; u . br . pVdbe ; u . br . pVdbe = u . br . pVdbe -> pNext ) { 
line 56619: if ( u . br . pVdbe -> magic == VDBE_MAGIC_RUN && u . br . pVdbe -> inVtabMethod < 2 && u . br . pVdbe -> pc >= 0 ) { 
line 56620: u . br . iCnt ++ ; 
line 56621: } 
line 56622: } 
line 56623: # else 
line 56624: u . br . iCnt = db -> activeVdbeCnt ; 
line 56625: # endif 
line 56626: pOut -> flags = MEM_Null ; 
line 56627: if ( u . br . iCnt > 1 ) { 
line 56628: rc = SQLITE_LOCKED ; 
line 56629: p -> errorAction = OE_Abort ; 
line 56630: } else { 
line 56631: u . br . iDb = pOp -> p3 ; 
line 56632: assert ( u . br . iCnt == 1 ) ; 
line 56633: assert ( ( p -> btreeMask & ( 1 << u . br . iDb ) ) != 0 ) ; 
line 56634: rc = sqlite3BtreeDropTable ( db -> aDb [ u . br . iDb ] . pBt , pOp -> p1 , & u . br . iMoved ) ; 
line 56635: pOut -> flags = MEM_Int ; 
line 56636: pOut -> u . i = u . br . iMoved ; 
line 56637: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 56638: if ( rc == SQLITE_OK && u . br . iMoved != 0 ) { 
line 56639: sqlite3RootPageMoved ( & db -> aDb [ u . br . iDb ] , u . br . iMoved , pOp -> p1 ) ; 
line 56640: resetSchemaOnFault = 1 ; 
line 56641: } 
line 56642: # endif 
line 56643: } 
line 56644: break ; 
line 56645: } 
line 56665: case OP_Clear : { 
line 56666: # if 0 
line 56667: int nChange ; 
line 56668: # endif 
line 56670: u . bs . nChange = 0 ; 
line 56671: assert ( ( p -> btreeMask & ( 1 << pOp -> p2 ) ) != 0 ) ; 
line 56672: rc = sqlite3BtreeClearTable ( 
line 56673: db -> aDb [ pOp -> p2 ] . pBt , pOp -> p1 , ( pOp -> p3 ? & u . bs . nChange : 0 ) 
line 56674: ) ; 
line 56675: if ( pOp -> p3 ) { 
line 56676: p -> nChange += u . bs . nChange ; 
line 56677: if ( pOp -> p3 > 0 ) { 
line 56678: aMem [ pOp -> p3 ] . u . i += u . bs . nChange ; 
line 56679: } 
line 56680: } 
line 56681: break ; 
line 56682: } 
line 56706: case OP_CreateIndex : 
line 56707: case OP_CreateTable : { 
line 56708: # if 0 
line 56709: int pgno ; 
line 56710: int flags ; 
line 56711: Db * pDb ; 
line 56712: # endif 
line 56714: u . bt . pgno = 0 ; 
line 56715: assert ( pOp -> p1 >= 0 && pOp -> p1 < db -> nDb ) ; 
line 56716: assert ( ( p -> btreeMask & ( 1 << pOp -> p1 ) ) != 0 ) ; 
line 56717: u . bt . pDb = & db -> aDb [ pOp -> p1 ] ; 
line 56718: assert ( u . bt . pDb -> pBt != 0 ) ; 
line 56719: if ( pOp -> opcode == OP_CreateTable ) { 
line 56721: u . bt . flags = BTREE_LEAFDATA | BTREE_INTKEY ; 
line 56722: } else { 
line 56723: u . bt . flags = BTREE_ZERODATA ; 
line 56724: } 
line 56725: rc = sqlite3BtreeCreateTable ( u . bt . pDb -> pBt , & u . bt . pgno , u . bt . flags ) ; 
line 56726: pOut -> u . i = u . bt . pgno ; 
line 56727: break ; 
line 56728: } 
line 56742: case OP_ParseSchema : { 
line 56743: # if 0 
line 56744: int iDb ; 
line 56745: const char * zMaster ; 
line 56746: char * zSql ; 
line 56747: InitData initData ; 
line 56748: # endif 
line 56750: u . bu . iDb = pOp -> p1 ; 
line 56751: assert ( u . bu . iDb >= 0 && u . bu . iDb < db -> nDb ) ; 
line 56774: assert ( sqlite3BtreeHoldsMutex ( db -> aDb [ u . bu . iDb ] . pBt ) ) ; 
line 56775: sqlite3BtreeEnterAll ( db ) ; 
line 56776: if ( pOp -> p2 || DbHasProperty ( db , u . bu . iDb , DB_SchemaLoaded ) ) { 
line 56777: u . bu . zMaster = SCHEMA_TABLE ( u . bu . iDb ) ; 
line 56778: u . bu . initData . db = db ; 
line 56779: u . bu . initData . iDb = pOp -> p1 ; 
line 56780: u . bu . initData . pzErrMsg = & p -> zErrMsg ; 
line 56781: u . bu . zSql = sqlite3MPrintf ( db , 
line 56782: "SELECT name, rootpage, sql FROM '%q'.%s WHERE %s" , 
line 56783: db -> aDb [ u . bu . iDb ] . zName , u . bu . zMaster , pOp -> p4 . z ) ; 
line 56784: if ( u . bu . zSql == 0 ) { 
line 56785: rc = SQLITE_NOMEM ; 
line 56786: } else { 
line 56787: ( void ) sqlite3SafetyOff ( db ) ; 
line 56788: assert ( db -> init . busy == 0 ) ; 
line 56789: db -> init . busy = 1 ; 
line 56790: u . bu . initData . rc = SQLITE_OK ; 
line 56791: assert ( ! db -> mallocFailed ) ; 
line 56792: rc = sqlite3_exec ( db , u . bu . zSql , sqlite3InitCallback , & u . bu . initData , 0 ) ; 
line 56793: if ( rc == SQLITE_OK ) rc = u . bu . initData . rc ; 
line 56794: sqlite3DbFree ( db , u . bu . zSql ) ; 
line 56795: db -> init . busy = 0 ; 
line 56796: ( void ) sqlite3SafetyOn ( db ) ; 
line 56797: } 
line 56798: } 
line 56799: sqlite3BtreeLeaveAll ( db ) ; 
line 56800: if ( rc == SQLITE_NOMEM ) { 
line 56801: goto no_mem ; 
line 56802: } 
line 56803: break ; 
line 56804: } 
line 56806: # if ! defined ( SQLITE_OMIT_ANALYZE ) 
line 56813: case OP_LoadAnalysis : { 
line 56814: assert ( pOp -> p1 >= 0 && pOp -> p1 < db -> nDb ) ; 
line 56815: rc = sqlite3AnalysisLoad ( db , pOp -> p1 ) ; 
line 56816: break ; 
line 56817: } 
line 56818: # endif 
line 56827: case OP_DropTable : { 
line 56828: sqlite3UnlinkAndDeleteTable ( db , pOp -> p1 , pOp -> p4 . z ) ; 
line 56829: break ; 
line 56830: } 
line 56839: case OP_DropIndex : { 
line 56840: sqlite3UnlinkAndDeleteIndex ( db , pOp -> p1 , pOp -> p4 . z ) ; 
line 56841: break ; 
line 56842: } 
line 56851: case OP_DropTrigger : { 
line 56852: sqlite3UnlinkAndDeleteTrigger ( db , pOp -> p1 , pOp -> p4 . z ) ; 
line 56853: break ; 
line 56854: } 
line 56857: # ifndef SQLITE_OMIT_INTEGRITY_CHECK 
line 56878: case OP_IntegrityCk : { 
line 56879: # if 0 
line 56880: int nRoot ; 
line 56881: int * aRoot ; 
line 56882: int j ; 
line 56883: int nErr ; 
line 56884: char * z ; 
line 56885: Mem * pnErr ; 
line 56886: # endif 
line 56888: u . bv . nRoot = pOp -> p2 ; 
line 56889: assert ( u . bv . nRoot > 0 ) ; 
line 56890: u . bv . aRoot = sqlite3DbMallocRaw ( db , sizeof ( int ) * ( u . bv . nRoot + 1 ) ) ; 
line 56891: if ( u . bv . aRoot == 0 ) goto no_mem ; 
line 56892: assert ( pOp -> p3 > 0 && pOp -> p3 <= p -> nMem ) ; 
line 56893: u . bv . pnErr = & aMem [ pOp -> p3 ] ; 
line 56894: assert ( ( u . bv . pnErr -> flags & MEM_Int ) != 0 ) ; 
line 56895: assert ( ( u . bv . pnErr -> flags & ( MEM_Str | MEM_Blob ) ) == 0 ) ; 
line 56896: pIn1 = & aMem [ pOp -> p1 ] ; 
line 56897: for ( u . bv . j = 0 ; u . bv . j < u . bv . nRoot ; u . bv . j ++ ) { 
line 56898: u . bv . aRoot [ u . bv . j ] = ( int ) sqlite3VdbeIntValue ( & pIn1 [ u . bv . j ] ) ; 
line 56899: } 
line 56900: u . bv . aRoot [ u . bv . j ] = 0 ; 
line 56901: assert ( pOp -> p5 < db -> nDb ) ; 
line 56902: assert ( ( p -> btreeMask & ( 1 << pOp -> p5 ) ) != 0 ) ; 
line 56903: u . bv . z = sqlite3BtreeIntegrityCheck ( db -> aDb [ pOp -> p5 ] . pBt , u . bv . aRoot , u . bv . nRoot , 
line 56904: ( int ) u . bv . pnErr -> u . i , & u . bv . nErr ) ; 
line 56905: sqlite3DbFree ( db , u . bv . aRoot ) ; 
line 56906: u . bv . pnErr -> u . i -= u . bv . nErr ; 
line 56907: sqlite3VdbeMemSetNull ( pIn1 ) ; 
line 56908: if ( u . bv . nErr == 0 ) { 
line 56909: assert ( u . bv . z == 0 ) ; 
line 56910: } else if ( u . bv . z == 0 ) { 
line 56911: goto no_mem ; 
line 56912: } else { 
line 56913: sqlite3VdbeMemSetStr ( pIn1 , u . bv . z , - 1 , SQLITE_UTF8 , sqlite3_free ) ; 
line 56914: } 
line 56915: UPDATE_MAX_BLOBSIZE ( pIn1 ) ; 
line 56916: sqlite3VdbeChangeEncoding ( pIn1 , encoding ) ; 
line 56917: break ; 
line 56918: } 
line 56919: # endif 
line 56928: case OP_RowSetAdd : { 
line 56929: pIn1 = & aMem [ pOp -> p1 ] ; 
line 56930: pIn2 = & aMem [ pOp -> p2 ] ; 
line 56931: assert ( ( pIn2 -> flags & MEM_Int ) != 0 ) ; 
line 56932: if ( ( pIn1 -> flags & MEM_RowSet ) == 0 ) { 
line 56933: sqlite3VdbeMemSetRowSet ( pIn1 ) ; 
line 56934: if ( ( pIn1 -> flags & MEM_RowSet ) == 0 ) goto no_mem ; 
line 56935: } 
line 56936: sqlite3RowSetInsert ( pIn1 -> u . pRowSet , pIn2 -> u . i ) ; 
line 56937: break ; 
line 56938: } 
line 56946: case OP_RowSetRead : { 
line 56947: # if 0 
line 56948: i64 val ; 
line 56949: # endif 
line 56950: CHECK_FOR_INTERRUPT ; 
line 56951: pIn1 = & aMem [ pOp -> p1 ] ; 
line 56952: if ( ( pIn1 -> flags & MEM_RowSet ) == 0 
line 56953: || sqlite3RowSetNext ( pIn1 -> u . pRowSet , & u . bw . val ) == 0 
line 56954: ) { 
line 56956: sqlite3VdbeMemSetNull ( pIn1 ) ; 
line 56957: pc = pOp -> p2 - 1 ; 
line 56958: } else { 
line 56960: sqlite3VdbeMemSetInt64 ( & aMem [ pOp -> p3 ] , u . bw . val ) ; 
line 56961: } 
line 56962: break ; 
line 56963: } 
line 56988: case OP_RowSetTest : { 
line 56989: # if 0 
line 56990: int iSet ; 
line 56991: int exists ; 
line 56992: # endif 
line 56994: pIn1 = & aMem [ pOp -> p1 ] ; 
line 56995: pIn3 = & aMem [ pOp -> p3 ] ; 
line 56996: u . bx . iSet = pOp -> p4 . i ; 
line 56997: assert ( pIn3 -> flags & MEM_Int ) ; 
line 57002: if ( ( pIn1 -> flags & MEM_RowSet ) == 0 ) { 
line 57003: sqlite3VdbeMemSetRowSet ( pIn1 ) ; 
line 57004: if ( ( pIn1 -> flags & MEM_RowSet ) == 0 ) goto no_mem ; 
line 57005: } 
line 57007: assert ( pOp -> p4type == P4_INT32 ) ; 
line 57008: assert ( u . bx . iSet == - 1 || u . bx . iSet >= 0 ) ; 
line 57009: if ( u . bx . iSet ) { 
line 57010: u . bx . exists = sqlite3RowSetTest ( pIn1 -> u . pRowSet , 
line 57011: ( u8 ) ( u . bx . iSet >= 0 ? u . bx . iSet & 0xf : 0xff ) , 
line 57012: pIn3 -> u . i ) ; 
line 57013: if ( u . bx . exists ) { 
line 57014: pc = pOp -> p2 - 1 ; 
line 57015: break ; 
line 57016: } 
line 57017: } 
line 57018: if ( u . bx . iSet >= 0 ) { 
line 57019: sqlite3RowSetInsert ( pIn1 -> u . pRowSet , pIn3 -> u . i ) ; 
line 57020: } 
line 57021: break ; 
line 57022: } 
line 57025: # ifndef SQLITE_OMIT_TRIGGER 
line 57040: case OP_Program : { 
line 57041: # if 0 
line 57042: int nMem ; 
line 57043: int nByte ; 
line 57044: Mem * pRt ; 
line 57045: Mem * pMem ; 
line 57046: Mem * pEnd ; 
line 57047: VdbeFrame * pFrame ; 
line 57048: SubProgram * pProgram ; 
line 57049: void * t ; 
line 57050: # endif 
line 57052: u . by . pProgram = pOp -> p4 . pProgram ; 
line 57053: u . by . pRt = & aMem [ pOp -> p3 ] ; 
line 57054: assert ( u . by . pProgram -> nOp > 0 ) ; 
line 57067: if ( pOp -> p5 ) { 
line 57068: u . by . t = u . by . pProgram -> token ; 
line 57069: for ( u . by . pFrame = p -> pFrame ; u . by . pFrame && u . by . pFrame -> token != u . by . t ; u . by . pFrame = u . by . pFrame -> pParent ) ; 
line 57070: if ( u . by . pFrame ) break ; 
line 57071: } 
line 57073: if ( p -> nFrame >= db -> aLimit [ SQLITE_LIMIT_TRIGGER_DEPTH ] ) { 
line 57074: rc = SQLITE_ERROR ; 
line 57075: sqlite3SetString ( & p -> zErrMsg , db , "too many levels of trigger recursion" ) ; 
line 57076: break ; 
line 57077: } 
line 57083: if ( ( u . by . pRt -> flags & MEM_Frame ) == 0 ) { 
line 57089: u . by . nMem = u . by . pProgram -> nMem + u . by . pProgram -> nCsr ; 
line 57090: u . by . nByte = ROUND8 ( sizeof ( VdbeFrame ) ) 
line 57091: + u . by . nMem * sizeof ( Mem ) 
line 57092: + u . by . pProgram -> nCsr * sizeof ( VdbeCursor * ) ; 
line 57093: u . by . pFrame = sqlite3DbMallocZero ( db , u . by . nByte ) ; 
line 57094: if ( ! u . by . pFrame ) { 
line 57095: goto no_mem ; 
line 57096: } 
line 57097: sqlite3VdbeMemRelease ( u . by . pRt ) ; 
line 57098: u . by . pRt -> flags = MEM_Frame ; 
line 57099: u . by . pRt -> u . pFrame = u . by . pFrame ; 
line 57101: u . by . pFrame -> v = p ; 
line 57102: u . by . pFrame -> nChildMem = u . by . nMem ; 
line 57103: u . by . pFrame -> nChildCsr = u . by . pProgram -> nCsr ; 
line 57104: u . by . pFrame -> pc = pc ; 
line 57105: u . by . pFrame -> aMem = p -> aMem ; 
line 57106: u . by . pFrame -> nMem = p -> nMem ; 
line 57107: u . by . pFrame -> apCsr = p -> apCsr ; 
line 57108: u . by . pFrame -> nCursor = p -> nCursor ; 
line 57109: u . by . pFrame -> aOp = p -> aOp ; 
line 57110: u . by . pFrame -> nOp = p -> nOp ; 
line 57111: u . by . pFrame -> token = u . by . pProgram -> token ; 
line 57113: u . by . pEnd = & VdbeFrameMem ( u . by . pFrame ) [ u . by . pFrame -> nChildMem ] ; 
line 57114: for ( u . by . pMem = VdbeFrameMem ( u . by . pFrame ) ; u . by . pMem != u . by . pEnd ; u . by . pMem ++ ) { 
line 57115: u . by . pMem -> flags = MEM_Null ; 
line 57116: u . by . pMem -> db = db ; 
line 57117: } 
line 57118: } else { 
line 57119: u . by . pFrame = u . by . pRt -> u . pFrame ; 
line 57120: assert ( u . by . pProgram -> nMem + u . by . pProgram -> nCsr == u . by . pFrame -> nChildMem ) ; 
line 57121: assert ( u . by . pProgram -> nCsr == u . by . pFrame -> nChildCsr ) ; 
line 57122: assert ( pc == u . by . pFrame -> pc ) ; 
line 57123: } 
line 57125: p -> nFrame ++ ; 
line 57126: u . by . pFrame -> pParent = p -> pFrame ; 
line 57127: u . by . pFrame -> lastRowid = db -> lastRowid ; 
line 57128: u . by . pFrame -> nChange = p -> nChange ; 
line 57129: p -> nChange = 0 ; 
line 57130: p -> pFrame = u . by . pFrame ; 
line 57131: p -> aMem = aMem = & VdbeFrameMem ( u . by . pFrame ) [ - 1 ] ; 
line 57132: p -> nMem = u . by . pFrame -> nChildMem ; 
line 57133: p -> nCursor = ( u16 ) u . by . pFrame -> nChildCsr ; 
line 57134: p -> apCsr = ( VdbeCursor * * ) & aMem [ p -> nMem + 1 ] ; 
line 57135: p -> aOp = aOp = u . by . pProgram -> aOp ; 
line 57136: p -> nOp = u . by . pProgram -> nOp ; 
line 57137: pc = - 1 ; 
line 57139: break ; 
line 57140: } 
line 57154: case OP_Param : { 
line 57155: # if 0 
line 57156: VdbeFrame * pFrame ; 
line 57157: Mem * pIn ; 
line 57158: # endif 
line 57159: u . bz . pFrame = p -> pFrame ; 
line 57160: u . bz . pIn = & u . bz . pFrame -> aMem [ pOp -> p1 + u . bz . pFrame -> aOp [ u . bz . pFrame -> pc ] . p1 ] ; 
line 57161: sqlite3VdbeMemShallowCopy ( pOut , u . bz . pIn , MEM_Ephem ) ; 
line 57162: break ; 
line 57163: } 
line 57165: # endif 
line 57167: # ifndef SQLITE_OMIT_FOREIGN_KEY 
line 57175: case OP_FkCounter : { 
line 57176: if ( pOp -> p1 ) { 
line 57177: db -> nDeferredCons += pOp -> p2 ; 
line 57178: } else { 
line 57179: p -> nFkConstraint += pOp -> p2 ; 
line 57180: } 
line 57181: break ; 
line 57182: } 
line 57195: case OP_FkIfZero : { 
line 57196: if ( pOp -> p1 ) { 
line 57197: if ( db -> nDeferredCons == 0 ) pc = pOp -> p2 - 1 ; 
line 57198: } else { 
line 57199: if ( p -> nFkConstraint == 0 ) pc = pOp -> p2 - 1 ; 
line 57200: } 
line 57201: break ; 
line 57202: } 
line 57203: # endif 
line 57205: # ifndef SQLITE_OMIT_AUTOINCREMENT 
line 57216: case OP_MemMax : { 
line 57217: # if 0 
line 57218: Mem * pIn1 ; 
line 57219: VdbeFrame * pFrame ; 
line 57220: # endif 
line 57221: if ( p -> pFrame ) { 
line 57222: for ( u . ca . pFrame = p -> pFrame ; u . ca . pFrame -> pParent ; u . ca . pFrame = u . ca . pFrame -> pParent ) ; 
line 57223: u . ca . pIn1 = & u . ca . pFrame -> aMem [ pOp -> p1 ] ; 
line 57224: } else { 
line 57225: u . ca . pIn1 = & aMem [ pOp -> p1 ] ; 
line 57226: } 
line 57227: sqlite3VdbeMemIntegerify ( u . ca . pIn1 ) ; 
line 57228: pIn2 = & aMem [ pOp -> p2 ] ; 
line 57229: sqlite3VdbeMemIntegerify ( pIn2 ) ; 
line 57230: if ( u . ca . pIn1 -> u . i < pIn2 -> u . i ) { 
line 57231: u . ca . pIn1 -> u . i = pIn2 -> u . i ; 
line 57232: } 
line 57233: break ; 
line 57234: } 
line 57235: # endif 
line 57244: case OP_IfPos : { 
line 57245: pIn1 = & aMem [ pOp -> p1 ] ; 
line 57246: assert ( pIn1 -> flags & MEM_Int ) ; 
line 57247: if ( pIn1 -> u . i > 0 ) { 
line 57248: pc = pOp -> p2 - 1 ; 
line 57249: } 
line 57250: break ; 
line 57251: } 
line 57260: case OP_IfNeg : { 
line 57261: pIn1 = & aMem [ pOp -> p1 ] ; 
line 57262: assert ( pIn1 -> flags & MEM_Int ) ; 
line 57263: if ( pIn1 -> u . i < 0 ) { 
line 57264: pc = pOp -> p2 - 1 ; 
line 57265: } 
line 57266: break ; 
line 57267: } 
line 57277: case OP_IfZero : { 
line 57278: pIn1 = & aMem [ pOp -> p1 ] ; 
line 57279: assert ( pIn1 -> flags & MEM_Int ) ; 
line 57280: pIn1 -> u . i += pOp -> p3 ; 
line 57281: if ( pIn1 -> u . i == 0 ) { 
line 57282: pc = pOp -> p2 - 1 ; 
line 57283: } 
line 57284: break ; 
line 57285: } 
line 57297: case OP_AggStep : { 
line 57298: # if 0 
line 57299: int n ; 
line 57300: int i ; 
line 57301: Mem * pMem ; 
line 57302: Mem * pRec ; 
line 57303: sqlite3_context ctx ; 
line 57304: sqlite3_value * * apVal ; 
line 57305: # endif 
line 57307: u . cb . n = pOp -> p5 ; 
line 57308: assert ( u . cb . n >= 0 ) ; 
line 57309: u . cb . pRec = & aMem [ pOp -> p2 ] ; 
line 57310: u . cb . apVal = p -> apArg ; 
line 57311: assert ( u . cb . apVal || u . cb . n == 0 ) ; 
line 57312: for ( u . cb . i = 0 ; u . cb . i < u . cb . n ; u . cb . i ++ , u . cb . pRec ++ ) { 
line 57313: u . cb . apVal [ u . cb . i ] = u . cb . pRec ; 
line 57314: sqlite3VdbeMemStoreType ( u . cb . pRec ) ; 
line 57315: } 
line 57316: u . cb . ctx . pFunc = pOp -> p4 . pFunc ; 
line 57317: assert ( pOp -> p3 > 0 && pOp -> p3 <= p -> nMem ) ; 
line 57318: u . cb . ctx . pMem = u . cb . pMem = & aMem [ pOp -> p3 ] ; 
line 57319: u . cb . pMem -> n ++ ; 
line 57320: u . cb . ctx . s . flags = MEM_Null ; 
line 57321: u . cb . ctx . s . z = 0 ; 
line 57322: u . cb . ctx . s . zMalloc = 0 ; 
line 57323: u . cb . ctx . s . xDel = 0 ; 
line 57324: u . cb . ctx . s . db = db ; 
line 57325: u . cb . ctx . isError = 0 ; 
line 57326: u . cb . ctx . pColl = 0 ; 
line 57327: if ( u . cb . ctx . pFunc -> flags & SQLITE_FUNC_NEEDCOLL ) { 
line 57328: assert ( pOp > p -> aOp ) ; 
line 57329: assert ( pOp [ - 1 ] . p4type == P4_COLLSEQ ) ; 
line 57330: assert ( pOp [ - 1 ] . opcode == OP_CollSeq ) ; 
line 57331: u . cb . ctx . pColl = pOp [ - 1 ] . p4 . pColl ; 
line 57332: } 
line 57333: ( u . cb . ctx . pFunc -> xStep ) ( & u . cb . ctx , u . cb . n , u . cb . apVal ) ; 
line 57334: if ( u . cb . ctx . isError ) { 
line 57335: sqlite3SetString ( & p -> zErrMsg , db , "%s" , sqlite3_value_text ( & u . cb . ctx . s ) ) ; 
line 57336: rc = u . cb . ctx . isError ; 
line 57337: } 
line 57338: sqlite3VdbeMemRelease ( & u . cb . ctx . s ) ; 
line 57339: break ; 
line 57340: } 
line 57354: case OP_AggFinal : { 
line 57355: # if 0 
line 57356: Mem * pMem ; 
line 57357: # endif 
line 57358: assert ( pOp -> p1 > 0 && pOp -> p1 <= p -> nMem ) ; 
line 57359: u . cc . pMem = & aMem [ pOp -> p1 ] ; 
line 57360: assert ( ( u . cc . pMem -> flags & ~ ( MEM_Null | MEM_Agg ) ) == 0 ) ; 
line 57361: rc = sqlite3VdbeMemFinalize ( u . cc . pMem , pOp -> p4 . pFunc ) ; 
line 57362: if ( rc ) { 
line 57363: sqlite3SetString ( & p -> zErrMsg , db , "%s" , sqlite3_value_text ( u . cc . pMem ) ) ; 
line 57364: } 
line 57365: sqlite3VdbeChangeEncoding ( u . cc . pMem , encoding ) ; 
line 57366: UPDATE_MAX_BLOBSIZE ( u . cc . pMem ) ; 
line 57367: if ( sqlite3VdbeMemTooBig ( u . cc . pMem ) ) { 
line 57368: goto too_big ; 
line 57369: } 
line 57370: break ; 
line 57371: } 
line 57374: # if ! defined ( SQLITE_OMIT_VACUUM ) && ! defined ( SQLITE_OMIT_ATTACH ) 
line 57381: case OP_Vacuum : { 
line 57382: if ( sqlite3SafetyOff ( db ) ) goto abort_due_to_misuse ; 
line 57383: rc = sqlite3RunVacuum ( & p -> zErrMsg , db ) ; 
line 57384: if ( sqlite3SafetyOn ( db ) ) goto abort_due_to_misuse ; 
line 57385: break ; 
line 57386: } 
line 57387: # endif 
line 57389: # if ! defined ( SQLITE_OMIT_AUTOVACUUM ) 
line 57396: case OP_IncrVacuum : { 
line 57397: # if 0 
line 57398: Btree * pBt ; 
line 57399: # endif 
line 57401: assert ( pOp -> p1 >= 0 && pOp -> p1 < db -> nDb ) ; 
line 57402: assert ( ( p -> btreeMask & ( 1 << pOp -> p1 ) ) != 0 ) ; 
line 57403: u . cd . pBt = db -> aDb [ pOp -> p1 ] . pBt ; 
line 57404: rc = sqlite3BtreeIncrVacuum ( u . cd . pBt ) ; 
line 57405: if ( rc == SQLITE_DONE ) { 
line 57406: pc = pOp -> p2 - 1 ; 
line 57407: rc = SQLITE_OK ; 
line 57408: } 
line 57409: break ; 
line 57410: } 
line 57411: # endif 
line 57422: case OP_Expire : { 
line 57423: if ( ! pOp -> p1 ) { 
line 57424: sqlite3ExpirePreparedStatements ( db ) ; 
line 57425: } else { 
line 57426: p -> expired = 1 ; 
line 57427: } 
line 57428: break ; 
line 57429: } 
line 57431: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 57446: case OP_TableLock : { 
line 57447: u8 isWriteLock = ( u8 ) pOp -> p3 ; 
line 57448: if ( isWriteLock || 0 == ( db -> flags & SQLITE_ReadUncommitted ) ) { 
line 57449: int p1 = pOp -> p1 ; 
line 57450: assert ( p1 >= 0 && p1 < db -> nDb ) ; 
line 57451: assert ( ( p -> btreeMask & ( 1 << p1 ) ) != 0 ) ; 
line 57452: assert ( isWriteLock == 0 || isWriteLock == 1 ) ; 
line 57453: rc = sqlite3BtreeLockTable ( db -> aDb [ p1 ] . pBt , pOp -> p2 , isWriteLock ) ; 
line 57454: if ( ( rc & 0xFF ) == SQLITE_LOCKED ) { 
line 57455: const char * z = pOp -> p4 . z ; 
line 57456: sqlite3SetString ( & p -> zErrMsg , db , "database table is locked: %s" , z ) ; 
line 57457: } 
line 57458: } 
line 57459: break ; 
line 57460: } 
line 57461: # endif 
line 57463: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 57473: case OP_VBegin : { 
line 57474: # if 0 
line 57475: VTable * pVTab ; 
line 57476: # endif 
line 57477: u . ce . pVTab = pOp -> p4 . pVtab ; 
line 57478: rc = sqlite3VtabBegin ( db , u . ce . pVTab ) ; 
line 57479: if ( u . ce . pVTab ) { 
line 57480: sqlite3DbFree ( db , p -> zErrMsg ) ; 
line 57481: p -> zErrMsg = u . ce . pVTab -> pVtab -> zErrMsg ; 
line 57482: u . ce . pVTab -> pVtab -> zErrMsg = 0 ; 
line 57483: } 
line 57484: break ; 
line 57485: } 
line 57486: # endif 
line 57488: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 57494: case OP_VCreate : { 
line 57495: rc = sqlite3VtabCallCreate ( db , pOp -> p1 , pOp -> p4 . z , & p -> zErrMsg ) ; 
line 57496: break ; 
line 57497: } 
line 57498: # endif 
line 57500: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 57506: case OP_VDestroy : { 
line 57507: p -> inVtabMethod = 2 ; 
line 57508: rc = sqlite3VtabCallDestroy ( db , pOp -> p1 , pOp -> p4 . z ) ; 
line 57509: p -> inVtabMethod = 0 ; 
line 57510: break ; 
line 57511: } 
line 57512: # endif 
line 57514: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 57521: case OP_VOpen : { 
line 57522: # if 0 
line 57523: VdbeCursor * pCur ; 
line 57524: sqlite3_vtab_cursor * pVtabCursor ; 
line 57525: sqlite3_vtab * pVtab ; 
line 57526: sqlite3_module * pModule ; 
line 57527: # endif 
line 57529: u . cf . pCur = 0 ; 
line 57530: u . cf . pVtabCursor = 0 ; 
line 57531: u . cf . pVtab = pOp -> p4 . pVtab -> pVtab ; 
line 57532: u . cf . pModule = ( sqlite3_module * ) u . cf . pVtab -> pModule ; 
line 57533: assert ( u . cf . pVtab && u . cf . pModule ) ; 
line 57534: if ( sqlite3SafetyOff ( db ) ) goto abort_due_to_misuse ; 
line 57535: rc = u . cf . pModule -> xOpen ( u . cf . pVtab , & u . cf . pVtabCursor ) ; 
line 57536: sqlite3DbFree ( db , p -> zErrMsg ) ; 
line 57537: p -> zErrMsg = u . cf . pVtab -> zErrMsg ; 
line 57538: u . cf . pVtab -> zErrMsg = 0 ; 
line 57539: if ( sqlite3SafetyOn ( db ) ) goto abort_due_to_misuse ; 
line 57540: if ( SQLITE_OK == rc ) { 
line 57542: u . cf . pVtabCursor -> pVtab = u . cf . pVtab ; 
line 57545: u . cf . pCur = allocateCursor ( p , pOp -> p1 , 0 , - 1 , 0 ) ; 
line 57546: if ( u . cf . pCur ) { 
line 57547: u . cf . pCur -> pVtabCursor = u . cf . pVtabCursor ; 
line 57548: u . cf . pCur -> pModule = u . cf . pVtabCursor -> pVtab -> pModule ; 
line 57549: } else { 
line 57550: db -> mallocFailed = 1 ; 
line 57551: u . cf . pModule -> xClose ( u . cf . pVtabCursor ) ; 
line 57552: } 
line 57553: } 
line 57554: break ; 
line 57555: } 
line 57556: # endif 
line 57558: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 57577: case OP_VFilter : { 
line 57578: # if 0 
line 57579: int nArg ; 
line 57580: int iQuery ; 
line 57581: const sqlite3_module * pModule ; 
line 57582: Mem * pQuery ; 
line 57583: Mem * pArgc ; 
line 57584: sqlite3_vtab_cursor * pVtabCursor ; 
line 57585: sqlite3_vtab * pVtab ; 
line 57586: VdbeCursor * pCur ; 
line 57587: int res ; 
line 57588: int i ; 
line 57589: Mem * * apArg ; 
line 57590: # endif 
line 57592: u . cg . pQuery = & aMem [ pOp -> p3 ] ; 
line 57593: u . cg . pArgc = & u . cg . pQuery [ 1 ] ; 
line 57594: u . cg . pCur = p -> apCsr [ pOp -> p1 ] ; 
line 57595: REGISTER_TRACE ( pOp -> p3 , u . cg . pQuery ) ; 
line 57596: assert ( u . cg . pCur -> pVtabCursor ) ; 
line 57597: u . cg . pVtabCursor = u . cg . pCur -> pVtabCursor ; 
line 57598: u . cg . pVtab = u . cg . pVtabCursor -> pVtab ; 
line 57599: u . cg . pModule = u . cg . pVtab -> pModule ; 
line 57602: assert ( ( u . cg . pQuery -> flags & MEM_Int ) != 0 && u . cg . pArgc -> flags == MEM_Int ) ; 
line 57603: u . cg . nArg = ( int ) u . cg . pArgc -> u . i ; 
line 57604: u . cg . iQuery = ( int ) u . cg . pQuery -> u . i ; 
line 57607: { 
line 57608: u . cg . res = 0 ; 
line 57609: u . cg . apArg = p -> apArg ; 
line 57610: for ( u . cg . i = 0 ; u . cg . i < u . cg . nArg ; u . cg . i ++ ) { 
line 57611: u . cg . apArg [ u . cg . i ] = & u . cg . pArgc [ u . cg . i + 1 ] ; 
line 57612: sqlite3VdbeMemStoreType ( u . cg . apArg [ u . cg . i ] ) ; 
line 57613: } 
line 57615: if ( sqlite3SafetyOff ( db ) ) goto abort_due_to_misuse ; 
line 57616: p -> inVtabMethod = 1 ; 
line 57617: rc = u . cg . pModule -> xFilter ( u . cg . pVtabCursor , u . cg . iQuery , pOp -> p4 . z , u . cg . nArg , u . cg . apArg ) ; 
line 57618: p -> inVtabMethod = 0 ; 
line 57619: sqlite3DbFree ( db , p -> zErrMsg ) ; 
line 57620: p -> zErrMsg = u . cg . pVtab -> zErrMsg ; 
line 57621: u . cg . pVtab -> zErrMsg = 0 ; 
line 57622: if ( rc == SQLITE_OK ) { 
line 57623: u . cg . res = u . cg . pModule -> xEof ( u . cg . pVtabCursor ) ; 
line 57624: } 
line 57625: if ( sqlite3SafetyOn ( db ) ) goto abort_due_to_misuse ; 
line 57627: if ( u . cg . res ) { 
line 57628: pc = pOp -> p2 - 1 ; 
line 57629: } 
line 57630: } 
line 57631: u . cg . pCur -> nullRow = 0 ; 
line 57633: break ; 
line 57634: } 
line 57635: # endif 
line 57637: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 57644: case OP_VColumn : { 
line 57645: # if 0 
line 57646: sqlite3_vtab * pVtab ; 
line 57647: const sqlite3_module * pModule ; 
line 57648: Mem * pDest ; 
line 57649: sqlite3_context sContext ; 
line 57650: # endif 
line 57652: VdbeCursor * pCur = p -> apCsr [ pOp -> p1 ] ; 
line 57653: assert ( pCur -> pVtabCursor ) ; 
line 57654: assert ( pOp -> p3 > 0 && pOp -> p3 <= p -> nMem ) ; 
line 57655: u . ch . pDest = & aMem [ pOp -> p3 ] ; 
line 57656: if ( pCur -> nullRow ) { 
line 57657: sqlite3VdbeMemSetNull ( u . ch . pDest ) ; 
line 57658: break ; 
line 57659: } 
line 57660: u . ch . pVtab = pCur -> pVtabCursor -> pVtab ; 
line 57661: u . ch . pModule = u . ch . pVtab -> pModule ; 
line 57662: assert ( u . ch . pModule -> xColumn ) ; 
line 57663: memset ( & u . ch . sContext , 0 , sizeof ( u . ch . sContext ) ) ; 
line 57670: sqlite3VdbeMemMove ( & u . ch . sContext . s , u . ch . pDest ) ; 
line 57671: MemSetTypeFlag ( & u . ch . sContext . s , MEM_Null ) ; 
line 57673: if ( sqlite3SafetyOff ( db ) ) goto abort_due_to_misuse ; 
line 57674: rc = u . ch . pModule -> xColumn ( pCur -> pVtabCursor , & u . ch . sContext , pOp -> p2 ) ; 
line 57675: sqlite3DbFree ( db , p -> zErrMsg ) ; 
line 57676: p -> zErrMsg = u . ch . pVtab -> zErrMsg ; 
line 57677: u . ch . pVtab -> zErrMsg = 0 ; 
line 57678: if ( u . ch . sContext . isError ) { 
line 57679: rc = u . ch . sContext . isError ; 
line 57680: } 
line 57686: sqlite3VdbeChangeEncoding ( & u . ch . sContext . s , encoding ) ; 
line 57687: sqlite3VdbeMemMove ( u . ch . pDest , & u . ch . sContext . s ) ; 
line 57688: REGISTER_TRACE ( pOp -> p3 , u . ch . pDest ) ; 
line 57689: UPDATE_MAX_BLOBSIZE ( u . ch . pDest ) ; 
line 57691: if ( sqlite3SafetyOn ( db ) ) { 
line 57692: goto abort_due_to_misuse ; 
line 57693: } 
line 57694: if ( sqlite3VdbeMemTooBig ( u . ch . pDest ) ) { 
line 57695: goto too_big ; 
line 57696: } 
line 57697: break ; 
line 57698: } 
line 57699: # endif 
line 57701: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 57708: case OP_VNext : { 
line 57709: # if 0 
line 57710: sqlite3_vtab * pVtab ; 
line 57711: const sqlite3_module * pModule ; 
line 57712: int res ; 
line 57713: VdbeCursor * pCur ; 
line 57714: # endif 
line 57716: u . ci . res = 0 ; 
line 57717: u . ci . pCur = p -> apCsr [ pOp -> p1 ] ; 
line 57718: assert ( u . ci . pCur -> pVtabCursor ) ; 
line 57719: if ( u . ci . pCur -> nullRow ) { 
line 57720: break ; 
line 57721: } 
line 57722: u . ci . pVtab = u . ci . pCur -> pVtabCursor -> pVtab ; 
line 57723: u . ci . pModule = u . ci . pVtab -> pModule ; 
line 57724: assert ( u . ci . pModule -> xNext ) ; 
line 57732: if ( sqlite3SafetyOff ( db ) ) goto abort_due_to_misuse ; 
line 57733: p -> inVtabMethod = 1 ; 
line 57734: rc = u . ci . pModule -> xNext ( u . ci . pCur -> pVtabCursor ) ; 
line 57735: p -> inVtabMethod = 0 ; 
line 57736: sqlite3DbFree ( db , p -> zErrMsg ) ; 
line 57737: p -> zErrMsg = u . ci . pVtab -> zErrMsg ; 
line 57738: u . ci . pVtab -> zErrMsg = 0 ; 
line 57739: if ( rc == SQLITE_OK ) { 
line 57740: u . ci . res = u . ci . pModule -> xEof ( u . ci . pCur -> pVtabCursor ) ; 
line 57741: } 
line 57742: if ( sqlite3SafetyOn ( db ) ) goto abort_due_to_misuse ; 
line 57744: if ( ! u . ci . res ) { 
line 57746: pc = pOp -> p2 - 1 ; 
line 57747: } 
line 57748: break ; 
line 57749: } 
line 57750: # endif 
line 57752: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 57759: case OP_VRename : { 
line 57760: # if 0 
line 57761: sqlite3_vtab * pVtab ; 
line 57762: Mem * pName ; 
line 57763: # endif 
line 57765: u . cj . pVtab = pOp -> p4 . pVtab -> pVtab ; 
line 57766: u . cj . pName = & aMem [ pOp -> p1 ] ; 
line 57767: assert ( u . cj . pVtab -> pModule -> xRename ) ; 
line 57768: REGISTER_TRACE ( pOp -> p1 , u . cj . pName ) ; 
line 57769: assert ( u . cj . pName -> flags & MEM_Str ) ; 
line 57770: if ( sqlite3SafetyOff ( db ) ) goto abort_due_to_misuse ; 
line 57771: rc = u . cj . pVtab -> pModule -> xRename ( u . cj . pVtab , u . cj . pName -> z ) ; 
line 57772: sqlite3DbFree ( db , p -> zErrMsg ) ; 
line 57773: p -> zErrMsg = u . cj . pVtab -> zErrMsg ; 
line 57774: u . cj . pVtab -> zErrMsg = 0 ; 
line 57775: if ( sqlite3SafetyOn ( db ) ) goto abort_due_to_misuse ; 
line 57777: break ; 
line 57778: } 
line 57779: # endif 
line 57781: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 57805: case OP_VUpdate : { 
line 57806: # if 0 
line 57807: sqlite3_vtab * pVtab ; 
line 57808: sqlite3_module * pModule ; 
line 57809: int nArg ; 
line 57810: int i ; 
line 57811: sqlite_int64 rowid ; 
line 57812: Mem * * apArg ; 
line 57813: Mem * pX ; 
line 57814: # endif 
line 57816: u . ck . pVtab = pOp -> p4 . pVtab -> pVtab ; 
line 57817: u . ck . pModule = ( sqlite3_module * ) u . ck . pVtab -> pModule ; 
line 57818: u . ck . nArg = pOp -> p2 ; 
line 57819: assert ( pOp -> p4type == P4_VTAB ) ; 
line 57820: if ( ALWAYS ( u . ck . pModule -> xUpdate ) ) { 
line 57821: u . ck . apArg = p -> apArg ; 
line 57822: u . ck . pX = & aMem [ pOp -> p3 ] ; 
line 57823: for ( u . ck . i = 0 ; u . ck . i < u . ck . nArg ; u . ck . i ++ ) { 
line 57824: sqlite3VdbeMemStoreType ( u . ck . pX ) ; 
line 57825: u . ck . apArg [ u . ck . i ] = u . ck . pX ; 
line 57826: u . ck . pX ++ ; 
line 57827: } 
line 57828: if ( sqlite3SafetyOff ( db ) ) goto abort_due_to_misuse ; 
line 57829: rc = u . ck . pModule -> xUpdate ( u . ck . pVtab , u . ck . nArg , u . ck . apArg , & u . ck . rowid ) ; 
line 57830: sqlite3DbFree ( db , p -> zErrMsg ) ; 
line 57831: p -> zErrMsg = u . ck . pVtab -> zErrMsg ; 
line 57832: u . ck . pVtab -> zErrMsg = 0 ; 
line 57833: if ( sqlite3SafetyOn ( db ) ) goto abort_due_to_misuse ; 
line 57834: if ( rc == SQLITE_OK && pOp -> p1 ) { 
line 57835: assert ( u . ck . nArg > 1 && u . ck . apArg [ 0 ] && ( u . ck . apArg [ 0 ] -> flags & MEM_Null ) ) ; 
line 57836: db -> lastRowid = u . ck . rowid ; 
line 57837: } 
line 57838: p -> nChange ++ ; 
line 57839: } 
line 57840: break ; 
line 57841: } 
line 57842: # endif 
line 57844: # ifndef SQLITE_OMIT_PAGER_PRAGMAS 
line 57849: case OP_Pagecount : { 
line 57850: # if 0 
line 57851: int p1 ; 
line 57852: int nPage ; 
line 57853: Pager * pPager ; 
line 57854: # endif 
line 57856: u . cl . p1 = pOp -> p1 ; 
line 57857: u . cl . pPager = sqlite3BtreePager ( db -> aDb [ u . cl . p1 ] . pBt ) ; 
line 57858: rc = sqlite3PagerPagecount ( u . cl . pPager , & u . cl . nPage ) ; 
line 57862: if ( ALWAYS ( rc == SQLITE_OK ) ) { 
line 57863: pOut -> u . i = u . cl . nPage ; 
line 57864: } 
line 57865: break ; 
line 57866: } 
line 57867: # endif 
line 57869: # ifndef SQLITE_OMIT_TRACE 
line 57875: case OP_Trace : { 
line 57876: # if 0 
line 57877: char * zTrace ; 
line 57878: # endif 
line 57880: u . cm . zTrace = ( pOp -> p4 . z ? pOp -> p4 . z : p -> zSql ) ; 
line 57881: if ( u . cm . zTrace ) { 
line 57882: if ( db -> xTrace ) { 
line 57883: char * z = sqlite3VdbeExpandSql ( p , u . cm . zTrace ) ; 
line 57884: db -> xTrace ( db -> pTraceArg , z ) ; 
line 57885: sqlite3DbFree ( db , z ) ; 
line 57886: } 
line 57887: # ifdef SQLITE_DEBUG 
line 57888: if ( ( db -> flags & SQLITE_SqlTrace ) != 0 ) { 
line 57889: sqlite3DebugPrintf ( "SQL-trace: %s\n" , u . cm . zTrace ) ; 
line 57890: } 
line 57891: # endif 
line 57892: } 
line 57893: break ; 
line 57894: } 
line 57895: # endif 
line 57909: default : { 
line 57910: break ; 
line 57911: } 
line 57919: } 
line 57921: # ifdef VDBE_PROFILE 
line 57922: { 
line 57923: u64 elapsed = sqlite3Hwtime ( ) - start ; 
line 57924: pOp -> cycles += elapsed ; 
line 57925: pOp -> cnt ++ ; 
line 57926: # if 0 
line 57927: fprintf ( stdout , "%10llu " , elapsed ) ; 
line 57928: sqlite3VdbePrintOp ( stdout , origPc , & aOp [ origPc ] ) ; 
line 57929: # endif 
line 57930: } 
line 57931: # endif 
line 57938: # ifndef NDEBUG 
line 57939: assert ( pc >= - 1 && pc < p -> nOp ) ; 
line 57941: # ifdef SQLITE_DEBUG 
line 57942: if ( p -> trace ) { 
line 57943: if ( rc != 0 ) fprintf ( p -> trace , "rc=%d\n" , rc ) ; 
line 57944: if ( pOp -> opflags & ( OPFLG_OUT2_PRERELEASE | OPFLG_OUT2 ) ) { 
line 57945: registerTrace ( p -> trace , pOp -> p2 , & aMem [ pOp -> p2 ] ) ; 
line 57946: } 
line 57947: if ( pOp -> opflags & OPFLG_OUT3 ) { 
line 57948: registerTrace ( p -> trace , pOp -> p3 , & aMem [ pOp -> p3 ] ) ; 
line 57949: } 
line 57950: } 
line 57951: # endif 
line 57952: # endif 
line 57953: } 
line 57958: vdbe_error_halt : 
line 57959: assert ( rc ) ; 
line 57960: p -> rc = rc ; 
line 57961: sqlite3VdbeHalt ( p ) ; 
line 57962: if ( rc == SQLITE_IOERR_NOMEM ) db -> mallocFailed = 1 ; 
line 57963: rc = SQLITE_ERROR ; 
line 57964: if ( resetSchemaOnFault ) sqlite3ResetInternalSchema ( db , 0 ) ; 
line 57969: vdbe_return : 
line 57970: sqlite3BtreeMutexArrayLeave ( & p -> aMutex ) ; 
line 57971: return rc ; 
line 57976: too_big : 
line 57977: sqlite3SetString ( & p -> zErrMsg , db , "string or blob too big" ) ; 
line 57978: rc = SQLITE_TOOBIG ; 
line 57979: goto vdbe_error_halt ; 
line 57983: no_mem : 
line 57984: db -> mallocFailed = 1 ; 
line 57985: sqlite3SetString ( & p -> zErrMsg , db , "out of memory" ) ; 
line 57986: rc = SQLITE_NOMEM ; 
line 57987: goto vdbe_error_halt ; 
line 57991: abort_due_to_misuse : 
line 57992: rc = SQLITE_MISUSE ; 
line 57998: abort_due_to_error : 
line 57999: assert ( p -> zErrMsg == 0 ) ; 
line 58000: if ( db -> mallocFailed ) rc = SQLITE_NOMEM ; 
line 58001: if ( rc != SQLITE_IOERR_NOMEM ) { 
line 58002: sqlite3SetString ( & p -> zErrMsg , db , "%s" , sqlite3ErrStr ( rc ) ) ; 
line 58003: } 
line 58004: goto vdbe_error_halt ; 
line 58009: abort_due_to_interrupt : 
line 58010: assert ( db -> u1 . isInterrupted ) ; 
line 58011: rc = SQLITE_INTERRUPT ; 
line 58012: p -> rc = rc ; 
line 58013: sqlite3SetString ( & p -> zErrMsg , db , "%s" , sqlite3ErrStr ( rc ) ) ; 
line 58014: goto vdbe_error_halt ; 
line 58015: } 
line 58035: # ifndef SQLITE_OMIT_INCRBLOB 
line 58040: typedef struct Incrblob Incrblob ; 
line 58041: struct Incrblob { 
line 58042: int flags ; 
line 58043: int nByte ; 
line 58044: int iOffset ; 
line 58045: BtCursor * pCsr ; 
line 58046: sqlite3_stmt * pStmt ; 
line 58047: sqlite3 * db ; 
line 58048: } ; 
line 58053: SQLITE_API int sqlite3_blob_open ( 
line 58054: sqlite3 * db , 
line 58055: const char * zDb , 
line 58056: const char * zTable , 
line 58057: const char * zColumn , 
line 58058: sqlite_int64 iRow , 
line 58059: int flags , 
line 58060: sqlite3_blob * * ppBlob 
line 58061: ) { 
line 58062: int nAttempt = 0 ; 
line 58063: int iCol ; 
line 58080: static const VdbeOpList openBlob [ ] = { 
line 58081: { OP_Transaction , 0 , 0 , 0 } , 
line 58082: { OP_VerifyCookie , 0 , 0 , 0 } , 
line 58083: { OP_TableLock , 0 , 0 , 0 } , 
line 58086: { OP_OpenRead , 0 , 0 , 0 } , 
line 58087: { OP_OpenWrite , 0 , 0 , 0 } , 
line 58089: { OP_Variable , 1 , 1 , 1 } , 
line 58090: { OP_NotExists , 0 , 9 , 1 } , 
line 58091: { OP_Column , 0 , 0 , 1 } , 
line 58092: { OP_ResultRow , 1 , 0 , 0 } , 
line 58093: { OP_Close , 0 , 0 , 0 } , 
line 58094: { OP_Halt , 0 , 0 , 0 } , 
line 58095: } ; 
line 58097: Vdbe * v = 0 ; 
line 58098: int rc = SQLITE_OK ; 
line 58099: char * zErr = 0 ; 
line 58100: Table * pTab ; 
line 58101: Parse * pParse ; 
line 58103: * ppBlob = 0 ; 
line 58104: sqlite3_mutex_enter ( db -> mutex ) ; 
line 58105: pParse = sqlite3StackAllocRaw ( db , sizeof ( * pParse ) ) ; 
line 58106: if ( pParse == 0 ) { 
line 58107: rc = SQLITE_NOMEM ; 
line 58108: goto blob_open_out ; 
line 58109: } 
line 58110: do { 
line 58111: memset ( pParse , 0 , sizeof ( Parse ) ) ; 
line 58112: pParse -> db = db ; 
line 58114: if ( sqlite3SafetyOn ( db ) ) { 
line 58115: sqlite3DbFree ( db , zErr ) ; 
line 58116: sqlite3StackFree ( db , pParse ) ; 
line 58117: sqlite3_mutex_leave ( db -> mutex ) ; 
line 58118: return SQLITE_MISUSE ; 
line 58119: } 
line 58121: sqlite3BtreeEnterAll ( db ) ; 
line 58122: pTab = sqlite3LocateTable ( pParse , 0 , zTable , zDb ) ; 
line 58123: if ( pTab && IsVirtual ( pTab ) ) { 
line 58124: pTab = 0 ; 
line 58125: sqlite3ErrorMsg ( pParse , "cannot open virtual table: %s" , zTable ) ; 
line 58126: } 
line 58127: # ifndef SQLITE_OMIT_VIEW 
line 58128: if ( pTab && pTab -> pSelect ) { 
line 58129: pTab = 0 ; 
line 58130: sqlite3ErrorMsg ( pParse , "cannot open view: %s" , zTable ) ; 
line 58131: } 
line 58132: # endif 
line 58133: if ( ! pTab ) { 
line 58134: if ( pParse -> zErrMsg ) { 
line 58135: sqlite3DbFree ( db , zErr ) ; 
line 58136: zErr = pParse -> zErrMsg ; 
line 58137: pParse -> zErrMsg = 0 ; 
line 58138: } 
line 58139: rc = SQLITE_ERROR ; 
line 58140: ( void ) sqlite3SafetyOff ( db ) ; 
line 58141: sqlite3BtreeLeaveAll ( db ) ; 
line 58142: goto blob_open_out ; 
line 58143: } 
line 58146: for ( iCol = 0 ; iCol < pTab -> nCol ; iCol ++ ) { 
line 58147: if ( sqlite3StrICmp ( pTab -> aCol [ iCol ] . zName , zColumn ) == 0 ) { 
line 58148: break ; 
line 58149: } 
line 58150: } 
line 58151: if ( iCol == pTab -> nCol ) { 
line 58152: sqlite3DbFree ( db , zErr ) ; 
line 58153: zErr = sqlite3MPrintf ( db , "no such column: \"%s\"" , zColumn ) ; 
line 58154: rc = SQLITE_ERROR ; 
line 58155: ( void ) sqlite3SafetyOff ( db ) ; 
line 58156: sqlite3BtreeLeaveAll ( db ) ; 
line 58157: goto blob_open_out ; 
line 58158: } 
line 58164: if ( flags ) { 
line 58165: const char * zFault = 0 ; 
line 58166: Index * pIdx ; 
line 58167: # ifndef SQLITE_OMIT_FOREIGN_KEY 
line 58168: if ( db -> flags & SQLITE_ForeignKeys ) { 
line 58173: FKey * pFKey ; 
line 58174: for ( pFKey = pTab -> pFKey ; pFKey ; pFKey = pFKey -> pNextFrom ) { 
line 58175: int j ; 
line 58176: for ( j = 0 ; j < pFKey -> nCol ; j ++ ) { 
line 58177: if ( pFKey -> aCol [ j ] . iFrom == iCol ) { 
line 58178: zFault = "foreign key" ; 
line 58179: } 
line 58180: } 
line 58181: } 
line 58182: } 
line 58183: # endif 
line 58184: for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { 
line 58185: int j ; 
line 58186: for ( j = 0 ; j < pIdx -> nColumn ; j ++ ) { 
line 58187: if ( pIdx -> aiColumn [ j ] == iCol ) { 
line 58188: zFault = "indexed" ; 
line 58189: } 
line 58190: } 
line 58191: } 
line 58192: if ( zFault ) { 
line 58193: sqlite3DbFree ( db , zErr ) ; 
line 58194: zErr = sqlite3MPrintf ( db , "cannot open %s column for writing" , zFault ) ; 
line 58195: rc = SQLITE_ERROR ; 
line 58196: ( void ) sqlite3SafetyOff ( db ) ; 
line 58197: sqlite3BtreeLeaveAll ( db ) ; 
line 58198: goto blob_open_out ; 
line 58199: } 
line 58200: } 
line 58202: v = sqlite3VdbeCreate ( db ) ; 
line 58203: if ( v ) { 
line 58204: int iDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; 
line 58205: sqlite3VdbeAddOpList ( v , sizeof ( openBlob ) / sizeof ( VdbeOpList ) , openBlob ) ; 
line 58206: flags = !! flags ; 
line 58209: sqlite3VdbeChangeP1 ( v , 0 , iDb ) ; 
line 58210: sqlite3VdbeChangeP2 ( v , 0 , flags ) ; 
line 58213: sqlite3VdbeChangeP1 ( v , 1 , iDb ) ; 
line 58214: sqlite3VdbeChangeP2 ( v , 1 , pTab -> pSchema -> schema_cookie ) ; 
line 58217: sqlite3VdbeUsesBtree ( v , iDb ) ; 
line 58220: sqlite3VdbeChangeP1 ( v , 2 , iDb ) ; 
line 58221: sqlite3VdbeChangeP2 ( v , 2 , pTab -> tnum ) ; 
line 58222: sqlite3VdbeChangeP3 ( v , 2 , flags ) ; 
line 58223: sqlite3VdbeChangeP4 ( v , 2 , pTab -> zName , P4_TRANSIENT ) ; 
line 58227: sqlite3VdbeChangeToNoop ( v , 4 - flags , 1 ) ; 
line 58228: sqlite3VdbeChangeP2 ( v , 3 + flags , pTab -> tnum ) ; 
line 58229: sqlite3VdbeChangeP3 ( v , 3 + flags , iDb ) ; 
line 58238: sqlite3VdbeChangeP4 ( v , 3 + flags , SQLITE_INT_TO_PTR ( pTab -> nCol + 1 ) , P4_INT32 ) ; 
line 58239: sqlite3VdbeChangeP2 ( v , 7 , pTab -> nCol ) ; 
line 58240: if ( ! db -> mallocFailed ) { 
line 58241: sqlite3VdbeMakeReady ( v , 1 , 1 , 1 , 0 , 0 , 0 ) ; 
line 58242: } 
line 58243: } 
line 58245: sqlite3BtreeLeaveAll ( db ) ; 
line 58246: rc = sqlite3SafetyOff ( db ) ; 
line 58247: if ( NEVER ( rc != SQLITE_OK ) || db -> mallocFailed ) { 
line 58248: goto blob_open_out ; 
line 58249: } 
line 58251: sqlite3_bind_int64 ( ( sqlite3_stmt * ) v , 1 , iRow ) ; 
line 58252: rc = sqlite3_step ( ( sqlite3_stmt * ) v ) ; 
line 58253: if ( rc != SQLITE_ROW ) { 
line 58254: nAttempt ++ ; 
line 58255: rc = sqlite3_finalize ( ( sqlite3_stmt * ) v ) ; 
line 58256: sqlite3DbFree ( db , zErr ) ; 
line 58257: zErr = sqlite3MPrintf ( db , sqlite3_errmsg ( db ) ) ; 
line 58258: v = 0 ; 
line 58259: } 
line 58260: } while ( nAttempt < 5 && rc == SQLITE_SCHEMA ) ; 
line 58262: if ( rc == SQLITE_ROW ) { 
line 58267: Incrblob * pBlob ; 
line 58268: u32 type = v -> apCsr [ 0 ] -> aType [ iCol ] ; 
line 58270: if ( type < 12 ) { 
line 58271: sqlite3DbFree ( db , zErr ) ; 
line 58272: zErr = sqlite3MPrintf ( db , "cannot open value of type %s" , 
line 58273: type == 0 ? "null" : type == 7 ? "real" : "integer" 
line 58274: ) ; 
line 58275: rc = SQLITE_ERROR ; 
line 58276: goto blob_open_out ; 
line 58277: } 
line 58278: pBlob = ( Incrblob * ) sqlite3DbMallocZero ( db , sizeof ( Incrblob ) ) ; 
line 58279: if ( db -> mallocFailed ) { 
line 58280: sqlite3DbFree ( db , pBlob ) ; 
line 58281: goto blob_open_out ; 
line 58282: } 
line 58283: pBlob -> flags = flags ; 
line 58284: pBlob -> pCsr = v -> apCsr [ 0 ] -> pCursor ; 
line 58285: sqlite3BtreeEnterCursor ( pBlob -> pCsr ) ; 
line 58286: sqlite3BtreeCacheOverflow ( pBlob -> pCsr ) ; 
line 58287: sqlite3BtreeLeaveCursor ( pBlob -> pCsr ) ; 
line 58288: pBlob -> pStmt = ( sqlite3_stmt * ) v ; 
line 58289: pBlob -> iOffset = v -> apCsr [ 0 ] -> aOffset [ iCol ] ; 
line 58290: pBlob -> nByte = sqlite3VdbeSerialTypeLen ( type ) ; 
line 58291: pBlob -> db = db ; 
line 58292: * ppBlob = ( sqlite3_blob * ) pBlob ; 
line 58293: rc = SQLITE_OK ; 
line 58294: } else if ( rc == SQLITE_OK ) { 
line 58295: sqlite3DbFree ( db , zErr ) ; 
line 58296: zErr = sqlite3MPrintf ( db , "no such rowid: %lld" , iRow ) ; 
line 58297: rc = SQLITE_ERROR ; 
line 58298: } 
line 58300: blob_open_out : 
line 58301: if ( v && ( rc != SQLITE_OK || db -> mallocFailed ) ) { 
line 58302: sqlite3VdbeFinalize ( v ) ; 
line 58303: } 
line 58304: sqlite3Error ( db , rc , zErr ) ; 
line 58305: sqlite3DbFree ( db , zErr ) ; 
line 58306: sqlite3StackFree ( db , pParse ) ; 
line 58307: rc = sqlite3ApiExit ( db , rc ) ; 
line 58308: sqlite3_mutex_leave ( db -> mutex ) ; 
line 58309: return rc ; 
line 58310: } 
line 58316: SQLITE_API int sqlite3_blob_close ( sqlite3_blob * pBlob ) { 
line 58317: Incrblob * p = ( Incrblob * ) pBlob ; 
line 58318: int rc ; 
line 58319: sqlite3 * db ; 
line 58321: if ( p ) { 
line 58322: db = p -> db ; 
line 58323: sqlite3_mutex_enter ( db -> mutex ) ; 
line 58324: rc = sqlite3_finalize ( p -> pStmt ) ; 
line 58325: sqlite3DbFree ( db , p ) ; 
line 58326: sqlite3_mutex_leave ( db -> mutex ) ; 
line 58327: } else { 
line 58328: rc = SQLITE_OK ; 
line 58329: } 
line 58330: return rc ; 
line 58331: } 
line 58336: static int blobReadWrite ( 
line 58337: sqlite3_blob * pBlob , 
line 58338: void * z , 
line 58339: int n , 
line 58340: int iOffset , 
line 58341: int ( * xCall ) ( BtCursor * , u32 , u32 , void * ) 
line 58342: ) { 
line 58343: int rc ; 
line 58344: Incrblob * p = ( Incrblob * ) pBlob ; 
line 58345: Vdbe * v ; 
line 58346: sqlite3 * db ; 
line 58348: if ( p == 0 ) return SQLITE_MISUSE ; 
line 58349: db = p -> db ; 
line 58350: sqlite3_mutex_enter ( db -> mutex ) ; 
line 58351: v = ( Vdbe * ) p -> pStmt ; 
line 58353: if ( n < 0 || iOffset < 0 || ( iOffset + n ) > p -> nByte ) { 
line 58355: rc = SQLITE_ERROR ; 
line 58356: sqlite3Error ( db , SQLITE_ERROR , 0 ) ; 
line 58357: } else if ( v == 0 ) { 
line 58361: rc = SQLITE_ABORT ; 
line 58362: } else { 
line 58366: assert ( db == v -> db ) ; 
line 58367: sqlite3BtreeEnterCursor ( p -> pCsr ) ; 
line 58368: rc = xCall ( p -> pCsr , iOffset + p -> iOffset , n , z ) ; 
line 58369: sqlite3BtreeLeaveCursor ( p -> pCsr ) ; 
line 58370: if ( rc == SQLITE_ABORT ) { 
line 58371: sqlite3VdbeFinalize ( v ) ; 
line 58372: p -> pStmt = 0 ; 
line 58373: } else { 
line 58374: db -> errCode = rc ; 
line 58375: v -> rc = rc ; 
line 58376: } 
line 58377: } 
line 58378: rc = sqlite3ApiExit ( db , rc ) ; 
line 58379: sqlite3_mutex_leave ( db -> mutex ) ; 
line 58380: return rc ; 
line 58381: } 
line 58386: SQLITE_API int sqlite3_blob_read ( sqlite3_blob * pBlob , void * z , int n , int iOffset ) { 
line 58387: return blobReadWrite ( pBlob , z , n , iOffset , sqlite3BtreeData ) ; 
line 58388: } 
line 58393: SQLITE_API int sqlite3_blob_write ( sqlite3_blob * pBlob , const void * z , int n , int iOffset ) { 
line 58394: return blobReadWrite ( pBlob , ( void * ) z , n , iOffset , sqlite3BtreePutData ) ; 
line 58395: } 
line 58403: SQLITE_API int sqlite3_blob_bytes ( sqlite3_blob * pBlob ) { 
line 58404: Incrblob * p = ( Incrblob * ) pBlob ; 
line 58405: return p ? p -> nByte : 0 ; 
line 58406: } 
line 58408: # endif 
line 58438: # ifdef SQLITE_ENABLE_ATOMIC_WRITE 
line 58445: struct JournalFile { 
line 58446: sqlite3_io_methods * pMethod ; 
line 58447: int nBuf ; 
line 58448: char * zBuf ; 
line 58449: int iSize ; 
line 58450: int flags ; 
line 58451: sqlite3_vfs * pVfs ; 
line 58452: sqlite3_file * pReal ; 
line 58453: const char * zJournal ; 
line 58454: } ; 
line 58455: typedef struct JournalFile JournalFile ; 
line 58461: static int createFile ( JournalFile * p ) { 
line 58462: int rc = SQLITE_OK ; 
line 58463: if ( ! p -> pReal ) { 
line 58464: sqlite3_file * pReal = ( sqlite3_file * ) & p [ 1 ] ; 
line 58465: rc = sqlite3OsOpen ( p -> pVfs , p -> zJournal , pReal , p -> flags , 0 ) ; 
line 58466: if ( rc == SQLITE_OK ) { 
line 58467: p -> pReal = pReal ; 
line 58468: if ( p -> iSize > 0 ) { 
line 58469: assert ( p -> iSize <= p -> nBuf ) ; 
line 58470: rc = sqlite3OsWrite ( p -> pReal , p -> zBuf , p -> iSize , 0 ) ; 
line 58471: } 
line 58472: } 
line 58473: } 
line 58474: return rc ; 
line 58475: } 
line 58480: static int jrnlClose ( sqlite3_file * pJfd ) { 
line 58481: JournalFile * p = ( JournalFile * ) pJfd ; 
line 58482: if ( p -> pReal ) { 
line 58483: sqlite3OsClose ( p -> pReal ) ; 
line 58484: } 
line 58485: sqlite3_free ( p -> zBuf ) ; 
line 58486: return SQLITE_OK ; 
line 58487: } 
line 58492: static int jrnlRead ( 
line 58493: sqlite3_file * pJfd , 
line 58494: void * zBuf , 
line 58495: int iAmt , 
line 58496: sqlite_int64 iOfst 
line 58497: ) { 
line 58498: int rc = SQLITE_OK ; 
line 58499: JournalFile * p = ( JournalFile * ) pJfd ; 
line 58500: if ( p -> pReal ) { 
line 58501: rc = sqlite3OsRead ( p -> pReal , zBuf , iAmt , iOfst ) ; 
line 58502: } else if ( ( iAmt + iOfst ) > p -> iSize ) { 
line 58503: rc = SQLITE_IOERR_SHORT_READ ; 
line 58504: } else { 
line 58505: memcpy ( zBuf , & p -> zBuf [ iOfst ] , iAmt ) ; 
line 58506: } 
line 58507: return rc ; 
line 58508: } 
line 58513: static int jrnlWrite ( 
line 58514: sqlite3_file * pJfd , 
line 58515: const void * zBuf , 
line 58516: int iAmt , 
line 58517: sqlite_int64 iOfst 
line 58518: ) { 
line 58519: int rc = SQLITE_OK ; 
line 58520: JournalFile * p = ( JournalFile * ) pJfd ; 
line 58521: if ( ! p -> pReal && ( iOfst + iAmt ) > p -> nBuf ) { 
line 58522: rc = createFile ( p ) ; 
line 58523: } 
line 58524: if ( rc == SQLITE_OK ) { 
line 58525: if ( p -> pReal ) { 
line 58526: rc = sqlite3OsWrite ( p -> pReal , zBuf , iAmt , iOfst ) ; 
line 58527: } else { 
line 58528: memcpy ( & p -> zBuf [ iOfst ] , zBuf , iAmt ) ; 
line 58529: if ( p -> iSize < ( iOfst + iAmt ) ) { 
line 58530: p -> iSize = ( iOfst + iAmt ) ; 
line 58531: } 
line 58532: } 
line 58533: } 
line 58534: return rc ; 
line 58535: } 
line 58540: static int jrnlTruncate ( sqlite3_file * pJfd , sqlite_int64 size ) { 
line 58541: int rc = SQLITE_OK ; 
line 58542: JournalFile * p = ( JournalFile * ) pJfd ; 
line 58543: if ( p -> pReal ) { 
line 58544: rc = sqlite3OsTruncate ( p -> pReal , size ) ; 
line 58545: } else if ( size < p -> iSize ) { 
line 58546: p -> iSize = size ; 
line 58547: } 
line 58548: return rc ; 
line 58549: } 
line 58554: static int jrnlSync ( sqlite3_file * pJfd , int flags ) { 
line 58555: int rc ; 
line 58556: JournalFile * p = ( JournalFile * ) pJfd ; 
line 58557: if ( p -> pReal ) { 
line 58558: rc = sqlite3OsSync ( p -> pReal , flags ) ; 
line 58559: } else { 
line 58560: rc = SQLITE_OK ; 
line 58561: } 
line 58562: return rc ; 
line 58563: } 
line 58568: static int jrnlFileSize ( sqlite3_file * pJfd , sqlite_int64 * pSize ) { 
line 58569: int rc = SQLITE_OK ; 
line 58570: JournalFile * p = ( JournalFile * ) pJfd ; 
line 58571: if ( p -> pReal ) { 
line 58572: rc = sqlite3OsFileSize ( p -> pReal , pSize ) ; 
line 58573: } else { 
line 58574: * pSize = ( sqlite_int64 ) p -> iSize ; 
line 58575: } 
line 58576: return rc ; 
line 58577: } 
line 58582: static struct sqlite3_io_methods JournalFileMethods = { 
line 58583: 1 , 
line 58584: jrnlClose , 
line 58585: jrnlRead , 
line 58586: jrnlWrite , 
line 58587: jrnlTruncate , 
line 58588: jrnlSync , 
line 58589: jrnlFileSize , 
line 58590: 0 , 
line 58591: 0 , 
line 58592: 0 , 
line 58593: 0 , 
line 58594: 0 , 
line 58595: 0 
line 58596: } ; 
line 58601: SQLITE_PRIVATE int sqlite3JournalOpen ( 
line 58602: sqlite3_vfs * pVfs , 
line 58603: const char * zName , 
line 58604: sqlite3_file * pJfd , 
line 58605: int flags , 
line 58606: int nBuf 
line 58607: ) { 
line 58608: JournalFile * p = ( JournalFile * ) pJfd ; 
line 58609: memset ( p , 0 , sqlite3JournalSize ( pVfs ) ) ; 
line 58610: if ( nBuf > 0 ) { 
line 58611: p -> zBuf = sqlite3MallocZero ( nBuf ) ; 
line 58612: if ( ! p -> zBuf ) { 
line 58613: return SQLITE_NOMEM ; 
line 58614: } 
line 58615: } else { 
line 58616: return sqlite3OsOpen ( pVfs , zName , pJfd , flags , 0 ) ; 
line 58617: } 
line 58618: p -> pMethod = & JournalFileMethods ; 
line 58619: p -> nBuf = nBuf ; 
line 58620: p -> flags = flags ; 
line 58621: p -> zJournal = zName ; 
line 58622: p -> pVfs = pVfs ; 
line 58623: return SQLITE_OK ; 
line 58624: } 
line 58630: SQLITE_PRIVATE int sqlite3JournalCreate ( sqlite3_file * p ) { 
line 58631: if ( p -> pMethods != & JournalFileMethods ) { 
line 58632: return SQLITE_OK ; 
line 58633: } 
line 58634: return createFile ( ( JournalFile * ) p ) ; 
line 58635: } 
line 58641: SQLITE_PRIVATE int sqlite3JournalSize ( sqlite3_vfs * pVfs ) { 
line 58642: return ( pVfs -> szOsFile + sizeof ( JournalFile ) ) ; 
line 58643: } 
line 58644: # endif 
line 58666: typedef struct MemJournal MemJournal ; 
line 58667: typedef struct FilePoint FilePoint ; 
line 58668: typedef struct FileChunk FileChunk ; 
line 58678: # define JOURNAL_CHUNKSIZE ( ( int ) ( 1024 - sizeof ( FileChunk * ) ) ) 
line 58682: # ifndef MIN 
line 58683: # define MIN ( x , y ) ( ( x ) < ( y ) ? ( x ) : ( y ) ) 
line 58684: # endif 
line 58689: struct FileChunk { 
line 58690: FileChunk * pNext ; 
line 58691: u8 zChunk [ JOURNAL_CHUNKSIZE ] ; 
line 58692: } ; 
line 58698: struct FilePoint { 
line 58699: sqlite3_int64 iOffset ; 
line 58700: FileChunk * pChunk ; 
line 58701: } ; 
line 58707: struct MemJournal { 
line 58708: sqlite3_io_methods * pMethod ; 
line 58709: FileChunk * pFirst ; 
line 58710: FilePoint endpoint ; 
line 58711: FilePoint readpoint ; 
line 58712: } ; 
line 58718: static int memjrnlRead ( 
line 58719: sqlite3_file * pJfd , 
line 58720: void * zBuf , 
line 58721: int iAmt , 
line 58722: sqlite_int64 iOfst 
line 58723: ) { 
line 58724: MemJournal * p = ( MemJournal * ) pJfd ; 
line 58725: u8 * zOut = zBuf ; 
line 58726: int nRead = iAmt ; 
line 58727: int iChunkOffset ; 
line 58728: FileChunk * pChunk ; 
line 58731: assert ( iOfst + iAmt <= p -> endpoint . iOffset ) ; 
line 58733: if ( p -> readpoint . iOffset != iOfst || iOfst == 0 ) { 
line 58734: sqlite3_int64 iOff = 0 ; 
line 58735: for ( pChunk = p -> pFirst ; 
line 58736: ALWAYS ( pChunk ) && ( iOff + JOURNAL_CHUNKSIZE ) <= iOfst ; 
line 58737: pChunk = pChunk -> pNext 
line 58738: ) { 
line 58739: iOff += JOURNAL_CHUNKSIZE ; 
line 58740: } 
line 58741: } else { 
line 58742: pChunk = p -> readpoint . pChunk ; 
line 58743: } 
line 58745: iChunkOffset = ( int ) ( iOfst % JOURNAL_CHUNKSIZE ) ; 
line 58746: do { 
line 58747: int iSpace = JOURNAL_CHUNKSIZE - iChunkOffset ; 
line 58748: int nCopy = MIN ( nRead , ( JOURNAL_CHUNKSIZE - iChunkOffset ) ) ; 
line 58749: memcpy ( zOut , & pChunk -> zChunk [ iChunkOffset ] , nCopy ) ; 
line 58750: zOut += nCopy ; 
line 58751: nRead -= iSpace ; 
line 58752: iChunkOffset = 0 ; 
line 58753: } while ( nRead >= 0 && ( pChunk = pChunk -> pNext ) != 0 && nRead > 0 ) ; 
line 58754: p -> readpoint . iOffset = iOfst + iAmt ; 
line 58755: p -> readpoint . pChunk = pChunk ; 
line 58757: return SQLITE_OK ; 
line 58758: } 
line 58763: static int memjrnlWrite ( 
line 58764: sqlite3_file * pJfd , 
line 58765: const void * zBuf , 
line 58766: int iAmt , 
line 58767: sqlite_int64 iOfst 
line 58768: ) { 
line 58769: MemJournal * p = ( MemJournal * ) pJfd ; 
line 58770: int nWrite = iAmt ; 
line 58771: u8 * zWrite = ( u8 * ) zBuf ; 
line 58776: assert ( iOfst == p -> endpoint . iOffset ) ; 
line 58777: UNUSED_PARAMETER ( iOfst ) ; 
line 58779: while ( nWrite > 0 ) { 
line 58780: FileChunk * pChunk = p -> endpoint . pChunk ; 
line 58781: int iChunkOffset = ( int ) ( p -> endpoint . iOffset % JOURNAL_CHUNKSIZE ) ; 
line 58782: int iSpace = MIN ( nWrite , JOURNAL_CHUNKSIZE - iChunkOffset ) ; 
line 58784: if ( iChunkOffset == 0 ) { 
line 58786: FileChunk * pNew = sqlite3_malloc ( sizeof ( FileChunk ) ) ; 
line 58787: if ( ! pNew ) { 
line 58788: return SQLITE_IOERR_NOMEM ; 
line 58789: } 
line 58790: pNew -> pNext = 0 ; 
line 58791: if ( pChunk ) { 
line 58792: assert ( p -> pFirst ) ; 
line 58793: pChunk -> pNext = pNew ; 
line 58794: } else { 
line 58795: assert ( ! p -> pFirst ) ; 
line 58796: p -> pFirst = pNew ; 
line 58797: } 
line 58798: p -> endpoint . pChunk = pNew ; 
line 58799: } 
line 58801: memcpy ( & p -> endpoint . pChunk -> zChunk [ iChunkOffset ] , zWrite , iSpace ) ; 
line 58802: zWrite += iSpace ; 
line 58803: nWrite -= iSpace ; 
line 58804: p -> endpoint . iOffset += iSpace ; 
line 58805: } 
line 58807: return SQLITE_OK ; 
line 58808: } 
line 58813: static int memjrnlTruncate ( sqlite3_file * pJfd , sqlite_int64 size ) { 
line 58814: MemJournal * p = ( MemJournal * ) pJfd ; 
line 58815: FileChunk * pChunk ; 
line 58816: assert ( size == 0 ) ; 
line 58817: UNUSED_PARAMETER ( size ) ; 
line 58818: pChunk = p -> pFirst ; 
line 58819: while ( pChunk ) { 
line 58820: FileChunk * pTmp = pChunk ; 
line 58821: pChunk = pChunk -> pNext ; 
line 58822: sqlite3_free ( pTmp ) ; 
line 58823: } 
line 58824: sqlite3MemJournalOpen ( pJfd ) ; 
line 58825: return SQLITE_OK ; 
line 58826: } 
line 58831: static int memjrnlClose ( sqlite3_file * pJfd ) { 
line 58832: memjrnlTruncate ( pJfd , 0 ) ; 
line 58833: return SQLITE_OK ; 
line 58834: } 
line 58845: static int memjrnlSync ( sqlite3_file * NotUsed , int NotUsed2 ) { 
line 58846: UNUSED_PARAMETER2 ( NotUsed , NotUsed2 ) ; 
line 58847: assert ( 0 ) ; 
line 58848: return SQLITE_OK ; 
line 58849: } 
line 58854: static int memjrnlFileSize ( sqlite3_file * pJfd , sqlite_int64 * pSize ) { 
line 58855: MemJournal * p = ( MemJournal * ) pJfd ; 
line 58856: * pSize = ( sqlite_int64 ) p -> endpoint . iOffset ; 
line 58857: return SQLITE_OK ; 
line 58858: } 
line 58863: static struct sqlite3_io_methods MemJournalMethods = { 
line 58864: 1 , 
line 58865: memjrnlClose , 
line 58866: memjrnlRead , 
line 58867: memjrnlWrite , 
line 58868: memjrnlTruncate , 
line 58869: memjrnlSync , 
line 58870: memjrnlFileSize , 
line 58871: 0 , 
line 58872: 0 , 
line 58873: 0 , 
line 58874: 0 , 
line 58875: 0 , 
line 58876: 0 
line 58877: } ; 
line 58882: SQLITE_PRIVATE void sqlite3MemJournalOpen ( sqlite3_file * pJfd ) { 
line 58883: MemJournal * p = ( MemJournal * ) pJfd ; 
line 58884: assert ( EIGHT_BYTE_ALIGNMENT ( p ) ) ; 
line 58885: memset ( p , 0 , sqlite3MemJournalSize ( ) ) ; 
line 58886: p -> pMethod = & MemJournalMethods ; 
line 58887: } 
line 58893: SQLITE_PRIVATE int sqlite3IsMemJournal ( sqlite3_file * pJfd ) { 
line 58894: return pJfd -> pMethods == & MemJournalMethods ; 
line 58895: } 
line 58901: SQLITE_PRIVATE int sqlite3MemJournalSize ( void ) { 
line 58902: return sizeof ( MemJournal ) ; 
line 58903: } 
line 58942: SQLITE_PRIVATE int sqlite3WalkExpr ( Walker * pWalker , Expr * pExpr ) { 
line 58943: int rc ; 
line 58944: if ( pExpr == 0 ) return WRC_Continue ; 
line 58945: testcase ( ExprHasProperty ( pExpr , EP_TokenOnly ) ) ; 
line 58946: testcase ( ExprHasProperty ( pExpr , EP_Reduced ) ) ; 
line 58947: rc = pWalker -> xExprCallback ( pWalker , pExpr ) ; 
line 58948: if ( rc == WRC_Continue 
line 58949: && ! ExprHasAnyProperty ( pExpr , EP_TokenOnly ) ) { 
line 58950: if ( sqlite3WalkExpr ( pWalker , pExpr -> pLeft ) ) return WRC_Abort ; 
line 58951: if ( sqlite3WalkExpr ( pWalker , pExpr -> pRight ) ) return WRC_Abort ; 
line 58952: if ( ExprHasProperty ( pExpr , EP_xIsSelect ) ) { 
line 58953: if ( sqlite3WalkSelect ( pWalker , pExpr -> x . pSelect ) ) return WRC_Abort ; 
line 58954: } else { 
line 58955: if ( sqlite3WalkExprList ( pWalker , pExpr -> x . pList ) ) return WRC_Abort ; 
line 58956: } 
line 58957: } 
line 58958: return rc & WRC_Abort ; 
line 58959: } 
line 58965: SQLITE_PRIVATE int sqlite3WalkExprList ( Walker * pWalker , ExprList * p ) { 
line 58966: int i ; 
line 58967: struct ExprList_item * pItem ; 
line 58968: if ( p ) { 
line 58969: for ( i = p -> nExpr , pItem = p -> a ; i > 0 ; i -- , pItem ++ ) { 
line 58970: if ( sqlite3WalkExpr ( pWalker , pItem -> pExpr ) ) return WRC_Abort ; 
line 58971: } 
line 58972: } 
line 58973: return WRC_Continue ; 
line 58974: } 
line 58982: SQLITE_PRIVATE int sqlite3WalkSelectExpr ( Walker * pWalker , Select * p ) { 
line 58983: if ( sqlite3WalkExprList ( pWalker , p -> pEList ) ) return WRC_Abort ; 
line 58984: if ( sqlite3WalkExpr ( pWalker , p -> pWhere ) ) return WRC_Abort ; 
line 58985: if ( sqlite3WalkExprList ( pWalker , p -> pGroupBy ) ) return WRC_Abort ; 
line 58986: if ( sqlite3WalkExpr ( pWalker , p -> pHaving ) ) return WRC_Abort ; 
line 58987: if ( sqlite3WalkExprList ( pWalker , p -> pOrderBy ) ) return WRC_Abort ; 
line 58988: if ( sqlite3WalkExpr ( pWalker , p -> pLimit ) ) return WRC_Abort ; 
line 58989: if ( sqlite3WalkExpr ( pWalker , p -> pOffset ) ) return WRC_Abort ; 
line 58990: return WRC_Continue ; 
line 58991: } 
line 59000: SQLITE_PRIVATE int sqlite3WalkSelectFrom ( Walker * pWalker , Select * p ) { 
line 59001: SrcList * pSrc ; 
line 59002: int i ; 
line 59003: struct SrcList_item * pItem ; 
line 59005: pSrc = p -> pSrc ; 
line 59006: if ( ALWAYS ( pSrc ) ) { 
line 59007: for ( i = pSrc -> nSrc , pItem = pSrc -> a ; i > 0 ; i -- , pItem ++ ) { 
line 59008: if ( sqlite3WalkSelect ( pWalker , pItem -> pSelect ) ) { 
line 59009: return WRC_Abort ; 
line 59010: } 
line 59011: } 
line 59012: } 
line 59013: return WRC_Continue ; 
line 59014: } 
line 59027: SQLITE_PRIVATE int sqlite3WalkSelect ( Walker * pWalker , Select * p ) { 
line 59028: int rc ; 
line 59029: if ( p == 0 || pWalker -> xSelectCallback == 0 ) return WRC_Continue ; 
line 59030: rc = WRC_Continue ; 
line 59031: while ( p ) { 
line 59032: rc = pWalker -> xSelectCallback ( pWalker , p ) ; 
line 59033: if ( rc ) break ; 
line 59034: if ( sqlite3WalkSelectExpr ( pWalker , p ) ) return WRC_Abort ; 
line 59035: if ( sqlite3WalkSelectFrom ( pWalker , p ) ) return WRC_Abort ; 
line 59036: p = p -> pPrior ; 
line 59037: } 
line 59038: return rc & WRC_Abort ; 
line 59039: } 
line 59087: static void resolveAlias ( 
line 59088: Parse * pParse , 
line 59089: ExprList * pEList , 
line 59090: int iCol , 
line 59091: Expr * pExpr , 
line 59092: const char * zType 
line 59093: ) { 
line 59094: Expr * pOrig ; 
line 59095: Expr * pDup ; 
line 59096: sqlite3 * db ; 
line 59098: assert ( iCol >= 0 && iCol < pEList -> nExpr ) ; 
line 59099: pOrig = pEList -> a [ iCol ] . pExpr ; 
line 59100: assert ( pOrig != 0 ) ; 
line 59101: assert ( pOrig -> flags & EP_Resolved ) ; 
line 59102: db = pParse -> db ; 
line 59103: if ( pOrig -> op != TK_COLUMN && zType [ 0 ] != 'G' ) { 
line 59104: pDup = sqlite3ExprDup ( db , pOrig , 0 ) ; 
line 59105: pDup = sqlite3PExpr ( pParse , TK_AS , pDup , 0 , 0 ) ; 
line 59106: if ( pDup == 0 ) return ; 
line 59107: if ( pEList -> a [ iCol ] . iAlias == 0 ) { 
line 59108: pEList -> a [ iCol ] . iAlias = ( u16 ) ( ++ pParse -> nAlias ) ; 
line 59109: } 
line 59110: pDup -> iTable = pEList -> a [ iCol ] . iAlias ; 
line 59111: } else if ( ExprHasProperty ( pOrig , EP_IntValue ) || pOrig -> u . zToken == 0 ) { 
line 59112: pDup = sqlite3ExprDup ( db , pOrig , 0 ) ; 
line 59113: if ( pDup == 0 ) return ; 
line 59114: } else { 
line 59115: char * zToken = pOrig -> u . zToken ; 
line 59116: assert ( zToken != 0 ) ; 
line 59117: pOrig -> u . zToken = 0 ; 
line 59118: pDup = sqlite3ExprDup ( db , pOrig , 0 ) ; 
line 59119: pOrig -> u . zToken = zToken ; 
line 59120: if ( pDup == 0 ) return ; 
line 59121: assert ( ( pDup -> flags & ( EP_Reduced | EP_TokenOnly ) ) == 0 ) ; 
line 59122: pDup -> flags2 |= EP2_MallocedToken ; 
line 59123: pDup -> u . zToken = sqlite3DbStrDup ( db , zToken ) ; 
line 59124: } 
line 59125: if ( pExpr -> flags & EP_ExpCollate ) { 
line 59126: pDup -> pColl = pExpr -> pColl ; 
line 59127: pDup -> flags |= EP_ExpCollate ; 
line 59128: } 
line 59134: ExprSetProperty ( pExpr , EP_Static ) ; 
line 59135: sqlite3ExprDelete ( db , pExpr ) ; 
line 59136: memcpy ( pExpr , pDup , sizeof ( * pExpr ) ) ; 
line 59137: sqlite3DbFree ( db , pDup ) ; 
line 59138: } 
line 59167: static int lookupName ( 
line 59168: Parse * pParse , 
line 59169: const char * zDb , 
line 59170: const char * zTab , 
line 59171: const char * zCol , 
line 59172: NameContext * pNC , 
line 59173: Expr * pExpr 
line 59174: ) { 
line 59175: int i , j ; 
line 59176: int cnt = 0 ; 
line 59177: int cntTab = 0 ; 
line 59178: sqlite3 * db = pParse -> db ; 
line 59179: struct SrcList_item * pItem ; 
line 59180: struct SrcList_item * pMatch = 0 ; 
line 59181: NameContext * pTopNC = pNC ; 
line 59182: Schema * pSchema = 0 ; 
line 59183: int isTrigger = 0 ; 
line 59185: assert ( pNC ) ; 
line 59186: assert ( zCol ) ; 
line 59187: assert ( ~ ExprHasAnyProperty ( pExpr , EP_TokenOnly | EP_Reduced ) ) ; 
line 59190: pExpr -> iTable = - 1 ; 
line 59191: pExpr -> pTab = 0 ; 
line 59192: ExprSetIrreducible ( pExpr ) ; 
line 59195: while ( pNC && cnt == 0 ) { 
line 59196: ExprList * pEList ; 
line 59197: SrcList * pSrcList = pNC -> pSrcList ; 
line 59199: if ( pSrcList ) { 
line 59200: for ( i = 0 , pItem = pSrcList -> a ; i < pSrcList -> nSrc ; i ++ , pItem ++ ) { 
line 59201: Table * pTab ; 
line 59202: int iDb ; 
line 59203: Column * pCol ; 
line 59205: pTab = pItem -> pTab ; 
line 59206: assert ( pTab != 0 && pTab -> zName != 0 ) ; 
line 59207: iDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; 
line 59208: assert ( pTab -> nCol > 0 ) ; 
line 59209: if ( zTab ) { 
line 59210: if ( pItem -> zAlias ) { 
line 59211: char * zTabName = pItem -> zAlias ; 
line 59212: if ( sqlite3StrICmp ( zTabName , zTab ) != 0 ) continue ; 
line 59213: } else { 
line 59214: char * zTabName = pTab -> zName ; 
line 59215: if ( NEVER ( zTabName == 0 ) || sqlite3StrICmp ( zTabName , zTab ) != 0 ) { 
line 59216: continue ; 
line 59217: } 
line 59218: if ( zDb != 0 && sqlite3StrICmp ( db -> aDb [ iDb ] . zName , zDb ) != 0 ) { 
line 59219: continue ; 
line 59220: } 
line 59221: } 
line 59222: } 
line 59223: if ( 0 == ( cntTab ++ ) ) { 
line 59224: pExpr -> iTable = pItem -> iCursor ; 
line 59225: pExpr -> pTab = pTab ; 
line 59226: pSchema = pTab -> pSchema ; 
line 59227: pMatch = pItem ; 
line 59228: } 
line 59229: for ( j = 0 , pCol = pTab -> aCol ; j < pTab -> nCol ; j ++ , pCol ++ ) { 
line 59230: if ( sqlite3StrICmp ( pCol -> zName , zCol ) == 0 ) { 
line 59231: IdList * pUsing ; 
line 59232: cnt ++ ; 
line 59233: pExpr -> iTable = pItem -> iCursor ; 
line 59234: pExpr -> pTab = pTab ; 
line 59235: pMatch = pItem ; 
line 59236: pSchema = pTab -> pSchema ; 
line 59238: pExpr -> iColumn = j == pTab -> iPKey ? - 1 : ( i16 ) j ; 
line 59239: if ( i < pSrcList -> nSrc - 1 ) { 
line 59240: if ( pItem [ 1 ] . jointype & JT_NATURAL ) { 
line 59243: pItem ++ ; 
line 59244: i ++ ; 
line 59245: } else if ( ( pUsing = pItem [ 1 ] . pUsing ) != 0 ) { 
line 59249: int k ; 
line 59250: for ( k = 0 ; k < pUsing -> nId ; k ++ ) { 
line 59251: if ( sqlite3StrICmp ( pUsing -> a [ k ] . zName , zCol ) == 0 ) { 
line 59252: pItem ++ ; 
line 59253: i ++ ; 
line 59254: break ; 
line 59255: } 
line 59256: } 
line 59257: } 
line 59258: } 
line 59259: break ; 
line 59260: } 
line 59261: } 
line 59262: } 
line 59263: } 
line 59265: # ifndef SQLITE_OMIT_TRIGGER 
line 59269: if ( zDb == 0 && zTab != 0 && cnt == 0 && pParse -> pTriggerTab != 0 ) { 
line 59270: int op = pParse -> eTriggerOp ; 
line 59271: Table * pTab = 0 ; 
line 59272: assert ( op == TK_DELETE || op == TK_UPDATE || op == TK_INSERT ) ; 
line 59273: if ( op != TK_DELETE && sqlite3StrICmp ( "new" , zTab ) == 0 ) { 
line 59274: pExpr -> iTable = 1 ; 
line 59275: pTab = pParse -> pTriggerTab ; 
line 59276: } else if ( op != TK_INSERT && sqlite3StrICmp ( "old" , zTab ) == 0 ) { 
line 59277: pExpr -> iTable = 0 ; 
line 59278: pTab = pParse -> pTriggerTab ; 
line 59279: } 
line 59281: if ( pTab ) { 
line 59282: int iCol ; 
line 59283: pSchema = pTab -> pSchema ; 
line 59284: cntTab ++ ; 
line 59285: for ( iCol = 0 ; iCol < pTab -> nCol ; iCol ++ ) { 
line 59286: Column * pCol = & pTab -> aCol [ iCol ] ; 
line 59287: if ( sqlite3StrICmp ( pCol -> zName , zCol ) == 0 ) { 
line 59288: if ( iCol == pTab -> iPKey ) { 
line 59289: iCol = - 1 ; 
line 59290: } 
line 59291: break ; 
line 59292: } 
line 59293: } 
line 59294: if ( iCol >= pTab -> nCol && sqlite3IsRowid ( zCol ) ) { 
line 59295: iCol = - 1 ; 
line 59296: } 
line 59297: if ( iCol < pTab -> nCol ) { 
line 59298: cnt ++ ; 
line 59299: if ( iCol < 0 ) { 
line 59300: pExpr -> affinity = SQLITE_AFF_INTEGER ; 
line 59301: } else if ( pExpr -> iTable == 0 ) { 
line 59302: testcase ( iCol == 31 ) ; 
line 59303: testcase ( iCol == 32 ) ; 
line 59304: pParse -> oldmask |= ( iCol >= 32 ? 0xffffffff : ( ( ( u32 ) 1 ) << iCol ) ) ; 
line 59305: } else { 
line 59306: testcase ( iCol == 31 ) ; 
line 59307: testcase ( iCol == 32 ) ; 
line 59308: pParse -> newmask |= ( iCol >= 32 ? 0xffffffff : ( ( ( u32 ) 1 ) << iCol ) ) ; 
line 59309: } 
line 59310: pExpr -> iColumn = ( i16 ) iCol ; 
line 59311: pExpr -> pTab = pTab ; 
line 59312: isTrigger = 1 ; 
line 59313: } 
line 59314: } 
line 59315: } 
line 59316: # endif 
line 59321: if ( cnt == 0 && cntTab == 1 && sqlite3IsRowid ( zCol ) ) { 
line 59322: cnt = 1 ; 
line 59323: pExpr -> iColumn = - 1 ; 
line 59324: pExpr -> affinity = SQLITE_AFF_INTEGER ; 
line 59325: } 
line 59339: if ( cnt == 0 && ( pEList = pNC -> pEList ) != 0 && zTab == 0 ) { 
line 59340: for ( j = 0 ; j < pEList -> nExpr ; j ++ ) { 
line 59341: char * zAs = pEList -> a [ j ] . zName ; 
line 59342: if ( zAs != 0 && sqlite3StrICmp ( zAs , zCol ) == 0 ) { 
line 59343: Expr * pOrig ; 
line 59344: assert ( pExpr -> pLeft == 0 && pExpr -> pRight == 0 ) ; 
line 59345: assert ( pExpr -> x . pList == 0 ) ; 
line 59346: assert ( pExpr -> x . pSelect == 0 ) ; 
line 59347: pOrig = pEList -> a [ j ] . pExpr ; 
line 59348: if ( ! pNC -> allowAgg && ExprHasProperty ( pOrig , EP_Agg ) ) { 
line 59349: sqlite3ErrorMsg ( pParse , "misuse of aliased aggregate %s" , zAs ) ; 
line 59350: return WRC_Abort ; 
line 59351: } 
line 59352: resolveAlias ( pParse , pEList , j , pExpr , "" ) ; 
line 59353: cnt = 1 ; 
line 59354: pMatch = 0 ; 
line 59355: assert ( zTab == 0 && zDb == 0 ) ; 
line 59356: goto lookupname_end ; 
line 59357: } 
line 59358: } 
line 59359: } 
line 59364: if ( cnt == 0 ) { 
line 59365: pNC = pNC -> pNext ; 
line 59366: } 
line 59367: } 
line 59379: if ( cnt == 0 && zTab == 0 && ExprHasProperty ( pExpr , EP_DblQuoted ) ) { 
line 59380: pExpr -> op = TK_STRING ; 
line 59381: pExpr -> pTab = 0 ; 
line 59382: return WRC_Prune ; 
line 59383: } 
line 59389: if ( cnt != 1 ) { 
line 59390: const char * zErr ; 
line 59391: zErr = cnt == 0 ? "no such column" : "ambiguous column name" ; 
line 59392: if ( zDb ) { 
line 59393: sqlite3ErrorMsg ( pParse , "%s: %s.%s.%s" , zErr , zDb , zTab , zCol ) ; 
line 59394: } else if ( zTab ) { 
line 59395: sqlite3ErrorMsg ( pParse , "%s: %s.%s" , zErr , zTab , zCol ) ; 
line 59396: } else { 
line 59397: sqlite3ErrorMsg ( pParse , "%s: %s" , zErr , zCol ) ; 
line 59398: } 
line 59399: pTopNC -> nErr ++ ; 
line 59400: } 
line 59408: if ( pExpr -> iColumn >= 0 && pMatch != 0 ) { 
line 59409: int n = pExpr -> iColumn ; 
line 59410: testcase ( n == BMS - 1 ) ; 
line 59411: if ( n >= BMS ) { 
line 59412: n = BMS - 1 ; 
line 59413: } 
line 59414: assert ( pMatch -> iCursor == pExpr -> iTable ) ; 
line 59415: pMatch -> colUsed |= ( ( Bitmask ) 1 ) << n ; 
line 59416: } 
line 59420: sqlite3ExprDelete ( db , pExpr -> pLeft ) ; 
line 59421: pExpr -> pLeft = 0 ; 
line 59422: sqlite3ExprDelete ( db , pExpr -> pRight ) ; 
line 59423: pExpr -> pRight = 0 ; 
line 59424: pExpr -> op = ( isTrigger ? TK_TRIGGER : TK_COLUMN ) ; 
line 59425: lookupname_end : 
line 59426: if ( cnt == 1 ) { 
line 59427: assert ( pNC != 0 ) ; 
line 59428: sqlite3AuthRead ( pParse , pExpr , pSchema , pNC -> pSrcList ) ; 
line 59431: for ( ; ; ) { 
line 59432: assert ( pTopNC != 0 ) ; 
line 59433: pTopNC -> nRef ++ ; 
line 59434: if ( pTopNC == pNC ) break ; 
line 59435: pTopNC = pTopNC -> pNext ; 
line 59436: } 
line 59437: return WRC_Prune ; 
line 59438: } else { 
line 59439: return WRC_Abort ; 
line 59440: } 
line 59441: } 
line 59447: SQLITE_PRIVATE Expr * sqlite3CreateColumnExpr ( sqlite3 * db , SrcList * pSrc , int iSrc , int iCol ) { 
line 59448: Expr * p = sqlite3ExprAlloc ( db , TK_COLUMN , 0 , 0 ) ; 
line 59449: if ( p ) { 
line 59450: struct SrcList_item * pItem = & pSrc -> a [ iSrc ] ; 
line 59451: p -> pTab = pItem -> pTab ; 
line 59452: p -> iTable = pItem -> iCursor ; 
line 59453: if ( p -> pTab -> iPKey == iCol ) { 
line 59454: p -> iColumn = - 1 ; 
line 59455: } else { 
line 59456: p -> iColumn = ( ynVar ) iCol ; 
line 59457: pItem -> colUsed |= ( ( Bitmask ) 1 ) << ( iCol >= BMS ? BMS - 1 : iCol ) ; 
line 59458: } 
line 59459: ExprSetProperty ( p , EP_Resolved ) ; 
line 59460: } 
line 59461: return p ; 
line 59462: } 
line 59475: static int resolveExprStep ( Walker * pWalker , Expr * pExpr ) { 
line 59476: NameContext * pNC ; 
line 59477: Parse * pParse ; 
line 59479: pNC = pWalker -> u . pNC ; 
line 59480: assert ( pNC != 0 ) ; 
line 59481: pParse = pNC -> pParse ; 
line 59482: assert ( pParse == pWalker -> pParse ) ; 
line 59484: if ( ExprHasAnyProperty ( pExpr , EP_Resolved ) ) return WRC_Prune ; 
line 59485: ExprSetProperty ( pExpr , EP_Resolved ) ; 
line 59486: # ifndef NDEBUG 
line 59487: if ( pNC -> pSrcList && pNC -> pSrcList -> nAlloc > 0 ) { 
line 59488: SrcList * pSrcList = pNC -> pSrcList ; 
line 59489: int i ; 
line 59490: for ( i = 0 ; i < pNC -> pSrcList -> nSrc ; i ++ ) { 
line 59491: assert ( pSrcList -> a [ i ] . iCursor >= 0 && pSrcList -> a [ i ] . iCursor < pParse -> nTab ) ; 
line 59492: } 
line 59493: } 
line 59494: # endif 
line 59495: switch ( pExpr -> op ) { 
line 59497: # if defined ( SQLITE_ENABLE_UPDATE_DELETE_LIMIT ) && ! defined ( SQLITE_OMIT_SUBQUERY ) 
line 59502: case TK_ROW : { 
line 59503: SrcList * pSrcList = pNC -> pSrcList ; 
line 59504: struct SrcList_item * pItem ; 
line 59505: assert ( pSrcList && pSrcList -> nSrc == 1 ) ; 
line 59506: pItem = pSrcList -> a ; 
line 59507: pExpr -> op = TK_COLUMN ; 
line 59508: pExpr -> pTab = pItem -> pTab ; 
line 59509: pExpr -> iTable = pItem -> iCursor ; 
line 59510: pExpr -> iColumn = - 1 ; 
line 59511: pExpr -> affinity = SQLITE_AFF_INTEGER ; 
line 59512: break ; 
line 59513: } 
line 59514: # endif 
line 59518: case TK_ID : { 
line 59519: return lookupName ( pParse , 0 , 0 , pExpr -> u . zToken , pNC , pExpr ) ; 
line 59520: } 
line 59525: case TK_DOT : { 
line 59526: const char * zColumn ; 
line 59527: const char * zTable ; 
line 59528: const char * zDb ; 
line 59529: Expr * pRight ; 
line 59532: pRight = pExpr -> pRight ; 
line 59533: if ( pRight -> op == TK_ID ) { 
line 59534: zDb = 0 ; 
line 59535: zTable = pExpr -> pLeft -> u . zToken ; 
line 59536: zColumn = pRight -> u . zToken ; 
line 59537: } else { 
line 59538: assert ( pRight -> op == TK_DOT ) ; 
line 59539: zDb = pExpr -> pLeft -> u . zToken ; 
line 59540: zTable = pRight -> pLeft -> u . zToken ; 
line 59541: zColumn = pRight -> pRight -> u . zToken ; 
line 59542: } 
line 59543: return lookupName ( pParse , zDb , zTable , zColumn , pNC , pExpr ) ; 
line 59544: } 
line 59548: case TK_CONST_FUNC : 
line 59549: case TK_FUNCTION : { 
line 59550: ExprList * pList = pExpr -> x . pList ; 
line 59551: int n = pList ? pList -> nExpr : 0 ; 
line 59552: int no_such_func = 0 ; 
line 59553: int wrong_num_args = 0 ; 
line 59554: int is_agg = 0 ; 
line 59555: int auth ; 
line 59556: int nId ; 
line 59557: const char * zId ; 
line 59558: FuncDef * pDef ; 
line 59559: u8 enc = ENC ( pParse -> db ) ; 
line 59561: testcase ( pExpr -> op == TK_CONST_FUNC ) ; 
line 59562: assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ) ; 
line 59563: zId = pExpr -> u . zToken ; 
line 59564: nId = sqlite3Strlen30 ( zId ) ; 
line 59565: pDef = sqlite3FindFunction ( pParse -> db , zId , nId , n , enc , 0 ) ; 
line 59566: if ( pDef == 0 ) { 
line 59567: pDef = sqlite3FindFunction ( pParse -> db , zId , nId , - 1 , enc , 0 ) ; 
line 59568: if ( pDef == 0 ) { 
line 59569: no_such_func = 1 ; 
line 59570: } else { 
line 59571: wrong_num_args = 1 ; 
line 59572: } 
line 59573: } else { 
line 59574: is_agg = pDef -> xFunc == 0 ; 
line 59575: } 
line 59576: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 59577: if ( pDef ) { 
line 59578: auth = sqlite3AuthCheck ( pParse , SQLITE_FUNCTION , 0 , pDef -> zName , 0 ) ; 
line 59579: if ( auth != SQLITE_OK ) { 
line 59580: if ( auth == SQLITE_DENY ) { 
line 59581: sqlite3ErrorMsg ( pParse , "not authorized to use function: %s" , 
line 59582: pDef -> zName ) ; 
line 59583: pNC -> nErr ++ ; 
line 59584: } 
line 59585: pExpr -> op = TK_NULL ; 
line 59586: return WRC_Prune ; 
line 59587: } 
line 59588: } 
line 59589: # endif 
line 59590: if ( is_agg && ! pNC -> allowAgg ) { 
line 59591: sqlite3ErrorMsg ( pParse , "misuse of aggregate function %.*s()" , nId , zId ) ; 
line 59592: pNC -> nErr ++ ; 
line 59593: is_agg = 0 ; 
line 59594: } else if ( no_such_func ) { 
line 59595: sqlite3ErrorMsg ( pParse , "no such function: %.*s" , nId , zId ) ; 
line 59596: pNC -> nErr ++ ; 
line 59597: } else if ( wrong_num_args ) { 
line 59598: sqlite3ErrorMsg ( pParse , "wrong number of arguments to function %.*s()" , 
line 59599: nId , zId ) ; 
line 59600: pNC -> nErr ++ ; 
line 59601: } 
line 59602: if ( is_agg ) { 
line 59603: pExpr -> op = TK_AGG_FUNCTION ; 
line 59604: pNC -> hasAgg = 1 ; 
line 59605: } 
line 59606: if ( is_agg ) pNC -> allowAgg = 0 ; 
line 59607: sqlite3WalkExprList ( pWalker , pList ) ; 
line 59608: if ( is_agg ) pNC -> allowAgg = 1 ; 
line 59612: return WRC_Prune ; 
line 59613: } 
line 59614: # ifndef SQLITE_OMIT_SUBQUERY 
line 59615: case TK_SELECT : 
line 59616: case TK_EXISTS : testcase ( pExpr -> op == TK_EXISTS ) ; 
line 59617: # endif 
line 59618: case TK_IN : { 
line 59619: testcase ( pExpr -> op == TK_IN ) ; 
line 59620: if ( ExprHasProperty ( pExpr , EP_xIsSelect ) ) { 
line 59621: int nRef = pNC -> nRef ; 
line 59622: # ifndef SQLITE_OMIT_CHECK 
line 59623: if ( pNC -> isCheck ) { 
line 59624: sqlite3ErrorMsg ( pParse , "subqueries prohibited in CHECK constraints" ) ; 
line 59625: } 
line 59626: # endif 
line 59627: sqlite3WalkSelect ( pWalker , pExpr -> x . pSelect ) ; 
line 59628: assert ( pNC -> nRef >= nRef ) ; 
line 59629: if ( nRef != pNC -> nRef ) { 
line 59630: ExprSetProperty ( pExpr , EP_VarSelect ) ; 
line 59631: } 
line 59632: } 
line 59633: break ; 
line 59634: } 
line 59635: # ifndef SQLITE_OMIT_CHECK 
line 59636: case TK_VARIABLE : { 
line 59637: if ( pNC -> isCheck ) { 
line 59638: sqlite3ErrorMsg ( pParse , "parameters prohibited in CHECK constraints" ) ; 
line 59639: } 
line 59640: break ; 
line 59641: } 
line 59642: # endif 
line 59643: } 
line 59644: return ( pParse -> nErr || pParse -> db -> mallocFailed ) ? WRC_Abort : WRC_Continue ; 
line 59645: } 
line 59659: static int resolveAsName ( 
line 59660: Parse * pParse , 
line 59661: ExprList * pEList , 
line 59662: Expr * pE 
line 59663: ) { 
line 59664: int i ; 
line 59666: UNUSED_PARAMETER ( pParse ) ; 
line 59668: if ( pE -> op == TK_ID ) { 
line 59669: char * zCol = pE -> u . zToken ; 
line 59670: for ( i = 0 ; i < pEList -> nExpr ; i ++ ) { 
line 59671: char * zAs = pEList -> a [ i ] . zName ; 
line 59672: if ( zAs != 0 && sqlite3StrICmp ( zAs , zCol ) == 0 ) { 
line 59673: return i + 1 ; 
line 59674: } 
line 59675: } 
line 59676: } 
line 59677: return 0 ; 
line 59678: } 
line 59698: static int resolveOrderByTermToExprList ( 
line 59699: Parse * pParse , 
line 59700: Select * pSelect , 
line 59701: Expr * pE 
line 59702: ) { 
line 59703: int i ; 
line 59704: ExprList * pEList ; 
line 59705: NameContext nc ; 
line 59707: assert ( sqlite3ExprIsInteger ( pE , & i ) == 0 ) ; 
line 59708: pEList = pSelect -> pEList ; 
line 59712: memset ( & nc , 0 , sizeof ( nc ) ) ; 
line 59713: nc . pParse = pParse ; 
line 59714: nc . pSrcList = pSelect -> pSrc ; 
line 59715: nc . pEList = pEList ; 
line 59716: nc . allowAgg = 1 ; 
line 59717: nc . nErr = 0 ; 
line 59718: if ( sqlite3ResolveExprNames ( & nc , pE ) ) { 
line 59719: sqlite3ErrorClear ( pParse ) ; 
line 59720: return 0 ; 
line 59721: } 
line 59727: for ( i = 0 ; i < pEList -> nExpr ; i ++ ) { 
line 59728: if ( sqlite3ExprCompare ( pEList -> a [ i ] . pExpr , pE ) ) { 
line 59729: return i + 1 ; 
line 59730: } 
line 59731: } 
line 59734: return 0 ; 
line 59735: } 
line 59740: static void resolveOutOfRangeError ( 
line 59741: Parse * pParse , 
line 59742: const char * zType , 
line 59743: int i , 
line 59744: int mx 
line 59745: ) { 
line 59746: sqlite3ErrorMsg ( pParse , 
line 59747: "%r %s BY term out of range - should be " 
line 59748: "between 1 and %d" , i , zType , mx ) ; 
line 59749: } 
line 59766: static int resolveCompoundOrderBy ( 
line 59767: Parse * pParse , 
line 59768: Select * pSelect 
line 59769: ) { 
line 59770: int i ; 
line 59771: ExprList * pOrderBy ; 
line 59772: ExprList * pEList ; 
line 59773: sqlite3 * db ; 
line 59774: int moreToDo = 1 ; 
line 59776: pOrderBy = pSelect -> pOrderBy ; 
line 59777: if ( pOrderBy == 0 ) return 0 ; 
line 59778: db = pParse -> db ; 
line 59779: # if SQLITE_MAX_COLUMN 
line 59780: if ( pOrderBy -> nExpr > db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) { 
line 59781: sqlite3ErrorMsg ( pParse , "too many terms in ORDER BY clause" ) ; 
line 59782: return 1 ; 
line 59783: } 
line 59784: # endif 
line 59785: for ( i = 0 ; i < pOrderBy -> nExpr ; i ++ ) { 
line 59786: pOrderBy -> a [ i ] . done = 0 ; 
line 59787: } 
line 59788: pSelect -> pNext = 0 ; 
line 59789: while ( pSelect -> pPrior ) { 
line 59790: pSelect -> pPrior -> pNext = pSelect ; 
line 59791: pSelect = pSelect -> pPrior ; 
line 59792: } 
line 59793: while ( pSelect && moreToDo ) { 
line 59794: struct ExprList_item * pItem ; 
line 59795: moreToDo = 0 ; 
line 59796: pEList = pSelect -> pEList ; 
line 59797: assert ( pEList != 0 ) ; 
line 59798: for ( i = 0 , pItem = pOrderBy -> a ; i < pOrderBy -> nExpr ; i ++ , pItem ++ ) { 
line 59799: int iCol = - 1 ; 
line 59800: Expr * pE , * pDup ; 
line 59801: if ( pItem -> done ) continue ; 
line 59802: pE = pItem -> pExpr ; 
line 59803: if ( sqlite3ExprIsInteger ( pE , & iCol ) ) { 
line 59804: if ( iCol <= 0 || iCol > pEList -> nExpr ) { 
line 59805: resolveOutOfRangeError ( pParse , "ORDER" , i + 1 , pEList -> nExpr ) ; 
line 59806: return 1 ; 
line 59807: } 
line 59808: } else { 
line 59809: iCol = resolveAsName ( pParse , pEList , pE ) ; 
line 59810: if ( iCol == 0 ) { 
line 59811: pDup = sqlite3ExprDup ( db , pE , 0 ) ; 
line 59812: if ( ! db -> mallocFailed ) { 
line 59813: assert ( pDup ) ; 
line 59814: iCol = resolveOrderByTermToExprList ( pParse , pSelect , pDup ) ; 
line 59815: } 
line 59816: sqlite3ExprDelete ( db , pDup ) ; 
line 59817: } 
line 59818: } 
line 59819: if ( iCol > 0 ) { 
line 59820: CollSeq * pColl = pE -> pColl ; 
line 59821: int flags = pE -> flags & EP_ExpCollate ; 
line 59822: sqlite3ExprDelete ( db , pE ) ; 
line 59823: pItem -> pExpr = pE = sqlite3Expr ( db , TK_INTEGER , 0 ) ; 
line 59824: if ( pE == 0 ) return 1 ; 
line 59825: pE -> pColl = pColl ; 
line 59826: pE -> flags |= EP_IntValue | flags ; 
line 59827: pE -> u . iValue = iCol ; 
line 59828: pItem -> iCol = ( u16 ) iCol ; 
line 59829: pItem -> done = 1 ; 
line 59830: } else { 
line 59831: moreToDo = 1 ; 
line 59832: } 
line 59833: } 
line 59834: pSelect = pSelect -> pNext ; 
line 59835: } 
line 59836: for ( i = 0 ; i < pOrderBy -> nExpr ; i ++ ) { 
line 59837: if ( pOrderBy -> a [ i ] . done == 0 ) { 
line 59838: sqlite3ErrorMsg ( pParse , "%r ORDER BY term does not match any " 
line 59839: "column in the result set" , i + 1 ) ; 
line 59840: return 1 ; 
line 59841: } 
line 59842: } 
line 59843: return 0 ; 
line 59844: } 
line 59856: SQLITE_PRIVATE int sqlite3ResolveOrderGroupBy ( 
line 59857: Parse * pParse , 
line 59858: Select * pSelect , 
line 59859: ExprList * pOrderBy , 
line 59860: const char * zType 
line 59861: ) { 
line 59862: int i ; 
line 59863: sqlite3 * db = pParse -> db ; 
line 59864: ExprList * pEList ; 
line 59865: struct ExprList_item * pItem ; 
line 59867: if ( pOrderBy == 0 || pParse -> db -> mallocFailed ) return 0 ; 
line 59868: # if SQLITE_MAX_COLUMN 
line 59869: if ( pOrderBy -> nExpr > db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) { 
line 59870: sqlite3ErrorMsg ( pParse , "too many terms in %s BY clause" , zType ) ; 
line 59871: return 1 ; 
line 59872: } 
line 59873: # endif 
line 59874: pEList = pSelect -> pEList ; 
line 59875: assert ( pEList != 0 ) ; 
line 59876: for ( i = 0 , pItem = pOrderBy -> a ; i < pOrderBy -> nExpr ; i ++ , pItem ++ ) { 
line 59877: if ( pItem -> iCol ) { 
line 59878: if ( pItem -> iCol > pEList -> nExpr ) { 
line 59879: resolveOutOfRangeError ( pParse , zType , i + 1 , pEList -> nExpr ) ; 
line 59880: return 1 ; 
line 59881: } 
line 59882: resolveAlias ( pParse , pEList , pItem -> iCol - 1 , pItem -> pExpr , zType ) ; 
line 59883: } 
line 59884: } 
line 59885: return 0 ; 
line 59886: } 
line 59906: static int resolveOrderGroupBy ( 
line 59907: NameContext * pNC , 
line 59908: Select * pSelect , 
line 59909: ExprList * pOrderBy , 
line 59910: const char * zType 
line 59911: ) { 
line 59912: int i ; 
line 59913: int iCol ; 
line 59914: struct ExprList_item * pItem ; 
line 59915: Parse * pParse ; 
line 59916: int nResult ; 
line 59918: if ( pOrderBy == 0 ) return 0 ; 
line 59919: nResult = pSelect -> pEList -> nExpr ; 
line 59920: pParse = pNC -> pParse ; 
line 59921: for ( i = 0 , pItem = pOrderBy -> a ; i < pOrderBy -> nExpr ; i ++ , pItem ++ ) { 
line 59922: Expr * pE = pItem -> pExpr ; 
line 59923: iCol = resolveAsName ( pParse , pSelect -> pEList , pE ) ; 
line 59924: if ( iCol > 0 ) { 
line 59929: pItem -> iCol = ( u16 ) iCol ; 
line 59930: continue ; 
line 59931: } 
line 59932: if ( sqlite3ExprIsInteger ( pE , & iCol ) ) { 
line 59936: if ( iCol < 1 ) { 
line 59937: resolveOutOfRangeError ( pParse , zType , i + 1 , nResult ) ; 
line 59938: return 1 ; 
line 59939: } 
line 59940: pItem -> iCol = ( u16 ) iCol ; 
line 59941: continue ; 
line 59942: } 
line 59945: pItem -> iCol = 0 ; 
line 59946: if ( sqlite3ResolveExprNames ( pNC , pE ) ) { 
line 59947: return 1 ; 
line 59948: } 
line 59949: } 
line 59950: return sqlite3ResolveOrderGroupBy ( pParse , pSelect , pOrderBy , zType ) ; 
line 59951: } 
line 59956: static int resolveSelectStep ( Walker * pWalker , Select * p ) { 
line 59957: NameContext * pOuterNC ; 
line 59958: NameContext sNC ; 
line 59959: int isCompound ; 
line 59960: int nCompound ; 
line 59961: Parse * pParse ; 
line 59962: ExprList * pEList ; 
line 59963: int i ; 
line 59964: ExprList * pGroupBy ; 
line 59965: Select * pLeftmost ; 
line 59966: sqlite3 * db ; 
line 59969: assert ( p != 0 ) ; 
line 59970: if ( p -> selFlags & SF_Resolved ) { 
line 59971: return WRC_Prune ; 
line 59972: } 
line 59973: pOuterNC = pWalker -> u . pNC ; 
line 59974: pParse = pWalker -> pParse ; 
line 59975: db = pParse -> db ; 
line 59985: if ( ( p -> selFlags & SF_Expanded ) == 0 ) { 
line 59986: sqlite3SelectPrep ( pParse , p , pOuterNC ) ; 
line 59987: return ( pParse -> nErr || db -> mallocFailed ) ? WRC_Abort : WRC_Prune ; 
line 59988: } 
line 59990: isCompound = p -> pPrior != 0 ; 
line 59991: nCompound = 0 ; 
line 59992: pLeftmost = p ; 
line 59993: while ( p ) { 
line 59994: assert ( ( p -> selFlags & SF_Expanded ) != 0 ) ; 
line 59995: assert ( ( p -> selFlags & SF_Resolved ) == 0 ) ; 
line 59996: p -> selFlags |= SF_Resolved ; 
line 60001: memset ( & sNC , 0 , sizeof ( sNC ) ) ; 
line 60002: sNC . pParse = pParse ; 
line 60003: if ( sqlite3ResolveExprNames ( & sNC , p -> pLimit ) || 
line 60004: sqlite3ResolveExprNames ( & sNC , p -> pOffset ) ) { 
line 60005: return WRC_Abort ; 
line 60006: } 
line 60011: sNC . allowAgg = 1 ; 
line 60012: sNC . pSrcList = p -> pSrc ; 
line 60013: sNC . pNext = pOuterNC ; 
line 60016: pEList = p -> pEList ; 
line 60017: assert ( pEList != 0 ) ; 
line 60018: for ( i = 0 ; i < pEList -> nExpr ; i ++ ) { 
line 60019: Expr * pX = pEList -> a [ i ] . pExpr ; 
line 60020: if ( sqlite3ResolveExprNames ( & sNC , pX ) ) { 
line 60021: return WRC_Abort ; 
line 60022: } 
line 60023: } 
line 60027: for ( i = 0 ; i < p -> pSrc -> nSrc ; i ++ ) { 
line 60028: struct SrcList_item * pItem = & p -> pSrc -> a [ i ] ; 
line 60029: if ( pItem -> pSelect ) { 
line 60030: const char * zSavedContext = pParse -> zAuthContext ; 
line 60031: if ( pItem -> zName ) pParse -> zAuthContext = pItem -> zName ; 
line 60032: sqlite3ResolveSelectNames ( pParse , pItem -> pSelect , pOuterNC ) ; 
line 60033: pParse -> zAuthContext = zSavedContext ; 
line 60034: if ( pParse -> nErr || db -> mallocFailed ) return WRC_Abort ; 
line 60035: } 
line 60036: } 
line 60041: assert ( ( p -> selFlags & SF_Aggregate ) == 0 ) ; 
line 60042: pGroupBy = p -> pGroupBy ; 
line 60043: if ( pGroupBy || sNC . hasAgg ) { 
line 60044: p -> selFlags |= SF_Aggregate ; 
line 60045: } else { 
line 60046: sNC . allowAgg = 0 ; 
line 60047: } 
line 60051: if ( p -> pHaving && ! pGroupBy ) { 
line 60052: sqlite3ErrorMsg ( pParse , "a GROUP BY clause is required before HAVING" ) ; 
line 60053: return WRC_Abort ; 
line 60054: } 
line 60064: sNC . pEList = p -> pEList ; 
line 60065: if ( sqlite3ResolveExprNames ( & sNC , p -> pWhere ) || 
line 60066: sqlite3ResolveExprNames ( & sNC , p -> pHaving ) 
line 60067: ) { 
line 60068: return WRC_Abort ; 
line 60069: } 
line 60074: sNC . pNext = 0 ; 
line 60075: sNC . allowAgg = 1 ; 
line 60082: if ( ! isCompound && resolveOrderGroupBy ( & sNC , p , p -> pOrderBy , "ORDER" ) ) { 
line 60083: return WRC_Abort ; 
line 60084: } 
line 60085: if ( db -> mallocFailed ) { 
line 60086: return WRC_Abort ; 
line 60087: } 
line 60092: if ( pGroupBy ) { 
line 60093: struct ExprList_item * pItem ; 
line 60095: if ( resolveOrderGroupBy ( & sNC , p , pGroupBy , "GROUP" ) || db -> mallocFailed ) { 
line 60096: return WRC_Abort ; 
line 60097: } 
line 60098: for ( i = 0 , pItem = pGroupBy -> a ; i < pGroupBy -> nExpr ; i ++ , pItem ++ ) { 
line 60099: if ( ExprHasProperty ( pItem -> pExpr , EP_Agg ) ) { 
line 60100: sqlite3ErrorMsg ( pParse , "aggregate functions are not allowed in " 
line 60101: "the GROUP BY clause" ) ; 
line 60102: return WRC_Abort ; 
line 60103: } 
line 60104: } 
line 60105: } 
line 60109: p = p -> pPrior ; 
line 60110: nCompound ++ ; 
line 60111: } 
line 60116: if ( isCompound && resolveCompoundOrderBy ( pParse , pLeftmost ) ) { 
line 60117: return WRC_Abort ; 
line 60118: } 
line 60120: return WRC_Prune ; 
line 60121: } 
line 60171: SQLITE_PRIVATE int sqlite3ResolveExprNames ( 
line 60172: NameContext * pNC , 
line 60173: Expr * pExpr 
line 60174: ) { 
line 60175: int savedHasAgg ; 
line 60176: Walker w ; 
line 60178: if ( pExpr == 0 ) return 0 ; 
line 60179: # if SQLITE_MAX_EXPR_DEPTH > 0 
line 60180: { 
line 60181: Parse * pParse = pNC -> pParse ; 
line 60182: if ( sqlite3ExprCheckHeight ( pParse , pExpr -> nHeight + pNC -> pParse -> nHeight ) ) { 
line 60183: return 1 ; 
line 60184: } 
line 60185: pParse -> nHeight += pExpr -> nHeight ; 
line 60186: } 
line 60187: # endif 
line 60188: savedHasAgg = pNC -> hasAgg ; 
line 60189: pNC -> hasAgg = 0 ; 
line 60190: w . xExprCallback = resolveExprStep ; 
line 60191: w . xSelectCallback = resolveSelectStep ; 
line 60192: w . pParse = pNC -> pParse ; 
line 60193: w . u . pNC = pNC ; 
line 60194: sqlite3WalkExpr ( & w , pExpr ) ; 
line 60195: # if SQLITE_MAX_EXPR_DEPTH > 0 
line 60196: pNC -> pParse -> nHeight -= pExpr -> nHeight ; 
line 60197: # endif 
line 60198: if ( pNC -> nErr > 0 || w . pParse -> nErr > 0 ) { 
line 60199: ExprSetProperty ( pExpr , EP_Error ) ; 
line 60200: } 
line 60201: if ( pNC -> hasAgg ) { 
line 60202: ExprSetProperty ( pExpr , EP_Agg ) ; 
line 60203: } else if ( savedHasAgg ) { 
line 60204: pNC -> hasAgg = 1 ; 
line 60205: } 
line 60206: return ExprHasProperty ( pExpr , EP_Error ) ; 
line 60207: } 
line 60222: SQLITE_PRIVATE void sqlite3ResolveSelectNames ( 
line 60223: Parse * pParse , 
line 60224: Select * p , 
line 60225: NameContext * pOuterNC 
line 60226: ) { 
line 60227: Walker w ; 
line 60229: assert ( p != 0 ) ; 
line 60230: w . xExprCallback = resolveExprStep ; 
line 60231: w . xSelectCallback = resolveSelectStep ; 
line 60232: w . pParse = pParse ; 
line 60233: w . u . pNC = pOuterNC ; 
line 60234: sqlite3WalkSelect ( & w , p ) ; 
line 60235: } 
line 60270: SQLITE_PRIVATE char sqlite3ExprAffinity ( Expr * pExpr ) { 
line 60271: int op = pExpr -> op ; 
line 60272: if ( op == TK_SELECT ) { 
line 60273: assert ( pExpr -> flags & EP_xIsSelect ) ; 
line 60274: return sqlite3ExprAffinity ( pExpr -> x . pSelect -> pEList -> a [ 0 ] . pExpr ) ; 
line 60275: } 
line 60276: # ifndef SQLITE_OMIT_CAST 
line 60277: if ( op == TK_CAST ) { 
line 60278: assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; 
line 60279: return sqlite3AffinityType ( pExpr -> u . zToken ) ; 
line 60280: } 
line 60281: # endif 
line 60282: if ( ( op == TK_AGG_COLUMN || op == TK_COLUMN || op == TK_REGISTER ) 
line 60283: && pExpr -> pTab != 0 
line 60284: ) { 
line 60287: int j = pExpr -> iColumn ; 
line 60288: if ( j < 0 ) return SQLITE_AFF_INTEGER ; 
line 60289: assert ( pExpr -> pTab && j < pExpr -> pTab -> nCol ) ; 
line 60290: return pExpr -> pTab -> aCol [ j ] . affinity ; 
line 60291: } 
line 60292: return pExpr -> affinity ; 
line 60293: } 
line 60302: SQLITE_PRIVATE Expr * sqlite3ExprSetColl ( Parse * pParse , Expr * pExpr , Token * pCollName ) { 
line 60303: char * zColl = 0 ; 
line 60304: CollSeq * pColl ; 
line 60305: sqlite3 * db = pParse -> db ; 
line 60306: zColl = sqlite3NameFromToken ( db , pCollName ) ; 
line 60307: if ( pExpr && zColl ) { 
line 60308: pColl = sqlite3LocateCollSeq ( pParse , zColl ) ; 
line 60309: if ( pColl ) { 
line 60310: pExpr -> pColl = pColl ; 
line 60311: pExpr -> flags |= EP_ExpCollate ; 
line 60312: } 
line 60313: } 
line 60314: sqlite3DbFree ( db , zColl ) ; 
line 60315: return pExpr ; 
line 60316: } 
line 60322: SQLITE_PRIVATE CollSeq * sqlite3ExprCollSeq ( Parse * pParse , Expr * pExpr ) { 
line 60323: CollSeq * pColl = 0 ; 
line 60324: Expr * p = pExpr ; 
line 60325: while ( ALWAYS ( p ) ) { 
line 60326: int op ; 
line 60327: pColl = p -> pColl ; 
line 60328: if ( pColl ) break ; 
line 60329: op = p -> op ; 
line 60330: if ( p -> pTab != 0 && ( 
line 60331: op == TK_AGG_COLUMN || op == TK_COLUMN || op == TK_REGISTER || op == TK_TRIGGER 
line 60332: ) ) { 
line 60335: const char * zColl ; 
line 60336: int j = p -> iColumn ; 
line 60337: if ( j >= 0 ) { 
line 60338: sqlite3 * db = pParse -> db ; 
line 60339: zColl = p -> pTab -> aCol [ j ] . zColl ; 
line 60340: pColl = sqlite3FindCollSeq ( db , ENC ( db ) , zColl , 0 ) ; 
line 60341: pExpr -> pColl = pColl ; 
line 60342: } 
line 60343: break ; 
line 60344: } 
line 60345: if ( op != TK_CAST && op != TK_UPLUS ) { 
line 60346: break ; 
line 60347: } 
line 60348: p = p -> pLeft ; 
line 60349: } 
line 60350: if ( sqlite3CheckCollSeq ( pParse , pColl ) ) { 
line 60351: pColl = 0 ; 
line 60352: } 
line 60353: return pColl ; 
line 60354: } 
line 60361: SQLITE_PRIVATE char sqlite3CompareAffinity ( Expr * pExpr , char aff2 ) { 
line 60362: char aff1 = sqlite3ExprAffinity ( pExpr ) ; 
line 60363: if ( aff1 && aff2 ) { 
line 60367: if ( sqlite3IsNumericAffinity ( aff1 ) || sqlite3IsNumericAffinity ( aff2 ) ) { 
line 60368: return SQLITE_AFF_NUMERIC ; 
line 60369: } else { 
line 60370: return SQLITE_AFF_NONE ; 
line 60371: } 
line 60372: } else if ( ! aff1 && ! aff2 ) { 
line 60376: return SQLITE_AFF_NONE ; 
line 60377: } else { 
line 60379: assert ( aff1 == 0 || aff2 == 0 ) ; 
line 60380: return ( aff1 + aff2 ) ; 
line 60381: } 
line 60382: } 
line 60388: static char comparisonAffinity ( Expr * pExpr ) { 
line 60389: char aff ; 
line 60390: assert ( pExpr -> op == TK_EQ || pExpr -> op == TK_IN || pExpr -> op == TK_LT || 
line 60391: pExpr -> op == TK_GT || pExpr -> op == TK_GE || pExpr -> op == TK_LE || 
line 60392: pExpr -> op == TK_NE || pExpr -> op == TK_IS || pExpr -> op == TK_ISNOT ) ; 
line 60393: assert ( pExpr -> pLeft ) ; 
line 60394: aff = sqlite3ExprAffinity ( pExpr -> pLeft ) ; 
line 60395: if ( pExpr -> pRight ) { 
line 60396: aff = sqlite3CompareAffinity ( pExpr -> pRight , aff ) ; 
line 60397: } else if ( ExprHasProperty ( pExpr , EP_xIsSelect ) ) { 
line 60398: aff = sqlite3CompareAffinity ( pExpr -> x . pSelect -> pEList -> a [ 0 ] . pExpr , aff ) ; 
line 60399: } else if ( ! aff ) { 
line 60400: aff = SQLITE_AFF_NONE ; 
line 60401: } 
line 60402: return aff ; 
line 60403: } 
line 60411: SQLITE_PRIVATE int sqlite3IndexAffinityOk ( Expr * pExpr , char idx_affinity ) { 
line 60412: char aff = comparisonAffinity ( pExpr ) ; 
line 60413: switch ( aff ) { 
line 60414: case SQLITE_AFF_NONE : 
line 60415: return 1 ; 
line 60416: case SQLITE_AFF_TEXT : 
line 60417: return idx_affinity == SQLITE_AFF_TEXT ; 
line 60418: default : 
line 60419: return sqlite3IsNumericAffinity ( idx_affinity ) ; 
line 60420: } 
line 60421: } 
line 60427: static u8 binaryCompareP5 ( Expr * pExpr1 , Expr * pExpr2 , int jumpIfNull ) { 
line 60428: u8 aff = ( char ) sqlite3ExprAffinity ( pExpr2 ) ; 
line 60429: aff = ( u8 ) sqlite3CompareAffinity ( pExpr1 , aff ) | ( u8 ) jumpIfNull ; 
line 60430: return aff ; 
line 60431: } 
line 60445: SQLITE_PRIVATE CollSeq * sqlite3BinaryCompareCollSeq ( 
line 60446: Parse * pParse , 
line 60447: Expr * pLeft , 
line 60448: Expr * pRight 
line 60449: ) { 
line 60450: CollSeq * pColl ; 
line 60451: assert ( pLeft ) ; 
line 60452: if ( pLeft -> flags & EP_ExpCollate ) { 
line 60453: assert ( pLeft -> pColl ) ; 
line 60454: pColl = pLeft -> pColl ; 
line 60455: } else if ( pRight && pRight -> flags & EP_ExpCollate ) { 
line 60456: assert ( pRight -> pColl ) ; 
line 60457: pColl = pRight -> pColl ; 
line 60458: } else { 
line 60459: pColl = sqlite3ExprCollSeq ( pParse , pLeft ) ; 
line 60460: if ( ! pColl ) { 
line 60461: pColl = sqlite3ExprCollSeq ( pParse , pRight ) ; 
line 60462: } 
line 60463: } 
line 60464: return pColl ; 
line 60465: } 
line 60470: static int codeCompare ( 
line 60471: Parse * pParse , 
line 60472: Expr * pLeft , 
line 60473: Expr * pRight , 
line 60474: int opcode , 
line 60475: int in1 , int in2 , 
line 60476: int dest , 
line 60477: int jumpIfNull 
line 60478: ) { 
line 60479: int p5 ; 
line 60480: int addr ; 
line 60481: CollSeq * p4 ; 
line 60483: p4 = sqlite3BinaryCompareCollSeq ( pParse , pLeft , pRight ) ; 
line 60484: p5 = binaryCompareP5 ( pLeft , pRight , jumpIfNull ) ; 
line 60485: addr = sqlite3VdbeAddOp4 ( pParse -> pVdbe , opcode , in2 , dest , in1 , 
line 60486: ( void * ) p4 , P4_COLLSEQ ) ; 
line 60487: sqlite3VdbeChangeP5 ( pParse -> pVdbe , ( u8 ) p5 ) ; 
line 60488: if ( ( p5 & SQLITE_AFF_MASK ) != SQLITE_AFF_NONE ) { 
line 60489: sqlite3ExprCacheAffinityChange ( pParse , in1 , 1 ) ; 
line 60490: sqlite3ExprCacheAffinityChange ( pParse , in2 , 1 ) ; 
line 60491: } 
line 60492: return addr ; 
line 60493: } 
line 60495: # if SQLITE_MAX_EXPR_DEPTH > 0 
line 60501: SQLITE_PRIVATE int sqlite3ExprCheckHeight ( Parse * pParse , int nHeight ) { 
line 60502: int rc = SQLITE_OK ; 
line 60503: int mxHeight = pParse -> db -> aLimit [ SQLITE_LIMIT_EXPR_DEPTH ] ; 
line 60504: if ( nHeight > mxHeight ) { 
line 60505: sqlite3ErrorMsg ( pParse , 
line 60506: "Expression tree is too large (maximum depth %d)" , mxHeight 
line 60507: ) ; 
line 60508: rc = SQLITE_ERROR ; 
line 60509: } 
line 60510: return rc ; 
line 60511: } 
line 60522: static void heightOfExpr ( Expr * p , int * pnHeight ) { 
line 60523: if ( p ) { 
line 60524: if ( p -> nHeight > * pnHeight ) { 
line 60525: * pnHeight = p -> nHeight ; 
line 60526: } 
line 60527: } 
line 60528: } 
line 60529: static void heightOfExprList ( ExprList * p , int * pnHeight ) { 
line 60530: if ( p ) { 
line 60531: int i ; 
line 60532: for ( i = 0 ; i < p -> nExpr ; i ++ ) { 
line 60533: heightOfExpr ( p -> a [ i ] . pExpr , pnHeight ) ; 
line 60534: } 
line 60535: } 
line 60536: } 
line 60537: static void heightOfSelect ( Select * p , int * pnHeight ) { 
line 60538: if ( p ) { 
line 60539: heightOfExpr ( p -> pWhere , pnHeight ) ; 
line 60540: heightOfExpr ( p -> pHaving , pnHeight ) ; 
line 60541: heightOfExpr ( p -> pLimit , pnHeight ) ; 
line 60542: heightOfExpr ( p -> pOffset , pnHeight ) ; 
line 60543: heightOfExprList ( p -> pEList , pnHeight ) ; 
line 60544: heightOfExprList ( p -> pGroupBy , pnHeight ) ; 
line 60545: heightOfExprList ( p -> pOrderBy , pnHeight ) ; 
line 60546: heightOfSelect ( p -> pPrior , pnHeight ) ; 
line 60547: } 
line 60548: } 
line 60557: static void exprSetHeight ( Expr * p ) { 
line 60558: int nHeight = 0 ; 
line 60559: heightOfExpr ( p -> pLeft , & nHeight ) ; 
line 60560: heightOfExpr ( p -> pRight , & nHeight ) ; 
line 60561: if ( ExprHasProperty ( p , EP_xIsSelect ) ) { 
line 60562: heightOfSelect ( p -> x . pSelect , & nHeight ) ; 
line 60563: } else { 
line 60564: heightOfExprList ( p -> x . pList , & nHeight ) ; 
line 60565: } 
line 60566: p -> nHeight = nHeight + 1 ; 
line 60567: } 
line 60574: SQLITE_PRIVATE void sqlite3ExprSetHeight ( Parse * pParse , Expr * p ) { 
line 60575: exprSetHeight ( p ) ; 
line 60576: sqlite3ExprCheckHeight ( pParse , p -> nHeight ) ; 
line 60577: } 
line 60583: SQLITE_PRIVATE int sqlite3SelectExprHeight ( Select * p ) { 
line 60584: int nHeight = 0 ; 
line 60585: heightOfSelect ( p , & nHeight ) ; 
line 60586: return nHeight ; 
line 60587: } 
line 60588: # else 
line 60589: # define exprSetHeight ( y ) 
line 60590: # endif 
line 60612: SQLITE_PRIVATE Expr * sqlite3ExprAlloc ( 
line 60613: sqlite3 * db , 
line 60614: int op , 
line 60615: const Token * pToken , 
line 60616: int dequote 
line 60617: ) { 
line 60618: Expr * pNew ; 
line 60619: int nExtra = 0 ; 
line 60620: int iValue = 0 ; 
line 60622: if ( pToken ) { 
line 60623: if ( op != TK_INTEGER || pToken -> z == 0 
line 60624: || sqlite3GetInt32 ( pToken -> z , & iValue ) == 0 ) { 
line 60625: nExtra = pToken -> n + 1 ; 
line 60626: } 
line 60627: } 
line 60628: pNew = sqlite3DbMallocZero ( db , sizeof ( Expr ) + nExtra ) ; 
line 60629: if ( pNew ) { 
line 60630: pNew -> op = ( u8 ) op ; 
line 60631: pNew -> iAgg = - 1 ; 
line 60632: if ( pToken ) { 
line 60633: if ( nExtra == 0 ) { 
line 60634: pNew -> flags |= EP_IntValue ; 
line 60635: pNew -> u . iValue = iValue ; 
line 60636: } else { 
line 60637: int c ; 
line 60638: pNew -> u . zToken = ( char * ) & pNew [ 1 ] ; 
line 60639: memcpy ( pNew -> u . zToken , pToken -> z , pToken -> n ) ; 
line 60640: pNew -> u . zToken [ pToken -> n ] = 0 ; 
line 60641: if ( dequote && nExtra >= 3 
line 60642: && ( ( c = pToken -> z [ 0 ] ) == '\'' || c == '"' || c == '[' || c == '`' ) ) { 
line 60643: sqlite3Dequote ( pNew -> u . zToken ) ; 
line 60644: if ( c == '"' ) pNew -> flags |= EP_DblQuoted ; 
line 60645: } 
line 60646: } 
line 60647: } 
line 60648: # if SQLITE_MAX_EXPR_DEPTH > 0 
line 60649: pNew -> nHeight = 1 ; 
line 60650: # endif 
line 60651: } 
line 60652: return pNew ; 
line 60653: } 
line 60659: SQLITE_PRIVATE Expr * sqlite3Expr ( 
line 60660: sqlite3 * db , 
line 60661: int op , 
line 60662: const char * zToken 
line 60663: ) { 
line 60664: Token x ; 
line 60665: x . z = zToken ; 
line 60666: x . n = zToken ? sqlite3Strlen30 ( zToken ) : 0 ; 
line 60667: return sqlite3ExprAlloc ( db , op , & x , 0 ) ; 
line 60668: } 
line 60676: SQLITE_PRIVATE void sqlite3ExprAttachSubtrees ( 
line 60677: sqlite3 * db , 
line 60678: Expr * pRoot , 
line 60679: Expr * pLeft , 
line 60680: Expr * pRight 
line 60681: ) { 
line 60682: if ( pRoot == 0 ) { 
line 60683: assert ( db -> mallocFailed ) ; 
line 60684: sqlite3ExprDelete ( db , pLeft ) ; 
line 60685: sqlite3ExprDelete ( db , pRight ) ; 
line 60686: } else { 
line 60687: if ( pRight ) { 
line 60688: pRoot -> pRight = pRight ; 
line 60689: if ( pRight -> flags & EP_ExpCollate ) { 
line 60690: pRoot -> flags |= EP_ExpCollate ; 
line 60691: pRoot -> pColl = pRight -> pColl ; 
line 60692: } 
line 60693: } 
line 60694: if ( pLeft ) { 
line 60695: pRoot -> pLeft = pLeft ; 
line 60696: if ( pLeft -> flags & EP_ExpCollate ) { 
line 60697: pRoot -> flags |= EP_ExpCollate ; 
line 60698: pRoot -> pColl = pLeft -> pColl ; 
line 60699: } 
line 60700: } 
line 60701: exprSetHeight ( pRoot ) ; 
line 60702: } 
line 60703: } 
line 60712: SQLITE_PRIVATE Expr * sqlite3PExpr ( 
line 60713: Parse * pParse , 
line 60714: int op , 
line 60715: Expr * pLeft , 
line 60716: Expr * pRight , 
line 60717: const Token * pToken 
line 60718: ) { 
line 60719: Expr * p = sqlite3ExprAlloc ( pParse -> db , op , pToken , 1 ) ; 
line 60720: sqlite3ExprAttachSubtrees ( pParse -> db , p , pLeft , pRight ) ; 
line 60721: return p ; 
line 60722: } 
line 60728: SQLITE_PRIVATE Expr * sqlite3ExprAnd ( sqlite3 * db , Expr * pLeft , Expr * pRight ) { 
line 60729: if ( pLeft == 0 ) { 
line 60730: return pRight ; 
line 60731: } else if ( pRight == 0 ) { 
line 60732: return pLeft ; 
line 60733: } else { 
line 60734: Expr * pNew = sqlite3ExprAlloc ( db , TK_AND , 0 , 0 ) ; 
line 60735: sqlite3ExprAttachSubtrees ( db , pNew , pLeft , pRight ) ; 
line 60736: return pNew ; 
line 60737: } 
line 60738: } 
line 60744: SQLITE_PRIVATE Expr * sqlite3ExprFunction ( Parse * pParse , ExprList * pList , Token * pToken ) { 
line 60745: Expr * pNew ; 
line 60746: sqlite3 * db = pParse -> db ; 
line 60747: assert ( pToken ) ; 
line 60748: pNew = sqlite3ExprAlloc ( db , TK_FUNCTION , pToken , 1 ) ; 
line 60749: if ( pNew == 0 ) { 
line 60750: sqlite3ExprListDelete ( db , pList ) ; 
line 60751: return 0 ; 
line 60752: } 
line 60753: pNew -> x . pList = pList ; 
line 60754: assert ( ! ExprHasProperty ( pNew , EP_xIsSelect ) ) ; 
line 60755: sqlite3ExprSetHeight ( pParse , pNew ) ; 
line 60756: return pNew ; 
line 60757: } 
line 60775: SQLITE_PRIVATE void sqlite3ExprAssignVarNumber ( Parse * pParse , Expr * pExpr ) { 
line 60776: sqlite3 * db = pParse -> db ; 
line 60777: const char * z ; 
line 60779: if ( pExpr == 0 ) return ; 
line 60780: assert ( ! ExprHasAnyProperty ( pExpr , EP_IntValue | EP_Reduced | EP_TokenOnly ) ) ; 
line 60781: z = pExpr -> u . zToken ; 
line 60782: assert ( z != 0 ) ; 
line 60783: assert ( z [ 0 ] != 0 ) ; 
line 60784: if ( z [ 1 ] == 0 ) { 
line 60786: assert ( z [ 0 ] == '?' ) ; 
line 60787: pExpr -> iColumn = ( ynVar ) ( ++ pParse -> nVar ) ; 
line 60788: } else if ( z [ 0 ] == '?' ) { 
line 60791: int i = atoi ( ( char * ) & z [ 1 ] ) ; 
line 60792: pExpr -> iColumn = ( ynVar ) i ; 
line 60793: testcase ( i == 0 ) ; 
line 60794: testcase ( i == 1 ) ; 
line 60795: testcase ( i == db -> aLimit [ SQLITE_LIMIT_VARIABLE_NUMBER ] - 1 ) ; 
line 60796: testcase ( i == db -> aLimit [ SQLITE_LIMIT_VARIABLE_NUMBER ] ) ; 
line 60797: if ( i < 1 || i > db -> aLimit [ SQLITE_LIMIT_VARIABLE_NUMBER ] ) { 
line 60798: sqlite3ErrorMsg ( pParse , "variable number must be between ?1 and ?%d" , 
line 60799: db -> aLimit [ SQLITE_LIMIT_VARIABLE_NUMBER ] ) ; 
line 60800: } 
line 60801: if ( i > pParse -> nVar ) { 
line 60802: pParse -> nVar = i ; 
line 60803: } 
line 60804: } else { 
line 60809: int i ; 
line 60810: u32 n ; 
line 60811: n = sqlite3Strlen30 ( z ) ; 
line 60812: for ( i = 0 ; i < pParse -> nVarExpr ; i ++ ) { 
line 60813: Expr * pE = pParse -> apVarExpr [ i ] ; 
line 60814: assert ( pE != 0 ) ; 
line 60815: if ( memcmp ( pE -> u . zToken , z , n ) == 0 && pE -> u . zToken [ n ] == 0 ) { 
line 60816: pExpr -> iColumn = pE -> iColumn ; 
line 60817: break ; 
line 60818: } 
line 60819: } 
line 60820: if ( i >= pParse -> nVarExpr ) { 
line 60821: pExpr -> iColumn = ( ynVar ) ( ++ pParse -> nVar ) ; 
line 60822: if ( pParse -> nVarExpr >= pParse -> nVarExprAlloc - 1 ) { 
line 60823: pParse -> nVarExprAlloc += pParse -> nVarExprAlloc + 10 ; 
line 60824: pParse -> apVarExpr = 
line 60825: sqlite3DbReallocOrFree ( 
line 60826: db , 
line 60827: pParse -> apVarExpr , 
line 60828: pParse -> nVarExprAlloc * sizeof ( pParse -> apVarExpr [ 0 ] ) 
line 60829: ) ; 
line 60830: } 
line 60831: if ( ! db -> mallocFailed ) { 
line 60832: assert ( pParse -> apVarExpr != 0 ) ; 
line 60833: pParse -> apVarExpr [ pParse -> nVarExpr ++ ] = pExpr ; 
line 60834: } 
line 60835: } 
line 60836: } 
line 60837: if ( ! pParse -> nErr && pParse -> nVar > db -> aLimit [ SQLITE_LIMIT_VARIABLE_NUMBER ] ) { 
line 60838: sqlite3ErrorMsg ( pParse , "too many SQL variables" ) ; 
line 60839: } 
line 60840: } 
line 60845: SQLITE_PRIVATE void sqlite3ExprDelete ( sqlite3 * db , Expr * p ) { 
line 60846: if ( p == 0 ) return ; 
line 60847: if ( ! ExprHasAnyProperty ( p , EP_TokenOnly ) ) { 
line 60848: sqlite3ExprDelete ( db , p -> pLeft ) ; 
line 60849: sqlite3ExprDelete ( db , p -> pRight ) ; 
line 60850: if ( ! ExprHasProperty ( p , EP_Reduced ) && ( p -> flags2 & EP2_MallocedToken ) != 0 ) { 
line 60851: sqlite3DbFree ( db , p -> u . zToken ) ; 
line 60852: } 
line 60853: if ( ExprHasProperty ( p , EP_xIsSelect ) ) { 
line 60854: sqlite3SelectDelete ( db , p -> x . pSelect ) ; 
line 60855: } else { 
line 60856: sqlite3ExprListDelete ( db , p -> x . pList ) ; 
line 60857: } 
line 60858: } 
line 60859: if ( ! ExprHasProperty ( p , EP_Static ) ) { 
line 60860: sqlite3DbFree ( db , p ) ; 
line 60861: } 
line 60862: } 
line 60869: static int exprStructSize ( Expr * p ) { 
line 60870: if ( ExprHasProperty ( p , EP_TokenOnly ) ) return EXPR_TOKENONLYSIZE ; 
line 60871: if ( ExprHasProperty ( p , EP_Reduced ) ) return EXPR_REDUCEDSIZE ; 
line 60872: return EXPR_FULLSIZE ; 
line 60873: } 
line 60909: static int dupedExprStructSize ( Expr * p , int flags ) { 
line 60910: int nSize ; 
line 60911: assert ( flags == EXPRDUP_REDUCE || flags == 0 ) ; 
line 60912: if ( 0 == ( flags & EXPRDUP_REDUCE ) ) { 
line 60913: nSize = EXPR_FULLSIZE ; 
line 60914: } else { 
line 60915: assert ( ! ExprHasAnyProperty ( p , EP_TokenOnly | EP_Reduced ) ) ; 
line 60916: assert ( ! ExprHasProperty ( p , EP_FromJoin ) ) ; 
line 60917: assert ( ( p -> flags2 & EP2_MallocedToken ) == 0 ) ; 
line 60918: assert ( ( p -> flags2 & EP2_Irreducible ) == 0 ) ; 
line 60919: if ( p -> pLeft || p -> pRight || p -> pColl || p -> x . pList ) { 
line 60920: nSize = EXPR_REDUCEDSIZE | EP_Reduced ; 
line 60921: } else { 
line 60922: nSize = EXPR_TOKENONLYSIZE | EP_TokenOnly ; 
line 60923: } 
line 60924: } 
line 60925: return nSize ; 
line 60926: } 
line 60933: static int dupedExprNodeSize ( Expr * p , int flags ) { 
line 60934: int nByte = dupedExprStructSize ( p , flags ) & 0xfff ; 
line 60935: if ( ! ExprHasProperty ( p , EP_IntValue ) && p -> u . zToken ) { 
line 60936: nByte += sqlite3Strlen30 ( p -> u . zToken ) + 1 ; 
line 60937: } 
line 60938: return ROUND8 ( nByte ) ; 
line 60939: } 
line 60954: static int dupedExprSize ( Expr * p , int flags ) { 
line 60955: int nByte = 0 ; 
line 60956: if ( p ) { 
line 60957: nByte = dupedExprNodeSize ( p , flags ) ; 
line 60958: if ( flags & EXPRDUP_REDUCE ) { 
line 60959: nByte += dupedExprSize ( p -> pLeft , flags ) + dupedExprSize ( p -> pRight , flags ) ; 
line 60960: } 
line 60961: } 
line 60962: return nByte ; 
line 60963: } 
line 60973: static Expr * exprDup ( sqlite3 * db , Expr * p , int flags , u8 * * pzBuffer ) { 
line 60974: Expr * pNew = 0 ; 
line 60975: if ( p ) { 
line 60976: const int isReduced = ( flags & EXPRDUP_REDUCE ) ; 
line 60977: u8 * zAlloc ; 
line 60978: u32 staticFlag = 0 ; 
line 60980: assert ( pzBuffer == 0 || isReduced ) ; 
line 60983: if ( pzBuffer ) { 
line 60984: zAlloc = * pzBuffer ; 
line 60985: staticFlag = EP_Static ; 
line 60986: } else { 
line 60987: zAlloc = sqlite3DbMallocRaw ( db , dupedExprSize ( p , flags ) ) ; 
line 60988: } 
line 60989: pNew = ( Expr * ) zAlloc ; 
line 60991: if ( pNew ) { 
line 60997: const unsigned nStructSize = dupedExprStructSize ( p , flags ) ; 
line 60998: const int nNewSize = nStructSize & 0xfff ; 
line 60999: int nToken ; 
line 61000: if ( ! ExprHasProperty ( p , EP_IntValue ) && p -> u . zToken ) { 
line 61001: nToken = sqlite3Strlen30 ( p -> u . zToken ) + 1 ; 
line 61002: } else { 
line 61003: nToken = 0 ; 
line 61004: } 
line 61005: if ( isReduced ) { 
line 61006: assert ( ExprHasProperty ( p , EP_Reduced ) == 0 ) ; 
line 61007: memcpy ( zAlloc , p , nNewSize ) ; 
line 61008: } else { 
line 61009: int nSize = exprStructSize ( p ) ; 
line 61010: memcpy ( zAlloc , p , nSize ) ; 
line 61011: memset ( & zAlloc [ nSize ] , 0 , EXPR_FULLSIZE - nSize ) ; 
line 61012: } 
line 61015: pNew -> flags &= ~ ( EP_Reduced | EP_TokenOnly | EP_Static ) ; 
line 61016: pNew -> flags |= nStructSize & ( EP_Reduced | EP_TokenOnly ) ; 
line 61017: pNew -> flags |= staticFlag ; 
line 61020: if ( nToken ) { 
line 61021: char * zToken = pNew -> u . zToken = ( char * ) & zAlloc [ nNewSize ] ; 
line 61022: memcpy ( zToken , p -> u . zToken , nToken ) ; 
line 61023: } 
line 61025: if ( 0 == ( ( p -> flags | pNew -> flags ) & EP_TokenOnly ) ) { 
line 61027: if ( ExprHasProperty ( p , EP_xIsSelect ) ) { 
line 61028: pNew -> x . pSelect = sqlite3SelectDup ( db , p -> x . pSelect , isReduced ) ; 
line 61029: } else { 
line 61030: pNew -> x . pList = sqlite3ExprListDup ( db , p -> x . pList , isReduced ) ; 
line 61031: } 
line 61032: } 
line 61035: if ( ExprHasAnyProperty ( pNew , EP_Reduced | EP_TokenOnly ) ) { 
line 61036: zAlloc += dupedExprNodeSize ( p , flags ) ; 
line 61037: if ( ExprHasProperty ( pNew , EP_Reduced ) ) { 
line 61038: pNew -> pLeft = exprDup ( db , p -> pLeft , EXPRDUP_REDUCE , & zAlloc ) ; 
line 61039: pNew -> pRight = exprDup ( db , p -> pRight , EXPRDUP_REDUCE , & zAlloc ) ; 
line 61040: } 
line 61041: if ( pzBuffer ) { 
line 61042: * pzBuffer = zAlloc ; 
line 61043: } 
line 61044: } else { 
line 61045: pNew -> flags2 = 0 ; 
line 61046: if ( ! ExprHasAnyProperty ( p , EP_TokenOnly ) ) { 
line 61047: pNew -> pLeft = sqlite3ExprDup ( db , p -> pLeft , 0 ) ; 
line 61048: pNew -> pRight = sqlite3ExprDup ( db , p -> pRight , 0 ) ; 
line 61049: } 
line 61050: } 
line 61052: } 
line 61053: } 
line 61054: return pNew ; 
line 61055: } 
line 61074: SQLITE_PRIVATE Expr * sqlite3ExprDup ( sqlite3 * db , Expr * p , int flags ) { 
line 61075: return exprDup ( db , p , flags , 0 ) ; 
line 61076: } 
line 61077: SQLITE_PRIVATE ExprList * sqlite3ExprListDup ( sqlite3 * db , ExprList * p , int flags ) { 
line 61078: ExprList * pNew ; 
line 61079: struct ExprList_item * pItem , * pOldItem ; 
line 61080: int i ; 
line 61081: if ( p == 0 ) return 0 ; 
line 61082: pNew = sqlite3DbMallocRaw ( db , sizeof ( * pNew ) ) ; 
line 61083: if ( pNew == 0 ) return 0 ; 
line 61084: pNew -> iECursor = 0 ; 
line 61085: pNew -> nExpr = pNew -> nAlloc = p -> nExpr ; 
line 61086: pNew -> a = pItem = sqlite3DbMallocRaw ( db , p -> nExpr * sizeof ( p -> a [ 0 ] ) ) ; 
line 61087: if ( pItem == 0 ) { 
line 61088: sqlite3DbFree ( db , pNew ) ; 
line 61089: return 0 ; 
line 61090: } 
line 61091: pOldItem = p -> a ; 
line 61092: for ( i = 0 ; i < p -> nExpr ; i ++ , pItem ++ , pOldItem ++ ) { 
line 61093: Expr * pOldExpr = pOldItem -> pExpr ; 
line 61094: pItem -> pExpr = sqlite3ExprDup ( db , pOldExpr , flags ) ; 
line 61095: pItem -> zName = sqlite3DbStrDup ( db , pOldItem -> zName ) ; 
line 61096: pItem -> zSpan = sqlite3DbStrDup ( db , pOldItem -> zSpan ) ; 
line 61097: pItem -> sortOrder = pOldItem -> sortOrder ; 
line 61098: pItem -> done = 0 ; 
line 61099: pItem -> iCol = pOldItem -> iCol ; 
line 61100: pItem -> iAlias = pOldItem -> iAlias ; 
line 61101: } 
line 61102: return pNew ; 
line 61103: } 
line 61111: # if ! defined ( SQLITE_OMIT_VIEW ) || ! defined ( SQLITE_OMIT_TRIGGER ) 
line 61112: || ! defined ( SQLITE_OMIT_SUBQUERY ) 
line 61113: SQLITE_PRIVATE SrcList * sqlite3SrcListDup ( sqlite3 * db , SrcList * p , int flags ) { 
line 61114: SrcList * pNew ; 
line 61115: int i ; 
line 61116: int nByte ; 
line 61117: if ( p == 0 ) return 0 ; 
line 61118: nByte = sizeof ( * p ) + ( p -> nSrc > 0 ? sizeof ( p -> a [ 0 ] ) * ( p -> nSrc - 1 ) : 0 ) ; 
line 61119: pNew = sqlite3DbMallocRaw ( db , nByte ) ; 
line 61120: if ( pNew == 0 ) return 0 ; 
line 61121: pNew -> nSrc = pNew -> nAlloc = p -> nSrc ; 
line 61122: for ( i = 0 ; i < p -> nSrc ; i ++ ) { 
line 61123: struct SrcList_item * pNewItem = & pNew -> a [ i ] ; 
line 61124: struct SrcList_item * pOldItem = & p -> a [ i ] ; 
line 61125: Table * pTab ; 
line 61126: pNewItem -> zDatabase = sqlite3DbStrDup ( db , pOldItem -> zDatabase ) ; 
line 61127: pNewItem -> zName = sqlite3DbStrDup ( db , pOldItem -> zName ) ; 
line 61128: pNewItem -> zAlias = sqlite3DbStrDup ( db , pOldItem -> zAlias ) ; 
line 61129: pNewItem -> jointype = pOldItem -> jointype ; 
line 61130: pNewItem -> iCursor = pOldItem -> iCursor ; 
line 61131: pNewItem -> isPopulated = pOldItem -> isPopulated ; 
line 61132: pNewItem -> zIndex = sqlite3DbStrDup ( db , pOldItem -> zIndex ) ; 
line 61133: pNewItem -> notIndexed = pOldItem -> notIndexed ; 
line 61134: pNewItem -> pIndex = pOldItem -> pIndex ; 
line 61135: pTab = pNewItem -> pTab = pOldItem -> pTab ; 
line 61136: if ( pTab ) { 
line 61137: pTab -> nRef ++ ; 
line 61138: } 
line 61139: pNewItem -> pSelect = sqlite3SelectDup ( db , pOldItem -> pSelect , flags ) ; 
line 61140: pNewItem -> pOn = sqlite3ExprDup ( db , pOldItem -> pOn , flags ) ; 
line 61141: pNewItem -> pUsing = sqlite3IdListDup ( db , pOldItem -> pUsing ) ; 
line 61142: pNewItem -> colUsed = pOldItem -> colUsed ; 
line 61143: } 
line 61144: return pNew ; 
line 61145: } 
line 61146: SQLITE_PRIVATE IdList * sqlite3IdListDup ( sqlite3 * db , IdList * p ) { 
line 61147: IdList * pNew ; 
line 61148: int i ; 
line 61149: if ( p == 0 ) return 0 ; 
line 61150: pNew = sqlite3DbMallocRaw ( db , sizeof ( * pNew ) ) ; 
line 61151: if ( pNew == 0 ) return 0 ; 
line 61152: pNew -> nId = pNew -> nAlloc = p -> nId ; 
line 61153: pNew -> a = sqlite3DbMallocRaw ( db , p -> nId * sizeof ( p -> a [ 0 ] ) ) ; 
line 61154: if ( pNew -> a == 0 ) { 
line 61155: sqlite3DbFree ( db , pNew ) ; 
line 61156: return 0 ; 
line 61157: } 
line 61158: for ( i = 0 ; i < p -> nId ; i ++ ) { 
line 61159: struct IdList_item * pNewItem = & pNew -> a [ i ] ; 
line 61160: struct IdList_item * pOldItem = & p -> a [ i ] ; 
line 61161: pNewItem -> zName = sqlite3DbStrDup ( db , pOldItem -> zName ) ; 
line 61162: pNewItem -> idx = pOldItem -> idx ; 
line 61163: } 
line 61164: return pNew ; 
line 61165: } 
line 61166: SQLITE_PRIVATE Select * sqlite3SelectDup ( sqlite3 * db , Select * p , int flags ) { 
line 61167: Select * pNew ; 
line 61168: if ( p == 0 ) return 0 ; 
line 61169: pNew = sqlite3DbMallocRaw ( db , sizeof ( * p ) ) ; 
line 61170: if ( pNew == 0 ) return 0 ; 
line 61171: pNew -> pEList = sqlite3ExprListDup ( db , p -> pEList , flags ) ; 
line 61172: pNew -> pSrc = sqlite3SrcListDup ( db , p -> pSrc , flags ) ; 
line 61173: pNew -> pWhere = sqlite3ExprDup ( db , p -> pWhere , flags ) ; 
line 61174: pNew -> pGroupBy = sqlite3ExprListDup ( db , p -> pGroupBy , flags ) ; 
line 61175: pNew -> pHaving = sqlite3ExprDup ( db , p -> pHaving , flags ) ; 
line 61176: pNew -> pOrderBy = sqlite3ExprListDup ( db , p -> pOrderBy , flags ) ; 
line 61177: pNew -> op = p -> op ; 
line 61178: pNew -> pPrior = sqlite3SelectDup ( db , p -> pPrior , flags ) ; 
line 61179: pNew -> pLimit = sqlite3ExprDup ( db , p -> pLimit , flags ) ; 
line 61180: pNew -> pOffset = sqlite3ExprDup ( db , p -> pOffset , flags ) ; 
line 61181: pNew -> iLimit = 0 ; 
line 61182: pNew -> iOffset = 0 ; 
line 61183: pNew -> selFlags = p -> selFlags & ~ SF_UsesEphemeral ; 
line 61184: pNew -> pRightmost = 0 ; 
line 61185: pNew -> addrOpenEphm [ 0 ] = - 1 ; 
line 61186: pNew -> addrOpenEphm [ 1 ] = - 1 ; 
line 61187: pNew -> addrOpenEphm [ 2 ] = - 1 ; 
line 61188: return pNew ; 
line 61189: } 
line 61190: # else 
line 61191: SQLITE_PRIVATE Select * sqlite3SelectDup ( sqlite3 * db , Select * p , int flags ) { 
line 61192: assert ( p == 0 ) ; 
line 61193: return 0 ; 
line 61194: } 
line 61195: # endif 
line 61206: SQLITE_PRIVATE ExprList * sqlite3ExprListAppend ( 
line 61207: Parse * pParse , 
line 61208: ExprList * pList , 
line 61209: Expr * pExpr 
line 61210: ) { 
line 61211: sqlite3 * db = pParse -> db ; 
line 61212: if ( pList == 0 ) { 
line 61213: pList = sqlite3DbMallocZero ( db , sizeof ( ExprList ) ) ; 
line 61214: if ( pList == 0 ) { 
line 61215: goto no_mem ; 
line 61216: } 
line 61217: assert ( pList -> nAlloc == 0 ) ; 
line 61218: } 
line 61219: if ( pList -> nAlloc <= pList -> nExpr ) { 
line 61220: struct ExprList_item * a ; 
line 61221: int n = pList -> nAlloc * 2 + 4 ; 
line 61222: a = sqlite3DbRealloc ( db , pList -> a , n * sizeof ( pList -> a [ 0 ] ) ) ; 
line 61223: if ( a == 0 ) { 
line 61224: goto no_mem ; 
line 61225: } 
line 61226: pList -> a = a ; 
line 61227: pList -> nAlloc = sqlite3DbMallocSize ( db , a ) / sizeof ( a [ 0 ] ) ; 
line 61228: } 
line 61229: assert ( pList -> a != 0 ) ; 
line 61230: if ( 1 ) { 
line 61231: struct ExprList_item * pItem = & pList -> a [ pList -> nExpr ++ ] ; 
line 61232: memset ( pItem , 0 , sizeof ( * pItem ) ) ; 
line 61233: pItem -> pExpr = pExpr ; 
line 61234: } 
line 61235: return pList ; 
line 61237: no_mem : 
line 61239: sqlite3ExprDelete ( db , pExpr ) ; 
line 61240: sqlite3ExprListDelete ( db , pList ) ; 
line 61241: return 0 ; 
line 61242: } 
line 61252: SQLITE_PRIVATE void sqlite3ExprListSetName ( 
line 61253: Parse * pParse , 
line 61254: ExprList * pList , 
line 61255: Token * pName , 
line 61256: int dequote 
line 61257: ) { 
line 61258: assert ( pList != 0 || pParse -> db -> mallocFailed != 0 ) ; 
line 61259: if ( pList ) { 
line 61260: struct ExprList_item * pItem ; 
line 61261: assert ( pList -> nExpr > 0 ) ; 
line 61262: pItem = & pList -> a [ pList -> nExpr - 1 ] ; 
line 61263: assert ( pItem -> zName == 0 ) ; 
line 61264: pItem -> zName = sqlite3DbStrNDup ( pParse -> db , pName -> z , pName -> n ) ; 
line 61265: if ( dequote && pItem -> zName ) sqlite3Dequote ( pItem -> zName ) ; 
line 61266: } 
line 61267: } 
line 61277: SQLITE_PRIVATE void sqlite3ExprListSetSpan ( 
line 61278: Parse * pParse , 
line 61279: ExprList * pList , 
line 61280: ExprSpan * pSpan 
line 61281: ) { 
line 61282: sqlite3 * db = pParse -> db ; 
line 61283: assert ( pList != 0 || db -> mallocFailed != 0 ) ; 
line 61284: if ( pList ) { 
line 61285: struct ExprList_item * pItem = & pList -> a [ pList -> nExpr - 1 ] ; 
line 61286: assert ( pList -> nExpr > 0 ) ; 
line 61287: assert ( db -> mallocFailed || pItem -> pExpr == pSpan -> pExpr ) ; 
line 61288: sqlite3DbFree ( db , pItem -> zSpan ) ; 
line 61289: pItem -> zSpan = sqlite3DbStrNDup ( db , ( char * ) pSpan -> zStart , 
line 61290: ( int ) ( pSpan -> zEnd - pSpan -> zStart ) ) ; 
line 61291: } 
line 61292: } 
line 61298: SQLITE_PRIVATE void sqlite3ExprListCheckLength ( 
line 61299: Parse * pParse , 
line 61300: ExprList * pEList , 
line 61301: const char * zObject 
line 61302: ) { 
line 61303: int mx = pParse -> db -> aLimit [ SQLITE_LIMIT_COLUMN ] ; 
line 61304: testcase ( pEList && pEList -> nExpr == mx ) ; 
line 61305: testcase ( pEList && pEList -> nExpr == mx + 1 ) ; 
line 61306: if ( pEList && pEList -> nExpr > mx ) { 
line 61307: sqlite3ErrorMsg ( pParse , "too many columns in %s" , zObject ) ; 
line 61308: } 
line 61309: } 
line 61314: SQLITE_PRIVATE void sqlite3ExprListDelete ( sqlite3 * db , ExprList * pList ) { 
line 61315: int i ; 
line 61316: struct ExprList_item * pItem ; 
line 61317: if ( pList == 0 ) return ; 
line 61318: assert ( pList -> a != 0 || ( pList -> nExpr == 0 && pList -> nAlloc == 0 ) ) ; 
line 61319: assert ( pList -> nExpr <= pList -> nAlloc ) ; 
line 61320: for ( pItem = pList -> a , i = 0 ; i < pList -> nExpr ; i ++ , pItem ++ ) { 
line 61321: sqlite3ExprDelete ( db , pItem -> pExpr ) ; 
line 61322: sqlite3DbFree ( db , pItem -> zName ) ; 
line 61323: sqlite3DbFree ( db , pItem -> zSpan ) ; 
line 61324: } 
line 61325: sqlite3DbFree ( db , pList -> a ) ; 
line 61326: sqlite3DbFree ( db , pList ) ; 
line 61327: } 
line 61342: static int exprNodeIsConstant ( Walker * pWalker , Expr * pExpr ) { 
line 61347: if ( pWalker -> u . i == 3 && ExprHasAnyProperty ( pExpr , EP_FromJoin ) ) { 
line 61348: pWalker -> u . i = 0 ; 
line 61349: return WRC_Abort ; 
line 61350: } 
line 61352: switch ( pExpr -> op ) { 
line 61355: case TK_FUNCTION : 
line 61356: if ( pWalker -> u . i == 2 ) return 0 ; 
line 61358: case TK_ID : 
line 61359: case TK_COLUMN : 
line 61360: case TK_AGG_FUNCTION : 
line 61361: case TK_AGG_COLUMN : 
line 61362: testcase ( pExpr -> op == TK_ID ) ; 
line 61363: testcase ( pExpr -> op == TK_COLUMN ) ; 
line 61364: testcase ( pExpr -> op == TK_AGG_FUNCTION ) ; 
line 61365: testcase ( pExpr -> op == TK_AGG_COLUMN ) ; 
line 61366: pWalker -> u . i = 0 ; 
line 61367: return WRC_Abort ; 
line 61368: default : 
line 61369: testcase ( pExpr -> op == TK_SELECT ) ; 
line 61370: testcase ( pExpr -> op == TK_EXISTS ) ; 
line 61371: return WRC_Continue ; 
line 61372: } 
line 61373: } 
line 61374: static int selectNodeIsConstant ( Walker * pWalker , Select * NotUsed ) { 
line 61375: UNUSED_PARAMETER ( NotUsed ) ; 
line 61376: pWalker -> u . i = 0 ; 
line 61377: return WRC_Abort ; 
line 61378: } 
line 61379: static int exprIsConst ( Expr * p , int initFlag ) { 
line 61380: Walker w ; 
line 61381: w . u . i = initFlag ; 
line 61382: w . xExprCallback = exprNodeIsConstant ; 
line 61383: w . xSelectCallback = selectNodeIsConstant ; 
line 61384: sqlite3WalkExpr ( & w , p ) ; 
line 61385: return w . u . i ; 
line 61386: } 
line 61396: SQLITE_PRIVATE int sqlite3ExprIsConstant ( Expr * p ) { 
line 61397: return exprIsConst ( p , 1 ) ; 
line 61398: } 
line 61406: SQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin ( Expr * p ) { 
line 61407: return exprIsConst ( p , 3 ) ; 
line 61408: } 
line 61419: SQLITE_PRIVATE int sqlite3ExprIsConstantOrFunction ( Expr * p ) { 
line 61420: return exprIsConst ( p , 2 ) ; 
line 61421: } 
line 61429: SQLITE_PRIVATE int sqlite3ExprIsInteger ( Expr * p , int * pValue ) { 
line 61430: int rc = 0 ; 
line 61431: if ( p -> flags & EP_IntValue ) { 
line 61432: * pValue = p -> u . iValue ; 
line 61433: return 1 ; 
line 61434: } 
line 61435: switch ( p -> op ) { 
line 61436: case TK_INTEGER : { 
line 61437: rc = sqlite3GetInt32 ( p -> u . zToken , pValue ) ; 
line 61438: assert ( rc == 0 ) ; 
line 61439: break ; 
line 61440: } 
line 61441: case TK_UPLUS : { 
line 61442: rc = sqlite3ExprIsInteger ( p -> pLeft , pValue ) ; 
line 61443: break ; 
line 61444: } 
line 61445: case TK_UMINUS : { 
line 61446: int v ; 
line 61447: if ( sqlite3ExprIsInteger ( p -> pLeft , & v ) ) { 
line 61448: * pValue = - v ; 
line 61449: rc = 1 ; 
line 61450: } 
line 61451: break ; 
line 61452: } 
line 61453: default : break ; 
line 61454: } 
line 61455: if ( rc ) { 
line 61456: assert ( ExprHasAnyProperty ( p , EP_Reduced | EP_TokenOnly ) 
line 61457: || ( p -> flags2 & EP2_MallocedToken ) == 0 ) ; 
line 61458: p -> op = TK_INTEGER ; 
line 61459: p -> flags |= EP_IntValue ; 
line 61460: p -> u . iValue = * pValue ; 
line 61461: } 
line 61462: return rc ; 
line 61463: } 
line 61479: SQLITE_PRIVATE int sqlite3ExprCanBeNull ( const Expr * p ) { 
line 61480: u8 op ; 
line 61481: while ( p -> op == TK_UPLUS || p -> op == TK_UMINUS ) { p = p -> pLeft ; } 
line 61482: op = p -> op ; 
line 61483: if ( op == TK_REGISTER ) op = p -> op2 ; 
line 61484: switch ( op ) { 
line 61485: case TK_INTEGER : 
line 61486: case TK_STRING : 
line 61487: case TK_FLOAT : 
line 61488: case TK_BLOB : 
line 61489: return 0 ; 
line 61490: default : 
line 61491: return 1 ; 
line 61492: } 
line 61493: } 
line 61502: SQLITE_PRIVATE void sqlite3ExprCodeIsNullJump ( 
line 61503: Vdbe * v , 
line 61504: const Expr * pExpr , 
line 61505: int iReg , 
line 61506: int iDest 
line 61507: ) { 
line 61508: if ( sqlite3ExprCanBeNull ( pExpr ) ) { 
line 61509: sqlite3VdbeAddOp2 ( v , OP_IsNull , iReg , iDest ) ; 
line 61510: } 
line 61511: } 
line 61523: SQLITE_PRIVATE int sqlite3ExprNeedsNoAffinityChange ( const Expr * p , char aff ) { 
line 61524: u8 op ; 
line 61525: if ( aff == SQLITE_AFF_NONE ) return 1 ; 
line 61526: while ( p -> op == TK_UPLUS || p -> op == TK_UMINUS ) { p = p -> pLeft ; } 
line 61527: op = p -> op ; 
line 61528: if ( op == TK_REGISTER ) op = p -> op2 ; 
line 61529: switch ( op ) { 
line 61530: case TK_INTEGER : { 
line 61531: return aff == SQLITE_AFF_INTEGER || aff == SQLITE_AFF_NUMERIC ; 
line 61532: } 
line 61533: case TK_FLOAT : { 
line 61534: return aff == SQLITE_AFF_REAL || aff == SQLITE_AFF_NUMERIC ; 
line 61535: } 
line 61536: case TK_STRING : { 
line 61537: return aff == SQLITE_AFF_TEXT ; 
line 61538: } 
line 61539: case TK_BLOB : { 
line 61540: return 1 ; 
line 61541: } 
line 61542: case TK_COLUMN : { 
line 61543: assert ( p -> iTable >= 0 ) ; 
line 61544: return p -> iColumn < 0 
line 61545: && ( aff == SQLITE_AFF_INTEGER || aff == SQLITE_AFF_NUMERIC ) ; 
line 61546: } 
line 61547: default : { 
line 61548: return 0 ; 
line 61549: } 
line 61550: } 
line 61551: } 
line 61556: SQLITE_PRIVATE int sqlite3IsRowid ( const char * z ) { 
line 61557: if ( sqlite3StrICmp ( z , "_ROWID_" ) == 0 ) return 1 ; 
line 61558: if ( sqlite3StrICmp ( z , "ROWID" ) == 0 ) return 1 ; 
line 61559: if ( sqlite3StrICmp ( z , "OID" ) == 0 ) return 1 ; 
line 61560: return 0 ; 
line 61561: } 
line 61575: # ifndef SQLITE_OMIT_SUBQUERY 
line 61576: static int isCandidateForInOpt ( Select * p ) { 
line 61577: SrcList * pSrc ; 
line 61578: ExprList * pEList ; 
line 61579: Table * pTab ; 
line 61580: if ( p == 0 ) return 0 ; 
line 61581: if ( p -> pPrior ) return 0 ; 
line 61582: if ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) { 
line 61583: testcase ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct ) ; 
line 61584: testcase ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Aggregate ) ; 
line 61585: return 0 ; 
line 61586: } 
line 61587: assert ( p -> pGroupBy == 0 ) ; 
line 61588: if ( p -> pLimit ) return 0 ; 
line 61589: assert ( p -> pOffset == 0 ) ; 
line 61590: if ( p -> pWhere ) return 0 ; 
line 61591: pSrc = p -> pSrc ; 
line 61592: assert ( pSrc != 0 ) ; 
line 61593: if ( pSrc -> nSrc != 1 ) return 0 ; 
line 61594: if ( pSrc -> a [ 0 ] . pSelect ) return 0 ; 
line 61595: pTab = pSrc -> a [ 0 ] . pTab ; 
line 61596: if ( NEVER ( pTab == 0 ) ) return 0 ; 
line 61597: assert ( pTab -> pSelect == 0 ) ; 
line 61598: if ( IsVirtual ( pTab ) ) return 0 ; 
line 61599: pEList = p -> pEList ; 
line 61600: if ( pEList -> nExpr != 1 ) return 0 ; 
line 61601: if ( pEList -> a [ 0 ] . pExpr -> op != TK_COLUMN ) return 0 ; 
line 61602: return 1 ; 
line 61603: } 
line 61604: # endif 
line 61660: # ifndef SQLITE_OMIT_SUBQUERY 
line 61661: SQLITE_PRIVATE int sqlite3FindInIndex ( Parse * pParse , Expr * pX , int * prNotFound ) { 
line 61662: Select * p ; 
line 61663: int eType = 0 ; 
line 61664: int iTab = pParse -> nTab ++ ; 
line 61665: int mustBeUnique = ( prNotFound == 0 ) ; 
line 61667: assert ( pX -> op == TK_IN ) ; 
line 61673: p = ( ExprHasProperty ( pX , EP_xIsSelect ) ? pX -> x . pSelect : 0 ) ; 
line 61674: if ( ALWAYS ( pParse -> nErr == 0 ) && isCandidateForInOpt ( p ) ) { 
line 61675: sqlite3 * db = pParse -> db ; 
line 61676: Expr * pExpr = p -> pEList -> a [ 0 ] . pExpr ; 
line 61677: int iCol = pExpr -> iColumn ; 
line 61678: Vdbe * v = sqlite3GetVdbe ( pParse ) ; 
line 61679: Table * pTab = p -> pSrc -> a [ 0 ] . pTab ; 
line 61680: int iDb ; 
line 61683: iDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; 
line 61684: sqlite3CodeVerifySchema ( pParse , iDb ) ; 
line 61685: sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ) ; 
line 61691: assert ( v ) ; 
line 61692: if ( iCol < 0 ) { 
line 61693: int iMem = ++ pParse -> nMem ; 
line 61694: int iAddr ; 
line 61696: iAddr = sqlite3VdbeAddOp1 ( v , OP_If , iMem ) ; 
line 61697: sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iMem ) ; 
line 61699: sqlite3OpenTable ( pParse , iTab , iDb , pTab , OP_OpenRead ) ; 
line 61700: eType = IN_INDEX_ROWID ; 
line 61702: sqlite3VdbeJumpHere ( v , iAddr ) ; 
line 61703: } else { 
line 61704: Index * pIdx ; 
line 61709: CollSeq * pReq = sqlite3BinaryCompareCollSeq ( pParse , pX -> pLeft , pExpr ) ; 
line 61715: char aff = comparisonAffinity ( pX ) ; 
line 61716: int affinity_ok = ( pTab -> aCol [ iCol ] . affinity == aff || aff == SQLITE_AFF_NONE ) ; 
line 61718: for ( pIdx = pTab -> pIndex ; pIdx && eType == 0 && affinity_ok ; pIdx = pIdx -> pNext ) { 
line 61719: if ( ( pIdx -> aiColumn [ 0 ] == iCol ) 
line 61720: && sqlite3FindCollSeq ( db , ENC ( db ) , pIdx -> azColl [ 0 ] , 0 ) == pReq 
line 61721: && ( ! mustBeUnique || ( pIdx -> nColumn == 1 && pIdx -> onError != OE_None ) ) 
line 61722: ) { 
line 61723: int iMem = ++ pParse -> nMem ; 
line 61724: int iAddr ; 
line 61725: char * pKey ; 
line 61727: pKey = ( char * ) sqlite3IndexKeyinfo ( pParse , pIdx ) ; 
line 61728: iAddr = sqlite3VdbeAddOp1 ( v , OP_If , iMem ) ; 
line 61729: sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iMem ) ; 
line 61731: sqlite3VdbeAddOp4 ( v , OP_OpenRead , iTab , pIdx -> tnum , iDb , 
line 61732: pKey , P4_KEYINFO_HANDOFF ) ; 
line 61733: VdbeComment ( ( v , "%s" , pIdx -> zName ) ) ; 
line 61734: eType = IN_INDEX_INDEX ; 
line 61736: sqlite3VdbeJumpHere ( v , iAddr ) ; 
line 61737: if ( prNotFound && ! pTab -> aCol [ iCol ] . notNull ) { 
line 61738: * prNotFound = ++ pParse -> nMem ; 
line 61739: } 
line 61740: } 
line 61741: } 
line 61742: } 
line 61743: } 
line 61745: if ( eType == 0 ) { 
line 61749: int rMayHaveNull = 0 ; 
line 61750: eType = IN_INDEX_EPH ; 
line 61751: if ( prNotFound ) { 
line 61752: * prNotFound = rMayHaveNull = ++ pParse -> nMem ; 
line 61753: } else if ( pX -> pLeft -> iColumn < 0 && ! ExprHasAnyProperty ( pX , EP_xIsSelect ) ) { 
line 61754: eType = IN_INDEX_ROWID ; 
line 61755: } 
line 61756: sqlite3CodeSubselect ( pParse , pX , rMayHaveNull , eType == IN_INDEX_ROWID ) ; 
line 61757: } else { 
line 61758: pX -> iTable = iTab ; 
line 61759: } 
line 61760: return eType ; 
line 61761: } 
line 61762: # endif 
line 61797: # ifndef SQLITE_OMIT_SUBQUERY 
line 61798: SQLITE_PRIVATE int sqlite3CodeSubselect ( 
line 61799: Parse * pParse , 
line 61800: Expr * pExpr , 
line 61801: int rMayHaveNull , 
line 61802: int isRowid 
line 61803: ) { 
line 61804: int testAddr = 0 ; 
line 61805: int rReg = 0 ; 
line 61806: Vdbe * v = sqlite3GetVdbe ( pParse ) ; 
line 61807: if ( NEVER ( v == 0 ) ) return 0 ; 
line 61808: sqlite3ExprCachePush ( pParse ) ; 
line 61820: if ( ! ExprHasAnyProperty ( pExpr , EP_VarSelect ) && ! pParse -> pTriggerTab ) { 
line 61821: int mem = ++ pParse -> nMem ; 
line 61822: sqlite3VdbeAddOp1 ( v , OP_If , mem ) ; 
line 61823: testAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , mem ) ; 
line 61824: assert ( testAddr > 0 || pParse -> db -> mallocFailed ) ; 
line 61825: } 
line 61827: switch ( pExpr -> op ) { 
line 61828: case TK_IN : { 
line 61829: char affinity ; 
line 61830: KeyInfo keyInfo ; 
line 61831: int addr ; 
line 61832: Expr * pLeft = pExpr -> pLeft ; 
line 61834: if ( rMayHaveNull ) { 
line 61835: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , rMayHaveNull ) ; 
line 61836: } 
line 61838: affinity = sqlite3ExprAffinity ( pLeft ) ; 
line 61853: pExpr -> iTable = pParse -> nTab ++ ; 
line 61854: addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pExpr -> iTable , ! isRowid ) ; 
line 61855: memset ( & keyInfo , 0 , sizeof ( keyInfo ) ) ; 
line 61856: keyInfo . nField = 1 ; 
line 61858: if ( ExprHasProperty ( pExpr , EP_xIsSelect ) ) { 
line 61864: SelectDest dest ; 
line 61865: ExprList * pEList ; 
line 61867: assert ( ! isRowid ) ; 
line 61868: sqlite3SelectDestInit ( & dest , SRT_Set , pExpr -> iTable ) ; 
line 61869: dest . affinity = ( u8 ) affinity ; 
line 61870: assert ( ( pExpr -> iTable & 0x0000FFFF ) == pExpr -> iTable ) ; 
line 61871: if ( sqlite3Select ( pParse , pExpr -> x . pSelect , & dest ) ) { 
line 61872: return 0 ; 
line 61873: } 
line 61874: pEList = pExpr -> x . pSelect -> pEList ; 
line 61875: if ( ALWAYS ( pEList != 0 && pEList -> nExpr > 0 ) ) { 
line 61876: keyInfo . aColl [ 0 ] = sqlite3BinaryCompareCollSeq ( pParse , pExpr -> pLeft , 
line 61877: pEList -> a [ 0 ] . pExpr ) ; 
line 61878: } 
line 61879: } else if ( pExpr -> x . pList != 0 ) { 
line 61887: int i ; 
line 61888: ExprList * pList = pExpr -> x . pList ; 
line 61889: struct ExprList_item * pItem ; 
line 61890: int r1 , r2 , r3 ; 
line 61892: if ( ! affinity ) { 
line 61893: affinity = SQLITE_AFF_NONE ; 
line 61894: } 
line 61895: keyInfo . aColl [ 0 ] = sqlite3ExprCollSeq ( pParse , pExpr -> pLeft ) ; 
line 61898: r1 = sqlite3GetTempReg ( pParse ) ; 
line 61899: r2 = sqlite3GetTempReg ( pParse ) ; 
line 61900: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , r2 ) ; 
line 61901: for ( i = pList -> nExpr , pItem = pList -> a ; i > 0 ; i -- , pItem ++ ) { 
line 61902: Expr * pE2 = pItem -> pExpr ; 
line 61903: int iValToIns ; 
line 61910: if ( testAddr && ! sqlite3ExprIsConstant ( pE2 ) ) { 
line 61911: sqlite3VdbeChangeToNoop ( v , testAddr - 1 , 2 ) ; 
line 61912: testAddr = 0 ; 
line 61913: } 
line 61916: if ( isRowid && sqlite3ExprIsInteger ( pE2 , & iValToIns ) ) { 
line 61917: sqlite3VdbeAddOp3 ( v , OP_InsertInt , pExpr -> iTable , r2 , iValToIns ) ; 
line 61918: } else { 
line 61919: r3 = sqlite3ExprCodeTarget ( pParse , pE2 , r1 ) ; 
line 61920: if ( isRowid ) { 
line 61921: sqlite3VdbeAddOp2 ( v , OP_MustBeInt , r3 , 
line 61922: sqlite3VdbeCurrentAddr ( v ) + 2 ) ; 
line 61923: sqlite3VdbeAddOp3 ( v , OP_Insert , pExpr -> iTable , r2 , r3 ) ; 
line 61924: } else { 
line 61925: sqlite3VdbeAddOp4 ( v , OP_MakeRecord , r3 , 1 , r2 , & affinity , 1 ) ; 
line 61926: sqlite3ExprCacheAffinityChange ( pParse , r3 , 1 ) ; 
line 61927: sqlite3VdbeAddOp2 ( v , OP_IdxInsert , pExpr -> iTable , r2 ) ; 
line 61928: } 
line 61929: } 
line 61930: } 
line 61931: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 61932: sqlite3ReleaseTempReg ( pParse , r2 ) ; 
line 61933: } 
line 61934: if ( ! isRowid ) { 
line 61935: sqlite3VdbeChangeP4 ( v , addr , ( void * ) & keyInfo , P4_KEYINFO ) ; 
line 61936: } 
line 61937: break ; 
line 61938: } 
line 61940: case TK_EXISTS : 
line 61941: case TK_SELECT : 
line 61942: default : { 
line 61949: static const Token one = { "1" , 1 } ; 
line 61950: Select * pSel ; 
line 61951: SelectDest dest ; 
line 61953: testcase ( pExpr -> op == TK_EXISTS ) ; 
line 61954: testcase ( pExpr -> op == TK_SELECT ) ; 
line 61955: assert ( pExpr -> op == TK_EXISTS || pExpr -> op == TK_SELECT ) ; 
line 61957: assert ( ExprHasProperty ( pExpr , EP_xIsSelect ) ) ; 
line 61958: pSel = pExpr -> x . pSelect ; 
line 61959: sqlite3SelectDestInit ( & dest , 0 , ++ pParse -> nMem ) ; 
line 61960: if ( pExpr -> op == TK_SELECT ) { 
line 61961: dest . eDest = SRT_Mem ; 
line 61962: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , dest . iParm ) ; 
line 61963: VdbeComment ( ( v , "Init subquery result" ) ) ; 
line 61964: } else { 
line 61965: dest . eDest = SRT_Exists ; 
line 61966: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , dest . iParm ) ; 
line 61967: VdbeComment ( ( v , "Init EXISTS result" ) ) ; 
line 61968: } 
line 61969: sqlite3ExprDelete ( pParse -> db , pSel -> pLimit ) ; 
line 61970: pSel -> pLimit = sqlite3PExpr ( pParse , TK_INTEGER , 0 , 0 , & one ) ; 
line 61971: if ( sqlite3Select ( pParse , pSel , & dest ) ) { 
line 61972: return 0 ; 
line 61973: } 
line 61974: rReg = dest . iParm ; 
line 61975: ExprSetIrreducible ( pExpr ) ; 
line 61976: break ; 
line 61977: } 
line 61978: } 
line 61980: if ( testAddr ) { 
line 61981: sqlite3VdbeJumpHere ( v , testAddr - 1 ) ; 
line 61982: } 
line 61983: sqlite3ExprCachePop ( pParse , 1 ) ; 
line 61985: return rReg ; 
line 61986: } 
line 61987: # endif 
line 61989: # ifndef SQLITE_OMIT_SUBQUERY 
line 62007: static void sqlite3ExprCodeIN ( 
line 62008: Parse * pParse , 
line 62009: Expr * pExpr , 
line 62010: int destIfFalse , 
line 62011: int destIfNull 
line 62012: ) { 
line 62013: int rRhsHasNull = 0 ; 
line 62014: char affinity ; 
line 62015: int eType ; 
line 62016: int r1 ; 
line 62017: Vdbe * v ; 
line 62022: v = pParse -> pVdbe ; 
line 62023: assert ( v != 0 ) ; 
line 62024: VdbeNoopComment ( ( v , "begin IN expr" ) ) ; 
line 62025: eType = sqlite3FindInIndex ( pParse , pExpr , & rRhsHasNull ) ; 
line 62031: affinity = comparisonAffinity ( pExpr ) ; 
line 62035: sqlite3ExprCachePush ( pParse ) ; 
line 62036: r1 = sqlite3GetTempReg ( pParse ) ; 
line 62037: sqlite3ExprCode ( pParse , pExpr -> pLeft , r1 ) ; 
line 62038: sqlite3VdbeAddOp2 ( v , OP_IsNull , r1 , destIfNull ) ; 
line 62041: if ( eType == IN_INDEX_ROWID ) { 
line 62044: sqlite3VdbeAddOp2 ( v , OP_MustBeInt , r1 , destIfFalse ) ; 
line 62045: sqlite3VdbeAddOp3 ( v , OP_NotExists , pExpr -> iTable , destIfFalse , r1 ) ; 
line 62046: } else { 
line 62049: sqlite3VdbeAddOp4 ( v , OP_Affinity , r1 , 1 , 0 , & affinity , 1 ) ; 
line 62057: if ( rRhsHasNull == 0 || destIfFalse == destIfNull ) { 
line 62065: sqlite3VdbeAddOp4Int ( v , OP_NotFound , pExpr -> iTable , destIfFalse , r1 , 1 ) ; 
line 62067: } else { 
line 62072: int j1 , j2 , j3 ; 
line 62078: j1 = sqlite3VdbeAddOp4Int ( v , OP_Found , pExpr -> iTable , 0 , r1 , 1 ) ; 
line 62086: j2 = sqlite3VdbeAddOp1 ( v , OP_NotNull , rRhsHasNull ) ; 
line 62087: j3 = sqlite3VdbeAddOp4Int ( v , OP_Found , pExpr -> iTable , 0 , rRhsHasNull , 1 ) ; 
line 62088: sqlite3VdbeAddOp2 ( v , OP_Integer , - 1 , rRhsHasNull ) ; 
line 62089: sqlite3VdbeJumpHere ( v , j3 ) ; 
line 62090: sqlite3VdbeAddOp2 ( v , OP_AddImm , rRhsHasNull , 1 ) ; 
line 62091: sqlite3VdbeJumpHere ( v , j2 ) ; 
line 62096: sqlite3VdbeAddOp2 ( v , OP_If , rRhsHasNull , destIfNull ) ; 
line 62097: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , destIfFalse ) ; 
line 62102: sqlite3VdbeJumpHere ( v , j1 ) ; 
line 62103: } 
line 62104: } 
line 62105: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 62106: sqlite3ExprCachePop ( pParse , 1 ) ; 
line 62107: VdbeComment ( ( v , "end IN expr" ) ) ; 
line 62108: } 
line 62109: # endif 
line 62114: static char * dup8bytes ( Vdbe * v , const char * in ) { 
line 62115: char * out = sqlite3DbMallocRaw ( sqlite3VdbeDb ( v ) , 8 ) ; 
line 62116: if ( out ) { 
line 62117: memcpy ( out , in , 8 ) ; 
line 62118: } 
line 62119: return out ; 
line 62120: } 
line 62130: static void codeReal ( Vdbe * v , const char * z , int negateFlag , int iMem ) { 
line 62131: if ( ALWAYS ( z != 0 ) ) { 
line 62132: double value ; 
line 62133: char * zV ; 
line 62134: sqlite3AtoF ( z , & value ) ; 
line 62135: assert ( ! sqlite3IsNaN ( value ) ) ; 
line 62136: if ( negateFlag ) value = - value ; 
line 62137: zV = dup8bytes ( v , ( char * ) & value ) ; 
line 62138: sqlite3VdbeAddOp4 ( v , OP_Real , 0 , iMem , 0 , zV , P4_REAL ) ; 
line 62139: } 
line 62140: } 
line 62151: static void codeInteger ( Vdbe * v , Expr * pExpr , int negFlag , int iMem ) { 
line 62152: if ( pExpr -> flags & EP_IntValue ) { 
line 62153: int i = pExpr -> u . iValue ; 
line 62154: if ( negFlag ) i = - i ; 
line 62155: sqlite3VdbeAddOp2 ( v , OP_Integer , i , iMem ) ; 
line 62156: } else { 
line 62157: const char * z = pExpr -> u . zToken ; 
line 62158: assert ( z != 0 ) ; 
line 62159: if ( sqlite3FitsIn64Bits ( z , negFlag ) ) { 
line 62160: i64 value ; 
line 62161: char * zV ; 
line 62162: sqlite3Atoi64 ( z , & value ) ; 
line 62163: if ( negFlag ) value = - value ; 
line 62164: zV = dup8bytes ( v , ( char * ) & value ) ; 
line 62165: sqlite3VdbeAddOp4 ( v , OP_Int64 , 0 , iMem , 0 , zV , P4_INT64 ) ; 
line 62166: } else { 
line 62167: codeReal ( v , z , negFlag , iMem ) ; 
line 62168: } 
line 62169: } 
line 62170: } 
line 62175: static void cacheEntryClear ( Parse * pParse , struct yColCache * p ) { 
line 62176: if ( p -> tempReg ) { 
line 62177: if ( pParse -> nTempReg < ArraySize ( pParse -> aTempReg ) ) { 
line 62178: pParse -> aTempReg [ pParse -> nTempReg ++ ] = p -> iReg ; 
line 62179: } 
line 62180: p -> tempReg = 0 ; 
line 62181: } 
line 62182: } 
line 62189: SQLITE_PRIVATE void sqlite3ExprCacheStore ( Parse * pParse , int iTab , int iCol , int iReg ) { 
line 62190: int i ; 
line 62191: int minLru ; 
line 62192: int idxLru ; 
line 62193: struct yColCache * p ; 
line 62195: assert ( iReg > 0 ) ; 
line 62196: assert ( iCol >= - 1 && iCol < 32768 ) ; 
line 62202: if ( pParse -> db -> flags & SQLITE_ColumnCache ) return ; 
line 62209: # ifndef NDEBUG 
line 62210: for ( i = 0 , p = pParse -> aColCache ; i < SQLITE_N_COLCACHE ; i ++ , p ++ ) { 
line 62211: # if 0 
line 62212: if ( p -> iReg && p -> iTable == iTab && p -> iColumn == iCol ) { 
line 62213: cacheEntryClear ( pParse , p ) ; 
line 62214: p -> iLevel = pParse -> iCacheLevel ; 
line 62215: p -> iReg = iReg ; 
line 62216: p -> lru = pParse -> iCacheCnt ++ ; 
line 62217: return ; 
line 62218: } 
line 62219: # endif 
line 62220: assert ( p -> iReg == 0 || p -> iTable != iTab || p -> iColumn != iCol ) ; 
line 62221: } 
line 62222: # endif 
line 62225: for ( i = 0 , p = pParse -> aColCache ; i < SQLITE_N_COLCACHE ; i ++ , p ++ ) { 
line 62226: if ( p -> iReg == 0 ) { 
line 62227: p -> iLevel = pParse -> iCacheLevel ; 
line 62228: p -> iTable = iTab ; 
line 62229: p -> iColumn = iCol ; 
line 62230: p -> iReg = iReg ; 
line 62231: p -> tempReg = 0 ; 
line 62232: p -> lru = pParse -> iCacheCnt ++ ; 
line 62233: return ; 
line 62234: } 
line 62235: } 
line 62238: minLru = 0x7fffffff ; 
line 62239: idxLru = - 1 ; 
line 62240: for ( i = 0 , p = pParse -> aColCache ; i < SQLITE_N_COLCACHE ; i ++ , p ++ ) { 
line 62241: if ( p -> lru < minLru ) { 
line 62242: idxLru = i ; 
line 62243: minLru = p -> lru ; 
line 62244: } 
line 62245: } 
line 62246: if ( ALWAYS ( idxLru >= 0 ) ) { 
line 62247: p = & pParse -> aColCache [ idxLru ] ; 
line 62248: p -> iLevel = pParse -> iCacheLevel ; 
line 62249: p -> iTable = iTab ; 
line 62250: p -> iColumn = iCol ; 
line 62251: p -> iReg = iReg ; 
line 62252: p -> tempReg = 0 ; 
line 62253: p -> lru = pParse -> iCacheCnt ++ ; 
line 62254: return ; 
line 62255: } 
line 62256: } 
line 62262: SQLITE_PRIVATE void sqlite3ExprCacheRemove ( Parse * pParse , int iReg , int nReg ) { 
line 62263: int i ; 
line 62264: int iLast = iReg + nReg - 1 ; 
line 62265: struct yColCache * p ; 
line 62266: for ( i = 0 , p = pParse -> aColCache ; i < SQLITE_N_COLCACHE ; i ++ , p ++ ) { 
line 62267: int r = p -> iReg ; 
line 62268: if ( r >= iReg && r <= iLast ) { 
line 62269: cacheEntryClear ( pParse , p ) ; 
line 62270: p -> iReg = 0 ; 
line 62271: } 
line 62272: } 
line 62273: } 
line 62280: SQLITE_PRIVATE void sqlite3ExprCachePush ( Parse * pParse ) { 
line 62281: pParse -> iCacheLevel ++ ; 
line 62282: } 
line 62289: SQLITE_PRIVATE void sqlite3ExprCachePop ( Parse * pParse , int N ) { 
line 62290: int i ; 
line 62291: struct yColCache * p ; 
line 62292: assert ( N > 0 ) ; 
line 62293: assert ( pParse -> iCacheLevel >= N ) ; 
line 62294: pParse -> iCacheLevel -= N ; 
line 62295: for ( i = 0 , p = pParse -> aColCache ; i < SQLITE_N_COLCACHE ; i ++ , p ++ ) { 
line 62296: if ( p -> iReg && p -> iLevel > pParse -> iCacheLevel ) { 
line 62297: cacheEntryClear ( pParse , p ) ; 
line 62298: p -> iReg = 0 ; 
line 62299: } 
line 62300: } 
line 62301: } 
line 62309: static void sqlite3ExprCachePinRegister ( Parse * pParse , int iReg ) { 
line 62310: int i ; 
line 62311: struct yColCache * p ; 
line 62312: for ( i = 0 , p = pParse -> aColCache ; i < SQLITE_N_COLCACHE ; i ++ , p ++ ) { 
line 62313: if ( p -> iReg == iReg ) { 
line 62314: p -> tempReg = 0 ; 
line 62315: } 
line 62316: } 
line 62317: } 
line 62328: SQLITE_PRIVATE int sqlite3ExprCodeGetColumn ( 
line 62329: Parse * pParse , 
line 62330: Table * pTab , 
line 62331: int iColumn , 
line 62332: int iTable , 
line 62333: int iReg 
line 62334: ) { 
line 62335: Vdbe * v = pParse -> pVdbe ; 
line 62336: int i ; 
line 62337: struct yColCache * p ; 
line 62339: for ( i = 0 , p = pParse -> aColCache ; i < SQLITE_N_COLCACHE ; i ++ , p ++ ) { 
line 62340: if ( p -> iReg > 0 && p -> iTable == iTable && p -> iColumn == iColumn ) { 
line 62341: p -> lru = pParse -> iCacheCnt ++ ; 
line 62342: sqlite3ExprCachePinRegister ( pParse , p -> iReg ) ; 
line 62343: return p -> iReg ; 
line 62344: } 
line 62345: } 
line 62346: assert ( v != 0 ) ; 
line 62347: if ( iColumn < 0 ) { 
line 62348: sqlite3VdbeAddOp2 ( v , OP_Rowid , iTable , iReg ) ; 
line 62349: } else if ( ALWAYS ( pTab != 0 ) ) { 
line 62350: int op = IsVirtual ( pTab ) ? OP_VColumn : OP_Column ; 
line 62351: sqlite3VdbeAddOp3 ( v , op , iTable , iColumn , iReg ) ; 
line 62352: sqlite3ColumnDefault ( v , pTab , iColumn , iReg ) ; 
line 62353: } 
line 62354: sqlite3ExprCacheStore ( pParse , iTable , iColumn , iReg ) ; 
line 62355: return iReg ; 
line 62356: } 
line 62361: SQLITE_PRIVATE void sqlite3ExprCacheClear ( Parse * pParse ) { 
line 62362: int i ; 
line 62363: struct yColCache * p ; 
line 62365: for ( i = 0 , p = pParse -> aColCache ; i < SQLITE_N_COLCACHE ; i ++ , p ++ ) { 
line 62366: if ( p -> iReg ) { 
line 62367: cacheEntryClear ( pParse , p ) ; 
line 62368: p -> iReg = 0 ; 
line 62369: } 
line 62370: } 
line 62371: } 
line 62377: SQLITE_PRIVATE void sqlite3ExprCacheAffinityChange ( Parse * pParse , int iStart , int iCount ) { 
line 62378: sqlite3ExprCacheRemove ( pParse , iStart , iCount ) ; 
line 62379: } 
line 62385: SQLITE_PRIVATE void sqlite3ExprCodeMove ( Parse * pParse , int iFrom , int iTo , int nReg ) { 
line 62386: int i ; 
line 62387: struct yColCache * p ; 
line 62388: if ( NEVER ( iFrom == iTo ) ) return ; 
line 62389: sqlite3VdbeAddOp3 ( pParse -> pVdbe , OP_Move , iFrom , iTo , nReg ) ; 
line 62390: for ( i = 0 , p = pParse -> aColCache ; i < SQLITE_N_COLCACHE ; i ++ , p ++ ) { 
line 62391: int x = p -> iReg ; 
line 62392: if ( x >= iFrom && x < iFrom + nReg ) { 
line 62393: p -> iReg += iTo - iFrom ; 
line 62394: } 
line 62395: } 
line 62396: } 
line 62402: SQLITE_PRIVATE void sqlite3ExprCodeCopy ( Parse * pParse , int iFrom , int iTo , int nReg ) { 
line 62403: int i ; 
line 62404: if ( NEVER ( iFrom == iTo ) ) return ; 
line 62405: for ( i = 0 ; i < nReg ; i ++ ) { 
line 62406: sqlite3VdbeAddOp2 ( pParse -> pVdbe , OP_Copy , iFrom + i , iTo + i ) ; 
line 62407: } 
line 62408: } 
line 62410: # if defined ( SQLITE_DEBUG ) || defined ( SQLITE_COVERAGE_TEST ) 
line 62418: static int usedAsColumnCache ( Parse * pParse , int iFrom , int iTo ) { 
line 62419: int i ; 
line 62420: struct yColCache * p ; 
line 62421: for ( i = 0 , p = pParse -> aColCache ; i < SQLITE_N_COLCACHE ; i ++ , p ++ ) { 
line 62422: int r = p -> iReg ; 
line 62423: if ( r >= iFrom && r <= iTo ) return 1 ; 
line 62424: } 
line 62425: return 0 ; 
line 62426: } 
line 62427: # endif 
line 62434: SQLITE_PRIVATE void sqlite3ExprHardCopy ( Parse * pParse , int iReg , int nReg ) { 
line 62435: VdbeOp * pOp ; 
line 62436: Vdbe * v ; 
line 62438: assert ( pParse -> db -> mallocFailed == 0 ) ; 
line 62439: v = pParse -> pVdbe ; 
line 62440: assert ( v != 0 ) ; 
line 62441: pOp = sqlite3VdbeGetOp ( v , - 1 ) ; 
line 62442: assert ( pOp != 0 ) ; 
line 62443: if ( pOp -> opcode == OP_SCopy && pOp -> p1 >= iReg && pOp -> p1 < iReg + nReg ) { 
line 62444: pOp -> opcode = OP_Copy ; 
line 62445: } 
line 62446: } 
line 62465: static int codeAlias ( Parse * pParse , int iAlias , Expr * pExpr , int target ) { 
line 62466: # if 0 
line 62467: sqlite3 * db = pParse -> db ; 
line 62468: int iReg ; 
line 62469: if ( pParse -> nAliasAlloc < pParse -> nAlias ) { 
line 62470: pParse -> aAlias = sqlite3DbReallocOrFree ( db , pParse -> aAlias , 
line 62471: sizeof ( pParse -> aAlias [ 0 ] ) * pParse -> nAlias ) ; 
line 62472: testcase ( db -> mallocFailed && pParse -> nAliasAlloc > 0 ) ; 
line 62473: if ( db -> mallocFailed ) return 0 ; 
line 62474: memset ( & pParse -> aAlias [ pParse -> nAliasAlloc ] , 0 , 
line 62475: ( pParse -> nAlias - pParse -> nAliasAlloc ) * sizeof ( pParse -> aAlias [ 0 ] ) ) ; 
line 62476: pParse -> nAliasAlloc = pParse -> nAlias ; 
line 62477: } 
line 62478: assert ( iAlias > 0 && iAlias <= pParse -> nAlias ) ; 
line 62479: iReg = pParse -> aAlias [ iAlias - 1 ] ; 
line 62480: if ( iReg == 0 ) { 
line 62481: if ( pParse -> iCacheLevel > 0 ) { 
line 62482: iReg = sqlite3ExprCodeTarget ( pParse , pExpr , target ) ; 
line 62483: } else { 
line 62484: iReg = ++ pParse -> nMem ; 
line 62485: sqlite3ExprCode ( pParse , pExpr , iReg ) ; 
line 62486: pParse -> aAlias [ iAlias - 1 ] = iReg ; 
line 62487: } 
line 62488: } 
line 62489: return iReg ; 
line 62490: # else 
line 62491: UNUSED_PARAMETER ( iAlias ) ; 
line 62492: return sqlite3ExprCodeTarget ( pParse , pExpr , target ) ; 
line 62493: # endif 
line 62494: } 
line 62507: SQLITE_PRIVATE int sqlite3ExprCodeTarget ( Parse * pParse , Expr * pExpr , int target ) { 
line 62508: Vdbe * v = pParse -> pVdbe ; 
line 62509: int op ; 
line 62510: int inReg = target ; 
line 62511: int regFree1 = 0 ; 
line 62512: int regFree2 = 0 ; 
line 62513: int r1 , r2 , r3 , r4 ; 
line 62514: sqlite3 * db = pParse -> db ; 
line 62516: assert ( target > 0 && target <= pParse -> nMem ) ; 
line 62517: if ( v == 0 ) { 
line 62518: assert ( pParse -> db -> mallocFailed ) ; 
line 62519: return 0 ; 
line 62520: } 
line 62522: if ( pExpr == 0 ) { 
line 62523: op = TK_NULL ; 
line 62524: } else { 
line 62525: op = pExpr -> op ; 
line 62526: } 
line 62527: switch ( op ) { 
line 62528: case TK_AGG_COLUMN : { 
line 62529: AggInfo * pAggInfo = pExpr -> pAggInfo ; 
line 62530: struct AggInfo_col * pCol = & pAggInfo -> aCol [ pExpr -> iAgg ] ; 
line 62531: if ( ! pAggInfo -> directMode ) { 
line 62532: assert ( pCol -> iMem > 0 ) ; 
line 62533: inReg = pCol -> iMem ; 
line 62534: break ; 
line 62535: } else if ( pAggInfo -> useSortingIdx ) { 
line 62536: sqlite3VdbeAddOp3 ( v , OP_Column , pAggInfo -> sortingIdx , 
line 62537: pCol -> iSorterColumn , target ) ; 
line 62538: break ; 
line 62539: } 
line 62541: } 
line 62542: case TK_COLUMN : { 
line 62543: if ( pExpr -> iTable < 0 ) { 
line 62545: assert ( pParse -> ckBase > 0 ) ; 
line 62546: inReg = pExpr -> iColumn + pParse -> ckBase ; 
line 62547: } else { 
line 62548: inReg = sqlite3ExprCodeGetColumn ( pParse , pExpr -> pTab , 
line 62549: pExpr -> iColumn , pExpr -> iTable , target ) ; 
line 62550: } 
line 62551: break ; 
line 62552: } 
line 62553: case TK_INTEGER : { 
line 62554: codeInteger ( v , pExpr , 0 , target ) ; 
line 62555: break ; 
line 62556: } 
line 62557: case TK_FLOAT : { 
line 62558: assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; 
line 62559: codeReal ( v , pExpr -> u . zToken , 0 , target ) ; 
line 62560: break ; 
line 62561: } 
line 62562: case TK_STRING : { 
line 62563: assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; 
line 62564: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , target , 0 , pExpr -> u . zToken , 0 ) ; 
line 62565: break ; 
line 62566: } 
line 62567: case TK_NULL : { 
line 62568: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , target ) ; 
line 62569: break ; 
line 62570: } 
line 62571: # ifndef SQLITE_OMIT_BLOB_LITERAL 
line 62572: case TK_BLOB : { 
line 62573: int n ; 
line 62574: const char * z ; 
line 62575: char * zBlob ; 
line 62576: assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; 
line 62577: assert ( pExpr -> u . zToken [ 0 ] == 'x' || pExpr -> u . zToken [ 0 ] == 'X' ) ; 
line 62578: assert ( pExpr -> u . zToken [ 1 ] == '\'' ) ; 
line 62579: z = & pExpr -> u . zToken [ 2 ] ; 
line 62580: n = sqlite3Strlen30 ( z ) - 1 ; 
line 62581: assert ( z [ n ] == '\'' ) ; 
line 62582: zBlob = sqlite3HexToBlob ( sqlite3VdbeDb ( v ) , z , n ) ; 
line 62583: sqlite3VdbeAddOp4 ( v , OP_Blob , n / 2 , target , 0 , zBlob , P4_DYNAMIC ) ; 
line 62584: break ; 
line 62585: } 
line 62586: # endif 
line 62587: case TK_VARIABLE : { 
line 62588: VdbeOp * pOp ; 
line 62589: assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; 
line 62590: assert ( pExpr -> u . zToken != 0 ) ; 
line 62591: assert ( pExpr -> u . zToken [ 0 ] != 0 ) ; 
line 62592: if ( pExpr -> u . zToken [ 1 ] == 0 
line 62593: && ( pOp = sqlite3VdbeGetOp ( v , - 1 ) ) -> opcode == OP_Variable 
line 62594: && pOp -> p1 + pOp -> p3 == pExpr -> iColumn 
line 62595: && pOp -> p2 + pOp -> p3 == target 
line 62596: && pOp -> p4 . z == 0 
line 62597: ) { 
line 62603: pOp -> p3 ++ ; 
line 62604: } else { 
line 62605: sqlite3VdbeAddOp3 ( v , OP_Variable , pExpr -> iColumn , target , 1 ) ; 
line 62606: if ( pExpr -> u . zToken [ 1 ] != 0 ) { 
line 62607: sqlite3VdbeChangeP4 ( v , - 1 , pExpr -> u . zToken , 0 ) ; 
line 62608: } 
line 62609: } 
line 62610: break ; 
line 62611: } 
line 62612: case TK_REGISTER : { 
line 62613: inReg = pExpr -> iTable ; 
line 62614: break ; 
line 62615: } 
line 62616: case TK_AS : { 
line 62617: inReg = codeAlias ( pParse , pExpr -> iTable , pExpr -> pLeft , target ) ; 
line 62618: break ; 
line 62619: } 
line 62620: # ifndef SQLITE_OMIT_CAST 
line 62621: case TK_CAST : { 
line 62623: int aff , to_op ; 
line 62624: inReg = sqlite3ExprCodeTarget ( pParse , pExpr -> pLeft , target ) ; 
line 62625: assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; 
line 62626: aff = sqlite3AffinityType ( pExpr -> u . zToken ) ; 
line 62627: to_op = aff - SQLITE_AFF_TEXT + OP_ToText ; 
line 62628: assert ( to_op == OP_ToText || aff != SQLITE_AFF_TEXT ) ; 
line 62629: assert ( to_op == OP_ToBlob || aff != SQLITE_AFF_NONE ) ; 
line 62630: assert ( to_op == OP_ToNumeric || aff != SQLITE_AFF_NUMERIC ) ; 
line 62631: assert ( to_op == OP_ToInt || aff != SQLITE_AFF_INTEGER ) ; 
line 62632: assert ( to_op == OP_ToReal || aff != SQLITE_AFF_REAL ) ; 
line 62633: testcase ( to_op == OP_ToText ) ; 
line 62634: testcase ( to_op == OP_ToBlob ) ; 
line 62635: testcase ( to_op == OP_ToNumeric ) ; 
line 62636: testcase ( to_op == OP_ToInt ) ; 
line 62637: testcase ( to_op == OP_ToReal ) ; 
line 62638: if ( inReg != target ) { 
line 62639: sqlite3VdbeAddOp2 ( v , OP_SCopy , inReg , target ) ; 
line 62640: inReg = target ; 
line 62641: } 
line 62642: sqlite3VdbeAddOp1 ( v , to_op , inReg ) ; 
line 62643: testcase ( usedAsColumnCache ( pParse , inReg , inReg ) ) ; 
line 62644: sqlite3ExprCacheAffinityChange ( pParse , inReg , 1 ) ; 
line 62645: break ; 
line 62646: } 
line 62647: # endif 
line 62648: case TK_LT : 
line 62649: case TK_LE : 
line 62650: case TK_GT : 
line 62651: case TK_GE : 
line 62652: case TK_NE : 
line 62653: case TK_EQ : { 
line 62654: assert ( TK_LT == OP_Lt ) ; 
line 62655: assert ( TK_LE == OP_Le ) ; 
line 62656: assert ( TK_GT == OP_Gt ) ; 
line 62657: assert ( TK_GE == OP_Ge ) ; 
line 62658: assert ( TK_EQ == OP_Eq ) ; 
line 62659: assert ( TK_NE == OP_Ne ) ; 
line 62660: testcase ( op == TK_LT ) ; 
line 62661: testcase ( op == TK_LE ) ; 
line 62662: testcase ( op == TK_GT ) ; 
line 62663: testcase ( op == TK_GE ) ; 
line 62664: testcase ( op == TK_EQ ) ; 
line 62665: testcase ( op == TK_NE ) ; 
line 62666: r1 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree1 ) ; 
line 62667: r2 = sqlite3ExprCodeTemp ( pParse , pExpr -> pRight , & regFree2 ) ; 
line 62668: codeCompare ( pParse , pExpr -> pLeft , pExpr -> pRight , op , 
line 62669: r1 , r2 , inReg , SQLITE_STOREP2 ) ; 
line 62670: testcase ( regFree1 == 0 ) ; 
line 62671: testcase ( regFree2 == 0 ) ; 
line 62672: break ; 
line 62673: } 
line 62674: case TK_IS : 
line 62675: case TK_ISNOT : { 
line 62676: testcase ( op == TK_IS ) ; 
line 62677: testcase ( op == TK_ISNOT ) ; 
line 62678: r1 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree1 ) ; 
line 62679: r2 = sqlite3ExprCodeTemp ( pParse , pExpr -> pRight , & regFree2 ) ; 
line 62680: op = ( op == TK_IS ) ? TK_EQ : TK_NE ; 
line 62681: codeCompare ( pParse , pExpr -> pLeft , pExpr -> pRight , op , 
line 62682: r1 , r2 , inReg , SQLITE_STOREP2 | SQLITE_NULLEQ ) ; 
line 62683: testcase ( regFree1 == 0 ) ; 
line 62684: testcase ( regFree2 == 0 ) ; 
line 62685: break ; 
line 62686: } 
line 62687: case TK_AND : 
line 62688: case TK_OR : 
line 62689: case TK_PLUS : 
line 62690: case TK_STAR : 
line 62691: case TK_MINUS : 
line 62692: case TK_REM : 
line 62693: case TK_BITAND : 
line 62694: case TK_BITOR : 
line 62695: case TK_SLASH : 
line 62696: case TK_LSHIFT : 
line 62697: case TK_RSHIFT : 
line 62698: case TK_CONCAT : { 
line 62699: assert ( TK_AND == OP_And ) ; 
line 62700: assert ( TK_OR == OP_Or ) ; 
line 62701: assert ( TK_PLUS == OP_Add ) ; 
line 62702: assert ( TK_MINUS == OP_Subtract ) ; 
line 62703: assert ( TK_REM == OP_Remainder ) ; 
line 62704: assert ( TK_BITAND == OP_BitAnd ) ; 
line 62705: assert ( TK_BITOR == OP_BitOr ) ; 
line 62706: assert ( TK_SLASH == OP_Divide ) ; 
line 62707: assert ( TK_LSHIFT == OP_ShiftLeft ) ; 
line 62708: assert ( TK_RSHIFT == OP_ShiftRight ) ; 
line 62709: assert ( TK_CONCAT == OP_Concat ) ; 
line 62710: testcase ( op == TK_AND ) ; 
line 62711: testcase ( op == TK_OR ) ; 
line 62712: testcase ( op == TK_PLUS ) ; 
line 62713: testcase ( op == TK_MINUS ) ; 
line 62714: testcase ( op == TK_REM ) ; 
line 62715: testcase ( op == TK_BITAND ) ; 
line 62716: testcase ( op == TK_BITOR ) ; 
line 62717: testcase ( op == TK_SLASH ) ; 
line 62718: testcase ( op == TK_LSHIFT ) ; 
line 62719: testcase ( op == TK_RSHIFT ) ; 
line 62720: testcase ( op == TK_CONCAT ) ; 
line 62721: r1 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree1 ) ; 
line 62722: r2 = sqlite3ExprCodeTemp ( pParse , pExpr -> pRight , & regFree2 ) ; 
line 62723: sqlite3VdbeAddOp3 ( v , op , r2 , r1 , target ) ; 
line 62724: testcase ( regFree1 == 0 ) ; 
line 62725: testcase ( regFree2 == 0 ) ; 
line 62726: break ; 
line 62727: } 
line 62728: case TK_UMINUS : { 
line 62729: Expr * pLeft = pExpr -> pLeft ; 
line 62730: assert ( pLeft ) ; 
line 62731: if ( pLeft -> op == TK_FLOAT ) { 
line 62732: assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; 
line 62733: codeReal ( v , pLeft -> u . zToken , 1 , target ) ; 
line 62734: } else if ( pLeft -> op == TK_INTEGER ) { 
line 62735: codeInteger ( v , pLeft , 1 , target ) ; 
line 62736: } else { 
line 62737: regFree1 = r1 = sqlite3GetTempReg ( pParse ) ; 
line 62738: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , r1 ) ; 
line 62739: r2 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree2 ) ; 
line 62740: sqlite3VdbeAddOp3 ( v , OP_Subtract , r2 , r1 , target ) ; 
line 62741: testcase ( regFree2 == 0 ) ; 
line 62742: } 
line 62743: inReg = target ; 
line 62744: break ; 
line 62745: } 
line 62746: case TK_BITNOT : 
line 62747: case TK_NOT : { 
line 62748: assert ( TK_BITNOT == OP_BitNot ) ; 
line 62749: assert ( TK_NOT == OP_Not ) ; 
line 62750: testcase ( op == TK_BITNOT ) ; 
line 62751: testcase ( op == TK_NOT ) ; 
line 62752: r1 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree1 ) ; 
line 62753: testcase ( regFree1 == 0 ) ; 
line 62754: inReg = target ; 
line 62755: sqlite3VdbeAddOp2 ( v , op , r1 , inReg ) ; 
line 62756: break ; 
line 62757: } 
line 62758: case TK_ISNULL : 
line 62759: case TK_NOTNULL : { 
line 62760: int addr ; 
line 62761: assert ( TK_ISNULL == OP_IsNull ) ; 
line 62762: assert ( TK_NOTNULL == OP_NotNull ) ; 
line 62763: testcase ( op == TK_ISNULL ) ; 
line 62764: testcase ( op == TK_NOTNULL ) ; 
line 62765: sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , target ) ; 
line 62766: r1 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree1 ) ; 
line 62767: testcase ( regFree1 == 0 ) ; 
line 62768: addr = sqlite3VdbeAddOp1 ( v , op , r1 ) ; 
line 62769: sqlite3VdbeAddOp2 ( v , OP_AddImm , target , - 1 ) ; 
line 62770: sqlite3VdbeJumpHere ( v , addr ) ; 
line 62771: break ; 
line 62772: } 
line 62773: case TK_AGG_FUNCTION : { 
line 62774: AggInfo * pInfo = pExpr -> pAggInfo ; 
line 62775: if ( pInfo == 0 ) { 
line 62776: assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; 
line 62777: sqlite3ErrorMsg ( pParse , "misuse of aggregate: %s()" , pExpr -> u . zToken ) ; 
line 62778: } else { 
line 62779: inReg = pInfo -> aFunc [ pExpr -> iAgg ] . iMem ; 
line 62780: } 
line 62781: break ; 
line 62782: } 
line 62783: case TK_CONST_FUNC : 
line 62784: case TK_FUNCTION : { 
line 62785: ExprList * pFarg ; 
line 62786: int nFarg ; 
line 62787: FuncDef * pDef ; 
line 62788: int nId ; 
line 62789: const char * zId ; 
line 62790: int constMask = 0 ; 
line 62791: int i ; 
line 62792: u8 enc = ENC ( db ) ; 
line 62793: CollSeq * pColl = 0 ; 
line 62795: assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ) ; 
line 62796: testcase ( op == TK_CONST_FUNC ) ; 
line 62797: testcase ( op == TK_FUNCTION ) ; 
line 62798: if ( ExprHasAnyProperty ( pExpr , EP_TokenOnly ) ) { 
line 62799: pFarg = 0 ; 
line 62800: } else { 
line 62801: pFarg = pExpr -> x . pList ; 
line 62802: } 
line 62803: nFarg = pFarg ? pFarg -> nExpr : 0 ; 
line 62804: assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; 
line 62805: zId = pExpr -> u . zToken ; 
line 62806: nId = sqlite3Strlen30 ( zId ) ; 
line 62807: pDef = sqlite3FindFunction ( db , zId , nId , nFarg , enc , 0 ) ; 
line 62808: if ( pDef == 0 ) { 
line 62809: sqlite3ErrorMsg ( pParse , "unknown function: %.*s()" , nId , zId ) ; 
line 62810: break ; 
line 62811: } 
line 62817: if ( pDef -> flags & SQLITE_FUNC_COALESCE ) { 
line 62818: int endCoalesce = sqlite3VdbeMakeLabel ( v ) ; 
line 62819: assert ( nFarg >= 2 ) ; 
line 62820: sqlite3ExprCode ( pParse , pFarg -> a [ 0 ] . pExpr , target ) ; 
line 62821: for ( i = 1 ; i < nFarg ; i ++ ) { 
line 62822: sqlite3VdbeAddOp2 ( v , OP_NotNull , target , endCoalesce ) ; 
line 62823: sqlite3ExprCacheRemove ( pParse , target , 1 ) ; 
line 62824: sqlite3ExprCachePush ( pParse ) ; 
line 62825: sqlite3ExprCode ( pParse , pFarg -> a [ i ] . pExpr , target ) ; 
line 62826: sqlite3ExprCachePop ( pParse , 1 ) ; 
line 62827: } 
line 62828: sqlite3VdbeResolveLabel ( v , endCoalesce ) ; 
line 62829: break ; 
line 62830: } 
line 62833: if ( pFarg ) { 
line 62834: r1 = sqlite3GetTempRange ( pParse , nFarg ) ; 
line 62835: sqlite3ExprCachePush ( pParse ) ; 
line 62836: sqlite3ExprCodeExprList ( pParse , pFarg , r1 , 1 ) ; 
line 62837: sqlite3ExprCachePop ( pParse , 1 ) ; 
line 62838: } else { 
line 62839: r1 = 0 ; 
line 62840: } 
line 62841: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 62854: if ( nFarg >= 2 && ( pExpr -> flags & EP_InfixFunc ) ) { 
line 62855: pDef = sqlite3VtabOverloadFunction ( db , pDef , nFarg , pFarg -> a [ 1 ] . pExpr ) ; 
line 62856: } else if ( nFarg > 0 ) { 
line 62857: pDef = sqlite3VtabOverloadFunction ( db , pDef , nFarg , pFarg -> a [ 0 ] . pExpr ) ; 
line 62858: } 
line 62859: # endif 
line 62860: for ( i = 0 ; i < nFarg ; i ++ ) { 
line 62861: if ( i < 32 && sqlite3ExprIsConstant ( pFarg -> a [ i ] . pExpr ) ) { 
line 62862: constMask |= ( 1 << i ) ; 
line 62863: } 
line 62864: if ( ( pDef -> flags & SQLITE_FUNC_NEEDCOLL ) != 0 && ! pColl ) { 
line 62865: pColl = sqlite3ExprCollSeq ( pParse , pFarg -> a [ i ] . pExpr ) ; 
line 62866: } 
line 62867: } 
line 62868: if ( pDef -> flags & SQLITE_FUNC_NEEDCOLL ) { 
line 62869: if ( ! pColl ) pColl = db -> pDfltColl ; 
line 62870: sqlite3VdbeAddOp4 ( v , OP_CollSeq , 0 , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ) ; 
line 62871: } 
line 62872: sqlite3VdbeAddOp4 ( v , OP_Function , constMask , r1 , target , 
line 62873: ( char * ) pDef , P4_FUNCDEF ) ; 
line 62874: sqlite3VdbeChangeP5 ( v , ( u8 ) nFarg ) ; 
line 62875: if ( nFarg ) { 
line 62876: sqlite3ReleaseTempRange ( pParse , r1 , nFarg ) ; 
line 62877: } 
line 62878: break ; 
line 62879: } 
line 62880: # ifndef SQLITE_OMIT_SUBQUERY 
line 62881: case TK_EXISTS : 
line 62882: case TK_SELECT : { 
line 62883: testcase ( op == TK_EXISTS ) ; 
line 62884: testcase ( op == TK_SELECT ) ; 
line 62885: inReg = sqlite3CodeSubselect ( pParse , pExpr , 0 , 0 ) ; 
line 62886: break ; 
line 62887: } 
line 62888: case TK_IN : { 
line 62889: int destIfFalse = sqlite3VdbeMakeLabel ( v ) ; 
line 62890: int destIfNull = sqlite3VdbeMakeLabel ( v ) ; 
line 62891: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , target ) ; 
line 62892: sqlite3ExprCodeIN ( pParse , pExpr , destIfFalse , destIfNull ) ; 
line 62893: sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , target ) ; 
line 62894: sqlite3VdbeResolveLabel ( v , destIfFalse ) ; 
line 62895: sqlite3VdbeAddOp2 ( v , OP_AddImm , target , 0 ) ; 
line 62896: sqlite3VdbeResolveLabel ( v , destIfNull ) ; 
line 62897: break ; 
line 62898: } 
line 62899: # endif 
line 62913: case TK_BETWEEN : { 
line 62914: Expr * pLeft = pExpr -> pLeft ; 
line 62915: struct ExprList_item * pLItem = pExpr -> x . pList -> a ; 
line 62916: Expr * pRight = pLItem -> pExpr ; 
line 62918: r1 = sqlite3ExprCodeTemp ( pParse , pLeft , & regFree1 ) ; 
line 62919: r2 = sqlite3ExprCodeTemp ( pParse , pRight , & regFree2 ) ; 
line 62920: testcase ( regFree1 == 0 ) ; 
line 62921: testcase ( regFree2 == 0 ) ; 
line 62922: r3 = sqlite3GetTempReg ( pParse ) ; 
line 62923: r4 = sqlite3GetTempReg ( pParse ) ; 
line 62924: codeCompare ( pParse , pLeft , pRight , OP_Ge , 
line 62925: r1 , r2 , r3 , SQLITE_STOREP2 ) ; 
line 62926: pLItem ++ ; 
line 62927: pRight = pLItem -> pExpr ; 
line 62928: sqlite3ReleaseTempReg ( pParse , regFree2 ) ; 
line 62929: r2 = sqlite3ExprCodeTemp ( pParse , pRight , & regFree2 ) ; 
line 62930: testcase ( regFree2 == 0 ) ; 
line 62931: codeCompare ( pParse , pLeft , pRight , OP_Le , r1 , r2 , r4 , SQLITE_STOREP2 ) ; 
line 62932: sqlite3VdbeAddOp3 ( v , OP_And , r3 , r4 , target ) ; 
line 62933: sqlite3ReleaseTempReg ( pParse , r3 ) ; 
line 62934: sqlite3ReleaseTempReg ( pParse , r4 ) ; 
line 62935: break ; 
line 62936: } 
line 62937: case TK_UPLUS : { 
line 62938: inReg = sqlite3ExprCodeTarget ( pParse , pExpr -> pLeft , target ) ; 
line 62939: break ; 
line 62940: } 
line 62942: case TK_TRIGGER : { 
line 62968: Table * pTab = pExpr -> pTab ; 
line 62969: int p1 = pExpr -> iTable * ( pTab -> nCol + 1 ) + 1 + pExpr -> iColumn ; 
line 62971: assert ( pExpr -> iTable == 0 || pExpr -> iTable == 1 ) ; 
line 62972: assert ( pExpr -> iColumn >= - 1 && pExpr -> iColumn < pTab -> nCol ) ; 
line 62973: assert ( pTab -> iPKey < 0 || pExpr -> iColumn != pTab -> iPKey ) ; 
line 62974: assert ( p1 >= 0 && p1 < ( pTab -> nCol * 2 + 2 ) ) ; 
line 62976: sqlite3VdbeAddOp2 ( v , OP_Param , p1 , target ) ; 
line 62977: VdbeComment ( ( v , "%s.%s -> $%d" , 
line 62978: ( pExpr -> iTable ? "new" : "old" ) , 
line 62979: ( pExpr -> iColumn < 0 ? "rowid" : pExpr -> pTab -> aCol [ pExpr -> iColumn ] . zName ) , 
line 62980: target 
line 62981: ) ) ; 
line 62985: if ( pExpr -> iColumn >= 0 
line 62986: && pTab -> aCol [ pExpr -> iColumn ] . affinity == SQLITE_AFF_REAL 
line 62987: ) { 
line 62988: sqlite3VdbeAddOp1 ( v , OP_RealAffinity , target ) ; 
line 62989: } 
line 62990: break ; 
line 62991: } 
line 63015: default : assert ( op == TK_CASE ) ; { 
line 63016: int endLabel ; 
line 63017: int nextCase ; 
line 63018: int nExpr ; 
line 63019: int i ; 
line 63020: ExprList * pEList ; 
line 63021: struct ExprList_item * aListelem ; 
line 63022: Expr opCompare ; 
line 63023: Expr cacheX ; 
line 63024: Expr * pX ; 
line 63025: Expr * pTest = 0 ; 
line 63026: VVA_ONLY ( int iCacheLevel = pParse -> iCacheLevel ; ) 
line 63028: assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) && pExpr -> x . pList ) ; 
line 63029: assert ( ( pExpr -> x . pList -> nExpr % 2 ) == 0 ) ; 
line 63030: assert ( pExpr -> x . pList -> nExpr > 0 ) ; 
line 63031: pEList = pExpr -> x . pList ; 
line 63032: aListelem = pEList -> a ; 
line 63033: nExpr = pEList -> nExpr ; 
line 63034: endLabel = sqlite3VdbeMakeLabel ( v ) ; 
line 63035: if ( ( pX = pExpr -> pLeft ) != 0 ) { 
line 63036: cacheX = * pX ; 
line 63037: testcase ( pX -> op == TK_COLUMN ) ; 
line 63038: testcase ( pX -> op == TK_REGISTER ) ; 
line 63039: cacheX . iTable = sqlite3ExprCodeTemp ( pParse , pX , & regFree1 ) ; 
line 63040: testcase ( regFree1 == 0 ) ; 
line 63041: cacheX . op = TK_REGISTER ; 
line 63042: opCompare . op = TK_EQ ; 
line 63043: opCompare . pLeft = & cacheX ; 
line 63044: pTest = & opCompare ; 
line 63045: } 
line 63046: for ( i = 0 ; i < nExpr ; i = i + 2 ) { 
line 63047: sqlite3ExprCachePush ( pParse ) ; 
line 63048: if ( pX ) { 
line 63049: assert ( pTest != 0 ) ; 
line 63050: opCompare . pRight = aListelem [ i ] . pExpr ; 
line 63051: } else { 
line 63052: pTest = aListelem [ i ] . pExpr ; 
line 63053: } 
line 63054: nextCase = sqlite3VdbeMakeLabel ( v ) ; 
line 63055: testcase ( pTest -> op == TK_COLUMN ) ; 
line 63056: sqlite3ExprIfFalse ( pParse , pTest , nextCase , SQLITE_JUMPIFNULL ) ; 
line 63057: testcase ( aListelem [ i + 1 ] . pExpr -> op == TK_COLUMN ) ; 
line 63058: testcase ( aListelem [ i + 1 ] . pExpr -> op == TK_REGISTER ) ; 
line 63059: sqlite3ExprCode ( pParse , aListelem [ i + 1 ] . pExpr , target ) ; 
line 63060: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , endLabel ) ; 
line 63061: sqlite3ExprCachePop ( pParse , 1 ) ; 
line 63062: sqlite3VdbeResolveLabel ( v , nextCase ) ; 
line 63063: } 
line 63064: if ( pExpr -> pRight ) { 
line 63065: sqlite3ExprCachePush ( pParse ) ; 
line 63066: sqlite3ExprCode ( pParse , pExpr -> pRight , target ) ; 
line 63067: sqlite3ExprCachePop ( pParse , 1 ) ; 
line 63068: } else { 
line 63069: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , target ) ; 
line 63070: } 
line 63071: assert ( db -> mallocFailed || pParse -> nErr > 0 
line 63072: || pParse -> iCacheLevel == iCacheLevel ) ; 
line 63073: sqlite3VdbeResolveLabel ( v , endLabel ) ; 
line 63074: break ; 
line 63075: } 
line 63076: # ifndef SQLITE_OMIT_TRIGGER 
line 63077: case TK_RAISE : { 
line 63078: assert ( pExpr -> affinity == OE_Rollback 
line 63079: || pExpr -> affinity == OE_Abort 
line 63080: || pExpr -> affinity == OE_Fail 
line 63081: || pExpr -> affinity == OE_Ignore 
line 63082: ) ; 
line 63083: if ( ! pParse -> pTriggerTab ) { 
line 63084: sqlite3ErrorMsg ( pParse , 
line 63085: "RAISE() may only be used within a trigger-program" ) ; 
line 63086: return 0 ; 
line 63087: } 
line 63088: if ( pExpr -> affinity == OE_Abort ) { 
line 63089: sqlite3MayAbort ( pParse ) ; 
line 63090: } 
line 63091: assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; 
line 63092: if ( pExpr -> affinity == OE_Ignore ) { 
line 63093: sqlite3VdbeAddOp4 ( 
line 63094: v , OP_Halt , SQLITE_OK , OE_Ignore , 0 , pExpr -> u . zToken , 0 ) ; 
line 63095: } else { 
line 63096: sqlite3HaltConstraint ( pParse , pExpr -> affinity , pExpr -> u . zToken , 0 ) ; 
line 63097: } 
line 63099: break ; 
line 63100: } 
line 63101: # endif 
line 63102: } 
line 63103: sqlite3ReleaseTempReg ( pParse , regFree1 ) ; 
line 63104: sqlite3ReleaseTempReg ( pParse , regFree2 ) ; 
line 63105: return inReg ; 
line 63106: } 
line 63117: SQLITE_PRIVATE int sqlite3ExprCodeTemp ( Parse * pParse , Expr * pExpr , int * pReg ) { 
line 63118: int r1 = sqlite3GetTempReg ( pParse ) ; 
line 63119: int r2 = sqlite3ExprCodeTarget ( pParse , pExpr , r1 ) ; 
line 63120: if ( r2 == r1 ) { 
line 63121: * pReg = r1 ; 
line 63122: } else { 
line 63123: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 63124: * pReg = 0 ; 
line 63125: } 
line 63126: return r2 ; 
line 63127: } 
line 63134: SQLITE_PRIVATE int sqlite3ExprCode ( Parse * pParse , Expr * pExpr , int target ) { 
line 63135: int inReg ; 
line 63137: assert ( target > 0 && target <= pParse -> nMem ) ; 
line 63138: inReg = sqlite3ExprCodeTarget ( pParse , pExpr , target ) ; 
line 63139: assert ( pParse -> pVdbe || pParse -> db -> mallocFailed ) ; 
line 63140: if ( inReg != target && pParse -> pVdbe ) { 
line 63141: sqlite3VdbeAddOp2 ( pParse -> pVdbe , OP_SCopy , inReg , target ) ; 
line 63142: } 
line 63143: return target ; 
line 63144: } 
line 63158: SQLITE_PRIVATE int sqlite3ExprCodeAndCache ( Parse * pParse , Expr * pExpr , int target ) { 
line 63159: Vdbe * v = pParse -> pVdbe ; 
line 63160: int inReg ; 
line 63161: inReg = sqlite3ExprCode ( pParse , pExpr , target ) ; 
line 63162: assert ( target > 0 ) ; 
line 63169: if ( ALWAYS ( pExpr -> op != TK_REGISTER ) ) { 
line 63170: int iMem ; 
line 63171: iMem = ++ pParse -> nMem ; 
line 63172: sqlite3VdbeAddOp2 ( v , OP_Copy , inReg , iMem ) ; 
line 63173: pExpr -> iTable = iMem ; 
line 63174: pExpr -> op2 = pExpr -> op ; 
line 63175: pExpr -> op = TK_REGISTER ; 
line 63176: } 
line 63177: return inReg ; 
line 63178: } 
line 63197: static int isAppropriateForFactoring ( Expr * p ) { 
line 63198: if ( ! sqlite3ExprIsConstantNotJoin ( p ) ) { 
line 63199: return 0 ; 
line 63200: } 
line 63201: if ( ( p -> flags & EP_FixedDest ) == 0 ) { 
line 63202: return 1 ; 
line 63203: } 
line 63204: while ( p -> op == TK_UPLUS ) p = p -> pLeft ; 
line 63205: switch ( p -> op ) { 
line 63206: # ifndef SQLITE_OMIT_BLOB_LITERAL 
line 63207: case TK_BLOB : 
line 63208: # endif 
line 63209: case TK_VARIABLE : 
line 63210: case TK_INTEGER : 
line 63211: case TK_FLOAT : 
line 63212: case TK_NULL : 
line 63213: case TK_STRING : { 
line 63214: testcase ( p -> op == TK_BLOB ) ; 
line 63215: testcase ( p -> op == TK_VARIABLE ) ; 
line 63216: testcase ( p -> op == TK_INTEGER ) ; 
line 63217: testcase ( p -> op == TK_FLOAT ) ; 
line 63218: testcase ( p -> op == TK_NULL ) ; 
line 63219: testcase ( p -> op == TK_STRING ) ; 
line 63224: return 0 ; 
line 63225: } 
line 63226: case TK_UMINUS : { 
line 63227: if ( p -> pLeft -> op == TK_FLOAT || p -> pLeft -> op == TK_INTEGER ) { 
line 63228: return 0 ; 
line 63229: } 
line 63230: break ; 
line 63231: } 
line 63232: default : { 
line 63233: break ; 
line 63234: } 
line 63235: } 
line 63236: return 1 ; 
line 63237: } 
line 63245: static int evalConstExpr ( Walker * pWalker , Expr * pExpr ) { 
line 63246: Parse * pParse = pWalker -> pParse ; 
line 63247: switch ( pExpr -> op ) { 
line 63248: case TK_IN : 
line 63249: case TK_REGISTER : { 
line 63250: return WRC_Prune ; 
line 63251: } 
line 63252: case TK_FUNCTION : 
line 63253: case TK_AGG_FUNCTION : 
line 63254: case TK_CONST_FUNC : { 
line 63259: ExprList * pList = pExpr -> x . pList ; 
line 63260: assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ) ; 
line 63261: if ( pList ) { 
line 63262: int i = pList -> nExpr ; 
line 63263: struct ExprList_item * pItem = pList -> a ; 
line 63264: for ( ; i > 0 ; i -- , pItem ++ ) { 
line 63265: if ( ALWAYS ( pItem -> pExpr ) ) pItem -> pExpr -> flags |= EP_FixedDest ; 
line 63266: } 
line 63267: } 
line 63268: break ; 
line 63269: } 
line 63270: } 
line 63271: if ( isAppropriateForFactoring ( pExpr ) ) { 
line 63272: int r1 = ++ pParse -> nMem ; 
line 63273: int r2 ; 
line 63274: r2 = sqlite3ExprCodeTarget ( pParse , pExpr , r1 ) ; 
line 63275: if ( NEVER ( r1 != r2 ) ) sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 63276: pExpr -> op2 = pExpr -> op ; 
line 63277: pExpr -> op = TK_REGISTER ; 
line 63278: pExpr -> iTable = r2 ; 
line 63279: return WRC_Prune ; 
line 63280: } 
line 63281: return WRC_Continue ; 
line 63282: } 
line 63289: SQLITE_PRIVATE void sqlite3ExprCodeConstants ( Parse * pParse , Expr * pExpr ) { 
line 63290: Walker w ; 
line 63291: w . xExprCallback = evalConstExpr ; 
line 63292: w . xSelectCallback = 0 ; 
line 63293: w . pParse = pParse ; 
line 63294: sqlite3WalkExpr ( & w , pExpr ) ; 
line 63295: } 
line 63304: SQLITE_PRIVATE int sqlite3ExprCodeExprList ( 
line 63305: Parse * pParse , 
line 63306: ExprList * pList , 
line 63307: int target , 
line 63308: int doHardCopy 
line 63309: ) { 
line 63310: struct ExprList_item * pItem ; 
line 63311: int i , n ; 
line 63312: assert ( pList != 0 ) ; 
line 63313: assert ( target > 0 ) ; 
line 63314: n = pList -> nExpr ; 
line 63315: for ( pItem = pList -> a , i = 0 ; i < n ; i ++ , pItem ++ ) { 
line 63316: if ( pItem -> iAlias ) { 
line 63317: int iReg = codeAlias ( pParse , pItem -> iAlias , pItem -> pExpr , target + i ) ; 
line 63318: Vdbe * v = sqlite3GetVdbe ( pParse ) ; 
line 63319: if ( iReg != target + i ) { 
line 63320: sqlite3VdbeAddOp2 ( v , OP_SCopy , iReg , target + i ) ; 
line 63321: } 
line 63322: } else { 
line 63323: sqlite3ExprCode ( pParse , pItem -> pExpr , target + i ) ; 
line 63324: } 
line 63325: if ( doHardCopy && ! pParse -> db -> mallocFailed ) { 
line 63326: sqlite3ExprHardCopy ( pParse , target , n ) ; 
line 63327: } 
line 63328: } 
line 63329: return n ; 
line 63330: } 
line 63344: static void exprCodeBetween ( 
line 63345: Parse * pParse , 
line 63346: Expr * pExpr , 
line 63347: int dest , 
line 63348: int jumpIfTrue , 
line 63349: int jumpIfNull 
line 63350: ) { 
line 63351: Expr exprAnd ; 
line 63352: Expr compLeft ; 
line 63353: Expr compRight ; 
line 63354: Expr exprX ; 
line 63355: int regFree1 = 0 ; 
line 63357: assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ) ; 
line 63358: exprX = * pExpr -> pLeft ; 
line 63359: exprAnd . op = TK_AND ; 
line 63360: exprAnd . pLeft = & compLeft ; 
line 63361: exprAnd . pRight = & compRight ; 
line 63362: compLeft . op = TK_GE ; 
line 63363: compLeft . pLeft = & exprX ; 
line 63364: compLeft . pRight = pExpr -> x . pList -> a [ 0 ] . pExpr ; 
line 63365: compRight . op = TK_LE ; 
line 63366: compRight . pLeft = & exprX ; 
line 63367: compRight . pRight = pExpr -> x . pList -> a [ 1 ] . pExpr ; 
line 63368: exprX . iTable = sqlite3ExprCodeTemp ( pParse , & exprX , & regFree1 ) ; 
line 63369: exprX . op = TK_REGISTER ; 
line 63370: if ( jumpIfTrue ) { 
line 63371: sqlite3ExprIfTrue ( pParse , & exprAnd , dest , jumpIfNull ) ; 
line 63372: } else { 
line 63373: sqlite3ExprIfFalse ( pParse , & exprAnd , dest , jumpIfNull ) ; 
line 63374: } 
line 63375: sqlite3ReleaseTempReg ( pParse , regFree1 ) ; 
line 63378: testcase ( jumpIfTrue == 0 && jumpIfNull == 0 && regFree1 == 0 ) ; 
line 63379: testcase ( jumpIfTrue == 0 && jumpIfNull == 0 && regFree1 != 0 ) ; 
line 63380: testcase ( jumpIfTrue == 0 && jumpIfNull != 0 && regFree1 == 0 ) ; 
line 63381: testcase ( jumpIfTrue == 0 && jumpIfNull != 0 && regFree1 != 0 ) ; 
line 63382: testcase ( jumpIfTrue != 0 && jumpIfNull == 0 && regFree1 == 0 ) ; 
line 63383: testcase ( jumpIfTrue != 0 && jumpIfNull == 0 && regFree1 != 0 ) ; 
line 63384: testcase ( jumpIfTrue != 0 && jumpIfNull != 0 && regFree1 == 0 ) ; 
line 63385: testcase ( jumpIfTrue != 0 && jumpIfNull != 0 && regFree1 != 0 ) ; 
line 63386: } 
line 63402: SQLITE_PRIVATE void sqlite3ExprIfTrue ( Parse * pParse , Expr * pExpr , int dest , int jumpIfNull ) { 
line 63403: Vdbe * v = pParse -> pVdbe ; 
line 63404: int op = 0 ; 
line 63405: int regFree1 = 0 ; 
line 63406: int regFree2 = 0 ; 
line 63407: int r1 , r2 ; 
line 63409: assert ( jumpIfNull == SQLITE_JUMPIFNULL || jumpIfNull == 0 ) ; 
line 63410: if ( NEVER ( v == 0 ) ) return ; 
line 63411: if ( NEVER ( pExpr == 0 ) ) return ; 
line 63412: op = pExpr -> op ; 
line 63413: switch ( op ) { 
line 63414: case TK_AND : { 
line 63415: int d2 = sqlite3VdbeMakeLabel ( v ) ; 
line 63416: testcase ( jumpIfNull == 0 ) ; 
line 63417: sqlite3ExprCachePush ( pParse ) ; 
line 63418: sqlite3ExprIfFalse ( pParse , pExpr -> pLeft , d2 , jumpIfNull ^ SQLITE_JUMPIFNULL ) ; 
line 63419: sqlite3ExprIfTrue ( pParse , pExpr -> pRight , dest , jumpIfNull ) ; 
line 63420: sqlite3VdbeResolveLabel ( v , d2 ) ; 
line 63421: sqlite3ExprCachePop ( pParse , 1 ) ; 
line 63422: break ; 
line 63423: } 
line 63424: case TK_OR : { 
line 63425: testcase ( jumpIfNull == 0 ) ; 
line 63426: sqlite3ExprIfTrue ( pParse , pExpr -> pLeft , dest , jumpIfNull ) ; 
line 63427: sqlite3ExprIfTrue ( pParse , pExpr -> pRight , dest , jumpIfNull ) ; 
line 63428: break ; 
line 63429: } 
line 63430: case TK_NOT : { 
line 63431: testcase ( jumpIfNull == 0 ) ; 
line 63432: sqlite3ExprIfFalse ( pParse , pExpr -> pLeft , dest , jumpIfNull ) ; 
line 63433: break ; 
line 63434: } 
line 63435: case TK_LT : 
line 63436: case TK_LE : 
line 63437: case TK_GT : 
line 63438: case TK_GE : 
line 63439: case TK_NE : 
line 63440: case TK_EQ : { 
line 63441: assert ( TK_LT == OP_Lt ) ; 
line 63442: assert ( TK_LE == OP_Le ) ; 
line 63443: assert ( TK_GT == OP_Gt ) ; 
line 63444: assert ( TK_GE == OP_Ge ) ; 
line 63445: assert ( TK_EQ == OP_Eq ) ; 
line 63446: assert ( TK_NE == OP_Ne ) ; 
line 63447: testcase ( op == TK_LT ) ; 
line 63448: testcase ( op == TK_LE ) ; 
line 63449: testcase ( op == TK_GT ) ; 
line 63450: testcase ( op == TK_GE ) ; 
line 63451: testcase ( op == TK_EQ ) ; 
line 63452: testcase ( op == TK_NE ) ; 
line 63453: testcase ( jumpIfNull == 0 ) ; 
line 63454: r1 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree1 ) ; 
line 63455: r2 = sqlite3ExprCodeTemp ( pParse , pExpr -> pRight , & regFree2 ) ; 
line 63456: codeCompare ( pParse , pExpr -> pLeft , pExpr -> pRight , op , 
line 63457: r1 , r2 , dest , jumpIfNull ) ; 
line 63458: testcase ( regFree1 == 0 ) ; 
line 63459: testcase ( regFree2 == 0 ) ; 
line 63460: break ; 
line 63461: } 
line 63462: case TK_IS : 
line 63463: case TK_ISNOT : { 
line 63464: testcase ( op == TK_IS ) ; 
line 63465: testcase ( op == TK_ISNOT ) ; 
line 63466: r1 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree1 ) ; 
line 63467: r2 = sqlite3ExprCodeTemp ( pParse , pExpr -> pRight , & regFree2 ) ; 
line 63468: op = ( op == TK_IS ) ? TK_EQ : TK_NE ; 
line 63469: codeCompare ( pParse , pExpr -> pLeft , pExpr -> pRight , op , 
line 63470: r1 , r2 , dest , SQLITE_NULLEQ ) ; 
line 63471: testcase ( regFree1 == 0 ) ; 
line 63472: testcase ( regFree2 == 0 ) ; 
line 63473: break ; 
line 63474: } 
line 63475: case TK_ISNULL : 
line 63476: case TK_NOTNULL : { 
line 63477: assert ( TK_ISNULL == OP_IsNull ) ; 
line 63478: assert ( TK_NOTNULL == OP_NotNull ) ; 
line 63479: testcase ( op == TK_ISNULL ) ; 
line 63480: testcase ( op == TK_NOTNULL ) ; 
line 63481: r1 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree1 ) ; 
line 63482: sqlite3VdbeAddOp2 ( v , op , r1 , dest ) ; 
line 63483: testcase ( regFree1 == 0 ) ; 
line 63484: break ; 
line 63485: } 
line 63486: case TK_BETWEEN : { 
line 63487: testcase ( jumpIfNull == 0 ) ; 
line 63488: exprCodeBetween ( pParse , pExpr , dest , 1 , jumpIfNull ) ; 
line 63489: break ; 
line 63490: } 
line 63491: case TK_IN : { 
line 63492: int destIfFalse = sqlite3VdbeMakeLabel ( v ) ; 
line 63493: int destIfNull = jumpIfNull ? dest : destIfFalse ; 
line 63494: sqlite3ExprCodeIN ( pParse , pExpr , destIfFalse , destIfNull ) ; 
line 63495: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , dest ) ; 
line 63496: sqlite3VdbeResolveLabel ( v , destIfFalse ) ; 
line 63497: break ; 
line 63498: } 
line 63499: default : { 
line 63500: r1 = sqlite3ExprCodeTemp ( pParse , pExpr , & regFree1 ) ; 
line 63501: sqlite3VdbeAddOp3 ( v , OP_If , r1 , dest , jumpIfNull != 0 ) ; 
line 63502: testcase ( regFree1 == 0 ) ; 
line 63503: testcase ( jumpIfNull == 0 ) ; 
line 63504: break ; 
line 63505: } 
line 63506: } 
line 63507: sqlite3ReleaseTempReg ( pParse , regFree1 ) ; 
line 63508: sqlite3ReleaseTempReg ( pParse , regFree2 ) ; 
line 63509: } 
line 63520: SQLITE_PRIVATE void sqlite3ExprIfFalse ( Parse * pParse , Expr * pExpr , int dest , int jumpIfNull ) { 
line 63521: Vdbe * v = pParse -> pVdbe ; 
line 63522: int op = 0 ; 
line 63523: int regFree1 = 0 ; 
line 63524: int regFree2 = 0 ; 
line 63525: int r1 , r2 ; 
line 63527: assert ( jumpIfNull == SQLITE_JUMPIFNULL || jumpIfNull == 0 ) ; 
line 63528: if ( NEVER ( v == 0 ) ) return ; 
line 63529: if ( pExpr == 0 ) return ; 
line 63549: op = ( ( pExpr -> op + ( TK_ISNULL & 1 ) ) ^ 1 ) - ( TK_ISNULL & 1 ) ; 
line 63553: assert ( pExpr -> op != TK_ISNULL || op == OP_NotNull ) ; 
line 63554: assert ( pExpr -> op != TK_NOTNULL || op == OP_IsNull ) ; 
line 63555: assert ( pExpr -> op != TK_NE || op == OP_Eq ) ; 
line 63556: assert ( pExpr -> op != TK_EQ || op == OP_Ne ) ; 
line 63557: assert ( pExpr -> op != TK_LT || op == OP_Ge ) ; 
line 63558: assert ( pExpr -> op != TK_LE || op == OP_Gt ) ; 
line 63559: assert ( pExpr -> op != TK_GT || op == OP_Le ) ; 
line 63560: assert ( pExpr -> op != TK_GE || op == OP_Lt ) ; 
line 63562: switch ( pExpr -> op ) { 
line 63563: case TK_AND : { 
line 63564: testcase ( jumpIfNull == 0 ) ; 
line 63565: sqlite3ExprIfFalse ( pParse , pExpr -> pLeft , dest , jumpIfNull ) ; 
line 63566: sqlite3ExprIfFalse ( pParse , pExpr -> pRight , dest , jumpIfNull ) ; 
line 63567: break ; 
line 63568: } 
line 63569: case TK_OR : { 
line 63570: int d2 = sqlite3VdbeMakeLabel ( v ) ; 
line 63571: testcase ( jumpIfNull == 0 ) ; 
line 63572: sqlite3ExprCachePush ( pParse ) ; 
line 63573: sqlite3ExprIfTrue ( pParse , pExpr -> pLeft , d2 , jumpIfNull ^ SQLITE_JUMPIFNULL ) ; 
line 63574: sqlite3ExprIfFalse ( pParse , pExpr -> pRight , dest , jumpIfNull ) ; 
line 63575: sqlite3VdbeResolveLabel ( v , d2 ) ; 
line 63576: sqlite3ExprCachePop ( pParse , 1 ) ; 
line 63577: break ; 
line 63578: } 
line 63579: case TK_NOT : { 
line 63580: testcase ( jumpIfNull == 0 ) ; 
line 63581: sqlite3ExprIfTrue ( pParse , pExpr -> pLeft , dest , jumpIfNull ) ; 
line 63582: break ; 
line 63583: } 
line 63584: case TK_LT : 
line 63585: case TK_LE : 
line 63586: case TK_GT : 
line 63587: case TK_GE : 
line 63588: case TK_NE : 
line 63589: case TK_EQ : { 
line 63590: testcase ( op == TK_LT ) ; 
line 63591: testcase ( op == TK_LE ) ; 
line 63592: testcase ( op == TK_GT ) ; 
line 63593: testcase ( op == TK_GE ) ; 
line 63594: testcase ( op == TK_EQ ) ; 
line 63595: testcase ( op == TK_NE ) ; 
line 63596: testcase ( jumpIfNull == 0 ) ; 
line 63597: r1 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree1 ) ; 
line 63598: r2 = sqlite3ExprCodeTemp ( pParse , pExpr -> pRight , & regFree2 ) ; 
line 63599: codeCompare ( pParse , pExpr -> pLeft , pExpr -> pRight , op , 
line 63600: r1 , r2 , dest , jumpIfNull ) ; 
line 63601: testcase ( regFree1 == 0 ) ; 
line 63602: testcase ( regFree2 == 0 ) ; 
line 63603: break ; 
line 63604: } 
line 63605: case TK_IS : 
line 63606: case TK_ISNOT : { 
line 63607: testcase ( pExpr -> op == TK_IS ) ; 
line 63608: testcase ( pExpr -> op == TK_ISNOT ) ; 
line 63609: r1 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree1 ) ; 
line 63610: r2 = sqlite3ExprCodeTemp ( pParse , pExpr -> pRight , & regFree2 ) ; 
line 63611: op = ( pExpr -> op == TK_IS ) ? TK_NE : TK_EQ ; 
line 63612: codeCompare ( pParse , pExpr -> pLeft , pExpr -> pRight , op , 
line 63613: r1 , r2 , dest , SQLITE_NULLEQ ) ; 
line 63614: testcase ( regFree1 == 0 ) ; 
line 63615: testcase ( regFree2 == 0 ) ; 
line 63616: break ; 
line 63617: } 
line 63618: case TK_ISNULL : 
line 63619: case TK_NOTNULL : { 
line 63620: testcase ( op == TK_ISNULL ) ; 
line 63621: testcase ( op == TK_NOTNULL ) ; 
line 63622: r1 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree1 ) ; 
line 63623: sqlite3VdbeAddOp2 ( v , op , r1 , dest ) ; 
line 63624: testcase ( regFree1 == 0 ) ; 
line 63625: break ; 
line 63626: } 
line 63627: case TK_BETWEEN : { 
line 63628: testcase ( jumpIfNull == 0 ) ; 
line 63629: exprCodeBetween ( pParse , pExpr , dest , 0 , jumpIfNull ) ; 
line 63630: break ; 
line 63631: } 
line 63632: case TK_IN : { 
line 63633: if ( jumpIfNull ) { 
line 63634: sqlite3ExprCodeIN ( pParse , pExpr , dest , dest ) ; 
line 63635: } else { 
line 63636: int destIfNull = sqlite3VdbeMakeLabel ( v ) ; 
line 63637: sqlite3ExprCodeIN ( pParse , pExpr , dest , destIfNull ) ; 
line 63638: sqlite3VdbeResolveLabel ( v , destIfNull ) ; 
line 63639: } 
line 63640: break ; 
line 63641: } 
line 63642: default : { 
line 63643: r1 = sqlite3ExprCodeTemp ( pParse , pExpr , & regFree1 ) ; 
line 63644: sqlite3VdbeAddOp3 ( v , OP_IfNot , r1 , dest , jumpIfNull != 0 ) ; 
line 63645: testcase ( regFree1 == 0 ) ; 
line 63646: testcase ( jumpIfNull == 0 ) ; 
line 63647: break ; 
line 63648: } 
line 63649: } 
line 63650: sqlite3ReleaseTempReg ( pParse , regFree1 ) ; 
line 63651: sqlite3ReleaseTempReg ( pParse , regFree2 ) ; 
line 63652: } 
line 63668: SQLITE_PRIVATE int sqlite3ExprCompare ( Expr * pA , Expr * pB ) { 
line 63669: int i ; 
line 63670: if ( pA == 0 || pB == 0 ) { 
line 63671: return pB == pA ; 
line 63672: } 
line 63673: assert ( ! ExprHasAnyProperty ( pA , EP_TokenOnly | EP_Reduced ) ) ; 
line 63674: assert ( ! ExprHasAnyProperty ( pB , EP_TokenOnly | EP_Reduced ) ) ; 
line 63675: if ( ExprHasProperty ( pA , EP_xIsSelect ) || ExprHasProperty ( pB , EP_xIsSelect ) ) { 
line 63676: return 0 ; 
line 63677: } 
line 63678: if ( ( pA -> flags & EP_Distinct ) != ( pB -> flags & EP_Distinct ) ) return 0 ; 
line 63679: if ( pA -> op != pB -> op ) return 0 ; 
line 63680: if ( ! sqlite3ExprCompare ( pA -> pLeft , pB -> pLeft ) ) return 0 ; 
line 63681: if ( ! sqlite3ExprCompare ( pA -> pRight , pB -> pRight ) ) return 0 ; 
line 63683: if ( pA -> x . pList && pB -> x . pList ) { 
line 63684: if ( pA -> x . pList -> nExpr != pB -> x . pList -> nExpr ) return 0 ; 
line 63685: for ( i = 0 ; i < pA -> x . pList -> nExpr ; i ++ ) { 
line 63686: Expr * pExprA = pA -> x . pList -> a [ i ] . pExpr ; 
line 63687: Expr * pExprB = pB -> x . pList -> a [ i ] . pExpr ; 
line 63688: if ( ! sqlite3ExprCompare ( pExprA , pExprB ) ) return 0 ; 
line 63689: } 
line 63690: } else if ( pA -> x . pList || pB -> x . pList ) { 
line 63691: return 0 ; 
line 63692: } 
line 63694: if ( pA -> iTable != pB -> iTable || pA -> iColumn != pB -> iColumn ) return 0 ; 
line 63695: if ( ExprHasProperty ( pA , EP_IntValue ) ) { 
line 63696: if ( ! ExprHasProperty ( pB , EP_IntValue ) || pA -> u . iValue != pB -> u . iValue ) { 
line 63697: return 0 ; 
line 63698: } 
line 63699: } else if ( pA -> op != TK_COLUMN && pA -> u . zToken ) { 
line 63700: if ( ExprHasProperty ( pB , EP_IntValue ) || NEVER ( pB -> u . zToken == 0 ) ) return 0 ; 
line 63701: if ( sqlite3StrICmp ( pA -> u . zToken , pB -> u . zToken ) != 0 ) { 
line 63702: return 0 ; 
line 63703: } 
line 63704: } 
line 63705: return 1 ; 
line 63706: } 
line 63713: static int addAggInfoColumn ( sqlite3 * db , AggInfo * pInfo ) { 
line 63714: int i ; 
line 63715: pInfo -> aCol = sqlite3ArrayAllocate ( 
line 63716: db , 
line 63717: pInfo -> aCol , 
line 63718: sizeof ( pInfo -> aCol [ 0 ] ) , 
line 63719: 3 , 
line 63720: & pInfo -> nColumn , 
line 63721: & pInfo -> nColumnAlloc , 
line 63722: & i 
line 63723: ) ; 
line 63724: return i ; 
line 63725: } 
line 63731: static int addAggInfoFunc ( sqlite3 * db , AggInfo * pInfo ) { 
line 63732: int i ; 
line 63733: pInfo -> aFunc = sqlite3ArrayAllocate ( 
line 63734: db , 
line 63735: pInfo -> aFunc , 
line 63736: sizeof ( pInfo -> aFunc [ 0 ] ) , 
line 63737: 3 , 
line 63738: & pInfo -> nFunc , 
line 63739: & pInfo -> nFuncAlloc , 
line 63740: & i 
line 63741: ) ; 
line 63742: return i ; 
line 63743: } 
line 63750: static int analyzeAggregate ( Walker * pWalker , Expr * pExpr ) { 
line 63751: int i ; 
line 63752: NameContext * pNC = pWalker -> u . pNC ; 
line 63753: Parse * pParse = pNC -> pParse ; 
line 63754: SrcList * pSrcList = pNC -> pSrcList ; 
line 63755: AggInfo * pAggInfo = pNC -> pAggInfo ; 
line 63757: switch ( pExpr -> op ) { 
line 63758: case TK_AGG_COLUMN : 
line 63759: case TK_COLUMN : { 
line 63760: testcase ( pExpr -> op == TK_AGG_COLUMN ) ; 
line 63761: testcase ( pExpr -> op == TK_COLUMN ) ; 
line 63764: if ( ALWAYS ( pSrcList != 0 ) ) { 
line 63765: struct SrcList_item * pItem = pSrcList -> a ; 
line 63766: for ( i = 0 ; i < pSrcList -> nSrc ; i ++ , pItem ++ ) { 
line 63767: struct AggInfo_col * pCol ; 
line 63768: assert ( ! ExprHasAnyProperty ( pExpr , EP_TokenOnly | EP_Reduced ) ) ; 
line 63769: if ( pExpr -> iTable == pItem -> iCursor ) { 
line 63776: int k ; 
line 63777: pCol = pAggInfo -> aCol ; 
line 63778: for ( k = 0 ; k < pAggInfo -> nColumn ; k ++ , pCol ++ ) { 
line 63779: if ( pCol -> iTable == pExpr -> iTable && 
line 63780: pCol -> iColumn == pExpr -> iColumn ) { 
line 63781: break ; 
line 63782: } 
line 63783: } 
line 63784: if ( ( k >= pAggInfo -> nColumn ) 
line 63785: && ( k = addAggInfoColumn ( pParse -> db , pAggInfo ) ) >= 0 
line 63786: ) { 
line 63787: pCol = & pAggInfo -> aCol [ k ] ; 
line 63788: pCol -> pTab = pExpr -> pTab ; 
line 63789: pCol -> iTable = pExpr -> iTable ; 
line 63790: pCol -> iColumn = pExpr -> iColumn ; 
line 63791: pCol -> iMem = ++ pParse -> nMem ; 
line 63792: pCol -> iSorterColumn = - 1 ; 
line 63793: pCol -> pExpr = pExpr ; 
line 63794: if ( pAggInfo -> pGroupBy ) { 
line 63795: int j , n ; 
line 63796: ExprList * pGB = pAggInfo -> pGroupBy ; 
line 63797: struct ExprList_item * pTerm = pGB -> a ; 
line 63798: n = pGB -> nExpr ; 
line 63799: for ( j = 0 ; j < n ; j ++ , pTerm ++ ) { 
line 63800: Expr * pE = pTerm -> pExpr ; 
line 63801: if ( pE -> op == TK_COLUMN && pE -> iTable == pExpr -> iTable && 
line 63802: pE -> iColumn == pExpr -> iColumn ) { 
line 63803: pCol -> iSorterColumn = j ; 
line 63804: break ; 
line 63805: } 
line 63806: } 
line 63807: } 
line 63808: if ( pCol -> iSorterColumn < 0 ) { 
line 63809: pCol -> iSorterColumn = pAggInfo -> nSortingColumn ++ ; 
line 63810: } 
line 63811: } 
line 63817: ExprSetIrreducible ( pExpr ) ; 
line 63818: pExpr -> pAggInfo = pAggInfo ; 
line 63819: pExpr -> op = TK_AGG_COLUMN ; 
line 63820: pExpr -> iAgg = ( i16 ) k ; 
line 63821: break ; 
line 63822: } 
line 63823: } 
line 63824: } 
line 63825: return WRC_Prune ; 
line 63826: } 
line 63827: case TK_AGG_FUNCTION : { 
line 63830: if ( pNC -> nDepth == 0 ) { 
line 63834: struct AggInfo_func * pItem = pAggInfo -> aFunc ; 
line 63835: for ( i = 0 ; i < pAggInfo -> nFunc ; i ++ , pItem ++ ) { 
line 63836: if ( sqlite3ExprCompare ( pItem -> pExpr , pExpr ) ) { 
line 63837: break ; 
line 63838: } 
line 63839: } 
line 63840: if ( i >= pAggInfo -> nFunc ) { 
line 63843: u8 enc = ENC ( pParse -> db ) ; 
line 63844: i = addAggInfoFunc ( pParse -> db , pAggInfo ) ; 
line 63845: if ( i >= 0 ) { 
line 63846: assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ) ; 
line 63847: pItem = & pAggInfo -> aFunc [ i ] ; 
line 63848: pItem -> pExpr = pExpr ; 
line 63849: pItem -> iMem = ++ pParse -> nMem ; 
line 63850: assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; 
line 63851: pItem -> pFunc = sqlite3FindFunction ( pParse -> db , 
line 63852: pExpr -> u . zToken , sqlite3Strlen30 ( pExpr -> u . zToken ) , 
line 63853: pExpr -> x . pList ? pExpr -> x . pList -> nExpr : 0 , enc , 0 ) ; 
line 63854: if ( pExpr -> flags & EP_Distinct ) { 
line 63855: pItem -> iDistinct = pParse -> nTab ++ ; 
line 63856: } else { 
line 63857: pItem -> iDistinct = - 1 ; 
line 63858: } 
line 63859: } 
line 63860: } 
line 63863: assert ( ! ExprHasAnyProperty ( pExpr , EP_TokenOnly | EP_Reduced ) ) ; 
line 63864: ExprSetIrreducible ( pExpr ) ; 
line 63865: pExpr -> iAgg = ( i16 ) i ; 
line 63866: pExpr -> pAggInfo = pAggInfo ; 
line 63867: return WRC_Prune ; 
line 63868: } 
line 63869: } 
line 63870: } 
line 63871: return WRC_Continue ; 
line 63872: } 
line 63873: static int analyzeAggregatesInSelect ( Walker * pWalker , Select * pSelect ) { 
line 63874: NameContext * pNC = pWalker -> u . pNC ; 
line 63875: if ( pNC -> nDepth == 0 ) { 
line 63876: pNC -> nDepth ++ ; 
line 63877: sqlite3WalkSelect ( pWalker , pSelect ) ; 
line 63878: pNC -> nDepth -- ; 
line 63879: return WRC_Prune ; 
line 63880: } else { 
line 63881: return WRC_Continue ; 
line 63882: } 
line 63883: } 
line 63893: SQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates ( NameContext * pNC , Expr * pExpr ) { 
line 63894: Walker w ; 
line 63895: w . xExprCallback = analyzeAggregate ; 
line 63896: w . xSelectCallback = analyzeAggregatesInSelect ; 
line 63897: w . u . pNC = pNC ; 
line 63898: assert ( pNC -> pSrcList != 0 ) ; 
line 63899: sqlite3WalkExpr ( & w , pExpr ) ; 
line 63900: } 
line 63908: SQLITE_PRIVATE void sqlite3ExprAnalyzeAggList ( NameContext * pNC , ExprList * pList ) { 
line 63909: struct ExprList_item * pItem ; 
line 63910: int i ; 
line 63911: if ( pList ) { 
line 63912: for ( pItem = pList -> a , i = 0 ; i < pList -> nExpr ; i ++ , pItem ++ ) { 
line 63913: sqlite3ExprAnalyzeAggregates ( pNC , pItem -> pExpr ) ; 
line 63914: } 
line 63915: } 
line 63916: } 
line 63921: SQLITE_PRIVATE int sqlite3GetTempReg ( Parse * pParse ) { 
line 63922: if ( pParse -> nTempReg == 0 ) { 
line 63923: return ++ pParse -> nMem ; 
line 63924: } 
line 63925: return pParse -> aTempReg [ -- pParse -> nTempReg ] ; 
line 63926: } 
line 63936: SQLITE_PRIVATE void sqlite3ReleaseTempReg ( Parse * pParse , int iReg ) { 
line 63937: if ( iReg && pParse -> nTempReg < ArraySize ( pParse -> aTempReg ) ) { 
line 63938: int i ; 
line 63939: struct yColCache * p ; 
line 63940: for ( i = 0 , p = pParse -> aColCache ; i < SQLITE_N_COLCACHE ; i ++ , p ++ ) { 
line 63941: if ( p -> iReg == iReg ) { 
line 63942: p -> tempReg = 1 ; 
line 63943: return ; 
line 63944: } 
line 63945: } 
line 63946: pParse -> aTempReg [ pParse -> nTempReg ++ ] = iReg ; 
line 63947: } 
line 63948: } 
line 63953: SQLITE_PRIVATE int sqlite3GetTempRange ( Parse * pParse , int nReg ) { 
line 63954: int i , n ; 
line 63955: i = pParse -> iRangeReg ; 
line 63956: n = pParse -> nRangeReg ; 
line 63957: if ( nReg <= n ) { 
line 63958: assert ( ! usedAsColumnCache ( pParse , i , i + n - 1 ) ) ; 
line 63959: pParse -> iRangeReg += nReg ; 
line 63960: pParse -> nRangeReg -= nReg ; 
line 63961: } else { 
line 63962: i = pParse -> nMem + 1 ; 
line 63963: pParse -> nMem += nReg ; 
line 63964: } 
line 63965: return i ; 
line 63966: } 
line 63967: SQLITE_PRIVATE void sqlite3ReleaseTempRange ( Parse * pParse , int iReg , int nReg ) { 
line 63968: sqlite3ExprCacheRemove ( pParse , iReg , nReg ) ; 
line 63969: if ( nReg > pParse -> nRangeReg ) { 
line 63970: pParse -> nRangeReg = nReg ; 
line 63971: pParse -> iRangeReg = iReg ; 
line 63972: } 
line 63973: } 
line 63996: # ifndef SQLITE_OMIT_ALTERTABLE 
line 64012: static void renameTableFunc ( 
line 64013: sqlite3_context * context , 
line 64014: int NotUsed , 
line 64015: sqlite3_value * * argv 
line 64016: ) { 
line 64017: unsigned char const * zSql = sqlite3_value_text ( argv [ 0 ] ) ; 
line 64018: unsigned char const * zTableName = sqlite3_value_text ( argv [ 1 ] ) ; 
line 64020: int token ; 
line 64021: Token tname ; 
line 64022: unsigned char const * zCsr = zSql ; 
line 64023: int len = 0 ; 
line 64024: char * zRet ; 
line 64026: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 64028: UNUSED_PARAMETER ( NotUsed ) ; 
line 64034: if ( zSql ) { 
line 64035: do { 
line 64036: if ( ! * zCsr ) { 
line 64038: return ; 
line 64039: } 
line 64042: tname . z = ( char * ) zCsr ; 
line 64043: tname . n = len ; 
line 64048: do { 
line 64049: zCsr += len ; 
line 64050: len = sqlite3GetToken ( zCsr , & token ) ; 
line 64051: } while ( token == TK_SPACE ) ; 
line 64052: assert ( len > 0 ) ; 
line 64053: } while ( token != TK_LP && token != TK_USING ) ; 
line 64055: zRet = sqlite3MPrintf ( db , "%.*s\"%w\"%s" , ( ( u8 * ) tname . z ) - zSql , zSql , 
line 64056: zTableName , tname . z + tname . n ) ; 
line 64057: sqlite3_result_text ( context , zRet , - 1 , SQLITE_DYNAMIC ) ; 
line 64058: } 
line 64059: } 
line 64076: # ifndef SQLITE_OMIT_FOREIGN_KEY 
line 64077: static void renameParentFunc ( 
line 64078: sqlite3_context * context , 
line 64079: int NotUsed , 
line 64080: sqlite3_value * * argv 
line 64081: ) { 
line 64082: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 64083: char * zOutput = 0 ; 
line 64084: char * zResult ; 
line 64085: unsigned char const * zInput = sqlite3_value_text ( argv [ 0 ] ) ; 
line 64086: unsigned char const * zOld = sqlite3_value_text ( argv [ 1 ] ) ; 
line 64087: unsigned char const * zNew = sqlite3_value_text ( argv [ 2 ] ) ; 
line 64089: unsigned const char * z ; 
line 64090: int n ; 
line 64091: int token ; 
line 64093: UNUSED_PARAMETER ( NotUsed ) ; 
line 64094: for ( z = zInput ; * z ; z = z + n ) { 
line 64095: n = sqlite3GetToken ( z , & token ) ; 
line 64096: if ( token == TK_REFERENCES ) { 
line 64097: char * zParent ; 
line 64098: do { 
line 64099: z += n ; 
line 64100: n = sqlite3GetToken ( z , & token ) ; 
line 64101: } while ( token == TK_SPACE ) ; 
line 64103: zParent = sqlite3DbStrNDup ( db , ( const char * ) z , n ) ; 
line 64104: if ( zParent == 0 ) break ; 
line 64105: sqlite3Dequote ( zParent ) ; 
line 64106: if ( 0 == sqlite3StrICmp ( ( const char * ) zOld , zParent ) ) { 
line 64107: char * zOut = sqlite3MPrintf ( db , "%s%.*s\"%w\"" , 
line 64108: ( zOutput ? zOutput : "" ) , z - zInput , zInput , ( const char * ) zNew 
line 64109: ) ; 
line 64110: sqlite3DbFree ( db , zOutput ) ; 
line 64111: zOutput = zOut ; 
line 64112: zInput = & z [ n ] ; 
line 64113: } 
line 64114: sqlite3DbFree ( db , zParent ) ; 
line 64115: } 
line 64116: } 
line 64118: zResult = sqlite3MPrintf ( db , "%s%s" , ( zOutput ? zOutput : "" ) , zInput ) , 
line 64119: sqlite3_result_text ( context , zResult , - 1 , SQLITE_DYNAMIC ) ; 
line 64120: sqlite3DbFree ( db , zOutput ) ; 
line 64121: } 
line 64122: # endif 
line 64124: # ifndef SQLITE_OMIT_TRIGGER 
line 64132: static void renameTriggerFunc ( 
line 64133: sqlite3_context * context , 
line 64134: int NotUsed , 
line 64135: sqlite3_value * * argv 
line 64136: ) { 
line 64137: unsigned char const * zSql = sqlite3_value_text ( argv [ 0 ] ) ; 
line 64138: unsigned char const * zTableName = sqlite3_value_text ( argv [ 1 ] ) ; 
line 64140: int token ; 
line 64141: Token tname ; 
line 64142: int dist = 3 ; 
line 64143: unsigned char const * zCsr = zSql ; 
line 64144: int len = 0 ; 
line 64145: char * zRet ; 
line 64146: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 64148: UNUSED_PARAMETER ( NotUsed ) ; 
line 64155: if ( zSql ) { 
line 64156: do { 
line 64158: if ( ! * zCsr ) { 
line 64160: return ; 
line 64161: } 
line 64164: tname . z = ( char * ) zCsr ; 
line 64165: tname . n = len ; 
line 64170: do { 
line 64171: zCsr += len ; 
line 64172: len = sqlite3GetToken ( zCsr , & token ) ; 
line 64173: } while ( token == TK_SPACE ) ; 
line 64174: assert ( len > 0 ) ; 
line 64185: dist ++ ; 
line 64186: if ( token == TK_DOT || token == TK_ON ) { 
line 64187: dist = 0 ; 
line 64188: } 
line 64189: } while ( dist != 2 || ( token != TK_WHEN && token != TK_FOR && token != TK_BEGIN ) ) ; 
line 64194: zRet = sqlite3MPrintf ( db , "%.*s\"%w\"%s" , ( ( u8 * ) tname . z ) - zSql , zSql , 
line 64195: zTableName , tname . z + tname . n ) ; 
line 64196: sqlite3_result_text ( context , zRet , - 1 , SQLITE_DYNAMIC ) ; 
line 64197: } 
line 64198: } 
line 64199: # endif 
line 64204: SQLITE_PRIVATE void sqlite3AlterFunctions ( sqlite3 * db ) { 
line 64205: sqlite3CreateFunc ( db , "sqlite_rename_table" , 2 , SQLITE_UTF8 , 0 , 
line 64206: renameTableFunc , 0 , 0 ) ; 
line 64207: # ifndef SQLITE_OMIT_TRIGGER 
line 64208: sqlite3CreateFunc ( db , "sqlite_rename_trigger" , 2 , SQLITE_UTF8 , 0 , 
line 64209: renameTriggerFunc , 0 , 0 ) ; 
line 64210: # endif 
line 64211: # ifndef SQLITE_OMIT_FOREIGN_KEY 
line 64212: sqlite3CreateFunc ( db , "sqlite_rename_parent" , 3 , SQLITE_UTF8 , 0 , 
line 64213: renameParentFunc , 0 , 0 ) ; 
line 64214: # endif 
line 64215: } 
line 64233: static char * whereOrName ( sqlite3 * db , char * zWhere , char * zConstant ) { 
line 64234: char * zNew ; 
line 64235: if ( ! zWhere ) { 
line 64236: zNew = sqlite3MPrintf ( db , "name=%Q" , zConstant ) ; 
line 64237: } else { 
line 64238: zNew = sqlite3MPrintf ( db , "%s OR name=%Q" , zWhere , zConstant ) ; 
line 64239: sqlite3DbFree ( db , zWhere ) ; 
line 64240: } 
line 64241: return zNew ; 
line 64242: } 
line 64244: # if ! defined ( SQLITE_OMIT_FOREIGN_KEY ) && ! defined ( SQLITE_OMIT_TRIGGER ) 
line 64251: static char * whereForeignKeys ( Parse * pParse , Table * pTab ) { 
line 64252: FKey * p ; 
line 64253: char * zWhere = 0 ; 
line 64254: for ( p = sqlite3FkReferences ( pTab ) ; p ; p = p -> pNextTo ) { 
line 64255: zWhere = whereOrName ( pParse -> db , zWhere , p -> pFrom -> zName ) ; 
line 64256: } 
line 64257: return zWhere ; 
line 64258: } 
line 64259: # endif 
line 64267: static char * whereTempTriggers ( Parse * pParse , Table * pTab ) { 
line 64268: Trigger * pTrig ; 
line 64269: char * zWhere = 0 ; 
line 64270: const Schema * pTempSchema = pParse -> db -> aDb [ 1 ] . pSchema ; 
line 64277: if ( pTab -> pSchema != pTempSchema ) { 
line 64278: sqlite3 * db = pParse -> db ; 
line 64279: for ( pTrig = sqlite3TriggerList ( pParse , pTab ) ; pTrig ; pTrig = pTrig -> pNext ) { 
line 64280: if ( pTrig -> pSchema == pTempSchema ) { 
line 64281: zWhere = whereOrName ( db , zWhere , pTrig -> zName ) ; 
line 64282: } 
line 64283: } 
line 64284: } 
line 64285: return zWhere ; 
line 64286: } 
line 64296: static void reloadTableSchema ( Parse * pParse , Table * pTab , const char * zName ) { 
line 64297: Vdbe * v ; 
line 64298: char * zWhere ; 
line 64299: int iDb ; 
line 64300: # ifndef SQLITE_OMIT_TRIGGER 
line 64301: Trigger * pTrig ; 
line 64302: # endif 
line 64304: v = sqlite3GetVdbe ( pParse ) ; 
line 64305: if ( NEVER ( v == 0 ) ) return ; 
line 64306: assert ( sqlite3BtreeHoldsAllMutexes ( pParse -> db ) ) ; 
line 64307: iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; 
line 64308: assert ( iDb >= 0 ) ; 
line 64310: # ifndef SQLITE_OMIT_TRIGGER 
line 64312: for ( pTrig = sqlite3TriggerList ( pParse , pTab ) ; pTrig ; pTrig = pTrig -> pNext ) { 
line 64313: int iTrigDb = sqlite3SchemaToIndex ( pParse -> db , pTrig -> pSchema ) ; 
line 64314: assert ( iTrigDb == iDb || iTrigDb == 1 ) ; 
line 64315: sqlite3VdbeAddOp4 ( v , OP_DropTrigger , iTrigDb , 0 , 0 , pTrig -> zName , 0 ) ; 
line 64316: } 
line 64317: # endif 
line 64320: sqlite3VdbeAddOp4 ( v , OP_DropTable , iDb , 0 , 0 , pTab -> zName , 0 ) ; 
line 64323: zWhere = sqlite3MPrintf ( pParse -> db , "tbl_name=%Q" , zName ) ; 
line 64324: if ( ! zWhere ) return ; 
line 64325: sqlite3VdbeAddOp4 ( v , OP_ParseSchema , iDb , 0 , 0 , zWhere , P4_DYNAMIC ) ; 
line 64327: # ifndef SQLITE_OMIT_TRIGGER 
line 64331: if ( ( zWhere = whereTempTriggers ( pParse , pTab ) ) != 0 ) { 
line 64332: sqlite3VdbeAddOp4 ( v , OP_ParseSchema , 1 , 0 , 0 , zWhere , P4_DYNAMIC ) ; 
line 64333: } 
line 64334: # endif 
line 64335: } 
line 64341: SQLITE_PRIVATE void sqlite3AlterRenameTable ( 
line 64342: Parse * pParse , 
line 64343: SrcList * pSrc , 
line 64344: Token * pName 
line 64345: ) { 
line 64346: int iDb ; 
line 64347: char * zDb ; 
line 64348: Table * pTab ; 
line 64349: char * zName = 0 ; 
line 64350: sqlite3 * db = pParse -> db ; 
line 64351: int nTabName ; 
line 64352: const char * zTabName ; 
line 64353: Vdbe * v ; 
line 64354: # ifndef SQLITE_OMIT_TRIGGER 
line 64355: char * zWhere = 0 ; 
line 64356: # endif 
line 64357: VTable * pVTab = 0 ; 
line 64359: if ( NEVER ( db -> mallocFailed ) ) goto exit_rename_table ; 
line 64360: assert ( pSrc -> nSrc == 1 ) ; 
line 64361: assert ( sqlite3BtreeHoldsAllMutexes ( pParse -> db ) ) ; 
line 64363: pTab = sqlite3LocateTable ( pParse , 0 , pSrc -> a [ 0 ] . zName , pSrc -> a [ 0 ] . zDatabase ) ; 
line 64364: if ( ! pTab ) goto exit_rename_table ; 
line 64365: iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; 
line 64366: zDb = db -> aDb [ iDb ] . zName ; 
line 64369: zName = sqlite3NameFromToken ( db , pName ) ; 
line 64370: if ( ! zName ) goto exit_rename_table ; 
line 64375: if ( sqlite3FindTable ( db , zName , zDb ) || sqlite3FindIndex ( db , zName , zDb ) ) { 
line 64376: sqlite3ErrorMsg ( pParse , 
line 64377: "there is already another table or index with this name: %s" , zName ) ; 
line 64378: goto exit_rename_table ; 
line 64379: } 
line 64384: if ( sqlite3Strlen30 ( pTab -> zName ) > 6 
line 64385: && 0 == sqlite3StrNICmp ( pTab -> zName , "sqlite_" , 7 ) 
line 64386: ) { 
line 64387: sqlite3ErrorMsg ( pParse , "table %s may not be altered" , pTab -> zName ) ; 
line 64388: goto exit_rename_table ; 
line 64389: } 
line 64390: if ( SQLITE_OK != sqlite3CheckObjectName ( pParse , zName ) ) { 
line 64391: goto exit_rename_table ; 
line 64392: } 
line 64394: # ifndef SQLITE_OMIT_VIEW 
line 64395: if ( pTab -> pSelect ) { 
line 64396: sqlite3ErrorMsg ( pParse , "view %s may not be altered" , pTab -> zName ) ; 
line 64397: goto exit_rename_table ; 
line 64398: } 
line 64399: # endif 
line 64401: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 64403: if ( sqlite3AuthCheck ( pParse , SQLITE_ALTER_TABLE , zDb , pTab -> zName , 0 ) ) { 
line 64404: goto exit_rename_table ; 
line 64405: } 
line 64406: # endif 
line 64408: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 64409: if ( sqlite3ViewGetColumnNames ( pParse , pTab ) ) { 
line 64410: goto exit_rename_table ; 
line 64411: } 
line 64412: if ( IsVirtual ( pTab ) ) { 
line 64413: pVTab = sqlite3GetVTable ( db , pTab ) ; 
line 64414: if ( pVTab -> pVtab -> pModule -> xRename == 0 ) { 
line 64415: pVTab = 0 ; 
line 64416: } 
line 64417: } 
line 64418: # endif 
line 64425: v = sqlite3GetVdbe ( pParse ) ; 
line 64426: if ( v == 0 ) { 
line 64427: goto exit_rename_table ; 
line 64428: } 
line 64429: sqlite3BeginWriteOperation ( pParse , pVTab != 0 , iDb ) ; 
line 64430: sqlite3ChangeCookie ( pParse , iDb ) ; 
line 64437: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 64438: if ( pVTab ) { 
line 64439: int i = ++ pParse -> nMem ; 
line 64440: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , i , 0 , zName , 0 ) ; 
line 64441: sqlite3VdbeAddOp4 ( v , OP_VRename , i , 0 , 0 , ( const char * ) pVTab , P4_VTAB ) ; 
line 64442: sqlite3MayAbort ( pParse ) ; 
line 64443: } 
line 64444: # endif 
line 64447: zTabName = pTab -> zName ; 
line 64448: nTabName = sqlite3Utf8CharLen ( zTabName , - 1 ) ; 
line 64450: # if ! defined ( SQLITE_OMIT_FOREIGN_KEY ) && ! defined ( SQLITE_OMIT_TRIGGER ) 
line 64451: if ( db -> flags & SQLITE_ForeignKeys ) { 
line 64455: if ( ( zWhere = whereForeignKeys ( pParse , pTab ) ) != 0 ) { 
line 64456: sqlite3NestedParse ( pParse , 
line 64457: "UPDATE sqlite_master SET " 
line 64458: "sql = sqlite_rename_parent(sql, %Q, %Q) " 
line 64459: "WHERE %s;" , zTabName , zName , zWhere ) ; 
line 64460: sqlite3DbFree ( db , zWhere ) ; 
line 64461: } 
line 64462: } 
line 64463: # endif 
line 64466: sqlite3NestedParse ( pParse , 
line 64467: "UPDATE %Q.%s SET " 
line 64468: # ifdef SQLITE_OMIT_TRIGGER 
line 64469: "sql = sqlite_rename_table(sql, %Q), " 
line 64470: # else 
line 64471: "sql = CASE " 
line 64472: "WHEN type = 'trigger' THEN sqlite_rename_trigger(sql, %Q)" 
line 64473: "ELSE sqlite_rename_table(sql, %Q) END, " 
line 64474: # endif 
line 64475: "tbl_name = %Q, " 
line 64476: "name = CASE " 
line 64477: "WHEN type='table' THEN %Q " 
line 64478: "WHEN name LIKE 'sqlite_autoindex%%' AND type='index' THEN " 
line 64479: "'sqlite_autoindex_' || %Q || substr(name,%d+18) " 
line 64480: "ELSE name END " 
line 64481: "WHERE tbl_name=%Q AND " 
line 64482: "(type='table' OR type='index' OR type='trigger');" , 
line 64483: zDb , SCHEMA_TABLE ( iDb ) , zName , zName , zName , 
line 64484: # ifndef SQLITE_OMIT_TRIGGER 
line 64485: zName , 
line 64486: # endif 
line 64487: zName , nTabName , zTabName 
line 64488: ) ; 
line 64490: # ifndef SQLITE_OMIT_AUTOINCREMENT 
line 64494: if ( sqlite3FindTable ( db , "sqlite_sequence" , zDb ) ) { 
line 64495: sqlite3NestedParse ( pParse , 
line 64496: "UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q" , 
line 64497: zDb , zName , pTab -> zName ) ; 
line 64498: } 
line 64499: # endif 
line 64501: # ifndef SQLITE_OMIT_TRIGGER 
line 64506: if ( ( zWhere = whereTempTriggers ( pParse , pTab ) ) != 0 ) { 
line 64507: sqlite3NestedParse ( pParse , 
line 64508: "UPDATE sqlite_temp_master SET " 
line 64509: "sql = sqlite_rename_trigger(sql, %Q), " 
line 64510: "tbl_name = %Q " 
line 64511: "WHERE %s;" , zName , zName , zWhere ) ; 
line 64512: sqlite3DbFree ( db , zWhere ) ; 
line 64513: } 
line 64514: # endif 
line 64516: # if ! defined ( SQLITE_OMIT_FOREIGN_KEY ) && ! defined ( SQLITE_OMIT_TRIGGER ) 
line 64517: if ( db -> flags & SQLITE_ForeignKeys ) { 
line 64518: FKey * p ; 
line 64519: for ( p = sqlite3FkReferences ( pTab ) ; p ; p = p -> pNextTo ) { 
line 64520: Table * pFrom = p -> pFrom ; 
line 64521: if ( pFrom != pTab ) { 
line 64522: reloadTableSchema ( pParse , p -> pFrom , pFrom -> zName ) ; 
line 64523: } 
line 64524: } 
line 64525: } 
line 64526: # endif 
line 64529: reloadTableSchema ( pParse , pTab , zName ) ; 
line 64531: exit_rename_table : 
line 64532: sqlite3SrcListDelete ( db , pSrc ) ; 
line 64533: sqlite3DbFree ( db , zName ) ; 
line 64534: } 
line 64541: SQLITE_PRIVATE void sqlite3MinimumFileFormat ( Parse * pParse , int iDb , int minFormat ) { 
line 64542: Vdbe * v ; 
line 64543: v = sqlite3GetVdbe ( pParse ) ; 
line 64547: if ( ALWAYS ( v ) ) { 
line 64548: int r1 = sqlite3GetTempReg ( pParse ) ; 
line 64549: int r2 = sqlite3GetTempReg ( pParse ) ; 
line 64550: int j1 ; 
line 64551: sqlite3VdbeAddOp3 ( v , OP_ReadCookie , iDb , r1 , BTREE_FILE_FORMAT ) ; 
line 64552: sqlite3VdbeUsesBtree ( v , iDb ) ; 
line 64553: sqlite3VdbeAddOp2 ( v , OP_Integer , minFormat , r2 ) ; 
line 64554: j1 = sqlite3VdbeAddOp3 ( v , OP_Ge , r2 , 0 , r1 ) ; 
line 64555: sqlite3VdbeAddOp3 ( v , OP_SetCookie , iDb , BTREE_FILE_FORMAT , r2 ) ; 
line 64556: sqlite3VdbeJumpHere ( v , j1 ) ; 
line 64557: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 64558: sqlite3ReleaseTempReg ( pParse , r2 ) ; 
line 64559: } 
line 64560: } 
line 64570: SQLITE_PRIVATE void sqlite3AlterFinishAddColumn ( Parse * pParse , Token * pColDef ) { 
line 64571: Table * pNew ; 
line 64572: Table * pTab ; 
line 64573: int iDb ; 
line 64574: const char * zDb ; 
line 64575: const char * zTab ; 
line 64576: char * zCol ; 
line 64577: Column * pCol ; 
line 64578: Expr * pDflt ; 
line 64579: sqlite3 * db ; 
line 64581: db = pParse -> db ; 
line 64582: if ( pParse -> nErr || db -> mallocFailed ) return ; 
line 64583: pNew = pParse -> pNewTable ; 
line 64584: assert ( pNew ) ; 
line 64586: assert ( sqlite3BtreeHoldsAllMutexes ( db ) ) ; 
line 64587: iDb = sqlite3SchemaToIndex ( db , pNew -> pSchema ) ; 
line 64588: zDb = db -> aDb [ iDb ] . zName ; 
line 64589: zTab = & pNew -> zName [ 16 ] ; 
line 64590: pCol = & pNew -> aCol [ pNew -> nCol - 1 ] ; 
line 64591: pDflt = pCol -> pDflt ; 
line 64592: pTab = sqlite3FindTable ( db , zTab , zDb ) ; 
line 64593: assert ( pTab ) ; 
line 64595: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 64597: if ( sqlite3AuthCheck ( pParse , SQLITE_ALTER_TABLE , zDb , pTab -> zName , 0 ) ) { 
line 64598: return ; 
line 64599: } 
line 64600: # endif 
line 64606: if ( pDflt && pDflt -> op == TK_NULL ) { 
line 64607: pDflt = 0 ; 
line 64608: } 
line 64614: if ( pCol -> isPrimKey ) { 
line 64615: sqlite3ErrorMsg ( pParse , "Cannot add a PRIMARY KEY column" ) ; 
line 64616: return ; 
line 64617: } 
line 64618: if ( pNew -> pIndex ) { 
line 64619: sqlite3ErrorMsg ( pParse , "Cannot add a UNIQUE column" ) ; 
line 64620: return ; 
line 64621: } 
line 64622: if ( ( db -> flags & SQLITE_ForeignKeys ) && pNew -> pFKey && pDflt ) { 
line 64623: sqlite3ErrorMsg ( pParse , 
line 64624: "Cannot add a REFERENCES column with non-NULL default value" ) ; 
line 64625: return ; 
line 64626: } 
line 64627: if ( pCol -> notNull && ! pDflt ) { 
line 64628: sqlite3ErrorMsg ( pParse , 
line 64629: "Cannot add a NOT NULL column with default value NULL" ) ; 
line 64630: return ; 
line 64631: } 
line 64636: if ( pDflt ) { 
line 64637: sqlite3_value * pVal ; 
line 64638: if ( sqlite3ValueFromExpr ( db , pDflt , SQLITE_UTF8 , SQLITE_AFF_NONE , & pVal ) ) { 
line 64639: db -> mallocFailed = 1 ; 
line 64640: return ; 
line 64641: } 
line 64642: if ( ! pVal ) { 
line 64643: sqlite3ErrorMsg ( pParse , "Cannot add a column with non-constant default" ) ; 
line 64644: return ; 
line 64645: } 
line 64646: sqlite3ValueFree ( pVal ) ; 
line 64647: } 
line 64650: zCol = sqlite3DbStrNDup ( db , ( char * ) pColDef -> z , pColDef -> n ) ; 
line 64651: if ( zCol ) { 
line 64652: char * zEnd = & zCol [ pColDef -> n - 1 ] ; 
line 64653: while ( zEnd > zCol && ( * zEnd == ';' || sqlite3Isspace ( * zEnd ) ) ) { 
line 64654: * zEnd -- = '\0' ; 
line 64655: } 
line 64656: sqlite3NestedParse ( pParse , 
line 64657: "UPDATE \"%w\".%s SET " 
line 64658: "sql = substr(sql,1,%d) || ', ' || %Q || substr(sql,%d) " 
line 64659: "WHERE type = 'table' AND name = %Q" , 
line 64660: zDb , SCHEMA_TABLE ( iDb ) , pNew -> addColOffset , zCol , pNew -> addColOffset + 1 , 
line 64661: zTab 
line 64662: ) ; 
line 64663: sqlite3DbFree ( db , zCol ) ; 
line 64664: } 
line 64670: sqlite3MinimumFileFormat ( pParse , iDb , pDflt ? 3 : 2 ) ; 
line 64673: reloadTableSchema ( pParse , pTab , pTab -> zName ) ; 
line 64674: } 
line 64691: SQLITE_PRIVATE void sqlite3AlterBeginAddColumn ( Parse * pParse , SrcList * pSrc ) { 
line 64692: Table * pNew ; 
line 64693: Table * pTab ; 
line 64694: Vdbe * v ; 
line 64695: int iDb ; 
line 64696: int i ; 
line 64697: int nAlloc ; 
line 64698: sqlite3 * db = pParse -> db ; 
line 64701: assert ( pParse -> pNewTable == 0 ) ; 
line 64702: assert ( sqlite3BtreeHoldsAllMutexes ( db ) ) ; 
line 64703: if ( db -> mallocFailed ) goto exit_begin_add_column ; 
line 64704: pTab = sqlite3LocateTable ( pParse , 0 , pSrc -> a [ 0 ] . zName , pSrc -> a [ 0 ] . zDatabase ) ; 
line 64705: if ( ! pTab ) goto exit_begin_add_column ; 
line 64707: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 64708: if ( IsVirtual ( pTab ) ) { 
line 64709: sqlite3ErrorMsg ( pParse , "virtual tables may not be altered" ) ; 
line 64710: goto exit_begin_add_column ; 
line 64711: } 
line 64712: # endif 
line 64715: if ( pTab -> pSelect ) { 
line 64716: sqlite3ErrorMsg ( pParse , "Cannot add a column to a view" ) ; 
line 64717: goto exit_begin_add_column ; 
line 64718: } 
line 64720: assert ( pTab -> addColOffset > 0 ) ; 
line 64721: iDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; 
line 64730: pNew = ( Table * ) sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; 
line 64731: if ( ! pNew ) goto exit_begin_add_column ; 
line 64732: pParse -> pNewTable = pNew ; 
line 64733: pNew -> nRef = 1 ; 
line 64734: pNew -> dbMem = pTab -> dbMem ; 
line 64735: pNew -> nCol = pTab -> nCol ; 
line 64736: assert ( pNew -> nCol > 0 ) ; 
line 64737: nAlloc = ( ( ( pNew -> nCol - 1 ) / 8 ) * 8 ) + 8 ; 
line 64738: assert ( nAlloc >= pNew -> nCol && nAlloc % 8 == 0 && nAlloc - pNew -> nCol < 8 ) ; 
line 64739: pNew -> aCol = ( Column * ) sqlite3DbMallocZero ( db , sizeof ( Column ) * nAlloc ) ; 
line 64740: pNew -> zName = sqlite3MPrintf ( db , "sqlite_altertab_%s" , pTab -> zName ) ; 
line 64741: if ( ! pNew -> aCol || ! pNew -> zName ) { 
line 64742: db -> mallocFailed = 1 ; 
line 64743: goto exit_begin_add_column ; 
line 64744: } 
line 64745: memcpy ( pNew -> aCol , pTab -> aCol , sizeof ( Column ) * pNew -> nCol ) ; 
line 64746: for ( i = 0 ; i < pNew -> nCol ; i ++ ) { 
line 64747: Column * pCol = & pNew -> aCol [ i ] ; 
line 64748: pCol -> zName = sqlite3DbStrDup ( db , pCol -> zName ) ; 
line 64749: pCol -> zColl = 0 ; 
line 64750: pCol -> zType = 0 ; 
line 64751: pCol -> pDflt = 0 ; 
line 64752: pCol -> zDflt = 0 ; 
line 64753: } 
line 64754: pNew -> pSchema = db -> aDb [ iDb ] . pSchema ; 
line 64755: pNew -> addColOffset = pTab -> addColOffset ; 
line 64756: pNew -> nRef = 1 ; 
line 64759: sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; 
line 64760: v = sqlite3GetVdbe ( pParse ) ; 
line 64761: if ( ! v ) goto exit_begin_add_column ; 
line 64762: sqlite3ChangeCookie ( pParse , iDb ) ; 
line 64764: exit_begin_add_column : 
line 64765: sqlite3SrcListDelete ( db , pSrc ) ; 
line 64766: return ; 
line 64767: } 
line 64768: # endif 
line 64785: # ifndef SQLITE_OMIT_ANALYZE 
line 64803: static void openStatTable ( 
line 64804: Parse * pParse , 
line 64805: int iDb , 
line 64806: int iStatCur , 
line 64807: const char * zWhere 
line 64808: ) { 
line 64809: static struct { 
line 64810: const char * zName ; 
line 64811: const char * zCols ; 
line 64812: } aTable [ ] = { 
line 64813: { "sqlite_stat1" , "tbl,idx,stat" } , 
line 64814: # ifdef SQLITE_ENABLE_STAT2 
line 64815: { "sqlite_stat2" , "tbl,idx,sampleno,sample" } , 
line 64816: # endif 
line 64817: } ; 
line 64819: int aRoot [ ] = { 0 , 0 } ; 
line 64820: u8 aCreateTbl [ ] = { 0 , 0 } ; 
line 64822: int i ; 
line 64823: sqlite3 * db = pParse -> db ; 
line 64824: Db * pDb ; 
line 64825: Vdbe * v = sqlite3GetVdbe ( pParse ) ; 
line 64826: if ( v == 0 ) return ; 
line 64827: assert ( sqlite3BtreeHoldsAllMutexes ( db ) ) ; 
line 64828: assert ( sqlite3VdbeDb ( v ) == db ) ; 
line 64829: pDb = & db -> aDb [ iDb ] ; 
line 64831: for ( i = 0 ; i < ArraySize ( aTable ) ; i ++ ) { 
line 64832: const char * zTab = aTable [ i ] . zName ; 
line 64833: Table * pStat ; 
line 64834: if ( ( pStat = sqlite3FindTable ( db , zTab , pDb -> zName ) ) == 0 ) { 
line 64839: sqlite3NestedParse ( pParse , 
line 64840: "CREATE TABLE %Q.%s(%s)" , pDb -> zName , zTab , aTable [ i ] . zCols 
line 64841: ) ; 
line 64842: aRoot [ i ] = pParse -> regRoot ; 
line 64843: aCreateTbl [ i ] = 1 ; 
line 64844: } else { 
line 64848: aRoot [ i ] = pStat -> tnum ; 
line 64849: sqlite3TableLock ( pParse , iDb , aRoot [ i ] , 1 , zTab ) ; 
line 64850: if ( zWhere ) { 
line 64851: sqlite3NestedParse ( pParse , 
line 64852: "DELETE FROM %Q.%s WHERE tbl=%Q" , pDb -> zName , zTab , zWhere 
line 64853: ) ; 
line 64854: } else { 
line 64856: sqlite3VdbeAddOp2 ( v , OP_Clear , aRoot [ i ] , iDb ) ; 
line 64857: } 
line 64858: } 
line 64859: } 
line 64862: for ( i = 0 ; i < ArraySize ( aTable ) ; i ++ ) { 
line 64863: sqlite3VdbeAddOp3 ( v , OP_OpenWrite , iStatCur + i , aRoot [ i ] , iDb ) ; 
line 64864: sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) 3 , P4_INT32 ) ; 
line 64865: sqlite3VdbeChangeP5 ( v , aCreateTbl [ i ] ) ; 
line 64866: } 
line 64867: } 
line 64873: static void analyzeOneTable ( 
line 64874: Parse * pParse , 
line 64875: Table * pTab , 
line 64876: int iStatCur , 
line 64877: int iMem 
line 64878: ) { 
line 64879: sqlite3 * db = pParse -> db ; 
line 64880: Index * pIdx ; 
line 64881: int iIdxCur ; 
line 64882: Vdbe * v ; 
line 64883: int i ; 
line 64884: int topOfLoop ; 
line 64885: int endOfLoop ; 
line 64886: int addr ; 
line 64887: int iDb ; 
line 64888: int regTabname = iMem ++ ; 
line 64889: int regIdxname = iMem ++ ; 
line 64890: int regSampleno = iMem ++ ; 
line 64891: int regCol = iMem ++ ; 
line 64892: int regRec = iMem ++ ; 
line 64893: int regTemp = iMem ++ ; 
line 64894: int regRowid = iMem ++ ; 
line 64896: # ifdef SQLITE_ENABLE_STAT2 
line 64897: int regTemp2 = iMem ++ ; 
line 64898: int regSamplerecno = iMem ++ ; 
line 64899: int regRecno = iMem ++ ; 
line 64900: int regLast = iMem ++ ; 
line 64901: int regFirst = iMem ++ ; 
line 64902: # endif 
line 64904: v = sqlite3GetVdbe ( pParse ) ; 
line 64905: if ( v == 0 || NEVER ( pTab == 0 ) || pTab -> pIndex == 0 ) { 
line 64907: return ; 
line 64908: } 
line 64909: assert ( sqlite3BtreeHoldsAllMutexes ( db ) ) ; 
line 64910: iDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; 
line 64911: assert ( iDb >= 0 ) ; 
line 64912: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 64913: if ( sqlite3AuthCheck ( pParse , SQLITE_ANALYZE , pTab -> zName , 0 , 
line 64914: db -> aDb [ iDb ] . zName ) ) { 
line 64915: return ; 
line 64916: } 
line 64917: # endif 
line 64920: sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ) ; 
line 64922: iIdxCur = pParse -> nTab ++ ; 
line 64923: for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { 
line 64924: int nCol = pIdx -> nColumn ; 
line 64925: KeyInfo * pKey = sqlite3IndexKeyinfo ( pParse , pIdx ) ; 
line 64927: if ( iMem + 1 + ( nCol * 2 ) > pParse -> nMem ) { 
line 64928: pParse -> nMem = iMem + 1 + ( nCol * 2 ) ; 
line 64929: } 
line 64932: assert ( iDb == sqlite3SchemaToIndex ( db , pIdx -> pSchema ) ) ; 
line 64933: sqlite3VdbeAddOp4 ( v , OP_OpenRead , iIdxCur , pIdx -> tnum , iDb , 
line 64934: ( char * ) pKey , P4_KEYINFO_HANDOFF ) ; 
line 64935: VdbeComment ( ( v , "%s" , pIdx -> zName ) ) ; 
line 64938: if ( pTab -> pIndex == pIdx ) { 
line 64939: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , regTabname , 0 , pTab -> zName , 0 ) ; 
line 64940: } 
line 64941: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , regIdxname , 0 , pIdx -> zName , 0 ) ; 
line 64943: # ifdef SQLITE_ENABLE_STAT2 
line 64948: if ( pTab -> pIndex == pIdx ) { 
line 64949: sqlite3VdbeAddOp2 ( v , OP_Integer , SQLITE_INDEX_SAMPLES , regSamplerecno ) ; 
line 64950: sqlite3VdbeAddOp2 ( v , OP_Integer , SQLITE_INDEX_SAMPLES * 2 - 1 , regTemp ) ; 
line 64951: sqlite3VdbeAddOp2 ( v , OP_Integer , SQLITE_INDEX_SAMPLES * 2 , regTemp2 ) ; 
line 64953: sqlite3VdbeAddOp2 ( v , OP_Count , iIdxCur , regLast ) ; 
line 64954: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , regFirst ) ; 
line 64955: addr = sqlite3VdbeAddOp3 ( v , OP_Lt , regSamplerecno , 0 , regLast ) ; 
line 64956: sqlite3VdbeAddOp3 ( v , OP_Divide , regTemp2 , regLast , regFirst ) ; 
line 64957: sqlite3VdbeAddOp3 ( v , OP_Multiply , regLast , regTemp , regLast ) ; 
line 64958: sqlite3VdbeAddOp2 ( v , OP_AddImm , regLast , SQLITE_INDEX_SAMPLES * 2 - 2 ) ; 
line 64959: sqlite3VdbeAddOp3 ( v , OP_Divide , regTemp2 , regLast , regLast ) ; 
line 64960: sqlite3VdbeJumpHere ( v , addr ) ; 
line 64961: } 
line 64964: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regSampleno ) ; 
line 64965: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regRecno ) ; 
line 64966: sqlite3VdbeAddOp2 ( v , OP_Copy , regFirst , regSamplerecno ) ; 
line 64967: # endif 
line 64985: for ( i = 0 ; i <= nCol ; i ++ ) { 
line 64986: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iMem + i ) ; 
line 64987: } 
line 64988: for ( i = 0 ; i < nCol ; i ++ ) { 
line 64989: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , iMem + nCol + i + 1 ) ; 
line 64990: } 
line 64994: endOfLoop = sqlite3VdbeMakeLabel ( v ) ; 
line 64995: sqlite3VdbeAddOp2 ( v , OP_Rewind , iIdxCur , endOfLoop ) ; 
line 64996: topOfLoop = sqlite3VdbeCurrentAddr ( v ) ; 
line 64997: sqlite3VdbeAddOp2 ( v , OP_AddImm , iMem , 1 ) ; 
line 64999: for ( i = 0 ; i < nCol ; i ++ ) { 
line 65000: sqlite3VdbeAddOp3 ( v , OP_Column , iIdxCur , i , regCol ) ; 
line 65001: # ifdef SQLITE_ENABLE_STAT2 
line 65002: if ( i == 0 ) { 
line 65006: int ne = sqlite3VdbeAddOp3 ( v , OP_Ne , regRecno , 0 , regSamplerecno ) ; 
line 65007: assert ( regTabname + 1 == regIdxname 
line 65008: && regTabname + 2 == regSampleno 
line 65009: && regTabname + 3 == regCol 
line 65010: ) ; 
line 65011: sqlite3VdbeChangeP5 ( v , SQLITE_JUMPIFNULL ) ; 
line 65012: sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regTabname , 4 , regRec , "aaab" , 0 ) ; 
line 65013: sqlite3VdbeAddOp2 ( v , OP_NewRowid , iStatCur + 1 , regRowid ) ; 
line 65014: sqlite3VdbeAddOp3 ( v , OP_Insert , iStatCur + 1 , regRec , regRowid ) ; 
line 65021: sqlite3VdbeAddOp2 ( v , OP_AddImm , regSampleno , 1 ) ; 
line 65022: sqlite3VdbeAddOp3 ( v , OP_Subtract , regRecno , regLast , regTemp ) ; 
line 65023: sqlite3VdbeAddOp2 ( v , OP_AddImm , regTemp , - 1 ) ; 
line 65024: sqlite3VdbeAddOp2 ( v , OP_Integer , SQLITE_INDEX_SAMPLES , regTemp2 ) ; 
line 65025: sqlite3VdbeAddOp3 ( v , OP_Subtract , regSampleno , regTemp2 , regTemp2 ) ; 
line 65026: sqlite3VdbeAddOp3 ( v , OP_Divide , regTemp2 , regTemp , regTemp ) ; 
line 65027: sqlite3VdbeAddOp3 ( v , OP_Add , regSamplerecno , regTemp , regSamplerecno ) ; 
line 65029: sqlite3VdbeJumpHere ( v , ne ) ; 
line 65030: sqlite3VdbeAddOp2 ( v , OP_AddImm , regRecno , 1 ) ; 
line 65031: } 
line 65032: # endif 
line 65034: sqlite3VdbeAddOp3 ( v , OP_Ne , regCol , 0 , iMem + nCol + i + 1 ) ; 
line 65036: sqlite3VdbeChangeP5 ( v , SQLITE_JUMPIFNULL ) ; 
line 65037: } 
line 65038: if ( db -> mallocFailed ) { 
line 65043: return ; 
line 65044: } 
line 65045: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , endOfLoop ) ; 
line 65046: for ( i = 0 ; i < nCol ; i ++ ) { 
line 65047: sqlite3VdbeJumpHere ( v , sqlite3VdbeCurrentAddr ( v ) - ( nCol * 2 ) ) ; 
line 65048: sqlite3VdbeAddOp2 ( v , OP_AddImm , iMem + i + 1 , 1 ) ; 
line 65049: sqlite3VdbeAddOp3 ( v , OP_Column , iIdxCur , i , iMem + nCol + i + 1 ) ; 
line 65050: } 
line 65053: sqlite3VdbeResolveLabel ( v , endOfLoop ) ; 
line 65054: sqlite3VdbeAddOp2 ( v , OP_Next , iIdxCur , topOfLoop ) ; 
line 65055: sqlite3VdbeAddOp1 ( v , OP_Close , iIdxCur ) ; 
line 65075: addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , iMem ) ; 
line 65076: sqlite3VdbeAddOp2 ( v , OP_SCopy , iMem , regSampleno ) ; 
line 65077: for ( i = 0 ; i < nCol ; i ++ ) { 
line 65078: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , regTemp , 0 , " " , 0 ) ; 
line 65079: sqlite3VdbeAddOp3 ( v , OP_Concat , regTemp , regSampleno , regSampleno ) ; 
line 65080: sqlite3VdbeAddOp3 ( v , OP_Add , iMem , iMem + i + 1 , regTemp ) ; 
line 65081: sqlite3VdbeAddOp2 ( v , OP_AddImm , regTemp , - 1 ) ; 
line 65082: sqlite3VdbeAddOp3 ( v , OP_Divide , iMem + i + 1 , regTemp , regTemp ) ; 
line 65083: sqlite3VdbeAddOp1 ( v , OP_ToInt , regTemp ) ; 
line 65084: sqlite3VdbeAddOp3 ( v , OP_Concat , regTemp , regSampleno , regSampleno ) ; 
line 65085: } 
line 65086: sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regTabname , 3 , regRec , "aaa" , 0 ) ; 
line 65087: sqlite3VdbeAddOp2 ( v , OP_NewRowid , iStatCur , regRowid ) ; 
line 65088: sqlite3VdbeAddOp3 ( v , OP_Insert , iStatCur , regRec , regRowid ) ; 
line 65089: sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ) ; 
line 65090: sqlite3VdbeJumpHere ( v , addr ) ; 
line 65091: } 
line 65092: } 
line 65098: static void loadAnalysis ( Parse * pParse , int iDb ) { 
line 65099: Vdbe * v = sqlite3GetVdbe ( pParse ) ; 
line 65100: if ( v ) { 
line 65101: sqlite3VdbeAddOp1 ( v , OP_LoadAnalysis , iDb ) ; 
line 65102: } 
line 65103: } 
line 65108: static void analyzeDatabase ( Parse * pParse , int iDb ) { 
line 65109: sqlite3 * db = pParse -> db ; 
line 65110: Schema * pSchema = db -> aDb [ iDb ] . pSchema ; 
line 65111: HashElem * k ; 
line 65112: int iStatCur ; 
line 65113: int iMem ; 
line 65115: sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; 
line 65116: iStatCur = pParse -> nTab ; 
line 65117: pParse -> nTab += 2 ; 
line 65118: openStatTable ( pParse , iDb , iStatCur , 0 ) ; 
line 65119: iMem = pParse -> nMem + 1 ; 
line 65120: for ( k = sqliteHashFirst ( & pSchema -> tblHash ) ; k ; k = sqliteHashNext ( k ) ) { 
line 65121: Table * pTab = ( Table * ) sqliteHashData ( k ) ; 
line 65122: analyzeOneTable ( pParse , pTab , iStatCur , iMem ) ; 
line 65123: } 
line 65124: loadAnalysis ( pParse , iDb ) ; 
line 65125: } 
line 65131: static void analyzeTable ( Parse * pParse , Table * pTab ) { 
line 65132: int iDb ; 
line 65133: int iStatCur ; 
line 65135: assert ( pTab != 0 ) ; 
line 65136: assert ( sqlite3BtreeHoldsAllMutexes ( pParse -> db ) ) ; 
line 65137: iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; 
line 65138: sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; 
line 65139: iStatCur = pParse -> nTab ; 
line 65140: pParse -> nTab += 2 ; 
line 65141: openStatTable ( pParse , iDb , iStatCur , pTab -> zName ) ; 
line 65142: analyzeOneTable ( pParse , pTab , iStatCur , pParse -> nMem + 1 ) ; 
line 65143: loadAnalysis ( pParse , iDb ) ; 
line 65144: } 
line 65158: SQLITE_PRIVATE void sqlite3Analyze ( Parse * pParse , Token * pName1 , Token * pName2 ) { 
line 65159: sqlite3 * db = pParse -> db ; 
line 65160: int iDb ; 
line 65161: int i ; 
line 65162: char * z , * zDb ; 
line 65163: Table * pTab ; 
line 65164: Token * pTableName ; 
line 65168: assert ( sqlite3BtreeHoldsAllMutexes ( pParse -> db ) ) ; 
line 65169: if ( SQLITE_OK != sqlite3ReadSchema ( pParse ) ) { 
line 65170: return ; 
line 65171: } 
line 65173: assert ( pName2 != 0 || pName1 == 0 ) ; 
line 65174: if ( pName1 == 0 ) { 
line 65176: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 65177: if ( i == 1 ) continue ; 
line 65178: analyzeDatabase ( pParse , i ) ; 
line 65179: } 
line 65180: } else if ( pName2 -> n == 0 ) { 
line 65182: iDb = sqlite3FindDb ( db , pName1 ) ; 
line 65183: if ( iDb >= 0 ) { 
line 65184: analyzeDatabase ( pParse , iDb ) ; 
line 65185: } else { 
line 65186: z = sqlite3NameFromToken ( db , pName1 ) ; 
line 65187: if ( z ) { 
line 65188: pTab = sqlite3LocateTable ( pParse , 0 , z , 0 ) ; 
line 65189: sqlite3DbFree ( db , z ) ; 
line 65190: if ( pTab ) { 
line 65191: analyzeTable ( pParse , pTab ) ; 
line 65192: } 
line 65193: } 
line 65194: } 
line 65195: } else { 
line 65197: iDb = sqlite3TwoPartName ( pParse , pName1 , pName2 , & pTableName ) ; 
line 65198: if ( iDb >= 0 ) { 
line 65199: zDb = db -> aDb [ iDb ] . zName ; 
line 65200: z = sqlite3NameFromToken ( db , pTableName ) ; 
line 65201: if ( z ) { 
line 65202: pTab = sqlite3LocateTable ( pParse , 0 , z , zDb ) ; 
line 65203: sqlite3DbFree ( db , z ) ; 
line 65204: if ( pTab ) { 
line 65205: analyzeTable ( pParse , pTab ) ; 
line 65206: } 
line 65207: } 
line 65208: } 
line 65209: } 
line 65210: } 
line 65216: typedef struct analysisInfo analysisInfo ; 
line 65217: struct analysisInfo { 
line 65218: sqlite3 * db ; 
line 65219: const char * zDatabase ; 
line 65220: } ; 
line 65229: static int analysisLoader ( void * pData , int argc , char * * argv , char * * NotUsed ) { 
line 65230: analysisInfo * pInfo = ( analysisInfo * ) pData ; 
line 65231: Index * pIndex ; 
line 65232: int i , c ; 
line 65233: unsigned int v ; 
line 65234: const char * z ; 
line 65236: assert ( argc == 2 ) ; 
line 65237: UNUSED_PARAMETER2 ( NotUsed , argc ) ; 
line 65239: if ( argv == 0 || argv [ 0 ] == 0 || argv [ 1 ] == 0 ) { 
line 65240: return 0 ; 
line 65241: } 
line 65242: pIndex = sqlite3FindIndex ( pInfo -> db , argv [ 0 ] , pInfo -> zDatabase ) ; 
line 65243: if ( pIndex == 0 ) { 
line 65244: return 0 ; 
line 65245: } 
line 65246: z = argv [ 1 ] ; 
line 65247: for ( i = 0 ; * z && i <= pIndex -> nColumn ; i ++ ) { 
line 65248: v = 0 ; 
line 65249: while ( ( c = z [ 0 ] ) >= '0' && c <= '9' ) { 
line 65250: v = v * 10 + c - '0' ; 
line 65251: z ++ ; 
line 65252: } 
line 65253: pIndex -> aiRowEst [ i ] = v ; 
line 65254: if ( * z == ' ' ) z ++ ; 
line 65255: } 
line 65256: return 0 ; 
line 65257: } 
line 65263: SQLITE_PRIVATE void sqlite3DeleteIndexSamples ( Index * pIdx ) { 
line 65264: # ifdef SQLITE_ENABLE_STAT2 
line 65265: if ( pIdx -> aSample ) { 
line 65266: int j ; 
line 65267: sqlite3 * dbMem = pIdx -> pTable -> dbMem ; 
line 65268: for ( j = 0 ; j < SQLITE_INDEX_SAMPLES ; j ++ ) { 
line 65269: IndexSample * p = & pIdx -> aSample [ j ] ; 
line 65270: if ( p -> eType == SQLITE_TEXT || p -> eType == SQLITE_BLOB ) { 
line 65271: sqlite3DbFree ( pIdx -> pTable -> dbMem , p -> u . z ) ; 
line 65272: } 
line 65273: } 
line 65274: sqlite3DbFree ( dbMem , pIdx -> aSample ) ; 
line 65275: pIdx -> aSample = 0 ; 
line 65276: } 
line 65277: # else 
line 65278: UNUSED_PARAMETER ( pIdx ) ; 
line 65279: # endif 
line 65280: } 
line 65302: SQLITE_PRIVATE int sqlite3AnalysisLoad ( sqlite3 * db , int iDb ) { 
line 65303: analysisInfo sInfo ; 
line 65304: HashElem * i ; 
line 65305: char * zSql ; 
line 65306: int rc ; 
line 65308: assert ( iDb >= 0 && iDb < db -> nDb ) ; 
line 65309: assert ( db -> aDb [ iDb ] . pBt != 0 ) ; 
line 65310: assert ( sqlite3BtreeHoldsMutex ( db -> aDb [ iDb ] . pBt ) ) ; 
line 65313: for ( i = sqliteHashFirst ( & db -> aDb [ iDb ] . pSchema -> idxHash ) ; i ; i = sqliteHashNext ( i ) ) { 
line 65314: Index * pIdx = sqliteHashData ( i ) ; 
line 65315: sqlite3DefaultRowEst ( pIdx ) ; 
line 65316: sqlite3DeleteIndexSamples ( pIdx ) ; 
line 65317: } 
line 65320: sInfo . db = db ; 
line 65321: sInfo . zDatabase = db -> aDb [ iDb ] . zName ; 
line 65322: if ( sqlite3FindTable ( db , "sqlite_stat1" , sInfo . zDatabase ) == 0 ) { 
line 65323: return SQLITE_ERROR ; 
line 65324: } 
line 65327: zSql = sqlite3MPrintf ( db , 
line 65328: "SELECT idx, stat FROM %Q.sqlite_stat1" , sInfo . zDatabase ) ; 
line 65329: if ( zSql == 0 ) { 
line 65330: rc = SQLITE_NOMEM ; 
line 65331: } else { 
line 65332: ( void ) sqlite3SafetyOff ( db ) ; 
line 65333: rc = sqlite3_exec ( db , zSql , analysisLoader , & sInfo , 0 ) ; 
line 65334: ( void ) sqlite3SafetyOn ( db ) ; 
line 65335: sqlite3DbFree ( db , zSql ) ; 
line 65336: } 
line 65340: # ifdef SQLITE_ENABLE_STAT2 
line 65341: if ( rc == SQLITE_OK && ! sqlite3FindTable ( db , "sqlite_stat2" , sInfo . zDatabase ) ) { 
line 65342: rc = SQLITE_ERROR ; 
line 65343: } 
line 65344: if ( rc == SQLITE_OK ) { 
line 65345: sqlite3_stmt * pStmt = 0 ; 
line 65347: zSql = sqlite3MPrintf ( db , 
line 65348: "SELECT idx,sampleno,sample FROM %Q.sqlite_stat2" , sInfo . zDatabase ) ; 
line 65349: if ( ! zSql ) { 
line 65350: rc = SQLITE_NOMEM ; 
line 65351: } else { 
line 65352: ( void ) sqlite3SafetyOff ( db ) ; 
line 65353: rc = sqlite3_prepare ( db , zSql , - 1 , & pStmt , 0 ) ; 
line 65354: ( void ) sqlite3SafetyOn ( db ) ; 
line 65355: sqlite3DbFree ( db , zSql ) ; 
line 65356: } 
line 65358: if ( rc == SQLITE_OK ) { 
line 65359: ( void ) sqlite3SafetyOff ( db ) ; 
line 65360: while ( sqlite3_step ( pStmt ) == SQLITE_ROW ) { 
line 65361: char * zIndex = ( char * ) sqlite3_column_text ( pStmt , 0 ) ; 
line 65362: Index * pIdx = sqlite3FindIndex ( db , zIndex , sInfo . zDatabase ) ; 
line 65363: if ( pIdx ) { 
line 65364: int iSample = sqlite3_column_int ( pStmt , 1 ) ; 
line 65365: sqlite3 * dbMem = pIdx -> pTable -> dbMem ; 
line 65366: assert ( dbMem == db || dbMem == 0 ) ; 
line 65367: if ( iSample < SQLITE_INDEX_SAMPLES && iSample >= 0 ) { 
line 65368: int eType = sqlite3_column_type ( pStmt , 2 ) ; 
line 65370: if ( pIdx -> aSample == 0 ) { 
line 65371: static const int sz = sizeof ( IndexSample ) * SQLITE_INDEX_SAMPLES ; 
line 65372: pIdx -> aSample = ( IndexSample * ) sqlite3DbMallocZero ( dbMem , sz ) ; 
line 65373: if ( pIdx -> aSample == 0 ) { 
line 65374: db -> mallocFailed = 1 ; 
line 65375: break ; 
line 65376: } 
line 65377: } 
line 65379: assert ( pIdx -> aSample ) ; 
line 65380: { 
line 65381: IndexSample * pSample = & pIdx -> aSample [ iSample ] ; 
line 65382: pSample -> eType = ( u8 ) eType ; 
line 65383: if ( eType == SQLITE_INTEGER || eType == SQLITE_FLOAT ) { 
line 65384: pSample -> u . r = sqlite3_column_double ( pStmt , 2 ) ; 
line 65385: } else if ( eType == SQLITE_TEXT || eType == SQLITE_BLOB ) { 
line 65386: const char * z = ( const char * ) ( 
line 65387: ( eType == SQLITE_BLOB ) ? 
line 65388: sqlite3_column_blob ( pStmt , 2 ) : 
line 65389: sqlite3_column_text ( pStmt , 2 ) 
line 65390: ) ; 
line 65391: int n = sqlite3_column_bytes ( pStmt , 2 ) ; 
line 65392: if ( n > 24 ) { 
line 65393: n = 24 ; 
line 65394: } 
line 65395: pSample -> nByte = ( u8 ) n ; 
line 65396: pSample -> u . z = sqlite3DbMallocRaw ( dbMem , n ) ; 
line 65397: if ( pSample -> u . z ) { 
line 65398: memcpy ( pSample -> u . z , z , n ) ; 
line 65399: } else { 
line 65400: db -> mallocFailed = 1 ; 
line 65401: break ; 
line 65402: } 
line 65403: } 
line 65404: } 
line 65405: } 
line 65406: } 
line 65407: } 
line 65408: rc = sqlite3_finalize ( pStmt ) ; 
line 65409: ( void ) sqlite3SafetyOn ( db ) ; 
line 65410: } 
line 65411: } 
line 65412: # endif 
line 65414: if ( rc == SQLITE_NOMEM ) { 
line 65415: db -> mallocFailed = 1 ; 
line 65416: } 
line 65417: return rc ; 
line 65418: } 
line 65421: # endif 
line 65439: # ifndef SQLITE_OMIT_ATTACH 
line 65458: static int resolveAttachExpr ( NameContext * pName , Expr * pExpr ) 
line 65459: { 
line 65460: int rc = SQLITE_OK ; 
line 65461: if ( pExpr ) { 
line 65462: if ( pExpr -> op != TK_ID ) { 
line 65463: rc = sqlite3ResolveExprNames ( pName , pExpr ) ; 
line 65464: if ( rc == SQLITE_OK && ! sqlite3ExprIsConstant ( pExpr ) ) { 
line 65465: sqlite3ErrorMsg ( pName -> pParse , "invalid name: \"%s\"" , pExpr -> u . zToken ) ; 
line 65466: return SQLITE_ERROR ; 
line 65467: } 
line 65468: } else { 
line 65469: pExpr -> op = TK_STRING ; 
line 65470: } 
line 65471: } 
line 65472: return rc ; 
line 65473: } 
line 65486: static void attachFunc ( 
line 65487: sqlite3_context * context , 
line 65488: int NotUsed , 
line 65489: sqlite3_value * * argv 
line 65490: ) { 
line 65491: int i ; 
line 65492: int rc = 0 ; 
line 65493: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 65494: const char * zName ; 
line 65495: const char * zFile ; 
line 65496: Db * aNew ; 
line 65497: char * zErrDyn = 0 ; 
line 65499: UNUSED_PARAMETER ( NotUsed ) ; 
line 65501: zFile = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; 
line 65502: zName = ( const char * ) sqlite3_value_text ( argv [ 1 ] ) ; 
line 65503: if ( zFile == 0 ) zFile = "" ; 
line 65504: if ( zName == 0 ) zName = "" ; 
line 65512: if ( db -> nDb >= db -> aLimit [ SQLITE_LIMIT_ATTACHED ] + 2 ) { 
line 65513: zErrDyn = sqlite3MPrintf ( db , "too many attached databases - max %d" , 
line 65514: db -> aLimit [ SQLITE_LIMIT_ATTACHED ] 
line 65515: ) ; 
line 65516: goto attach_error ; 
line 65517: } 
line 65518: if ( ! db -> autoCommit ) { 
line 65519: zErrDyn = sqlite3MPrintf ( db , "cannot ATTACH database within transaction" ) ; 
line 65520: goto attach_error ; 
line 65521: } 
line 65522: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 65523: char * z = db -> aDb [ i ] . zName ; 
line 65524: assert ( z && zName ) ; 
line 65525: if ( sqlite3StrICmp ( z , zName ) == 0 ) { 
line 65526: zErrDyn = sqlite3MPrintf ( db , "database %s is already in use" , zName ) ; 
line 65527: goto attach_error ; 
line 65528: } 
line 65529: } 
line 65534: if ( db -> aDb == db -> aDbStatic ) { 
line 65535: aNew = sqlite3DbMallocRaw ( db , sizeof ( db -> aDb [ 0 ] ) * 3 ) ; 
line 65536: if ( aNew == 0 ) return ; 
line 65537: memcpy ( aNew , db -> aDb , sizeof ( db -> aDb [ 0 ] ) * 2 ) ; 
line 65538: } else { 
line 65539: aNew = sqlite3DbRealloc ( db , db -> aDb , sizeof ( db -> aDb [ 0 ] ) * ( db -> nDb + 1 ) ) ; 
line 65540: if ( aNew == 0 ) return ; 
line 65541: } 
line 65542: db -> aDb = aNew ; 
line 65543: aNew = & db -> aDb [ db -> nDb ] ; 
line 65544: memset ( aNew , 0 , sizeof ( * aNew ) ) ; 
line 65550: rc = sqlite3BtreeFactory ( db , zFile , 0 , SQLITE_DEFAULT_CACHE_SIZE , 
line 65551: db -> openFlags | SQLITE_OPEN_MAIN_DB , 
line 65552: & aNew -> pBt ) ; 
line 65553: db -> nDb ++ ; 
line 65554: if ( rc == SQLITE_CONSTRAINT ) { 
line 65555: rc = SQLITE_ERROR ; 
line 65556: zErrDyn = sqlite3MPrintf ( db , "database is already attached" ) ; 
line 65557: } else if ( rc == SQLITE_OK ) { 
line 65558: Pager * pPager ; 
line 65559: aNew -> pSchema = sqlite3SchemaGet ( db , aNew -> pBt ) ; 
line 65560: if ( ! aNew -> pSchema ) { 
line 65561: rc = SQLITE_NOMEM ; 
line 65562: } else if ( aNew -> pSchema -> file_format && aNew -> pSchema -> enc != ENC ( db ) ) { 
line 65563: zErrDyn = sqlite3MPrintf ( db , 
line 65564: "attached databases must use the same text encoding as main database" ) ; 
line 65565: rc = SQLITE_ERROR ; 
line 65566: } 
line 65567: pPager = sqlite3BtreePager ( aNew -> pBt ) ; 
line 65568: sqlite3PagerLockingMode ( pPager , db -> dfltLockMode ) ; 
line 65569: sqlite3PagerJournalMode ( pPager , db -> dfltJournalMode ) ; 
line 65570: } 
line 65571: aNew -> zName = sqlite3DbStrDup ( db , zName ) ; 
line 65572: aNew -> safety_level = 3 ; 
line 65574: # if SQLITE_HAS_CODEC 
line 65575: if ( rc == SQLITE_OK ) { 
line 65576: extern int sqlite3CodecAttach ( sqlite3 * , int , const void * , int ) ; 
line 65577: extern void sqlite3CodecGetKey ( sqlite3 * , int , void * * , int * ) ; 
line 65578: int nKey ; 
line 65579: char * zKey ; 
line 65580: int t = sqlite3_value_type ( argv [ 2 ] ) ; 
line 65581: switch ( t ) { 
line 65582: case SQLITE_INTEGER : 
line 65583: case SQLITE_FLOAT : 
line 65584: zErrDyn = sqlite3DbStrDup ( db , "Invalid key value" ) ; 
line 65585: rc = SQLITE_ERROR ; 
line 65586: break ; 
line 65588: case SQLITE_TEXT : 
line 65589: case SQLITE_BLOB : 
line 65590: nKey = sqlite3_value_bytes ( argv [ 2 ] ) ; 
line 65591: zKey = ( char * ) sqlite3_value_blob ( argv [ 2 ] ) ; 
line 65592: rc = sqlite3CodecAttach ( db , db -> nDb - 1 , zKey , nKey ) ; 
line 65593: break ; 
line 65595: case SQLITE_NULL : 
line 65597: sqlite3CodecGetKey ( db , 0 , ( void * * ) & zKey , & nKey ) ; 
line 65598: rc = sqlite3CodecAttach ( db , db -> nDb - 1 , zKey , nKey ) ; 
line 65599: break ; 
line 65600: } 
line 65601: } 
line 65602: # endif 
line 65609: if ( rc == SQLITE_OK ) { 
line 65610: ( void ) sqlite3SafetyOn ( db ) ; 
line 65611: sqlite3BtreeEnterAll ( db ) ; 
line 65612: rc = sqlite3Init ( db , & zErrDyn ) ; 
line 65613: sqlite3BtreeLeaveAll ( db ) ; 
line 65614: ( void ) sqlite3SafetyOff ( db ) ; 
line 65615: } 
line 65616: if ( rc ) { 
line 65617: int iDb = db -> nDb - 1 ; 
line 65618: assert ( iDb >= 2 ) ; 
line 65619: if ( db -> aDb [ iDb ] . pBt ) { 
line 65620: sqlite3BtreeClose ( db -> aDb [ iDb ] . pBt ) ; 
line 65621: db -> aDb [ iDb ] . pBt = 0 ; 
line 65622: db -> aDb [ iDb ] . pSchema = 0 ; 
line 65623: } 
line 65624: sqlite3ResetInternalSchema ( db , 0 ) ; 
line 65625: db -> nDb = iDb ; 
line 65626: if ( rc == SQLITE_NOMEM || rc == SQLITE_IOERR_NOMEM ) { 
line 65627: db -> mallocFailed = 1 ; 
line 65628: sqlite3DbFree ( db , zErrDyn ) ; 
line 65629: zErrDyn = sqlite3MPrintf ( db , "out of memory" ) ; 
line 65630: } else if ( zErrDyn == 0 ) { 
line 65631: zErrDyn = sqlite3MPrintf ( db , "unable to open database: %s" , zFile ) ; 
line 65632: } 
line 65633: goto attach_error ; 
line 65634: } 
line 65636: return ; 
line 65638: attach_error : 
line 65640: if ( zErrDyn ) { 
line 65641: sqlite3_result_error ( context , zErrDyn , - 1 ) ; 
line 65642: sqlite3DbFree ( db , zErrDyn ) ; 
line 65643: } 
line 65644: if ( rc ) sqlite3_result_error_code ( context , rc ) ; 
line 65645: } 
line 65655: static void detachFunc ( 
line 65656: sqlite3_context * context , 
line 65657: int NotUsed , 
line 65658: sqlite3_value * * argv 
line 65659: ) { 
line 65660: const char * zName = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; 
line 65661: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 65662: int i ; 
line 65663: Db * pDb = 0 ; 
line 65664: char zErr [ 128 ] ; 
line 65666: UNUSED_PARAMETER ( NotUsed ) ; 
line 65668: if ( zName == 0 ) zName = "" ; 
line 65669: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 65670: pDb = & db -> aDb [ i ] ; 
line 65671: if ( pDb -> pBt == 0 ) continue ; 
line 65672: if ( sqlite3StrICmp ( pDb -> zName , zName ) == 0 ) break ; 
line 65673: } 
line 65675: if ( i >= db -> nDb ) { 
line 65676: sqlite3_snprintf ( sizeof ( zErr ) , zErr , "no such database: %s" , zName ) ; 
line 65677: goto detach_error ; 
line 65678: } 
line 65679: if ( i < 2 ) { 
line 65680: sqlite3_snprintf ( sizeof ( zErr ) , zErr , "cannot detach database %s" , zName ) ; 
line 65681: goto detach_error ; 
line 65682: } 
line 65683: if ( ! db -> autoCommit ) { 
line 65684: sqlite3_snprintf ( sizeof ( zErr ) , zErr , 
line 65685: "cannot DETACH database within transaction" ) ; 
line 65686: goto detach_error ; 
line 65687: } 
line 65688: if ( sqlite3BtreeIsInReadTrans ( pDb -> pBt ) || sqlite3BtreeIsInBackup ( pDb -> pBt ) ) { 
line 65689: sqlite3_snprintf ( sizeof ( zErr ) , zErr , "database %s is locked" , zName ) ; 
line 65690: goto detach_error ; 
line 65691: } 
line 65693: sqlite3BtreeClose ( pDb -> pBt ) ; 
line 65694: pDb -> pBt = 0 ; 
line 65695: pDb -> pSchema = 0 ; 
line 65696: sqlite3ResetInternalSchema ( db , 0 ) ; 
line 65697: return ; 
line 65699: detach_error : 
line 65700: sqlite3_result_error ( context , zErr , - 1 ) ; 
line 65701: } 
line 65707: static void codeAttach ( 
line 65708: Parse * pParse , 
line 65709: int type , 
line 65710: FuncDef * pFunc , 
line 65711: Expr * pAuthArg , 
line 65712: Expr * pFilename , 
line 65713: Expr * pDbname , 
line 65714: Expr * pKey 
line 65715: ) { 
line 65716: int rc ; 
line 65717: NameContext sName ; 
line 65718: Vdbe * v ; 
line 65719: sqlite3 * db = pParse -> db ; 
line 65720: int regArgs ; 
line 65722: memset ( & sName , 0 , sizeof ( NameContext ) ) ; 
line 65723: sName . pParse = pParse ; 
line 65725: if ( 
line 65726: SQLITE_OK != ( rc = resolveAttachExpr ( & sName , pFilename ) ) || 
line 65727: SQLITE_OK != ( rc = resolveAttachExpr ( & sName , pDbname ) ) || 
line 65728: SQLITE_OK != ( rc = resolveAttachExpr ( & sName , pKey ) ) 
line 65729: ) { 
line 65730: pParse -> nErr ++ ; 
line 65731: goto attach_end ; 
line 65732: } 
line 65734: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 65735: if ( pAuthArg ) { 
line 65736: char * zAuthArg = pAuthArg -> u . zToken ; 
line 65737: if ( NEVER ( zAuthArg == 0 ) ) { 
line 65738: goto attach_end ; 
line 65739: } 
line 65740: rc = sqlite3AuthCheck ( pParse , type , zAuthArg , 0 , 0 ) ; 
line 65741: if ( rc != SQLITE_OK ) { 
line 65742: goto attach_end ; 
line 65743: } 
line 65744: } 
line 65745: # endif 
line 65748: v = sqlite3GetVdbe ( pParse ) ; 
line 65749: regArgs = sqlite3GetTempRange ( pParse , 4 ) ; 
line 65750: sqlite3ExprCode ( pParse , pFilename , regArgs ) ; 
line 65751: sqlite3ExprCode ( pParse , pDbname , regArgs + 1 ) ; 
line 65752: sqlite3ExprCode ( pParse , pKey , regArgs + 2 ) ; 
line 65754: assert ( v || db -> mallocFailed ) ; 
line 65755: if ( v ) { 
line 65756: sqlite3VdbeAddOp3 ( v , OP_Function , 0 , regArgs + 3 - pFunc -> nArg , regArgs + 3 ) ; 
line 65757: assert ( pFunc -> nArg == - 1 || ( pFunc -> nArg & 0xff ) == pFunc -> nArg ) ; 
line 65758: sqlite3VdbeChangeP5 ( v , ( u8 ) ( pFunc -> nArg ) ) ; 
line 65759: sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pFunc , P4_FUNCDEF ) ; 
line 65765: sqlite3VdbeAddOp1 ( v , OP_Expire , ( type == SQLITE_ATTACH ) ) ; 
line 65766: } 
line 65768: attach_end : 
line 65769: sqlite3ExprDelete ( db , pFilename ) ; 
line 65770: sqlite3ExprDelete ( db , pDbname ) ; 
line 65771: sqlite3ExprDelete ( db , pKey ) ; 
line 65772: } 
line 65779: SQLITE_PRIVATE void sqlite3Detach ( Parse * pParse , Expr * pDbname ) { 
line 65780: static FuncDef detach_func = { 
line 65781: 1 , 
line 65782: SQLITE_UTF8 , 
line 65783: 0 , 
line 65784: 0 , 
line 65785: 0 , 
line 65786: detachFunc , 
line 65787: 0 , 
line 65788: 0 , 
line 65789: "sqlite_detach" , 
line 65790: 0 
line 65791: } ; 
line 65792: codeAttach ( pParse , SQLITE_DETACH , & detach_func , pDbname , 0 , 0 , pDbname ) ; 
line 65793: } 
line 65800: SQLITE_PRIVATE void sqlite3Attach ( Parse * pParse , Expr * p , Expr * pDbname , Expr * pKey ) { 
line 65801: static FuncDef attach_func = { 
line 65802: 3 , 
line 65803: SQLITE_UTF8 , 
line 65804: 0 , 
line 65805: 0 , 
line 65806: 0 , 
line 65807: attachFunc , 
line 65808: 0 , 
line 65809: 0 , 
line 65810: "sqlite_attach" , 
line 65811: 0 
line 65812: } ; 
line 65813: codeAttach ( pParse , SQLITE_ATTACH , & attach_func , p , p , pDbname , pKey ) ; 
line 65814: } 
line 65815: # endif 
line 65824: SQLITE_PRIVATE int sqlite3FixInit ( 
line 65825: DbFixer * pFix , 
line 65826: Parse * pParse , 
line 65827: int iDb , 
line 65828: const char * zType , 
line 65829: const Token * pName 
line 65830: ) { 
line 65831: sqlite3 * db ; 
line 65833: if ( NEVER ( iDb < 0 ) || iDb == 1 ) return 0 ; 
line 65834: db = pParse -> db ; 
line 65835: assert ( db -> nDb > iDb ) ; 
line 65836: pFix -> pParse = pParse ; 
line 65837: pFix -> zDb = db -> aDb [ iDb ] . zName ; 
line 65838: pFix -> zType = zType ; 
line 65839: pFix -> pName = pName ; 
line 65840: return 1 ; 
line 65841: } 
line 65857: SQLITE_PRIVATE int sqlite3FixSrcList ( 
line 65858: DbFixer * pFix , 
line 65859: SrcList * pList 
line 65860: ) { 
line 65861: int i ; 
line 65862: const char * zDb ; 
line 65863: struct SrcList_item * pItem ; 
line 65865: if ( NEVER ( pList == 0 ) ) return 0 ; 
line 65866: zDb = pFix -> zDb ; 
line 65867: for ( i = 0 , pItem = pList -> a ; i < pList -> nSrc ; i ++ , pItem ++ ) { 
line 65868: if ( pItem -> zDatabase == 0 ) { 
line 65869: pItem -> zDatabase = sqlite3DbStrDup ( pFix -> pParse -> db , zDb ) ; 
line 65870: } else if ( sqlite3StrICmp ( pItem -> zDatabase , zDb ) != 0 ) { 
line 65871: sqlite3ErrorMsg ( pFix -> pParse , 
line 65872: "%s %T cannot reference objects in database %s" , 
line 65873: pFix -> zType , pFix -> pName , pItem -> zDatabase ) ; 
line 65874: return 1 ; 
line 65875: } 
line 65876: # if ! defined ( SQLITE_OMIT_VIEW ) || ! defined ( SQLITE_OMIT_TRIGGER ) 
line 65877: if ( sqlite3FixSelect ( pFix , pItem -> pSelect ) ) return 1 ; 
line 65878: if ( sqlite3FixExpr ( pFix , pItem -> pOn ) ) return 1 ; 
line 65879: # endif 
line 65880: } 
line 65881: return 0 ; 
line 65882: } 
line 65883: # if ! defined ( SQLITE_OMIT_VIEW ) || ! defined ( SQLITE_OMIT_TRIGGER ) 
line 65884: SQLITE_PRIVATE int sqlite3FixSelect ( 
line 65885: DbFixer * pFix , 
line 65886: Select * pSelect 
line 65887: ) { 
line 65888: while ( pSelect ) { 
line 65889: if ( sqlite3FixExprList ( pFix , pSelect -> pEList ) ) { 
line 65890: return 1 ; 
line 65891: } 
line 65892: if ( sqlite3FixSrcList ( pFix , pSelect -> pSrc ) ) { 
line 65893: return 1 ; 
line 65894: } 
line 65895: if ( sqlite3FixExpr ( pFix , pSelect -> pWhere ) ) { 
line 65896: return 1 ; 
line 65897: } 
line 65898: if ( sqlite3FixExpr ( pFix , pSelect -> pHaving ) ) { 
line 65899: return 1 ; 
line 65900: } 
line 65901: pSelect = pSelect -> pPrior ; 
line 65902: } 
line 65903: return 0 ; 
line 65904: } 
line 65905: SQLITE_PRIVATE int sqlite3FixExpr ( 
line 65906: DbFixer * pFix , 
line 65907: Expr * pExpr 
line 65908: ) { 
line 65909: while ( pExpr ) { 
line 65910: if ( ExprHasAnyProperty ( pExpr , EP_TokenOnly ) ) break ; 
line 65911: if ( ExprHasProperty ( pExpr , EP_xIsSelect ) ) { 
line 65912: if ( sqlite3FixSelect ( pFix , pExpr -> x . pSelect ) ) return 1 ; 
line 65913: } else { 
line 65914: if ( sqlite3FixExprList ( pFix , pExpr -> x . pList ) ) return 1 ; 
line 65915: } 
line 65916: if ( sqlite3FixExpr ( pFix , pExpr -> pRight ) ) { 
line 65917: return 1 ; 
line 65918: } 
line 65919: pExpr = pExpr -> pLeft ; 
line 65920: } 
line 65921: return 0 ; 
line 65922: } 
line 65923: SQLITE_PRIVATE int sqlite3FixExprList ( 
line 65924: DbFixer * pFix , 
line 65925: ExprList * pList 
line 65926: ) { 
line 65927: int i ; 
line 65928: struct ExprList_item * pItem ; 
line 65929: if ( pList == 0 ) return 0 ; 
line 65930: for ( i = 0 , pItem = pList -> a ; i < pList -> nExpr ; i ++ , pItem ++ ) { 
line 65931: if ( sqlite3FixExpr ( pFix , pItem -> pExpr ) ) { 
line 65932: return 1 ; 
line 65933: } 
line 65934: } 
line 65935: return 0 ; 
line 65936: } 
line 65937: # endif 
line 65939: # ifndef SQLITE_OMIT_TRIGGER 
line 65940: SQLITE_PRIVATE int sqlite3FixTriggerStep ( 
line 65941: DbFixer * pFix , 
line 65942: TriggerStep * pStep 
line 65943: ) { 
line 65944: while ( pStep ) { 
line 65945: if ( sqlite3FixSelect ( pFix , pStep -> pSelect ) ) { 
line 65946: return 1 ; 
line 65947: } 
line 65948: if ( sqlite3FixExpr ( pFix , pStep -> pWhere ) ) { 
line 65949: return 1 ; 
line 65950: } 
line 65951: if ( sqlite3FixExprList ( pFix , pStep -> pExprList ) ) { 
line 65952: return 1 ; 
line 65953: } 
line 65954: pStep = pStep -> pNext ; 
line 65955: } 
line 65956: return 0 ; 
line 65957: } 
line 65958: # endif 
line 65983: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 66030: SQLITE_API int sqlite3_set_authorizer ( 
line 66031: sqlite3 * db , 
line 66032: int ( * xAuth ) ( void * , int , const char * , const char * , const char * , const char * ) , 
line 66033: void * pArg 
line 66034: ) { 
line 66035: sqlite3_mutex_enter ( db -> mutex ) ; 
line 66036: db -> xAuth = xAuth ; 
line 66037: db -> pAuthArg = pArg ; 
line 66038: sqlite3ExpirePreparedStatements ( db ) ; 
line 66039: sqlite3_mutex_leave ( db -> mutex ) ; 
line 66040: return SQLITE_OK ; 
line 66041: } 
line 66047: static void sqliteAuthBadReturnCode ( Parse * pParse ) { 
line 66048: sqlite3ErrorMsg ( pParse , "authorizer malfunction" ) ; 
line 66049: pParse -> rc = SQLITE_ERROR ; 
line 66050: } 
line 66061: SQLITE_PRIVATE int sqlite3AuthReadCol ( 
line 66062: Parse * pParse , 
line 66063: const char * zTab , 
line 66064: const char * zCol , 
line 66065: int iDb 
line 66066: ) { 
line 66067: sqlite3 * db = pParse -> db ; 
line 66068: char * zDb = db -> aDb [ iDb ] . zName ; 
line 66069: int rc ; 
line 66071: rc = db -> xAuth ( db -> pAuthArg , SQLITE_READ , zTab , zCol , zDb , pParse -> zAuthContext ) ; 
line 66072: if ( rc == SQLITE_DENY ) { 
line 66073: if ( db -> nDb > 2 || iDb != 0 ) { 
line 66074: sqlite3ErrorMsg ( pParse , "access to %s.%s.%s is prohibited" , zDb , zTab , zCol ) ; 
line 66075: } else { 
line 66076: sqlite3ErrorMsg ( pParse , "access to %s.%s is prohibited" , zTab , zCol ) ; 
line 66077: } 
line 66078: pParse -> rc = SQLITE_AUTH ; 
line 66079: } else if ( rc != SQLITE_IGNORE && rc != SQLITE_OK ) { 
line 66080: sqliteAuthBadReturnCode ( pParse ) ; 
line 66081: } 
line 66082: return rc ; 
line 66083: } 
line 66094: SQLITE_PRIVATE void sqlite3AuthRead ( 
line 66095: Parse * pParse , 
line 66096: Expr * pExpr , 
line 66097: Schema * pSchema , 
line 66098: SrcList * pTabList 
line 66099: ) { 
line 66100: sqlite3 * db = pParse -> db ; 
line 66101: Table * pTab = 0 ; 
line 66102: const char * zCol ; 
line 66103: int iSrc ; 
line 66104: int iDb ; 
line 66105: int iCol ; 
line 66107: if ( db -> xAuth == 0 ) return ; 
line 66108: iDb = sqlite3SchemaToIndex ( pParse -> db , pSchema ) ; 
line 66109: if ( iDb < 0 ) { 
line 66112: return ; 
line 66113: } 
line 66115: assert ( pExpr -> op == TK_COLUMN || pExpr -> op == TK_TRIGGER ) ; 
line 66116: if ( pExpr -> op == TK_TRIGGER ) { 
line 66117: pTab = pParse -> pTriggerTab ; 
line 66118: } else { 
line 66119: assert ( pTabList ) ; 
line 66120: for ( iSrc = 0 ; ALWAYS ( iSrc < pTabList -> nSrc ) ; iSrc ++ ) { 
line 66121: if ( pExpr -> iTable == pTabList -> a [ iSrc ] . iCursor ) { 
line 66122: pTab = pTabList -> a [ iSrc ] . pTab ; 
line 66123: break ; 
line 66124: } 
line 66125: } 
line 66126: } 
line 66127: iCol = pExpr -> iColumn ; 
line 66128: if ( NEVER ( pTab == 0 ) ) return ; 
line 66130: if ( iCol >= 0 ) { 
line 66131: assert ( iCol < pTab -> nCol ) ; 
line 66132: zCol = pTab -> aCol [ iCol ] . zName ; 
line 66133: } else if ( pTab -> iPKey >= 0 ) { 
line 66134: assert ( pTab -> iPKey < pTab -> nCol ) ; 
line 66135: zCol = pTab -> aCol [ pTab -> iPKey ] . zName ; 
line 66136: } else { 
line 66137: zCol = "ROWID" ; 
line 66138: } 
line 66139: assert ( iDb >= 0 && iDb < db -> nDb ) ; 
line 66140: if ( SQLITE_IGNORE == sqlite3AuthReadCol ( pParse , pTab -> zName , zCol , iDb ) ) { 
line 66141: pExpr -> op = TK_NULL ; 
line 66142: } 
line 66143: } 
line 66151: SQLITE_PRIVATE int sqlite3AuthCheck ( 
line 66152: Parse * pParse , 
line 66153: int code , 
line 66154: const char * zArg1 , 
line 66155: const char * zArg2 , 
line 66156: const char * zArg3 
line 66157: ) { 
line 66158: sqlite3 * db = pParse -> db ; 
line 66159: int rc ; 
line 66164: if ( db -> init . busy || IN_DECLARE_VTAB ) { 
line 66165: return SQLITE_OK ; 
line 66166: } 
line 66168: if ( db -> xAuth == 0 ) { 
line 66169: return SQLITE_OK ; 
line 66170: } 
line 66171: rc = db -> xAuth ( db -> pAuthArg , code , zArg1 , zArg2 , zArg3 , pParse -> zAuthContext ) ; 
line 66172: if ( rc == SQLITE_DENY ) { 
line 66173: sqlite3ErrorMsg ( pParse , "not authorized" ) ; 
line 66174: pParse -> rc = SQLITE_AUTH ; 
line 66175: } else if ( rc != SQLITE_OK && rc != SQLITE_IGNORE ) { 
line 66176: rc = SQLITE_DENY ; 
line 66177: sqliteAuthBadReturnCode ( pParse ) ; 
line 66178: } 
line 66179: return rc ; 
line 66180: } 
line 66187: SQLITE_PRIVATE void sqlite3AuthContextPush ( 
line 66188: Parse * pParse , 
line 66189: AuthContext * pContext , 
line 66190: const char * zContext 
line 66191: ) { 
line 66192: assert ( pParse ) ; 
line 66193: pContext -> pParse = pParse ; 
line 66194: pContext -> zAuthContext = pParse -> zAuthContext ; 
line 66195: pParse -> zAuthContext = zContext ; 
line 66196: } 
line 66202: SQLITE_PRIVATE void sqlite3AuthContextPop ( AuthContext * pContext ) { 
line 66203: if ( pContext -> pParse ) { 
line 66204: pContext -> pParse -> zAuthContext = pContext -> zAuthContext ; 
line 66205: pContext -> pParse = 0 ; 
line 66206: } 
line 66207: } 
line 66209: # endif 
line 66242: SQLITE_PRIVATE void sqlite3BeginParse ( Parse * pParse , int explainFlag ) { 
line 66243: pParse -> explain = ( u8 ) explainFlag ; 
line 66244: pParse -> nVar = 0 ; 
line 66245: } 
line 66247: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 66252: struct TableLock { 
line 66253: int iDb ; 
line 66254: int iTab ; 
line 66255: u8 isWriteLock ; 
line 66256: const char * zName ; 
line 66257: } ; 
line 66269: SQLITE_PRIVATE void sqlite3TableLock ( 
line 66270: Parse * pParse , 
line 66271: int iDb , 
line 66272: int iTab , 
line 66273: u8 isWriteLock , 
line 66274: const char * zName 
line 66275: ) { 
line 66276: Parse * pToplevel = sqlite3ParseToplevel ( pParse ) ; 
line 66277: int i ; 
line 66278: int nBytes ; 
line 66279: TableLock * p ; 
line 66280: assert ( iDb >= 0 ) ; 
line 66282: for ( i = 0 ; i < pToplevel -> nTableLock ; i ++ ) { 
line 66283: p = & pToplevel -> aTableLock [ i ] ; 
line 66284: if ( p -> iDb == iDb && p -> iTab == iTab ) { 
line 66285: p -> isWriteLock = ( p -> isWriteLock || isWriteLock ) ; 
line 66286: return ; 
line 66287: } 
line 66288: } 
line 66290: nBytes = sizeof ( TableLock ) * ( pToplevel -> nTableLock + 1 ) ; 
line 66291: pToplevel -> aTableLock = 
line 66292: sqlite3DbReallocOrFree ( pToplevel -> db , pToplevel -> aTableLock , nBytes ) ; 
line 66293: if ( pToplevel -> aTableLock ) { 
line 66294: p = & pToplevel -> aTableLock [ pToplevel -> nTableLock ++ ] ; 
line 66295: p -> iDb = iDb ; 
line 66296: p -> iTab = iTab ; 
line 66297: p -> isWriteLock = isWriteLock ; 
line 66298: p -> zName = zName ; 
line 66299: } else { 
line 66300: pToplevel -> nTableLock = 0 ; 
line 66301: pToplevel -> db -> mallocFailed = 1 ; 
line 66302: } 
line 66303: } 
line 66309: static void codeTableLocks ( Parse * pParse ) { 
line 66310: int i ; 
line 66311: Vdbe * pVdbe ; 
line 66313: pVdbe = sqlite3GetVdbe ( pParse ) ; 
line 66314: assert ( pVdbe != 0 ) ; 
line 66316: for ( i = 0 ; i < pParse -> nTableLock ; i ++ ) { 
line 66317: TableLock * p = & pParse -> aTableLock [ i ] ; 
line 66318: int p1 = p -> iDb ; 
line 66319: sqlite3VdbeAddOp4 ( pVdbe , OP_TableLock , p1 , p -> iTab , p -> isWriteLock , 
line 66320: p -> zName , P4_STATIC ) ; 
line 66321: } 
line 66322: } 
line 66323: # else 
line 66324: # define codeTableLocks ( x ) 
line 66325: # endif 
line 66337: SQLITE_PRIVATE void sqlite3FinishCoding ( Parse * pParse ) { 
line 66338: sqlite3 * db ; 
line 66339: Vdbe * v ; 
line 66341: db = pParse -> db ; 
line 66342: if ( db -> mallocFailed ) return ; 
line 66343: if ( pParse -> nested ) return ; 
line 66344: if ( pParse -> nErr ) return ; 
line 66349: v = sqlite3GetVdbe ( pParse ) ; 
line 66350: assert ( ! pParse -> isMultiWrite 
line 66351: || sqlite3VdbeAssertMayAbort ( v , pParse -> mayAbort ) ) ; 
line 66352: if ( v ) { 
line 66353: sqlite3VdbeAddOp0 ( v , OP_Halt ) ; 
line 66361: if ( pParse -> cookieGoto > 0 ) { 
line 66362: u32 mask ; 
line 66363: int iDb ; 
line 66364: sqlite3VdbeJumpHere ( v , pParse -> cookieGoto - 1 ) ; 
line 66365: for ( iDb = 0 , mask = 1 ; iDb < db -> nDb ; mask <<= 1 , iDb ++ ) { 
line 66366: if ( ( mask & pParse -> cookieMask ) == 0 ) continue ; 
line 66367: sqlite3VdbeUsesBtree ( v , iDb ) ; 
line 66368: sqlite3VdbeAddOp2 ( v , OP_Transaction , iDb , ( mask & pParse -> writeMask ) != 0 ) ; 
line 66369: if ( db -> init . busy == 0 ) { 
line 66370: sqlite3VdbeAddOp2 ( v , OP_VerifyCookie , iDb , pParse -> cookieValue [ iDb ] ) ; 
line 66371: } 
line 66372: } 
line 66373: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 66374: { 
line 66375: int i ; 
line 66376: for ( i = 0 ; i < pParse -> nVtabLock ; i ++ ) { 
line 66377: char * vtab = ( char * ) sqlite3GetVTable ( db , pParse -> apVtabLock [ i ] ) ; 
line 66378: sqlite3VdbeAddOp4 ( v , OP_VBegin , 0 , 0 , 0 , vtab , P4_VTAB ) ; 
line 66379: } 
line 66380: pParse -> nVtabLock = 0 ; 
line 66381: } 
line 66382: # endif 
line 66388: codeTableLocks ( pParse ) ; 
line 66392: sqlite3AutoincrementBegin ( pParse ) ; 
line 66395: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , pParse -> cookieGoto ) ; 
line 66396: } 
line 66397: } 
line 66402: if ( v && ALWAYS ( pParse -> nErr == 0 ) && ! db -> mallocFailed ) { 
line 66403: # ifdef SQLITE_DEBUG 
line 66404: FILE * trace = ( db -> flags & SQLITE_VdbeTrace ) != 0 ? stdout : 0 ; 
line 66405: sqlite3VdbeTrace ( v , trace ) ; 
line 66406: # endif 
line 66407: assert ( pParse -> iCacheLevel == 0 ) ; 
line 66410: if ( pParse -> pAinc != 0 && pParse -> nTab == 0 ) pParse -> nTab = 1 ; 
line 66411: sqlite3VdbeMakeReady ( v , pParse -> nVar , pParse -> nMem , 
line 66412: pParse -> nTab , pParse -> nMaxArg , pParse -> explain , 
line 66413: pParse -> isMultiWrite && pParse -> mayAbort ) ; 
line 66414: pParse -> rc = SQLITE_DONE ; 
line 66415: pParse -> colNamesSet = 0 ; 
line 66416: } else if ( pParse -> rc == SQLITE_OK ) { 
line 66417: pParse -> rc = SQLITE_ERROR ; 
line 66418: } 
line 66419: pParse -> nTab = 0 ; 
line 66420: pParse -> nMem = 0 ; 
line 66421: pParse -> nSet = 0 ; 
line 66422: pParse -> nVar = 0 ; 
line 66423: pParse -> cookieMask = 0 ; 
line 66424: pParse -> cookieGoto = 0 ; 
line 66425: } 
line 66439: SQLITE_PRIVATE void sqlite3NestedParse ( Parse * pParse , const char * zFormat , ... ) { 
line 66440: va_list ap ; 
line 66441: char * zSql ; 
line 66442: char * zErrMsg = 0 ; 
line 66443: sqlite3 * db = pParse -> db ; 
line 66444: # define SAVE_SZ ( sizeof ( Parse ) - offsetof ( Parse , nVar ) ) 
line 66445: char saveBuf [ SAVE_SZ ] ; 
line 66447: if ( pParse -> nErr ) return ; 
line 66448: assert ( pParse -> nested < 10 ) ; 
line 66449: va_start ( ap , zFormat ) ; 
line 66450: zSql = sqlite3VMPrintf ( db , zFormat , ap ) ; 
line 66451: va_end ( ap ) ; 
line 66452: if ( zSql == 0 ) { 
line 66453: return ; 
line 66454: } 
line 66455: pParse -> nested ++ ; 
line 66456: memcpy ( saveBuf , & pParse -> nVar , SAVE_SZ ) ; 
line 66457: memset ( & pParse -> nVar , 0 , SAVE_SZ ) ; 
line 66458: sqlite3RunParser ( pParse , zSql , & zErrMsg ) ; 
line 66459: sqlite3DbFree ( db , zErrMsg ) ; 
line 66460: sqlite3DbFree ( db , zSql ) ; 
line 66461: memcpy ( & pParse -> nVar , saveBuf , SAVE_SZ ) ; 
line 66462: pParse -> nested -- ; 
line 66463: } 
line 66477: SQLITE_PRIVATE Table * sqlite3FindTable ( sqlite3 * db , const char * zName , const char * zDatabase ) { 
line 66478: Table * p = 0 ; 
line 66479: int i ; 
line 66480: int nName ; 
line 66481: assert ( zName != 0 ) ; 
line 66482: nName = sqlite3Strlen30 ( zName ) ; 
line 66483: for ( i = OMIT_TEMPDB ; i < db -> nDb ; i ++ ) { 
line 66484: int j = ( i < 2 ) ? i ^ 1 : i ; 
line 66485: if ( zDatabase != 0 && sqlite3StrICmp ( zDatabase , db -> aDb [ j ] . zName ) ) continue ; 
line 66486: p = sqlite3HashFind ( & db -> aDb [ j ] . pSchema -> tblHash , zName , nName ) ; 
line 66487: if ( p ) break ; 
line 66488: } 
line 66489: return p ; 
line 66490: } 
line 66502: SQLITE_PRIVATE Table * sqlite3LocateTable ( 
line 66503: Parse * pParse , 
line 66504: int isView , 
line 66505: const char * zName , 
line 66506: const char * zDbase 
line 66507: ) { 
line 66508: Table * p ; 
line 66512: if ( SQLITE_OK != sqlite3ReadSchema ( pParse ) ) { 
line 66513: return 0 ; 
line 66514: } 
line 66516: p = sqlite3FindTable ( pParse -> db , zName , zDbase ) ; 
line 66517: if ( p == 0 ) { 
line 66518: const char * zMsg = isView ? "no such view" : "no such table" ; 
line 66519: if ( zDbase ) { 
line 66520: sqlite3ErrorMsg ( pParse , "%s: %s.%s" , zMsg , zDbase , zName ) ; 
line 66521: } else { 
line 66522: sqlite3ErrorMsg ( pParse , "%s: %s" , zMsg , zName ) ; 
line 66523: } 
line 66524: pParse -> checkSchema = 1 ; 
line 66525: } 
line 66526: return p ; 
line 66527: } 
line 66541: SQLITE_PRIVATE Index * sqlite3FindIndex ( sqlite3 * db , const char * zName , const char * zDb ) { 
line 66542: Index * p = 0 ; 
line 66543: int i ; 
line 66544: int nName = sqlite3Strlen30 ( zName ) ; 
line 66545: for ( i = OMIT_TEMPDB ; i < db -> nDb ; i ++ ) { 
line 66546: int j = ( i < 2 ) ? i ^ 1 : i ; 
line 66547: Schema * pSchema = db -> aDb [ j ] . pSchema ; 
line 66548: assert ( pSchema ) ; 
line 66549: if ( zDb && sqlite3StrICmp ( zDb , db -> aDb [ j ] . zName ) ) continue ; 
line 66550: p = sqlite3HashFind ( & pSchema -> idxHash , zName , nName ) ; 
line 66551: if ( p ) break ; 
line 66552: } 
line 66553: return p ; 
line 66554: } 
line 66559: static void freeIndex ( Index * p ) { 
line 66560: sqlite3 * db = p -> pTable -> dbMem ; 
line 66561: # ifndef SQLITE_OMIT_ANALYZE 
line 66562: sqlite3DeleteIndexSamples ( p ) ; 
line 66563: # endif 
line 66564: sqlite3DbFree ( db , p -> zColAff ) ; 
line 66565: sqlite3DbFree ( db , p ) ; 
line 66566: } 
line 66576: static void sqlite3DeleteIndex ( Index * p ) { 
line 66577: Index * pOld ; 
line 66578: const char * zName = p -> zName ; 
line 66580: pOld = sqlite3HashInsert ( & p -> pSchema -> idxHash , zName , 
line 66581: sqlite3Strlen30 ( zName ) , 0 ) ; 
line 66582: assert ( pOld == 0 || pOld == p ) ; 
line 66583: freeIndex ( p ) ; 
line 66584: } 
line 66592: SQLITE_PRIVATE void sqlite3UnlinkAndDeleteIndex ( sqlite3 * db , int iDb , const char * zIdxName ) { 
line 66593: Index * pIndex ; 
line 66594: int len ; 
line 66595: Hash * pHash = & db -> aDb [ iDb ] . pSchema -> idxHash ; 
line 66597: len = sqlite3Strlen30 ( zIdxName ) ; 
line 66598: pIndex = sqlite3HashInsert ( pHash , zIdxName , len , 0 ) ; 
line 66599: if ( pIndex ) { 
line 66600: if ( pIndex -> pTable -> pIndex == pIndex ) { 
line 66601: pIndex -> pTable -> pIndex = pIndex -> pNext ; 
line 66602: } else { 
line 66603: Index * p ; 
line 66606: p = pIndex -> pTable -> pIndex ; 
line 66607: while ( ALWAYS ( p ) && p -> pNext != pIndex ) { p = p -> pNext ; } 
line 66608: if ( ALWAYS ( p && p -> pNext == pIndex ) ) { 
line 66609: p -> pNext = pIndex -> pNext ; 
line 66610: } 
line 66611: } 
line 66612: freeIndex ( pIndex ) ; 
line 66613: } 
line 66614: db -> flags |= SQLITE_InternChanges ; 
line 66615: } 
line 66628: SQLITE_PRIVATE void sqlite3ResetInternalSchema ( sqlite3 * db , int iDb ) { 
line 66629: int i , j ; 
line 66630: assert ( iDb >= 0 && iDb < db -> nDb ) ; 
line 66632: if ( iDb == 0 ) { 
line 66633: sqlite3BtreeEnterAll ( db ) ; 
line 66634: } 
line 66635: for ( i = iDb ; i < db -> nDb ; i ++ ) { 
line 66636: Db * pDb = & db -> aDb [ i ] ; 
line 66637: if ( pDb -> pSchema ) { 
line 66638: assert ( i == 1 || ( pDb -> pBt && sqlite3BtreeHoldsMutex ( pDb -> pBt ) ) ) ; 
line 66639: sqlite3SchemaFree ( pDb -> pSchema ) ; 
line 66640: } 
line 66641: if ( iDb > 0 ) return ; 
line 66642: } 
line 66643: assert ( iDb == 0 ) ; 
line 66644: db -> flags &= ~ SQLITE_InternChanges ; 
line 66645: sqlite3VtabUnlockList ( db ) ; 
line 66646: sqlite3BtreeLeaveAll ( db ) ; 
line 66654: for ( i = j = 2 ; i < db -> nDb ; i ++ ) { 
line 66655: struct Db * pDb = & db -> aDb [ i ] ; 
line 66656: if ( pDb -> pBt == 0 ) { 
line 66657: sqlite3DbFree ( db , pDb -> zName ) ; 
line 66658: pDb -> zName = 0 ; 
line 66659: continue ; 
line 66660: } 
line 66661: if ( j < i ) { 
line 66662: db -> aDb [ j ] = db -> aDb [ i ] ; 
line 66663: } 
line 66664: j ++ ; 
line 66665: } 
line 66666: memset ( & db -> aDb [ j ] , 0 , ( db -> nDb - j ) * sizeof ( db -> aDb [ j ] ) ) ; 
line 66667: db -> nDb = j ; 
line 66668: if ( db -> nDb <= 2 && db -> aDb != db -> aDbStatic ) { 
line 66669: memcpy ( db -> aDbStatic , db -> aDb , 2 * sizeof ( db -> aDb [ 0 ] ) ) ; 
line 66670: sqlite3DbFree ( db , db -> aDb ) ; 
line 66671: db -> aDb = db -> aDbStatic ; 
line 66672: } 
line 66673: } 
line 66678: SQLITE_PRIVATE void sqlite3CommitInternalChanges ( sqlite3 * db ) { 
line 66679: db -> flags &= ~ SQLITE_InternChanges ; 
line 66680: } 
line 66685: static void sqliteResetColumnNames ( Table * pTable ) { 
line 66686: int i ; 
line 66687: Column * pCol ; 
line 66688: sqlite3 * db = pTable -> dbMem ; 
line 66689: testcase ( db == 0 ) ; 
line 66690: assert ( pTable != 0 ) ; 
line 66691: if ( ( pCol = pTable -> aCol ) != 0 ) { 
line 66692: for ( i = 0 ; i < pTable -> nCol ; i ++ , pCol ++ ) { 
line 66693: sqlite3DbFree ( db , pCol -> zName ) ; 
line 66694: sqlite3ExprDelete ( db , pCol -> pDflt ) ; 
line 66695: sqlite3DbFree ( db , pCol -> zDflt ) ; 
line 66696: sqlite3DbFree ( db , pCol -> zType ) ; 
line 66697: sqlite3DbFree ( db , pCol -> zColl ) ; 
line 66698: } 
line 66699: sqlite3DbFree ( db , pTable -> aCol ) ; 
line 66700: } 
line 66701: pTable -> aCol = 0 ; 
line 66702: pTable -> nCol = 0 ; 
line 66703: } 
line 66714: SQLITE_PRIVATE void sqlite3DeleteTable ( Table * pTable ) { 
line 66715: Index * pIndex , * pNext ; 
line 66716: sqlite3 * db ; 
line 66718: if ( pTable == 0 ) return ; 
line 66719: db = pTable -> dbMem ; 
line 66720: testcase ( db == 0 ) ; 
line 66723: pTable -> nRef -- ; 
line 66724: if ( pTable -> nRef > 0 ) { 
line 66725: return ; 
line 66726: } 
line 66727: assert ( pTable -> nRef == 0 ) ; 
line 66731: for ( pIndex = pTable -> pIndex ; pIndex ; pIndex = pNext ) { 
line 66732: pNext = pIndex -> pNext ; 
line 66733: assert ( pIndex -> pSchema == pTable -> pSchema ) ; 
line 66734: sqlite3DeleteIndex ( pIndex ) ; 
line 66735: } 
line 66738: sqlite3FkDelete ( pTable ) ; 
line 66742: sqliteResetColumnNames ( pTable ) ; 
line 66743: sqlite3DbFree ( db , pTable -> zName ) ; 
line 66744: sqlite3DbFree ( db , pTable -> zColAff ) ; 
line 66745: sqlite3SelectDelete ( db , pTable -> pSelect ) ; 
line 66746: # ifndef SQLITE_OMIT_CHECK 
line 66747: sqlite3ExprDelete ( db , pTable -> pCheck ) ; 
line 66748: # endif 
line 66749: sqlite3VtabClear ( pTable ) ; 
line 66750: sqlite3DbFree ( db , pTable ) ; 
line 66751: } 
line 66757: SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTable ( sqlite3 * db , int iDb , const char * zTabName ) { 
line 66758: Table * p ; 
line 66759: Db * pDb ; 
line 66761: assert ( db != 0 ) ; 
line 66762: assert ( iDb >= 0 && iDb < db -> nDb ) ; 
line 66763: assert ( zTabName ) ; 
line 66764: testcase ( zTabName [ 0 ] == 0 ) ; 
line 66765: pDb = & db -> aDb [ iDb ] ; 
line 66766: p = sqlite3HashInsert ( & pDb -> pSchema -> tblHash , zTabName , 
line 66767: sqlite3Strlen30 ( zTabName ) , 0 ) ; 
line 66768: sqlite3DeleteTable ( p ) ; 
line 66769: db -> flags |= SQLITE_InternChanges ; 
line 66770: } 
line 66785: SQLITE_PRIVATE char * sqlite3NameFromToken ( sqlite3 * db , Token * pName ) { 
line 66786: char * zName ; 
line 66787: if ( pName ) { 
line 66788: zName = sqlite3DbStrNDup ( db , ( char * ) pName -> z , pName -> n ) ; 
line 66789: sqlite3Dequote ( zName ) ; 
line 66790: } else { 
line 66791: zName = 0 ; 
line 66792: } 
line 66793: return zName ; 
line 66794: } 
line 66800: SQLITE_PRIVATE void sqlite3OpenMasterTable ( Parse * p , int iDb ) { 
line 66801: Vdbe * v = sqlite3GetVdbe ( p ) ; 
line 66802: sqlite3TableLock ( p , iDb , MASTER_ROOT , 1 , SCHEMA_TABLE ( iDb ) ) ; 
line 66803: sqlite3VdbeAddOp3 ( v , OP_OpenWrite , 0 , MASTER_ROOT , iDb ) ; 
line 66804: sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) 5 , P4_INT32 ) ; 
line 66805: if ( p -> nTab == 0 ) { 
line 66806: p -> nTab = 1 ; 
line 66807: } 
line 66808: } 
line 66816: SQLITE_PRIVATE int sqlite3FindDbName ( sqlite3 * db , const char * zName ) { 
line 66817: int i = - 1 ; 
line 66818: if ( zName ) { 
line 66819: Db * pDb ; 
line 66820: int n = sqlite3Strlen30 ( zName ) ; 
line 66821: for ( i = ( db -> nDb - 1 ) , pDb = & db -> aDb [ i ] ; i >= 0 ; i -- , pDb -- ) { 
line 66822: if ( ( ! OMIT_TEMPDB || i != 1 ) && n == sqlite3Strlen30 ( pDb -> zName ) && 
line 66823: 0 == sqlite3StrICmp ( pDb -> zName , zName ) ) { 
line 66824: break ; 
line 66825: } 
line 66826: } 
line 66827: } 
line 66828: return i ; 
line 66829: } 
line 66837: SQLITE_PRIVATE int sqlite3FindDb ( sqlite3 * db , Token * pName ) { 
line 66838: int i ; 
line 66839: char * zName ; 
line 66840: zName = sqlite3NameFromToken ( db , pName ) ; 
line 66841: i = sqlite3FindDbName ( db , zName ) ; 
line 66842: sqlite3DbFree ( db , zName ) ; 
line 66843: return i ; 
line 66844: } 
line 66862: SQLITE_PRIVATE int sqlite3TwoPartName ( 
line 66863: Parse * pParse , 
line 66864: Token * pName1 , 
line 66865: Token * pName2 , 
line 66866: Token * * pUnqual 
line 66867: ) { 
line 66868: int iDb ; 
line 66869: sqlite3 * db = pParse -> db ; 
line 66871: if ( ALWAYS ( pName2 != 0 ) && pName2 -> n > 0 ) { 
line 66872: if ( db -> init . busy ) { 
line 66873: sqlite3ErrorMsg ( pParse , "corrupt database" ) ; 
line 66874: pParse -> nErr ++ ; 
line 66875: return - 1 ; 
line 66876: } 
line 66877: * pUnqual = pName2 ; 
line 66878: iDb = sqlite3FindDb ( db , pName1 ) ; 
line 66879: if ( iDb < 0 ) { 
line 66880: sqlite3ErrorMsg ( pParse , "unknown database %T" , pName1 ) ; 
line 66881: pParse -> nErr ++ ; 
line 66882: return - 1 ; 
line 66883: } 
line 66884: } else { 
line 66885: assert ( db -> init . iDb == 0 || db -> init . busy ) ; 
line 66886: iDb = db -> init . iDb ; 
line 66887: * pUnqual = pName1 ; 
line 66888: } 
line 66889: return iDb ; 
line 66890: } 
line 66899: SQLITE_PRIVATE int sqlite3CheckObjectName ( Parse * pParse , const char * zName ) { 
line 66900: if ( ! pParse -> db -> init . busy && pParse -> nested == 0 
line 66901: && ( pParse -> db -> flags & SQLITE_WriteSchema ) == 0 
line 66902: && 0 == sqlite3StrNICmp ( zName , "sqlite_" , 7 ) ) { 
line 66903: sqlite3ErrorMsg ( pParse , "object name reserved for internal use: %s" , zName ) ; 
line 66904: return SQLITE_ERROR ; 
line 66905: } 
line 66906: return SQLITE_OK ; 
line 66907: } 
line 66925: SQLITE_PRIVATE void sqlite3StartTable ( 
line 66926: Parse * pParse , 
line 66927: Token * pName1 , 
line 66928: Token * pName2 , 
line 66929: int isTemp , 
line 66930: int isView , 
line 66931: int isVirtual , 
line 66932: int noErr 
line 66933: ) { 
line 66934: Table * pTable ; 
line 66935: char * zName = 0 ; 
line 66936: sqlite3 * db = pParse -> db ; 
line 66937: Vdbe * v ; 
line 66938: int iDb ; 
line 66939: Token * pName ; 
line 66958: iDb = sqlite3TwoPartName ( pParse , pName1 , pName2 , & pName ) ; 
line 66959: if ( iDb < 0 ) return ; 
line 66960: if ( ! OMIT_TEMPDB && isTemp && iDb > 1 ) { 
line 66962: sqlite3ErrorMsg ( pParse , "temporary table name must be unqualified" ) ; 
line 66963: return ; 
line 66964: } 
line 66965: if ( ! OMIT_TEMPDB && isTemp ) iDb = 1 ; 
line 66967: pParse -> sNameToken = * pName ; 
line 66968: zName = sqlite3NameFromToken ( db , pName ) ; 
line 66969: if ( zName == 0 ) return ; 
line 66970: if ( SQLITE_OK != sqlite3CheckObjectName ( pParse , zName ) ) { 
line 66971: goto begin_table_error ; 
line 66972: } 
line 66973: if ( db -> init . iDb == 1 ) isTemp = 1 ; 
line 66974: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 66975: assert ( ( isTemp & 1 ) == isTemp ) ; 
line 66976: { 
line 66977: int code ; 
line 66978: char * zDb = db -> aDb [ iDb ] . zName ; 
line 66979: if ( sqlite3AuthCheck ( pParse , SQLITE_INSERT , SCHEMA_TABLE ( isTemp ) , 0 , zDb ) ) { 
line 66980: goto begin_table_error ; 
line 66981: } 
line 66982: if ( isView ) { 
line 66983: if ( ! OMIT_TEMPDB && isTemp ) { 
line 66984: code = SQLITE_CREATE_TEMP_VIEW ; 
line 66985: } else { 
line 66986: code = SQLITE_CREATE_VIEW ; 
line 66987: } 
line 66988: } else { 
line 66989: if ( ! OMIT_TEMPDB && isTemp ) { 
line 66990: code = SQLITE_CREATE_TEMP_TABLE ; 
line 66991: } else { 
line 66992: code = SQLITE_CREATE_TABLE ; 
line 66993: } 
line 66994: } 
line 66995: if ( ! isVirtual && sqlite3AuthCheck ( pParse , code , zName , 0 , zDb ) ) { 
line 66996: goto begin_table_error ; 
line 66997: } 
line 66998: } 
line 66999: # endif 
line 67008: if ( ! IN_DECLARE_VTAB ) { 
line 67009: if ( SQLITE_OK != sqlite3ReadSchema ( pParse ) ) { 
line 67010: goto begin_table_error ; 
line 67011: } 
line 67012: pTable = sqlite3FindTable ( db , zName , db -> aDb [ iDb ] . zName ) ; 
line 67013: if ( pTable ) { 
line 67014: if ( ! noErr ) { 
line 67015: sqlite3ErrorMsg ( pParse , "table %T already exists" , pName ) ; 
line 67016: } 
line 67017: goto begin_table_error ; 
line 67018: } 
line 67019: if ( sqlite3FindIndex ( db , zName , 0 ) != 0 && ( iDb == 0 || ! db -> init . busy ) ) { 
line 67020: sqlite3ErrorMsg ( pParse , "there is already an index named %s" , zName ) ; 
line 67021: goto begin_table_error ; 
line 67022: } 
line 67023: } 
line 67025: pTable = sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; 
line 67026: if ( pTable == 0 ) { 
line 67027: db -> mallocFailed = 1 ; 
line 67028: pParse -> rc = SQLITE_NOMEM ; 
line 67029: pParse -> nErr ++ ; 
line 67030: goto begin_table_error ; 
line 67031: } 
line 67032: pTable -> zName = zName ; 
line 67033: pTable -> iPKey = - 1 ; 
line 67034: pTable -> pSchema = db -> aDb [ iDb ] . pSchema ; 
line 67035: pTable -> nRef = 1 ; 
line 67036: pTable -> dbMem = 0 ; 
line 67037: assert ( pParse -> pNewTable == 0 ) ; 
line 67038: pParse -> pNewTable = pTable ; 
line 67044: # ifndef SQLITE_OMIT_AUTOINCREMENT 
line 67045: if ( ! pParse -> nested && strcmp ( zName , "sqlite_sequence" ) == 0 ) { 
line 67046: pTable -> pSchema -> pSeqTab = pTable ; 
line 67047: } 
line 67048: # endif 
line 67058: if ( ! db -> init . busy && ( v = sqlite3GetVdbe ( pParse ) ) != 0 ) { 
line 67059: int j1 ; 
line 67060: int fileFormat ; 
line 67061: int reg1 , reg2 , reg3 ; 
line 67062: sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; 
line 67064: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 67065: if ( isVirtual ) { 
line 67066: sqlite3VdbeAddOp0 ( v , OP_VBegin ) ; 
line 67067: } 
line 67068: # endif 
line 67073: reg1 = pParse -> regRowid = ++ pParse -> nMem ; 
line 67074: reg2 = pParse -> regRoot = ++ pParse -> nMem ; 
line 67075: reg3 = ++ pParse -> nMem ; 
line 67076: sqlite3VdbeAddOp3 ( v , OP_ReadCookie , iDb , reg3 , BTREE_FILE_FORMAT ) ; 
line 67077: sqlite3VdbeUsesBtree ( v , iDb ) ; 
line 67078: j1 = sqlite3VdbeAddOp1 ( v , OP_If , reg3 ) ; 
line 67079: fileFormat = ( db -> flags & SQLITE_LegacyFileFmt ) != 0 ? 
line 67080: 1 : SQLITE_MAX_FILE_FORMAT ; 
line 67081: sqlite3VdbeAddOp2 ( v , OP_Integer , fileFormat , reg3 ) ; 
line 67082: sqlite3VdbeAddOp3 ( v , OP_SetCookie , iDb , BTREE_FILE_FORMAT , reg3 ) ; 
line 67083: sqlite3VdbeAddOp2 ( v , OP_Integer , ENC ( db ) , reg3 ) ; 
line 67084: sqlite3VdbeAddOp3 ( v , OP_SetCookie , iDb , BTREE_TEXT_ENCODING , reg3 ) ; 
line 67085: sqlite3VdbeJumpHere ( v , j1 ) ; 
line 67096: # if ! defined ( SQLITE_OMIT_VIEW ) || ! defined ( SQLITE_OMIT_VIRTUALTABLE ) 
line 67097: if ( isView || isVirtual ) { 
line 67098: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , reg2 ) ; 
line 67099: } else 
line 67100: # endif 
line 67101: { 
line 67102: sqlite3VdbeAddOp2 ( v , OP_CreateTable , iDb , reg2 ) ; 
line 67103: } 
line 67104: sqlite3OpenMasterTable ( pParse , iDb ) ; 
line 67105: sqlite3VdbeAddOp2 ( v , OP_NewRowid , 0 , reg1 ) ; 
line 67106: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , reg3 ) ; 
line 67107: sqlite3VdbeAddOp3 ( v , OP_Insert , 0 , reg3 , reg1 ) ; 
line 67108: sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ) ; 
line 67109: sqlite3VdbeAddOp0 ( v , OP_Close ) ; 
line 67110: } 
line 67113: return ; 
line 67116: begin_table_error : 
line 67117: sqlite3DbFree ( db , zName ) ; 
line 67118: return ; 
line 67119: } 
line 67129: # define STRICMP ( x , y ) 
line 67130: ( sqlite3UpperToLower [ * ( unsigned char * ) ( x ) ] == 
line 67131: sqlite3UpperToLower [ * ( unsigned char * ) ( y ) ] 
line 67132: && sqlite3StrICmp ( ( x ) + 1 , ( y ) + 1 ) == 0 ) 
line 67142: SQLITE_PRIVATE void sqlite3AddColumn ( Parse * pParse , Token * pName ) { 
line 67143: Table * p ; 
line 67144: int i ; 
line 67145: char * z ; 
line 67146: Column * pCol ; 
line 67147: sqlite3 * db = pParse -> db ; 
line 67148: if ( ( p = pParse -> pNewTable ) == 0 ) return ; 
line 67149: # if SQLITE_MAX_COLUMN 
line 67150: if ( p -> nCol + 1 > db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) { 
line 67151: sqlite3ErrorMsg ( pParse , "too many columns on %s" , p -> zName ) ; 
line 67152: return ; 
line 67153: } 
line 67154: # endif 
line 67155: z = sqlite3NameFromToken ( db , pName ) ; 
line 67156: if ( z == 0 ) return ; 
line 67157: for ( i = 0 ; i < p -> nCol ; i ++ ) { 
line 67158: if ( STRICMP ( z , p -> aCol [ i ] . zName ) ) { 
line 67159: sqlite3ErrorMsg ( pParse , "duplicate column name: %s" , z ) ; 
line 67160: sqlite3DbFree ( db , z ) ; 
line 67161: return ; 
line 67162: } 
line 67163: } 
line 67164: if ( ( p -> nCol & 0x7 ) == 0 ) { 
line 67165: Column * aNew ; 
line 67166: aNew = sqlite3DbRealloc ( db , p -> aCol , ( p -> nCol + 8 ) * sizeof ( p -> aCol [ 0 ] ) ) ; 
line 67167: if ( aNew == 0 ) { 
line 67168: sqlite3DbFree ( db , z ) ; 
line 67169: return ; 
line 67170: } 
line 67171: p -> aCol = aNew ; 
line 67172: } 
line 67173: pCol = & p -> aCol [ p -> nCol ] ; 
line 67174: memset ( pCol , 0 , sizeof ( p -> aCol [ 0 ] ) ) ; 
line 67175: pCol -> zName = z ; 
line 67181: pCol -> affinity = SQLITE_AFF_NONE ; 
line 67182: p -> nCol ++ ; 
line 67183: } 
line 67191: SQLITE_PRIVATE void sqlite3AddNotNull ( Parse * pParse , int onError ) { 
line 67192: Table * p ; 
line 67193: p = pParse -> pNewTable ; 
line 67194: if ( p == 0 || NEVER ( p -> nCol < 1 ) ) return ; 
line 67195: p -> aCol [ p -> nCol - 1 ] . notNull = ( u8 ) onError ; 
line 67196: } 
line 67223: SQLITE_PRIVATE char sqlite3AffinityType ( const char * zIn ) { 
line 67224: u32 h = 0 ; 
line 67225: char aff = SQLITE_AFF_NUMERIC ; 
line 67227: if ( zIn ) while ( zIn [ 0 ] ) { 
line 67228: h = ( h << 8 ) + sqlite3UpperToLower [ ( * zIn ) & 0xff ] ; 
line 67229: zIn ++ ; 
line 67230: if ( h == ( ( 'c' << 24 ) + ( 'h' << 16 ) + ( 'a' << 8 ) + 'r' ) ) { 
line 67231: aff = SQLITE_AFF_TEXT ; 
line 67232: } else if ( h == ( ( 'c' << 24 ) + ( 'l' << 16 ) + ( 'o' << 8 ) + 'b' ) ) { 
line 67233: aff = SQLITE_AFF_TEXT ; 
line 67234: } else if ( h == ( ( 't' << 24 ) + ( 'e' << 16 ) + ( 'x' << 8 ) + 't' ) ) { 
line 67235: aff = SQLITE_AFF_TEXT ; 
line 67236: } else if ( h == ( ( 'b' << 24 ) + ( 'l' << 16 ) + ( 'o' << 8 ) + 'b' ) 
line 67237: && ( aff == SQLITE_AFF_NUMERIC || aff == SQLITE_AFF_REAL ) ) { 
line 67238: aff = SQLITE_AFF_NONE ; 
line 67239: # ifndef SQLITE_OMIT_FLOATING_POINT 
line 67240: } else if ( h == ( ( 'r' << 24 ) + ( 'e' << 16 ) + ( 'a' << 8 ) + 'l' ) 
line 67241: && aff == SQLITE_AFF_NUMERIC ) { 
line 67242: aff = SQLITE_AFF_REAL ; 
line 67243: } else if ( h == ( ( 'f' << 24 ) + ( 'l' << 16 ) + ( 'o' << 8 ) + 'a' ) 
line 67244: && aff == SQLITE_AFF_NUMERIC ) { 
line 67245: aff = SQLITE_AFF_REAL ; 
line 67246: } else if ( h == ( ( 'd' << 24 ) + ( 'o' << 16 ) + ( 'u' << 8 ) + 'b' ) 
line 67247: && aff == SQLITE_AFF_NUMERIC ) { 
line 67248: aff = SQLITE_AFF_REAL ; 
line 67249: # endif 
line 67250: } else if ( ( h & 0x00FFFFFF ) == ( ( 'i' << 16 ) + ( 'n' << 8 ) + 't' ) ) { 
line 67251: aff = SQLITE_AFF_INTEGER ; 
line 67252: break ; 
line 67253: } 
line 67254: } 
line 67256: return aff ; 
line 67257: } 
line 67268: SQLITE_PRIVATE void sqlite3AddColumnType ( Parse * pParse , Token * pType ) { 
line 67269: Table * p ; 
line 67270: Column * pCol ; 
line 67272: p = pParse -> pNewTable ; 
line 67273: if ( p == 0 || NEVER ( p -> nCol < 1 ) ) return ; 
line 67274: pCol = & p -> aCol [ p -> nCol - 1 ] ; 
line 67275: assert ( pCol -> zType == 0 ) ; 
line 67276: pCol -> zType = sqlite3NameFromToken ( pParse -> db , pType ) ; 
line 67277: pCol -> affinity = sqlite3AffinityType ( pCol -> zType ) ; 
line 67278: } 
line 67290: SQLITE_PRIVATE void sqlite3AddDefaultValue ( Parse * pParse , ExprSpan * pSpan ) { 
line 67291: Table * p ; 
line 67292: Column * pCol ; 
line 67293: sqlite3 * db = pParse -> db ; 
line 67294: p = pParse -> pNewTable ; 
line 67295: if ( p != 0 ) { 
line 67296: pCol = & ( p -> aCol [ p -> nCol - 1 ] ) ; 
line 67297: if ( ! sqlite3ExprIsConstantOrFunction ( pSpan -> pExpr ) ) { 
line 67298: sqlite3ErrorMsg ( pParse , "default value of column [%s] is not constant" , 
line 67299: pCol -> zName ) ; 
line 67300: } else { 
line 67305: sqlite3ExprDelete ( db , pCol -> pDflt ) ; 
line 67306: pCol -> pDflt = sqlite3ExprDup ( db , pSpan -> pExpr , EXPRDUP_REDUCE ) ; 
line 67307: sqlite3DbFree ( db , pCol -> zDflt ) ; 
line 67308: pCol -> zDflt = sqlite3DbStrNDup ( db , ( char * ) pSpan -> zStart , 
line 67309: ( int ) ( pSpan -> zEnd - pSpan -> zStart ) ) ; 
line 67310: } 
line 67311: } 
line 67312: sqlite3ExprDelete ( db , pSpan -> pExpr ) ; 
line 67313: } 
line 67333: SQLITE_PRIVATE void sqlite3AddPrimaryKey ( 
line 67334: Parse * pParse , 
line 67335: ExprList * pList , 
line 67336: int onError , 
line 67337: int autoInc , 
line 67338: int sortOrder 
line 67339: ) { 
line 67340: Table * pTab = pParse -> pNewTable ; 
line 67341: char * zType = 0 ; 
line 67342: int iCol = - 1 , i ; 
line 67343: if ( pTab == 0 || IN_DECLARE_VTAB ) goto primary_key_exit ; 
line 67344: if ( pTab -> tabFlags & TF_HasPrimaryKey ) { 
line 67345: sqlite3ErrorMsg ( pParse , 
line 67346: "table \"%s\" has more than one primary key" , pTab -> zName ) ; 
line 67347: goto primary_key_exit ; 
line 67348: } 
line 67349: pTab -> tabFlags |= TF_HasPrimaryKey ; 
line 67350: if ( pList == 0 ) { 
line 67351: iCol = pTab -> nCol - 1 ; 
line 67352: pTab -> aCol [ iCol ] . isPrimKey = 1 ; 
line 67353: } else { 
line 67354: for ( i = 0 ; i < pList -> nExpr ; i ++ ) { 
line 67355: for ( iCol = 0 ; iCol < pTab -> nCol ; iCol ++ ) { 
line 67356: if ( sqlite3StrICmp ( pList -> a [ i ] . zName , pTab -> aCol [ iCol ] . zName ) == 0 ) { 
line 67357: break ; 
line 67358: } 
line 67359: } 
line 67360: if ( iCol < pTab -> nCol ) { 
line 67361: pTab -> aCol [ iCol ] . isPrimKey = 1 ; 
line 67362: } 
line 67363: } 
line 67364: if ( pList -> nExpr > 1 ) iCol = - 1 ; 
line 67365: } 
line 67366: if ( iCol >= 0 && iCol < pTab -> nCol ) { 
line 67367: zType = pTab -> aCol [ iCol ] . zType ; 
line 67368: } 
line 67369: if ( zType && sqlite3StrICmp ( zType , "INTEGER" ) == 0 
line 67370: && sortOrder == SQLITE_SO_ASC ) { 
line 67371: pTab -> iPKey = iCol ; 
line 67372: pTab -> keyConf = ( u8 ) onError ; 
line 67373: assert ( autoInc == 0 || autoInc == 1 ) ; 
line 67374: pTab -> tabFlags |= autoInc * TF_Autoincrement ; 
line 67375: } else if ( autoInc ) { 
line 67376: # ifndef SQLITE_OMIT_AUTOINCREMENT 
line 67377: sqlite3ErrorMsg ( pParse , "AUTOINCREMENT is only allowed on an " 
line 67378: "INTEGER PRIMARY KEY" ) ; 
line 67379: # endif 
line 67380: } else { 
line 67381: Index * p ; 
line 67382: p = sqlite3CreateIndex ( pParse , 0 , 0 , 0 , pList , onError , 0 , 0 , sortOrder , 0 ) ; 
line 67383: if ( p ) { 
line 67384: p -> autoIndex = 2 ; 
line 67385: } 
line 67386: pList = 0 ; 
line 67387: } 
line 67389: primary_key_exit : 
line 67390: sqlite3ExprListDelete ( pParse -> db , pList ) ; 
line 67391: return ; 
line 67392: } 
line 67397: SQLITE_PRIVATE void sqlite3AddCheckConstraint ( 
line 67398: Parse * pParse , 
line 67399: Expr * pCheckExpr 
line 67400: ) { 
line 67401: sqlite3 * db = pParse -> db ; 
line 67402: # ifndef SQLITE_OMIT_CHECK 
line 67403: Table * pTab = pParse -> pNewTable ; 
line 67404: if ( pTab && ! IN_DECLARE_VTAB ) { 
line 67405: pTab -> pCheck = sqlite3ExprAnd ( db , pTab -> pCheck , pCheckExpr ) ; 
line 67406: } else 
line 67407: # endif 
line 67408: { 
line 67409: sqlite3ExprDelete ( db , pCheckExpr ) ; 
line 67410: } 
line 67411: } 
line 67417: SQLITE_PRIVATE void sqlite3AddCollateType ( Parse * pParse , Token * pToken ) { 
line 67418: Table * p ; 
line 67419: int i ; 
line 67420: char * zColl ; 
line 67421: sqlite3 * db ; 
line 67423: if ( ( p = pParse -> pNewTable ) == 0 ) return ; 
line 67424: i = p -> nCol - 1 ; 
line 67425: db = pParse -> db ; 
line 67426: zColl = sqlite3NameFromToken ( db , pToken ) ; 
line 67427: if ( ! zColl ) return ; 
line 67429: if ( sqlite3LocateCollSeq ( pParse , zColl ) ) { 
line 67430: Index * pIdx ; 
line 67431: p -> aCol [ i ] . zColl = zColl ; 
line 67437: for ( pIdx = p -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { 
line 67438: assert ( pIdx -> nColumn == 1 ) ; 
line 67439: if ( pIdx -> aiColumn [ 0 ] == i ) { 
line 67440: pIdx -> azColl [ 0 ] = p -> aCol [ i ] . zColl ; 
line 67441: } 
line 67442: } 
line 67443: } else { 
line 67444: sqlite3DbFree ( db , zColl ) ; 
line 67445: } 
line 67446: } 
line 67468: SQLITE_PRIVATE CollSeq * sqlite3LocateCollSeq ( Parse * pParse , const char * zName ) { 
line 67469: sqlite3 * db = pParse -> db ; 
line 67470: u8 enc = ENC ( db ) ; 
line 67471: u8 initbusy = db -> init . busy ; 
line 67472: CollSeq * pColl ; 
line 67474: pColl = sqlite3FindCollSeq ( db , enc , zName , initbusy ) ; 
line 67475: if ( ! initbusy && ( ! pColl || ! pColl -> xCmp ) ) { 
line 67476: pColl = sqlite3GetCollSeq ( db , enc , pColl , zName ) ; 
line 67477: if ( ! pColl ) { 
line 67478: sqlite3ErrorMsg ( pParse , "no such collation sequence: %s" , zName ) ; 
line 67479: } 
line 67480: } 
line 67482: return pColl ; 
line 67483: } 
line 67502: SQLITE_PRIVATE void sqlite3ChangeCookie ( Parse * pParse , int iDb ) { 
line 67503: int r1 = sqlite3GetTempReg ( pParse ) ; 
line 67504: sqlite3 * db = pParse -> db ; 
line 67505: Vdbe * v = pParse -> pVdbe ; 
line 67506: sqlite3VdbeAddOp2 ( v , OP_Integer , db -> aDb [ iDb ] . pSchema -> schema_cookie + 1 , r1 ) ; 
line 67507: sqlite3VdbeAddOp3 ( v , OP_SetCookie , iDb , BTREE_SCHEMA_VERSION , r1 ) ; 
line 67508: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 67509: } 
line 67519: static int identLength ( const char * z ) { 
line 67520: int n ; 
line 67521: for ( n = 0 ; * z ; n ++ , z ++ ) { 
line 67522: if ( * z == '"' ) { n ++ ; } 
line 67523: } 
line 67524: return n + 2 ; 
line 67525: } 
line 67540: static void identPut ( char * z , int * pIdx , char * zSignedIdent ) { 
line 67541: unsigned char * zIdent = ( unsigned char * ) zSignedIdent ; 
line 67542: int i , j , needQuote ; 
line 67543: i = * pIdx ; 
line 67545: for ( j = 0 ; zIdent [ j ] ; j ++ ) { 
line 67546: if ( ! sqlite3Isalnum ( zIdent [ j ] ) && zIdent [ j ] != '_' ) break ; 
line 67547: } 
line 67548: needQuote = sqlite3Isdigit ( zIdent [ 0 ] ) || sqlite3KeywordCode ( zIdent , j ) != TK_ID ; 
line 67549: if ( ! needQuote ) { 
line 67550: needQuote = zIdent [ j ] ; 
line 67551: } 
line 67553: if ( needQuote ) z [ i ++ ] = '"' ; 
line 67554: for ( j = 0 ; zIdent [ j ] ; j ++ ) { 
line 67555: z [ i ++ ] = zIdent [ j ] ; 
line 67556: if ( zIdent [ j ] == '"' ) z [ i ++ ] = '"' ; 
line 67557: } 
line 67558: if ( needQuote ) z [ i ++ ] = '"' ; 
line 67559: z [ i ] = 0 ; 
line 67560: * pIdx = i ; 
line 67561: } 
line 67568: static char * createTableStmt ( sqlite3 * db , Table * p ) { 
line 67569: int i , k , n ; 
line 67570: char * zStmt ; 
line 67571: char * zSep , * zSep2 , * zEnd ; 
line 67572: Column * pCol ; 
line 67573: n = 0 ; 
line 67574: for ( pCol = p -> aCol , i = 0 ; i < p -> nCol ; i ++ , pCol ++ ) { 
line 67575: n += identLength ( pCol -> zName ) + 5 ; 
line 67576: } 
line 67577: n += identLength ( p -> zName ) ; 
line 67578: if ( n < 50 ) { 
line 67579: zSep = "" ; 
line 67580: zSep2 = "," ; 
line 67581: zEnd = ")" ; 
line 67582: } else { 
line 67583: zSep = "\n  " ; 
line 67584: zSep2 = ",\n  " ; 
line 67585: zEnd = "\n)" ; 
line 67586: } 
line 67587: n += 35 + 6 * p -> nCol ; 
line 67588: zStmt = sqlite3Malloc ( n ) ; 
line 67589: if ( zStmt == 0 ) { 
line 67590: db -> mallocFailed = 1 ; 
line 67591: return 0 ; 
line 67592: } 
line 67593: sqlite3_snprintf ( n , zStmt , "CREATE TABLE " ) ; 
line 67594: k = sqlite3Strlen30 ( zStmt ) ; 
line 67595: identPut ( zStmt , & k , p -> zName ) ; 
line 67596: zStmt [ k ++ ] = '(' ; 
line 67597: for ( pCol = p -> aCol , i = 0 ; i < p -> nCol ; i ++ , pCol ++ ) { 
line 67598: static const char * const azType [ ] = { 
line 67599: " TEXT" , 
line 67600: "" , 
line 67601: " NUM" , 
line 67602: " INT" , 
line 67603: " REAL" 
line 67604: } ; 
line 67605: int len ; 
line 67606: const char * zType ; 
line 67608: sqlite3_snprintf ( n - k , & zStmt [ k ] , zSep ) ; 
line 67609: k += sqlite3Strlen30 ( & zStmt [ k ] ) ; 
line 67610: zSep = zSep2 ; 
line 67611: identPut ( zStmt , & k , pCol -> zName ) ; 
line 67612: assert ( pCol -> affinity - SQLITE_AFF_TEXT >= 0 ) ; 
line 67613: assert ( pCol -> affinity - SQLITE_AFF_TEXT < sizeof ( azType ) / sizeof ( azType [ 0 ] ) ) ; 
line 67614: testcase ( pCol -> affinity == SQLITE_AFF_TEXT ) ; 
line 67615: testcase ( pCol -> affinity == SQLITE_AFF_NONE ) ; 
line 67616: testcase ( pCol -> affinity == SQLITE_AFF_NUMERIC ) ; 
line 67617: testcase ( pCol -> affinity == SQLITE_AFF_INTEGER ) ; 
line 67618: testcase ( pCol -> affinity == SQLITE_AFF_REAL ) ; 
line 67620: zType = azType [ pCol -> affinity - SQLITE_AFF_TEXT ] ; 
line 67621: len = sqlite3Strlen30 ( zType ) ; 
line 67622: assert ( pCol -> affinity == SQLITE_AFF_NONE 
line 67623: || pCol -> affinity == sqlite3AffinityType ( zType ) ) ; 
line 67624: memcpy ( & zStmt [ k ] , zType , len ) ; 
line 67625: k += len ; 
line 67626: assert ( k <= n ) ; 
line 67627: } 
line 67628: sqlite3_snprintf ( n - k , & zStmt [ k ] , "%s" , zEnd ) ; 
line 67629: return zStmt ; 
line 67630: } 
line 67652: SQLITE_PRIVATE void sqlite3EndTable ( 
line 67653: Parse * pParse , 
line 67654: Token * pCons , 
line 67655: Token * pEnd , 
line 67656: Select * pSelect 
line 67657: ) { 
line 67658: Table * p ; 
line 67659: sqlite3 * db = pParse -> db ; 
line 67660: int iDb ; 
line 67662: if ( ( pEnd == 0 && pSelect == 0 ) || db -> mallocFailed ) { 
line 67663: return ; 
line 67664: } 
line 67665: p = pParse -> pNewTable ; 
line 67666: if ( p == 0 ) return ; 
line 67668: assert ( ! db -> init . busy || ! pSelect ) ; 
line 67670: iDb = sqlite3SchemaToIndex ( db , p -> pSchema ) ; 
line 67672: # ifndef SQLITE_OMIT_CHECK 
line 67675: if ( p -> pCheck ) { 
line 67676: SrcList sSrc ; 
line 67677: NameContext sNC ; 
line 67679: memset ( & sNC , 0 , sizeof ( sNC ) ) ; 
line 67680: memset ( & sSrc , 0 , sizeof ( sSrc ) ) ; 
line 67681: sSrc . nSrc = 1 ; 
line 67682: sSrc . a [ 0 ] . zName = p -> zName ; 
line 67683: sSrc . a [ 0 ] . pTab = p ; 
line 67684: sSrc . a [ 0 ] . iCursor = - 1 ; 
line 67685: sNC . pParse = pParse ; 
line 67686: sNC . pSrcList = & sSrc ; 
line 67687: sNC . isCheck = 1 ; 
line 67688: if ( sqlite3ResolveExprNames ( & sNC , p -> pCheck ) ) { 
line 67689: return ; 
line 67690: } 
line 67691: } 
line 67692: # endif 
line 67700: if ( db -> init . busy ) { 
line 67701: p -> tnum = db -> init . newTnum ; 
line 67702: } 
line 67710: if ( ! db -> init . busy ) { 
line 67711: int n ; 
line 67712: Vdbe * v ; 
line 67713: char * zType ; 
line 67714: char * zType2 ; 
line 67715: char * zStmt ; 
line 67717: v = sqlite3GetVdbe ( pParse ) ; 
line 67718: if ( NEVER ( v == 0 ) ) return ; 
line 67720: sqlite3VdbeAddOp1 ( v , OP_Close , 0 ) ; 
line 67725: if ( p -> pSelect == 0 ) { 
line 67727: zType = "table" ; 
line 67728: zType2 = "TABLE" ; 
line 67729: # ifndef SQLITE_OMIT_VIEW 
line 67730: } else { 
line 67732: zType = "view" ; 
line 67733: zType2 = "VIEW" ; 
line 67734: # endif 
line 67735: } 
line 67750: if ( pSelect ) { 
line 67751: SelectDest dest ; 
line 67752: Table * pSelTab ; 
line 67754: assert ( pParse -> nTab == 1 ) ; 
line 67755: sqlite3VdbeAddOp3 ( v , OP_OpenWrite , 1 , pParse -> regRoot , iDb ) ; 
line 67756: sqlite3VdbeChangeP5 ( v , 1 ) ; 
line 67757: pParse -> nTab = 2 ; 
line 67758: sqlite3SelectDestInit ( & dest , SRT_Table , 1 ) ; 
line 67759: sqlite3Select ( pParse , pSelect , & dest ) ; 
line 67760: sqlite3VdbeAddOp1 ( v , OP_Close , 1 ) ; 
line 67761: if ( pParse -> nErr == 0 ) { 
line 67762: pSelTab = sqlite3ResultSetOfSelect ( pParse , pSelect ) ; 
line 67763: if ( pSelTab == 0 ) return ; 
line 67764: assert ( p -> aCol == 0 ) ; 
line 67765: p -> nCol = pSelTab -> nCol ; 
line 67766: p -> aCol = pSelTab -> aCol ; 
line 67767: pSelTab -> nCol = 0 ; 
line 67768: pSelTab -> aCol = 0 ; 
line 67769: sqlite3DeleteTable ( pSelTab ) ; 
line 67770: } 
line 67771: } 
line 67774: if ( pSelect ) { 
line 67775: zStmt = createTableStmt ( db , p ) ; 
line 67776: } else { 
line 67777: n = ( int ) ( pEnd -> z - pParse -> sNameToken . z ) + 1 ; 
line 67778: zStmt = sqlite3MPrintf ( db , 
line 67779: "CREATE %s %.*s" , zType2 , n , pParse -> sNameToken . z 
line 67780: ) ; 
line 67781: } 
line 67787: sqlite3NestedParse ( pParse , 
line 67788: "UPDATE %Q.%s " 
line 67789: "SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q " 
line 67790: "WHERE rowid=#%d" , 
line 67791: db -> aDb [ iDb ] . zName , SCHEMA_TABLE ( iDb ) , 
line 67792: zType , 
line 67793: p -> zName , 
line 67794: p -> zName , 
line 67795: pParse -> regRoot , 
line 67796: zStmt , 
line 67797: pParse -> regRowid 
line 67798: ) ; 
line 67799: sqlite3DbFree ( db , zStmt ) ; 
line 67800: sqlite3ChangeCookie ( pParse , iDb ) ; 
line 67802: # ifndef SQLITE_OMIT_AUTOINCREMENT 
line 67806: if ( p -> tabFlags & TF_Autoincrement ) { 
line 67807: Db * pDb = & db -> aDb [ iDb ] ; 
line 67808: if ( pDb -> pSchema -> pSeqTab == 0 ) { 
line 67809: sqlite3NestedParse ( pParse , 
line 67810: "CREATE TABLE %Q.sqlite_sequence(name,seq)" , 
line 67811: pDb -> zName 
line 67812: ) ; 
line 67813: } 
line 67814: } 
line 67815: # endif 
line 67818: sqlite3VdbeAddOp4 ( v , OP_ParseSchema , iDb , 0 , 0 , 
line 67819: sqlite3MPrintf ( db , "tbl_name='%q'" , p -> zName ) , P4_DYNAMIC ) ; 
line 67820: } 
line 67825: if ( db -> init . busy ) { 
line 67826: Table * pOld ; 
line 67827: Schema * pSchema = p -> pSchema ; 
line 67828: pOld = sqlite3HashInsert ( & pSchema -> tblHash , p -> zName , 
line 67829: sqlite3Strlen30 ( p -> zName ) , p ) ; 
line 67830: if ( pOld ) { 
line 67831: assert ( p == pOld ) ; 
line 67832: db -> mallocFailed = 1 ; 
line 67833: return ; 
line 67834: } 
line 67835: pParse -> pNewTable = 0 ; 
line 67836: db -> nTable ++ ; 
line 67837: db -> flags |= SQLITE_InternChanges ; 
line 67839: # ifndef SQLITE_OMIT_ALTERTABLE 
line 67840: if ( ! p -> pSelect ) { 
line 67841: const char * zName = ( const char * ) pParse -> sNameToken . z ; 
line 67842: int nName ; 
line 67843: assert ( ! pSelect && pCons && pEnd ) ; 
line 67844: if ( pCons -> z == 0 ) { 
line 67845: pCons = pEnd ; 
line 67846: } 
line 67847: nName = ( int ) ( ( const char * ) pCons -> z - zName ) ; 
line 67848: p -> addColOffset = 13 + sqlite3Utf8CharLen ( zName , nName ) ; 
line 67849: } 
line 67850: # endif 
line 67851: } 
line 67852: } 
line 67854: # ifndef SQLITE_OMIT_VIEW 
line 67858: SQLITE_PRIVATE void sqlite3CreateView ( 
line 67859: Parse * pParse , 
line 67860: Token * pBegin , 
line 67861: Token * pName1 , 
line 67862: Token * pName2 , 
line 67863: Select * pSelect , 
line 67864: int isTemp , 
line 67865: int noErr 
line 67866: ) { 
line 67867: Table * p ; 
line 67868: int n ; 
line 67869: const char * z ; 
line 67870: Token sEnd ; 
line 67871: DbFixer sFix ; 
line 67872: Token * pName ; 
line 67873: int iDb ; 
line 67874: sqlite3 * db = pParse -> db ; 
line 67876: if ( pParse -> nVar > 0 ) { 
line 67877: sqlite3ErrorMsg ( pParse , "parameters are not allowed in views" ) ; 
line 67878: sqlite3SelectDelete ( db , pSelect ) ; 
line 67879: return ; 
line 67880: } 
line 67881: sqlite3StartTable ( pParse , pName1 , pName2 , isTemp , 1 , 0 , noErr ) ; 
line 67882: p = pParse -> pNewTable ; 
line 67883: if ( p == 0 ) { 
line 67884: sqlite3SelectDelete ( db , pSelect ) ; 
line 67885: return ; 
line 67886: } 
line 67887: assert ( pParse -> nErr == 0 ) ; 
line 67889: sqlite3TwoPartName ( pParse , pName1 , pName2 , & pName ) ; 
line 67890: iDb = sqlite3SchemaToIndex ( db , p -> pSchema ) ; 
line 67891: if ( sqlite3FixInit ( & sFix , pParse , iDb , "view" , pName ) 
line 67892: && sqlite3FixSelect ( & sFix , pSelect ) 
line 67893: ) { 
line 67894: sqlite3SelectDelete ( db , pSelect ) ; 
line 67895: return ; 
line 67896: } 
line 67903: p -> pSelect = sqlite3SelectDup ( db , pSelect , EXPRDUP_REDUCE ) ; 
line 67904: sqlite3SelectDelete ( db , pSelect ) ; 
line 67905: if ( db -> mallocFailed ) { 
line 67906: return ; 
line 67907: } 
line 67908: if ( ! db -> init . busy ) { 
line 67909: sqlite3ViewGetColumnNames ( pParse , p ) ; 
line 67910: } 
line 67915: sEnd = pParse -> sLastToken ; 
line 67916: if ( ALWAYS ( sEnd . z [ 0 ] != 0 ) && sEnd . z [ 0 ] != ';' ) { 
line 67917: sEnd . z += sEnd . n ; 
line 67918: } 
line 67919: sEnd . n = 0 ; 
line 67920: n = ( int ) ( sEnd . z - pBegin -> z ) ; 
line 67921: z = pBegin -> z ; 
line 67922: while ( ALWAYS ( n > 0 ) && sqlite3Isspace ( z [ n - 1 ] ) ) { n -- ; } 
line 67923: sEnd . z = & z [ n - 1 ] ; 
line 67924: sEnd . n = 1 ; 
line 67927: sqlite3EndTable ( pParse , 0 , & sEnd , 0 ) ; 
line 67928: return ; 
line 67929: } 
line 67930: # endif 
line 67932: # if ! defined ( SQLITE_OMIT_VIEW ) || ! defined ( SQLITE_OMIT_VIRTUALTABLE ) 
line 67938: SQLITE_PRIVATE int sqlite3ViewGetColumnNames ( Parse * pParse , Table * pTable ) { 
line 67939: Table * pSelTab ; 
line 67940: Select * pSel ; 
line 67941: int nErr = 0 ; 
line 67942: int n ; 
line 67943: sqlite3 * db = pParse -> db ; 
line 67944: int ( * xAuth ) ( void * , int , const char * , const char * , const char * , const char * ) ; 
line 67946: assert ( pTable ) ; 
line 67948: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 67949: if ( sqlite3VtabCallConnect ( pParse , pTable ) ) { 
line 67950: return SQLITE_ERROR ; 
line 67951: } 
line 67952: if ( IsVirtual ( pTable ) ) return 0 ; 
line 67953: # endif 
line 67955: # ifndef SQLITE_OMIT_VIEW 
line 67959: if ( pTable -> nCol > 0 ) return 0 ; 
line 67976: if ( pTable -> nCol < 0 ) { 
line 67977: sqlite3ErrorMsg ( pParse , "view %s is circularly defined" , pTable -> zName ) ; 
line 67978: return 1 ; 
line 67979: } 
line 67980: assert ( pTable -> nCol >= 0 ) ; 
line 67989: assert ( pTable -> pSelect ) ; 
line 67990: pSel = sqlite3SelectDup ( db , pTable -> pSelect , 0 ) ; 
line 67991: if ( pSel ) { 
line 67992: u8 enableLookaside = db -> lookaside . bEnabled ; 
line 67993: n = pParse -> nTab ; 
line 67994: sqlite3SrcListAssignCursors ( pParse , pSel -> pSrc ) ; 
line 67995: pTable -> nCol = - 1 ; 
line 67996: db -> lookaside . bEnabled = 0 ; 
line 67997: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 67998: xAuth = db -> xAuth ; 
line 67999: db -> xAuth = 0 ; 
line 68000: pSelTab = sqlite3ResultSetOfSelect ( pParse , pSel ) ; 
line 68001: db -> xAuth = xAuth ; 
line 68002: # else 
line 68003: pSelTab = sqlite3ResultSetOfSelect ( pParse , pSel ) ; 
line 68004: # endif 
line 68005: db -> lookaside . bEnabled = enableLookaside ; 
line 68006: pParse -> nTab = n ; 
line 68007: if ( pSelTab ) { 
line 68008: assert ( pTable -> aCol == 0 ) ; 
line 68009: pTable -> nCol = pSelTab -> nCol ; 
line 68010: pTable -> aCol = pSelTab -> aCol ; 
line 68011: pSelTab -> nCol = 0 ; 
line 68012: pSelTab -> aCol = 0 ; 
line 68013: sqlite3DeleteTable ( pSelTab ) ; 
line 68014: pTable -> pSchema -> flags |= DB_UnresetViews ; 
line 68015: } else { 
line 68016: pTable -> nCol = 0 ; 
line 68017: nErr ++ ; 
line 68018: } 
line 68019: sqlite3SelectDelete ( db , pSel ) ; 
line 68020: } else { 
line 68021: nErr ++ ; 
line 68022: } 
line 68023: # endif 
line 68024: return nErr ; 
line 68025: } 
line 68026: # endif 
line 68028: # ifndef SQLITE_OMIT_VIEW 
line 68032: static void sqliteViewResetAll ( sqlite3 * db , int idx ) { 
line 68033: HashElem * i ; 
line 68034: if ( ! DbHasProperty ( db , idx , DB_UnresetViews ) ) return ; 
line 68035: for ( i = sqliteHashFirst ( & db -> aDb [ idx ] . pSchema -> tblHash ) ; i ; i = sqliteHashNext ( i ) ) { 
line 68036: Table * pTab = sqliteHashData ( i ) ; 
line 68037: if ( pTab -> pSelect ) { 
line 68038: sqliteResetColumnNames ( pTab ) ; 
line 68039: } 
line 68040: } 
line 68041: DbClearProperty ( db , idx , DB_UnresetViews ) ; 
line 68042: } 
line 68043: # else 
line 68044: # define sqliteViewResetAll ( A , B ) 
line 68045: # endif 
line 68064: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 68065: SQLITE_PRIVATE void sqlite3RootPageMoved ( Db * pDb , int iFrom , int iTo ) { 
line 68066: HashElem * pElem ; 
line 68067: Hash * pHash ; 
line 68069: pHash = & pDb -> pSchema -> tblHash ; 
line 68070: for ( pElem = sqliteHashFirst ( pHash ) ; pElem ; pElem = sqliteHashNext ( pElem ) ) { 
line 68071: Table * pTab = sqliteHashData ( pElem ) ; 
line 68072: if ( pTab -> tnum == iFrom ) { 
line 68073: pTab -> tnum = iTo ; 
line 68074: } 
line 68075: } 
line 68076: pHash = & pDb -> pSchema -> idxHash ; 
line 68077: for ( pElem = sqliteHashFirst ( pHash ) ; pElem ; pElem = sqliteHashNext ( pElem ) ) { 
line 68078: Index * pIdx = sqliteHashData ( pElem ) ; 
line 68079: if ( pIdx -> tnum == iFrom ) { 
line 68080: pIdx -> tnum = iTo ; 
line 68081: } 
line 68082: } 
line 68083: } 
line 68084: # endif 
line 68092: static void destroyRootPage ( Parse * pParse , int iTable , int iDb ) { 
line 68093: Vdbe * v = sqlite3GetVdbe ( pParse ) ; 
line 68094: int r1 = sqlite3GetTempReg ( pParse ) ; 
line 68095: sqlite3VdbeAddOp3 ( v , OP_Destroy , iTable , r1 , iDb ) ; 
line 68096: sqlite3MayAbort ( pParse ) ; 
line 68097: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 68107: sqlite3NestedParse ( pParse , 
line 68108: "UPDATE %Q.%s SET rootpage=%d WHERE #%d AND rootpage=#%d" , 
line 68109: pParse -> db -> aDb [ iDb ] . zName , SCHEMA_TABLE ( iDb ) , iTable , r1 , r1 ) ; 
line 68110: # endif 
line 68111: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 68112: } 
line 68120: static void destroyTable ( Parse * pParse , Table * pTab ) { 
line 68121: # ifdef SQLITE_OMIT_AUTOVACUUM 
line 68122: Index * pIdx ; 
line 68123: int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; 
line 68124: destroyRootPage ( pParse , pTab -> tnum , iDb ) ; 
line 68125: for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { 
line 68126: destroyRootPage ( pParse , pIdx -> tnum , iDb ) ; 
line 68127: } 
line 68128: # else 
line 68145: int iTab = pTab -> tnum ; 
line 68146: int iDestroyed = 0 ; 
line 68148: while ( 1 ) { 
line 68149: Index * pIdx ; 
line 68150: int iLargest = 0 ; 
line 68152: if ( iDestroyed == 0 || iTab < iDestroyed ) { 
line 68153: iLargest = iTab ; 
line 68154: } 
line 68155: for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { 
line 68156: int iIdx = pIdx -> tnum ; 
line 68157: assert ( pIdx -> pSchema == pTab -> pSchema ) ; 
line 68158: if ( ( iDestroyed == 0 || ( iIdx < iDestroyed ) ) && iIdx > iLargest ) { 
line 68159: iLargest = iIdx ; 
line 68160: } 
line 68161: } 
line 68162: if ( iLargest == 0 ) { 
line 68163: return ; 
line 68164: } else { 
line 68165: int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; 
line 68166: destroyRootPage ( pParse , iLargest , iDb ) ; 
line 68167: iDestroyed = iLargest ; 
line 68168: } 
line 68169: } 
line 68170: # endif 
line 68171: } 
line 68177: SQLITE_PRIVATE void sqlite3DropTable ( Parse * pParse , SrcList * pName , int isView , int noErr ) { 
line 68178: Table * pTab ; 
line 68179: Vdbe * v ; 
line 68180: sqlite3 * db = pParse -> db ; 
line 68181: int iDb ; 
line 68183: if ( db -> mallocFailed ) { 
line 68184: goto exit_drop_table ; 
line 68185: } 
line 68186: assert ( pParse -> nErr == 0 ) ; 
line 68187: assert ( pName -> nSrc == 1 ) ; 
line 68188: pTab = sqlite3LocateTable ( pParse , isView , 
line 68189: pName -> a [ 0 ] . zName , pName -> a [ 0 ] . zDatabase ) ; 
line 68191: if ( pTab == 0 ) { 
line 68192: if ( noErr ) { 
line 68193: sqlite3ErrorClear ( pParse ) ; 
line 68194: } 
line 68195: goto exit_drop_table ; 
line 68196: } 
line 68197: iDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; 
line 68198: assert ( iDb >= 0 && iDb < db -> nDb ) ; 
line 68203: if ( IsVirtual ( pTab ) && sqlite3ViewGetColumnNames ( pParse , pTab ) ) { 
line 68204: goto exit_drop_table ; 
line 68205: } 
line 68206: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 68207: { 
line 68208: int code ; 
line 68209: const char * zTab = SCHEMA_TABLE ( iDb ) ; 
line 68210: const char * zDb = db -> aDb [ iDb ] . zName ; 
line 68211: const char * zArg2 = 0 ; 
line 68212: if ( sqlite3AuthCheck ( pParse , SQLITE_DELETE , zTab , 0 , zDb ) ) { 
line 68213: goto exit_drop_table ; 
line 68214: } 
line 68215: if ( isView ) { 
line 68216: if ( ! OMIT_TEMPDB && iDb == 1 ) { 
line 68217: code = SQLITE_DROP_TEMP_VIEW ; 
line 68218: } else { 
line 68219: code = SQLITE_DROP_VIEW ; 
line 68220: } 
line 68221: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 68222: } else if ( IsVirtual ( pTab ) ) { 
line 68223: code = SQLITE_DROP_VTABLE ; 
line 68224: zArg2 = sqlite3GetVTable ( db , pTab ) -> pMod -> zName ; 
line 68225: # endif 
line 68226: } else { 
line 68227: if ( ! OMIT_TEMPDB && iDb == 1 ) { 
line 68228: code = SQLITE_DROP_TEMP_TABLE ; 
line 68229: } else { 
line 68230: code = SQLITE_DROP_TABLE ; 
line 68231: } 
line 68232: } 
line 68233: if ( sqlite3AuthCheck ( pParse , code , pTab -> zName , zArg2 , zDb ) ) { 
line 68234: goto exit_drop_table ; 
line 68235: } 
line 68236: if ( sqlite3AuthCheck ( pParse , SQLITE_DELETE , pTab -> zName , 0 , zDb ) ) { 
line 68237: goto exit_drop_table ; 
line 68238: } 
line 68239: } 
line 68240: # endif 
line 68241: if ( sqlite3StrNICmp ( pTab -> zName , "sqlite_" , 7 ) == 0 ) { 
line 68242: sqlite3ErrorMsg ( pParse , "table %s may not be dropped" , pTab -> zName ) ; 
line 68243: goto exit_drop_table ; 
line 68244: } 
line 68246: # ifndef SQLITE_OMIT_VIEW 
line 68250: if ( isView && pTab -> pSelect == 0 ) { 
line 68251: sqlite3ErrorMsg ( pParse , "use DROP TABLE to delete table %s" , pTab -> zName ) ; 
line 68252: goto exit_drop_table ; 
line 68253: } 
line 68254: if ( ! isView && pTab -> pSelect ) { 
line 68255: sqlite3ErrorMsg ( pParse , "use DROP VIEW to delete view %s" , pTab -> zName ) ; 
line 68256: goto exit_drop_table ; 
line 68257: } 
line 68258: # endif 
line 68263: v = sqlite3GetVdbe ( pParse ) ; 
line 68264: if ( v ) { 
line 68265: Trigger * pTrigger ; 
line 68266: Db * pDb = & db -> aDb [ iDb ] ; 
line 68267: sqlite3BeginWriteOperation ( pParse , 1 , iDb ) ; 
line 68269: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 68270: if ( IsVirtual ( pTab ) ) { 
line 68271: sqlite3VdbeAddOp0 ( v , OP_VBegin ) ; 
line 68272: } 
line 68273: # endif 
line 68274: sqlite3FkDropTable ( pParse , pName , pTab ) ; 
line 68280: pTrigger = sqlite3TriggerList ( pParse , pTab ) ; 
line 68281: while ( pTrigger ) { 
line 68282: assert ( pTrigger -> pSchema == pTab -> pSchema || 
line 68283: pTrigger -> pSchema == db -> aDb [ 1 ] . pSchema ) ; 
line 68284: sqlite3DropTriggerPtr ( pParse , pTrigger ) ; 
line 68285: pTrigger = pTrigger -> pNext ; 
line 68286: } 
line 68288: # ifndef SQLITE_OMIT_AUTOINCREMENT 
line 68294: if ( pTab -> tabFlags & TF_Autoincrement ) { 
line 68295: sqlite3NestedParse ( pParse , 
line 68296: "DELETE FROM %s.sqlite_sequence WHERE name=%Q" , 
line 68297: pDb -> zName , pTab -> zName 
line 68298: ) ; 
line 68299: } 
line 68300: # endif 
line 68309: sqlite3NestedParse ( pParse , 
line 68310: "DELETE FROM %Q.%s WHERE tbl_name=%Q and type!='trigger'" , 
line 68311: pDb -> zName , SCHEMA_TABLE ( iDb ) , pTab -> zName ) ; 
line 68314: if ( sqlite3FindTable ( db , "sqlite_stat1" , db -> aDb [ iDb ] . zName ) ) { 
line 68315: sqlite3NestedParse ( pParse , 
line 68316: "DELETE FROM %Q.sqlite_stat1 WHERE tbl=%Q" , pDb -> zName , pTab -> zName 
line 68317: ) ; 
line 68318: } 
line 68320: if ( ! isView && ! IsVirtual ( pTab ) ) { 
line 68321: destroyTable ( pParse , pTab ) ; 
line 68322: } 
line 68327: if ( IsVirtual ( pTab ) ) { 
line 68328: sqlite3VdbeAddOp4 ( v , OP_VDestroy , iDb , 0 , 0 , pTab -> zName , 0 ) ; 
line 68329: } 
line 68330: sqlite3VdbeAddOp4 ( v , OP_DropTable , iDb , 0 , 0 , pTab -> zName , 0 ) ; 
line 68331: sqlite3ChangeCookie ( pParse , iDb ) ; 
line 68332: } 
line 68333: sqliteViewResetAll ( db , iDb ) ; 
line 68335: exit_drop_table : 
line 68336: sqlite3SrcListDelete ( db , pName ) ; 
line 68337: } 
line 68355: SQLITE_PRIVATE void sqlite3CreateForeignKey ( 
line 68356: Parse * pParse , 
line 68357: ExprList * pFromCol , 
line 68358: Token * pTo , 
line 68359: ExprList * pToCol , 
line 68360: int flags 
line 68361: ) { 
line 68362: sqlite3 * db = pParse -> db ; 
line 68363: # ifndef SQLITE_OMIT_FOREIGN_KEY 
line 68364: FKey * pFKey = 0 ; 
line 68365: FKey * pNextTo ; 
line 68366: Table * p = pParse -> pNewTable ; 
line 68367: int nByte ; 
line 68368: int i ; 
line 68369: int nCol ; 
line 68370: char * z ; 
line 68372: assert ( pTo != 0 ) ; 
line 68373: if ( p == 0 || IN_DECLARE_VTAB ) goto fk_end ; 
line 68374: if ( pFromCol == 0 ) { 
line 68375: int iCol = p -> nCol - 1 ; 
line 68376: if ( NEVER ( iCol < 0 ) ) goto fk_end ; 
line 68377: if ( pToCol && pToCol -> nExpr != 1 ) { 
line 68378: sqlite3ErrorMsg ( pParse , "foreign key on %s" 
line 68379: " should reference only one column of table %T" , 
line 68380: p -> aCol [ iCol ] . zName , pTo ) ; 
line 68381: goto fk_end ; 
line 68382: } 
line 68383: nCol = 1 ; 
line 68384: } else if ( pToCol && pToCol -> nExpr != pFromCol -> nExpr ) { 
line 68385: sqlite3ErrorMsg ( pParse , 
line 68386: "number of columns in foreign key does not match the number of " 
line 68387: "columns in the referenced table" ) ; 
line 68388: goto fk_end ; 
line 68389: } else { 
line 68390: nCol = pFromCol -> nExpr ; 
line 68391: } 
line 68392: nByte = sizeof ( * pFKey ) + ( nCol - 1 ) * sizeof ( pFKey -> aCol [ 0 ] ) + pTo -> n + 1 ; 
line 68393: if ( pToCol ) { 
line 68394: for ( i = 0 ; i < pToCol -> nExpr ; i ++ ) { 
line 68395: nByte += sqlite3Strlen30 ( pToCol -> a [ i ] . zName ) + 1 ; 
line 68396: } 
line 68397: } 
line 68398: pFKey = sqlite3DbMallocZero ( db , nByte ) ; 
line 68399: if ( pFKey == 0 ) { 
line 68400: goto fk_end ; 
line 68401: } 
line 68402: pFKey -> pFrom = p ; 
line 68403: pFKey -> pNextFrom = p -> pFKey ; 
line 68404: z = ( char * ) & pFKey -> aCol [ nCol ] ; 
line 68405: pFKey -> zTo = z ; 
line 68406: memcpy ( z , pTo -> z , pTo -> n ) ; 
line 68407: z [ pTo -> n ] = 0 ; 
line 68408: sqlite3Dequote ( z ) ; 
line 68409: z += pTo -> n + 1 ; 
line 68410: pFKey -> nCol = nCol ; 
line 68411: if ( pFromCol == 0 ) { 
line 68412: pFKey -> aCol [ 0 ] . iFrom = p -> nCol - 1 ; 
line 68413: } else { 
line 68414: for ( i = 0 ; i < nCol ; i ++ ) { 
line 68415: int j ; 
line 68416: for ( j = 0 ; j < p -> nCol ; j ++ ) { 
line 68417: if ( sqlite3StrICmp ( p -> aCol [ j ] . zName , pFromCol -> a [ i ] . zName ) == 0 ) { 
line 68418: pFKey -> aCol [ i ] . iFrom = j ; 
line 68419: break ; 
line 68420: } 
line 68421: } 
line 68422: if ( j >= p -> nCol ) { 
line 68423: sqlite3ErrorMsg ( pParse , 
line 68424: "unknown column \"%s\" in foreign key definition" , 
line 68425: pFromCol -> a [ i ] . zName ) ; 
line 68426: goto fk_end ; 
line 68427: } 
line 68428: } 
line 68429: } 
line 68430: if ( pToCol ) { 
line 68431: for ( i = 0 ; i < nCol ; i ++ ) { 
line 68432: int n = sqlite3Strlen30 ( pToCol -> a [ i ] . zName ) ; 
line 68433: pFKey -> aCol [ i ] . zCol = z ; 
line 68434: memcpy ( z , pToCol -> a [ i ] . zName , n ) ; 
line 68435: z [ n ] = 0 ; 
line 68436: z += n + 1 ; 
line 68437: } 
line 68438: } 
line 68439: pFKey -> isDeferred = 0 ; 
line 68440: pFKey -> aAction [ 0 ] = ( u8 ) ( flags & 0xff ) ; 
line 68441: pFKey -> aAction [ 1 ] = ( u8 ) ( ( flags >> 8 ) & 0xff ) ; 
line 68443: pNextTo = ( FKey * ) sqlite3HashInsert ( & p -> pSchema -> fkeyHash , 
line 68444: pFKey -> zTo , sqlite3Strlen30 ( pFKey -> zTo ) , ( void * ) pFKey 
line 68445: ) ; 
line 68446: if ( pNextTo == pFKey ) { 
line 68447: db -> mallocFailed = 1 ; 
line 68448: goto fk_end ; 
line 68449: } 
line 68450: if ( pNextTo ) { 
line 68451: assert ( pNextTo -> pPrevTo == 0 ) ; 
line 68452: pFKey -> pNextTo = pNextTo ; 
line 68453: pNextTo -> pPrevTo = pFKey ; 
line 68454: } 
line 68458: p -> pFKey = pFKey ; 
line 68459: pFKey = 0 ; 
line 68461: fk_end : 
line 68462: sqlite3DbFree ( db , pFKey ) ; 
line 68463: # endif 
line 68464: sqlite3ExprListDelete ( db , pFromCol ) ; 
line 68465: sqlite3ExprListDelete ( db , pToCol ) ; 
line 68466: } 
line 68475: SQLITE_PRIVATE void sqlite3DeferForeignKey ( Parse * pParse , int isDeferred ) { 
line 68476: # ifndef SQLITE_OMIT_FOREIGN_KEY 
line 68477: Table * pTab ; 
line 68478: FKey * pFKey ; 
line 68479: if ( ( pTab = pParse -> pNewTable ) == 0 || ( pFKey = pTab -> pFKey ) == 0 ) return ; 
line 68480: assert ( isDeferred == 0 || isDeferred == 1 ) ; 
line 68481: pFKey -> isDeferred = ( u8 ) isDeferred ; 
line 68482: # endif 
line 68483: } 
line 68496: static void sqlite3RefillIndex ( Parse * pParse , Index * pIndex , int memRootPage ) { 
line 68497: Table * pTab = pIndex -> pTable ; 
line 68498: int iTab = pParse -> nTab ++ ; 
line 68499: int iIdx = pParse -> nTab ++ ; 
line 68500: int addr1 ; 
line 68501: int tnum ; 
line 68502: Vdbe * v ; 
line 68503: KeyInfo * pKey ; 
line 68504: int regIdxKey ; 
line 68505: int regRecord ; 
line 68506: sqlite3 * db = pParse -> db ; 
line 68507: int iDb = sqlite3SchemaToIndex ( db , pIndex -> pSchema ) ; 
line 68509: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 68510: if ( sqlite3AuthCheck ( pParse , SQLITE_REINDEX , pIndex -> zName , 0 , 
line 68511: db -> aDb [ iDb ] . zName ) ) { 
line 68512: return ; 
line 68513: } 
line 68514: # endif 
line 68517: sqlite3TableLock ( pParse , iDb , pTab -> tnum , 1 , pTab -> zName ) ; 
line 68519: v = sqlite3GetVdbe ( pParse ) ; 
line 68520: if ( v == 0 ) return ; 
line 68521: if ( memRootPage >= 0 ) { 
line 68522: tnum = memRootPage ; 
line 68523: } else { 
line 68524: tnum = pIndex -> tnum ; 
line 68525: sqlite3VdbeAddOp2 ( v , OP_Clear , tnum , iDb ) ; 
line 68526: } 
line 68527: pKey = sqlite3IndexKeyinfo ( pParse , pIndex ) ; 
line 68528: sqlite3VdbeAddOp4 ( v , OP_OpenWrite , iIdx , tnum , iDb , 
line 68529: ( char * ) pKey , P4_KEYINFO_HANDOFF ) ; 
line 68530: if ( memRootPage >= 0 ) { 
line 68531: sqlite3VdbeChangeP5 ( v , 1 ) ; 
line 68532: } 
line 68533: sqlite3OpenTable ( pParse , iTab , iDb , pTab , OP_OpenRead ) ; 
line 68534: addr1 = sqlite3VdbeAddOp2 ( v , OP_Rewind , iTab , 0 ) ; 
line 68535: regRecord = sqlite3GetTempReg ( pParse ) ; 
line 68536: regIdxKey = sqlite3GenerateIndexKey ( pParse , pIndex , iTab , regRecord , 1 ) ; 
line 68537: if ( pIndex -> onError != OE_None ) { 
line 68538: const int regRowid = regIdxKey + pIndex -> nColumn ; 
line 68539: const int j2 = sqlite3VdbeCurrentAddr ( v ) + 2 ; 
line 68540: void * const pRegKey = SQLITE_INT_TO_PTR ( regIdxKey ) ; 
line 68551: sqlite3VdbeAddOp4 ( v , OP_IsUnique , iIdx , j2 , regRowid , pRegKey , P4_INT32 ) ; 
line 68552: sqlite3HaltConstraint ( 
line 68553: pParse , OE_Abort , "indexed columns are not unique" , P4_STATIC ) ; 
line 68554: } 
line 68555: sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iIdx , regRecord ) ; 
line 68556: sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ) ; 
line 68557: sqlite3ReleaseTempReg ( pParse , regRecord ) ; 
line 68558: sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr1 + 1 ) ; 
line 68559: sqlite3VdbeJumpHere ( v , addr1 ) ; 
line 68560: sqlite3VdbeAddOp1 ( v , OP_Close , iTab ) ; 
line 68561: sqlite3VdbeAddOp1 ( v , OP_Close , iIdx ) ; 
line 68562: } 
line 68580: SQLITE_PRIVATE Index * sqlite3CreateIndex ( 
line 68581: Parse * pParse , 
line 68582: Token * pName1 , 
line 68583: Token * pName2 , 
line 68584: SrcList * pTblName , 
line 68585: ExprList * pList , 
line 68586: int onError , 
line 68587: Token * pStart , 
line 68588: Token * pEnd , 
line 68589: int sortOrder , 
line 68590: int ifNotExist 
line 68591: ) { 
line 68592: Index * pRet = 0 ; 
line 68593: Table * pTab = 0 ; 
line 68594: Index * pIndex = 0 ; 
line 68595: char * zName = 0 ; 
line 68596: int nName ; 
line 68597: int i , j ; 
line 68598: Token nullId ; 
line 68599: DbFixer sFix ; 
line 68600: int sortOrderMask ; 
line 68601: sqlite3 * db = pParse -> db ; 
line 68602: Db * pDb ; 
line 68603: int iDb ; 
line 68604: Token * pName = 0 ; 
line 68605: struct ExprList_item * pListItem ; 
line 68606: int nCol ; 
line 68607: int nExtra = 0 ; 
line 68608: char * zExtra ; 
line 68610: assert ( pStart == 0 || pEnd != 0 ) ; 
line 68611: assert ( pParse -> nErr == 0 ) ; 
line 68612: if ( db -> mallocFailed || IN_DECLARE_VTAB ) { 
line 68613: goto exit_create_index ; 
line 68614: } 
line 68615: if ( SQLITE_OK != sqlite3ReadSchema ( pParse ) ) { 
line 68616: goto exit_create_index ; 
line 68617: } 
line 68622: if ( pTblName != 0 ) { 
line 68628: assert ( pName1 && pName2 ) ; 
line 68629: iDb = sqlite3TwoPartName ( pParse , pName1 , pName2 , & pName ) ; 
line 68630: if ( iDb < 0 ) goto exit_create_index ; 
line 68632: # ifndef SQLITE_OMIT_TEMPDB 
line 68637: if ( ! db -> init . busy ) { 
line 68638: pTab = sqlite3SrcListLookup ( pParse , pTblName ) ; 
line 68639: if ( pName2 -> n == 0 && pTab && pTab -> pSchema == db -> aDb [ 1 ] . pSchema ) { 
line 68640: iDb = 1 ; 
line 68641: } 
line 68642: } 
line 68643: # endif 
line 68645: if ( sqlite3FixInit ( & sFix , pParse , iDb , "index" , pName ) && 
line 68646: sqlite3FixSrcList ( & sFix , pTblName ) 
line 68647: ) { 
line 68650: assert ( 0 ) ; 
line 68651: } 
line 68652: pTab = sqlite3LocateTable ( pParse , 0 , pTblName -> a [ 0 ] . zName , 
line 68653: pTblName -> a [ 0 ] . zDatabase ) ; 
line 68654: if ( ! pTab || db -> mallocFailed ) goto exit_create_index ; 
line 68655: assert ( db -> aDb [ iDb ] . pSchema == pTab -> pSchema ) ; 
line 68656: } else { 
line 68657: assert ( pName == 0 ) ; 
line 68658: pTab = pParse -> pNewTable ; 
line 68659: if ( ! pTab ) goto exit_create_index ; 
line 68660: iDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; 
line 68661: } 
line 68662: pDb = & db -> aDb [ iDb ] ; 
line 68664: assert ( pTab != 0 ) ; 
line 68665: assert ( pParse -> nErr == 0 ) ; 
line 68666: if ( sqlite3StrNICmp ( pTab -> zName , "sqlite_" , 7 ) == 0 
line 68667: && memcmp ( & pTab -> zName [ 7 ] , "altertab_" , 9 ) != 0 ) { 
line 68668: sqlite3ErrorMsg ( pParse , "table %s may not be indexed" , pTab -> zName ) ; 
line 68669: goto exit_create_index ; 
line 68670: } 
line 68671: # ifndef SQLITE_OMIT_VIEW 
line 68672: if ( pTab -> pSelect ) { 
line 68673: sqlite3ErrorMsg ( pParse , "views may not be indexed" ) ; 
line 68674: goto exit_create_index ; 
line 68675: } 
line 68676: # endif 
line 68677: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 68678: if ( IsVirtual ( pTab ) ) { 
line 68679: sqlite3ErrorMsg ( pParse , "virtual tables may not be indexed" ) ; 
line 68680: goto exit_create_index ; 
line 68681: } 
line 68682: # endif 
line 68697: if ( pName ) { 
line 68698: zName = sqlite3NameFromToken ( db , pName ) ; 
line 68699: if ( zName == 0 ) goto exit_create_index ; 
line 68700: if ( SQLITE_OK != sqlite3CheckObjectName ( pParse , zName ) ) { 
line 68701: goto exit_create_index ; 
line 68702: } 
line 68703: if ( ! db -> init . busy ) { 
line 68704: if ( sqlite3FindTable ( db , zName , 0 ) != 0 ) { 
line 68705: sqlite3ErrorMsg ( pParse , "there is already a table named %s" , zName ) ; 
line 68706: goto exit_create_index ; 
line 68707: } 
line 68708: } 
line 68709: if ( sqlite3FindIndex ( db , zName , pDb -> zName ) != 0 ) { 
line 68710: if ( ! ifNotExist ) { 
line 68711: sqlite3ErrorMsg ( pParse , "index %s already exists" , zName ) ; 
line 68712: } 
line 68713: goto exit_create_index ; 
line 68714: } 
line 68715: } else { 
line 68716: int n ; 
line 68717: Index * pLoop ; 
line 68718: for ( pLoop = pTab -> pIndex , n = 1 ; pLoop ; pLoop = pLoop -> pNext , n ++ ) { } 
line 68719: zName = sqlite3MPrintf ( db , "sqlite_autoindex_%s_%d" , pTab -> zName , n ) ; 
line 68720: if ( zName == 0 ) { 
line 68721: goto exit_create_index ; 
line 68722: } 
line 68723: } 
line 68727: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 68728: { 
line 68729: const char * zDb = pDb -> zName ; 
line 68730: if ( sqlite3AuthCheck ( pParse , SQLITE_INSERT , SCHEMA_TABLE ( iDb ) , 0 , zDb ) ) { 
line 68731: goto exit_create_index ; 
line 68732: } 
line 68733: i = SQLITE_CREATE_INDEX ; 
line 68734: if ( ! OMIT_TEMPDB && iDb == 1 ) i = SQLITE_CREATE_TEMP_INDEX ; 
line 68735: if ( sqlite3AuthCheck ( pParse , i , zName , pTab -> zName , zDb ) ) { 
line 68736: goto exit_create_index ; 
line 68737: } 
line 68738: } 
line 68739: # endif 
line 68745: if ( pList == 0 ) { 
line 68746: nullId . z = pTab -> aCol [ pTab -> nCol - 1 ] . zName ; 
line 68747: nullId . n = sqlite3Strlen30 ( ( char * ) nullId . z ) ; 
line 68748: pList = sqlite3ExprListAppend ( pParse , 0 , 0 ) ; 
line 68749: if ( pList == 0 ) goto exit_create_index ; 
line 68750: sqlite3ExprListSetName ( pParse , pList , & nullId , 0 ) ; 
line 68751: pList -> a [ 0 ] . sortOrder = ( u8 ) sortOrder ; 
line 68752: } 
line 68757: for ( i = 0 ; i < pList -> nExpr ; i ++ ) { 
line 68758: Expr * pExpr = pList -> a [ i ] . pExpr ; 
line 68759: if ( pExpr ) { 
line 68760: CollSeq * pColl = pExpr -> pColl ; 
line 68763: if ( ALWAYS ( pColl ) ) { 
line 68764: nExtra += ( 1 + sqlite3Strlen30 ( pColl -> zName ) ) ; 
line 68765: } 
line 68766: } 
line 68767: } 
line 68772: nName = sqlite3Strlen30 ( zName ) ; 
line 68773: nCol = pList -> nExpr ; 
line 68774: pIndex = sqlite3DbMallocZero ( db , 
line 68775: sizeof ( Index ) + 
line 68776: sizeof ( int ) * nCol + 
line 68777: sizeof ( int ) * ( nCol + 1 ) + 
line 68778: sizeof ( char * ) * nCol + 
line 68779: sizeof ( u8 ) * nCol + 
line 68780: nName + 1 + 
line 68781: nExtra 
line 68782: ) ; 
line 68783: if ( db -> mallocFailed ) { 
line 68784: goto exit_create_index ; 
line 68785: } 
line 68786: pIndex -> azColl = ( char * * ) ( & pIndex [ 1 ] ) ; 
line 68787: pIndex -> aiColumn = ( int * ) ( & pIndex -> azColl [ nCol ] ) ; 
line 68788: pIndex -> aiRowEst = ( unsigned * ) ( & pIndex -> aiColumn [ nCol ] ) ; 
line 68789: pIndex -> aSortOrder = ( u8 * ) ( & pIndex -> aiRowEst [ nCol + 1 ] ) ; 
line 68790: pIndex -> zName = ( char * ) ( & pIndex -> aSortOrder [ nCol ] ) ; 
line 68791: zExtra = ( char * ) ( & pIndex -> zName [ nName + 1 ] ) ; 
line 68792: memcpy ( pIndex -> zName , zName , nName + 1 ) ; 
line 68793: pIndex -> pTable = pTab ; 
line 68794: pIndex -> nColumn = pList -> nExpr ; 
line 68795: pIndex -> onError = ( u8 ) onError ; 
line 68796: pIndex -> autoIndex = ( u8 ) ( pName == 0 ) ; 
line 68797: pIndex -> pSchema = db -> aDb [ iDb ] . pSchema ; 
line 68801: if ( pDb -> pSchema -> file_format >= 4 ) { 
line 68802: sortOrderMask = - 1 ; 
line 68803: } else { 
line 68804: sortOrderMask = 0 ; 
line 68805: } 
line 68817: for ( i = 0 , pListItem = pList -> a ; i < pList -> nExpr ; i ++ , pListItem ++ ) { 
line 68818: const char * zColName = pListItem -> zName ; 
line 68819: Column * pTabCol ; 
line 68820: int requestedSortOrder ; 
line 68821: char * zColl ; 
line 68823: for ( j = 0 , pTabCol = pTab -> aCol ; j < pTab -> nCol ; j ++ , pTabCol ++ ) { 
line 68824: if ( sqlite3StrICmp ( zColName , pTabCol -> zName ) == 0 ) break ; 
line 68825: } 
line 68826: if ( j >= pTab -> nCol ) { 
line 68827: sqlite3ErrorMsg ( pParse , "table %s has no column named %s" , 
line 68828: pTab -> zName , zColName ) ; 
line 68829: goto exit_create_index ; 
line 68830: } 
line 68831: pIndex -> aiColumn [ i ] = j ; 
line 68837: if ( pListItem -> pExpr && ALWAYS ( pListItem -> pExpr -> pColl ) ) { 
line 68838: int nColl ; 
line 68839: zColl = pListItem -> pExpr -> pColl -> zName ; 
line 68840: nColl = sqlite3Strlen30 ( zColl ) + 1 ; 
line 68841: assert ( nExtra >= nColl ) ; 
line 68842: memcpy ( zExtra , zColl , nColl ) ; 
line 68843: zColl = zExtra ; 
line 68844: zExtra += nColl ; 
line 68845: nExtra -= nColl ; 
line 68846: } else { 
line 68847: zColl = pTab -> aCol [ j ] . zColl ; 
line 68848: if ( ! zColl ) { 
line 68849: zColl = db -> pDfltColl -> zName ; 
line 68850: } 
line 68851: } 
line 68852: if ( ! db -> init . busy && ! sqlite3LocateCollSeq ( pParse , zColl ) ) { 
line 68853: goto exit_create_index ; 
line 68854: } 
line 68855: pIndex -> azColl [ i ] = zColl ; 
line 68856: requestedSortOrder = pListItem -> sortOrder & sortOrderMask ; 
line 68857: pIndex -> aSortOrder [ i ] = ( u8 ) requestedSortOrder ; 
line 68858: } 
line 68859: sqlite3DefaultRowEst ( pIndex ) ; 
line 68861: if ( pTab == pParse -> pNewTable ) { 
line 68883: Index * pIdx ; 
line 68884: for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { 
line 68885: int k ; 
line 68886: assert ( pIdx -> onError != OE_None ) ; 
line 68887: assert ( pIdx -> autoIndex ) ; 
line 68888: assert ( pIndex -> onError != OE_None ) ; 
line 68890: if ( pIdx -> nColumn != pIndex -> nColumn ) continue ; 
line 68891: for ( k = 0 ; k < pIdx -> nColumn ; k ++ ) { 
line 68892: const char * z1 ; 
line 68893: const char * z2 ; 
line 68894: if ( pIdx -> aiColumn [ k ] != pIndex -> aiColumn [ k ] ) break ; 
line 68895: z1 = pIdx -> azColl [ k ] ; 
line 68896: z2 = pIndex -> azColl [ k ] ; 
line 68897: if ( z1 != z2 && sqlite3StrICmp ( z1 , z2 ) ) break ; 
line 68898: } 
line 68899: if ( k == pIdx -> nColumn ) { 
line 68900: if ( pIdx -> onError != pIndex -> onError ) { 
line 68908: if ( ! ( pIdx -> onError == OE_Default || pIndex -> onError == OE_Default ) ) { 
line 68909: sqlite3ErrorMsg ( pParse , 
line 68910: "conflicting ON CONFLICT clauses specified" , 0 ) ; 
line 68911: } 
line 68912: if ( pIdx -> onError == OE_Default ) { 
line 68913: pIdx -> onError = pIndex -> onError ; 
line 68914: } 
line 68915: } 
line 68916: goto exit_create_index ; 
line 68917: } 
line 68918: } 
line 68919: } 
line 68924: if ( db -> init . busy ) { 
line 68925: Index * p ; 
line 68926: p = sqlite3HashInsert ( & pIndex -> pSchema -> idxHash , 
line 68927: pIndex -> zName , sqlite3Strlen30 ( pIndex -> zName ) , 
line 68928: pIndex ) ; 
line 68929: if ( p ) { 
line 68930: assert ( p == pIndex ) ; 
line 68931: db -> mallocFailed = 1 ; 
line 68932: goto exit_create_index ; 
line 68933: } 
line 68934: db -> flags |= SQLITE_InternChanges ; 
line 68935: if ( pTblName != 0 ) { 
line 68936: pIndex -> tnum = db -> init . newTnum ; 
line 68937: } 
line 68938: } 
line 68955: else { 
line 68956: Vdbe * v ; 
line 68957: char * zStmt ; 
line 68958: int iMem = ++ pParse -> nMem ; 
line 68960: v = sqlite3GetVdbe ( pParse ) ; 
line 68961: if ( v == 0 ) goto exit_create_index ; 
line 68966: sqlite3BeginWriteOperation ( pParse , 1 , iDb ) ; 
line 68967: sqlite3VdbeAddOp2 ( v , OP_CreateIndex , iDb , iMem ) ; 
line 68972: if ( pStart ) { 
line 68973: assert ( pEnd != 0 ) ; 
line 68975: zStmt = sqlite3MPrintf ( db , "CREATE%s INDEX %.*s" , 
line 68976: onError == OE_None ? "" : " UNIQUE" , 
line 68977: pEnd -> z - pName -> z + 1 , 
line 68978: pName -> z ) ; 
line 68979: } else { 
line 68982: zStmt = 0 ; 
line 68983: } 
line 68987: sqlite3NestedParse ( pParse , 
line 68988: "INSERT INTO %Q.%s VALUES('index',%Q,%Q,#%d,%Q);" , 
line 68989: db -> aDb [ iDb ] . zName , SCHEMA_TABLE ( iDb ) , 
line 68990: pIndex -> zName , 
line 68991: pTab -> zName , 
line 68992: iMem , 
line 68993: zStmt 
line 68994: ) ; 
line 68995: sqlite3DbFree ( db , zStmt ) ; 
line 69000: if ( pTblName ) { 
line 69001: sqlite3RefillIndex ( pParse , pIndex , iMem ) ; 
line 69002: sqlite3ChangeCookie ( pParse , iDb ) ; 
line 69003: sqlite3VdbeAddOp4 ( v , OP_ParseSchema , iDb , 0 , 0 , 
line 69004: sqlite3MPrintf ( db , "name='%q'" , pIndex -> zName ) , P4_DYNAMIC ) ; 
line 69005: sqlite3VdbeAddOp1 ( v , OP_Expire , 0 ) ; 
line 69006: } 
line 69007: } 
line 69015: if ( db -> init . busy || pTblName == 0 ) { 
line 69016: if ( onError != OE_Replace || pTab -> pIndex == 0 
line 69017: || pTab -> pIndex -> onError == OE_Replace ) { 
line 69018: pIndex -> pNext = pTab -> pIndex ; 
line 69019: pTab -> pIndex = pIndex ; 
line 69020: } else { 
line 69021: Index * pOther = pTab -> pIndex ; 
line 69022: while ( pOther -> pNext && pOther -> pNext -> onError != OE_Replace ) { 
line 69023: pOther = pOther -> pNext ; 
line 69024: } 
line 69025: pIndex -> pNext = pOther -> pNext ; 
line 69026: pOther -> pNext = pIndex ; 
line 69027: } 
line 69028: pRet = pIndex ; 
line 69029: pIndex = 0 ; 
line 69030: } 
line 69033: exit_create_index : 
line 69034: if ( pIndex ) { 
line 69035: sqlite3_free ( pIndex -> zColAff ) ; 
line 69036: sqlite3DbFree ( db , pIndex ) ; 
line 69037: } 
line 69038: sqlite3ExprListDelete ( db , pList ) ; 
line 69039: sqlite3SrcListDelete ( db , pTblName ) ; 
line 69040: sqlite3DbFree ( db , zName ) ; 
line 69041: return pRet ; 
line 69042: } 
line 69062: SQLITE_PRIVATE void sqlite3DefaultRowEst ( Index * pIdx ) { 
line 69063: unsigned * a = pIdx -> aiRowEst ; 
line 69064: int i ; 
line 69065: assert ( a != 0 ) ; 
line 69066: a [ 0 ] = 1000000 ; 
line 69067: for ( i = pIdx -> nColumn ; i >= 5 ; i -- ) { 
line 69068: a [ i ] = 5 ; 
line 69069: } 
line 69070: while ( i >= 1 ) { 
line 69071: a [ i ] = 11 - i ; 
line 69072: i -- ; 
line 69073: } 
line 69074: if ( pIdx -> onError != OE_None ) { 
line 69075: a [ pIdx -> nColumn ] = 1 ; 
line 69076: } 
line 69077: } 
line 69083: SQLITE_PRIVATE void sqlite3DropIndex ( Parse * pParse , SrcList * pName , int ifExists ) { 
line 69084: Index * pIndex ; 
line 69085: Vdbe * v ; 
line 69086: sqlite3 * db = pParse -> db ; 
line 69087: int iDb ; 
line 69089: assert ( pParse -> nErr == 0 ) ; 
line 69090: if ( db -> mallocFailed ) { 
line 69091: goto exit_drop_index ; 
line 69092: } 
line 69093: assert ( pName -> nSrc == 1 ) ; 
line 69094: if ( SQLITE_OK != sqlite3ReadSchema ( pParse ) ) { 
line 69095: goto exit_drop_index ; 
line 69096: } 
line 69097: pIndex = sqlite3FindIndex ( db , pName -> a [ 0 ] . zName , pName -> a [ 0 ] . zDatabase ) ; 
line 69098: if ( pIndex == 0 ) { 
line 69099: if ( ! ifExists ) { 
line 69100: sqlite3ErrorMsg ( pParse , "no such index: %S" , pName , 0 ) ; 
line 69101: } 
line 69102: pParse -> checkSchema = 1 ; 
line 69103: goto exit_drop_index ; 
line 69104: } 
line 69105: if ( pIndex -> autoIndex ) { 
line 69106: sqlite3ErrorMsg ( pParse , "index associated with UNIQUE " 
line 69107: "or PRIMARY KEY constraint cannot be dropped" , 0 ) ; 
line 69108: goto exit_drop_index ; 
line 69109: } 
line 69110: iDb = sqlite3SchemaToIndex ( db , pIndex -> pSchema ) ; 
line 69111: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 69112: { 
line 69113: int code = SQLITE_DROP_INDEX ; 
line 69114: Table * pTab = pIndex -> pTable ; 
line 69115: const char * zDb = db -> aDb [ iDb ] . zName ; 
line 69116: const char * zTab = SCHEMA_TABLE ( iDb ) ; 
line 69117: if ( sqlite3AuthCheck ( pParse , SQLITE_DELETE , zTab , 0 , zDb ) ) { 
line 69118: goto exit_drop_index ; 
line 69119: } 
line 69120: if ( ! OMIT_TEMPDB && iDb ) code = SQLITE_DROP_TEMP_INDEX ; 
line 69121: if ( sqlite3AuthCheck ( pParse , code , pIndex -> zName , pTab -> zName , zDb ) ) { 
line 69122: goto exit_drop_index ; 
line 69123: } 
line 69124: } 
line 69125: # endif 
line 69128: v = sqlite3GetVdbe ( pParse ) ; 
line 69129: if ( v ) { 
line 69130: sqlite3BeginWriteOperation ( pParse , 1 , iDb ) ; 
line 69131: sqlite3NestedParse ( pParse , 
line 69132: "DELETE FROM %Q.%s WHERE name=%Q" , 
line 69133: db -> aDb [ iDb ] . zName , SCHEMA_TABLE ( iDb ) , 
line 69134: pIndex -> zName 
line 69135: ) ; 
line 69136: if ( sqlite3FindTable ( db , "sqlite_stat1" , db -> aDb [ iDb ] . zName ) ) { 
line 69137: sqlite3NestedParse ( pParse , 
line 69138: "DELETE FROM %Q.sqlite_stat1 WHERE idx=%Q" , 
line 69139: db -> aDb [ iDb ] . zName , pIndex -> zName 
line 69140: ) ; 
line 69141: } 
line 69142: sqlite3ChangeCookie ( pParse , iDb ) ; 
line 69143: destroyRootPage ( pParse , pIndex -> tnum , iDb ) ; 
line 69144: sqlite3VdbeAddOp4 ( v , OP_DropIndex , iDb , 0 , 0 , pIndex -> zName , 0 ) ; 
line 69145: } 
line 69147: exit_drop_index : 
line 69148: sqlite3SrcListDelete ( db , pName ) ; 
line 69149: } 
line 69166: SQLITE_PRIVATE void * sqlite3ArrayAllocate ( 
line 69167: sqlite3 * db , 
line 69168: void * pArray , 
line 69169: int szEntry , 
line 69170: int initSize , 
line 69171: int * pnEntry , 
line 69172: int * pnAlloc , 
line 69173: int * pIdx 
line 69174: ) { 
line 69175: char * z ; 
line 69176: if ( * pnEntry >= * pnAlloc ) { 
line 69177: void * pNew ; 
line 69178: int newSize ; 
line 69179: newSize = ( * pnAlloc ) * 2 + initSize ; 
line 69180: pNew = sqlite3DbRealloc ( db , pArray , newSize * szEntry ) ; 
line 69181: if ( pNew == 0 ) { 
line 69182: * pIdx = - 1 ; 
line 69183: return pArray ; 
line 69184: } 
line 69185: * pnAlloc = sqlite3DbMallocSize ( db , pNew ) / szEntry ; 
line 69186: pArray = pNew ; 
line 69187: } 
line 69188: z = ( char * ) pArray ; 
line 69189: memset ( & z [ * pnEntry * szEntry ] , 0 , szEntry ) ; 
line 69190: * pIdx = * pnEntry ; 
line 69191: ++ * pnEntry ; 
line 69192: return pArray ; 
line 69193: } 
line 69201: SQLITE_PRIVATE IdList * sqlite3IdListAppend ( sqlite3 * db , IdList * pList , Token * pToken ) { 
line 69202: int i ; 
line 69203: if ( pList == 0 ) { 
line 69204: pList = sqlite3DbMallocZero ( db , sizeof ( IdList ) ) ; 
line 69205: if ( pList == 0 ) return 0 ; 
line 69206: pList -> nAlloc = 0 ; 
line 69207: } 
line 69208: pList -> a = sqlite3ArrayAllocate ( 
line 69209: db , 
line 69210: pList -> a , 
line 69211: sizeof ( pList -> a [ 0 ] ) , 
line 69212: 5 , 
line 69213: & pList -> nId , 
line 69214: & pList -> nAlloc , 
line 69215: & i 
line 69216: ) ; 
line 69217: if ( i < 0 ) { 
line 69218: sqlite3IdListDelete ( db , pList ) ; 
line 69219: return 0 ; 
line 69220: } 
line 69221: pList -> a [ i ] . zName = sqlite3NameFromToken ( db , pToken ) ; 
line 69222: return pList ; 
line 69223: } 
line 69228: SQLITE_PRIVATE void sqlite3IdListDelete ( sqlite3 * db , IdList * pList ) { 
line 69229: int i ; 
line 69230: if ( pList == 0 ) return ; 
line 69231: for ( i = 0 ; i < pList -> nId ; i ++ ) { 
line 69232: sqlite3DbFree ( db , pList -> a [ i ] . zName ) ; 
line 69233: } 
line 69234: sqlite3DbFree ( db , pList -> a ) ; 
line 69235: sqlite3DbFree ( db , pList ) ; 
line 69236: } 
line 69242: SQLITE_PRIVATE int sqlite3IdListIndex ( IdList * pList , const char * zName ) { 
line 69243: int i ; 
line 69244: if ( pList == 0 ) return - 1 ; 
line 69245: for ( i = 0 ; i < pList -> nId ; i ++ ) { 
line 69246: if ( sqlite3StrICmp ( pList -> a [ i ] . zName , zName ) == 0 ) return i ; 
line 69247: } 
line 69248: return - 1 ; 
line 69249: } 
line 69270: SQLITE_PRIVATE SrcList * sqlite3SrcListEnlarge ( 
line 69271: sqlite3 * db , 
line 69272: SrcList * pSrc , 
line 69273: int nExtra , 
line 69274: int iStart 
line 69275: ) { 
line 69276: int i ; 
line 69279: assert ( iStart >= 0 ) ; 
line 69280: assert ( nExtra >= 1 ) ; 
line 69281: assert ( pSrc != 0 ) ; 
line 69282: assert ( iStart <= pSrc -> nSrc ) ; 
line 69285: if ( pSrc -> nSrc + nExtra > pSrc -> nAlloc ) { 
line 69286: SrcList * pNew ; 
line 69287: int nAlloc = pSrc -> nSrc + nExtra ; 
line 69288: int nGot ; 
line 69289: pNew = sqlite3DbRealloc ( db , pSrc , 
line 69290: sizeof ( * pSrc ) + ( nAlloc - 1 ) * sizeof ( pSrc -> a [ 0 ] ) ) ; 
line 69291: if ( pNew == 0 ) { 
line 69292: assert ( db -> mallocFailed ) ; 
line 69293: return pSrc ; 
line 69294: } 
line 69295: pSrc = pNew ; 
line 69296: nGot = ( sqlite3DbMallocSize ( db , pNew ) - sizeof ( * pSrc ) ) / sizeof ( pSrc -> a [ 0 ] ) + 1 ; 
line 69297: pSrc -> nAlloc = ( u16 ) nGot ; 
line 69298: } 
line 69302: for ( i = pSrc -> nSrc - 1 ; i >= iStart ; i -- ) { 
line 69303: pSrc -> a [ i + nExtra ] = pSrc -> a [ i ] ; 
line 69304: } 
line 69305: pSrc -> nSrc += ( i16 ) nExtra ; 
line 69308: memset ( & pSrc -> a [ iStart ] , 0 , sizeof ( pSrc -> a [ 0 ] ) * nExtra ) ; 
line 69309: for ( i = iStart ; i < iStart + nExtra ; i ++ ) { 
line 69310: pSrc -> a [ i ] . iCursor = - 1 ; 
line 69311: } 
line 69314: return pSrc ; 
line 69315: } 
line 69352: SQLITE_PRIVATE SrcList * sqlite3SrcListAppend ( 
line 69353: sqlite3 * db , 
line 69354: SrcList * pList , 
line 69355: Token * pTable , 
line 69356: Token * pDatabase 
line 69357: ) { 
line 69358: struct SrcList_item * pItem ; 
line 69359: assert ( pDatabase == 0 || pTable != 0 ) ; 
line 69360: if ( pList == 0 ) { 
line 69361: pList = sqlite3DbMallocZero ( db , sizeof ( SrcList ) ) ; 
line 69362: if ( pList == 0 ) return 0 ; 
line 69363: pList -> nAlloc = 1 ; 
line 69364: } 
line 69365: pList = sqlite3SrcListEnlarge ( db , pList , 1 , pList -> nSrc ) ; 
line 69366: if ( db -> mallocFailed ) { 
line 69367: sqlite3SrcListDelete ( db , pList ) ; 
line 69368: return 0 ; 
line 69369: } 
line 69370: pItem = & pList -> a [ pList -> nSrc - 1 ] ; 
line 69371: if ( pDatabase && pDatabase -> z == 0 ) { 
line 69372: pDatabase = 0 ; 
line 69373: } 
line 69374: if ( pDatabase ) { 
line 69375: Token * pTemp = pDatabase ; 
line 69376: pDatabase = pTable ; 
line 69377: pTable = pTemp ; 
line 69378: } 
line 69379: pItem -> zName = sqlite3NameFromToken ( db , pTable ) ; 
line 69380: pItem -> zDatabase = sqlite3NameFromToken ( db , pDatabase ) ; 
line 69381: return pList ; 
line 69382: } 
line 69387: SQLITE_PRIVATE void sqlite3SrcListAssignCursors ( Parse * pParse , SrcList * pList ) { 
line 69388: int i ; 
line 69389: struct SrcList_item * pItem ; 
line 69390: assert ( pList || pParse -> db -> mallocFailed ) ; 
line 69391: if ( pList ) { 
line 69392: for ( i = 0 , pItem = pList -> a ; i < pList -> nSrc ; i ++ , pItem ++ ) { 
line 69393: if ( pItem -> iCursor >= 0 ) break ; 
line 69394: pItem -> iCursor = pParse -> nTab ++ ; 
line 69395: if ( pItem -> pSelect ) { 
line 69396: sqlite3SrcListAssignCursors ( pParse , pItem -> pSelect -> pSrc ) ; 
line 69397: } 
line 69398: } 
line 69399: } 
line 69400: } 
line 69405: SQLITE_PRIVATE void sqlite3SrcListDelete ( sqlite3 * db , SrcList * pList ) { 
line 69406: int i ; 
line 69407: struct SrcList_item * pItem ; 
line 69408: if ( pList == 0 ) return ; 
line 69409: for ( pItem = pList -> a , i = 0 ; i < pList -> nSrc ; i ++ , pItem ++ ) { 
line 69410: sqlite3DbFree ( db , pItem -> zDatabase ) ; 
line 69411: sqlite3DbFree ( db , pItem -> zName ) ; 
line 69412: sqlite3DbFree ( db , pItem -> zAlias ) ; 
line 69413: sqlite3DbFree ( db , pItem -> zIndex ) ; 
line 69414: sqlite3DeleteTable ( pItem -> pTab ) ; 
line 69415: sqlite3SelectDelete ( db , pItem -> pSelect ) ; 
line 69416: sqlite3ExprDelete ( db , pItem -> pOn ) ; 
line 69417: sqlite3IdListDelete ( db , pItem -> pUsing ) ; 
line 69418: } 
line 69419: sqlite3DbFree ( db , pList ) ; 
line 69420: } 
line 69438: SQLITE_PRIVATE SrcList * sqlite3SrcListAppendFromTerm ( 
line 69439: Parse * pParse , 
line 69440: SrcList * p , 
line 69441: Token * pTable , 
line 69442: Token * pDatabase , 
line 69443: Token * pAlias , 
line 69444: Select * pSubquery , 
line 69445: Expr * pOn , 
line 69446: IdList * pUsing 
line 69447: ) { 
line 69448: struct SrcList_item * pItem ; 
line 69449: sqlite3 * db = pParse -> db ; 
line 69450: if ( ! p && ( pOn || pUsing ) ) { 
line 69451: sqlite3ErrorMsg ( pParse , "a JOIN clause is required before %s" , 
line 69452: ( pOn ? "ON" : "USING" ) 
line 69453: ) ; 
line 69454: goto append_from_error ; 
line 69455: } 
line 69456: p = sqlite3SrcListAppend ( db , p , pTable , pDatabase ) ; 
line 69457: if ( p == 0 || NEVER ( p -> nSrc == 0 ) ) { 
line 69458: goto append_from_error ; 
line 69459: } 
line 69460: pItem = & p -> a [ p -> nSrc - 1 ] ; 
line 69461: assert ( pAlias != 0 ) ; 
line 69462: if ( pAlias -> n ) { 
line 69463: pItem -> zAlias = sqlite3NameFromToken ( db , pAlias ) ; 
line 69464: } 
line 69465: pItem -> pSelect = pSubquery ; 
line 69466: pItem -> pOn = pOn ; 
line 69467: pItem -> pUsing = pUsing ; 
line 69468: return p ; 
line 69470: append_from_error : 
line 69471: assert ( p == 0 ) ; 
line 69472: sqlite3ExprDelete ( db , pOn ) ; 
line 69473: sqlite3IdListDelete ( db , pUsing ) ; 
line 69474: sqlite3SelectDelete ( db , pSubquery ) ; 
line 69475: return 0 ; 
line 69476: } 
line 69482: SQLITE_PRIVATE void sqlite3SrcListIndexedBy ( Parse * pParse , SrcList * p , Token * pIndexedBy ) { 
line 69483: assert ( pIndexedBy != 0 ) ; 
line 69484: if ( p && ALWAYS ( p -> nSrc > 0 ) ) { 
line 69485: struct SrcList_item * pItem = & p -> a [ p -> nSrc - 1 ] ; 
line 69486: assert ( pItem -> notIndexed == 0 && pItem -> zIndex == 0 ) ; 
line 69487: if ( pIndexedBy -> n == 1 && ! pIndexedBy -> z ) { 
line 69490: pItem -> notIndexed = 1 ; 
line 69491: } else { 
line 69492: pItem -> zIndex = sqlite3NameFromToken ( pParse -> db , pIndexedBy ) ; 
line 69493: } 
line 69494: } 
line 69495: } 
line 69512: SQLITE_PRIVATE void sqlite3SrcListShiftJoinType ( SrcList * p ) { 
line 69513: if ( p && p -> a ) { 
line 69514: int i ; 
line 69515: for ( i = p -> nSrc - 1 ; i > 0 ; i -- ) { 
line 69516: p -> a [ i ] . jointype = p -> a [ i - 1 ] . jointype ; 
line 69517: } 
line 69518: p -> a [ 0 ] . jointype = 0 ; 
line 69519: } 
line 69520: } 
line 69525: SQLITE_PRIVATE void sqlite3BeginTransaction ( Parse * pParse , int type ) { 
line 69526: sqlite3 * db ; 
line 69527: Vdbe * v ; 
line 69528: int i ; 
line 69530: assert ( pParse != 0 ) ; 
line 69531: db = pParse -> db ; 
line 69532: assert ( db != 0 ) ; 
line 69534: if ( sqlite3AuthCheck ( pParse , SQLITE_TRANSACTION , "BEGIN" , 0 , 0 ) ) { 
line 69535: return ; 
line 69536: } 
line 69537: v = sqlite3GetVdbe ( pParse ) ; 
line 69538: if ( ! v ) return ; 
line 69539: if ( type != TK_DEFERRED ) { 
line 69540: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 69541: sqlite3VdbeAddOp2 ( v , OP_Transaction , i , ( type == TK_EXCLUSIVE ) + 1 ) ; 
line 69542: sqlite3VdbeUsesBtree ( v , i ) ; 
line 69543: } 
line 69544: } 
line 69545: sqlite3VdbeAddOp2 ( v , OP_AutoCommit , 0 , 0 ) ; 
line 69546: } 
line 69551: SQLITE_PRIVATE void sqlite3CommitTransaction ( Parse * pParse ) { 
line 69552: sqlite3 * db ; 
line 69553: Vdbe * v ; 
line 69555: assert ( pParse != 0 ) ; 
line 69556: db = pParse -> db ; 
line 69557: assert ( db != 0 ) ; 
line 69559: if ( sqlite3AuthCheck ( pParse , SQLITE_TRANSACTION , "COMMIT" , 0 , 0 ) ) { 
line 69560: return ; 
line 69561: } 
line 69562: v = sqlite3GetVdbe ( pParse ) ; 
line 69563: if ( v ) { 
line 69564: sqlite3VdbeAddOp2 ( v , OP_AutoCommit , 1 , 0 ) ; 
line 69565: } 
line 69566: } 
line 69571: SQLITE_PRIVATE void sqlite3RollbackTransaction ( Parse * pParse ) { 
line 69572: sqlite3 * db ; 
line 69573: Vdbe * v ; 
line 69575: assert ( pParse != 0 ) ; 
line 69576: db = pParse -> db ; 
line 69577: assert ( db != 0 ) ; 
line 69579: if ( sqlite3AuthCheck ( pParse , SQLITE_TRANSACTION , "ROLLBACK" , 0 , 0 ) ) { 
line 69580: return ; 
line 69581: } 
line 69582: v = sqlite3GetVdbe ( pParse ) ; 
line 69583: if ( v ) { 
line 69584: sqlite3VdbeAddOp2 ( v , OP_AutoCommit , 1 , 1 ) ; 
line 69585: } 
line 69586: } 
line 69592: SQLITE_PRIVATE void sqlite3Savepoint ( Parse * pParse , int op , Token * pName ) { 
line 69593: char * zName = sqlite3NameFromToken ( pParse -> db , pName ) ; 
line 69594: if ( zName ) { 
line 69595: Vdbe * v = sqlite3GetVdbe ( pParse ) ; 
line 69596: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 69597: static const char * az [ ] = { "BEGIN" , "RELEASE" , "ROLLBACK" } ; 
line 69598: assert ( ! SAVEPOINT_BEGIN && SAVEPOINT_RELEASE == 1 && SAVEPOINT_ROLLBACK == 2 ) ; 
line 69599: # endif 
line 69600: if ( ! v || sqlite3AuthCheck ( pParse , SQLITE_SAVEPOINT , az [ op ] , zName , 0 ) ) { 
line 69601: sqlite3DbFree ( pParse -> db , zName ) ; 
line 69602: return ; 
line 69603: } 
line 69604: sqlite3VdbeAddOp4 ( v , OP_Savepoint , op , 0 , 0 , zName , P4_DYNAMIC ) ; 
line 69605: } 
line 69606: } 
line 69612: SQLITE_PRIVATE int sqlite3OpenTempDatabase ( Parse * pParse ) { 
line 69613: sqlite3 * db = pParse -> db ; 
line 69614: if ( db -> aDb [ 1 ] . pBt == 0 && ! pParse -> explain ) { 
line 69615: int rc ; 
line 69616: static const int flags = 
line 69617: SQLITE_OPEN_READWRITE | 
line 69618: SQLITE_OPEN_CREATE | 
line 69619: SQLITE_OPEN_EXCLUSIVE | 
line 69620: SQLITE_OPEN_DELETEONCLOSE | 
line 69621: SQLITE_OPEN_TEMP_DB ; 
line 69623: rc = sqlite3BtreeFactory ( db , 0 , 0 , SQLITE_DEFAULT_CACHE_SIZE , flags , 
line 69624: & db -> aDb [ 1 ] . pBt ) ; 
line 69625: if ( rc != SQLITE_OK ) { 
line 69626: sqlite3ErrorMsg ( pParse , "unable to open a temporary database " 
line 69627: "file for storing temporary tables" ) ; 
line 69628: pParse -> rc = rc ; 
line 69629: return 1 ; 
line 69630: } 
line 69631: assert ( db -> aDb [ 1 ] . pSchema ) ; 
line 69632: sqlite3PagerJournalMode ( sqlite3BtreePager ( db -> aDb [ 1 ] . pBt ) , 
line 69633: db -> dfltJournalMode ) ; 
line 69634: } 
line 69635: return 0 ; 
line 69636: } 
line 69660: SQLITE_PRIVATE void sqlite3CodeVerifySchema ( Parse * pParse , int iDb ) { 
line 69661: Parse * pToplevel = sqlite3ParseToplevel ( pParse ) ; 
line 69663: if ( pToplevel -> cookieGoto == 0 ) { 
line 69664: Vdbe * v = sqlite3GetVdbe ( pToplevel ) ; 
line 69665: if ( v == 0 ) return ; 
line 69666: pToplevel -> cookieGoto = sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , 0 ) + 1 ; 
line 69667: } 
line 69668: if ( iDb >= 0 ) { 
line 69669: sqlite3 * db = pToplevel -> db ; 
line 69670: int mask ; 
line 69672: assert ( iDb < db -> nDb ) ; 
line 69673: assert ( db -> aDb [ iDb ] . pBt != 0 || iDb == 1 ) ; 
line 69674: assert ( iDb < SQLITE_MAX_ATTACHED + 2 ) ; 
line 69675: mask = 1 << iDb ; 
line 69676: if ( ( pToplevel -> cookieMask & mask ) == 0 ) { 
line 69677: pToplevel -> cookieMask |= mask ; 
line 69678: pToplevel -> cookieValue [ iDb ] = db -> aDb [ iDb ] . pSchema -> schema_cookie ; 
line 69679: if ( ! OMIT_TEMPDB && iDb == 1 ) { 
line 69680: sqlite3OpenTempDatabase ( pToplevel ) ; 
line 69681: } 
line 69682: } 
line 69683: } 
line 69684: } 
line 69699: SQLITE_PRIVATE void sqlite3BeginWriteOperation ( Parse * pParse , int setStatement , int iDb ) { 
line 69700: Parse * pToplevel = sqlite3ParseToplevel ( pParse ) ; 
line 69701: sqlite3CodeVerifySchema ( pParse , iDb ) ; 
line 69702: pToplevel -> writeMask |= 1 << iDb ; 
line 69703: pToplevel -> isMultiWrite |= setStatement ; 
line 69704: } 
line 69713: SQLITE_PRIVATE void sqlite3MultiWrite ( Parse * pParse ) { 
line 69714: Parse * pToplevel = sqlite3ParseToplevel ( pParse ) ; 
line 69715: pToplevel -> isMultiWrite = 1 ; 
line 69716: } 
line 69734: SQLITE_PRIVATE void sqlite3MayAbort ( Parse * pParse ) { 
line 69735: Parse * pToplevel = sqlite3ParseToplevel ( pParse ) ; 
line 69736: pToplevel -> mayAbort = 1 ; 
line 69737: } 
line 69744: SQLITE_PRIVATE void sqlite3HaltConstraint ( Parse * pParse , int onError , char * p4 , int p4type ) { 
line 69745: Vdbe * v = sqlite3GetVdbe ( pParse ) ; 
line 69746: if ( onError == OE_Abort ) { 
line 69747: sqlite3MayAbort ( pParse ) ; 
line 69748: } 
line 69749: sqlite3VdbeAddOp4 ( v , OP_Halt , SQLITE_CONSTRAINT , onError , 0 , p4 , p4type ) ; 
line 69750: } 
line 69756: # ifndef SQLITE_OMIT_REINDEX 
line 69757: static int collationMatch ( const char * zColl , Index * pIndex ) { 
line 69758: int i ; 
line 69759: assert ( zColl != 0 ) ; 
line 69760: for ( i = 0 ; i < pIndex -> nColumn ; i ++ ) { 
line 69761: const char * z = pIndex -> azColl [ i ] ; 
line 69762: assert ( z != 0 ) ; 
line 69763: if ( 0 == sqlite3StrICmp ( z , zColl ) ) { 
line 69764: return 1 ; 
line 69765: } 
line 69766: } 
line 69767: return 0 ; 
line 69768: } 
line 69769: # endif 
line 69775: # ifndef SQLITE_OMIT_REINDEX 
line 69776: static void reindexTable ( Parse * pParse , Table * pTab , char const * zColl ) { 
line 69777: Index * pIndex ; 
line 69779: for ( pIndex = pTab -> pIndex ; pIndex ; pIndex = pIndex -> pNext ) { 
line 69780: if ( zColl == 0 || collationMatch ( zColl , pIndex ) ) { 
line 69781: int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; 
line 69782: sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; 
line 69783: sqlite3RefillIndex ( pParse , pIndex , - 1 ) ; 
line 69784: } 
line 69785: } 
line 69786: } 
line 69787: # endif 
line 69794: # ifndef SQLITE_OMIT_REINDEX 
line 69795: static void reindexDatabases ( Parse * pParse , char const * zColl ) { 
line 69796: Db * pDb ; 
line 69797: int iDb ; 
line 69798: sqlite3 * db = pParse -> db ; 
line 69799: HashElem * k ; 
line 69800: Table * pTab ; 
line 69802: for ( iDb = 0 , pDb = db -> aDb ; iDb < db -> nDb ; iDb ++ , pDb ++ ) { 
line 69803: assert ( pDb != 0 ) ; 
line 69804: for ( k = sqliteHashFirst ( & pDb -> pSchema -> tblHash ) ; k ; k = sqliteHashNext ( k ) ) { 
line 69805: pTab = ( Table * ) sqliteHashData ( k ) ; 
line 69806: reindexTable ( pParse , pTab , zColl ) ; 
line 69807: } 
line 69808: } 
line 69809: } 
line 69810: # endif 
line 69825: # ifndef SQLITE_OMIT_REINDEX 
line 69826: SQLITE_PRIVATE void sqlite3Reindex ( Parse * pParse , Token * pName1 , Token * pName2 ) { 
line 69827: CollSeq * pColl ; 
line 69828: char * z ; 
line 69829: const char * zDb ; 
line 69830: Table * pTab ; 
line 69831: Index * pIndex ; 
line 69832: int iDb ; 
line 69833: sqlite3 * db = pParse -> db ; 
line 69834: Token * pObjName ; 
line 69838: if ( SQLITE_OK != sqlite3ReadSchema ( pParse ) ) { 
line 69839: return ; 
line 69840: } 
line 69842: if ( pName1 == 0 ) { 
line 69843: reindexDatabases ( pParse , 0 ) ; 
line 69844: return ; 
line 69845: } else if ( NEVER ( pName2 == 0 ) || pName2 -> z == 0 ) { 
line 69846: char * zColl ; 
line 69847: assert ( pName1 -> z ) ; 
line 69848: zColl = sqlite3NameFromToken ( pParse -> db , pName1 ) ; 
line 69849: if ( ! zColl ) return ; 
line 69850: pColl = sqlite3FindCollSeq ( db , ENC ( db ) , zColl , 0 ) ; 
line 69851: if ( pColl ) { 
line 69852: reindexDatabases ( pParse , zColl ) ; 
line 69853: sqlite3DbFree ( db , zColl ) ; 
line 69854: return ; 
line 69855: } 
line 69856: sqlite3DbFree ( db , zColl ) ; 
line 69857: } 
line 69858: iDb = sqlite3TwoPartName ( pParse , pName1 , pName2 , & pObjName ) ; 
line 69859: if ( iDb < 0 ) return ; 
line 69860: z = sqlite3NameFromToken ( db , pObjName ) ; 
line 69861: if ( z == 0 ) return ; 
line 69862: zDb = db -> aDb [ iDb ] . zName ; 
line 69863: pTab = sqlite3FindTable ( db , z , zDb ) ; 
line 69864: if ( pTab ) { 
line 69865: reindexTable ( pParse , pTab , 0 ) ; 
line 69866: sqlite3DbFree ( db , z ) ; 
line 69867: return ; 
line 69868: } 
line 69869: pIndex = sqlite3FindIndex ( db , z , zDb ) ; 
line 69870: sqlite3DbFree ( db , z ) ; 
line 69871: if ( pIndex ) { 
line 69872: sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; 
line 69873: sqlite3RefillIndex ( pParse , pIndex , - 1 ) ; 
line 69874: return ; 
line 69875: } 
line 69876: sqlite3ErrorMsg ( pParse , "unable to identify the object to be reindexed" ) ; 
line 69877: } 
line 69878: # endif 
line 69890: SQLITE_PRIVATE KeyInfo * sqlite3IndexKeyinfo ( Parse * pParse , Index * pIdx ) { 
line 69891: int i ; 
line 69892: int nCol = pIdx -> nColumn ; 
line 69893: int nBytes = sizeof ( KeyInfo ) + ( nCol - 1 ) * sizeof ( CollSeq * ) + nCol ; 
line 69894: sqlite3 * db = pParse -> db ; 
line 69895: KeyInfo * pKey = ( KeyInfo * ) sqlite3DbMallocZero ( db , nBytes ) ; 
line 69897: if ( pKey ) { 
line 69898: pKey -> db = pParse -> db ; 
line 69899: pKey -> aSortOrder = ( u8 * ) & ( pKey -> aColl [ nCol ] ) ; 
line 69900: assert ( & pKey -> aSortOrder [ nCol ] == & ( ( ( u8 * ) pKey ) [ nBytes ] ) ) ; 
line 69901: for ( i = 0 ; i < nCol ; i ++ ) { 
line 69902: char * zColl = pIdx -> azColl [ i ] ; 
line 69903: assert ( zColl ) ; 
line 69904: pKey -> aColl [ i ] = sqlite3LocateCollSeq ( pParse , zColl ) ; 
line 69905: pKey -> aSortOrder [ i ] = pIdx -> aSortOrder [ i ] ; 
line 69906: } 
line 69907: pKey -> nField = ( u16 ) nCol ; 
line 69908: } 
line 69910: if ( pParse -> nErr ) { 
line 69911: sqlite3DbFree ( db , pKey ) ; 
line 69912: pKey = 0 ; 
line 69913: } 
line 69914: return pKey ; 
line 69915: } 
line 69940: static void callCollNeeded ( sqlite3 * db , int enc , const char * zName ) { 
line 69941: assert ( ! db -> xCollNeeded || ! db -> xCollNeeded16 ) ; 
line 69942: if ( db -> xCollNeeded ) { 
line 69943: char * zExternal = sqlite3DbStrDup ( db , zName ) ; 
line 69944: if ( ! zExternal ) return ; 
line 69945: db -> xCollNeeded ( db -> pCollNeededArg , db , enc , zExternal ) ; 
line 69946: sqlite3DbFree ( db , zExternal ) ; 
line 69947: } 
line 69948: # ifndef SQLITE_OMIT_UTF16 
line 69949: if ( db -> xCollNeeded16 ) { 
line 69950: char const * zExternal ; 
line 69951: sqlite3_value * pTmp = sqlite3ValueNew ( db ) ; 
line 69952: sqlite3ValueSetStr ( pTmp , - 1 , zName , SQLITE_UTF8 , SQLITE_STATIC ) ; 
line 69953: zExternal = sqlite3ValueText ( pTmp , SQLITE_UTF16NATIVE ) ; 
line 69954: if ( zExternal ) { 
line 69955: db -> xCollNeeded16 ( db -> pCollNeededArg , db , ( int ) ENC ( db ) , zExternal ) ; 
line 69956: } 
line 69957: sqlite3ValueFree ( pTmp ) ; 
line 69958: } 
line 69959: # endif 
line 69960: } 
line 69969: static int synthCollSeq ( sqlite3 * db , CollSeq * pColl ) { 
line 69970: CollSeq * pColl2 ; 
line 69971: char * z = pColl -> zName ; 
line 69972: int i ; 
line 69973: static const u8 aEnc [ ] = { SQLITE_UTF16BE , SQLITE_UTF16LE , SQLITE_UTF8 } ; 
line 69974: for ( i = 0 ; i < 3 ; i ++ ) { 
line 69975: pColl2 = sqlite3FindCollSeq ( db , aEnc [ i ] , z , 0 ) ; 
line 69976: if ( pColl2 -> xCmp != 0 ) { 
line 69977: memcpy ( pColl , pColl2 , sizeof ( CollSeq ) ) ; 
line 69978: pColl -> xDel = 0 ; 
line 69979: return SQLITE_OK ; 
line 69980: } 
line 69981: } 
line 69982: return SQLITE_ERROR ; 
line 69983: } 
line 69999: SQLITE_PRIVATE CollSeq * sqlite3GetCollSeq ( 
line 70000: sqlite3 * db , 
line 70001: u8 enc , 
line 70002: CollSeq * pColl , 
line 70003: const char * zName 
line 70004: ) { 
line 70005: CollSeq * p ; 
line 70007: p = pColl ; 
line 70008: if ( ! p ) { 
line 70009: p = sqlite3FindCollSeq ( db , enc , zName , 0 ) ; 
line 70010: } 
line 70011: if ( ! p || ! p -> xCmp ) { 
line 70015: callCollNeeded ( db , enc , zName ) ; 
line 70016: p = sqlite3FindCollSeq ( db , enc , zName , 0 ) ; 
line 70017: } 
line 70018: if ( p && ! p -> xCmp && synthCollSeq ( db , p ) ) { 
line 70019: p = 0 ; 
line 70020: } 
line 70021: assert ( ! p || p -> xCmp ) ; 
line 70022: return p ; 
line 70023: } 
line 70036: SQLITE_PRIVATE int sqlite3CheckCollSeq ( Parse * pParse , CollSeq * pColl ) { 
line 70037: if ( pColl ) { 
line 70038: const char * zName = pColl -> zName ; 
line 70039: sqlite3 * db = pParse -> db ; 
line 70040: CollSeq * p = sqlite3GetCollSeq ( db , ENC ( db ) , pColl , zName ) ; 
line 70041: if ( ! p ) { 
line 70042: sqlite3ErrorMsg ( pParse , "no such collation sequence: %s" , zName ) ; 
line 70043: pParse -> nErr ++ ; 
line 70044: return SQLITE_ERROR ; 
line 70045: } 
line 70046: assert ( p == pColl ) ; 
line 70047: } 
line 70048: return SQLITE_OK ; 
line 70049: } 
line 70066: static CollSeq * findCollSeqEntry ( 
line 70067: sqlite3 * db , 
line 70068: const char * zName , 
line 70069: int create 
line 70070: ) { 
line 70071: CollSeq * pColl ; 
line 70072: int nName = sqlite3Strlen30 ( zName ) ; 
line 70073: pColl = sqlite3HashFind ( & db -> aCollSeq , zName , nName ) ; 
line 70075: if ( 0 == pColl && create ) { 
line 70076: pColl = sqlite3DbMallocZero ( db , 3 * sizeof ( * pColl ) + nName + 1 ) ; 
line 70077: if ( pColl ) { 
line 70078: CollSeq * pDel = 0 ; 
line 70079: pColl [ 0 ] . zName = ( char * ) & pColl [ 3 ] ; 
line 70080: pColl [ 0 ] . enc = SQLITE_UTF8 ; 
line 70081: pColl [ 1 ] . zName = ( char * ) & pColl [ 3 ] ; 
line 70082: pColl [ 1 ] . enc = SQLITE_UTF16LE ; 
line 70083: pColl [ 2 ] . zName = ( char * ) & pColl [ 3 ] ; 
line 70084: pColl [ 2 ] . enc = SQLITE_UTF16BE ; 
line 70085: memcpy ( pColl [ 0 ] . zName , zName , nName ) ; 
line 70086: pColl [ 0 ] . zName [ nName ] = 0 ; 
line 70087: pDel = sqlite3HashInsert ( & db -> aCollSeq , pColl [ 0 ] . zName , nName , pColl ) ; 
line 70093: assert ( pDel == 0 || pDel == pColl ) ; 
line 70094: if ( pDel != 0 ) { 
line 70095: db -> mallocFailed = 1 ; 
line 70096: sqlite3DbFree ( db , pDel ) ; 
line 70097: pColl = 0 ; 
line 70098: } 
line 70099: } 
line 70100: } 
line 70101: return pColl ; 
line 70102: } 
line 70119: SQLITE_PRIVATE CollSeq * sqlite3FindCollSeq ( 
line 70120: sqlite3 * db , 
line 70121: u8 enc , 
line 70122: const char * zName , 
line 70123: int create 
line 70124: ) { 
line 70125: CollSeq * pColl ; 
line 70126: if ( zName ) { 
line 70127: pColl = findCollSeqEntry ( db , zName , create ) ; 
line 70128: } else { 
line 70129: pColl = db -> pDfltColl ; 
line 70130: } 
line 70131: assert ( SQLITE_UTF8 == 1 && SQLITE_UTF16LE == 2 && SQLITE_UTF16BE == 3 ) ; 
line 70132: assert ( enc >= SQLITE_UTF8 && enc <= SQLITE_UTF16BE ) ; 
line 70133: if ( pColl ) pColl += enc - 1 ; 
line 70134: return pColl ; 
line 70135: } 
line 70158: static int matchQuality ( FuncDef * p , int nArg , u8 enc ) { 
line 70159: int match = 0 ; 
line 70160: if ( p -> nArg == - 1 || p -> nArg == nArg 
line 70161: || ( nArg == - 1 && ( p -> xFunc != 0 || p -> xStep != 0 ) ) 
line 70162: ) { 
line 70163: match = 1 ; 
line 70164: if ( p -> nArg == nArg || nArg == - 1 ) { 
line 70165: match = 4 ; 
line 70166: } 
line 70167: if ( enc == p -> iPrefEnc ) { 
line 70168: match += 2 ; 
line 70169: } 
line 70170: else if ( ( enc == SQLITE_UTF16LE && p -> iPrefEnc == SQLITE_UTF16BE ) || 
line 70171: ( enc == SQLITE_UTF16BE && p -> iPrefEnc == SQLITE_UTF16LE ) ) { 
line 70172: match += 1 ; 
line 70173: } 
line 70174: } 
line 70175: return match ; 
line 70176: } 
line 70182: static FuncDef * functionSearch ( 
line 70183: FuncDefHash * pHash , 
line 70184: int h , 
line 70185: const char * zFunc , 
line 70186: int nFunc 
line 70187: ) { 
line 70188: FuncDef * p ; 
line 70189: for ( p = pHash -> a [ h ] ; p ; p = p -> pHash ) { 
line 70190: if ( sqlite3StrNICmp ( p -> zName , zFunc , nFunc ) == 0 && p -> zName [ nFunc ] == 0 ) { 
line 70191: return p ; 
line 70192: } 
line 70193: } 
line 70194: return 0 ; 
line 70195: } 
line 70200: SQLITE_PRIVATE void sqlite3FuncDefInsert ( 
line 70201: FuncDefHash * pHash , 
line 70202: FuncDef * pDef 
line 70203: ) { 
line 70204: FuncDef * pOther ; 
line 70205: int nName = sqlite3Strlen30 ( pDef -> zName ) ; 
line 70206: u8 c1 = ( u8 ) pDef -> zName [ 0 ] ; 
line 70207: int h = ( sqlite3UpperToLower [ c1 ] + nName ) % ArraySize ( pHash -> a ) ; 
line 70208: pOther = functionSearch ( pHash , h , pDef -> zName , nName ) ; 
line 70209: if ( pOther ) { 
line 70210: assert ( pOther != pDef && pOther -> pNext != pDef ) ; 
line 70211: pDef -> pNext = pOther -> pNext ; 
line 70212: pOther -> pNext = pDef ; 
line 70213: } else { 
line 70214: pDef -> pNext = 0 ; 
line 70215: pDef -> pHash = pHash -> a [ h ] ; 
line 70216: pHash -> a [ h ] = pDef ; 
line 70217: } 
line 70218: } 
line 70242: SQLITE_PRIVATE FuncDef * sqlite3FindFunction ( 
line 70243: sqlite3 * db , 
line 70244: const char * zName , 
line 70245: int nName , 
line 70246: int nArg , 
line 70247: u8 enc , 
line 70248: int createFlag 
line 70249: ) { 
line 70250: FuncDef * p ; 
line 70251: FuncDef * pBest = 0 ; 
line 70252: int bestScore = 0 ; 
line 70253: int h ; 
line 70256: assert ( enc == SQLITE_UTF8 || enc == SQLITE_UTF16LE || enc == SQLITE_UTF16BE ) ; 
line 70257: h = ( sqlite3UpperToLower [ ( u8 ) zName [ 0 ] ] + nName ) % ArraySize ( db -> aFunc . a ) ; 
line 70261: p = functionSearch ( & db -> aFunc , h , zName , nName ) ; 
line 70262: while ( p ) { 
line 70263: int score = matchQuality ( p , nArg , enc ) ; 
line 70264: if ( score > bestScore ) { 
line 70265: pBest = p ; 
line 70266: bestScore = score ; 
line 70267: } 
line 70268: p = p -> pNext ; 
line 70269: } 
line 70279: if ( ! createFlag && ! pBest ) { 
line 70280: FuncDefHash * pHash = & GLOBAL ( FuncDefHash , sqlite3GlobalFunctions ) ; 
line 70281: p = functionSearch ( pHash , h , zName , nName ) ; 
line 70282: while ( p ) { 
line 70283: int score = matchQuality ( p , nArg , enc ) ; 
line 70284: if ( score > bestScore ) { 
line 70285: pBest = p ; 
line 70286: bestScore = score ; 
line 70287: } 
line 70288: p = p -> pNext ; 
line 70289: } 
line 70290: } 
line 70296: if ( createFlag && ( bestScore < 6 || pBest -> nArg != nArg ) && 
line 70297: ( pBest = sqlite3DbMallocZero ( db , sizeof ( * pBest ) + nName + 1 ) ) != 0 ) { 
line 70298: pBest -> zName = ( char * ) & pBest [ 1 ] ; 
line 70299: pBest -> nArg = ( u16 ) nArg ; 
line 70300: pBest -> iPrefEnc = enc ; 
line 70301: memcpy ( pBest -> zName , zName , nName ) ; 
line 70302: pBest -> zName [ nName ] = 0 ; 
line 70303: sqlite3FuncDefInsert ( & db -> aFunc , pBest ) ; 
line 70304: } 
line 70306: if ( pBest && ( pBest -> xStep || pBest -> xFunc || createFlag ) ) { 
line 70307: return pBest ; 
line 70308: } 
line 70309: return 0 ; 
line 70310: } 
line 70320: SQLITE_PRIVATE void sqlite3SchemaFree ( void * p ) { 
line 70321: Hash temp1 ; 
line 70322: Hash temp2 ; 
line 70323: HashElem * pElem ; 
line 70324: Schema * pSchema = ( Schema * ) p ; 
line 70326: temp1 = pSchema -> tblHash ; 
line 70327: temp2 = pSchema -> trigHash ; 
line 70328: sqlite3HashInit ( & pSchema -> trigHash ) ; 
line 70329: sqlite3HashClear ( & pSchema -> idxHash ) ; 
line 70330: for ( pElem = sqliteHashFirst ( & temp2 ) ; pElem ; pElem = sqliteHashNext ( pElem ) ) { 
line 70331: sqlite3DeleteTrigger ( 0 , ( Trigger * ) sqliteHashData ( pElem ) ) ; 
line 70332: } 
line 70333: sqlite3HashClear ( & temp2 ) ; 
line 70334: sqlite3HashInit ( & pSchema -> tblHash ) ; 
line 70335: for ( pElem = sqliteHashFirst ( & temp1 ) ; pElem ; pElem = sqliteHashNext ( pElem ) ) { 
line 70336: Table * pTab = sqliteHashData ( pElem ) ; 
line 70337: assert ( pTab -> dbMem == 0 ) ; 
line 70338: sqlite3DeleteTable ( pTab ) ; 
line 70339: } 
line 70340: sqlite3HashClear ( & temp1 ) ; 
line 70341: sqlite3HashClear ( & pSchema -> fkeyHash ) ; 
line 70342: pSchema -> pSeqTab = 0 ; 
line 70343: pSchema -> flags &= ~ DB_SchemaLoaded ; 
line 70344: } 
line 70350: SQLITE_PRIVATE Schema * sqlite3SchemaGet ( sqlite3 * db , Btree * pBt ) { 
line 70351: Schema * p ; 
line 70352: if ( pBt ) { 
line 70353: p = ( Schema * ) sqlite3BtreeSchema ( pBt , sizeof ( Schema ) , sqlite3SchemaFree ) ; 
line 70354: } else { 
line 70355: p = ( Schema * ) sqlite3MallocZero ( sizeof ( Schema ) ) ; 
line 70356: } 
line 70357: if ( ! p ) { 
line 70358: db -> mallocFailed = 1 ; 
line 70359: } else if ( 0 == p -> file_format ) { 
line 70360: sqlite3HashInit ( & p -> tblHash ) ; 
line 70361: sqlite3HashInit ( & p -> idxHash ) ; 
line 70362: sqlite3HashInit ( & p -> trigHash ) ; 
line 70363: sqlite3HashInit ( & p -> fkeyHash ) ; 
line 70364: p -> enc = SQLITE_UTF8 ; 
line 70365: } 
line 70366: return p ; 
line 70367: } 
line 70391: SQLITE_PRIVATE Table * sqlite3SrcListLookup ( Parse * pParse , SrcList * pSrc ) { 
line 70392: struct SrcList_item * pItem = pSrc -> a ; 
line 70393: Table * pTab ; 
line 70394: assert ( pItem && pSrc -> nSrc == 1 ) ; 
line 70395: pTab = sqlite3LocateTable ( pParse , 0 , pItem -> zName , pItem -> zDatabase ) ; 
line 70396: sqlite3DeleteTable ( pItem -> pTab ) ; 
line 70397: pItem -> pTab = pTab ; 
line 70398: if ( pTab ) { 
line 70399: pTab -> nRef ++ ; 
line 70400: } 
line 70401: if ( sqlite3IndexedByLookup ( pParse , pItem ) ) { 
line 70402: pTab = 0 ; 
line 70403: } 
line 70404: return pTab ; 
line 70405: } 
line 70412: SQLITE_PRIVATE int sqlite3IsReadOnly ( Parse * pParse , Table * pTab , int viewOk ) { 
line 70423: if ( ( IsVirtual ( pTab ) 
line 70424: && sqlite3GetVTable ( pParse -> db , pTab ) -> pMod -> pModule -> xUpdate == 0 ) 
line 70425: || ( ( pTab -> tabFlags & TF_Readonly ) != 0 
line 70426: && ( pParse -> db -> flags & SQLITE_WriteSchema ) == 0 
line 70427: && pParse -> nested == 0 ) 
line 70428: ) { 
line 70429: sqlite3ErrorMsg ( pParse , "table %s may not be modified" , pTab -> zName ) ; 
line 70430: return 1 ; 
line 70431: } 
line 70433: # ifndef SQLITE_OMIT_VIEW 
line 70434: if ( ! viewOk && pTab -> pSelect ) { 
line 70435: sqlite3ErrorMsg ( pParse , "cannot modify %s because it is a view" , pTab -> zName ) ; 
line 70436: return 1 ; 
line 70437: } 
line 70438: # endif 
line 70439: return 0 ; 
line 70440: } 
line 70443: # if ! defined ( SQLITE_OMIT_VIEW ) && ! defined ( SQLITE_OMIT_TRIGGER ) 
line 70449: SQLITE_PRIVATE void sqlite3MaterializeView ( 
line 70450: Parse * pParse , 
line 70451: Table * pView , 
line 70452: Expr * pWhere , 
line 70453: int iCur 
line 70454: ) { 
line 70455: SelectDest dest ; 
line 70456: Select * pDup ; 
line 70457: sqlite3 * db = pParse -> db ; 
line 70459: pDup = sqlite3SelectDup ( db , pView -> pSelect , 0 ) ; 
line 70460: if ( pWhere ) { 
line 70461: SrcList * pFrom ; 
line 70463: pWhere = sqlite3ExprDup ( db , pWhere , 0 ) ; 
line 70464: pFrom = sqlite3SrcListAppend ( db , 0 , 0 , 0 ) ; 
line 70465: if ( pFrom ) { 
line 70466: assert ( pFrom -> nSrc == 1 ) ; 
line 70467: pFrom -> a [ 0 ] . zAlias = sqlite3DbStrDup ( db , pView -> zName ) ; 
line 70468: pFrom -> a [ 0 ] . pSelect = pDup ; 
line 70469: assert ( pFrom -> a [ 0 ] . pOn == 0 ) ; 
line 70470: assert ( pFrom -> a [ 0 ] . pUsing == 0 ) ; 
line 70471: } else { 
line 70472: sqlite3SelectDelete ( db , pDup ) ; 
line 70473: } 
line 70474: pDup = sqlite3SelectNew ( pParse , 0 , pFrom , pWhere , 0 , 0 , 0 , 0 , 0 , 0 ) ; 
line 70475: } 
line 70476: sqlite3SelectDestInit ( & dest , SRT_EphemTab , iCur ) ; 
line 70477: sqlite3Select ( pParse , pDup , & dest ) ; 
line 70478: sqlite3SelectDelete ( db , pDup ) ; 
line 70479: } 
line 70480: # endif 
line 70482: # if defined ( SQLITE_ENABLE_UPDATE_DELETE_LIMIT ) && ! defined ( SQLITE_OMIT_SUBQUERY ) 
line 70491: SQLITE_PRIVATE Expr * sqlite3LimitWhere ( 
line 70492: Parse * pParse , 
line 70493: SrcList * pSrc , 
line 70494: Expr * pWhere , 
line 70495: ExprList * pOrderBy , 
line 70496: Expr * pLimit , 
line 70497: Expr * pOffset , 
line 70498: char * zStmtType 
line 70499: ) { 
line 70500: Expr * pWhereRowid = NULL ; 
line 70501: Expr * pInClause = NULL ; 
line 70502: Expr * pSelectRowid = NULL ; 
line 70503: ExprList * pEList = NULL ; 
line 70504: SrcList * pSelectSrc = NULL ; 
line 70505: Select * pSelect = NULL ; 
line 70509: if ( pOrderBy && ( pLimit == 0 ) ) { 
line 70510: sqlite3ErrorMsg ( pParse , "ORDER BY without LIMIT on %s" , zStmtType ) ; 
line 70511: pParse -> parseError = 1 ; 
line 70512: goto limit_where_cleanup_2 ; 
line 70513: } 
line 70518: if ( pLimit == 0 ) { 
line 70520: assert ( pOffset == 0 ) ; 
line 70521: return pWhere ; 
line 70522: } 
line 70533: pSelectRowid = sqlite3PExpr ( pParse , TK_ROW , 0 , 0 , 0 ) ; 
line 70534: if ( pSelectRowid == 0 ) goto limit_where_cleanup_2 ; 
line 70535: pEList = sqlite3ExprListAppend ( pParse , 0 , pSelectRowid ) ; 
line 70536: if ( pEList == 0 ) goto limit_where_cleanup_2 ; 
line 70540: pSelectSrc = sqlite3SrcListDup ( pParse -> db , pSrc , 0 ) ; 
line 70541: if ( pSelectSrc == 0 ) { 
line 70542: sqlite3ExprListDelete ( pParse -> db , pEList ) ; 
line 70543: goto limit_where_cleanup_2 ; 
line 70544: } 
line 70547: pSelect = sqlite3SelectNew ( pParse , pEList , pSelectSrc , pWhere , 0 , 0 , 
line 70548: pOrderBy , 0 , pLimit , pOffset ) ; 
line 70549: if ( pSelect == 0 ) return 0 ; 
line 70552: pWhereRowid = sqlite3PExpr ( pParse , TK_ROW , 0 , 0 , 0 ) ; 
line 70553: if ( pWhereRowid == 0 ) goto limit_where_cleanup_1 ; 
line 70554: pInClause = sqlite3PExpr ( pParse , TK_IN , pWhereRowid , 0 , 0 ) ; 
line 70555: if ( pInClause == 0 ) goto limit_where_cleanup_1 ; 
line 70557: pInClause -> x . pSelect = pSelect ; 
line 70558: pInClause -> flags |= EP_xIsSelect ; 
line 70559: sqlite3ExprSetHeight ( pParse , pInClause ) ; 
line 70560: return pInClause ; 
line 70563: limit_where_cleanup_1 : 
line 70564: sqlite3SelectDelete ( pParse -> db , pSelect ) ; 
line 70565: return 0 ; 
line 70567: limit_where_cleanup_2 : 
line 70568: sqlite3ExprDelete ( pParse -> db , pWhere ) ; 
line 70569: sqlite3ExprListDelete ( pParse -> db , pOrderBy ) ; 
line 70570: sqlite3ExprDelete ( pParse -> db , pLimit ) ; 
line 70571: sqlite3ExprDelete ( pParse -> db , pOffset ) ; 
line 70572: return 0 ; 
line 70573: } 
line 70574: # endif 
line 70583: SQLITE_PRIVATE void sqlite3DeleteFrom ( 
line 70584: Parse * pParse , 
line 70585: SrcList * pTabList , 
line 70586: Expr * pWhere 
line 70587: ) { 
line 70588: Vdbe * v ; 
line 70589: Table * pTab ; 
line 70590: const char * zDb ; 
line 70591: int end , addr = 0 ; 
line 70592: int i ; 
line 70593: WhereInfo * pWInfo ; 
line 70594: Index * pIdx ; 
line 70595: int iCur ; 
line 70596: sqlite3 * db ; 
line 70597: AuthContext sContext ; 
line 70598: NameContext sNC ; 
line 70599: int iDb ; 
line 70600: int memCnt = - 1 ; 
line 70601: int rcauth ; 
line 70603: # ifndef SQLITE_OMIT_TRIGGER 
line 70604: int isView ; 
line 70605: Trigger * pTrigger ; 
line 70606: # endif 
line 70608: memset ( & sContext , 0 , sizeof ( sContext ) ) ; 
line 70609: db = pParse -> db ; 
line 70610: if ( pParse -> nErr || db -> mallocFailed ) { 
line 70611: goto delete_from_cleanup ; 
line 70612: } 
line 70613: assert ( pTabList -> nSrc == 1 ) ; 
line 70620: pTab = sqlite3SrcListLookup ( pParse , pTabList ) ; 
line 70621: if ( pTab == 0 ) goto delete_from_cleanup ; 
line 70626: # ifndef SQLITE_OMIT_TRIGGER 
line 70627: pTrigger = sqlite3TriggersExist ( pParse , pTab , TK_DELETE , 0 , 0 ) ; 
line 70628: isView = pTab -> pSelect != 0 ; 
line 70629: # else 
line 70630: # define pTrigger 0 
line 70631: # define isView 0 
line 70632: # endif 
line 70633: # ifdef SQLITE_OMIT_VIEW 
line 70634: # undef isView 
line 70635: # define isView 0 
line 70636: # endif 
line 70640: if ( sqlite3ViewGetColumnNames ( pParse , pTab ) ) { 
line 70641: goto delete_from_cleanup ; 
line 70642: } 
line 70644: if ( sqlite3IsReadOnly ( pParse , pTab , ( pTrigger ? 1 : 0 ) ) ) { 
line 70645: goto delete_from_cleanup ; 
line 70646: } 
line 70647: iDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; 
line 70648: assert ( iDb < db -> nDb ) ; 
line 70649: zDb = db -> aDb [ iDb ] . zName ; 
line 70650: rcauth = sqlite3AuthCheck ( pParse , SQLITE_DELETE , pTab -> zName , 0 , zDb ) ; 
line 70651: assert ( rcauth == SQLITE_OK || rcauth == SQLITE_DENY || rcauth == SQLITE_IGNORE ) ; 
line 70652: if ( rcauth == SQLITE_DENY ) { 
line 70653: goto delete_from_cleanup ; 
line 70654: } 
line 70655: assert ( ! isView || pTrigger ) ; 
line 70659: assert ( pTabList -> nSrc == 1 ) ; 
line 70660: iCur = pTabList -> a [ 0 ] . iCursor = pParse -> nTab ++ ; 
line 70661: for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { 
line 70662: pParse -> nTab ++ ; 
line 70663: } 
line 70667: if ( isView ) { 
line 70668: sqlite3AuthContextPush ( pParse , & sContext , pTab -> zName ) ; 
line 70669: } 
line 70673: v = sqlite3GetVdbe ( pParse ) ; 
line 70674: if ( v == 0 ) { 
line 70675: goto delete_from_cleanup ; 
line 70676: } 
line 70677: if ( pParse -> nested == 0 ) sqlite3VdbeCountChanges ( v ) ; 
line 70678: sqlite3BeginWriteOperation ( pParse , 1 , iDb ) ; 
line 70683: # if ! defined ( SQLITE_OMIT_VIEW ) && ! defined ( SQLITE_OMIT_TRIGGER ) 
line 70684: if ( isView ) { 
line 70685: sqlite3MaterializeView ( pParse , pTab , pWhere , iCur ) ; 
line 70686: } 
line 70687: # endif 
line 70691: memset ( & sNC , 0 , sizeof ( sNC ) ) ; 
line 70692: sNC . pParse = pParse ; 
line 70693: sNC . pSrcList = pTabList ; 
line 70694: if ( sqlite3ResolveExprNames ( & sNC , pWhere ) ) { 
line 70695: goto delete_from_cleanup ; 
line 70696: } 
line 70701: if ( db -> flags & SQLITE_CountRows ) { 
line 70702: memCnt = ++ pParse -> nMem ; 
line 70703: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , memCnt ) ; 
line 70704: } 
line 70706: # ifndef SQLITE_OMIT_TRUNCATE_OPTIMIZATION 
line 70711: if ( rcauth == SQLITE_OK && pWhere == 0 && ! pTrigger && ! IsVirtual ( pTab ) 
line 70712: && 0 == sqlite3FkRequired ( pParse , pTab , 0 , 0 ) 
line 70713: ) { 
line 70714: assert ( ! isView ) ; 
line 70715: sqlite3VdbeAddOp4 ( v , OP_Clear , pTab -> tnum , iDb , memCnt , 
line 70716: pTab -> zName , P4_STATIC ) ; 
line 70717: for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { 
line 70718: assert ( pIdx -> pSchema == pTab -> pSchema ) ; 
line 70719: sqlite3VdbeAddOp2 ( v , OP_Clear , pIdx -> tnum , iDb ) ; 
line 70720: } 
line 70721: } else 
line 70722: # endif 
line 70726: { 
line 70727: int iRowSet = ++ pParse -> nMem ; 
line 70728: int iRowid = ++ pParse -> nMem ; 
line 70729: int regRowid ; 
line 70733: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , iRowSet ) ; 
line 70734: pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , 0 , WHERE_DUPLICATES_OK ) ; 
line 70735: if ( pWInfo == 0 ) goto delete_from_cleanup ; 
line 70736: regRowid = sqlite3ExprCodeGetColumn ( pParse , pTab , - 1 , iCur , iRowid ) ; 
line 70737: sqlite3VdbeAddOp2 ( v , OP_RowSetAdd , iRowSet , regRowid ) ; 
line 70738: if ( db -> flags & SQLITE_CountRows ) { 
line 70739: sqlite3VdbeAddOp2 ( v , OP_AddImm , memCnt , 1 ) ; 
line 70740: } 
line 70741: sqlite3WhereEnd ( pWInfo ) ; 
line 70746: end = sqlite3VdbeMakeLabel ( v ) ; 
line 70752: if ( ! isView ) { 
line 70753: sqlite3OpenTableAndIndices ( pParse , pTab , iCur , OP_OpenWrite ) ; 
line 70754: } 
line 70756: addr = sqlite3VdbeAddOp3 ( v , OP_RowSetRead , iRowSet , end , iRowid ) ; 
line 70759: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 70760: if ( IsVirtual ( pTab ) ) { 
line 70761: const char * pVTab = ( const char * ) sqlite3GetVTable ( db , pTab ) ; 
line 70762: sqlite3VtabMakeWritable ( pParse , pTab ) ; 
line 70763: sqlite3VdbeAddOp4 ( v , OP_VUpdate , 0 , 1 , iRowid , pVTab , P4_VTAB ) ; 
line 70764: sqlite3MayAbort ( pParse ) ; 
line 70765: } else 
line 70766: # endif 
line 70767: { 
line 70768: int count = ( pParse -> nested == 0 ) ; 
line 70769: sqlite3GenerateRowDelete ( pParse , pTab , iCur , iRowid , count , pTrigger , OE_Default ) ; 
line 70770: } 
line 70773: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , addr ) ; 
line 70774: sqlite3VdbeResolveLabel ( v , end ) ; 
line 70777: if ( ! isView && ! IsVirtual ( pTab ) ) { 
line 70778: for ( i = 1 , pIdx = pTab -> pIndex ; pIdx ; i ++ , pIdx = pIdx -> pNext ) { 
line 70779: sqlite3VdbeAddOp2 ( v , OP_Close , iCur + i , pIdx -> tnum ) ; 
line 70780: } 
line 70781: sqlite3VdbeAddOp1 ( v , OP_Close , iCur ) ; 
line 70782: } 
line 70783: } 
line 70789: if ( pParse -> nested == 0 && pParse -> pTriggerTab == 0 ) { 
line 70790: sqlite3AutoincrementEnd ( pParse ) ; 
line 70791: } 
line 70797: if ( ( db -> flags & SQLITE_CountRows ) && ! pParse -> nested && ! pParse -> pTriggerTab ) { 
line 70798: sqlite3VdbeAddOp2 ( v , OP_ResultRow , memCnt , 1 ) ; 
line 70799: sqlite3VdbeSetNumCols ( v , 1 ) ; 
line 70800: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "rows deleted" , SQLITE_STATIC ) ; 
line 70801: } 
line 70803: delete_from_cleanup : 
line 70804: sqlite3AuthContextPop ( & sContext ) ; 
line 70805: sqlite3SrcListDelete ( db , pTabList ) ; 
line 70806: sqlite3ExprDelete ( db , pWhere ) ; 
line 70807: return ; 
line 70808: } 
line 70812: # ifdef isView 
line 70813: # undef isView 
line 70814: # endif 
line 70815: # ifdef pTrigger 
line 70816: # undef pTrigger 
line 70817: # endif 
line 70838: SQLITE_PRIVATE void sqlite3GenerateRowDelete ( 
line 70839: Parse * pParse , 
line 70840: Table * pTab , 
line 70841: int iCur , 
line 70842: int iRowid , 
line 70843: int count , 
line 70844: Trigger * pTrigger , 
line 70845: int onconf 
line 70846: ) { 
line 70847: Vdbe * v = pParse -> pVdbe ; 
line 70848: int iOld = 0 ; 
line 70849: int iLabel ; 
line 70852: assert ( v ) ; 
line 70857: iLabel = sqlite3VdbeMakeLabel ( v ) ; 
line 70858: sqlite3VdbeAddOp3 ( v , OP_NotExists , iCur , iLabel , iRowid ) ; 
line 70862: if ( sqlite3FkRequired ( pParse , pTab , 0 , 0 ) || pTrigger ) { 
line 70863: u32 mask ; 
line 70864: int iCol ; 
line 70868: mask = sqlite3TriggerColmask ( 
line 70869: pParse , pTrigger , 0 , 0 , TRIGGER_BEFORE | TRIGGER_AFTER , pTab , onconf 
line 70870: ) ; 
line 70871: mask |= sqlite3FkOldmask ( pParse , pTab ) ; 
line 70872: iOld = pParse -> nMem + 1 ; 
line 70873: pParse -> nMem += ( 1 + pTab -> nCol ) ; 
line 70877: sqlite3VdbeAddOp2 ( v , OP_Copy , iRowid , iOld ) ; 
line 70878: for ( iCol = 0 ; iCol < pTab -> nCol ; iCol ++ ) { 
line 70879: if ( mask == 0xffffffff || mask & ( 1 << iCol ) ) { 
line 70880: int iTarget = iOld + iCol + 1 ; 
line 70881: sqlite3VdbeAddOp3 ( v , OP_Column , iCur , iCol , iTarget ) ; 
line 70882: sqlite3ColumnDefault ( v , pTab , iCol , iTarget ) ; 
line 70883: } 
line 70884: } 
line 70887: sqlite3CodeRowTrigger ( pParse , pTrigger , 
line 70888: TK_DELETE , 0 , TRIGGER_BEFORE , pTab , iOld , onconf , iLabel 
line 70889: ) ; 
line 70895: sqlite3VdbeAddOp3 ( v , OP_NotExists , iCur , iLabel , iRowid ) ; 
line 70900: sqlite3FkCheck ( pParse , pTab , iOld , 0 ) ; 
line 70901: } 
line 70906: if ( pTab -> pSelect == 0 ) { 
line 70907: sqlite3GenerateRowIndexDelete ( pParse , pTab , iCur , 0 ) ; 
line 70908: sqlite3VdbeAddOp2 ( v , OP_Delete , iCur , ( count ? OPFLAG_NCHANGE : 0 ) ) ; 
line 70909: if ( count ) { 
line 70910: sqlite3VdbeChangeP4 ( v , - 1 , pTab -> zName , P4_STATIC ) ; 
line 70911: } 
line 70912: } 
line 70917: sqlite3FkActions ( pParse , pTab , 0 , iOld ) ; 
line 70920: sqlite3CodeRowTrigger ( pParse , pTrigger , 
line 70921: TK_DELETE , 0 , TRIGGER_AFTER , pTab , iOld , onconf , iLabel 
line 70922: ) ; 
line 70927: sqlite3VdbeResolveLabel ( v , iLabel ) ; 
line 70928: } 
line 70946: SQLITE_PRIVATE void sqlite3GenerateRowIndexDelete ( 
line 70947: Parse * pParse , 
line 70948: Table * pTab , 
line 70949: int iCur , 
line 70950: int * aRegIdx 
line 70951: ) { 
line 70952: int i ; 
line 70953: Index * pIdx ; 
line 70954: int r1 ; 
line 70956: for ( i = 1 , pIdx = pTab -> pIndex ; pIdx ; i ++ , pIdx = pIdx -> pNext ) { 
line 70957: if ( aRegIdx != 0 && aRegIdx [ i - 1 ] == 0 ) continue ; 
line 70958: r1 = sqlite3GenerateIndexKey ( pParse , pIdx , iCur , 0 , 0 ) ; 
line 70959: sqlite3VdbeAddOp3 ( pParse -> pVdbe , OP_IdxDelete , iCur + i , r1 , pIdx -> nColumn + 1 ) ; 
line 70960: } 
line 70961: } 
line 70974: SQLITE_PRIVATE int sqlite3GenerateIndexKey ( 
line 70975: Parse * pParse , 
line 70976: Index * pIdx , 
line 70977: int iCur , 
line 70978: int regOut , 
line 70979: int doMakeRec 
line 70980: ) { 
line 70981: Vdbe * v = pParse -> pVdbe ; 
line 70982: int j ; 
line 70983: Table * pTab = pIdx -> pTable ; 
line 70984: int regBase ; 
line 70985: int nCol ; 
line 70987: nCol = pIdx -> nColumn ; 
line 70988: regBase = sqlite3GetTempRange ( pParse , nCol + 1 ) ; 
line 70989: sqlite3VdbeAddOp2 ( v , OP_Rowid , iCur , regBase + nCol ) ; 
line 70990: for ( j = 0 ; j < nCol ; j ++ ) { 
line 70991: int idx = pIdx -> aiColumn [ j ] ; 
line 70992: if ( idx == pTab -> iPKey ) { 
line 70993: sqlite3VdbeAddOp2 ( v , OP_SCopy , regBase + nCol , regBase + j ) ; 
line 70994: } else { 
line 70995: sqlite3VdbeAddOp3 ( v , OP_Column , iCur , idx , regBase + j ) ; 
line 70996: sqlite3ColumnDefault ( v , pTab , idx , - 1 ) ; 
line 70997: } 
line 70998: } 
line 70999: if ( doMakeRec ) { 
line 71000: sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol + 1 , regOut ) ; 
line 71001: sqlite3VdbeChangeP4 ( v , - 1 , sqlite3IndexAffinityStr ( v , pIdx ) , 0 ) ; 
line 71002: } 
line 71003: sqlite3ReleaseTempRange ( pParse , regBase , nCol + 1 ) ; 
line 71004: return regBase ; 
line 71005: } 
line 71031: static CollSeq * sqlite3GetFuncCollSeq ( sqlite3_context * context ) { 
line 71032: return context -> pColl ; 
line 71033: } 
line 71038: static void minmaxFunc ( 
line 71039: sqlite3_context * context , 
line 71040: int argc , 
line 71041: sqlite3_value * * argv 
line 71042: ) { 
line 71043: int i ; 
line 71044: int mask ; 
line 71045: int iBest ; 
line 71046: CollSeq * pColl ; 
line 71048: assert ( argc > 1 ) ; 
line 71049: mask = sqlite3_user_data ( context ) == 0 ? 0 : - 1 ; 
line 71050: pColl = sqlite3GetFuncCollSeq ( context ) ; 
line 71051: assert ( pColl ) ; 
line 71052: assert ( mask == - 1 || mask == 0 ) ; 
line 71053: iBest = 0 ; 
line 71054: if ( sqlite3_value_type ( argv [ 0 ] ) == SQLITE_NULL ) return ; 
line 71055: for ( i = 1 ; i < argc ; i ++ ) { 
line 71056: if ( sqlite3_value_type ( argv [ i ] ) == SQLITE_NULL ) return ; 
line 71057: if ( ( sqlite3MemCompare ( argv [ iBest ] , argv [ i ] , pColl ) ^ mask ) >= 0 ) { 
line 71058: testcase ( mask == 0 ) ; 
line 71059: iBest = i ; 
line 71060: } 
line 71061: } 
line 71062: sqlite3_result_value ( context , argv [ iBest ] ) ; 
line 71063: } 
line 71068: static void typeofFunc ( 
line 71069: sqlite3_context * context , 
line 71070: int NotUsed , 
line 71071: sqlite3_value * * argv 
line 71072: ) { 
line 71073: const char * z = 0 ; 
line 71074: UNUSED_PARAMETER ( NotUsed ) ; 
line 71075: switch ( sqlite3_value_type ( argv [ 0 ] ) ) { 
line 71076: case SQLITE_INTEGER : z = "integer" ; break ; 
line 71077: case SQLITE_TEXT : z = "text" ; break ; 
line 71078: case SQLITE_FLOAT : z = "real" ; break ; 
line 71079: case SQLITE_BLOB : z = "blob" ; break ; 
line 71080: default : z = "null" ; break ; 
line 71081: } 
line 71082: sqlite3_result_text ( context , z , - 1 , SQLITE_STATIC ) ; 
line 71083: } 
line 71089: static void lengthFunc ( 
line 71090: sqlite3_context * context , 
line 71091: int argc , 
line 71092: sqlite3_value * * argv 
line 71093: ) { 
line 71094: int len ; 
line 71096: assert ( argc == 1 ) ; 
line 71097: UNUSED_PARAMETER ( argc ) ; 
line 71098: switch ( sqlite3_value_type ( argv [ 0 ] ) ) { 
line 71099: case SQLITE_BLOB : 
line 71100: case SQLITE_INTEGER : 
line 71101: case SQLITE_FLOAT : { 
line 71102: sqlite3_result_int ( context , sqlite3_value_bytes ( argv [ 0 ] ) ) ; 
line 71103: break ; 
line 71104: } 
line 71105: case SQLITE_TEXT : { 
line 71106: const unsigned char * z = sqlite3_value_text ( argv [ 0 ] ) ; 
line 71107: if ( z == 0 ) return ; 
line 71108: len = 0 ; 
line 71109: while ( * z ) { 
line 71110: len ++ ; 
line 71111: SQLITE_SKIP_UTF8 ( z ) ; 
line 71112: } 
line 71113: sqlite3_result_int ( context , len ) ; 
line 71114: break ; 
line 71115: } 
line 71116: default : { 
line 71117: sqlite3_result_null ( context ) ; 
line 71118: break ; 
line 71119: } 
line 71120: } 
line 71121: } 
line 71129: static void absFunc ( sqlite3_context * context , int argc , sqlite3_value * * argv ) { 
line 71130: assert ( argc == 1 ) ; 
line 71131: UNUSED_PARAMETER ( argc ) ; 
line 71132: switch ( sqlite3_value_type ( argv [ 0 ] ) ) { 
line 71133: case SQLITE_INTEGER : { 
line 71134: i64 iVal = sqlite3_value_int64 ( argv [ 0 ] ) ; 
line 71135: if ( iVal < 0 ) { 
line 71136: if ( ( iVal << 1 ) == 0 ) { 
line 71140: sqlite3_result_error ( context , "integer overflow" , - 1 ) ; 
line 71141: return ; 
line 71142: } 
line 71143: iVal = - iVal ; 
line 71144: } 
line 71145: sqlite3_result_int64 ( context , iVal ) ; 
line 71146: break ; 
line 71147: } 
line 71148: case SQLITE_NULL : { 
line 71150: sqlite3_result_null ( context ) ; 
line 71151: break ; 
line 71152: } 
line 71153: default : { 
line 71159: double rVal = sqlite3_value_double ( argv [ 0 ] ) ; 
line 71160: if ( rVal < 0 ) rVal = - rVal ; 
line 71161: sqlite3_result_double ( context , rVal ) ; 
line 71162: break ; 
line 71163: } 
line 71164: } 
line 71165: } 
line 71179: static void substrFunc ( 
line 71180: sqlite3_context * context , 
line 71181: int argc , 
line 71182: sqlite3_value * * argv 
line 71183: ) { 
line 71184: const unsigned char * z ; 
line 71185: const unsigned char * z2 ; 
line 71186: int len ; 
line 71187: int p0type ; 
line 71188: i64 p1 , p2 ; 
line 71189: int negP2 = 0 ; 
line 71191: assert ( argc == 3 || argc == 2 ) ; 
line 71192: if ( sqlite3_value_type ( argv [ 1 ] ) == SQLITE_NULL 
line 71193: || ( argc == 3 && sqlite3_value_type ( argv [ 2 ] ) == SQLITE_NULL ) 
line 71194: ) { 
line 71195: return ; 
line 71196: } 
line 71197: p0type = sqlite3_value_type ( argv [ 0 ] ) ; 
line 71198: p1 = sqlite3_value_int ( argv [ 1 ] ) ; 
line 71199: if ( p0type == SQLITE_BLOB ) { 
line 71200: len = sqlite3_value_bytes ( argv [ 0 ] ) ; 
line 71201: z = sqlite3_value_blob ( argv [ 0 ] ) ; 
line 71202: if ( z == 0 ) return ; 
line 71203: assert ( len == sqlite3_value_bytes ( argv [ 0 ] ) ) ; 
line 71204: } else { 
line 71205: z = sqlite3_value_text ( argv [ 0 ] ) ; 
line 71206: if ( z == 0 ) return ; 
line 71207: len = 0 ; 
line 71208: if ( p1 < 0 ) { 
line 71209: for ( z2 = z ; * z2 ; len ++ ) { 
line 71210: SQLITE_SKIP_UTF8 ( z2 ) ; 
line 71211: } 
line 71212: } 
line 71213: } 
line 71214: if ( argc == 3 ) { 
line 71215: p2 = sqlite3_value_int ( argv [ 2 ] ) ; 
line 71216: if ( p2 < 0 ) { 
line 71217: p2 = - p2 ; 
line 71218: negP2 = 1 ; 
line 71219: } 
line 71220: } else { 
line 71221: p2 = sqlite3_context_db_handle ( context ) -> aLimit [ SQLITE_LIMIT_LENGTH ] ; 
line 71222: } 
line 71223: if ( p1 < 0 ) { 
line 71224: p1 += len ; 
line 71225: if ( p1 < 0 ) { 
line 71226: p2 += p1 ; 
line 71227: if ( p2 < 0 ) p2 = 0 ; 
line 71228: p1 = 0 ; 
line 71229: } 
line 71230: } else if ( p1 > 0 ) { 
line 71231: p1 -- ; 
line 71232: } else if ( p2 > 0 ) { 
line 71233: p2 -- ; 
line 71234: } 
line 71235: if ( negP2 ) { 
line 71236: p1 -= p2 ; 
line 71237: if ( p1 < 0 ) { 
line 71238: p2 += p1 ; 
line 71239: p1 = 0 ; 
line 71240: } 
line 71241: } 
line 71242: assert ( p1 >= 0 && p2 >= 0 ) ; 
line 71243: if ( p0type != SQLITE_BLOB ) { 
line 71244: while ( * z && p1 ) { 
line 71245: SQLITE_SKIP_UTF8 ( z ) ; 
line 71246: p1 -- ; 
line 71247: } 
line 71248: for ( z2 = z ; * z2 && p2 ; p2 -- ) { 
line 71249: SQLITE_SKIP_UTF8 ( z2 ) ; 
line 71250: } 
line 71251: sqlite3_result_text ( context , ( char * ) z , ( int ) ( z2 - z ) , SQLITE_TRANSIENT ) ; 
line 71252: } else { 
line 71253: if ( p1 + p2 > len ) { 
line 71254: p2 = len - p1 ; 
line 71255: if ( p2 < 0 ) p2 = 0 ; 
line 71256: } 
line 71257: sqlite3_result_blob ( context , ( char * ) & z [ p1 ] , ( int ) p2 , SQLITE_TRANSIENT ) ; 
line 71258: } 
line 71259: } 
line 71264: # ifndef SQLITE_OMIT_FLOATING_POINT 
line 71265: static void roundFunc ( sqlite3_context * context , int argc , sqlite3_value * * argv ) { 
line 71266: int n = 0 ; 
line 71267: double r ; 
line 71268: char * zBuf ; 
line 71269: assert ( argc == 1 || argc == 2 ) ; 
line 71270: if ( argc == 2 ) { 
line 71271: if ( SQLITE_NULL == sqlite3_value_type ( argv [ 1 ] ) ) return ; 
line 71272: n = sqlite3_value_int ( argv [ 1 ] ) ; 
line 71273: if ( n > 30 ) n = 30 ; 
line 71274: if ( n < 0 ) n = 0 ; 
line 71275: } 
line 71276: if ( sqlite3_value_type ( argv [ 0 ] ) == SQLITE_NULL ) return ; 
line 71277: r = sqlite3_value_double ( argv [ 0 ] ) ; 
line 71278: zBuf = sqlite3_mprintf ( "%.*f" , n , r ) ; 
line 71279: if ( zBuf == 0 ) { 
line 71280: sqlite3_result_error_nomem ( context ) ; 
line 71281: } else { 
line 71282: sqlite3AtoF ( zBuf , & r ) ; 
line 71283: sqlite3_free ( zBuf ) ; 
line 71284: sqlite3_result_double ( context , r ) ; 
line 71285: } 
line 71286: } 
line 71287: # endif 
line 71296: static void * contextMalloc ( sqlite3_context * context , i64 nByte ) { 
line 71297: char * z ; 
line 71298: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 71299: assert ( nByte > 0 ) ; 
line 71300: testcase ( nByte == db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) ; 
line 71301: testcase ( nByte == db -> aLimit [ SQLITE_LIMIT_LENGTH ] + 1 ) ; 
line 71302: if ( nByte > db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) { 
line 71303: sqlite3_result_error_toobig ( context ) ; 
line 71304: z = 0 ; 
line 71305: } else { 
line 71306: z = sqlite3Malloc ( ( int ) nByte ) ; 
line 71307: if ( ! z ) { 
line 71308: sqlite3_result_error_nomem ( context ) ; 
line 71309: } 
line 71310: } 
line 71311: return z ; 
line 71312: } 
line 71317: static void upperFunc ( sqlite3_context * context , int argc , sqlite3_value * * argv ) { 
line 71318: char * z1 ; 
line 71319: const char * z2 ; 
line 71320: int i , n ; 
line 71321: UNUSED_PARAMETER ( argc ) ; 
line 71322: z2 = ( char * ) sqlite3_value_text ( argv [ 0 ] ) ; 
line 71323: n = sqlite3_value_bytes ( argv [ 0 ] ) ; 
line 71325: assert ( z2 == ( char * ) sqlite3_value_text ( argv [ 0 ] ) ) ; 
line 71326: if ( z2 ) { 
line 71327: z1 = contextMalloc ( context , ( ( i64 ) n ) + 1 ) ; 
line 71328: if ( z1 ) { 
line 71329: memcpy ( z1 , z2 , n + 1 ) ; 
line 71330: for ( i = 0 ; z1 [ i ] ; i ++ ) { 
line 71331: z1 [ i ] = ( char ) sqlite3Toupper ( z1 [ i ] ) ; 
line 71332: } 
line 71333: sqlite3_result_text ( context , z1 , - 1 , sqlite3_free ) ; 
line 71334: } 
line 71335: } 
line 71336: } 
line 71337: static void lowerFunc ( sqlite3_context * context , int argc , sqlite3_value * * argv ) { 
line 71338: u8 * z1 ; 
line 71339: const char * z2 ; 
line 71340: int i , n ; 
line 71341: UNUSED_PARAMETER ( argc ) ; 
line 71342: z2 = ( char * ) sqlite3_value_text ( argv [ 0 ] ) ; 
line 71343: n = sqlite3_value_bytes ( argv [ 0 ] ) ; 
line 71345: assert ( z2 == ( char * ) sqlite3_value_text ( argv [ 0 ] ) ) ; 
line 71346: if ( z2 ) { 
line 71347: z1 = contextMalloc ( context , ( ( i64 ) n ) + 1 ) ; 
line 71348: if ( z1 ) { 
line 71349: memcpy ( z1 , z2 , n + 1 ) ; 
line 71350: for ( i = 0 ; z1 [ i ] ; i ++ ) { 
line 71351: z1 [ i ] = sqlite3Tolower ( z1 [ i ] ) ; 
line 71352: } 
line 71353: sqlite3_result_text ( context , ( char * ) z1 , - 1 , sqlite3_free ) ; 
line 71354: } 
line 71355: } 
line 71356: } 
line 71359: # if 0 
line 71371: static void ifnullFunc ( 
line 71372: sqlite3_context * context , 
line 71373: int argc , 
line 71374: sqlite3_value * * argv 
line 71375: ) { 
line 71376: int i ; 
line 71377: for ( i = 0 ; i < argc ; i ++ ) { 
line 71378: if ( SQLITE_NULL != sqlite3_value_type ( argv [ i ] ) ) { 
line 71379: sqlite3_result_value ( context , argv [ i ] ) ; 
line 71380: break ; 
line 71381: } 
line 71382: } 
line 71383: } 
line 71384: # endif 
line 71385: # define ifnullFunc versionFunc 
line 71390: static void randomFunc ( 
line 71391: sqlite3_context * context , 
line 71392: int NotUsed , 
line 71393: sqlite3_value * * NotUsed2 
line 71394: ) { 
line 71395: sqlite_int64 r ; 
line 71396: UNUSED_PARAMETER2 ( NotUsed , NotUsed2 ) ; 
line 71397: sqlite3_randomness ( sizeof ( r ) , & r ) ; 
line 71398: if ( r < 0 ) { 
line 71407: r = - ( r ^ ( ( ( sqlite3_int64 ) 1 ) << 63 ) ) ; 
line 71408: } 
line 71409: sqlite3_result_int64 ( context , r ) ; 
line 71410: } 
line 71416: static void randomBlob ( 
line 71417: sqlite3_context * context , 
line 71418: int argc , 
line 71419: sqlite3_value * * argv 
line 71420: ) { 
line 71421: int n ; 
line 71422: unsigned char * p ; 
line 71423: assert ( argc == 1 ) ; 
line 71424: UNUSED_PARAMETER ( argc ) ; 
line 71425: n = sqlite3_value_int ( argv [ 0 ] ) ; 
line 71426: if ( n < 1 ) { 
line 71427: n = 1 ; 
line 71428: } 
line 71429: p = contextMalloc ( context , n ) ; 
line 71430: if ( p ) { 
line 71431: sqlite3_randomness ( n , p ) ; 
line 71432: sqlite3_result_blob ( context , ( char * ) p , n , sqlite3_free ) ; 
line 71433: } 
line 71434: } 
line 71440: static void last_insert_rowid ( 
line 71441: sqlite3_context * context , 
line 71442: int NotUsed , 
line 71443: sqlite3_value * * NotUsed2 
line 71444: ) { 
line 71445: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 71446: UNUSED_PARAMETER2 ( NotUsed , NotUsed2 ) ; 
line 71447: sqlite3_result_int64 ( context , sqlite3_last_insert_rowid ( db ) ) ; 
line 71448: } 
line 71454: static void changes ( 
line 71455: sqlite3_context * context , 
line 71456: int NotUsed , 
line 71457: sqlite3_value * * NotUsed2 
line 71458: ) { 
line 71459: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 71460: UNUSED_PARAMETER2 ( NotUsed , NotUsed2 ) ; 
line 71461: sqlite3_result_int ( context , sqlite3_changes ( db ) ) ; 
line 71462: } 
line 71468: static void total_changes ( 
line 71469: sqlite3_context * context , 
line 71470: int NotUsed , 
line 71471: sqlite3_value * * NotUsed2 
line 71472: ) { 
line 71473: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 71474: UNUSED_PARAMETER2 ( NotUsed , NotUsed2 ) ; 
line 71475: sqlite3_result_int ( context , sqlite3_total_changes ( db ) ) ; 
line 71476: } 
line 71481: struct compareInfo { 
line 71482: u8 matchAll ; 
line 71483: u8 matchOne ; 
line 71484: u8 matchSet ; 
line 71485: u8 noCase ; 
line 71486: } ; 
line 71494: # if defined ( SQLITE_EBCDIC ) 
line 71495: # define sqlite3Utf8Read ( A , C ) ( * ( A ++ ) ) 
line 71496: # define GlogUpperToLower ( A ) A = sqlite3UpperToLower [ A ] 
line 71497: # else 
line 71498: # define GlogUpperToLower ( A ) if ( A < 0x80 ) { A = sqlite3UpperToLower [ A ] ; } 
line 71499: # endif 
line 71501: static const struct compareInfo globInfo = { '*' , '?' , '[' , 0 } ; 
line 71504: static const struct compareInfo likeInfoNorm = { '%' , '_' , 0 , 1 } ; 
line 71507: static const struct compareInfo likeInfoAlt = { '%' , '_' , 0 , 0 } ; 
line 71537: static int patternCompare ( 
line 71538: const u8 * zPattern , 
line 71539: const u8 * zString , 
line 71540: const struct compareInfo * pInfo , 
line 71541: const int esc 
line 71542: ) { 
line 71543: int c , c2 ; 
line 71544: int invert ; 
line 71545: int seen ; 
line 71546: u8 matchOne = pInfo -> matchOne ; 
line 71547: u8 matchAll = pInfo -> matchAll ; 
line 71548: u8 matchSet = pInfo -> matchSet ; 
line 71549: u8 noCase = pInfo -> noCase ; 
line 71550: int prevEscape = 0 ; 
line 71552: while ( ( c = sqlite3Utf8Read ( zPattern , & zPattern ) ) != 0 ) { 
line 71553: if ( ! prevEscape && c == matchAll ) { 
line 71554: while ( ( c = sqlite3Utf8Read ( zPattern , & zPattern ) ) == matchAll 
line 71555: || c == matchOne ) { 
line 71556: if ( c == matchOne && sqlite3Utf8Read ( zString , & zString ) == 0 ) { 
line 71557: return 0 ; 
line 71558: } 
line 71559: } 
line 71560: if ( c == 0 ) { 
line 71561: return 1 ; 
line 71562: } else if ( c == esc ) { 
line 71563: c = sqlite3Utf8Read ( zPattern , & zPattern ) ; 
line 71564: if ( c == 0 ) { 
line 71565: return 0 ; 
line 71566: } 
line 71567: } else if ( c == matchSet ) { 
line 71568: assert ( esc == 0 ) ; 
line 71569: assert ( matchSet < 0x80 ) ; 
line 71570: while ( * zString && patternCompare ( & zPattern [ - 1 ] , zString , pInfo , esc ) == 0 ) { 
line 71571: SQLITE_SKIP_UTF8 ( zString ) ; 
line 71572: } 
line 71573: return * zString != 0 ; 
line 71574: } 
line 71575: while ( ( c2 = sqlite3Utf8Read ( zString , & zString ) ) != 0 ) { 
line 71576: if ( noCase ) { 
line 71577: GlogUpperToLower ( c2 ) ; 
line 71578: GlogUpperToLower ( c ) ; 
line 71579: while ( c2 != 0 && c2 != c ) { 
line 71580: c2 = sqlite3Utf8Read ( zString , & zString ) ; 
line 71581: GlogUpperToLower ( c2 ) ; 
line 71582: } 
line 71583: } else { 
line 71584: while ( c2 != 0 && c2 != c ) { 
line 71585: c2 = sqlite3Utf8Read ( zString , & zString ) ; 
line 71586: } 
line 71587: } 
line 71588: if ( c2 == 0 ) return 0 ; 
line 71589: if ( patternCompare ( zPattern , zString , pInfo , esc ) ) return 1 ; 
line 71590: } 
line 71591: return 0 ; 
line 71592: } else if ( ! prevEscape && c == matchOne ) { 
line 71593: if ( sqlite3Utf8Read ( zString , & zString ) == 0 ) { 
line 71594: return 0 ; 
line 71595: } 
line 71596: } else if ( c == matchSet ) { 
line 71597: int prior_c = 0 ; 
line 71598: assert ( esc == 0 ) ; 
line 71599: seen = 0 ; 
line 71600: invert = 0 ; 
line 71601: c = sqlite3Utf8Read ( zString , & zString ) ; 
line 71602: if ( c == 0 ) return 0 ; 
line 71603: c2 = sqlite3Utf8Read ( zPattern , & zPattern ) ; 
line 71604: if ( c2 == '^' ) { 
line 71605: invert = 1 ; 
line 71606: c2 = sqlite3Utf8Read ( zPattern , & zPattern ) ; 
line 71607: } 
line 71608: if ( c2 == ']' ) { 
line 71609: if ( c == ']' ) seen = 1 ; 
line 71610: c2 = sqlite3Utf8Read ( zPattern , & zPattern ) ; 
line 71611: } 
line 71612: while ( c2 && c2 != ']' ) { 
line 71613: if ( c2 == '-' && zPattern [ 0 ] != ']' && zPattern [ 0 ] != 0 && prior_c > 0 ) { 
line 71614: c2 = sqlite3Utf8Read ( zPattern , & zPattern ) ; 
line 71615: if ( c >= prior_c && c <= c2 ) seen = 1 ; 
line 71616: prior_c = 0 ; 
line 71617: } else { 
line 71618: if ( c == c2 ) { 
line 71619: seen = 1 ; 
line 71620: } 
line 71621: prior_c = c2 ; 
line 71622: } 
line 71623: c2 = sqlite3Utf8Read ( zPattern , & zPattern ) ; 
line 71624: } 
line 71625: if ( c2 == 0 || ( seen ^ invert ) == 0 ) { 
line 71626: return 0 ; 
line 71627: } 
line 71628: } else if ( esc == c && ! prevEscape ) { 
line 71629: prevEscape = 1 ; 
line 71630: } else { 
line 71631: c2 = sqlite3Utf8Read ( zString , & zString ) ; 
line 71632: if ( noCase ) { 
line 71633: GlogUpperToLower ( c ) ; 
line 71634: GlogUpperToLower ( c2 ) ; 
line 71635: } 
line 71636: if ( c != c2 ) { 
line 71637: return 0 ; 
line 71638: } 
line 71639: prevEscape = 0 ; 
line 71640: } 
line 71641: } 
line 71642: return * zString == 0 ; 
line 71643: } 
line 71650: # ifdef SQLITE_TEST 
line 71651: SQLITE_API int sqlite3_like_count = 0 ; 
line 71652: # endif 
line 71667: static void likeFunc ( 
line 71668: sqlite3_context * context , 
line 71669: int argc , 
line 71670: sqlite3_value * * argv 
line 71671: ) { 
line 71672: const unsigned char * zA , * zB ; 
line 71673: int escape = 0 ; 
line 71674: int nPat ; 
line 71675: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 71677: zB = sqlite3_value_text ( argv [ 0 ] ) ; 
line 71678: zA = sqlite3_value_text ( argv [ 1 ] ) ; 
line 71683: nPat = sqlite3_value_bytes ( argv [ 0 ] ) ; 
line 71684: testcase ( nPat == db -> aLimit [ SQLITE_LIMIT_LIKE_PATTERN_LENGTH ] ) ; 
line 71685: testcase ( nPat == db -> aLimit [ SQLITE_LIMIT_LIKE_PATTERN_LENGTH ] + 1 ) ; 
line 71686: if ( nPat > db -> aLimit [ SQLITE_LIMIT_LIKE_PATTERN_LENGTH ] ) { 
line 71687: sqlite3_result_error ( context , "LIKE or GLOB pattern too complex" , - 1 ) ; 
line 71688: return ; 
line 71689: } 
line 71690: assert ( zB == sqlite3_value_text ( argv [ 0 ] ) ) ; 
line 71692: if ( argc == 3 ) { 
line 71696: const unsigned char * zEsc = sqlite3_value_text ( argv [ 2 ] ) ; 
line 71697: if ( zEsc == 0 ) return ; 
line 71698: if ( sqlite3Utf8CharLen ( ( char * ) zEsc , - 1 ) != 1 ) { 
line 71699: sqlite3_result_error ( context , 
line 71700: "ESCAPE expression must be a single character" , - 1 ) ; 
line 71701: return ; 
line 71702: } 
line 71703: escape = sqlite3Utf8Read ( zEsc , & zEsc ) ; 
line 71704: } 
line 71705: if ( zA && zB ) { 
line 71706: struct compareInfo * pInfo = sqlite3_user_data ( context ) ; 
line 71707: # ifdef SQLITE_TEST 
line 71708: sqlite3_like_count ++ ; 
line 71709: # endif 
line 71711: sqlite3_result_int ( context , patternCompare ( zB , zA , pInfo , escape ) ) ; 
line 71712: } 
line 71713: } 
line 71720: static void nullifFunc ( 
line 71721: sqlite3_context * context , 
line 71722: int NotUsed , 
line 71723: sqlite3_value * * argv 
line 71724: ) { 
line 71725: CollSeq * pColl = sqlite3GetFuncCollSeq ( context ) ; 
line 71726: UNUSED_PARAMETER ( NotUsed ) ; 
line 71727: if ( sqlite3MemCompare ( argv [ 0 ] , argv [ 1 ] , pColl ) != 0 ) { 
line 71728: sqlite3_result_value ( context , argv [ 0 ] ) ; 
line 71729: } 
line 71730: } 
line 71736: static void versionFunc ( 
line 71737: sqlite3_context * context , 
line 71738: int NotUsed , 
line 71739: sqlite3_value * * NotUsed2 
line 71740: ) { 
line 71741: UNUSED_PARAMETER2 ( NotUsed , NotUsed2 ) ; 
line 71742: sqlite3_result_text ( context , sqlite3_version , - 1 , SQLITE_STATIC ) ; 
line 71743: } 
line 71750: static void sourceidFunc ( 
line 71751: sqlite3_context * context , 
line 71752: int NotUsed , 
line 71753: sqlite3_value * * NotUsed2 
line 71754: ) { 
line 71755: UNUSED_PARAMETER2 ( NotUsed , NotUsed2 ) ; 
line 71756: sqlite3_result_text ( context , SQLITE_SOURCE_ID , - 1 , SQLITE_STATIC ) ; 
line 71757: } 
line 71761: static const char hexdigits [ ] = { 
line 71762: '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , 
line 71763: '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' 
line 71764: } ; 
line 71777: static void quoteFunc ( sqlite3_context * context , int argc , sqlite3_value * * argv ) { 
line 71778: assert ( argc == 1 ) ; 
line 71779: UNUSED_PARAMETER ( argc ) ; 
line 71780: switch ( sqlite3_value_type ( argv [ 0 ] ) ) { 
line 71781: case SQLITE_INTEGER : 
line 71782: case SQLITE_FLOAT : { 
line 71783: sqlite3_result_value ( context , argv [ 0 ] ) ; 
line 71784: break ; 
line 71785: } 
line 71786: case SQLITE_BLOB : { 
line 71787: char * zText = 0 ; 
line 71788: char const * zBlob = sqlite3_value_blob ( argv [ 0 ] ) ; 
line 71789: int nBlob = sqlite3_value_bytes ( argv [ 0 ] ) ; 
line 71790: assert ( zBlob == sqlite3_value_blob ( argv [ 0 ] ) ) ; 
line 71791: zText = ( char * ) contextMalloc ( context , ( 2 * ( i64 ) nBlob ) + 4 ) ; 
line 71792: if ( zText ) { 
line 71793: int i ; 
line 71794: for ( i = 0 ; i < nBlob ; i ++ ) { 
line 71795: zText [ ( i * 2 ) + 2 ] = hexdigits [ ( zBlob [ i ] >> 4 ) & 0x0F ] ; 
line 71796: zText [ ( i * 2 ) + 3 ] = hexdigits [ ( zBlob [ i ] ) & 0x0F ] ; 
line 71797: } 
line 71798: zText [ ( nBlob * 2 ) + 2 ] = '\'' ; 
line 71799: zText [ ( nBlob * 2 ) + 3 ] = '\0' ; 
line 71800: zText [ 0 ] = 'X' ; 
line 71801: zText [ 1 ] = '\'' ; 
line 71802: sqlite3_result_text ( context , zText , - 1 , SQLITE_TRANSIENT ) ; 
line 71803: sqlite3_free ( zText ) ; 
line 71804: } 
line 71805: break ; 
line 71806: } 
line 71807: case SQLITE_TEXT : { 
line 71808: int i , j ; 
line 71809: u64 n ; 
line 71810: const unsigned char * zArg = sqlite3_value_text ( argv [ 0 ] ) ; 
line 71811: char * z ; 
line 71813: if ( zArg == 0 ) return ; 
line 71814: for ( i = 0 , n = 0 ; zArg [ i ] ; i ++ ) { if ( zArg [ i ] == '\'' ) n ++ ; } 
line 71815: z = contextMalloc ( context , ( ( i64 ) i ) + ( ( i64 ) n ) + 3 ) ; 
line 71816: if ( z ) { 
line 71817: z [ 0 ] = '\'' ; 
line 71818: for ( i = 0 , j = 1 ; zArg [ i ] ; i ++ ) { 
line 71819: z [ j ++ ] = zArg [ i ] ; 
line 71820: if ( zArg [ i ] == '\'' ) { 
line 71821: z [ j ++ ] = '\'' ; 
line 71822: } 
line 71823: } 
line 71824: z [ j ++ ] = '\'' ; 
line 71825: z [ j ] = 0 ; 
line 71826: sqlite3_result_text ( context , z , j , sqlite3_free ) ; 
line 71827: } 
line 71828: break ; 
line 71829: } 
line 71830: default : { 
line 71831: assert ( sqlite3_value_type ( argv [ 0 ] ) == SQLITE_NULL ) ; 
line 71832: sqlite3_result_text ( context , "NULL" , 4 , SQLITE_STATIC ) ; 
line 71833: break ; 
line 71834: } 
line 71835: } 
line 71836: } 
line 71842: static void hexFunc ( 
line 71843: sqlite3_context * context , 
line 71844: int argc , 
line 71845: sqlite3_value * * argv 
line 71846: ) { 
line 71847: int i , n ; 
line 71848: const unsigned char * pBlob ; 
line 71849: char * zHex , * z ; 
line 71850: assert ( argc == 1 ) ; 
line 71851: UNUSED_PARAMETER ( argc ) ; 
line 71852: pBlob = sqlite3_value_blob ( argv [ 0 ] ) ; 
line 71853: n = sqlite3_value_bytes ( argv [ 0 ] ) ; 
line 71854: assert ( pBlob == sqlite3_value_blob ( argv [ 0 ] ) ) ; 
line 71855: z = zHex = contextMalloc ( context , ( ( i64 ) n ) * 2 + 1 ) ; 
line 71856: if ( zHex ) { 
line 71857: for ( i = 0 ; i < n ; i ++ , pBlob ++ ) { 
line 71858: unsigned char c = * pBlob ; 
line 71859: * ( z ++ ) = hexdigits [ ( c >> 4 ) & 0xf ] ; 
line 71860: * ( z ++ ) = hexdigits [ c & 0xf ] ; 
line 71861: } 
line 71862: * z = 0 ; 
line 71863: sqlite3_result_text ( context , zHex , n * 2 , sqlite3_free ) ; 
line 71864: } 
line 71865: } 
line 71870: static void zeroblobFunc ( 
line 71871: sqlite3_context * context , 
line 71872: int argc , 
line 71873: sqlite3_value * * argv 
line 71874: ) { 
line 71875: i64 n ; 
line 71876: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 71877: assert ( argc == 1 ) ; 
line 71878: UNUSED_PARAMETER ( argc ) ; 
line 71879: n = sqlite3_value_int64 ( argv [ 0 ] ) ; 
line 71880: testcase ( n == db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) ; 
line 71881: testcase ( n == db -> aLimit [ SQLITE_LIMIT_LENGTH ] + 1 ) ; 
line 71882: if ( n > db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) { 
line 71883: sqlite3_result_error_toobig ( context ) ; 
line 71884: } else { 
line 71885: sqlite3_result_zeroblob ( context , ( int ) n ) ; 
line 71886: } 
line 71887: } 
line 71895: static void replaceFunc ( 
line 71896: sqlite3_context * context , 
line 71897: int argc , 
line 71898: sqlite3_value * * argv 
line 71899: ) { 
line 71900: const unsigned char * zStr ; 
line 71901: const unsigned char * zPattern ; 
line 71902: const unsigned char * zRep ; 
line 71903: unsigned char * zOut ; 
line 71904: int nStr ; 
line 71905: int nPattern ; 
line 71906: int nRep ; 
line 71907: i64 nOut ; 
line 71908: int loopLimit ; 
line 71909: int i , j ; 
line 71911: assert ( argc == 3 ) ; 
line 71912: UNUSED_PARAMETER ( argc ) ; 
line 71913: zStr = sqlite3_value_text ( argv [ 0 ] ) ; 
line 71914: if ( zStr == 0 ) return ; 
line 71915: nStr = sqlite3_value_bytes ( argv [ 0 ] ) ; 
line 71916: assert ( zStr == sqlite3_value_text ( argv [ 0 ] ) ) ; 
line 71917: zPattern = sqlite3_value_text ( argv [ 1 ] ) ; 
line 71918: if ( zPattern == 0 ) { 
line 71919: assert ( sqlite3_value_type ( argv [ 1 ] ) == SQLITE_NULL 
line 71920: || sqlite3_context_db_handle ( context ) -> mallocFailed ) ; 
line 71921: return ; 
line 71922: } 
line 71923: if ( zPattern [ 0 ] == 0 ) { 
line 71924: assert ( sqlite3_value_type ( argv [ 1 ] ) != SQLITE_NULL ) ; 
line 71925: sqlite3_result_value ( context , argv [ 0 ] ) ; 
line 71926: return ; 
line 71927: } 
line 71928: nPattern = sqlite3_value_bytes ( argv [ 1 ] ) ; 
line 71929: assert ( zPattern == sqlite3_value_text ( argv [ 1 ] ) ) ; 
line 71930: zRep = sqlite3_value_text ( argv [ 2 ] ) ; 
line 71931: if ( zRep == 0 ) return ; 
line 71932: nRep = sqlite3_value_bytes ( argv [ 2 ] ) ; 
line 71933: assert ( zRep == sqlite3_value_text ( argv [ 2 ] ) ) ; 
line 71934: nOut = nStr + 1 ; 
line 71935: assert ( nOut < SQLITE_MAX_LENGTH ) ; 
line 71936: zOut = contextMalloc ( context , ( i64 ) nOut ) ; 
line 71937: if ( zOut == 0 ) { 
line 71938: return ; 
line 71939: } 
line 71940: loopLimit = nStr - nPattern ; 
line 71941: for ( i = j = 0 ; i <= loopLimit ; i ++ ) { 
line 71942: if ( zStr [ i ] != zPattern [ 0 ] || memcmp ( & zStr [ i ] , zPattern , nPattern ) ) { 
line 71943: zOut [ j ++ ] = zStr [ i ] ; 
line 71944: } else { 
line 71945: u8 * zOld ; 
line 71946: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 71947: nOut += nRep - nPattern ; 
line 71948: testcase ( nOut - 1 == db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) ; 
line 71949: testcase ( nOut - 2 == db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) ; 
line 71950: if ( nOut - 1 > db -> aLimit [ SQLITE_LIMIT_LENGTH ] ) { 
line 71951: sqlite3_result_error_toobig ( context ) ; 
line 71952: sqlite3DbFree ( db , zOut ) ; 
line 71953: return ; 
line 71954: } 
line 71955: zOld = zOut ; 
line 71956: zOut = sqlite3_realloc ( zOut , ( int ) nOut ) ; 
line 71957: if ( zOut == 0 ) { 
line 71958: sqlite3_result_error_nomem ( context ) ; 
line 71959: sqlite3DbFree ( db , zOld ) ; 
line 71960: return ; 
line 71961: } 
line 71962: memcpy ( & zOut [ j ] , zRep , nRep ) ; 
line 71963: j += nRep ; 
line 71964: i += nPattern - 1 ; 
line 71965: } 
line 71966: } 
line 71967: assert ( j + nStr - i + 1 == nOut ) ; 
line 71968: memcpy ( & zOut [ j ] , & zStr [ i ] , nStr - i ) ; 
line 71969: j += nStr - i ; 
line 71970: assert ( j <= nOut ) ; 
line 71971: zOut [ j ] = 0 ; 
line 71972: sqlite3_result_text ( context , ( char * ) zOut , j , sqlite3_free ) ; 
line 71973: } 
line 71979: static void trimFunc ( 
line 71980: sqlite3_context * context , 
line 71981: int argc , 
line 71982: sqlite3_value * * argv 
line 71983: ) { 
line 71984: const unsigned char * zIn ; 
line 71985: const unsigned char * zCharSet ; 
line 71986: int nIn ; 
line 71987: int flags ; 
line 71988: int i ; 
line 71989: unsigned char * aLen = 0 ; 
line 71990: unsigned char * * azChar = 0 ; 
line 71991: int nChar ; 
line 71993: if ( sqlite3_value_type ( argv [ 0 ] ) == SQLITE_NULL ) { 
line 71994: return ; 
line 71995: } 
line 71996: zIn = sqlite3_value_text ( argv [ 0 ] ) ; 
line 71997: if ( zIn == 0 ) return ; 
line 71998: nIn = sqlite3_value_bytes ( argv [ 0 ] ) ; 
line 71999: assert ( zIn == sqlite3_value_text ( argv [ 0 ] ) ) ; 
line 72000: if ( argc == 1 ) { 
line 72001: static const unsigned char lenOne [ ] = { 1 } ; 
line 72002: static unsigned char * const azOne [ ] = { ( u8 * ) " " } ; 
line 72003: nChar = 1 ; 
line 72004: aLen = ( u8 * ) lenOne ; 
line 72005: azChar = ( unsigned char * * ) azOne ; 
line 72006: zCharSet = 0 ; 
line 72007: } else if ( ( zCharSet = sqlite3_value_text ( argv [ 1 ] ) ) == 0 ) { 
line 72008: return ; 
line 72009: } else { 
line 72010: const unsigned char * z ; 
line 72011: for ( z = zCharSet , nChar = 0 ; * z ; nChar ++ ) { 
line 72012: SQLITE_SKIP_UTF8 ( z ) ; 
line 72013: } 
line 72014: if ( nChar > 0 ) { 
line 72015: azChar = contextMalloc ( context , ( ( i64 ) nChar ) * ( sizeof ( char * ) + 1 ) ) ; 
line 72016: if ( azChar == 0 ) { 
line 72017: return ; 
line 72018: } 
line 72019: aLen = ( unsigned char * ) & azChar [ nChar ] ; 
line 72020: for ( z = zCharSet , nChar = 0 ; * z ; nChar ++ ) { 
line 72021: azChar [ nChar ] = ( unsigned char * ) z ; 
line 72022: SQLITE_SKIP_UTF8 ( z ) ; 
line 72023: aLen [ nChar ] = ( u8 ) ( z - azChar [ nChar ] ) ; 
line 72024: } 
line 72025: } 
line 72026: } 
line 72027: if ( nChar > 0 ) { 
line 72028: flags = SQLITE_PTR_TO_INT ( sqlite3_user_data ( context ) ) ; 
line 72029: if ( flags & 1 ) { 
line 72030: while ( nIn > 0 ) { 
line 72031: int len = 0 ; 
line 72032: for ( i = 0 ; i < nChar ; i ++ ) { 
line 72033: len = aLen [ i ] ; 
line 72034: if ( len <= nIn && memcmp ( zIn , azChar [ i ] , len ) == 0 ) break ; 
line 72035: } 
line 72036: if ( i >= nChar ) break ; 
line 72037: zIn += len ; 
line 72038: nIn -= len ; 
line 72039: } 
line 72040: } 
line 72041: if ( flags & 2 ) { 
line 72042: while ( nIn > 0 ) { 
line 72043: int len = 0 ; 
line 72044: for ( i = 0 ; i < nChar ; i ++ ) { 
line 72045: len = aLen [ i ] ; 
line 72046: if ( len <= nIn && memcmp ( & zIn [ nIn - len ] , azChar [ i ] , len ) == 0 ) break ; 
line 72047: } 
line 72048: if ( i >= nChar ) break ; 
line 72049: nIn -= len ; 
line 72050: } 
line 72051: } 
line 72052: if ( zCharSet ) { 
line 72053: sqlite3_free ( azChar ) ; 
line 72054: } 
line 72055: } 
line 72056: sqlite3_result_text ( context , ( char * ) zIn , nIn , SQLITE_TRANSIENT ) ; 
line 72057: } 
line 72064: # ifdef SQLITE_SOUNDEX 
line 72071: static void soundexFunc ( 
line 72072: sqlite3_context * context , 
line 72073: int argc , 
line 72074: sqlite3_value * * argv 
line 72075: ) { 
line 72076: char zResult [ 8 ] ; 
line 72077: const u8 * zIn ; 
line 72078: int i , j ; 
line 72079: static const unsigned char iCode [ ] = { 
line 72080: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 72081: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 72082: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 72083: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 72084: 0 , 0 , 1 , 2 , 3 , 0 , 1 , 2 , 0 , 0 , 2 , 2 , 4 , 5 , 5 , 0 , 
line 72085: 1 , 2 , 6 , 2 , 3 , 0 , 1 , 0 , 2 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 
line 72086: 0 , 0 , 1 , 2 , 3 , 0 , 1 , 2 , 0 , 0 , 2 , 2 , 4 , 5 , 5 , 0 , 
line 72087: 1 , 2 , 6 , 2 , 3 , 0 , 1 , 0 , 2 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 
line 72088: } ; 
line 72089: assert ( argc == 1 ) ; 
line 72090: zIn = ( u8 * ) sqlite3_value_text ( argv [ 0 ] ) ; 
line 72091: if ( zIn == 0 ) zIn = ( u8 * ) "" ; 
line 72092: for ( i = 0 ; zIn [ i ] && ! sqlite3Isalpha ( zIn [ i ] ) ; i ++ ) { } 
line 72093: if ( zIn [ i ] ) { 
line 72094: u8 prevcode = iCode [ zIn [ i ] & 0x7f ] ; 
line 72095: zResult [ 0 ] = sqlite3Toupper ( zIn [ i ] ) ; 
line 72096: for ( j = 1 ; j < 4 && zIn [ i ] ; i ++ ) { 
line 72097: int code = iCode [ zIn [ i ] & 0x7f ] ; 
line 72098: if ( code > 0 ) { 
line 72099: if ( code != prevcode ) { 
line 72100: prevcode = code ; 
line 72101: zResult [ j ++ ] = code + '0' ; 
line 72102: } 
line 72103: } else { 
line 72104: prevcode = 0 ; 
line 72105: } 
line 72106: } 
line 72107: while ( j < 4 ) { 
line 72108: zResult [ j ++ ] = '0' ; 
line 72109: } 
line 72110: zResult [ j ] = 0 ; 
line 72111: sqlite3_result_text ( context , zResult , 4 , SQLITE_TRANSIENT ) ; 
line 72112: } else { 
line 72115: sqlite3_result_text ( context , "?000" , 4 , SQLITE_STATIC ) ; 
line 72116: } 
line 72117: } 
line 72118: # endif 
line 72120: # ifndef SQLITE_OMIT_LOAD_EXTENSION 
line 72124: static void loadExt ( sqlite3_context * context , int argc , sqlite3_value * * argv ) { 
line 72125: const char * zFile = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; 
line 72126: const char * zProc ; 
line 72127: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 72128: char * zErrMsg = 0 ; 
line 72130: if ( argc == 2 ) { 
line 72131: zProc = ( const char * ) sqlite3_value_text ( argv [ 1 ] ) ; 
line 72132: } else { 
line 72133: zProc = 0 ; 
line 72134: } 
line 72135: if ( zFile && sqlite3_load_extension ( db , zFile , zProc , & zErrMsg ) ) { 
line 72136: sqlite3_result_error ( context , zErrMsg , - 1 ) ; 
line 72137: sqlite3_free ( zErrMsg ) ; 
line 72138: } 
line 72139: } 
line 72140: # endif 
line 72147: typedef struct SumCtx SumCtx ; 
line 72148: struct SumCtx { 
line 72149: double rSum ; 
line 72150: i64 iSum ; 
line 72151: i64 cnt ; 
line 72152: u8 overflow ; 
line 72153: u8 approx ; 
line 72154: } ; 
line 72166: static void sumStep ( sqlite3_context * context , int argc , sqlite3_value * * argv ) { 
line 72167: SumCtx * p ; 
line 72168: int type ; 
line 72169: assert ( argc == 1 ) ; 
line 72170: UNUSED_PARAMETER ( argc ) ; 
line 72171: p = sqlite3_aggregate_context ( context , sizeof ( * p ) ) ; 
line 72172: type = sqlite3_value_numeric_type ( argv [ 0 ] ) ; 
line 72173: if ( p && type != SQLITE_NULL ) { 
line 72174: p -> cnt ++ ; 
line 72175: if ( type == SQLITE_INTEGER ) { 
line 72176: i64 v = sqlite3_value_int64 ( argv [ 0 ] ) ; 
line 72177: p -> rSum += v ; 
line 72178: if ( ( p -> approx | p -> overflow ) == 0 ) { 
line 72179: i64 iNewSum = p -> iSum + v ; 
line 72180: int s1 = ( int ) ( p -> iSum >> ( sizeof ( i64 ) * 8 - 1 ) ) ; 
line 72181: int s2 = ( int ) ( v >> ( sizeof ( i64 ) * 8 - 1 ) ) ; 
line 72182: int s3 = ( int ) ( iNewSum >> ( sizeof ( i64 ) * 8 - 1 ) ) ; 
line 72183: p -> overflow = ( ( s1 & s2 & ~ s3 ) | ( ~ s1 & ~ s2 & s3 ) ) ? 1 : 0 ; 
line 72184: p -> iSum = iNewSum ; 
line 72185: } 
line 72186: } else { 
line 72187: p -> rSum += sqlite3_value_double ( argv [ 0 ] ) ; 
line 72188: p -> approx = 1 ; 
line 72189: } 
line 72190: } 
line 72191: } 
line 72192: static void sumFinalize ( sqlite3_context * context ) { 
line 72193: SumCtx * p ; 
line 72194: p = sqlite3_aggregate_context ( context , 0 ) ; 
line 72195: if ( p && p -> cnt > 0 ) { 
line 72196: if ( p -> overflow ) { 
line 72197: sqlite3_result_error ( context , "integer overflow" , - 1 ) ; 
line 72198: } else if ( p -> approx ) { 
line 72199: sqlite3_result_double ( context , p -> rSum ) ; 
line 72200: } else { 
line 72201: sqlite3_result_int64 ( context , p -> iSum ) ; 
line 72202: } 
line 72203: } 
line 72204: } 
line 72205: static void avgFinalize ( sqlite3_context * context ) { 
line 72206: SumCtx * p ; 
line 72207: p = sqlite3_aggregate_context ( context , 0 ) ; 
line 72208: if ( p && p -> cnt > 0 ) { 
line 72209: sqlite3_result_double ( context , p -> rSum / ( double ) p -> cnt ) ; 
line 72210: } 
line 72211: } 
line 72212: static void totalFinalize ( sqlite3_context * context ) { 
line 72213: SumCtx * p ; 
line 72214: p = sqlite3_aggregate_context ( context , 0 ) ; 
line 72216: sqlite3_result_double ( context , p ? p -> rSum : ( double ) 0 ) ; 
line 72217: } 
line 72223: typedef struct CountCtx CountCtx ; 
line 72224: struct CountCtx { 
line 72225: i64 n ; 
line 72226: } ; 
line 72231: static void countStep ( sqlite3_context * context , int argc , sqlite3_value * * argv ) { 
line 72232: CountCtx * p ; 
line 72233: p = sqlite3_aggregate_context ( context , sizeof ( * p ) ) ; 
line 72234: if ( ( argc == 0 || SQLITE_NULL != sqlite3_value_type ( argv [ 0 ] ) ) && p ) { 
line 72235: p -> n ++ ; 
line 72236: } 
line 72238: # ifndef SQLITE_OMIT_DEPRECATED 
line 72243: assert ( argc == 1 || p == 0 || p -> n > 0x7fffffff 
line 72244: || p -> n == sqlite3_aggregate_count ( context ) ) ; 
line 72245: # endif 
line 72246: } 
line 72247: static void countFinalize ( sqlite3_context * context ) { 
line 72248: CountCtx * p ; 
line 72249: p = sqlite3_aggregate_context ( context , 0 ) ; 
line 72250: sqlite3_result_int64 ( context , p ? p -> n : 0 ) ; 
line 72251: } 
line 72256: static void minmaxStep ( 
line 72257: sqlite3_context * context , 
line 72258: int NotUsed , 
line 72259: sqlite3_value * * argv 
line 72260: ) { 
line 72261: Mem * pArg = ( Mem * ) argv [ 0 ] ; 
line 72262: Mem * pBest ; 
line 72263: UNUSED_PARAMETER ( NotUsed ) ; 
line 72265: if ( sqlite3_value_type ( argv [ 0 ] ) == SQLITE_NULL ) return ; 
line 72266: pBest = ( Mem * ) sqlite3_aggregate_context ( context , sizeof ( * pBest ) ) ; 
line 72267: if ( ! pBest ) return ; 
line 72269: if ( pBest -> flags ) { 
line 72270: int max ; 
line 72271: int cmp ; 
line 72272: CollSeq * pColl = sqlite3GetFuncCollSeq ( context ) ; 
line 72281: max = sqlite3_user_data ( context ) != 0 ; 
line 72282: cmp = sqlite3MemCompare ( pBest , pArg , pColl ) ; 
line 72283: if ( ( max && cmp < 0 ) || ( ! max && cmp > 0 ) ) { 
line 72284: sqlite3VdbeMemCopy ( pBest , pArg ) ; 
line 72285: } 
line 72286: } else { 
line 72287: sqlite3VdbeMemCopy ( pBest , pArg ) ; 
line 72288: } 
line 72289: } 
line 72290: static void minMaxFinalize ( sqlite3_context * context ) { 
line 72291: sqlite3_value * pRes ; 
line 72292: pRes = ( sqlite3_value * ) sqlite3_aggregate_context ( context , 0 ) ; 
line 72293: if ( pRes ) { 
line 72294: if ( ALWAYS ( pRes -> flags ) ) { 
line 72295: sqlite3_result_value ( context , pRes ) ; 
line 72296: } 
line 72297: sqlite3VdbeMemRelease ( pRes ) ; 
line 72298: } 
line 72299: } 
line 72304: static void groupConcatStep ( 
line 72305: sqlite3_context * context , 
line 72306: int argc , 
line 72307: sqlite3_value * * argv 
line 72308: ) { 
line 72309: const char * zVal ; 
line 72310: StrAccum * pAccum ; 
line 72311: const char * zSep ; 
line 72312: int nVal , nSep ; 
line 72313: assert ( argc == 1 || argc == 2 ) ; 
line 72314: if ( sqlite3_value_type ( argv [ 0 ] ) == SQLITE_NULL ) return ; 
line 72315: pAccum = ( StrAccum * ) sqlite3_aggregate_context ( context , sizeof ( * pAccum ) ) ; 
line 72317: if ( pAccum ) { 
line 72318: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 72319: int firstTerm = pAccum -> useMalloc == 0 ; 
line 72320: pAccum -> useMalloc = 1 ; 
line 72321: pAccum -> mxAlloc = db -> aLimit [ SQLITE_LIMIT_LENGTH ] ; 
line 72322: if ( ! firstTerm ) { 
line 72323: if ( argc == 2 ) { 
line 72324: zSep = ( char * ) sqlite3_value_text ( argv [ 1 ] ) ; 
line 72325: nSep = sqlite3_value_bytes ( argv [ 1 ] ) ; 
line 72326: } else { 
line 72327: zSep = "," ; 
line 72328: nSep = 1 ; 
line 72329: } 
line 72330: sqlite3StrAccumAppend ( pAccum , zSep , nSep ) ; 
line 72331: } 
line 72332: zVal = ( char * ) sqlite3_value_text ( argv [ 0 ] ) ; 
line 72333: nVal = sqlite3_value_bytes ( argv [ 0 ] ) ; 
line 72334: sqlite3StrAccumAppend ( pAccum , zVal , nVal ) ; 
line 72335: } 
line 72336: } 
line 72337: static void groupConcatFinalize ( sqlite3_context * context ) { 
line 72338: StrAccum * pAccum ; 
line 72339: pAccum = sqlite3_aggregate_context ( context , 0 ) ; 
line 72340: if ( pAccum ) { 
line 72341: if ( pAccum -> tooBig ) { 
line 72342: sqlite3_result_error_toobig ( context ) ; 
line 72343: } else if ( pAccum -> mallocFailed ) { 
line 72344: sqlite3_result_error_nomem ( context ) ; 
line 72345: } else { 
line 72346: sqlite3_result_text ( context , sqlite3StrAccumFinish ( pAccum ) , - 1 , 
line 72347: sqlite3_free ) ; 
line 72348: } 
line 72349: } 
line 72350: } 
line 72357: SQLITE_PRIVATE void sqlite3RegisterBuiltinFunctions ( sqlite3 * db ) { 
line 72358: # ifndef SQLITE_OMIT_ALTERTABLE 
line 72359: sqlite3AlterFunctions ( db ) ; 
line 72360: # endif 
line 72361: if ( ! db -> mallocFailed ) { 
line 72362: int rc = sqlite3_overload_function ( db , "MATCH" , 2 ) ; 
line 72363: assert ( rc == SQLITE_NOMEM || rc == SQLITE_OK ) ; 
line 72364: if ( rc == SQLITE_NOMEM ) { 
line 72365: db -> mallocFailed = 1 ; 
line 72366: } 
line 72367: } 
line 72368: } 
line 72373: static void setLikeOptFlag ( sqlite3 * db , const char * zName , u8 flagVal ) { 
line 72374: FuncDef * pDef ; 
line 72375: pDef = sqlite3FindFunction ( db , zName , sqlite3Strlen30 ( zName ) , 
line 72376: 2 , SQLITE_UTF8 , 0 ) ; 
line 72377: if ( ALWAYS ( pDef ) ) { 
line 72378: pDef -> flags = flagVal ; 
line 72379: } 
line 72380: } 
line 72387: SQLITE_PRIVATE void sqlite3RegisterLikeFunctions ( sqlite3 * db , int caseSensitive ) { 
line 72388: struct compareInfo * pInfo ; 
line 72389: if ( caseSensitive ) { 
line 72390: pInfo = ( struct compareInfo * ) & likeInfoAlt ; 
line 72391: } else { 
line 72392: pInfo = ( struct compareInfo * ) & likeInfoNorm ; 
line 72393: } 
line 72394: sqlite3CreateFunc ( db , "like" , 2 , SQLITE_ANY , pInfo , likeFunc , 0 , 0 ) ; 
line 72395: sqlite3CreateFunc ( db , "like" , 3 , SQLITE_ANY , pInfo , likeFunc , 0 , 0 ) ; 
line 72396: sqlite3CreateFunc ( db , "glob" , 2 , SQLITE_ANY , 
line 72397: ( struct compareInfo * ) & globInfo , likeFunc , 0 , 0 ) ; 
line 72398: setLikeOptFlag ( db , "glob" , SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE ) ; 
line 72399: setLikeOptFlag ( db , "like" , 
line 72400: caseSensitive ? ( SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE ) : SQLITE_FUNC_LIKE ) ; 
line 72401: } 
line 72410: SQLITE_PRIVATE int sqlite3IsLikeFunction ( sqlite3 * db , Expr * pExpr , int * pIsNocase , char * aWc ) { 
line 72411: FuncDef * pDef ; 
line 72412: if ( pExpr -> op != TK_FUNCTION 
line 72413: || ! pExpr -> x . pList 
line 72414: || pExpr -> x . pList -> nExpr != 2 
line 72415: ) { 
line 72416: return 0 ; 
line 72417: } 
line 72418: assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ) ; 
line 72419: pDef = sqlite3FindFunction ( db , pExpr -> u . zToken , 
line 72420: sqlite3Strlen30 ( pExpr -> u . zToken ) , 
line 72421: 2 , SQLITE_UTF8 , 0 ) ; 
line 72422: if ( NEVER ( pDef == 0 ) || ( pDef -> flags & SQLITE_FUNC_LIKE ) == 0 ) { 
line 72423: return 0 ; 
line 72424: } 
line 72430: memcpy ( aWc , pDef -> pUserData , 3 ) ; 
line 72431: assert ( ( char * ) & likeInfoAlt == ( char * ) & likeInfoAlt . matchAll ) ; 
line 72432: assert ( & ( ( char * ) & likeInfoAlt ) [ 1 ] == ( char * ) & likeInfoAlt . matchOne ) ; 
line 72433: assert ( & ( ( char * ) & likeInfoAlt ) [ 2 ] == ( char * ) & likeInfoAlt . matchSet ) ; 
line 72434: * pIsNocase = ( pDef -> flags & SQLITE_FUNC_CASE ) == 0 ; 
line 72435: return 1 ; 
line 72436: } 
line 72445: SQLITE_PRIVATE void sqlite3RegisterGlobalFunctions ( void ) { 
line 72454: static SQLITE_WSD FuncDef aBuiltinFunc [ ] = { 
line 72455: FUNCTION ( ltrim , 1 , 1 , 0 , trimFunc ) , 
line 72456: FUNCTION ( ltrim , 2 , 1 , 0 , trimFunc ) , 
line 72457: FUNCTION ( rtrim , 1 , 2 , 0 , trimFunc ) , 
line 72458: FUNCTION ( rtrim , 2 , 2 , 0 , trimFunc ) , 
line 72459: FUNCTION ( trim , 1 , 3 , 0 , trimFunc ) , 
line 72460: FUNCTION ( trim , 2 , 3 , 0 , trimFunc ) , 
line 72461: FUNCTION ( min , - 1 , 0 , 1 , minmaxFunc ) , 
line 72462: FUNCTION ( min , 0 , 0 , 1 , 0 ) , 
line 72463: AGGREGATE ( min , 1 , 0 , 1 , minmaxStep , minMaxFinalize ) , 
line 72464: FUNCTION ( max , - 1 , 1 , 1 , minmaxFunc ) , 
line 72465: FUNCTION ( max , 0 , 1 , 1 , 0 ) , 
line 72466: AGGREGATE ( max , 1 , 1 , 1 , minmaxStep , minMaxFinalize ) , 
line 72467: FUNCTION ( typeof , 1 , 0 , 0 , typeofFunc ) , 
line 72468: FUNCTION ( length , 1 , 0 , 0 , lengthFunc ) , 
line 72469: FUNCTION ( substr , 2 , 0 , 0 , substrFunc ) , 
line 72470: FUNCTION ( substr , 3 , 0 , 0 , substrFunc ) , 
line 72471: FUNCTION ( abs , 1 , 0 , 0 , absFunc ) , 
line 72472: # ifndef SQLITE_OMIT_FLOATING_POINT 
line 72473: FUNCTION ( round , 1 , 0 , 0 , roundFunc ) , 
line 72474: FUNCTION ( round , 2 , 0 , 0 , roundFunc ) , 
line 72475: # endif 
line 72476: FUNCTION ( upper , 1 , 0 , 0 , upperFunc ) , 
line 72477: FUNCTION ( lower , 1 , 0 , 0 , lowerFunc ) , 
line 72478: FUNCTION ( coalesce , 1 , 0 , 0 , 0 ) , 
line 72479: FUNCTION ( coalesce , 0 , 0 , 0 , 0 ) , 
line 72481: { - 1 , SQLITE_UTF8 , SQLITE_FUNC_COALESCE , 0 , 0 , ifnullFunc , 0 , 0 , "coalesce" , 0 } , 
line 72482: FUNCTION ( hex , 1 , 0 , 0 , hexFunc ) , 
line 72484: { 2 , SQLITE_UTF8 , SQLITE_FUNC_COALESCE , 0 , 0 , ifnullFunc , 0 , 0 , "ifnull" , 0 } , 
line 72485: FUNCTION ( random , 0 , 0 , 0 , randomFunc ) , 
line 72486: FUNCTION ( randomblob , 1 , 0 , 0 , randomBlob ) , 
line 72487: FUNCTION ( nullif , 2 , 0 , 1 , nullifFunc ) , 
line 72488: FUNCTION ( sqlite_version , 0 , 0 , 0 , versionFunc ) , 
line 72489: FUNCTION ( sqlite_source_id , 0 , 0 , 0 , sourceidFunc ) , 
line 72490: FUNCTION ( quote , 1 , 0 , 0 , quoteFunc ) , 
line 72491: FUNCTION ( last_insert_rowid , 0 , 0 , 0 , last_insert_rowid ) , 
line 72492: FUNCTION ( changes , 0 , 0 , 0 , changes ) , 
line 72493: FUNCTION ( total_changes , 0 , 0 , 0 , total_changes ) , 
line 72494: FUNCTION ( replace , 3 , 0 , 0 , replaceFunc ) , 
line 72495: FUNCTION ( zeroblob , 1 , 0 , 0 , zeroblobFunc ) , 
line 72496: # ifdef SQLITE_SOUNDEX 
line 72497: FUNCTION ( soundex , 1 , 0 , 0 , soundexFunc ) , 
line 72498: # endif 
line 72499: # ifndef SQLITE_OMIT_LOAD_EXTENSION 
line 72500: FUNCTION ( load_extension , 1 , 0 , 0 , loadExt ) , 
line 72501: FUNCTION ( load_extension , 2 , 0 , 0 , loadExt ) , 
line 72502: # endif 
line 72503: AGGREGATE ( sum , 1 , 0 , 0 , sumStep , sumFinalize ) , 
line 72504: AGGREGATE ( total , 1 , 0 , 0 , sumStep , totalFinalize ) , 
line 72505: AGGREGATE ( avg , 1 , 0 , 0 , sumStep , avgFinalize ) , 
line 72507: { 0 , SQLITE_UTF8 , SQLITE_FUNC_COUNT , 0 , 0 , 0 , countStep , countFinalize , "count" , 0 } , 
line 72508: AGGREGATE ( count , 1 , 0 , 0 , countStep , countFinalize ) , 
line 72509: AGGREGATE ( group_concat , 1 , 0 , 0 , groupConcatStep , groupConcatFinalize ) , 
line 72510: AGGREGATE ( group_concat , 2 , 0 , 0 , groupConcatStep , groupConcatFinalize ) , 
line 72512: LIKEFUNC ( glob , 2 , & globInfo , SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE ) , 
line 72513: # ifdef SQLITE_CASE_SENSITIVE_LIKE 
line 72514: LIKEFUNC ( like , 2 , & likeInfoAlt , SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE ) , 
line 72515: LIKEFUNC ( like , 3 , & likeInfoAlt , SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE ) , 
line 72516: # else 
line 72517: LIKEFUNC ( like , 2 , & likeInfoNorm , SQLITE_FUNC_LIKE ) , 
line 72518: LIKEFUNC ( like , 3 , & likeInfoNorm , SQLITE_FUNC_LIKE ) , 
line 72519: # endif 
line 72520: } ; 
line 72522: int i ; 
line 72523: FuncDefHash * pHash = & GLOBAL ( FuncDefHash , sqlite3GlobalFunctions ) ; 
line 72524: FuncDef * aFunc = ( FuncDef * ) & GLOBAL ( FuncDef , aBuiltinFunc ) ; 
line 72526: for ( i = 0 ; i < ArraySize ( aBuiltinFunc ) ; i ++ ) { 
line 72527: sqlite3FuncDefInsert ( pHash , & aFunc [ i ] ) ; 
line 72528: } 
line 72529: sqlite3RegisterDateTimeFunctions ( ) ; 
line 72530: } 
line 72548: # ifndef SQLITE_OMIT_FOREIGN_KEY 
line 72549: # ifndef SQLITE_OMIT_TRIGGER 
line 72713: static int locateFkeyIndex ( 
line 72714: Parse * pParse , 
line 72715: Table * pParent , 
line 72716: FKey * pFKey , 
line 72717: Index * * ppIdx , 
line 72718: int * * paiCol 
line 72719: ) { 
line 72720: Index * pIdx = 0 ; 
line 72721: int * aiCol = 0 ; 
line 72722: int nCol = pFKey -> nCol ; 
line 72723: char * zKey = pFKey -> aCol [ 0 ] . zCol ; 
line 72726: assert ( ppIdx && * ppIdx == 0 ) ; 
line 72727: assert ( ! paiCol || * paiCol == 0 ) ; 
line 72728: assert ( pParse ) ; 
line 72738: if ( nCol == 1 ) { 
line 72746: if ( pParent -> iPKey >= 0 ) { 
line 72747: if ( ! zKey ) return 0 ; 
line 72748: if ( ! sqlite3StrICmp ( pParent -> aCol [ pParent -> iPKey ] . zName , zKey ) ) return 0 ; 
line 72749: } 
line 72750: } else if ( paiCol ) { 
line 72751: assert ( nCol > 1 ) ; 
line 72752: aiCol = ( int * ) sqlite3DbMallocRaw ( pParse -> db , nCol * sizeof ( int ) ) ; 
line 72753: if ( ! aiCol ) return 1 ; 
line 72754: * paiCol = aiCol ; 
line 72755: } 
line 72757: for ( pIdx = pParent -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { 
line 72758: if ( pIdx -> nColumn == nCol && pIdx -> onError != OE_None ) { 
line 72763: if ( zKey == 0 ) { 
line 72767: if ( pIdx -> autoIndex == 2 ) { 
line 72768: if ( aiCol ) { 
line 72769: int i ; 
line 72770: for ( i = 0 ; i < nCol ; i ++ ) aiCol [ i ] = pFKey -> aCol [ i ] . iFrom ; 
line 72771: } 
line 72772: break ; 
line 72773: } 
line 72774: } else { 
line 72779: int i , j ; 
line 72780: for ( i = 0 ; i < nCol ; i ++ ) { 
line 72781: int iCol = pIdx -> aiColumn [ i ] ; 
line 72782: char * zDfltColl ; 
line 72783: char * zIdxCol ; 
line 72788: zDfltColl = pParent -> aCol [ iCol ] . zColl ; 
line 72789: if ( ! zDfltColl ) { 
line 72790: zDfltColl = "BINARY" ; 
line 72791: } 
line 72792: if ( sqlite3StrICmp ( pIdx -> azColl [ i ] , zDfltColl ) ) break ; 
line 72794: zIdxCol = pParent -> aCol [ iCol ] . zName ; 
line 72795: for ( j = 0 ; j < nCol ; j ++ ) { 
line 72796: if ( sqlite3StrICmp ( pFKey -> aCol [ j ] . zCol , zIdxCol ) == 0 ) { 
line 72797: if ( aiCol ) aiCol [ i ] = pFKey -> aCol [ j ] . iFrom ; 
line 72798: break ; 
line 72799: } 
line 72800: } 
line 72801: if ( j == nCol ) break ; 
line 72802: } 
line 72803: if ( i == nCol ) break ; 
line 72804: } 
line 72805: } 
line 72806: } 
line 72808: if ( ! pIdx ) { 
line 72809: if ( ! pParse -> disableTriggers ) { 
line 72810: sqlite3ErrorMsg ( pParse , "foreign key mismatch" ) ; 
line 72811: } 
line 72812: sqlite3DbFree ( pParse -> db , aiCol ) ; 
line 72813: return 1 ; 
line 72814: } 
line 72816: * ppIdx = pIdx ; 
line 72817: return 0 ; 
line 72818: } 
line 72846: static void fkLookupParent ( 
line 72847: Parse * pParse , 
line 72848: int iDb , 
line 72849: Table * pTab , 
line 72850: Index * pIdx , 
line 72851: FKey * pFKey , 
line 72852: int * aiCol , 
line 72853: int regData , 
line 72854: int nIncr , 
line 72855: int isIgnore 
line 72856: ) { 
line 72857: int i ; 
line 72858: Vdbe * v = sqlite3GetVdbe ( pParse ) ; 
line 72859: int iCur = pParse -> nTab - 1 ; 
line 72860: int iOk = sqlite3VdbeMakeLabel ( v ) ; 
line 72869: if ( nIncr < 0 ) { 
line 72870: sqlite3VdbeAddOp2 ( v , OP_FkIfZero , pFKey -> isDeferred , iOk ) ; 
line 72871: } 
line 72872: for ( i = 0 ; i < pFKey -> nCol ; i ++ ) { 
line 72873: int iReg = aiCol [ i ] + regData + 1 ; 
line 72874: sqlite3VdbeAddOp2 ( v , OP_IsNull , iReg , iOk ) ; 
line 72875: } 
line 72877: if ( isIgnore == 0 ) { 
line 72878: if ( pIdx == 0 ) { 
line 72881: int iMustBeInt ; 
line 72882: int regTemp = sqlite3GetTempReg ( pParse ) ; 
line 72889: sqlite3VdbeAddOp2 ( v , OP_SCopy , aiCol [ 0 ] + 1 + regData , regTemp ) ; 
line 72890: iMustBeInt = sqlite3VdbeAddOp2 ( v , OP_MustBeInt , regTemp , 0 ) ; 
line 72896: if ( pTab == pFKey -> pFrom && nIncr == 1 ) { 
line 72897: sqlite3VdbeAddOp3 ( v , OP_Eq , regData , iOk , regTemp ) ; 
line 72898: } 
line 72900: sqlite3OpenTable ( pParse , iCur , iDb , pTab , OP_OpenRead ) ; 
line 72901: sqlite3VdbeAddOp3 ( v , OP_NotExists , iCur , 0 , regTemp ) ; 
line 72902: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iOk ) ; 
line 72903: sqlite3VdbeJumpHere ( v , sqlite3VdbeCurrentAddr ( v ) - 2 ) ; 
line 72904: sqlite3VdbeJumpHere ( v , iMustBeInt ) ; 
line 72905: sqlite3ReleaseTempReg ( pParse , regTemp ) ; 
line 72906: } else { 
line 72907: int nCol = pFKey -> nCol ; 
line 72908: int regTemp = sqlite3GetTempRange ( pParse , nCol ) ; 
line 72909: int regRec = sqlite3GetTempReg ( pParse ) ; 
line 72910: KeyInfo * pKey = sqlite3IndexKeyinfo ( pParse , pIdx ) ; 
line 72912: sqlite3VdbeAddOp3 ( v , OP_OpenRead , iCur , pIdx -> tnum , iDb ) ; 
line 72913: sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKey , P4_KEYINFO_HANDOFF ) ; 
line 72914: for ( i = 0 ; i < nCol ; i ++ ) { 
line 72915: sqlite3VdbeAddOp2 ( v , OP_SCopy , aiCol [ i ] + 1 + regData , regTemp + i ) ; 
line 72916: } 
line 72922: if ( pTab == pFKey -> pFrom && nIncr == 1 ) { 
line 72923: int iJump = sqlite3VdbeCurrentAddr ( v ) + nCol + 1 ; 
line 72924: for ( i = 0 ; i < nCol ; i ++ ) { 
line 72925: int iChild = aiCol [ i ] + 1 + regData ; 
line 72926: int iParent = pIdx -> aiColumn [ i ] + 1 + regData ; 
line 72927: sqlite3VdbeAddOp3 ( v , OP_Ne , iChild , iJump , iParent ) ; 
line 72928: } 
line 72929: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iOk ) ; 
line 72930: } 
line 72932: sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regTemp , nCol , regRec ) ; 
line 72933: sqlite3VdbeChangeP4 ( v , - 1 , sqlite3IndexAffinityStr ( v , pIdx ) , 0 ) ; 
line 72934: sqlite3VdbeAddOp4Int ( v , OP_Found , iCur , iOk , regRec , 0 ) ; 
line 72936: sqlite3ReleaseTempReg ( pParse , regRec ) ; 
line 72937: sqlite3ReleaseTempRange ( pParse , regTemp , nCol ) ; 
line 72938: } 
line 72939: } 
line 72941: if ( ! pFKey -> isDeferred && ! pParse -> pToplevel && ! pParse -> isMultiWrite ) { 
line 72946: assert ( nIncr == 1 ) ; 
line 72947: sqlite3HaltConstraint ( 
line 72948: pParse , OE_Abort , "foreign key constraint failed" , P4_STATIC 
line 72949: ) ; 
line 72950: } else { 
line 72951: if ( nIncr > 0 && pFKey -> isDeferred == 0 ) { 
line 72952: sqlite3ParseToplevel ( pParse ) -> mayAbort = 1 ; 
line 72953: } 
line 72954: sqlite3VdbeAddOp2 ( v , OP_FkCounter , pFKey -> isDeferred , nIncr ) ; 
line 72955: } 
line 72957: sqlite3VdbeResolveLabel ( v , iOk ) ; 
line 72958: sqlite3VdbeAddOp1 ( v , OP_Close , iCur ) ; 
line 72959: } 
line 72989: static void fkScanChildren ( 
line 72990: Parse * pParse , 
line 72991: SrcList * pSrc , 
line 72992: Table * pTab , 
line 72993: Index * pIdx , 
line 72994: FKey * pFKey , 
line 72995: int * aiCol , 
line 72996: int regData , 
line 72997: int nIncr 
line 72998: ) { 
line 72999: sqlite3 * db = pParse -> db ; 
line 73000: int i ; 
line 73001: Expr * pWhere = 0 ; 
line 73002: NameContext sNameContext ; 
line 73003: WhereInfo * pWInfo ; 
line 73004: int iFkIfZero = 0 ; 
line 73005: Vdbe * v = sqlite3GetVdbe ( pParse ) ; 
line 73007: assert ( ! pIdx || pIdx -> pTable == pTab ) ; 
line 73009: if ( nIncr < 0 ) { 
line 73010: iFkIfZero = sqlite3VdbeAddOp2 ( v , OP_FkIfZero , pFKey -> isDeferred , 0 ) ; 
line 73011: } 
line 73021: for ( i = 0 ; i < pFKey -> nCol ; i ++ ) { 
line 73022: Expr * pLeft ; 
line 73023: Expr * pRight ; 
line 73024: Expr * pEq ; 
line 73025: int iCol ; 
line 73026: const char * zCol ; 
line 73028: pLeft = sqlite3Expr ( db , TK_REGISTER , 0 ) ; 
line 73029: if ( pLeft ) { 
line 73032: if ( pIdx ) { 
line 73033: Column * pCol ; 
line 73034: iCol = pIdx -> aiColumn [ i ] ; 
line 73035: pCol = & pIdx -> pTable -> aCol [ iCol ] ; 
line 73036: pLeft -> iTable = regData + iCol + 1 ; 
line 73037: pLeft -> affinity = pCol -> affinity ; 
line 73038: pLeft -> pColl = sqlite3LocateCollSeq ( pParse , pCol -> zColl ) ; 
line 73039: } else { 
line 73040: pLeft -> iTable = regData ; 
line 73041: pLeft -> affinity = SQLITE_AFF_INTEGER ; 
line 73042: } 
line 73043: } 
line 73044: iCol = aiCol ? aiCol [ i ] : pFKey -> aCol [ 0 ] . iFrom ; 
line 73045: assert ( iCol >= 0 ) ; 
line 73046: zCol = pFKey -> pFrom -> aCol [ iCol ] . zName ; 
line 73047: pRight = sqlite3Expr ( db , TK_ID , zCol ) ; 
line 73048: pEq = sqlite3PExpr ( pParse , TK_EQ , pLeft , pRight , 0 ) ; 
line 73049: pWhere = sqlite3ExprAnd ( db , pWhere , pEq ) ; 
line 73050: } 
line 73056: if ( pTab == pFKey -> pFrom && nIncr > 0 ) { 
line 73057: Expr * pEq ; 
line 73058: Expr * pLeft ; 
line 73059: Expr * pRight ; 
line 73060: pLeft = sqlite3Expr ( db , TK_REGISTER , 0 ) ; 
line 73061: pRight = sqlite3Expr ( db , TK_COLUMN , 0 ) ; 
line 73062: if ( pLeft && pRight ) { 
line 73063: pLeft -> iTable = regData ; 
line 73064: pLeft -> affinity = SQLITE_AFF_INTEGER ; 
line 73065: pRight -> iTable = pSrc -> a [ 0 ] . iCursor ; 
line 73066: pRight -> iColumn = - 1 ; 
line 73067: } 
line 73068: pEq = sqlite3PExpr ( pParse , TK_NE , pLeft , pRight , 0 ) ; 
line 73069: pWhere = sqlite3ExprAnd ( db , pWhere , pEq ) ; 
line 73070: } 
line 73073: memset ( & sNameContext , 0 , sizeof ( NameContext ) ) ; 
line 73074: sNameContext . pSrcList = pSrc ; 
line 73075: sNameContext . pParse = pParse ; 
line 73076: sqlite3ResolveExprNames ( & sNameContext , pWhere ) ; 
line 73082: pWInfo = sqlite3WhereBegin ( pParse , pSrc , pWhere , 0 , 0 ) ; 
line 73083: if ( nIncr > 0 && pFKey -> isDeferred == 0 ) { 
line 73084: sqlite3ParseToplevel ( pParse ) -> mayAbort = 1 ; 
line 73085: } 
line 73086: sqlite3VdbeAddOp2 ( v , OP_FkCounter , pFKey -> isDeferred , nIncr ) ; 
line 73087: if ( pWInfo ) { 
line 73088: sqlite3WhereEnd ( pWInfo ) ; 
line 73089: } 
line 73092: sqlite3ExprDelete ( db , pWhere ) ; 
line 73093: if ( iFkIfZero ) { 
line 73094: sqlite3VdbeJumpHere ( v , iFkIfZero ) ; 
line 73095: } 
line 73096: } 
line 73112: SQLITE_PRIVATE FKey * sqlite3FkReferences ( Table * pTab ) { 
line 73113: int nName = sqlite3Strlen30 ( pTab -> zName ) ; 
line 73114: return ( FKey * ) sqlite3HashFind ( & pTab -> pSchema -> fkeyHash , pTab -> zName , nName ) ; 
line 73115: } 
line 73125: static void fkTriggerDelete ( sqlite3 * dbMem , Trigger * p ) { 
line 73126: if ( p ) { 
line 73127: TriggerStep * pStep = p -> step_list ; 
line 73128: sqlite3ExprDelete ( dbMem , pStep -> pWhere ) ; 
line 73129: sqlite3ExprListDelete ( dbMem , pStep -> pExprList ) ; 
line 73130: sqlite3SelectDelete ( dbMem , pStep -> pSelect ) ; 
line 73131: sqlite3ExprDelete ( dbMem , p -> pWhen ) ; 
line 73132: sqlite3DbFree ( dbMem , p ) ; 
line 73133: } 
line 73134: } 
line 73153: SQLITE_PRIVATE void sqlite3FkDropTable ( Parse * pParse , SrcList * pName , Table * pTab ) { 
line 73154: sqlite3 * db = pParse -> db ; 
line 73155: if ( ( db -> flags & SQLITE_ForeignKeys ) && ! IsVirtual ( pTab ) && ! pTab -> pSelect ) { 
line 73156: int iSkip = 0 ; 
line 73157: Vdbe * v = sqlite3GetVdbe ( pParse ) ; 
line 73159: assert ( v ) ; 
line 73160: if ( sqlite3FkReferences ( pTab ) == 0 ) { 
line 73166: FKey * p ; 
line 73167: for ( p = pTab -> pFKey ; p ; p = p -> pNextFrom ) { 
line 73168: if ( p -> isDeferred ) break ; 
line 73169: } 
line 73170: if ( ! p ) return ; 
line 73171: iSkip = sqlite3VdbeMakeLabel ( v ) ; 
line 73172: sqlite3VdbeAddOp2 ( v , OP_FkIfZero , 1 , iSkip ) ; 
line 73173: } 
line 73175: pParse -> disableTriggers = 1 ; 
line 73176: sqlite3DeleteFrom ( pParse , sqlite3SrcListDup ( db , pName , 0 ) , 0 ) ; 
line 73177: pParse -> disableTriggers = 0 ; 
line 73183: sqlite3VdbeAddOp2 ( v , OP_FkIfZero , 0 , sqlite3VdbeCurrentAddr ( v ) + 2 ) ; 
line 73184: sqlite3HaltConstraint ( 
line 73185: pParse , OE_Abort , "foreign key constraint failed" , P4_STATIC 
line 73186: ) ; 
line 73188: if ( iSkip ) { 
line 73189: sqlite3VdbeResolveLabel ( v , iSkip ) ; 
line 73190: } 
line 73191: } 
line 73192: } 
line 73214: SQLITE_PRIVATE void sqlite3FkCheck ( 
line 73215: Parse * pParse , 
line 73216: Table * pTab , 
line 73217: int regOld , 
line 73218: int regNew 
line 73219: ) { 
line 73220: sqlite3 * db = pParse -> db ; 
line 73221: Vdbe * v ; 
line 73222: FKey * pFKey ; 
line 73223: int iDb ; 
line 73224: const char * zDb ; 
line 73225: int isIgnoreErrors = pParse -> disableTriggers ; 
line 73228: assert ( ( regOld == 0 ) != ( regNew == 0 ) ) ; 
line 73231: if ( ( db -> flags & SQLITE_ForeignKeys ) == 0 ) return ; 
line 73233: v = sqlite3GetVdbe ( pParse ) ; 
line 73234: iDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; 
line 73235: zDb = db -> aDb [ iDb ] . zName ; 
line 73239: for ( pFKey = pTab -> pFKey ; pFKey ; pFKey = pFKey -> pNextFrom ) { 
line 73240: Table * pTo ; 
line 73241: Index * pIdx = 0 ; 
line 73242: int * aiFree = 0 ; 
line 73243: int * aiCol ; 
line 73244: int iCol ; 
line 73245: int i ; 
line 73246: int isIgnore = 0 ; 
line 73252: if ( pParse -> disableTriggers ) { 
line 73253: pTo = sqlite3FindTable ( db , pFKey -> zTo , zDb ) ; 
line 73254: } else { 
line 73255: pTo = sqlite3LocateTable ( pParse , 0 , pFKey -> zTo , zDb ) ; 
line 73256: } 
line 73257: if ( ! pTo || locateFkeyIndex ( pParse , pTo , pFKey , & pIdx , & aiFree ) ) { 
line 73258: if ( ! isIgnoreErrors || db -> mallocFailed ) return ; 
line 73259: continue ; 
line 73260: } 
line 73261: assert ( pFKey -> nCol == 1 || ( aiFree && pIdx ) ) ; 
line 73263: if ( aiFree ) { 
line 73264: aiCol = aiFree ; 
line 73265: } else { 
line 73266: iCol = pFKey -> aCol [ 0 ] . iFrom ; 
line 73267: aiCol = & iCol ; 
line 73268: } 
line 73269: for ( i = 0 ; i < pFKey -> nCol ; i ++ ) { 
line 73270: if ( aiCol [ i ] == pTab -> iPKey ) { 
line 73271: aiCol [ i ] = - 1 ; 
line 73272: } 
line 73273: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 73277: if ( db -> xAuth ) { 
line 73278: int rcauth ; 
line 73279: char * zCol = pTo -> aCol [ pIdx ? pIdx -> aiColumn [ i ] : pTo -> iPKey ] . zName ; 
line 73280: rcauth = sqlite3AuthReadCol ( pParse , pTo -> zName , zCol , iDb ) ; 
line 73281: isIgnore = ( rcauth == SQLITE_IGNORE ) ; 
line 73282: } 
line 73283: # endif 
line 73284: } 
line 73289: sqlite3TableLock ( pParse , iDb , pTo -> tnum , 0 , pTo -> zName ) ; 
line 73290: pParse -> nTab ++ ; 
line 73292: if ( regOld != 0 ) { 
line 73296: fkLookupParent ( pParse , iDb , pTo , pIdx , pFKey , aiCol , regOld , - 1 , isIgnore ) ; 
line 73297: } 
line 73298: if ( regNew != 0 ) { 
line 73301: fkLookupParent ( pParse , iDb , pTo , pIdx , pFKey , aiCol , regNew , + 1 , isIgnore ) ; 
line 73302: } 
line 73304: sqlite3DbFree ( db , aiFree ) ; 
line 73305: } 
line 73308: for ( pFKey = sqlite3FkReferences ( pTab ) ; pFKey ; pFKey = pFKey -> pNextTo ) { 
line 73309: Index * pIdx = 0 ; 
line 73310: SrcList * pSrc ; 
line 73311: int * aiCol = 0 ; 
line 73313: if ( ! pFKey -> isDeferred && ! pParse -> pToplevel && ! pParse -> isMultiWrite ) { 
line 73314: assert ( regOld == 0 && regNew != 0 ) ; 
line 73317: continue ; 
line 73318: } 
line 73320: if ( locateFkeyIndex ( pParse , pTab , pFKey , & pIdx , & aiCol ) ) { 
line 73321: if ( ! isIgnoreErrors || db -> mallocFailed ) return ; 
line 73322: continue ; 
line 73323: } 
line 73324: assert ( aiCol || pFKey -> nCol == 1 ) ; 
line 73329: pSrc = sqlite3SrcListAppend ( db , 0 , 0 , 0 ) ; 
line 73330: if ( pSrc ) { 
line 73331: struct SrcList_item * pItem = pSrc -> a ; 
line 73332: pItem -> pTab = pFKey -> pFrom ; 
line 73333: pItem -> zName = pFKey -> pFrom -> zName ; 
line 73334: pItem -> pTab -> nRef ++ ; 
line 73335: pItem -> iCursor = pParse -> nTab ++ ; 
line 73337: if ( regNew != 0 ) { 
line 73338: fkScanChildren ( pParse , pSrc , pTab , pIdx , pFKey , aiCol , regNew , - 1 ) ; 
line 73339: } 
line 73340: if ( regOld != 0 ) { 
line 73347: fkScanChildren ( pParse , pSrc , pTab , pIdx , pFKey , aiCol , regOld , 1 ) ; 
line 73348: } 
line 73349: pItem -> zName = 0 ; 
line 73350: sqlite3SrcListDelete ( db , pSrc ) ; 
line 73351: } 
line 73352: sqlite3DbFree ( db , aiCol ) ; 
line 73353: } 
line 73354: } 
line 73356: # define COLUMN_MASK ( x ) ( ( ( x ) > 31 ) ? 0xffffffff : ( ( u32 ) 1 << ( x ) ) ) 
line 73362: SQLITE_PRIVATE u32 sqlite3FkOldmask ( 
line 73363: Parse * pParse , 
line 73364: Table * pTab 
line 73365: ) { 
line 73366: u32 mask = 0 ; 
line 73367: if ( pParse -> db -> flags & SQLITE_ForeignKeys ) { 
line 73368: FKey * p ; 
line 73369: int i ; 
line 73370: for ( p = pTab -> pFKey ; p ; p = p -> pNextFrom ) { 
line 73371: for ( i = 0 ; i < p -> nCol ; i ++ ) mask |= COLUMN_MASK ( p -> aCol [ i ] . iFrom ) ; 
line 73372: } 
line 73373: for ( p = sqlite3FkReferences ( pTab ) ; p ; p = p -> pNextTo ) { 
line 73374: Index * pIdx = 0 ; 
line 73375: locateFkeyIndex ( pParse , pTab , p , & pIdx , 0 ) ; 
line 73376: if ( pIdx ) { 
line 73377: for ( i = 0 ; i < pIdx -> nColumn ; i ++ ) mask |= COLUMN_MASK ( pIdx -> aiColumn [ i ] ) ; 
line 73378: } 
line 73379: } 
line 73380: } 
line 73381: return mask ; 
line 73382: } 
line 73398: SQLITE_PRIVATE int sqlite3FkRequired ( 
line 73399: Parse * pParse , 
line 73400: Table * pTab , 
line 73401: int * aChange , 
line 73402: int chngRowid 
line 73403: ) { 
line 73404: if ( pParse -> db -> flags & SQLITE_ForeignKeys ) { 
line 73405: if ( ! aChange ) { 
line 73409: return ( sqlite3FkReferences ( pTab ) || pTab -> pFKey ) ; 
line 73410: } else { 
line 73413: int i ; 
line 73414: FKey * p ; 
line 73417: for ( p = pTab -> pFKey ; p ; p = p -> pNextFrom ) { 
line 73418: for ( i = 0 ; i < p -> nCol ; i ++ ) { 
line 73419: int iChildKey = p -> aCol [ i ] . iFrom ; 
line 73420: if ( aChange [ iChildKey ] >= 0 ) return 1 ; 
line 73421: if ( iChildKey == pTab -> iPKey && chngRowid ) return 1 ; 
line 73422: } 
line 73423: } 
line 73426: for ( p = sqlite3FkReferences ( pTab ) ; p ; p = p -> pNextTo ) { 
line 73427: for ( i = 0 ; i < p -> nCol ; i ++ ) { 
line 73428: char * zKey = p -> aCol [ i ] . zCol ; 
line 73429: int iKey ; 
line 73430: for ( iKey = 0 ; iKey < pTab -> nCol ; iKey ++ ) { 
line 73431: Column * pCol = & pTab -> aCol [ iKey ] ; 
line 73432: if ( ( zKey ? ! sqlite3StrICmp ( pCol -> zName , zKey ) : pCol -> isPrimKey ) ) { 
line 73433: if ( aChange [ iKey ] >= 0 ) return 1 ; 
line 73434: if ( iKey == pTab -> iPKey && chngRowid ) return 1 ; 
line 73435: } 
line 73436: } 
line 73437: } 
line 73438: } 
line 73439: } 
line 73440: } 
line 73441: return 0 ; 
line 73442: } 
line 73473: static Trigger * fkActionTrigger ( 
line 73474: Parse * pParse , 
line 73475: Table * pTab , 
line 73476: FKey * pFKey , 
line 73477: ExprList * pChanges 
line 73478: ) { 
line 73479: sqlite3 * db = pParse -> db ; 
line 73480: int action ; 
line 73481: Trigger * pTrigger ; 
line 73482: int iAction = ( pChanges != 0 ) ; 
line 73484: action = pFKey -> aAction [ iAction ] ; 
line 73485: pTrigger = pFKey -> apTrigger [ iAction ] ; 
line 73487: if ( action != OE_None && ! pTrigger ) { 
line 73488: u8 enableLookaside ; 
line 73489: char const * zFrom ; 
line 73490: int nFrom ; 
line 73491: Index * pIdx = 0 ; 
line 73492: int * aiCol = 0 ; 
line 73493: TriggerStep * pStep = 0 ; 
line 73494: Expr * pWhere = 0 ; 
line 73495: ExprList * pList = 0 ; 
line 73496: Select * pSelect = 0 ; 
line 73497: int i ; 
line 73498: Expr * pWhen = 0 ; 
line 73500: if ( locateFkeyIndex ( pParse , pTab , pFKey , & pIdx , & aiCol ) ) return 0 ; 
line 73501: assert ( aiCol || pFKey -> nCol == 1 ) ; 
line 73503: for ( i = 0 ; i < pFKey -> nCol ; i ++ ) { 
line 73504: Token tOld = { "old" , 3 } ; 
line 73505: Token tNew = { "new" , 3 } ; 
line 73506: Token tFromCol ; 
line 73507: Token tToCol ; 
line 73508: int iFromCol ; 
line 73509: Expr * pEq ; 
line 73511: iFromCol = aiCol ? aiCol [ i ] : pFKey -> aCol [ 0 ] . iFrom ; 
line 73512: assert ( iFromCol >= 0 ) ; 
line 73513: tToCol . z = pIdx ? pTab -> aCol [ pIdx -> aiColumn [ i ] ] . zName : "oid" ; 
line 73514: tFromCol . z = pFKey -> pFrom -> aCol [ iFromCol ] . zName ; 
line 73516: tToCol . n = sqlite3Strlen30 ( tToCol . z ) ; 
line 73517: tFromCol . n = sqlite3Strlen30 ( tFromCol . z ) ; 
line 73523: pEq = sqlite3PExpr ( pParse , TK_EQ , 
line 73524: sqlite3PExpr ( pParse , TK_DOT , 
line 73525: sqlite3PExpr ( pParse , TK_ID , 0 , 0 , & tOld ) , 
line 73526: sqlite3PExpr ( pParse , TK_ID , 0 , 0 , & tToCol ) 
line 73527: , 0 ) , 
line 73528: sqlite3PExpr ( pParse , TK_ID , 0 , 0 , & tFromCol ) 
line 73529: , 0 ) ; 
line 73530: pWhere = sqlite3ExprAnd ( db , pWhere , pEq ) ; 
line 73537: if ( pChanges ) { 
line 73538: pEq = sqlite3PExpr ( pParse , TK_IS , 
line 73539: sqlite3PExpr ( pParse , TK_DOT , 
line 73540: sqlite3PExpr ( pParse , TK_ID , 0 , 0 , & tOld ) , 
line 73541: sqlite3PExpr ( pParse , TK_ID , 0 , 0 , & tToCol ) , 
line 73542: 0 ) , 
line 73543: sqlite3PExpr ( pParse , TK_DOT , 
line 73544: sqlite3PExpr ( pParse , TK_ID , 0 , 0 , & tNew ) , 
line 73545: sqlite3PExpr ( pParse , TK_ID , 0 , 0 , & tToCol ) , 
line 73546: 0 ) , 
line 73547: 0 ) ; 
line 73548: pWhen = sqlite3ExprAnd ( db , pWhen , pEq ) ; 
line 73549: } 
line 73551: if ( action != OE_Restrict && ( action != OE_Cascade || pChanges ) ) { 
line 73552: Expr * pNew ; 
line 73553: if ( action == OE_Cascade ) { 
line 73554: pNew = sqlite3PExpr ( pParse , TK_DOT , 
line 73555: sqlite3PExpr ( pParse , TK_ID , 0 , 0 , & tNew ) , 
line 73556: sqlite3PExpr ( pParse , TK_ID , 0 , 0 , & tToCol ) 
line 73557: , 0 ) ; 
line 73558: } else if ( action == OE_SetDflt ) { 
line 73559: Expr * pDflt = pFKey -> pFrom -> aCol [ iFromCol ] . pDflt ; 
line 73560: if ( pDflt ) { 
line 73561: pNew = sqlite3ExprDup ( db , pDflt , 0 ) ; 
line 73562: } else { 
line 73563: pNew = sqlite3PExpr ( pParse , TK_NULL , 0 , 0 , 0 ) ; 
line 73564: } 
line 73565: } else { 
line 73566: pNew = sqlite3PExpr ( pParse , TK_NULL , 0 , 0 , 0 ) ; 
line 73567: } 
line 73568: pList = sqlite3ExprListAppend ( pParse , pList , pNew ) ; 
line 73569: sqlite3ExprListSetName ( pParse , pList , & tFromCol , 0 ) ; 
line 73570: } 
line 73571: } 
line 73572: sqlite3DbFree ( db , aiCol ) ; 
line 73574: zFrom = pFKey -> pFrom -> zName ; 
line 73575: nFrom = sqlite3Strlen30 ( zFrom ) ; 
line 73577: if ( action == OE_Restrict ) { 
line 73578: Token tFrom ; 
line 73579: Expr * pRaise ; 
line 73581: tFrom . z = zFrom ; 
line 73582: tFrom . n = nFrom ; 
line 73583: pRaise = sqlite3Expr ( db , TK_RAISE , "foreign key constraint failed" ) ; 
line 73584: if ( pRaise ) { 
line 73585: pRaise -> affinity = OE_Abort ; 
line 73586: } 
line 73587: pSelect = sqlite3SelectNew ( pParse , 
line 73588: sqlite3ExprListAppend ( pParse , 0 , pRaise ) , 
line 73589: sqlite3SrcListAppend ( db , 0 , & tFrom , 0 ) , 
line 73590: pWhere , 
line 73591: 0 , 0 , 0 , 0 , 0 , 0 
line 73592: ) ; 
line 73593: pWhere = 0 ; 
line 73594: } 
line 73601: enableLookaside = db -> lookaside . bEnabled ; 
line 73602: db -> lookaside . bEnabled = 0 ; 
line 73604: pTrigger = ( Trigger * ) sqlite3DbMallocZero ( db , 
line 73605: sizeof ( Trigger ) + 
line 73606: sizeof ( TriggerStep ) + 
line 73607: nFrom + 1 
line 73608: ) ; 
line 73609: if ( pTrigger ) { 
line 73610: pStep = pTrigger -> step_list = ( TriggerStep * ) & pTrigger [ 1 ] ; 
line 73611: pStep -> target . z = ( char * ) & pStep [ 1 ] ; 
line 73612: pStep -> target . n = nFrom ; 
line 73613: memcpy ( ( char * ) pStep -> target . z , zFrom , nFrom ) ; 
line 73615: pStep -> pWhere = sqlite3ExprDup ( db , pWhere , EXPRDUP_REDUCE ) ; 
line 73616: pStep -> pExprList = sqlite3ExprListDup ( db , pList , EXPRDUP_REDUCE ) ; 
line 73617: pStep -> pSelect = sqlite3SelectDup ( db , pSelect , EXPRDUP_REDUCE ) ; 
line 73618: if ( pWhen ) { 
line 73619: pWhen = sqlite3PExpr ( pParse , TK_NOT , pWhen , 0 , 0 ) ; 
line 73620: pTrigger -> pWhen = sqlite3ExprDup ( db , pWhen , EXPRDUP_REDUCE ) ; 
line 73621: } 
line 73622: } 
line 73625: db -> lookaside . bEnabled = enableLookaside ; 
line 73627: sqlite3ExprDelete ( db , pWhere ) ; 
line 73628: sqlite3ExprDelete ( db , pWhen ) ; 
line 73629: sqlite3ExprListDelete ( db , pList ) ; 
line 73630: sqlite3SelectDelete ( db , pSelect ) ; 
line 73631: if ( db -> mallocFailed == 1 ) { 
line 73632: fkTriggerDelete ( db , pTrigger ) ; 
line 73633: return 0 ; 
line 73634: } 
line 73636: switch ( action ) { 
line 73637: case OE_Restrict : 
line 73638: pStep -> op = TK_SELECT ; 
line 73639: break ; 
line 73640: case OE_Cascade : 
line 73641: if ( ! pChanges ) { 
line 73642: pStep -> op = TK_DELETE ; 
line 73643: break ; 
line 73644: } 
line 73645: default : 
line 73646: pStep -> op = TK_UPDATE ; 
line 73647: } 
line 73648: pStep -> pTrig = pTrigger ; 
line 73649: pTrigger -> pSchema = pTab -> pSchema ; 
line 73650: pTrigger -> pTabSchema = pTab -> pSchema ; 
line 73651: pFKey -> apTrigger [ iAction ] = pTrigger ; 
line 73652: pTrigger -> op = ( pChanges ? TK_UPDATE : TK_DELETE ) ; 
line 73653: } 
line 73655: return pTrigger ; 
line 73656: } 
line 73662: SQLITE_PRIVATE void sqlite3FkActions ( 
line 73663: Parse * pParse , 
line 73664: Table * pTab , 
line 73665: ExprList * pChanges , 
line 73666: int regOld 
line 73667: ) { 
line 73672: if ( pParse -> db -> flags & SQLITE_ForeignKeys ) { 
line 73673: FKey * pFKey ; 
line 73674: for ( pFKey = sqlite3FkReferences ( pTab ) ; pFKey ; pFKey = pFKey -> pNextTo ) { 
line 73675: Trigger * pAction = fkActionTrigger ( pParse , pTab , pFKey , pChanges ) ; 
line 73676: if ( pAction ) { 
line 73677: sqlite3CodeRowTriggerDirect ( pParse , pAction , pTab , regOld , OE_Abort , 0 ) ; 
line 73678: } 
line 73679: } 
line 73680: } 
line 73681: } 
line 73683: # endif 
line 73690: SQLITE_PRIVATE void sqlite3FkDelete ( Table * pTab ) { 
line 73691: FKey * pFKey ; 
line 73692: FKey * pNext ; 
line 73694: for ( pFKey = pTab -> pFKey ; pFKey ; pFKey = pNext ) { 
line 73697: if ( pFKey -> pPrevTo ) { 
line 73698: pFKey -> pPrevTo -> pNextTo = pFKey -> pNextTo ; 
line 73699: } else { 
line 73700: void * data = ( void * ) pFKey -> pNextTo ; 
line 73701: const char * z = ( data ? pFKey -> pNextTo -> zTo : pFKey -> zTo ) ; 
line 73702: sqlite3HashInsert ( & pTab -> pSchema -> fkeyHash , z , sqlite3Strlen30 ( z ) , data ) ; 
line 73703: } 
line 73704: if ( pFKey -> pNextTo ) { 
line 73705: pFKey -> pNextTo -> pPrevTo = pFKey -> pPrevTo ; 
line 73706: } 
line 73709: # ifndef SQLITE_OMIT_TRIGGER 
line 73710: fkTriggerDelete ( pTab -> dbMem , pFKey -> apTrigger [ 0 ] ) ; 
line 73711: fkTriggerDelete ( pTab -> dbMem , pFKey -> apTrigger [ 1 ] ) ; 
line 73712: # endif 
line 73717: assert ( pFKey -> isDeferred == 0 || pFKey -> isDeferred == 1 ) ; 
line 73719: pNext = pFKey -> pNextFrom ; 
line 73720: sqlite3DbFree ( pTab -> dbMem , pFKey ) ; 
line 73721: } 
line 73722: } 
line 73723: # endif 
line 73745: SQLITE_PRIVATE void sqlite3OpenTable ( 
line 73746: Parse * p , 
line 73747: int iCur , 
line 73748: int iDb , 
line 73749: Table * pTab , 
line 73750: int opcode 
line 73751: ) { 
line 73752: Vdbe * v ; 
line 73753: if ( IsVirtual ( pTab ) ) return ; 
line 73754: v = sqlite3GetVdbe ( p ) ; 
line 73755: assert ( opcode == OP_OpenWrite || opcode == OP_OpenRead ) ; 
line 73756: sqlite3TableLock ( p , iDb , pTab -> tnum , ( opcode == OP_OpenWrite ) ? 1 : 0 , pTab -> zName ) ; 
line 73757: sqlite3VdbeAddOp3 ( v , opcode , iCur , pTab -> tnum , iDb ) ; 
line 73758: sqlite3VdbeChangeP4 ( v , - 1 , SQLITE_INT_TO_PTR ( pTab -> nCol ) , P4_INT32 ) ; 
line 73759: VdbeComment ( ( v , "%s" , pTab -> zName ) ) ; 
line 73760: } 
line 73782: SQLITE_PRIVATE const char * sqlite3IndexAffinityStr ( Vdbe * v , Index * pIdx ) { 
line 73783: if ( ! pIdx -> zColAff ) { 
line 73792: int n ; 
line 73793: Table * pTab = pIdx -> pTable ; 
line 73794: sqlite3 * db = sqlite3VdbeDb ( v ) ; 
line 73795: pIdx -> zColAff = ( char * ) sqlite3Malloc ( pIdx -> nColumn + 2 ) ; 
line 73796: if ( ! pIdx -> zColAff ) { 
line 73797: db -> mallocFailed = 1 ; 
line 73798: return 0 ; 
line 73799: } 
line 73800: for ( n = 0 ; n < pIdx -> nColumn ; n ++ ) { 
line 73801: pIdx -> zColAff [ n ] = pTab -> aCol [ pIdx -> aiColumn [ n ] ] . affinity ; 
line 73802: } 
line 73803: pIdx -> zColAff [ n ++ ] = SQLITE_AFF_NONE ; 
line 73804: pIdx -> zColAff [ n ] = 0 ; 
line 73805: } 
line 73807: return pIdx -> zColAff ; 
line 73808: } 
line 73824: SQLITE_PRIVATE void sqlite3TableAffinityStr ( Vdbe * v , Table * pTab ) { 
line 73832: if ( ! pTab -> zColAff ) { 
line 73833: char * zColAff ; 
line 73834: int i ; 
line 73835: sqlite3 * db = sqlite3VdbeDb ( v ) ; 
line 73837: zColAff = ( char * ) sqlite3Malloc ( pTab -> nCol + 1 ) ; 
line 73838: if ( ! zColAff ) { 
line 73839: db -> mallocFailed = 1 ; 
line 73840: return ; 
line 73841: } 
line 73843: for ( i = 0 ; i < pTab -> nCol ; i ++ ) { 
line 73844: zColAff [ i ] = pTab -> aCol [ i ] . affinity ; 
line 73845: } 
line 73846: zColAff [ pTab -> nCol ] = '\0' ; 
line 73848: pTab -> zColAff = zColAff ; 
line 73849: } 
line 73851: sqlite3VdbeChangeP4 ( v , - 1 , pTab -> zColAff , 0 ) ; 
line 73852: } 
line 73861: static int readsTable ( Parse * p , int iStartAddr , int iDb , Table * pTab ) { 
line 73862: Vdbe * v = sqlite3GetVdbe ( p ) ; 
line 73863: int i ; 
line 73864: int iEnd = sqlite3VdbeCurrentAddr ( v ) ; 
line 73865: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 73866: VTable * pVTab = IsVirtual ( pTab ) ? sqlite3GetVTable ( p -> db , pTab ) : 0 ; 
line 73867: # endif 
line 73869: for ( i = iStartAddr ; i < iEnd ; i ++ ) { 
line 73870: VdbeOp * pOp = sqlite3VdbeGetOp ( v , i ) ; 
line 73871: assert ( pOp != 0 ) ; 
line 73872: if ( pOp -> opcode == OP_OpenRead && pOp -> p3 == iDb ) { 
line 73873: Index * pIndex ; 
line 73874: int tnum = pOp -> p2 ; 
line 73875: if ( tnum == pTab -> tnum ) { 
line 73876: return 1 ; 
line 73877: } 
line 73878: for ( pIndex = pTab -> pIndex ; pIndex ; pIndex = pIndex -> pNext ) { 
line 73879: if ( tnum == pIndex -> tnum ) { 
line 73880: return 1 ; 
line 73881: } 
line 73882: } 
line 73883: } 
line 73884: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 73885: if ( pOp -> opcode == OP_VOpen && pOp -> p4 . pVtab == pVTab ) { 
line 73886: assert ( pOp -> p4 . pVtab != 0 ) ; 
line 73887: assert ( pOp -> p4type == P4_VTAB ) ; 
line 73888: return 1 ; 
line 73889: } 
line 73890: # endif 
line 73891: } 
line 73892: return 0 ; 
line 73893: } 
line 73895: # ifndef SQLITE_OMIT_AUTOINCREMENT 
line 73916: static int autoIncBegin ( 
line 73917: Parse * pParse , 
line 73918: int iDb , 
line 73919: Table * pTab 
line 73920: ) { 
line 73921: int memId = 0 ; 
line 73922: if ( pTab -> tabFlags & TF_Autoincrement ) { 
line 73923: Parse * pToplevel = sqlite3ParseToplevel ( pParse ) ; 
line 73924: AutoincInfo * pInfo ; 
line 73926: pInfo = pToplevel -> pAinc ; 
line 73927: while ( pInfo && pInfo -> pTab != pTab ) { pInfo = pInfo -> pNext ; } 
line 73928: if ( pInfo == 0 ) { 
line 73929: pInfo = sqlite3DbMallocRaw ( pParse -> db , sizeof ( * pInfo ) ) ; 
line 73930: if ( pInfo == 0 ) return 0 ; 
line 73931: pInfo -> pNext = pToplevel -> pAinc ; 
line 73932: pToplevel -> pAinc = pInfo ; 
line 73933: pInfo -> pTab = pTab ; 
line 73934: pInfo -> iDb = iDb ; 
line 73935: pToplevel -> nMem ++ ; 
line 73936: pInfo -> regCtr = ++ pToplevel -> nMem ; 
line 73937: pToplevel -> nMem ++ ; 
line 73938: } 
line 73939: memId = pInfo -> regCtr ; 
line 73940: } 
line 73941: return memId ; 
line 73942: } 
line 73948: SQLITE_PRIVATE void sqlite3AutoincrementBegin ( Parse * pParse ) { 
line 73949: AutoincInfo * p ; 
line 73950: sqlite3 * db = pParse -> db ; 
line 73951: Db * pDb ; 
line 73952: int memId ; 
line 73953: int addr ; 
line 73954: Vdbe * v = pParse -> pVdbe ; 
line 73958: assert ( pParse -> pTriggerTab == 0 ) ; 
line 73959: assert ( pParse == sqlite3ParseToplevel ( pParse ) ) ; 
line 73961: assert ( v ) ; 
line 73962: for ( p = pParse -> pAinc ; p ; p = p -> pNext ) { 
line 73963: pDb = & db -> aDb [ p -> iDb ] ; 
line 73964: memId = p -> regCtr ; 
line 73965: sqlite3OpenTable ( pParse , 0 , p -> iDb , pDb -> pSchema -> pSeqTab , OP_OpenRead ) ; 
line 73966: addr = sqlite3VdbeCurrentAddr ( v ) ; 
line 73967: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , memId - 1 , 0 , p -> pTab -> zName , 0 ) ; 
line 73968: sqlite3VdbeAddOp2 ( v , OP_Rewind , 0 , addr + 9 ) ; 
line 73969: sqlite3VdbeAddOp3 ( v , OP_Column , 0 , 0 , memId ) ; 
line 73970: sqlite3VdbeAddOp3 ( v , OP_Ne , memId - 1 , addr + 7 , memId ) ; 
line 73971: sqlite3VdbeChangeP5 ( v , SQLITE_JUMPIFNULL ) ; 
line 73972: sqlite3VdbeAddOp2 ( v , OP_Rowid , 0 , memId + 1 ) ; 
line 73973: sqlite3VdbeAddOp3 ( v , OP_Column , 0 , 1 , memId ) ; 
line 73974: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , addr + 9 ) ; 
line 73975: sqlite3VdbeAddOp2 ( v , OP_Next , 0 , addr + 2 ) ; 
line 73976: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , memId ) ; 
line 73977: sqlite3VdbeAddOp0 ( v , OP_Close ) ; 
line 73978: } 
line 73979: } 
line 73989: static void autoIncStep ( Parse * pParse , int memId , int regRowid ) { 
line 73990: if ( memId > 0 ) { 
line 73991: sqlite3VdbeAddOp2 ( pParse -> pVdbe , OP_MemMax , memId , regRowid ) ; 
line 73992: } 
line 73993: } 
line 74002: SQLITE_PRIVATE void sqlite3AutoincrementEnd ( Parse * pParse ) { 
line 74003: AutoincInfo * p ; 
line 74004: Vdbe * v = pParse -> pVdbe ; 
line 74005: sqlite3 * db = pParse -> db ; 
line 74007: assert ( v ) ; 
line 74008: for ( p = pParse -> pAinc ; p ; p = p -> pNext ) { 
line 74009: Db * pDb = & db -> aDb [ p -> iDb ] ; 
line 74010: int j1 , j2 , j3 , j4 , j5 ; 
line 74011: int iRec ; 
line 74012: int memId = p -> regCtr ; 
line 74014: iRec = sqlite3GetTempReg ( pParse ) ; 
line 74015: sqlite3OpenTable ( pParse , 0 , p -> iDb , pDb -> pSchema -> pSeqTab , OP_OpenWrite ) ; 
line 74016: j1 = sqlite3VdbeAddOp1 ( v , OP_NotNull , memId + 1 ) ; 
line 74017: j2 = sqlite3VdbeAddOp0 ( v , OP_Rewind ) ; 
line 74018: j3 = sqlite3VdbeAddOp3 ( v , OP_Column , 0 , 0 , iRec ) ; 
line 74019: j4 = sqlite3VdbeAddOp3 ( v , OP_Eq , memId - 1 , 0 , iRec ) ; 
line 74020: sqlite3VdbeAddOp2 ( v , OP_Next , 0 , j3 ) ; 
line 74021: sqlite3VdbeJumpHere ( v , j2 ) ; 
line 74022: sqlite3VdbeAddOp2 ( v , OP_NewRowid , 0 , memId + 1 ) ; 
line 74023: j5 = sqlite3VdbeAddOp0 ( v , OP_Goto ) ; 
line 74024: sqlite3VdbeJumpHere ( v , j4 ) ; 
line 74025: sqlite3VdbeAddOp2 ( v , OP_Rowid , 0 , memId + 1 ) ; 
line 74026: sqlite3VdbeJumpHere ( v , j1 ) ; 
line 74027: sqlite3VdbeJumpHere ( v , j5 ) ; 
line 74028: sqlite3VdbeAddOp3 ( v , OP_MakeRecord , memId - 1 , 2 , iRec ) ; 
line 74029: sqlite3VdbeAddOp3 ( v , OP_Insert , 0 , iRec , memId + 1 ) ; 
line 74030: sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ) ; 
line 74031: sqlite3VdbeAddOp0 ( v , OP_Close ) ; 
line 74032: sqlite3ReleaseTempReg ( pParse , iRec ) ; 
line 74033: } 
line 74034: } 
line 74035: # else 
line 74040: # define autoIncBegin ( A , B , C ) ( 0 ) 
line 74041: # define autoIncStep ( A , B , C ) 
line 74042: # endif 
line 74046: static int xferOptimization ( 
line 74047: Parse * pParse , 
line 74048: Table * pDest , 
line 74049: Select * pSelect , 
line 74050: int onError , 
line 74051: int iDbDest 
line 74052: ) ; 
line 74156: SQLITE_PRIVATE void sqlite3Insert ( 
line 74157: Parse * pParse , 
line 74158: SrcList * pTabList , 
line 74159: ExprList * pList , 
line 74160: Select * pSelect , 
line 74161: IdList * pColumn , 
line 74162: int onError 
line 74163: ) { 
line 74164: sqlite3 * db ; 
line 74165: Table * pTab ; 
line 74166: char * zTab ; 
line 74167: const char * zDb ; 
line 74168: int i , j , idx ; 
line 74169: Vdbe * v ; 
line 74170: Index * pIdx ; 
line 74171: int nColumn ; 
line 74172: int nHidden = 0 ; 
line 74173: int baseCur = 0 ; 
line 74174: int keyColumn = - 1 ; 
line 74175: int endOfLoop ; 
line 74176: int useTempTable = 0 ; 
line 74177: int srcTab = 0 ; 
line 74178: int addrInsTop = 0 ; 
line 74179: int addrCont = 0 ; 
line 74180: int addrSelect = 0 ; 
line 74181: SelectDest dest ; 
line 74182: int iDb ; 
line 74183: Db * pDb ; 
line 74184: int appendFlag = 0 ; 
line 74187: int regFromSelect = 0 ; 
line 74188: int regAutoinc = 0 ; 
line 74189: int regRowCount = 0 ; 
line 74190: int regIns ; 
line 74191: int regRowid ; 
line 74192: int regData ; 
line 74193: int regRecord ; 
line 74194: int regEof = 0 ; 
line 74195: int * aRegIdx = 0 ; 
line 74197: # ifndef SQLITE_OMIT_TRIGGER 
line 74198: int isView ; 
line 74199: Trigger * pTrigger ; 
line 74200: int tmask ; 
line 74201: # endif 
line 74203: db = pParse -> db ; 
line 74204: memset ( & dest , 0 , sizeof ( dest ) ) ; 
line 74205: if ( pParse -> nErr || db -> mallocFailed ) { 
line 74206: goto insert_cleanup ; 
line 74207: } 
line 74211: assert ( pTabList -> nSrc == 1 ) ; 
line 74212: zTab = pTabList -> a [ 0 ] . zName ; 
line 74213: if ( NEVER ( zTab == 0 ) ) goto insert_cleanup ; 
line 74214: pTab = sqlite3SrcListLookup ( pParse , pTabList ) ; 
line 74215: if ( pTab == 0 ) { 
line 74216: goto insert_cleanup ; 
line 74217: } 
line 74218: iDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; 
line 74219: assert ( iDb < db -> nDb ) ; 
line 74220: pDb = & db -> aDb [ iDb ] ; 
line 74221: zDb = pDb -> zName ; 
line 74222: if ( sqlite3AuthCheck ( pParse , SQLITE_INSERT , pTab -> zName , 0 , zDb ) ) { 
line 74223: goto insert_cleanup ; 
line 74224: } 
line 74229: # ifndef SQLITE_OMIT_TRIGGER 
line 74230: pTrigger = sqlite3TriggersExist ( pParse , pTab , TK_INSERT , 0 , & tmask ) ; 
line 74231: isView = pTab -> pSelect != 0 ; 
line 74232: # else 
line 74233: # define pTrigger 0 
line 74234: # define tmask 0 
line 74235: # define isView 0 
line 74236: # endif 
line 74237: # ifdef SQLITE_OMIT_VIEW 
line 74238: # undef isView 
line 74239: # define isView 0 
line 74240: # endif 
line 74241: assert ( ( pTrigger && tmask ) || ( pTrigger == 0 && tmask == 0 ) ) ; 
line 74247: if ( sqlite3ViewGetColumnNames ( pParse , pTab ) ) { 
line 74248: goto insert_cleanup ; 
line 74249: } 
line 74255: if ( sqlite3IsReadOnly ( pParse , pTab , tmask ) ) { 
line 74256: goto insert_cleanup ; 
line 74257: } 
line 74261: v = sqlite3GetVdbe ( pParse ) ; 
line 74262: if ( v == 0 ) goto insert_cleanup ; 
line 74263: if ( pParse -> nested == 0 ) sqlite3VdbeCountChanges ( v ) ; 
line 74264: sqlite3BeginWriteOperation ( pParse , pSelect || pTrigger , iDb ) ; 
line 74266: # ifndef SQLITE_OMIT_XFER_OPT 
line 74276: if ( pColumn == 0 && xferOptimization ( pParse , pTab , pSelect , onError , iDb ) ) { 
line 74277: assert ( ! pTrigger ) ; 
line 74278: assert ( pList == 0 ) ; 
line 74279: goto insert_end ; 
line 74280: } 
line 74281: # endif 
line 74286: regAutoinc = autoIncBegin ( pParse , iDb , pTab ) ; 
line 74293: if ( pSelect ) { 
line 74316: int rc , j1 ; 
line 74318: regEof = ++ pParse -> nMem ; 
line 74319: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regEof ) ; 
line 74320: VdbeComment ( ( v , "SELECT eof flag" ) ) ; 
line 74321: sqlite3SelectDestInit ( & dest , SRT_Coroutine , ++ pParse -> nMem ) ; 
line 74322: addrSelect = sqlite3VdbeCurrentAddr ( v ) + 2 ; 
line 74323: sqlite3VdbeAddOp2 ( v , OP_Integer , addrSelect - 1 , dest . iParm ) ; 
line 74324: j1 = sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , 0 ) ; 
line 74325: VdbeComment ( ( v , "Jump over SELECT coroutine" ) ) ; 
line 74328: rc = sqlite3Select ( pParse , pSelect , & dest ) ; 
line 74329: assert ( pParse -> nErr == 0 || rc ) ; 
line 74330: if ( rc || NEVER ( pParse -> nErr ) || db -> mallocFailed ) { 
line 74331: goto insert_cleanup ; 
line 74332: } 
line 74333: sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regEof ) ; 
line 74334: sqlite3VdbeAddOp1 ( v , OP_Yield , dest . iParm ) ; 
line 74335: sqlite3VdbeAddOp2 ( v , OP_Halt , SQLITE_INTERNAL , OE_Abort ) ; 
line 74336: VdbeComment ( ( v , "End of SELECT coroutine" ) ) ; 
line 74337: sqlite3VdbeJumpHere ( v , j1 ) ; 
line 74339: regFromSelect = dest . iMem ; 
line 74340: assert ( pSelect -> pEList ) ; 
line 74341: nColumn = pSelect -> pEList -> nExpr ; 
line 74342: assert ( dest . nMem == nColumn ) ; 
line 74353: if ( pTrigger || readsTable ( pParse , addrSelect , iDb , pTab ) ) { 
line 74354: useTempTable = 1 ; 
line 74355: } 
line 74357: if ( useTempTable ) { 
line 74369: int regRec ; 
line 74370: int regTempRowid ; 
line 74371: int addrTop ; 
line 74372: int addrIf ; 
line 74374: srcTab = pParse -> nTab ++ ; 
line 74375: regRec = sqlite3GetTempReg ( pParse ) ; 
line 74376: regTempRowid = sqlite3GetTempReg ( pParse ) ; 
line 74377: sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , srcTab , nColumn ) ; 
line 74378: addrTop = sqlite3VdbeAddOp1 ( v , OP_Yield , dest . iParm ) ; 
line 74379: addrIf = sqlite3VdbeAddOp1 ( v , OP_If , regEof ) ; 
line 74380: sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regFromSelect , nColumn , regRec ) ; 
line 74381: sqlite3VdbeAddOp2 ( v , OP_NewRowid , srcTab , regTempRowid ) ; 
line 74382: sqlite3VdbeAddOp3 ( v , OP_Insert , srcTab , regRec , regTempRowid ) ; 
line 74383: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , addrTop ) ; 
line 74384: sqlite3VdbeJumpHere ( v , addrIf ) ; 
line 74385: sqlite3ReleaseTempReg ( pParse , regRec ) ; 
line 74386: sqlite3ReleaseTempReg ( pParse , regTempRowid ) ; 
line 74387: } 
line 74388: } else { 
line 74392: NameContext sNC ; 
line 74393: memset ( & sNC , 0 , sizeof ( sNC ) ) ; 
line 74394: sNC . pParse = pParse ; 
line 74395: srcTab = - 1 ; 
line 74396: assert ( useTempTable == 0 ) ; 
line 74397: nColumn = pList ? pList -> nExpr : 0 ; 
line 74398: for ( i = 0 ; i < nColumn ; i ++ ) { 
line 74399: if ( sqlite3ResolveExprNames ( & sNC , pList -> a [ i ] . pExpr ) ) { 
line 74400: goto insert_cleanup ; 
line 74401: } 
line 74402: } 
line 74403: } 
line 74408: if ( IsVirtual ( pTab ) ) { 
line 74409: for ( i = 0 ; i < pTab -> nCol ; i ++ ) { 
line 74410: nHidden += ( IsHiddenColumn ( & pTab -> aCol [ i ] ) ? 1 : 0 ) ; 
line 74411: } 
line 74412: } 
line 74413: if ( pColumn == 0 && nColumn && nColumn != ( pTab -> nCol - nHidden ) ) { 
line 74414: sqlite3ErrorMsg ( pParse , 
line 74415: "table %S has %d columns but %d values were supplied" , 
line 74416: pTabList , 0 , pTab -> nCol - nHidden , nColumn ) ; 
line 74417: goto insert_cleanup ; 
line 74418: } 
line 74419: if ( pColumn != 0 && nColumn != pColumn -> nId ) { 
line 74420: sqlite3ErrorMsg ( pParse , "%d values for %d columns" , nColumn , pColumn -> nId ) ; 
line 74421: goto insert_cleanup ; 
line 74422: } 
line 74435: if ( pColumn ) { 
line 74436: for ( i = 0 ; i < pColumn -> nId ; i ++ ) { 
line 74437: pColumn -> a [ i ] . idx = - 1 ; 
line 74438: } 
line 74439: for ( i = 0 ; i < pColumn -> nId ; i ++ ) { 
line 74440: for ( j = 0 ; j < pTab -> nCol ; j ++ ) { 
line 74441: if ( sqlite3StrICmp ( pColumn -> a [ i ] . zName , pTab -> aCol [ j ] . zName ) == 0 ) { 
line 74442: pColumn -> a [ i ] . idx = j ; 
line 74443: if ( j == pTab -> iPKey ) { 
line 74444: keyColumn = i ; 
line 74445: } 
line 74446: break ; 
line 74447: } 
line 74448: } 
line 74449: if ( j >= pTab -> nCol ) { 
line 74450: if ( sqlite3IsRowid ( pColumn -> a [ i ] . zName ) ) { 
line 74451: keyColumn = i ; 
line 74452: } else { 
line 74453: sqlite3ErrorMsg ( pParse , "table %S has no column named %s" , 
line 74454: pTabList , 0 , pColumn -> a [ i ] . zName ) ; 
line 74455: pParse -> nErr ++ ; 
line 74456: goto insert_cleanup ; 
line 74457: } 
line 74458: } 
line 74459: } 
line 74460: } 
line 74466: if ( pColumn == 0 && nColumn > 0 ) { 
line 74467: keyColumn = pTab -> iPKey ; 
line 74468: } 
line 74472: if ( db -> flags & SQLITE_CountRows ) { 
line 74473: regRowCount = ++ pParse -> nMem ; 
line 74474: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regRowCount ) ; 
line 74475: } 
line 74478: if ( ! isView ) { 
line 74479: int nIdx ; 
line 74481: baseCur = pParse -> nTab ; 
line 74482: nIdx = sqlite3OpenTableAndIndices ( pParse , pTab , baseCur , OP_OpenWrite ) ; 
line 74483: aRegIdx = sqlite3DbMallocRaw ( db , sizeof ( int ) * ( nIdx + 1 ) ) ; 
line 74484: if ( aRegIdx == 0 ) { 
line 74485: goto insert_cleanup ; 
line 74486: } 
line 74487: for ( i = 0 ; i < nIdx ; i ++ ) { 
line 74488: aRegIdx [ i ] = ++ pParse -> nMem ; 
line 74489: } 
line 74490: } 
line 74493: if ( useTempTable ) { 
line 74503: addrInsTop = sqlite3VdbeAddOp1 ( v , OP_Rewind , srcTab ) ; 
line 74504: addrCont = sqlite3VdbeCurrentAddr ( v ) ; 
line 74505: } else if ( pSelect ) { 
line 74515: addrCont = sqlite3VdbeAddOp1 ( v , OP_Yield , dest . iParm ) ; 
line 74516: addrInsTop = sqlite3VdbeAddOp1 ( v , OP_If , regEof ) ; 
line 74517: } 
line 74522: regRecord = ++ pParse -> nMem ; 
line 74523: regRowid = regIns = pParse -> nMem + 1 ; 
line 74524: pParse -> nMem += pTab -> nCol + 1 ; 
line 74525: if ( IsVirtual ( pTab ) ) { 
line 74526: regRowid ++ ; 
line 74527: pParse -> nMem ++ ; 
line 74528: } 
line 74529: regData = regRowid + 1 ; 
line 74533: endOfLoop = sqlite3VdbeMakeLabel ( v ) ; 
line 74534: if ( tmask & TRIGGER_BEFORE ) { 
line 74535: int regCols = sqlite3GetTempRange ( pParse , pTab -> nCol + 1 ) ; 
line 74543: if ( keyColumn < 0 ) { 
line 74544: sqlite3VdbeAddOp2 ( v , OP_Integer , - 1 , regCols ) ; 
line 74545: } else { 
line 74546: int j1 ; 
line 74547: if ( useTempTable ) { 
line 74548: sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , keyColumn , regCols ) ; 
line 74549: } else { 
line 74550: assert ( pSelect == 0 ) ; 
line 74551: sqlite3ExprCode ( pParse , pList -> a [ keyColumn ] . pExpr , regCols ) ; 
line 74552: } 
line 74553: j1 = sqlite3VdbeAddOp1 ( v , OP_NotNull , regCols ) ; 
line 74554: sqlite3VdbeAddOp2 ( v , OP_Integer , - 1 , regCols ) ; 
line 74555: sqlite3VdbeJumpHere ( v , j1 ) ; 
line 74556: sqlite3VdbeAddOp1 ( v , OP_MustBeInt , regCols ) ; 
line 74557: } 
line 74562: assert ( ! IsVirtual ( pTab ) ) ; 
line 74566: for ( i = 0 ; i < pTab -> nCol ; i ++ ) { 
line 74567: if ( pColumn == 0 ) { 
line 74568: j = i ; 
line 74569: } else { 
line 74570: for ( j = 0 ; j < pColumn -> nId ; j ++ ) { 
line 74571: if ( pColumn -> a [ j ] . idx == i ) break ; 
line 74572: } 
line 74573: } 
line 74574: if ( pColumn && j >= pColumn -> nId ) { 
line 74575: sqlite3ExprCode ( pParse , pTab -> aCol [ i ] . pDflt , regCols + i + 1 ) ; 
line 74576: } else if ( useTempTable ) { 
line 74577: sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , j , regCols + i + 1 ) ; 
line 74578: } else { 
line 74579: assert ( pSelect == 0 ) ; 
line 74580: sqlite3ExprCodeAndCache ( pParse , pList -> a [ j ] . pExpr , regCols + i + 1 ) ; 
line 74581: } 
line 74582: } 
line 74589: if ( ! isView ) { 
line 74590: sqlite3VdbeAddOp2 ( v , OP_Affinity , regCols + 1 , pTab -> nCol ) ; 
line 74591: sqlite3TableAffinityStr ( v , pTab ) ; 
line 74592: } 
line 74595: sqlite3CodeRowTrigger ( pParse , pTrigger , TK_INSERT , 0 , TRIGGER_BEFORE , 
line 74596: pTab , regCols - pTab -> nCol - 1 , onError , endOfLoop ) ; 
line 74598: sqlite3ReleaseTempRange ( pParse , regCols , pTab -> nCol + 1 ) ; 
line 74599: } 
line 74606: if ( ! isView ) { 
line 74607: if ( IsVirtual ( pTab ) ) { 
line 74609: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , regIns ) ; 
line 74610: } 
line 74611: if ( keyColumn >= 0 ) { 
line 74612: if ( useTempTable ) { 
line 74613: sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , keyColumn , regRowid ) ; 
line 74614: } else if ( pSelect ) { 
line 74615: sqlite3VdbeAddOp2 ( v , OP_SCopy , regFromSelect + keyColumn , regRowid ) ; 
line 74616: } else { 
line 74617: VdbeOp * pOp ; 
line 74618: sqlite3ExprCode ( pParse , pList -> a [ keyColumn ] . pExpr , regRowid ) ; 
line 74619: pOp = sqlite3VdbeGetOp ( v , - 1 ) ; 
line 74620: if ( ALWAYS ( pOp ) && pOp -> opcode == OP_Null && ! IsVirtual ( pTab ) ) { 
line 74621: appendFlag = 1 ; 
line 74622: pOp -> opcode = OP_NewRowid ; 
line 74623: pOp -> p1 = baseCur ; 
line 74624: pOp -> p2 = regRowid ; 
line 74625: pOp -> p3 = regAutoinc ; 
line 74626: } 
line 74627: } 
line 74631: if ( ! appendFlag ) { 
line 74632: int j1 ; 
line 74633: if ( ! IsVirtual ( pTab ) ) { 
line 74634: j1 = sqlite3VdbeAddOp1 ( v , OP_NotNull , regRowid ) ; 
line 74635: sqlite3VdbeAddOp3 ( v , OP_NewRowid , baseCur , regRowid , regAutoinc ) ; 
line 74636: sqlite3VdbeJumpHere ( v , j1 ) ; 
line 74637: } else { 
line 74638: j1 = sqlite3VdbeCurrentAddr ( v ) ; 
line 74639: sqlite3VdbeAddOp2 ( v , OP_IsNull , regRowid , j1 + 2 ) ; 
line 74640: } 
line 74641: sqlite3VdbeAddOp1 ( v , OP_MustBeInt , regRowid ) ; 
line 74642: } 
line 74643: } else if ( IsVirtual ( pTab ) ) { 
line 74644: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , regRowid ) ; 
line 74645: } else { 
line 74646: sqlite3VdbeAddOp3 ( v , OP_NewRowid , baseCur , regRowid , regAutoinc ) ; 
line 74647: appendFlag = 1 ; 
line 74648: } 
line 74649: autoIncStep ( pParse , regAutoinc , regRowid ) ; 
line 74654: nHidden = 0 ; 
line 74655: for ( i = 0 ; i < pTab -> nCol ; i ++ ) { 
line 74656: int iRegStore = regRowid + 1 + i ; 
line 74657: if ( i == pTab -> iPKey ) { 
line 74662: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , iRegStore ) ; 
line 74663: continue ; 
line 74664: } 
line 74665: if ( pColumn == 0 ) { 
line 74666: if ( IsHiddenColumn ( & pTab -> aCol [ i ] ) ) { 
line 74667: assert ( IsVirtual ( pTab ) ) ; 
line 74668: j = - 1 ; 
line 74669: nHidden ++ ; 
line 74670: } else { 
line 74671: j = i - nHidden ; 
line 74672: } 
line 74673: } else { 
line 74674: for ( j = 0 ; j < pColumn -> nId ; j ++ ) { 
line 74675: if ( pColumn -> a [ j ] . idx == i ) break ; 
line 74676: } 
line 74677: } 
line 74678: if ( j < 0 || nColumn == 0 || ( pColumn && j >= pColumn -> nId ) ) { 
line 74679: sqlite3ExprCode ( pParse , pTab -> aCol [ i ] . pDflt , iRegStore ) ; 
line 74680: } else if ( useTempTable ) { 
line 74681: sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , j , iRegStore ) ; 
line 74682: } else if ( pSelect ) { 
line 74683: sqlite3VdbeAddOp2 ( v , OP_SCopy , regFromSelect + j , iRegStore ) ; 
line 74684: } else { 
line 74685: sqlite3ExprCode ( pParse , pList -> a [ j ] . pExpr , iRegStore ) ; 
line 74686: } 
line 74687: } 
line 74692: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 74693: if ( IsVirtual ( pTab ) ) { 
line 74694: const char * pVTab = ( const char * ) sqlite3GetVTable ( db , pTab ) ; 
line 74695: sqlite3VtabMakeWritable ( pParse , pTab ) ; 
line 74696: sqlite3VdbeAddOp4 ( v , OP_VUpdate , 1 , pTab -> nCol + 2 , regIns , pVTab , P4_VTAB ) ; 
line 74697: sqlite3MayAbort ( pParse ) ; 
line 74698: } else 
line 74699: # endif 
line 74700: { 
line 74701: int isReplace ; 
line 74702: sqlite3GenerateConstraintChecks ( pParse , pTab , baseCur , regIns , aRegIdx , 
line 74703: keyColumn >= 0 , 0 , onError , endOfLoop , & isReplace 
line 74704: ) ; 
line 74705: sqlite3FkCheck ( pParse , pTab , 0 , regIns ) ; 
line 74706: sqlite3CompleteInsertion ( 
line 74707: pParse , pTab , baseCur , regIns , aRegIdx , 0 , appendFlag , isReplace == 0 
line 74708: ) ; 
line 74709: } 
line 74710: } 
line 74714: if ( ( db -> flags & SQLITE_CountRows ) != 0 ) { 
line 74715: sqlite3VdbeAddOp2 ( v , OP_AddImm , regRowCount , 1 ) ; 
line 74716: } 
line 74718: if ( pTrigger ) { 
line 74720: sqlite3CodeRowTrigger ( pParse , pTrigger , TK_INSERT , 0 , TRIGGER_AFTER , 
line 74721: pTab , regData - 2 - pTab -> nCol , onError , endOfLoop ) ; 
line 74722: } 
line 74727: sqlite3VdbeResolveLabel ( v , endOfLoop ) ; 
line 74728: if ( useTempTable ) { 
line 74729: sqlite3VdbeAddOp2 ( v , OP_Next , srcTab , addrCont ) ; 
line 74730: sqlite3VdbeJumpHere ( v , addrInsTop ) ; 
line 74731: sqlite3VdbeAddOp1 ( v , OP_Close , srcTab ) ; 
line 74732: } else if ( pSelect ) { 
line 74733: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , addrCont ) ; 
line 74734: sqlite3VdbeJumpHere ( v , addrInsTop ) ; 
line 74735: } 
line 74737: if ( ! IsVirtual ( pTab ) && ! isView ) { 
line 74739: sqlite3VdbeAddOp1 ( v , OP_Close , baseCur ) ; 
line 74740: for ( idx = 1 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , idx ++ ) { 
line 74741: sqlite3VdbeAddOp1 ( v , OP_Close , idx + baseCur ) ; 
line 74742: } 
line 74743: } 
line 74745: insert_end : 
line 74750: if ( pParse -> nested == 0 && pParse -> pTriggerTab == 0 ) { 
line 74751: sqlite3AutoincrementEnd ( pParse ) ; 
line 74752: } 
line 74759: if ( ( db -> flags & SQLITE_CountRows ) && ! pParse -> nested && ! pParse -> pTriggerTab ) { 
line 74760: sqlite3VdbeAddOp2 ( v , OP_ResultRow , regRowCount , 1 ) ; 
line 74761: sqlite3VdbeSetNumCols ( v , 1 ) ; 
line 74762: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "rows inserted" , SQLITE_STATIC ) ; 
line 74763: } 
line 74765: insert_cleanup : 
line 74766: sqlite3SrcListDelete ( db , pTabList ) ; 
line 74767: sqlite3ExprListDelete ( db , pList ) ; 
line 74768: sqlite3SelectDelete ( db , pSelect ) ; 
line 74769: sqlite3IdListDelete ( db , pColumn ) ; 
line 74770: sqlite3DbFree ( db , aRegIdx ) ; 
line 74771: } 
line 74776: # ifdef isView 
line 74777: # undef isView 
line 74778: # endif 
line 74779: # ifdef pTrigger 
line 74780: # undef pTrigger 
line 74781: # endif 
line 74782: # ifdef tmask 
line 74783: # undef tmask 
line 74784: # endif 
line 74862: SQLITE_PRIVATE void sqlite3GenerateConstraintChecks ( 
line 74863: Parse * pParse , 
line 74864: Table * pTab , 
line 74865: int baseCur , 
line 74866: int regRowid , 
line 74867: int * aRegIdx , 
line 74868: int rowidChng , 
line 74869: int isUpdate , 
line 74870: int overrideError , 
line 74871: int ignoreDest , 
line 74872: int * pbMayReplace 
line 74873: ) { 
line 74874: int i ; 
line 74875: Vdbe * v ; 
line 74876: int nCol ; 
line 74877: int onError ; 
line 74878: int j1 ; 
line 74879: int j2 = 0 , j3 ; 
line 74880: int regData ; 
line 74881: int iCur ; 
line 74882: Index * pIdx ; 
line 74883: int seenReplace = 0 ; 
line 74884: int regOldRowid = ( rowidChng && isUpdate ) ? rowidChng : regRowid ; 
line 74886: v = sqlite3GetVdbe ( pParse ) ; 
line 74887: assert ( v != 0 ) ; 
line 74888: assert ( pTab -> pSelect == 0 ) ; 
line 74889: nCol = pTab -> nCol ; 
line 74890: regData = regRowid + 1 ; 
line 74894: for ( i = 0 ; i < nCol ; i ++ ) { 
line 74895: if ( i == pTab -> iPKey ) { 
line 74896: continue ; 
line 74897: } 
line 74898: onError = pTab -> aCol [ i ] . notNull ; 
line 74899: if ( onError == OE_None ) continue ; 
line 74900: if ( overrideError != OE_Default ) { 
line 74901: onError = overrideError ; 
line 74902: } else if ( onError == OE_Default ) { 
line 74903: onError = OE_Abort ; 
line 74904: } 
line 74905: if ( onError == OE_Replace && pTab -> aCol [ i ] . pDflt == 0 ) { 
line 74906: onError = OE_Abort ; 
line 74907: } 
line 74908: assert ( onError == OE_Rollback || onError == OE_Abort || onError == OE_Fail 
line 74909: || onError == OE_Ignore || onError == OE_Replace ) ; 
line 74910: switch ( onError ) { 
line 74911: case OE_Abort : 
line 74912: sqlite3MayAbort ( pParse ) ; 
line 74913: case OE_Rollback : 
line 74914: case OE_Fail : { 
line 74915: char * zMsg ; 
line 74916: j1 = sqlite3VdbeAddOp3 ( v , OP_HaltIfNull , 
line 74917: SQLITE_CONSTRAINT , onError , regData + i ) ; 
line 74918: zMsg = sqlite3MPrintf ( pParse -> db , "%s.%s may not be NULL" , 
line 74919: pTab -> zName , pTab -> aCol [ i ] . zName ) ; 
line 74920: sqlite3VdbeChangeP4 ( v , - 1 , zMsg , P4_DYNAMIC ) ; 
line 74921: break ; 
line 74922: } 
line 74923: case OE_Ignore : { 
line 74924: sqlite3VdbeAddOp2 ( v , OP_IsNull , regData + i , ignoreDest ) ; 
line 74925: break ; 
line 74926: } 
line 74927: default : { 
line 74928: assert ( onError == OE_Replace ) ; 
line 74929: j1 = sqlite3VdbeAddOp1 ( v , OP_NotNull , regData + i ) ; 
line 74930: sqlite3ExprCode ( pParse , pTab -> aCol [ i ] . pDflt , regData + i ) ; 
line 74931: sqlite3VdbeJumpHere ( v , j1 ) ; 
line 74932: break ; 
line 74933: } 
line 74934: } 
line 74935: } 
line 74939: # ifndef SQLITE_OMIT_CHECK 
line 74940: if ( pTab -> pCheck && ( pParse -> db -> flags & SQLITE_IgnoreChecks ) == 0 ) { 
line 74941: int allOk = sqlite3VdbeMakeLabel ( v ) ; 
line 74942: pParse -> ckBase = regData ; 
line 74943: sqlite3ExprIfTrue ( pParse , pTab -> pCheck , allOk , SQLITE_JUMPIFNULL ) ; 
line 74944: onError = overrideError != OE_Default ? overrideError : OE_Abort ; 
line 74945: if ( onError == OE_Ignore ) { 
line 74946: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , ignoreDest ) ; 
line 74947: } else { 
line 74948: sqlite3HaltConstraint ( pParse , onError , 0 , 0 ) ; 
line 74949: } 
line 74950: sqlite3VdbeResolveLabel ( v , allOk ) ; 
line 74951: } 
line 74952: # endif 
line 74958: if ( rowidChng ) { 
line 74959: onError = pTab -> keyConf ; 
line 74960: if ( overrideError != OE_Default ) { 
line 74961: onError = overrideError ; 
line 74962: } else if ( onError == OE_Default ) { 
line 74963: onError = OE_Abort ; 
line 74964: } 
line 74966: if ( isUpdate ) { 
line 74967: j2 = sqlite3VdbeAddOp3 ( v , OP_Eq , regRowid , 0 , rowidChng ) ; 
line 74968: } 
line 74969: j3 = sqlite3VdbeAddOp3 ( v , OP_NotExists , baseCur , 0 , regRowid ) ; 
line 74970: switch ( onError ) { 
line 74971: default : { 
line 74972: onError = OE_Abort ; 
line 74974: } 
line 74975: case OE_Rollback : 
line 74976: case OE_Abort : 
line 74977: case OE_Fail : { 
line 74978: sqlite3HaltConstraint ( 
line 74979: pParse , onError , "PRIMARY KEY must be unique" , P4_STATIC ) ; 
line 74980: break ; 
line 74981: } 
line 74982: case OE_Replace : { 
line 74992: Trigger * pTrigger = 0 ; 
line 74993: if ( pParse -> db -> flags & SQLITE_RecTriggers ) { 
line 74994: pTrigger = sqlite3TriggersExist ( pParse , pTab , TK_DELETE , 0 , 0 ) ; 
line 74995: } 
line 74996: sqlite3MultiWrite ( pParse ) ; 
line 74997: if ( pTrigger || sqlite3FkRequired ( pParse , pTab , 0 , 0 ) ) { 
line 74998: sqlite3GenerateRowDelete ( 
line 74999: pParse , pTab , baseCur , regRowid , 0 , pTrigger , OE_Replace 
line 75000: ) ; 
line 75001: } else { 
line 75002: sqlite3GenerateRowIndexDelete ( pParse , pTab , baseCur , 0 ) ; 
line 75003: } 
line 75004: seenReplace = 1 ; 
line 75005: break ; 
line 75006: } 
line 75007: case OE_Ignore : { 
line 75008: assert ( seenReplace == 0 ) ; 
line 75009: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , ignoreDest ) ; 
line 75010: break ; 
line 75011: } 
line 75012: } 
line 75013: sqlite3VdbeJumpHere ( v , j3 ) ; 
line 75014: if ( isUpdate ) { 
line 75015: sqlite3VdbeJumpHere ( v , j2 ) ; 
line 75016: } 
line 75017: } 
line 75023: for ( iCur = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , iCur ++ ) { 
line 75024: int regIdx ; 
line 75025: int regR ; 
line 75027: if ( aRegIdx [ iCur ] == 0 ) continue ; 
line 75030: regIdx = sqlite3GetTempRange ( pParse , pIdx -> nColumn + 1 ) ; 
line 75031: for ( i = 0 ; i < pIdx -> nColumn ; i ++ ) { 
line 75032: int idx = pIdx -> aiColumn [ i ] ; 
line 75033: if ( idx == pTab -> iPKey ) { 
line 75034: sqlite3VdbeAddOp2 ( v , OP_SCopy , regRowid , regIdx + i ) ; 
line 75035: } else { 
line 75036: sqlite3VdbeAddOp2 ( v , OP_SCopy , regData + idx , regIdx + i ) ; 
line 75037: } 
line 75038: } 
line 75039: sqlite3VdbeAddOp2 ( v , OP_SCopy , regRowid , regIdx + i ) ; 
line 75040: sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regIdx , pIdx -> nColumn + 1 , aRegIdx [ iCur ] ) ; 
line 75041: sqlite3VdbeChangeP4 ( v , - 1 , sqlite3IndexAffinityStr ( v , pIdx ) , 0 ) ; 
line 75042: sqlite3ExprCacheAffinityChange ( pParse , regIdx , pIdx -> nColumn + 1 ) ; 
line 75045: onError = pIdx -> onError ; 
line 75046: if ( onError == OE_None ) { 
line 75047: sqlite3ReleaseTempRange ( pParse , regIdx , pIdx -> nColumn + 1 ) ; 
line 75048: continue ; 
line 75049: } 
line 75050: if ( overrideError != OE_Default ) { 
line 75051: onError = overrideError ; 
line 75052: } else if ( onError == OE_Default ) { 
line 75053: onError = OE_Abort ; 
line 75054: } 
line 75055: if ( seenReplace ) { 
line 75056: if ( onError == OE_Ignore ) onError = OE_Replace ; 
line 75057: else if ( onError == OE_Fail ) onError = OE_Abort ; 
line 75058: } 
line 75061: regR = sqlite3GetTempReg ( pParse ) ; 
line 75062: sqlite3VdbeAddOp2 ( v , OP_SCopy , regOldRowid , regR ) ; 
line 75063: j3 = sqlite3VdbeAddOp4 ( v , OP_IsUnique , baseCur + iCur + 1 , 0 , 
line 75064: regR , SQLITE_INT_TO_PTR ( regIdx ) , 
line 75065: P4_INT32 ) ; 
line 75066: sqlite3ReleaseTempRange ( pParse , regIdx , pIdx -> nColumn + 1 ) ; 
line 75069: assert ( onError == OE_Rollback || onError == OE_Abort || onError == OE_Fail 
line 75070: || onError == OE_Ignore || onError == OE_Replace ) ; 
line 75071: switch ( onError ) { 
line 75072: case OE_Rollback : 
line 75073: case OE_Abort : 
line 75074: case OE_Fail : { 
line 75075: int j ; 
line 75076: StrAccum errMsg ; 
line 75077: const char * zSep ; 
line 75078: char * zErr ; 
line 75080: sqlite3StrAccumInit ( & errMsg , 0 , 0 , 200 ) ; 
line 75081: errMsg . db = pParse -> db ; 
line 75082: zSep = pIdx -> nColumn > 1 ? "columns " : "column " ; 
line 75083: for ( j = 0 ; j < pIdx -> nColumn ; j ++ ) { 
line 75084: char * zCol = pTab -> aCol [ pIdx -> aiColumn [ j ] ] . zName ; 
line 75085: sqlite3StrAccumAppend ( & errMsg , zSep , - 1 ) ; 
line 75086: zSep = ", " ; 
line 75087: sqlite3StrAccumAppend ( & errMsg , zCol , - 1 ) ; 
line 75088: } 
line 75089: sqlite3StrAccumAppend ( & errMsg , 
line 75090: pIdx -> nColumn > 1 ? " are not unique" : " is not unique" , - 1 ) ; 
line 75091: zErr = sqlite3StrAccumFinish ( & errMsg ) ; 
line 75092: sqlite3HaltConstraint ( pParse , onError , zErr , 0 ) ; 
line 75093: sqlite3DbFree ( errMsg . db , zErr ) ; 
line 75094: break ; 
line 75095: } 
line 75096: case OE_Ignore : { 
line 75097: assert ( seenReplace == 0 ) ; 
line 75098: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , ignoreDest ) ; 
line 75099: break ; 
line 75100: } 
line 75101: default : { 
line 75102: Trigger * pTrigger = 0 ; 
line 75103: assert ( onError == OE_Replace ) ; 
line 75104: sqlite3MultiWrite ( pParse ) ; 
line 75105: if ( pParse -> db -> flags & SQLITE_RecTriggers ) { 
line 75106: pTrigger = sqlite3TriggersExist ( pParse , pTab , TK_DELETE , 0 , 0 ) ; 
line 75107: } 
line 75108: sqlite3GenerateRowDelete ( 
line 75109: pParse , pTab , baseCur , regR , 0 , pTrigger , OE_Replace 
line 75110: ) ; 
line 75111: seenReplace = 1 ; 
line 75112: break ; 
line 75113: } 
line 75114: } 
line 75115: sqlite3VdbeJumpHere ( v , j3 ) ; 
line 75116: sqlite3ReleaseTempReg ( pParse , regR ) ; 
line 75117: } 
line 75119: if ( pbMayReplace ) { 
line 75120: * pbMayReplace = seenReplace ; 
line 75121: } 
line 75122: } 
line 75133: SQLITE_PRIVATE void sqlite3CompleteInsertion ( 
line 75134: Parse * pParse , 
line 75135: Table * pTab , 
line 75136: int baseCur , 
line 75137: int regRowid , 
line 75138: int * aRegIdx , 
line 75139: int isUpdate , 
line 75140: int appendBias , 
line 75141: int useSeekResult 
line 75142: ) { 
line 75143: int i ; 
line 75144: Vdbe * v ; 
line 75145: int nIdx ; 
line 75146: Index * pIdx ; 
line 75147: u8 pik_flags ; 
line 75148: int regData ; 
line 75149: int regRec ; 
line 75151: v = sqlite3GetVdbe ( pParse ) ; 
line 75152: assert ( v != 0 ) ; 
line 75153: assert ( pTab -> pSelect == 0 ) ; 
line 75154: for ( nIdx = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , nIdx ++ ) { } 
line 75155: for ( i = nIdx - 1 ; i >= 0 ; i -- ) { 
line 75156: if ( aRegIdx [ i ] == 0 ) continue ; 
line 75157: sqlite3VdbeAddOp2 ( v , OP_IdxInsert , baseCur + i + 1 , aRegIdx [ i ] ) ; 
line 75158: if ( useSeekResult ) { 
line 75159: sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ) ; 
line 75160: } 
line 75161: } 
line 75162: regData = regRowid + 1 ; 
line 75163: regRec = sqlite3GetTempReg ( pParse ) ; 
line 75164: sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regData , pTab -> nCol , regRec ) ; 
line 75165: sqlite3TableAffinityStr ( v , pTab ) ; 
line 75166: sqlite3ExprCacheAffinityChange ( pParse , regData , pTab -> nCol ) ; 
line 75167: if ( pParse -> nested ) { 
line 75168: pik_flags = 0 ; 
line 75169: } else { 
line 75170: pik_flags = OPFLAG_NCHANGE ; 
line 75171: pik_flags |= ( isUpdate ? OPFLAG_ISUPDATE : OPFLAG_LASTROWID ) ; 
line 75172: } 
line 75173: if ( appendBias ) { 
line 75174: pik_flags |= OPFLAG_APPEND ; 
line 75175: } 
line 75176: if ( useSeekResult ) { 
line 75177: pik_flags |= OPFLAG_USESEEKRESULT ; 
line 75178: } 
line 75179: sqlite3VdbeAddOp3 ( v , OP_Insert , baseCur , regRec , regRowid ) ; 
line 75180: if ( ! pParse -> nested ) { 
line 75181: sqlite3VdbeChangeP4 ( v , - 1 , pTab -> zName , P4_STATIC ) ; 
line 75182: } 
line 75183: sqlite3VdbeChangeP5 ( v , pik_flags ) ; 
line 75184: } 
line 75193: SQLITE_PRIVATE int sqlite3OpenTableAndIndices ( 
line 75194: Parse * pParse , 
line 75195: Table * pTab , 
line 75196: int baseCur , 
line 75197: int op 
line 75198: ) { 
line 75199: int i ; 
line 75200: int iDb ; 
line 75201: Index * pIdx ; 
line 75202: Vdbe * v ; 
line 75204: if ( IsVirtual ( pTab ) ) return 0 ; 
line 75205: iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; 
line 75206: v = sqlite3GetVdbe ( pParse ) ; 
line 75207: assert ( v != 0 ) ; 
line 75208: sqlite3OpenTable ( pParse , baseCur , iDb , pTab , op ) ; 
line 75209: for ( i = 1 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , i ++ ) { 
line 75210: KeyInfo * pKey = sqlite3IndexKeyinfo ( pParse , pIdx ) ; 
line 75211: assert ( pIdx -> pSchema == pTab -> pSchema ) ; 
line 75212: sqlite3VdbeAddOp4 ( v , op , i + baseCur , pIdx -> tnum , iDb , 
line 75213: ( char * ) pKey , P4_KEYINFO_HANDOFF ) ; 
line 75214: VdbeComment ( ( v , "%s" , pIdx -> zName ) ) ; 
line 75215: } 
line 75216: if ( pParse -> nTab < baseCur + i ) { 
line 75217: pParse -> nTab = baseCur + i ; 
line 75218: } 
line 75219: return i - 1 ; 
line 75220: } 
line 75223: # ifdef SQLITE_TEST 
line 75230: SQLITE_API int sqlite3_xferopt_count ; 
line 75231: # endif 
line 75234: # ifndef SQLITE_OMIT_XFER_OPT 
line 75238: static int xferCompatibleCollation ( const char * z1 , const char * z2 ) { 
line 75239: if ( z1 == 0 ) { 
line 75240: return z2 == 0 ; 
line 75241: } 
line 75242: if ( z2 == 0 ) { 
line 75243: return 0 ; 
line 75244: } 
line 75245: return sqlite3StrICmp ( z1 , z2 ) == 0 ; 
line 75246: } 
line 75259: static int xferCompatibleIndex ( Index * pDest , Index * pSrc ) { 
line 75260: int i ; 
line 75261: assert ( pDest && pSrc ) ; 
line 75262: assert ( pDest -> pTable != pSrc -> pTable ) ; 
line 75263: if ( pDest -> nColumn != pSrc -> nColumn ) { 
line 75264: return 0 ; 
line 75265: } 
line 75266: if ( pDest -> onError != pSrc -> onError ) { 
line 75267: return 0 ; 
line 75268: } 
line 75269: for ( i = 0 ; i < pSrc -> nColumn ; i ++ ) { 
line 75270: if ( pSrc -> aiColumn [ i ] != pDest -> aiColumn [ i ] ) { 
line 75271: return 0 ; 
line 75272: } 
line 75273: if ( pSrc -> aSortOrder [ i ] != pDest -> aSortOrder [ i ] ) { 
line 75274: return 0 ; 
line 75275: } 
line 75276: if ( ! xferCompatibleCollation ( pSrc -> azColl [ i ] , pDest -> azColl [ i ] ) ) { 
line 75277: return 0 ; 
line 75278: } 
line 75279: } 
line 75282: return 1 ; 
line 75283: } 
line 75316: static int xferOptimization ( 
line 75317: Parse * pParse , 
line 75318: Table * pDest , 
line 75319: Select * pSelect , 
line 75320: int onError , 
line 75321: int iDbDest 
line 75322: ) { 
line 75323: ExprList * pEList ; 
line 75324: Table * pSrc ; 
line 75325: Index * pSrcIdx , * pDestIdx ; 
line 75326: struct SrcList_item * pItem ; 
line 75327: int i ; 
line 75328: int iDbSrc ; 
line 75329: int iSrc , iDest ; 
line 75330: int addr1 , addr2 ; 
line 75331: int emptyDestTest ; 
line 75332: int emptySrcTest ; 
line 75333: Vdbe * v ; 
line 75334: KeyInfo * pKey ; 
line 75335: int regAutoinc ; 
line 75336: int destHasUniqueIdx = 0 ; 
line 75337: int regData , regRowid ; 
line 75339: if ( pSelect == 0 ) { 
line 75340: return 0 ; 
line 75341: } 
line 75342: if ( sqlite3TriggerList ( pParse , pDest ) ) { 
line 75343: return 0 ; 
line 75344: } 
line 75345: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 75346: if ( pDest -> tabFlags & TF_Virtual ) { 
line 75347: return 0 ; 
line 75348: } 
line 75349: # endif 
line 75350: if ( onError == OE_Default ) { 
line 75351: onError = OE_Abort ; 
line 75352: } 
line 75353: if ( onError != OE_Abort && onError != OE_Rollback ) { 
line 75354: return 0 ; 
line 75355: } 
line 75356: assert ( pSelect -> pSrc ) ; 
line 75357: if ( pSelect -> pSrc -> nSrc != 1 ) { 
line 75358: return 0 ; 
line 75359: } 
line 75360: if ( pSelect -> pSrc -> a [ 0 ] . pSelect ) { 
line 75361: return 0 ; 
line 75362: } 
line 75363: if ( pSelect -> pWhere ) { 
line 75364: return 0 ; 
line 75365: } 
line 75366: if ( pSelect -> pOrderBy ) { 
line 75367: return 0 ; 
line 75368: } 
line 75371: if ( pSelect -> pGroupBy ) { 
line 75372: return 0 ; 
line 75373: } 
line 75374: if ( pSelect -> pLimit ) { 
line 75375: return 0 ; 
line 75376: } 
line 75377: assert ( pSelect -> pOffset == 0 ) ; 
line 75378: if ( pSelect -> pPrior ) { 
line 75379: return 0 ; 
line 75380: } 
line 75381: if ( pSelect -> selFlags & SF_Distinct ) { 
line 75382: return 0 ; 
line 75383: } 
line 75384: pEList = pSelect -> pEList ; 
line 75385: assert ( pEList != 0 ) ; 
line 75386: if ( pEList -> nExpr != 1 ) { 
line 75387: return 0 ; 
line 75388: } 
line 75389: assert ( pEList -> a [ 0 ] . pExpr ) ; 
line 75390: if ( pEList -> a [ 0 ] . pExpr -> op != TK_ALL ) { 
line 75391: return 0 ; 
line 75392: } 
line 75398: pItem = pSelect -> pSrc -> a ; 
line 75399: pSrc = sqlite3LocateTable ( pParse , 0 , pItem -> zName , pItem -> zDatabase ) ; 
line 75400: if ( pSrc == 0 ) { 
line 75401: return 0 ; 
line 75402: } 
line 75403: if ( pSrc == pDest ) { 
line 75404: return 0 ; 
line 75405: } 
line 75406: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 75407: if ( pSrc -> tabFlags & TF_Virtual ) { 
line 75408: return 0 ; 
line 75409: } 
line 75410: # endif 
line 75411: if ( pSrc -> pSelect ) { 
line 75412: return 0 ; 
line 75413: } 
line 75414: if ( pDest -> nCol != pSrc -> nCol ) { 
line 75415: return 0 ; 
line 75416: } 
line 75417: if ( pDest -> iPKey != pSrc -> iPKey ) { 
line 75418: return 0 ; 
line 75419: } 
line 75420: for ( i = 0 ; i < pDest -> nCol ; i ++ ) { 
line 75421: if ( pDest -> aCol [ i ] . affinity != pSrc -> aCol [ i ] . affinity ) { 
line 75422: return 0 ; 
line 75423: } 
line 75424: if ( ! xferCompatibleCollation ( pDest -> aCol [ i ] . zColl , pSrc -> aCol [ i ] . zColl ) ) { 
line 75425: return 0 ; 
line 75426: } 
line 75427: if ( pDest -> aCol [ i ] . notNull && ! pSrc -> aCol [ i ] . notNull ) { 
line 75428: return 0 ; 
line 75429: } 
line 75430: } 
line 75431: for ( pDestIdx = pDest -> pIndex ; pDestIdx ; pDestIdx = pDestIdx -> pNext ) { 
line 75432: if ( pDestIdx -> onError != OE_None ) { 
line 75433: destHasUniqueIdx = 1 ; 
line 75434: } 
line 75435: for ( pSrcIdx = pSrc -> pIndex ; pSrcIdx ; pSrcIdx = pSrcIdx -> pNext ) { 
line 75436: if ( xferCompatibleIndex ( pDestIdx , pSrcIdx ) ) break ; 
line 75437: } 
line 75438: if ( pSrcIdx == 0 ) { 
line 75439: return 0 ; 
line 75440: } 
line 75441: } 
line 75442: # ifndef SQLITE_OMIT_CHECK 
line 75443: if ( pDest -> pCheck && ! sqlite3ExprCompare ( pSrc -> pCheck , pDest -> pCheck ) ) { 
line 75444: return 0 ; 
line 75445: } 
line 75446: # endif 
line 75456: # ifdef SQLITE_TEST 
line 75457: sqlite3_xferopt_count ++ ; 
line 75458: # endif 
line 75459: iDbSrc = sqlite3SchemaToIndex ( pParse -> db , pSrc -> pSchema ) ; 
line 75460: v = sqlite3GetVdbe ( pParse ) ; 
line 75461: sqlite3CodeVerifySchema ( pParse , iDbSrc ) ; 
line 75462: iSrc = pParse -> nTab ++ ; 
line 75463: iDest = pParse -> nTab ++ ; 
line 75464: regAutoinc = autoIncBegin ( pParse , iDbDest , pDest ) ; 
line 75465: sqlite3OpenTable ( pParse , iDest , iDbDest , pDest , OP_OpenWrite ) ; 
line 75466: if ( ( pDest -> iPKey < 0 && pDest -> pIndex != 0 ) || destHasUniqueIdx ) { 
line 75477: addr1 = sqlite3VdbeAddOp2 ( v , OP_Rewind , iDest , 0 ) ; 
line 75478: emptyDestTest = sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , 0 ) ; 
line 75479: sqlite3VdbeJumpHere ( v , addr1 ) ; 
line 75480: } else { 
line 75481: emptyDestTest = 0 ; 
line 75482: } 
line 75483: sqlite3OpenTable ( pParse , iSrc , iDbSrc , pSrc , OP_OpenRead ) ; 
line 75484: emptySrcTest = sqlite3VdbeAddOp2 ( v , OP_Rewind , iSrc , 0 ) ; 
line 75485: regData = sqlite3GetTempReg ( pParse ) ; 
line 75486: regRowid = sqlite3GetTempReg ( pParse ) ; 
line 75487: if ( pDest -> iPKey >= 0 ) { 
line 75488: addr1 = sqlite3VdbeAddOp2 ( v , OP_Rowid , iSrc , regRowid ) ; 
line 75489: addr2 = sqlite3VdbeAddOp3 ( v , OP_NotExists , iDest , 0 , regRowid ) ; 
line 75490: sqlite3HaltConstraint ( 
line 75491: pParse , onError , "PRIMARY KEY must be unique" , P4_STATIC ) ; 
line 75492: sqlite3VdbeJumpHere ( v , addr2 ) ; 
line 75493: autoIncStep ( pParse , regAutoinc , regRowid ) ; 
line 75494: } else if ( pDest -> pIndex == 0 ) { 
line 75495: addr1 = sqlite3VdbeAddOp2 ( v , OP_NewRowid , iDest , regRowid ) ; 
line 75496: } else { 
line 75497: addr1 = sqlite3VdbeAddOp2 ( v , OP_Rowid , iSrc , regRowid ) ; 
line 75498: assert ( ( pDest -> tabFlags & TF_Autoincrement ) == 0 ) ; 
line 75499: } 
line 75500: sqlite3VdbeAddOp2 ( v , OP_RowData , iSrc , regData ) ; 
line 75501: sqlite3VdbeAddOp3 ( v , OP_Insert , iDest , regData , regRowid ) ; 
line 75502: sqlite3VdbeChangeP5 ( v , OPFLAG_NCHANGE | OPFLAG_LASTROWID | OPFLAG_APPEND ) ; 
line 75503: sqlite3VdbeChangeP4 ( v , - 1 , pDest -> zName , 0 ) ; 
line 75504: sqlite3VdbeAddOp2 ( v , OP_Next , iSrc , addr1 ) ; 
line 75505: for ( pDestIdx = pDest -> pIndex ; pDestIdx ; pDestIdx = pDestIdx -> pNext ) { 
line 75506: for ( pSrcIdx = pSrc -> pIndex ; ALWAYS ( pSrcIdx ) ; pSrcIdx = pSrcIdx -> pNext ) { 
line 75507: if ( xferCompatibleIndex ( pDestIdx , pSrcIdx ) ) break ; 
line 75508: } 
line 75509: assert ( pSrcIdx ) ; 
line 75510: sqlite3VdbeAddOp2 ( v , OP_Close , iSrc , 0 ) ; 
line 75511: sqlite3VdbeAddOp2 ( v , OP_Close , iDest , 0 ) ; 
line 75512: pKey = sqlite3IndexKeyinfo ( pParse , pSrcIdx ) ; 
line 75513: sqlite3VdbeAddOp4 ( v , OP_OpenRead , iSrc , pSrcIdx -> tnum , iDbSrc , 
line 75514: ( char * ) pKey , P4_KEYINFO_HANDOFF ) ; 
line 75515: VdbeComment ( ( v , "%s" , pSrcIdx -> zName ) ) ; 
line 75516: pKey = sqlite3IndexKeyinfo ( pParse , pDestIdx ) ; 
line 75517: sqlite3VdbeAddOp4 ( v , OP_OpenWrite , iDest , pDestIdx -> tnum , iDbDest , 
line 75518: ( char * ) pKey , P4_KEYINFO_HANDOFF ) ; 
line 75519: VdbeComment ( ( v , "%s" , pDestIdx -> zName ) ) ; 
line 75520: addr1 = sqlite3VdbeAddOp2 ( v , OP_Rewind , iSrc , 0 ) ; 
line 75521: sqlite3VdbeAddOp2 ( v , OP_RowKey , iSrc , regData ) ; 
line 75522: sqlite3VdbeAddOp3 ( v , OP_IdxInsert , iDest , regData , 1 ) ; 
line 75523: sqlite3VdbeAddOp2 ( v , OP_Next , iSrc , addr1 + 1 ) ; 
line 75524: sqlite3VdbeJumpHere ( v , addr1 ) ; 
line 75525: } 
line 75526: sqlite3VdbeJumpHere ( v , emptySrcTest ) ; 
line 75527: sqlite3ReleaseTempReg ( pParse , regRowid ) ; 
line 75528: sqlite3ReleaseTempReg ( pParse , regData ) ; 
line 75529: sqlite3VdbeAddOp2 ( v , OP_Close , iSrc , 0 ) ; 
line 75530: sqlite3VdbeAddOp2 ( v , OP_Close , iDest , 0 ) ; 
line 75531: if ( emptyDestTest ) { 
line 75532: sqlite3VdbeAddOp2 ( v , OP_Halt , SQLITE_OK , 0 ) ; 
line 75533: sqlite3VdbeJumpHere ( v , emptyDestTest ) ; 
line 75534: sqlite3VdbeAddOp2 ( v , OP_Close , iDest , 0 ) ; 
line 75535: return 0 ; 
line 75536: } else { 
line 75537: return 1 ; 
line 75538: } 
line 75539: } 
line 75540: # endif 
line 75572: SQLITE_API int sqlite3_exec ( 
line 75573: sqlite3 * db , 
line 75574: const char * zSql , 
line 75575: sqlite3_callback xCallback , 
line 75576: void * pArg , 
line 75577: char * * pzErrMsg 
line 75578: ) { 
line 75579: int rc = SQLITE_OK ; 
line 75580: const char * zLeftover ; 
line 75581: sqlite3_stmt * pStmt = 0 ; 
line 75582: char * * azCols = 0 ; 
line 75583: int nRetry = 0 ; 
line 75584: int callbackIsInit ; 
line 75586: if ( zSql == 0 ) zSql = "" ; 
line 75588: sqlite3_mutex_enter ( db -> mutex ) ; 
line 75589: sqlite3Error ( db , SQLITE_OK , 0 ) ; 
line 75590: while ( ( rc == SQLITE_OK || ( rc == SQLITE_SCHEMA && ( ++ nRetry ) < 2 ) ) && zSql [ 0 ] ) { 
line 75591: int nCol ; 
line 75592: char * * azVals = 0 ; 
line 75594: pStmt = 0 ; 
line 75595: rc = sqlite3_prepare ( db , zSql , - 1 , & pStmt , & zLeftover ) ; 
line 75596: assert ( rc == SQLITE_OK || pStmt == 0 ) ; 
line 75597: if ( rc != SQLITE_OK ) { 
line 75598: continue ; 
line 75599: } 
line 75600: if ( ! pStmt ) { 
line 75602: zSql = zLeftover ; 
line 75603: continue ; 
line 75604: } 
line 75606: callbackIsInit = 0 ; 
line 75607: nCol = sqlite3_column_count ( pStmt ) ; 
line 75609: while ( 1 ) { 
line 75610: int i ; 
line 75611: rc = sqlite3_step ( pStmt ) ; 
line 75614: if ( xCallback && ( SQLITE_ROW == rc || 
line 75615: ( SQLITE_DONE == rc && ! callbackIsInit 
line 75616: && db -> flags & SQLITE_NullCallback ) ) ) { 
line 75617: if ( ! callbackIsInit ) { 
line 75618: azCols = sqlite3DbMallocZero ( db , 2 * nCol * sizeof ( const char * ) + 1 ) ; 
line 75619: if ( azCols == 0 ) { 
line 75620: goto exec_out ; 
line 75621: } 
line 75622: for ( i = 0 ; i < nCol ; i ++ ) { 
line 75623: azCols [ i ] = ( char * ) sqlite3_column_name ( pStmt , i ) ; 
line 75626: assert ( azCols [ i ] != 0 ) ; 
line 75627: } 
line 75628: callbackIsInit = 1 ; 
line 75629: } 
line 75630: if ( rc == SQLITE_ROW ) { 
line 75631: azVals = & azCols [ nCol ] ; 
line 75632: for ( i = 0 ; i < nCol ; i ++ ) { 
line 75633: azVals [ i ] = ( char * ) sqlite3_column_text ( pStmt , i ) ; 
line 75634: if ( ! azVals [ i ] && sqlite3_column_type ( pStmt , i ) != SQLITE_NULL ) { 
line 75635: db -> mallocFailed = 1 ; 
line 75636: goto exec_out ; 
line 75637: } 
line 75638: } 
line 75639: } 
line 75640: if ( xCallback ( pArg , nCol , azVals , azCols ) ) { 
line 75641: rc = SQLITE_ABORT ; 
line 75642: sqlite3VdbeFinalize ( ( Vdbe * ) pStmt ) ; 
line 75643: pStmt = 0 ; 
line 75644: sqlite3Error ( db , SQLITE_ABORT , 0 ) ; 
line 75645: goto exec_out ; 
line 75646: } 
line 75647: } 
line 75649: if ( rc != SQLITE_ROW ) { 
line 75650: rc = sqlite3VdbeFinalize ( ( Vdbe * ) pStmt ) ; 
line 75651: pStmt = 0 ; 
line 75652: if ( rc != SQLITE_SCHEMA ) { 
line 75653: nRetry = 0 ; 
line 75654: zSql = zLeftover ; 
line 75655: while ( sqlite3Isspace ( zSql [ 0 ] ) ) zSql ++ ; 
line 75656: } 
line 75657: break ; 
line 75658: } 
line 75659: } 
line 75661: sqlite3DbFree ( db , azCols ) ; 
line 75662: azCols = 0 ; 
line 75663: } 
line 75665: exec_out : 
line 75666: if ( pStmt ) sqlite3VdbeFinalize ( ( Vdbe * ) pStmt ) ; 
line 75667: sqlite3DbFree ( db , azCols ) ; 
line 75669: rc = sqlite3ApiExit ( db , rc ) ; 
line 75670: if ( rc != SQLITE_OK && ALWAYS ( rc == sqlite3_errcode ( db ) ) && pzErrMsg ) { 
line 75671: int nErrMsg = 1 + sqlite3Strlen30 ( sqlite3_errmsg ( db ) ) ; 
line 75672: * pzErrMsg = sqlite3Malloc ( nErrMsg ) ; 
line 75673: if ( * pzErrMsg ) { 
line 75674: memcpy ( * pzErrMsg , sqlite3_errmsg ( db ) , nErrMsg ) ; 
line 75675: } else { 
line 75676: rc = SQLITE_NOMEM ; 
line 75677: sqlite3Error ( db , SQLITE_NOMEM , 0 ) ; 
line 75678: } 
line 75679: } else if ( pzErrMsg ) { 
line 75680: * pzErrMsg = 0 ; 
line 75681: } 
line 75683: assert ( ( rc & db -> errMask ) == rc ) ; 
line 75684: sqlite3_mutex_leave ( db -> mutex ) ; 
line 75685: return rc ; 
line 75686: } 
line 75705: # ifndef SQLITE_CORE 
line 75706: # define SQLITE_CORE 1 
line 75707: # endif 
line 75727: # ifndef _SQLITE3EXT_H_ 
line 75728: # define _SQLITE3EXT_H_ 
line 75730: typedef struct sqlite3_api_routines sqlite3_api_routines ; 
line 75742: struct sqlite3_api_routines { 
line 75743: void * ( * aggregate_context ) ( sqlite3_context * , int nBytes ) ; 
line 75744: int ( * aggregate_count ) ( sqlite3_context * ) ; 
line 75745: int ( * bind_blob ) ( sqlite3_stmt * , int , const void * , int n , void ( * ) ( void * ) ) ; 
line 75746: int ( * bind_double ) ( sqlite3_stmt * , int , double ) ; 
line 75747: int ( * bind_int ) ( sqlite3_stmt * , int , int ) ; 
line 75748: int ( * bind_int64 ) ( sqlite3_stmt * , int , sqlite_int64 ) ; 
line 75749: int ( * bind_null ) ( sqlite3_stmt * , int ) ; 
line 75750: int ( * bind_parameter_count ) ( sqlite3_stmt * ) ; 
line 75751: int ( * bind_parameter_index ) ( sqlite3_stmt * , const char * zName ) ; 
line 75752: const char * ( * bind_parameter_name ) ( sqlite3_stmt * , int ) ; 
line 75753: int ( * bind_text ) ( sqlite3_stmt * , int , const char * , int n , void ( * ) ( void * ) ) ; 
line 75754: int ( * bind_text16 ) ( sqlite3_stmt * , int , const void * , int , void ( * ) ( void * ) ) ; 
line 75755: int ( * bind_value ) ( sqlite3_stmt * , int , const sqlite3_value * ) ; 
line 75756: int ( * busy_handler ) ( sqlite3 * , int ( * ) ( void * , int ) , void * ) ; 
line 75757: int ( * busy_timeout ) ( sqlite3 * , int ms ) ; 
line 75758: int ( * changes ) ( sqlite3 * ) ; 
line 75759: int ( * close ) ( sqlite3 * ) ; 
line 75760: int ( * collation_needed ) ( sqlite3 * , void * , void ( * ) ( void * , sqlite3 * , int eTextRep , const char * ) ) ; 
line 75761: int ( * collation_needed16 ) ( sqlite3 * , void * , void ( * ) ( void * , sqlite3 * , int eTextRep , const void * ) ) ; 
line 75762: const void * ( * column_blob ) ( sqlite3_stmt * , int iCol ) ; 
line 75763: int ( * column_bytes ) ( sqlite3_stmt * , int iCol ) ; 
line 75764: int ( * column_bytes16 ) ( sqlite3_stmt * , int iCol ) ; 
line 75765: int ( * column_count ) ( sqlite3_stmt * pStmt ) ; 
line 75766: const char * ( * column_database_name ) ( sqlite3_stmt * , int ) ; 
line 75767: const void * ( * column_database_name16 ) ( sqlite3_stmt * , int ) ; 
line 75768: const char * ( * column_decltype ) ( sqlite3_stmt * , int i ) ; 
line 75769: const void * ( * column_decltype16 ) ( sqlite3_stmt * , int ) ; 
line 75770: double ( * column_double ) ( sqlite3_stmt * , int iCol ) ; 
line 75771: int ( * column_int ) ( sqlite3_stmt * , int iCol ) ; 
line 75772: sqlite_int64 ( * column_int64 ) ( sqlite3_stmt * , int iCol ) ; 
line 75773: const char * ( * column_name ) ( sqlite3_stmt * , int ) ; 
line 75774: const void * ( * column_name16 ) ( sqlite3_stmt * , int ) ; 
line 75775: const char * ( * column_origin_name ) ( sqlite3_stmt * , int ) ; 
line 75776: const void * ( * column_origin_name16 ) ( sqlite3_stmt * , int ) ; 
line 75777: const char * ( * column_table_name ) ( sqlite3_stmt * , int ) ; 
line 75778: const void * ( * column_table_name16 ) ( sqlite3_stmt * , int ) ; 
line 75779: const unsigned char * ( * column_text ) ( sqlite3_stmt * , int iCol ) ; 
line 75780: const void * ( * column_text16 ) ( sqlite3_stmt * , int iCol ) ; 
line 75781: int ( * column_type ) ( sqlite3_stmt * , int iCol ) ; 
line 75782: sqlite3_value * ( * column_value ) ( sqlite3_stmt * , int iCol ) ; 
line 75783: void * ( * commit_hook ) ( sqlite3 * , int ( * ) ( void * ) , void * ) ; 
line 75784: int ( * complete ) ( const char * sql ) ; 
line 75785: int ( * complete16 ) ( const void * sql ) ; 
line 75786: int ( * create_collation ) ( sqlite3 * , const char * , int , void * , int ( * ) ( void * , int , const void * , int , const void * ) ) ; 
line 75787: int ( * create_collation16 ) ( sqlite3 * , const void * , int , void * , int ( * ) ( void * , int , const void * , int , const void * ) ) ; 
line 75788: int ( * create_function ) ( sqlite3 * , const char * , int , int , void * , void ( * xFunc ) ( sqlite3_context * , int , sqlite3_value * * ) , void ( * xStep ) ( sqlite3_context * , int , sqlite3_value * * ) , void ( * xFinal ) ( sqlite3_context * ) ) ; 
line 75789: int ( * create_function16 ) ( sqlite3 * , const void * , int , int , void * , void ( * xFunc ) ( sqlite3_context * , int , sqlite3_value * * ) , void ( * xStep ) ( sqlite3_context * , int , sqlite3_value * * ) , void ( * xFinal ) ( sqlite3_context * ) ) ; 
line 75790: int ( * create_module ) ( sqlite3 * , const char * , const sqlite3_module * , void * ) ; 
line 75791: int ( * data_count ) ( sqlite3_stmt * pStmt ) ; 
line 75792: sqlite3 * ( * db_handle ) ( sqlite3_stmt * ) ; 
line 75793: int ( * declare_vtab ) ( sqlite3 * , const char * ) ; 
line 75794: int ( * enable_shared_cache ) ( int ) ; 
line 75795: int ( * errcode ) ( sqlite3 * db ) ; 
line 75796: const char * ( * errmsg ) ( sqlite3 * ) ; 
line 75797: const void * ( * errmsg16 ) ( sqlite3 * ) ; 
line 75798: int ( * exec ) ( sqlite3 * , const char * , sqlite3_callback , void * , char * * ) ; 
line 75799: int ( * expired ) ( sqlite3_stmt * ) ; 
line 75800: int ( * finalize ) ( sqlite3_stmt * pStmt ) ; 
line 75801: void ( * free ) ( void * ) ; 
line 75802: void ( * free_table ) ( char * * result ) ; 
line 75803: int ( * get_autocommit ) ( sqlite3 * ) ; 
line 75804: void * ( * get_auxdata ) ( sqlite3_context * , int ) ; 
line 75805: int ( * get_table ) ( sqlite3 * , const char * , char * * * , int * , int * , char * * ) ; 
line 75806: int ( * global_recover ) ( void ) ; 
line 75807: void ( * interruptx ) ( sqlite3 * ) ; 
line 75808: sqlite_int64 ( * last_insert_rowid ) ( sqlite3 * ) ; 
line 75809: const char * ( * libversion ) ( void ) ; 
line 75810: int ( * libversion_number ) ( void ) ; 
line 75811: void * ( * malloc ) ( int ) ; 
line 75812: char * ( * mprintf ) ( const char * , ... ) ; 
line 75813: int ( * open ) ( const char * , sqlite3 * * ) ; 
line 75814: int ( * open16 ) ( const void * , sqlite3 * * ) ; 
line 75815: int ( * prepare ) ( sqlite3 * , const char * , int , sqlite3_stmt * * , const char * * ) ; 
line 75816: int ( * prepare16 ) ( sqlite3 * , const void * , int , sqlite3_stmt * * , const void * * ) ; 
line 75817: void * ( * profile ) ( sqlite3 * , void ( * ) ( void * , const char * , sqlite_uint64 ) , void * ) ; 
line 75818: void ( * progress_handler ) ( sqlite3 * , int , int ( * ) ( void * ) , void * ) ; 
line 75819: void * ( * realloc ) ( void * , int ) ; 
line 75820: int ( * reset ) ( sqlite3_stmt * pStmt ) ; 
line 75821: void ( * result_blob ) ( sqlite3_context * , const void * , int , void ( * ) ( void * ) ) ; 
line 75822: void ( * result_double ) ( sqlite3_context * , double ) ; 
line 75823: void ( * result_error ) ( sqlite3_context * , const char * , int ) ; 
line 75824: void ( * result_error16 ) ( sqlite3_context * , const void * , int ) ; 
line 75825: void ( * result_int ) ( sqlite3_context * , int ) ; 
line 75826: void ( * result_int64 ) ( sqlite3_context * , sqlite_int64 ) ; 
line 75827: void ( * result_null ) ( sqlite3_context * ) ; 
line 75828: void ( * result_text ) ( sqlite3_context * , const char * , int , void ( * ) ( void * ) ) ; 
line 75829: void ( * result_text16 ) ( sqlite3_context * , const void * , int , void ( * ) ( void * ) ) ; 
line 75830: void ( * result_text16be ) ( sqlite3_context * , const void * , int , void ( * ) ( void * ) ) ; 
line 75831: void ( * result_text16le ) ( sqlite3_context * , const void * , int , void ( * ) ( void * ) ) ; 
line 75832: void ( * result_value ) ( sqlite3_context * , sqlite3_value * ) ; 
line 75833: void * ( * rollback_hook ) ( sqlite3 * , void ( * ) ( void * ) , void * ) ; 
line 75834: int ( * set_authorizer ) ( sqlite3 * , int ( * ) ( void * , int , const char * , const char * , const char * , const char * ) , void * ) ; 
line 75835: void ( * set_auxdata ) ( sqlite3_context * , int , void * , void ( * ) ( void * ) ) ; 
line 75836: char * ( * snprintf ) ( int , char * , const char * , ... ) ; 
line 75837: int ( * step ) ( sqlite3_stmt * ) ; 
line 75838: int ( * table_column_metadata ) ( sqlite3 * , const char * , const char * , const char * , char const * * , char const * * , int * , int * , int * ) ; 
line 75839: void ( * thread_cleanup ) ( void ) ; 
line 75840: int ( * total_changes ) ( sqlite3 * ) ; 
line 75841: void * ( * trace ) ( sqlite3 * , void ( * xTrace ) ( void * , const char * ) , void * ) ; 
line 75842: int ( * transfer_bindings ) ( sqlite3_stmt * , sqlite3_stmt * ) ; 
line 75843: void * ( * update_hook ) ( sqlite3 * , void ( * ) ( void * , int , char const * , char const * , sqlite_int64 ) , void * ) ; 
line 75844: void * ( * user_data ) ( sqlite3_context * ) ; 
line 75845: const void * ( * value_blob ) ( sqlite3_value * ) ; 
line 75846: int ( * value_bytes ) ( sqlite3_value * ) ; 
line 75847: int ( * value_bytes16 ) ( sqlite3_value * ) ; 
line 75848: double ( * value_double ) ( sqlite3_value * ) ; 
line 75849: int ( * value_int ) ( sqlite3_value * ) ; 
line 75850: sqlite_int64 ( * value_int64 ) ( sqlite3_value * ) ; 
line 75851: int ( * value_numeric_type ) ( sqlite3_value * ) ; 
line 75852: const unsigned char * ( * value_text ) ( sqlite3_value * ) ; 
line 75853: const void * ( * value_text16 ) ( sqlite3_value * ) ; 
line 75854: const void * ( * value_text16be ) ( sqlite3_value * ) ; 
line 75855: const void * ( * value_text16le ) ( sqlite3_value * ) ; 
line 75856: int ( * value_type ) ( sqlite3_value * ) ; 
line 75857: char * ( * vmprintf ) ( const char * , va_list ) ; 
line 75859: int ( * overload_function ) ( sqlite3 * , const char * zFuncName , int nArg ) ; 
line 75861: int ( * prepare_v2 ) ( sqlite3 * , const char * , int , sqlite3_stmt * * , const char * * ) ; 
line 75862: int ( * prepare16_v2 ) ( sqlite3 * , const void * , int , sqlite3_stmt * * , const void * * ) ; 
line 75863: int ( * clear_bindings ) ( sqlite3_stmt * ) ; 
line 75865: int ( * create_module_v2 ) ( sqlite3 * , const char * , const sqlite3_module * , void * , void ( * xDestroy ) ( void * ) ) ; 
line 75867: int ( * bind_zeroblob ) ( sqlite3_stmt * , int , int ) ; 
line 75868: int ( * blob_bytes ) ( sqlite3_blob * ) ; 
line 75869: int ( * blob_close ) ( sqlite3_blob * ) ; 
line 75870: int ( * blob_open ) ( sqlite3 * , const char * , const char * , const char * , sqlite3_int64 , int , sqlite3_blob * * ) ; 
line 75871: int ( * blob_read ) ( sqlite3_blob * , void * , int , int ) ; 
line 75872: int ( * blob_write ) ( sqlite3_blob * , const void * , int , int ) ; 
line 75873: int ( * create_collation_v2 ) ( sqlite3 * , const char * , int , void * , int ( * ) ( void * , int , const void * , int , const void * ) , void ( * ) ( void * ) ) ; 
line 75874: int ( * file_control ) ( sqlite3 * , const char * , int , void * ) ; 
line 75875: sqlite3_int64 ( * memory_highwater ) ( int ) ; 
line 75876: sqlite3_int64 ( * memory_used ) ( void ) ; 
line 75877: sqlite3_mutex * ( * mutex_alloc ) ( int ) ; 
line 75878: void ( * mutex_enter ) ( sqlite3_mutex * ) ; 
line 75879: void ( * mutex_free ) ( sqlite3_mutex * ) ; 
line 75880: void ( * mutex_leave ) ( sqlite3_mutex * ) ; 
line 75881: int ( * mutex_try ) ( sqlite3_mutex * ) ; 
line 75882: int ( * open_v2 ) ( const char * , sqlite3 * * , int , const char * ) ; 
line 75883: int ( * release_memory ) ( int ) ; 
line 75884: void ( * result_error_nomem ) ( sqlite3_context * ) ; 
line 75885: void ( * result_error_toobig ) ( sqlite3_context * ) ; 
line 75886: int ( * sleep ) ( int ) ; 
line 75887: void ( * soft_heap_limit ) ( int ) ; 
line 75888: sqlite3_vfs * ( * vfs_find ) ( const char * ) ; 
line 75889: int ( * vfs_register ) ( sqlite3_vfs * , int ) ; 
line 75890: int ( * vfs_unregister ) ( sqlite3_vfs * ) ; 
line 75891: int ( * xthreadsafe ) ( void ) ; 
line 75892: void ( * result_zeroblob ) ( sqlite3_context * , int ) ; 
line 75893: void ( * result_error_code ) ( sqlite3_context * , int ) ; 
line 75894: int ( * test_control ) ( int , ... ) ; 
line 75895: void ( * randomness ) ( int , void * ) ; 
line 75896: sqlite3 * ( * context_db_handle ) ( sqlite3_context * ) ; 
line 75897: int ( * extended_result_codes ) ( sqlite3 * , int ) ; 
line 75898: int ( * limit ) ( sqlite3 * , int , int ) ; 
line 75899: sqlite3_stmt * ( * next_stmt ) ( sqlite3 * , sqlite3_stmt * ) ; 
line 75900: const char * ( * sql ) ( sqlite3_stmt * ) ; 
line 75901: int ( * status ) ( int , int * , int * , int ) ; 
line 75902: } ; 
line 75915: # ifndef SQLITE_CORE 
line 75916: # define sqlite3_aggregate_context sqlite3_api -> aggregate_context 
line 75917: # ifndef SQLITE_OMIT_DEPRECATED 
line 75918: # define sqlite3_aggregate_count sqlite3_api -> aggregate_count 
line 75919: # endif 
line 75920: # define sqlite3_bind_blob sqlite3_api -> bind_blob 
line 75921: # define sqlite3_bind_double sqlite3_api -> bind_double 
line 75922: # define sqlite3_bind_int sqlite3_api -> bind_int 
line 75923: # define sqlite3_bind_int64 sqlite3_api -> bind_int64 
line 75924: # define sqlite3_bind_null sqlite3_api -> bind_null 
line 75925: # define sqlite3_bind_parameter_count sqlite3_api -> bind_parameter_count 
line 75926: # define sqlite3_bind_parameter_index sqlite3_api -> bind_parameter_index 
line 75927: # define sqlite3_bind_parameter_name sqlite3_api -> bind_parameter_name 
line 75928: # define sqlite3_bind_text sqlite3_api -> bind_text 
line 75929: # define sqlite3_bind_text16 sqlite3_api -> bind_text16 
line 75930: # define sqlite3_bind_value sqlite3_api -> bind_value 
line 75931: # define sqlite3_busy_handler sqlite3_api -> busy_handler 
line 75932: # define sqlite3_busy_timeout sqlite3_api -> busy_timeout 
line 75933: # define sqlite3_changes sqlite3_api -> changes 
line 75934: # define sqlite3_close sqlite3_api -> close 
line 75935: # define sqlite3_collation_needed sqlite3_api -> collation_needed 
line 75936: # define sqlite3_collation_needed16 sqlite3_api -> collation_needed16 
line 75937: # define sqlite3_column_blob sqlite3_api -> column_blob 
line 75938: # define sqlite3_column_bytes sqlite3_api -> column_bytes 
line 75939: # define sqlite3_column_bytes16 sqlite3_api -> column_bytes16 
line 75940: # define sqlite3_column_count sqlite3_api -> column_count 
line 75941: # define sqlite3_column_database_name sqlite3_api -> column_database_name 
line 75942: # define sqlite3_column_database_name16 sqlite3_api -> column_database_name16 
line 75943: # define sqlite3_column_decltype sqlite3_api -> column_decltype 
line 75944: # define sqlite3_column_decltype16 sqlite3_api -> column_decltype16 
line 75945: # define sqlite3_column_double sqlite3_api -> column_double 
line 75946: # define sqlite3_column_int sqlite3_api -> column_int 
line 75947: # define sqlite3_column_int64 sqlite3_api -> column_int64 
line 75948: # define sqlite3_column_name sqlite3_api -> column_name 
line 75949: # define sqlite3_column_name16 sqlite3_api -> column_name16 
line 75950: # define sqlite3_column_origin_name sqlite3_api -> column_origin_name 
line 75951: # define sqlite3_column_origin_name16 sqlite3_api -> column_origin_name16 
line 75952: # define sqlite3_column_table_name sqlite3_api -> column_table_name 
line 75953: # define sqlite3_column_table_name16 sqlite3_api -> column_table_name16 
line 75954: # define sqlite3_column_text sqlite3_api -> column_text 
line 75955: # define sqlite3_column_text16 sqlite3_api -> column_text16 
line 75956: # define sqlite3_column_type sqlite3_api -> column_type 
line 75957: # define sqlite3_column_value sqlite3_api -> column_value 
line 75958: # define sqlite3_commit_hook sqlite3_api -> commit_hook 
line 75959: # define sqlite3_complete sqlite3_api -> complete 
line 75960: # define sqlite3_complete16 sqlite3_api -> complete16 
line 75961: # define sqlite3_create_collation sqlite3_api -> create_collation 
line 75962: # define sqlite3_create_collation16 sqlite3_api -> create_collation16 
line 75963: # define sqlite3_create_function sqlite3_api -> create_function 
line 75964: # define sqlite3_create_function16 sqlite3_api -> create_function16 
line 75965: # define sqlite3_create_module sqlite3_api -> create_module 
line 75966: # define sqlite3_create_module_v2 sqlite3_api -> create_module_v2 
line 75967: # define sqlite3_data_count sqlite3_api -> data_count 
line 75968: # define sqlite3_db_handle sqlite3_api -> db_handle 
line 75969: # define sqlite3_declare_vtab sqlite3_api -> declare_vtab 
line 75970: # define sqlite3_enable_shared_cache sqlite3_api -> enable_shared_cache 
line 75971: # define sqlite3_errcode sqlite3_api -> errcode 
line 75972: # define sqlite3_errmsg sqlite3_api -> errmsg 
line 75973: # define sqlite3_errmsg16 sqlite3_api -> errmsg16 
line 75974: # define sqlite3_exec sqlite3_api -> exec 
line 75975: # ifndef SQLITE_OMIT_DEPRECATED 
line 75976: # define sqlite3_expired sqlite3_api -> expired 
line 75977: # endif 
line 75978: # define sqlite3_finalize sqlite3_api -> finalize 
line 75979: # define sqlite3_free sqlite3_api -> free 
line 75980: # define sqlite3_free_table sqlite3_api -> free_table 
line 75981: # define sqlite3_get_autocommit sqlite3_api -> get_autocommit 
line 75982: # define sqlite3_get_auxdata sqlite3_api -> get_auxdata 
line 75983: # define sqlite3_get_table sqlite3_api -> get_table 
line 75984: # ifndef SQLITE_OMIT_DEPRECATED 
line 75985: # define sqlite3_global_recover sqlite3_api -> global_recover 
line 75986: # endif 
line 75987: # define sqlite3_interrupt sqlite3_api -> interruptx 
line 75988: # define sqlite3_last_insert_rowid sqlite3_api -> last_insert_rowid 
line 75989: # define sqlite3_libversion sqlite3_api -> libversion 
line 75990: # define sqlite3_libversion_number sqlite3_api -> libversion_number 
line 75991: # define sqlite3_malloc sqlite3_api -> malloc 
line 75992: # define sqlite3_mprintf sqlite3_api -> mprintf 
line 75993: # define sqlite3_open sqlite3_api -> open 
line 75994: # define sqlite3_open16 sqlite3_api -> open16 
line 75995: # define sqlite3_prepare sqlite3_api -> prepare 
line 75996: # define sqlite3_prepare16 sqlite3_api -> prepare16 
line 75997: # define sqlite3_prepare_v2 sqlite3_api -> prepare_v2 
line 75998: # define sqlite3_prepare16_v2 sqlite3_api -> prepare16_v2 
line 75999: # define sqlite3_profile sqlite3_api -> profile 
line 76000: # define sqlite3_progress_handler sqlite3_api -> progress_handler 
line 76001: # define sqlite3_realloc sqlite3_api -> realloc 
line 76002: # define sqlite3_reset sqlite3_api -> reset 
line 76003: # define sqlite3_result_blob sqlite3_api -> result_blob 
line 76004: # define sqlite3_result_double sqlite3_api -> result_double 
line 76005: # define sqlite3_result_error sqlite3_api -> result_error 
line 76006: # define sqlite3_result_error16 sqlite3_api -> result_error16 
line 76007: # define sqlite3_result_int sqlite3_api -> result_int 
line 76008: # define sqlite3_result_int64 sqlite3_api -> result_int64 
line 76009: # define sqlite3_result_null sqlite3_api -> result_null 
line 76010: # define sqlite3_result_text sqlite3_api -> result_text 
line 76011: # define sqlite3_result_text16 sqlite3_api -> result_text16 
line 76012: # define sqlite3_result_text16be sqlite3_api -> result_text16be 
line 76013: # define sqlite3_result_text16le sqlite3_api -> result_text16le 
line 76014: # define sqlite3_result_value sqlite3_api -> result_value 
line 76015: # define sqlite3_rollback_hook sqlite3_api -> rollback_hook 
line 76016: # define sqlite3_set_authorizer sqlite3_api -> set_authorizer 
line 76017: # define sqlite3_set_auxdata sqlite3_api -> set_auxdata 
line 76018: # define sqlite3_snprintf sqlite3_api -> snprintf 
line 76019: # define sqlite3_step sqlite3_api -> step 
line 76020: # define sqlite3_table_column_metadata sqlite3_api -> table_column_metadata 
line 76021: # define sqlite3_thread_cleanup sqlite3_api -> thread_cleanup 
line 76022: # define sqlite3_total_changes sqlite3_api -> total_changes 
line 76023: # define sqlite3_trace sqlite3_api -> trace 
line 76024: # ifndef SQLITE_OMIT_DEPRECATED 
line 76025: # define sqlite3_transfer_bindings sqlite3_api -> transfer_bindings 
line 76026: # endif 
line 76027: # define sqlite3_update_hook sqlite3_api -> update_hook 
line 76028: # define sqlite3_user_data sqlite3_api -> user_data 
line 76029: # define sqlite3_value_blob sqlite3_api -> value_blob 
line 76030: # define sqlite3_value_bytes sqlite3_api -> value_bytes 
line 76031: # define sqlite3_value_bytes16 sqlite3_api -> value_bytes16 
line 76032: # define sqlite3_value_double sqlite3_api -> value_double 
line 76033: # define sqlite3_value_int sqlite3_api -> value_int 
line 76034: # define sqlite3_value_int64 sqlite3_api -> value_int64 
line 76035: # define sqlite3_value_numeric_type sqlite3_api -> value_numeric_type 
line 76036: # define sqlite3_value_text sqlite3_api -> value_text 
line 76037: # define sqlite3_value_text16 sqlite3_api -> value_text16 
line 76038: # define sqlite3_value_text16be sqlite3_api -> value_text16be 
line 76039: # define sqlite3_value_text16le sqlite3_api -> value_text16le 
line 76040: # define sqlite3_value_type sqlite3_api -> value_type 
line 76041: # define sqlite3_vmprintf sqlite3_api -> vmprintf 
line 76042: # define sqlite3_overload_function sqlite3_api -> overload_function 
line 76043: # define sqlite3_prepare_v2 sqlite3_api -> prepare_v2 
line 76044: # define sqlite3_prepare16_v2 sqlite3_api -> prepare16_v2 
line 76045: # define sqlite3_clear_bindings sqlite3_api -> clear_bindings 
line 76046: # define sqlite3_bind_zeroblob sqlite3_api -> bind_zeroblob 
line 76047: # define sqlite3_blob_bytes sqlite3_api -> blob_bytes 
line 76048: # define sqlite3_blob_close sqlite3_api -> blob_close 
line 76049: # define sqlite3_blob_open sqlite3_api -> blob_open 
line 76050: # define sqlite3_blob_read sqlite3_api -> blob_read 
line 76051: # define sqlite3_blob_write sqlite3_api -> blob_write 
line 76052: # define sqlite3_create_collation_v2 sqlite3_api -> create_collation_v2 
line 76053: # define sqlite3_file_control sqlite3_api -> file_control 
line 76054: # define sqlite3_memory_highwater sqlite3_api -> memory_highwater 
line 76055: # define sqlite3_memory_used sqlite3_api -> memory_used 
line 76056: # define sqlite3_mutex_alloc sqlite3_api -> mutex_alloc 
line 76057: # define sqlite3_mutex_enter sqlite3_api -> mutex_enter 
line 76058: # define sqlite3_mutex_free sqlite3_api -> mutex_free 
line 76059: # define sqlite3_mutex_leave sqlite3_api -> mutex_leave 
line 76060: # define sqlite3_mutex_try sqlite3_api -> mutex_try 
line 76061: # define sqlite3_open_v2 sqlite3_api -> open_v2 
line 76062: # define sqlite3_release_memory sqlite3_api -> release_memory 
line 76063: # define sqlite3_result_error_nomem sqlite3_api -> result_error_nomem 
line 76064: # define sqlite3_result_error_toobig sqlite3_api -> result_error_toobig 
line 76065: # define sqlite3_sleep sqlite3_api -> sleep 
line 76066: # define sqlite3_soft_heap_limit sqlite3_api -> soft_heap_limit 
line 76067: # define sqlite3_vfs_find sqlite3_api -> vfs_find 
line 76068: # define sqlite3_vfs_register sqlite3_api -> vfs_register 
line 76069: # define sqlite3_vfs_unregister sqlite3_api -> vfs_unregister 
line 76070: # define sqlite3_threadsafe sqlite3_api -> xthreadsafe 
line 76071: # define sqlite3_result_zeroblob sqlite3_api -> result_zeroblob 
line 76072: # define sqlite3_result_error_code sqlite3_api -> result_error_code 
line 76073: # define sqlite3_test_control sqlite3_api -> test_control 
line 76074: # define sqlite3_randomness sqlite3_api -> randomness 
line 76075: # define sqlite3_context_db_handle sqlite3_api -> context_db_handle 
line 76076: # define sqlite3_extended_result_codes sqlite3_api -> extended_result_codes 
line 76077: # define sqlite3_limit sqlite3_api -> limit 
line 76078: # define sqlite3_next_stmt sqlite3_api -> next_stmt 
line 76079: # define sqlite3_sql sqlite3_api -> sql 
line 76080: # define sqlite3_status sqlite3_api -> status 
line 76081: # endif 
line 76083: # define SQLITE_EXTENSION_INIT1 const sqlite3_api_routines * sqlite3_api = 0 ; 
line 76084: # define SQLITE_EXTENSION_INIT2 ( v ) sqlite3_api = v ; 
line 76086: # endif 
line 76091: # ifndef SQLITE_OMIT_LOAD_EXTENSION 
line 76098: # ifndef SQLITE_ENABLE_COLUMN_METADATA 
line 76099: # define sqlite3_column_database_name 0 
line 76100: # define sqlite3_column_database_name16 0 
line 76101: # define sqlite3_column_table_name 0 
line 76102: # define sqlite3_column_table_name16 0 
line 76103: # define sqlite3_column_origin_name 0 
line 76104: # define sqlite3_column_origin_name16 0 
line 76105: # define sqlite3_table_column_metadata 0 
line 76106: # endif 
line 76108: # ifdef SQLITE_OMIT_AUTHORIZATION 
line 76109: # define sqlite3_set_authorizer 0 
line 76110: # endif 
line 76112: # ifdef SQLITE_OMIT_UTF16 
line 76113: # define sqlite3_bind_text16 0 
line 76114: # define sqlite3_collation_needed16 0 
line 76115: # define sqlite3_column_decltype16 0 
line 76116: # define sqlite3_column_name16 0 
line 76117: # define sqlite3_column_text16 0 
line 76118: # define sqlite3_complete16 0 
line 76119: # define sqlite3_create_collation16 0 
line 76120: # define sqlite3_create_function16 0 
line 76121: # define sqlite3_errmsg16 0 
line 76122: # define sqlite3_open16 0 
line 76123: # define sqlite3_prepare16 0 
line 76124: # define sqlite3_prepare16_v2 0 
line 76125: # define sqlite3_result_error16 0 
line 76126: # define sqlite3_result_text16 0 
line 76127: # define sqlite3_result_text16be 0 
line 76128: # define sqlite3_result_text16le 0 
line 76129: # define sqlite3_value_text16 0 
line 76130: # define sqlite3_value_text16be 0 
line 76131: # define sqlite3_value_text16le 0 
line 76132: # define sqlite3_column_database_name16 0 
line 76133: # define sqlite3_column_table_name16 0 
line 76134: # define sqlite3_column_origin_name16 0 
line 76135: # endif 
line 76137: # ifdef SQLITE_OMIT_COMPLETE 
line 76138: # define sqlite3_complete 0 
line 76139: # define sqlite3_complete16 0 
line 76140: # endif 
line 76142: # ifdef SQLITE_OMIT_PROGRESS_CALLBACK 
line 76143: # define sqlite3_progress_handler 0 
line 76144: # endif 
line 76146: # ifdef SQLITE_OMIT_VIRTUALTABLE 
line 76147: # define sqlite3_create_module 0 
line 76148: # define sqlite3_create_module_v2 0 
line 76149: # define sqlite3_declare_vtab 0 
line 76150: # endif 
line 76152: # ifdef SQLITE_OMIT_SHARED_CACHE 
line 76153: # define sqlite3_enable_shared_cache 0 
line 76154: # endif 
line 76156: # ifdef SQLITE_OMIT_TRACE 
line 76157: # define sqlite3_profile 0 
line 76158: # define sqlite3_trace 0 
line 76159: # endif 
line 76161: # ifdef SQLITE_OMIT_GET_TABLE 
line 76162: # define sqlite3_free_table 0 
line 76163: # define sqlite3_get_table 0 
line 76164: # endif 
line 76166: # ifdef SQLITE_OMIT_INCRBLOB 
line 76167: # define sqlite3_bind_zeroblob 0 
line 76168: # define sqlite3_blob_bytes 0 
line 76169: # define sqlite3_blob_close 0 
line 76170: # define sqlite3_blob_open 0 
line 76171: # define sqlite3_blob_read 0 
line 76172: # define sqlite3_blob_write 0 
line 76173: # endif 
line 76190: static const sqlite3_api_routines sqlite3Apis = { 
line 76191: sqlite3_aggregate_context , 
line 76192: # ifndef SQLITE_OMIT_DEPRECATED 
line 76193: sqlite3_aggregate_count , 
line 76194: # else 
line 76195: 0 , 
line 76196: # endif 
line 76197: sqlite3_bind_blob , 
line 76198: sqlite3_bind_double , 
line 76199: sqlite3_bind_int , 
line 76200: sqlite3_bind_int64 , 
line 76201: sqlite3_bind_null , 
line 76202: sqlite3_bind_parameter_count , 
line 76203: sqlite3_bind_parameter_index , 
line 76204: sqlite3_bind_parameter_name , 
line 76205: sqlite3_bind_text , 
line 76206: sqlite3_bind_text16 , 
line 76207: sqlite3_bind_value , 
line 76208: sqlite3_busy_handler , 
line 76209: sqlite3_busy_timeout , 
line 76210: sqlite3_changes , 
line 76211: sqlite3_close , 
line 76212: sqlite3_collation_needed , 
line 76213: sqlite3_collation_needed16 , 
line 76214: sqlite3_column_blob , 
line 76215: sqlite3_column_bytes , 
line 76216: sqlite3_column_bytes16 , 
line 76217: sqlite3_column_count , 
line 76218: sqlite3_column_database_name , 
line 76219: sqlite3_column_database_name16 , 
line 76220: sqlite3_column_decltype , 
line 76221: sqlite3_column_decltype16 , 
line 76222: sqlite3_column_double , 
line 76223: sqlite3_column_int , 
line 76224: sqlite3_column_int64 , 
line 76225: sqlite3_column_name , 
line 76226: sqlite3_column_name16 , 
line 76227: sqlite3_column_origin_name , 
line 76228: sqlite3_column_origin_name16 , 
line 76229: sqlite3_column_table_name , 
line 76230: sqlite3_column_table_name16 , 
line 76231: sqlite3_column_text , 
line 76232: sqlite3_column_text16 , 
line 76233: sqlite3_column_type , 
line 76234: sqlite3_column_value , 
line 76235: sqlite3_commit_hook , 
line 76236: sqlite3_complete , 
line 76237: sqlite3_complete16 , 
line 76238: sqlite3_create_collation , 
line 76239: sqlite3_create_collation16 , 
line 76240: sqlite3_create_function , 
line 76241: sqlite3_create_function16 , 
line 76242: sqlite3_create_module , 
line 76243: sqlite3_data_count , 
line 76244: sqlite3_db_handle , 
line 76245: sqlite3_declare_vtab , 
line 76246: sqlite3_enable_shared_cache , 
line 76247: sqlite3_errcode , 
line 76248: sqlite3_errmsg , 
line 76249: sqlite3_errmsg16 , 
line 76250: sqlite3_exec , 
line 76251: # ifndef SQLITE_OMIT_DEPRECATED 
line 76252: sqlite3_expired , 
line 76253: # else 
line 76254: 0 , 
line 76255: # endif 
line 76256: sqlite3_finalize , 
line 76257: sqlite3_free , 
line 76258: sqlite3_free_table , 
line 76259: sqlite3_get_autocommit , 
line 76260: sqlite3_get_auxdata , 
line 76261: sqlite3_get_table , 
line 76262: 0 , 
line 76263: sqlite3_interrupt , 
line 76264: sqlite3_last_insert_rowid , 
line 76265: sqlite3_libversion , 
line 76266: sqlite3_libversion_number , 
line 76267: sqlite3_malloc , 
line 76268: sqlite3_mprintf , 
line 76269: sqlite3_open , 
line 76270: sqlite3_open16 , 
line 76271: sqlite3_prepare , 
line 76272: sqlite3_prepare16 , 
line 76273: sqlite3_profile , 
line 76274: sqlite3_progress_handler , 
line 76275: sqlite3_realloc , 
line 76276: sqlite3_reset , 
line 76277: sqlite3_result_blob , 
line 76278: sqlite3_result_double , 
line 76279: sqlite3_result_error , 
line 76280: sqlite3_result_error16 , 
line 76281: sqlite3_result_int , 
line 76282: sqlite3_result_int64 , 
line 76283: sqlite3_result_null , 
line 76284: sqlite3_result_text , 
line 76285: sqlite3_result_text16 , 
line 76286: sqlite3_result_text16be , 
line 76287: sqlite3_result_text16le , 
line 76288: sqlite3_result_value , 
line 76289: sqlite3_rollback_hook , 
line 76290: sqlite3_set_authorizer , 
line 76291: sqlite3_set_auxdata , 
line 76292: sqlite3_snprintf , 
line 76293: sqlite3_step , 
line 76294: sqlite3_table_column_metadata , 
line 76295: # ifndef SQLITE_OMIT_DEPRECATED 
line 76296: sqlite3_thread_cleanup , 
line 76297: # else 
line 76298: 0 , 
line 76299: # endif 
line 76300: sqlite3_total_changes , 
line 76301: sqlite3_trace , 
line 76302: # ifndef SQLITE_OMIT_DEPRECATED 
line 76303: sqlite3_transfer_bindings , 
line 76304: # else 
line 76305: 0 , 
line 76306: # endif 
line 76307: sqlite3_update_hook , 
line 76308: sqlite3_user_data , 
line 76309: sqlite3_value_blob , 
line 76310: sqlite3_value_bytes , 
line 76311: sqlite3_value_bytes16 , 
line 76312: sqlite3_value_double , 
line 76313: sqlite3_value_int , 
line 76314: sqlite3_value_int64 , 
line 76315: sqlite3_value_numeric_type , 
line 76316: sqlite3_value_text , 
line 76317: sqlite3_value_text16 , 
line 76318: sqlite3_value_text16be , 
line 76319: sqlite3_value_text16le , 
line 76320: sqlite3_value_type , 
line 76321: sqlite3_vmprintf , 
line 76330: sqlite3_overload_function , 
line 76335: sqlite3_prepare_v2 , 
line 76336: sqlite3_prepare16_v2 , 
line 76337: sqlite3_clear_bindings , 
line 76342: sqlite3_create_module_v2 , 
line 76347: sqlite3_bind_zeroblob , 
line 76348: sqlite3_blob_bytes , 
line 76349: sqlite3_blob_close , 
line 76350: sqlite3_blob_open , 
line 76351: sqlite3_blob_read , 
line 76352: sqlite3_blob_write , 
line 76353: sqlite3_create_collation_v2 , 
line 76354: sqlite3_file_control , 
line 76355: sqlite3_memory_highwater , 
line 76356: sqlite3_memory_used , 
line 76357: # ifdef SQLITE_MUTEX_OMIT 
line 76358: 0 , 
line 76359: 0 , 
line 76360: 0 , 
line 76361: 0 , 
line 76362: 0 , 
line 76363: # else 
line 76364: sqlite3_mutex_alloc , 
line 76365: sqlite3_mutex_enter , 
line 76366: sqlite3_mutex_free , 
line 76367: sqlite3_mutex_leave , 
line 76368: sqlite3_mutex_try , 
line 76369: # endif 
line 76370: sqlite3_open_v2 , 
line 76371: sqlite3_release_memory , 
line 76372: sqlite3_result_error_nomem , 
line 76373: sqlite3_result_error_toobig , 
line 76374: sqlite3_sleep , 
line 76375: sqlite3_soft_heap_limit , 
line 76376: sqlite3_vfs_find , 
line 76377: sqlite3_vfs_register , 
line 76378: sqlite3_vfs_unregister , 
line 76383: sqlite3_threadsafe , 
line 76384: sqlite3_result_zeroblob , 
line 76385: sqlite3_result_error_code , 
line 76386: sqlite3_test_control , 
line 76387: sqlite3_randomness , 
line 76388: sqlite3_context_db_handle , 
line 76393: sqlite3_extended_result_codes , 
line 76394: sqlite3_limit , 
line 76395: sqlite3_next_stmt , 
line 76396: sqlite3_sql , 
line 76397: sqlite3_status , 
line 76398: } ; 
line 76412: static int sqlite3LoadExtension ( 
line 76413: sqlite3 * db , 
line 76414: const char * zFile , 
line 76415: const char * zProc , 
line 76416: char * * pzErrMsg 
line 76417: ) { 
line 76418: sqlite3_vfs * pVfs = db -> pVfs ; 
line 76419: void * handle ; 
line 76420: int ( * xInit ) ( sqlite3 * , char * * , const sqlite3_api_routines * ) ; 
line 76421: char * zErrmsg = 0 ; 
line 76422: void * * aHandle ; 
line 76423: const int nMsg = 300 ; 
line 76425: if ( pzErrMsg ) * pzErrMsg = 0 ; 
line 76433: if ( ( db -> flags & SQLITE_LoadExtension ) == 0 ) { 
line 76434: if ( pzErrMsg ) { 
line 76435: * pzErrMsg = sqlite3_mprintf ( "not authorized" ) ; 
line 76436: } 
line 76437: return SQLITE_ERROR ; 
line 76438: } 
line 76440: if ( zProc == 0 ) { 
line 76441: zProc = "sqlite3_extension_init" ; 
line 76442: } 
line 76444: handle = sqlite3OsDlOpen ( pVfs , zFile ) ; 
line 76445: if ( handle == 0 ) { 
line 76446: if ( pzErrMsg ) { 
line 76447: zErrmsg = sqlite3StackAllocZero ( db , nMsg ) ; 
line 76448: if ( zErrmsg ) { 
line 76449: sqlite3_snprintf ( nMsg , zErrmsg , 
line 76450: "unable to open shared library [%s]" , zFile ) ; 
line 76451: sqlite3OsDlError ( pVfs , nMsg - 1 , zErrmsg ) ; 
line 76452: * pzErrMsg = sqlite3DbStrDup ( 0 , zErrmsg ) ; 
line 76453: sqlite3StackFree ( db , zErrmsg ) ; 
line 76454: } 
line 76455: } 
line 76456: return SQLITE_ERROR ; 
line 76457: } 
line 76458: xInit = ( int ( * ) ( sqlite3 * , char * * , const sqlite3_api_routines * ) ) 
line 76459: sqlite3OsDlSym ( pVfs , handle , zProc ) ; 
line 76460: if ( xInit == 0 ) { 
line 76461: if ( pzErrMsg ) { 
line 76462: zErrmsg = sqlite3StackAllocZero ( db , nMsg ) ; 
line 76463: if ( zErrmsg ) { 
line 76464: sqlite3_snprintf ( nMsg , zErrmsg , 
line 76465: "no entry point [%s] in shared library [%s]" , zProc , zFile ) ; 
line 76466: sqlite3OsDlError ( pVfs , nMsg - 1 , zErrmsg ) ; 
line 76467: * pzErrMsg = sqlite3DbStrDup ( 0 , zErrmsg ) ; 
line 76468: sqlite3StackFree ( db , zErrmsg ) ; 
line 76469: } 
line 76470: sqlite3OsDlClose ( pVfs , handle ) ; 
line 76471: } 
line 76472: return SQLITE_ERROR ; 
line 76473: } else if ( xInit ( db , & zErrmsg , & sqlite3Apis ) ) { 
line 76474: if ( pzErrMsg ) { 
line 76475: * pzErrMsg = sqlite3_mprintf ( "error during initialization: %s" , zErrmsg ) ; 
line 76476: } 
line 76477: sqlite3_free ( zErrmsg ) ; 
line 76478: sqlite3OsDlClose ( pVfs , handle ) ; 
line 76479: return SQLITE_ERROR ; 
line 76480: } 
line 76483: aHandle = sqlite3DbMallocZero ( db , sizeof ( handle ) * ( db -> nExtension + 1 ) ) ; 
line 76484: if ( aHandle == 0 ) { 
line 76485: return SQLITE_NOMEM ; 
line 76486: } 
line 76487: if ( db -> nExtension > 0 ) { 
line 76488: memcpy ( aHandle , db -> aExtension , sizeof ( handle ) * db -> nExtension ) ; 
line 76489: } 
line 76490: sqlite3DbFree ( db , db -> aExtension ) ; 
line 76491: db -> aExtension = aHandle ; 
line 76493: db -> aExtension [ db -> nExtension ++ ] = handle ; 
line 76494: return SQLITE_OK ; 
line 76495: } 
line 76496: SQLITE_API int sqlite3_load_extension ( 
line 76497: sqlite3 * db , 
line 76498: const char * zFile , 
line 76499: const char * zProc , 
line 76500: char * * pzErrMsg 
line 76501: ) { 
line 76502: int rc ; 
line 76503: sqlite3_mutex_enter ( db -> mutex ) ; 
line 76504: rc = sqlite3LoadExtension ( db , zFile , zProc , pzErrMsg ) ; 
line 76505: rc = sqlite3ApiExit ( db , rc ) ; 
line 76506: sqlite3_mutex_leave ( db -> mutex ) ; 
line 76507: return rc ; 
line 76508: } 
line 76514: SQLITE_PRIVATE void sqlite3CloseExtensions ( sqlite3 * db ) { 
line 76515: int i ; 
line 76516: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 76517: for ( i = 0 ; i < db -> nExtension ; i ++ ) { 
line 76518: sqlite3OsDlClose ( db -> pVfs , db -> aExtension [ i ] ) ; 
line 76519: } 
line 76520: sqlite3DbFree ( db , db -> aExtension ) ; 
line 76521: } 
line 76527: SQLITE_API int sqlite3_enable_load_extension ( sqlite3 * db , int onoff ) { 
line 76528: sqlite3_mutex_enter ( db -> mutex ) ; 
line 76529: if ( onoff ) { 
line 76530: db -> flags |= SQLITE_LoadExtension ; 
line 76531: } else { 
line 76532: db -> flags &= ~ SQLITE_LoadExtension ; 
line 76533: } 
line 76534: sqlite3_mutex_leave ( db -> mutex ) ; 
line 76535: return SQLITE_OK ; 
line 76536: } 
line 76538: # endif 
line 76546: # ifdef SQLITE_OMIT_LOAD_EXTENSION 
line 76547: static const sqlite3_api_routines sqlite3Apis = { 0 } ; 
line 76548: # endif 
line 76558: typedef struct sqlite3AutoExtList sqlite3AutoExtList ; 
line 76559: static SQLITE_WSD struct sqlite3AutoExtList { 
line 76560: int nExt ; 
line 76561: void ( * * aExt ) ( void ) ; 
line 76562: } sqlite3Autoext = { 0 , 0 } ; 
line 76570: # ifdef SQLITE_OMIT_WSD 
line 76571: # define wsdAutoextInit 
line 76572: sqlite3AutoExtList * x = & GLOBAL ( sqlite3AutoExtList , sqlite3Autoext ) 
line 76573: # define wsdAutoext x [ 0 ] 
line 76574: # else 
line 76575: # define wsdAutoextInit 
line 76576: # define wsdAutoext sqlite3Autoext 
line 76577: # endif 
line 76584: SQLITE_API int sqlite3_auto_extension ( void ( * xInit ) ( void ) ) { 
line 76585: int rc = SQLITE_OK ; 
line 76586: # ifndef SQLITE_OMIT_AUTOINIT 
line 76587: rc = sqlite3_initialize ( ) ; 
line 76588: if ( rc ) { 
line 76589: return rc ; 
line 76590: } else 
line 76591: # endif 
line 76592: { 
line 76593: int i ; 
line 76594: # if SQLITE_THREADSAFE 
line 76595: sqlite3_mutex * mutex = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ; 
line 76596: # endif 
line 76597: wsdAutoextInit ; 
line 76598: sqlite3_mutex_enter ( mutex ) ; 
line 76599: for ( i = 0 ; i < wsdAutoext . nExt ; i ++ ) { 
line 76600: if ( wsdAutoext . aExt [ i ] == xInit ) break ; 
line 76601: } 
line 76602: if ( i == wsdAutoext . nExt ) { 
line 76603: int nByte = ( wsdAutoext . nExt + 1 ) * sizeof ( wsdAutoext . aExt [ 0 ] ) ; 
line 76604: void ( * * aNew ) ( void ) ; 
line 76605: aNew = sqlite3_realloc ( wsdAutoext . aExt , nByte ) ; 
line 76606: if ( aNew == 0 ) { 
line 76607: rc = SQLITE_NOMEM ; 
line 76608: } else { 
line 76609: wsdAutoext . aExt = aNew ; 
line 76610: wsdAutoext . aExt [ wsdAutoext . nExt ] = xInit ; 
line 76611: wsdAutoext . nExt ++ ; 
line 76612: } 
line 76613: } 
line 76614: sqlite3_mutex_leave ( mutex ) ; 
line 76615: assert ( ( rc & 0xff ) == rc ) ; 
line 76616: return rc ; 
line 76617: } 
line 76618: } 
line 76623: SQLITE_API void sqlite3_reset_auto_extension ( void ) { 
line 76624: # ifndef SQLITE_OMIT_AUTOINIT 
line 76625: if ( sqlite3_initialize ( ) == SQLITE_OK ) 
line 76626: # endif 
line 76627: { 
line 76628: # if SQLITE_THREADSAFE 
line 76629: sqlite3_mutex * mutex = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ; 
line 76630: # endif 
line 76631: wsdAutoextInit ; 
line 76632: sqlite3_mutex_enter ( mutex ) ; 
line 76633: sqlite3_free ( wsdAutoext . aExt ) ; 
line 76634: wsdAutoext . aExt = 0 ; 
line 76635: wsdAutoext . nExt = 0 ; 
line 76636: sqlite3_mutex_leave ( mutex ) ; 
line 76637: } 
line 76638: } 
line 76645: SQLITE_PRIVATE void sqlite3AutoLoadExtensions ( sqlite3 * db ) { 
line 76646: int i ; 
line 76647: int go = 1 ; 
line 76648: int ( * xInit ) ( sqlite3 * , char * * , const sqlite3_api_routines * ) ; 
line 76650: wsdAutoextInit ; 
line 76651: if ( wsdAutoext . nExt == 0 ) { 
line 76653: return ; 
line 76654: } 
line 76655: for ( i = 0 ; go ; i ++ ) { 
line 76656: char * zErrmsg ; 
line 76657: # if SQLITE_THREADSAFE 
line 76658: sqlite3_mutex * mutex = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ; 
line 76659: # endif 
line 76660: sqlite3_mutex_enter ( mutex ) ; 
line 76661: if ( i >= wsdAutoext . nExt ) { 
line 76662: xInit = 0 ; 
line 76663: go = 0 ; 
line 76664: } else { 
line 76665: xInit = ( int ( * ) ( sqlite3 * , char * * , const sqlite3_api_routines * ) ) 
line 76666: wsdAutoext . aExt [ i ] ; 
line 76667: } 
line 76668: sqlite3_mutex_leave ( mutex ) ; 
line 76669: zErrmsg = 0 ; 
line 76670: if ( xInit && xInit ( db , & zErrmsg , & sqlite3Apis ) ) { 
line 76671: sqlite3Error ( db , SQLITE_ERROR , 
line 76672: "automatic extension loading failed: %s" , zErrmsg ) ; 
line 76673: go = 0 ; 
line 76674: } 
line 76675: sqlite3_free ( zErrmsg ) ; 
line 76676: } 
line 76677: } 
line 76697: # if ! defined ( SQLITE_OMIT_PRAGMA ) 
line 76709: static u8 getSafetyLevel ( const char * z ) { 
line 76711: static const char zText [ ] = "onoffalseyestruefull" ; 
line 76712: static const u8 iOffset [ ] = { 0 , 1 , 2 , 4 , 9 , 12 , 16 } ; 
line 76713: static const u8 iLength [ ] = { 2 , 2 , 3 , 5 , 3 , 4 , 4 } ; 
line 76714: static const u8 iValue [ ] = { 1 , 0 , 0 , 0 , 1 , 1 , 2 } ; 
line 76715: int i , n ; 
line 76716: if ( sqlite3Isdigit ( * z ) ) { 
line 76717: return ( u8 ) atoi ( z ) ; 
line 76718: } 
line 76719: n = sqlite3Strlen30 ( z ) ; 
line 76720: for ( i = 0 ; i < ArraySize ( iLength ) ; i ++ ) { 
line 76721: if ( iLength [ i ] == n && sqlite3StrNICmp ( & zText [ iOffset [ i ] ] , z , n ) == 0 ) { 
line 76722: return iValue [ i ] ; 
line 76723: } 
line 76724: } 
line 76725: return 1 ; 
line 76726: } 
line 76731: static u8 getBoolean ( const char * z ) { 
line 76732: return getSafetyLevel ( z ) & 1 ; 
line 76733: } 
line 76738: static int getLockingMode ( const char * z ) { 
line 76739: if ( z ) { 
line 76740: if ( 0 == sqlite3StrICmp ( z , "exclusive" ) ) return PAGER_LOCKINGMODE_EXCLUSIVE ; 
line 76741: if ( 0 == sqlite3StrICmp ( z , "normal" ) ) return PAGER_LOCKINGMODE_NORMAL ; 
line 76742: } 
line 76743: return PAGER_LOCKINGMODE_QUERY ; 
line 76744: } 
line 76746: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 76753: static int getAutoVacuum ( const char * z ) { 
line 76754: int i ; 
line 76755: if ( 0 == sqlite3StrICmp ( z , "none" ) ) return BTREE_AUTOVACUUM_NONE ; 
line 76756: if ( 0 == sqlite3StrICmp ( z , "full" ) ) return BTREE_AUTOVACUUM_FULL ; 
line 76757: if ( 0 == sqlite3StrICmp ( z , "incremental" ) ) return BTREE_AUTOVACUUM_INCR ; 
line 76758: i = atoi ( z ) ; 
line 76759: return ( u8 ) ( ( i >= 0 && i <= 2 ) ? i : 0 ) ; 
line 76760: } 
line 76761: # endif 
line 76763: # ifndef SQLITE_OMIT_PAGER_PRAGMAS 
line 76769: static int getTempStore ( const char * z ) { 
line 76770: if ( z [ 0 ] >= '0' && z [ 0 ] <= '2' ) { 
line 76771: return z [ 0 ] - '0' ; 
line 76772: } else if ( sqlite3StrICmp ( z , "file" ) == 0 ) { 
line 76773: return 1 ; 
line 76774: } else if ( sqlite3StrICmp ( z , "memory" ) == 0 ) { 
line 76775: return 2 ; 
line 76776: } else { 
line 76777: return 0 ; 
line 76778: } 
line 76779: } 
line 76780: # endif 
line 76782: # ifndef SQLITE_OMIT_PAGER_PRAGMAS 
line 76787: static int invalidateTempStorage ( Parse * pParse ) { 
line 76788: sqlite3 * db = pParse -> db ; 
line 76789: if ( db -> aDb [ 1 ] . pBt != 0 ) { 
line 76790: if ( ! db -> autoCommit || sqlite3BtreeIsInReadTrans ( db -> aDb [ 1 ] . pBt ) ) { 
line 76791: sqlite3ErrorMsg ( pParse , "temporary storage cannot be changed " 
line 76792: "from within a transaction" ) ; 
line 76793: return SQLITE_ERROR ; 
line 76794: } 
line 76795: sqlite3BtreeClose ( db -> aDb [ 1 ] . pBt ) ; 
line 76796: db -> aDb [ 1 ] . pBt = 0 ; 
line 76797: sqlite3ResetInternalSchema ( db , 0 ) ; 
line 76798: } 
line 76799: return SQLITE_OK ; 
line 76800: } 
line 76801: # endif 
line 76803: # ifndef SQLITE_OMIT_PAGER_PRAGMAS 
line 76809: static int changeTempStorage ( Parse * pParse , const char * zStorageType ) { 
line 76810: int ts = getTempStore ( zStorageType ) ; 
line 76811: sqlite3 * db = pParse -> db ; 
line 76812: if ( db -> temp_store == ts ) return SQLITE_OK ; 
line 76813: if ( invalidateTempStorage ( pParse ) != SQLITE_OK ) { 
line 76814: return SQLITE_ERROR ; 
line 76815: } 
line 76816: db -> temp_store = ( u8 ) ts ; 
line 76817: return SQLITE_OK ; 
line 76818: } 
line 76819: # endif 
line 76824: static void returnSingleInt ( Parse * pParse , const char * zLabel , i64 value ) { 
line 76825: Vdbe * v = sqlite3GetVdbe ( pParse ) ; 
line 76826: int mem = ++ pParse -> nMem ; 
line 76827: i64 * pI64 = sqlite3DbMallocRaw ( pParse -> db , sizeof ( value ) ) ; 
line 76828: if ( pI64 ) { 
line 76829: memcpy ( pI64 , & value , sizeof ( value ) ) ; 
line 76830: } 
line 76831: sqlite3VdbeAddOp4 ( v , OP_Int64 , 0 , mem , 0 , ( char * ) pI64 , P4_INT64 ) ; 
line 76832: sqlite3VdbeSetNumCols ( v , 1 ) ; 
line 76833: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , zLabel , SQLITE_STATIC ) ; 
line 76834: sqlite3VdbeAddOp2 ( v , OP_ResultRow , mem , 1 ) ; 
line 76835: } 
line 76837: # ifndef SQLITE_OMIT_FLAG_PRAGMAS 
line 76843: static int flagPragma ( Parse * pParse , const char * zLeft , const char * zRight ) { 
line 76844: static const struct sPragmaType { 
line 76845: const char * zName ; 
line 76846: int mask ; 
line 76847: } aPragma [ ] = { 
line 76848: { "full_column_names" , SQLITE_FullColNames } , 
line 76849: { "short_column_names" , SQLITE_ShortColNames } , 
line 76850: { "count_changes" , SQLITE_CountRows } , 
line 76851: { "empty_result_callbacks" , SQLITE_NullCallback } , 
line 76852: { "legacy_file_format" , SQLITE_LegacyFileFmt } , 
line 76853: { "fullfsync" , SQLITE_FullFSync } , 
line 76854: { "reverse_unordered_selects" , SQLITE_ReverseOrder } , 
line 76855: # ifdef SQLITE_DEBUG 
line 76856: { "sql_trace" , SQLITE_SqlTrace } , 
line 76857: { "vdbe_listing" , SQLITE_VdbeListing } , 
line 76858: { "vdbe_trace" , SQLITE_VdbeTrace } , 
line 76859: # endif 
line 76860: # ifndef SQLITE_OMIT_CHECK 
line 76861: { "ignore_check_constraints" , SQLITE_IgnoreChecks } , 
line 76862: # endif 
line 76864: { "writable_schema" , SQLITE_WriteSchema | SQLITE_RecoveryMode } , 
line 76865: { "omit_readlock" , SQLITE_NoReadlock } , 
line 76869: { "read_uncommitted" , SQLITE_ReadUncommitted } , 
line 76870: { "recursive_triggers" , SQLITE_RecTriggers } , 
line 76874: # if ! defined ( SQLITE_OMIT_FOREIGN_KEY ) && ! defined ( SQLITE_OMIT_TRIGGER ) 
line 76875: { "foreign_keys" , SQLITE_ForeignKeys } , 
line 76876: # endif 
line 76877: } ; 
line 76878: int i ; 
line 76879: const struct sPragmaType * p ; 
line 76880: for ( i = 0 , p = aPragma ; i < ArraySize ( aPragma ) ; i ++ , p ++ ) { 
line 76881: if ( sqlite3StrICmp ( zLeft , p -> zName ) == 0 ) { 
line 76882: sqlite3 * db = pParse -> db ; 
line 76883: Vdbe * v ; 
line 76884: v = sqlite3GetVdbe ( pParse ) ; 
line 76885: assert ( v != 0 ) ; 
line 76886: if ( ALWAYS ( v ) ) { 
line 76887: if ( zRight == 0 ) { 
line 76888: returnSingleInt ( pParse , p -> zName , ( db -> flags & p -> mask ) != 0 ) ; 
line 76889: } else { 
line 76890: int mask = p -> mask ; 
line 76891: if ( db -> autoCommit == 0 ) { 
line 76894: mask &= ~ ( SQLITE_ForeignKeys ) ; 
line 76895: } 
line 76897: if ( getBoolean ( zRight ) ) { 
line 76898: db -> flags |= mask ; 
line 76899: } else { 
line 76900: db -> flags &= ~ mask ; 
line 76901: } 
line 76907: sqlite3VdbeAddOp2 ( v , OP_Expire , 0 , 0 ) ; 
line 76908: } 
line 76909: } 
line 76911: return 1 ; 
line 76912: } 
line 76913: } 
line 76914: return 0 ; 
line 76915: } 
line 76916: # endif 
line 76921: # ifndef SQLITE_OMIT_FOREIGN_KEY 
line 76922: static const char * actionName ( u8 action ) { 
line 76923: const char * zName ; 
line 76924: switch ( action ) { 
line 76925: case OE_SetNull : zName = "SET NULL" ; break ; 
line 76926: case OE_SetDflt : zName = "SET DEFAULT" ; break ; 
line 76927: case OE_Cascade : zName = "CASCADE" ; break ; 
line 76928: case OE_Restrict : zName = "RESTRICT" ; break ; 
line 76929: default : zName = "NO ACTION" ; 
line 76930: assert ( action == OE_None ) ; break ; 
line 76931: } 
line 76932: return zName ; 
line 76933: } 
line 76934: # endif 
line 76951: SQLITE_PRIVATE void sqlite3Pragma ( 
line 76952: Parse * pParse , 
line 76953: Token * pId1 , 
line 76954: Token * pId2 , 
line 76955: Token * pValue , 
line 76956: int minusFlag 
line 76957: ) { 
line 76958: char * zLeft = 0 ; 
line 76959: char * zRight = 0 ; 
line 76960: const char * zDb = 0 ; 
line 76961: Token * pId ; 
line 76962: int iDb ; 
line 76963: sqlite3 * db = pParse -> db ; 
line 76964: Db * pDb ; 
line 76965: Vdbe * v = pParse -> pVdbe = sqlite3VdbeCreate ( db ) ; 
line 76966: if ( v == 0 ) return ; 
line 76967: pParse -> nMem = 2 ; 
line 76971: iDb = sqlite3TwoPartName ( pParse , pId1 , pId2 , & pId ) ; 
line 76972: if ( iDb < 0 ) return ; 
line 76973: pDb = & db -> aDb [ iDb ] ; 
line 76978: if ( iDb == 1 && sqlite3OpenTempDatabase ( pParse ) ) { 
line 76979: return ; 
line 76980: } 
line 76982: zLeft = sqlite3NameFromToken ( db , pId ) ; 
line 76983: if ( ! zLeft ) return ; 
line 76984: if ( minusFlag ) { 
line 76985: zRight = sqlite3MPrintf ( db , "-%T" , pValue ) ; 
line 76986: } else { 
line 76987: zRight = sqlite3NameFromToken ( db , pValue ) ; 
line 76988: } 
line 76990: assert ( pId2 ) ; 
line 76991: zDb = pId2 -> n > 0 ? pDb -> zName : 0 ; 
line 76992: if ( sqlite3AuthCheck ( pParse , SQLITE_PRAGMA , zLeft , zRight , zDb ) ) { 
line 76993: goto pragma_out ; 
line 76994: } 
line 76996: # ifndef SQLITE_OMIT_PAGER_PRAGMAS 
line 77013: if ( sqlite3StrICmp ( zLeft , "default_cache_size" ) == 0 ) { 
line 77014: static const VdbeOpList getCacheSize [ ] = { 
line 77015: { OP_Transaction , 0 , 0 , 0 } , 
line 77016: { OP_ReadCookie , 0 , 1 , BTREE_DEFAULT_CACHE_SIZE } , 
line 77017: { OP_IfPos , 1 , 7 , 0 } , 
line 77018: { OP_Integer , 0 , 2 , 0 } , 
line 77019: { OP_Subtract , 1 , 2 , 1 } , 
line 77020: { OP_IfPos , 1 , 7 , 0 } , 
line 77021: { OP_Integer , 0 , 1 , 0 } , 
line 77022: { OP_ResultRow , 1 , 1 , 0 } , 
line 77023: } ; 
line 77024: int addr ; 
line 77025: if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; 
line 77026: sqlite3VdbeUsesBtree ( v , iDb ) ; 
line 77027: if ( ! zRight ) { 
line 77028: sqlite3VdbeSetNumCols ( v , 1 ) ; 
line 77029: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "cache_size" , SQLITE_STATIC ) ; 
line 77030: pParse -> nMem += 2 ; 
line 77031: addr = sqlite3VdbeAddOpList ( v , ArraySize ( getCacheSize ) , getCacheSize ) ; 
line 77032: sqlite3VdbeChangeP1 ( v , addr , iDb ) ; 
line 77033: sqlite3VdbeChangeP1 ( v , addr + 1 , iDb ) ; 
line 77034: sqlite3VdbeChangeP1 ( v , addr + 6 , SQLITE_DEFAULT_CACHE_SIZE ) ; 
line 77035: } else { 
line 77036: int size = atoi ( zRight ) ; 
line 77037: if ( size < 0 ) size = - size ; 
line 77038: sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; 
line 77039: sqlite3VdbeAddOp2 ( v , OP_Integer , size , 1 ) ; 
line 77040: sqlite3VdbeAddOp3 ( v , OP_ReadCookie , iDb , 2 , BTREE_DEFAULT_CACHE_SIZE ) ; 
line 77041: addr = sqlite3VdbeAddOp2 ( v , OP_IfPos , 2 , 0 ) ; 
line 77042: sqlite3VdbeAddOp2 ( v , OP_Integer , - size , 1 ) ; 
line 77043: sqlite3VdbeJumpHere ( v , addr ) ; 
line 77044: sqlite3VdbeAddOp3 ( v , OP_SetCookie , iDb , BTREE_DEFAULT_CACHE_SIZE , 1 ) ; 
line 77045: pDb -> pSchema -> cache_size = size ; 
line 77046: sqlite3BtreeSetCacheSize ( pDb -> pBt , pDb -> pSchema -> cache_size ) ; 
line 77047: } 
line 77048: } else 
line 77059: if ( sqlite3StrICmp ( zLeft , "page_size" ) == 0 ) { 
line 77060: Btree * pBt = pDb -> pBt ; 
line 77061: assert ( pBt != 0 ) ; 
line 77062: if ( ! zRight ) { 
line 77063: int size = ALWAYS ( pBt ) ? sqlite3BtreeGetPageSize ( pBt ) : 0 ; 
line 77064: returnSingleInt ( pParse , "page_size" , size ) ; 
line 77065: } else { 
line 77069: db -> nextPagesize = atoi ( zRight ) ; 
line 77070: if ( SQLITE_NOMEM == sqlite3BtreeSetPageSize ( pBt , db -> nextPagesize , - 1 , 0 ) ) { 
line 77071: db -> mallocFailed = 1 ; 
line 77072: } 
line 77073: } 
line 77074: } else 
line 77085: if ( sqlite3StrICmp ( zLeft , "max_page_count" ) == 0 ) { 
line 77086: Btree * pBt = pDb -> pBt ; 
line 77087: int newMax = 0 ; 
line 77088: assert ( pBt != 0 ) ; 
line 77089: if ( zRight ) { 
line 77090: newMax = atoi ( zRight ) ; 
line 77091: } 
line 77092: if ( ALWAYS ( pBt ) ) { 
line 77093: newMax = sqlite3BtreeMaxPageCount ( pBt , newMax ) ; 
line 77094: } 
line 77095: returnSingleInt ( pParse , "max_page_count" , newMax ) ; 
line 77096: } else 
line 77103: if ( sqlite3StrICmp ( zLeft , "page_count" ) == 0 ) { 
line 77104: int iReg ; 
line 77105: if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; 
line 77106: sqlite3CodeVerifySchema ( pParse , iDb ) ; 
line 77107: iReg = ++ pParse -> nMem ; 
line 77108: sqlite3VdbeAddOp2 ( v , OP_Pagecount , iDb , iReg ) ; 
line 77109: sqlite3VdbeAddOp2 ( v , OP_ResultRow , iReg , 1 ) ; 
line 77110: sqlite3VdbeSetNumCols ( v , 1 ) ; 
line 77111: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "page_count" , SQLITE_STATIC ) ; 
line 77112: } else 
line 77118: if ( sqlite3StrICmp ( zLeft , "locking_mode" ) == 0 ) { 
line 77119: const char * zRet = "normal" ; 
line 77120: int eMode = getLockingMode ( zRight ) ; 
line 77122: if ( pId2 -> n == 0 && eMode == PAGER_LOCKINGMODE_QUERY ) { 
line 77127: eMode = db -> dfltLockMode ; 
line 77128: } else { 
line 77129: Pager * pPager ; 
line 77130: if ( pId2 -> n == 0 ) { 
line 77139: int ii ; 
line 77140: assert ( pDb == & db -> aDb [ 0 ] ) ; 
line 77141: for ( ii = 2 ; ii < db -> nDb ; ii ++ ) { 
line 77142: pPager = sqlite3BtreePager ( db -> aDb [ ii ] . pBt ) ; 
line 77143: sqlite3PagerLockingMode ( pPager , eMode ) ; 
line 77144: } 
line 77145: db -> dfltLockMode = ( u8 ) eMode ; 
line 77146: } 
line 77147: pPager = sqlite3BtreePager ( pDb -> pBt ) ; 
line 77148: eMode = sqlite3PagerLockingMode ( pPager , eMode ) ; 
line 77149: } 
line 77151: assert ( eMode == PAGER_LOCKINGMODE_NORMAL || eMode == PAGER_LOCKINGMODE_EXCLUSIVE ) ; 
line 77152: if ( eMode == PAGER_LOCKINGMODE_EXCLUSIVE ) { 
line 77153: zRet = "exclusive" ; 
line 77154: } 
line 77155: sqlite3VdbeSetNumCols ( v , 1 ) ; 
line 77156: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "locking_mode" , SQLITE_STATIC ) ; 
line 77157: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 1 , 0 , zRet , 0 ) ; 
line 77158: sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ) ; 
line 77159: } else 
line 77165: if ( sqlite3StrICmp ( zLeft , "journal_mode" ) == 0 ) { 
line 77166: int eMode ; 
line 77167: static char * const azModeName [ ] = { 
line 77168: "delete" , "persist" , "off" , "truncate" , "memory" 
line 77169: } ; 
line 77171: if ( zRight == 0 ) { 
line 77172: eMode = PAGER_JOURNALMODE_QUERY ; 
line 77173: } else { 
line 77174: int n = sqlite3Strlen30 ( zRight ) ; 
line 77175: eMode = sizeof ( azModeName ) / sizeof ( azModeName [ 0 ] ) - 1 ; 
line 77176: while ( eMode >= 0 && sqlite3StrNICmp ( zRight , azModeName [ eMode ] , n ) != 0 ) { 
line 77177: eMode -- ; 
line 77178: } 
line 77179: } 
line 77180: if ( pId2 -> n == 0 && eMode == PAGER_JOURNALMODE_QUERY ) { 
line 77185: eMode = db -> dfltJournalMode ; 
line 77186: } else { 
line 77187: Pager * pPager ; 
line 77188: if ( pId2 -> n == 0 ) { 
line 77197: int ii ; 
line 77198: assert ( pDb == & db -> aDb [ 0 ] ) ; 
line 77199: for ( ii = 1 ; ii < db -> nDb ; ii ++ ) { 
line 77200: if ( db -> aDb [ ii ] . pBt ) { 
line 77201: pPager = sqlite3BtreePager ( db -> aDb [ ii ] . pBt ) ; 
line 77202: sqlite3PagerJournalMode ( pPager , eMode ) ; 
line 77203: } 
line 77204: } 
line 77205: db -> dfltJournalMode = ( u8 ) eMode ; 
line 77206: } 
line 77207: pPager = sqlite3BtreePager ( pDb -> pBt ) ; 
line 77208: eMode = sqlite3PagerJournalMode ( pPager , eMode ) ; 
line 77209: } 
line 77210: assert ( eMode == PAGER_JOURNALMODE_DELETE 
line 77211: || eMode == PAGER_JOURNALMODE_TRUNCATE 
line 77212: || eMode == PAGER_JOURNALMODE_PERSIST 
line 77213: || eMode == PAGER_JOURNALMODE_OFF 
line 77214: || eMode == PAGER_JOURNALMODE_MEMORY ) ; 
line 77215: sqlite3VdbeSetNumCols ( v , 1 ) ; 
line 77216: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "journal_mode" , SQLITE_STATIC ) ; 
line 77217: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 1 , 0 , 
line 77218: azModeName [ eMode ] , P4_STATIC ) ; 
line 77219: sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ) ; 
line 77220: } else 
line 77228: if ( sqlite3StrICmp ( zLeft , "journal_size_limit" ) == 0 ) { 
line 77229: Pager * pPager = sqlite3BtreePager ( pDb -> pBt ) ; 
line 77230: i64 iLimit = - 2 ; 
line 77231: if ( zRight ) { 
line 77232: sqlite3Atoi64 ( zRight , & iLimit ) ; 
line 77233: if ( iLimit < - 1 ) iLimit = - 1 ; 
line 77234: } 
line 77235: iLimit = sqlite3PagerJournalSizeLimit ( pPager , iLimit ) ; 
line 77236: returnSingleInt ( pParse , "journal_size_limit" , iLimit ) ; 
line 77237: } else 
line 77239: # endif 
line 77248: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 77249: if ( sqlite3StrICmp ( zLeft , "auto_vacuum" ) == 0 ) { 
line 77250: Btree * pBt = pDb -> pBt ; 
line 77251: assert ( pBt != 0 ) ; 
line 77252: if ( sqlite3ReadSchema ( pParse ) ) { 
line 77253: goto pragma_out ; 
line 77254: } 
line 77255: if ( ! zRight ) { 
line 77256: int auto_vacuum ; 
line 77257: if ( ALWAYS ( pBt ) ) { 
line 77258: auto_vacuum = sqlite3BtreeGetAutoVacuum ( pBt ) ; 
line 77259: } else { 
line 77260: auto_vacuum = SQLITE_DEFAULT_AUTOVACUUM ; 
line 77261: } 
line 77262: returnSingleInt ( pParse , "auto_vacuum" , auto_vacuum ) ; 
line 77263: } else { 
line 77264: int eAuto = getAutoVacuum ( zRight ) ; 
line 77265: assert ( eAuto >= 0 && eAuto <= 2 ) ; 
line 77266: db -> nextAutovac = ( u8 ) eAuto ; 
line 77267: if ( ALWAYS ( eAuto >= 0 ) ) { 
line 77273: int rc = sqlite3BtreeSetAutoVacuum ( pBt , eAuto ) ; 
line 77274: if ( rc == SQLITE_OK && ( eAuto == 1 || eAuto == 2 ) ) { 
line 77280: static const VdbeOpList setMeta6 [ ] = { 
line 77281: { OP_Transaction , 0 , 1 , 0 } , 
line 77282: { OP_ReadCookie , 0 , 1 , BTREE_LARGEST_ROOT_PAGE } , 
line 77283: { OP_If , 1 , 0 , 0 } , 
line 77284: { OP_Halt , SQLITE_OK , OE_Abort , 0 } , 
line 77285: { OP_Integer , 0 , 1 , 0 } , 
line 77286: { OP_SetCookie , 0 , BTREE_INCR_VACUUM , 1 } , 
line 77287: } ; 
line 77288: int iAddr ; 
line 77289: iAddr = sqlite3VdbeAddOpList ( v , ArraySize ( setMeta6 ) , setMeta6 ) ; 
line 77290: sqlite3VdbeChangeP1 ( v , iAddr , iDb ) ; 
line 77291: sqlite3VdbeChangeP1 ( v , iAddr + 1 , iDb ) ; 
line 77292: sqlite3VdbeChangeP2 ( v , iAddr + 2 , iAddr + 4 ) ; 
line 77293: sqlite3VdbeChangeP1 ( v , iAddr + 4 , eAuto - 1 ) ; 
line 77294: sqlite3VdbeChangeP1 ( v , iAddr + 5 , iDb ) ; 
line 77295: sqlite3VdbeUsesBtree ( v , iDb ) ; 
line 77296: } 
line 77297: } 
line 77298: } 
line 77299: } else 
line 77300: # endif 
line 77307: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 77308: if ( sqlite3StrICmp ( zLeft , "incremental_vacuum" ) == 0 ) { 
line 77309: int iLimit , addr ; 
line 77310: if ( sqlite3ReadSchema ( pParse ) ) { 
line 77311: goto pragma_out ; 
line 77312: } 
line 77313: if ( zRight == 0 || ! sqlite3GetInt32 ( zRight , & iLimit ) || iLimit <= 0 ) { 
line 77314: iLimit = 0x7fffffff ; 
line 77315: } 
line 77316: sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; 
line 77317: sqlite3VdbeAddOp2 ( v , OP_Integer , iLimit , 1 ) ; 
line 77318: addr = sqlite3VdbeAddOp1 ( v , OP_IncrVacuum , iDb ) ; 
line 77319: sqlite3VdbeAddOp1 ( v , OP_ResultRow , 1 ) ; 
line 77320: sqlite3VdbeAddOp2 ( v , OP_AddImm , 1 , - 1 ) ; 
line 77321: sqlite3VdbeAddOp2 ( v , OP_IfPos , 1 , addr ) ; 
line 77322: sqlite3VdbeJumpHere ( v , addr ) ; 
line 77323: } else 
line 77324: # endif 
line 77326: # ifndef SQLITE_OMIT_PAGER_PRAGMAS 
line 77341: if ( sqlite3StrICmp ( zLeft , "cache_size" ) == 0 ) { 
line 77342: if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; 
line 77343: if ( ! zRight ) { 
line 77344: returnSingleInt ( pParse , "cache_size" , pDb -> pSchema -> cache_size ) ; 
line 77345: } else { 
line 77346: int size = atoi ( zRight ) ; 
line 77347: if ( size < 0 ) size = - size ; 
line 77348: pDb -> pSchema -> cache_size = size ; 
line 77349: sqlite3BtreeSetCacheSize ( pDb -> pBt , pDb -> pSchema -> cache_size ) ; 
line 77350: } 
line 77351: } else 
line 77364: if ( sqlite3StrICmp ( zLeft , "temp_store" ) == 0 ) { 
line 77365: if ( ! zRight ) { 
line 77366: returnSingleInt ( pParse , "temp_store" , db -> temp_store ) ; 
line 77367: } else { 
line 77368: changeTempStorage ( pParse , zRight ) ; 
line 77369: } 
line 77370: } else 
line 77382: if ( sqlite3StrICmp ( zLeft , "temp_store_directory" ) == 0 ) { 
line 77383: if ( ! zRight ) { 
line 77384: if ( sqlite3_temp_directory ) { 
line 77385: sqlite3VdbeSetNumCols ( v , 1 ) ; 
line 77386: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , 
line 77387: "temp_store_directory" , SQLITE_STATIC ) ; 
line 77388: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 1 , 0 , sqlite3_temp_directory , 0 ) ; 
line 77389: sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ) ; 
line 77390: } 
line 77391: } else { 
line 77392: # ifndef SQLITE_OMIT_WSD 
line 77393: if ( zRight [ 0 ] ) { 
line 77394: int rc ; 
line 77395: int res ; 
line 77396: rc = sqlite3OsAccess ( db -> pVfs , zRight , SQLITE_ACCESS_READWRITE , & res ) ; 
line 77397: if ( rc != SQLITE_OK || res == 0 ) { 
line 77398: sqlite3ErrorMsg ( pParse , "not a writable directory" ) ; 
line 77399: goto pragma_out ; 
line 77400: } 
line 77401: } 
line 77402: if ( SQLITE_TEMP_STORE == 0 
line 77403: || ( SQLITE_TEMP_STORE == 1 && db -> temp_store <= 1 ) 
line 77404: || ( SQLITE_TEMP_STORE == 2 && db -> temp_store == 1 ) 
line 77405: ) { 
line 77406: invalidateTempStorage ( pParse ) ; 
line 77407: } 
line 77408: sqlite3_free ( sqlite3_temp_directory ) ; 
line 77409: if ( zRight [ 0 ] ) { 
line 77410: sqlite3_temp_directory = sqlite3DbStrDup ( 0 , zRight ) ; 
line 77411: } else { 
line 77412: sqlite3_temp_directory = 0 ; 
line 77413: } 
line 77414: # endif 
line 77415: } 
line 77416: } else 
line 77418: # if ! defined ( SQLITE_ENABLE_LOCKING_STYLE ) 
line 77419: # if defined ( __APPLE__ ) 
line 77420: # define SQLITE_ENABLE_LOCKING_STYLE 1 
line 77421: # else 
line 77422: # define SQLITE_ENABLE_LOCKING_STYLE 0 
line 77423: # endif 
line 77424: # endif 
line 77425: # if SQLITE_ENABLE_LOCKING_STYLE 
line 77434: if ( sqlite3StrICmp ( zLeft , "lock_proxy_file" ) == 0 ) { 
line 77435: if ( ! zRight ) { 
line 77436: Pager * pPager = sqlite3BtreePager ( pDb -> pBt ) ; 
line 77437: char * proxy_file_path = NULL ; 
line 77438: sqlite3_file * pFile = sqlite3PagerFile ( pPager ) ; 
line 77439: sqlite3OsFileControl ( pFile , SQLITE_GET_LOCKPROXYFILE , 
line 77440: & proxy_file_path ) ; 
line 77442: if ( proxy_file_path ) { 
line 77443: sqlite3VdbeSetNumCols ( v , 1 ) ; 
line 77444: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , 
line 77445: "lock_proxy_file" , SQLITE_STATIC ) ; 
line 77446: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 1 , 0 , proxy_file_path , 0 ) ; 
line 77447: sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ) ; 
line 77448: } 
line 77449: } else { 
line 77450: Pager * pPager = sqlite3BtreePager ( pDb -> pBt ) ; 
line 77451: sqlite3_file * pFile = sqlite3PagerFile ( pPager ) ; 
line 77452: int res ; 
line 77453: if ( zRight [ 0 ] ) { 
line 77454: res = sqlite3OsFileControl ( pFile , SQLITE_SET_LOCKPROXYFILE , 
line 77455: zRight ) ; 
line 77456: } else { 
line 77457: res = sqlite3OsFileControl ( pFile , SQLITE_SET_LOCKPROXYFILE , 
line 77458: NULL ) ; 
line 77459: } 
line 77460: if ( res != SQLITE_OK ) { 
line 77461: sqlite3ErrorMsg ( pParse , "failed to set lock proxy file" ) ; 
line 77462: goto pragma_out ; 
line 77463: } 
line 77464: } 
line 77465: } else 
line 77466: # endif 
line 77477: if ( sqlite3StrICmp ( zLeft , "synchronous" ) == 0 ) { 
line 77478: if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; 
line 77479: if ( ! zRight ) { 
line 77480: returnSingleInt ( pParse , "synchronous" , pDb -> safety_level - 1 ) ; 
line 77481: } else { 
line 77482: if ( ! db -> autoCommit ) { 
line 77483: sqlite3ErrorMsg ( pParse , 
line 77484: "Safety level may not be changed inside a transaction" ) ; 
line 77485: } else { 
line 77486: pDb -> safety_level = getSafetyLevel ( zRight ) + 1 ; 
line 77487: } 
line 77488: } 
line 77489: } else 
line 77490: # endif 
line 77492: # ifndef SQLITE_OMIT_FLAG_PRAGMAS 
line 77493: if ( flagPragma ( pParse , zLeft , zRight ) ) { 
line 77496: } else 
line 77497: # endif 
line 77499: # ifndef SQLITE_OMIT_SCHEMA_PRAGMAS 
line 77512: if ( sqlite3StrICmp ( zLeft , "table_info" ) == 0 && zRight ) { 
line 77513: Table * pTab ; 
line 77514: if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; 
line 77515: pTab = sqlite3FindTable ( db , zRight , zDb ) ; 
line 77516: if ( pTab ) { 
line 77517: int i ; 
line 77518: int nHidden = 0 ; 
line 77519: Column * pCol ; 
line 77520: sqlite3VdbeSetNumCols ( v , 6 ) ; 
line 77521: pParse -> nMem = 6 ; 
line 77522: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "cid" , SQLITE_STATIC ) ; 
line 77523: sqlite3VdbeSetColName ( v , 1 , COLNAME_NAME , "name" , SQLITE_STATIC ) ; 
line 77524: sqlite3VdbeSetColName ( v , 2 , COLNAME_NAME , "type" , SQLITE_STATIC ) ; 
line 77525: sqlite3VdbeSetColName ( v , 3 , COLNAME_NAME , "notnull" , SQLITE_STATIC ) ; 
line 77526: sqlite3VdbeSetColName ( v , 4 , COLNAME_NAME , "dflt_value" , SQLITE_STATIC ) ; 
line 77527: sqlite3VdbeSetColName ( v , 5 , COLNAME_NAME , "pk" , SQLITE_STATIC ) ; 
line 77528: sqlite3ViewGetColumnNames ( pParse , pTab ) ; 
line 77529: for ( i = 0 , pCol = pTab -> aCol ; i < pTab -> nCol ; i ++ , pCol ++ ) { 
line 77530: if ( IsHiddenColumn ( pCol ) ) { 
line 77531: nHidden ++ ; 
line 77532: continue ; 
line 77533: } 
line 77534: sqlite3VdbeAddOp2 ( v , OP_Integer , i - nHidden , 1 ) ; 
line 77535: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 2 , 0 , pCol -> zName , 0 ) ; 
line 77536: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , 
line 77537: pCol -> zType ? pCol -> zType : "" , 0 ) ; 
line 77538: sqlite3VdbeAddOp2 ( v , OP_Integer , ( pCol -> notNull ? 1 : 0 ) , 4 ) ; 
line 77539: if ( pCol -> zDflt ) { 
line 77540: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 5 , 0 , ( char * ) pCol -> zDflt , 0 ) ; 
line 77541: } else { 
line 77542: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , 5 ) ; 
line 77543: } 
line 77544: sqlite3VdbeAddOp2 ( v , OP_Integer , pCol -> isPrimKey , 6 ) ; 
line 77545: sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 6 ) ; 
line 77546: } 
line 77547: } 
line 77548: } else 
line 77550: if ( sqlite3StrICmp ( zLeft , "index_info" ) == 0 && zRight ) { 
line 77551: Index * pIdx ; 
line 77552: Table * pTab ; 
line 77553: if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; 
line 77554: pIdx = sqlite3FindIndex ( db , zRight , zDb ) ; 
line 77555: if ( pIdx ) { 
line 77556: int i ; 
line 77557: pTab = pIdx -> pTable ; 
line 77558: sqlite3VdbeSetNumCols ( v , 3 ) ; 
line 77559: pParse -> nMem = 3 ; 
line 77560: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "seqno" , SQLITE_STATIC ) ; 
line 77561: sqlite3VdbeSetColName ( v , 1 , COLNAME_NAME , "cid" , SQLITE_STATIC ) ; 
line 77562: sqlite3VdbeSetColName ( v , 2 , COLNAME_NAME , "name" , SQLITE_STATIC ) ; 
line 77563: for ( i = 0 ; i < pIdx -> nColumn ; i ++ ) { 
line 77564: int cnum = pIdx -> aiColumn [ i ] ; 
line 77565: sqlite3VdbeAddOp2 ( v , OP_Integer , i , 1 ) ; 
line 77566: sqlite3VdbeAddOp2 ( v , OP_Integer , cnum , 2 ) ; 
line 77567: assert ( pTab -> nCol > cnum ) ; 
line 77568: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , pTab -> aCol [ cnum ] . zName , 0 ) ; 
line 77569: sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 3 ) ; 
line 77570: } 
line 77571: } 
line 77572: } else 
line 77574: if ( sqlite3StrICmp ( zLeft , "index_list" ) == 0 && zRight ) { 
line 77575: Index * pIdx ; 
line 77576: Table * pTab ; 
line 77577: if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; 
line 77578: pTab = sqlite3FindTable ( db , zRight , zDb ) ; 
line 77579: if ( pTab ) { 
line 77580: v = sqlite3GetVdbe ( pParse ) ; 
line 77581: pIdx = pTab -> pIndex ; 
line 77582: if ( pIdx ) { 
line 77583: int i = 0 ; 
line 77584: sqlite3VdbeSetNumCols ( v , 3 ) ; 
line 77585: pParse -> nMem = 3 ; 
line 77586: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "seq" , SQLITE_STATIC ) ; 
line 77587: sqlite3VdbeSetColName ( v , 1 , COLNAME_NAME , "name" , SQLITE_STATIC ) ; 
line 77588: sqlite3VdbeSetColName ( v , 2 , COLNAME_NAME , "unique" , SQLITE_STATIC ) ; 
line 77589: while ( pIdx ) { 
line 77590: sqlite3VdbeAddOp2 ( v , OP_Integer , i , 1 ) ; 
line 77591: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 2 , 0 , pIdx -> zName , 0 ) ; 
line 77592: sqlite3VdbeAddOp2 ( v , OP_Integer , pIdx -> onError != OE_None , 3 ) ; 
line 77593: sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 3 ) ; 
line 77594: ++ i ; 
line 77595: pIdx = pIdx -> pNext ; 
line 77596: } 
line 77597: } 
line 77598: } 
line 77599: } else 
line 77601: if ( sqlite3StrICmp ( zLeft , "database_list" ) == 0 ) { 
line 77602: int i ; 
line 77603: if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; 
line 77604: sqlite3VdbeSetNumCols ( v , 3 ) ; 
line 77605: pParse -> nMem = 3 ; 
line 77606: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "seq" , SQLITE_STATIC ) ; 
line 77607: sqlite3VdbeSetColName ( v , 1 , COLNAME_NAME , "name" , SQLITE_STATIC ) ; 
line 77608: sqlite3VdbeSetColName ( v , 2 , COLNAME_NAME , "file" , SQLITE_STATIC ) ; 
line 77609: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 77610: if ( db -> aDb [ i ] . pBt == 0 ) continue ; 
line 77611: assert ( db -> aDb [ i ] . zName != 0 ) ; 
line 77612: sqlite3VdbeAddOp2 ( v , OP_Integer , i , 1 ) ; 
line 77613: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 2 , 0 , db -> aDb [ i ] . zName , 0 ) ; 
line 77614: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , 
line 77615: sqlite3BtreeGetFilename ( db -> aDb [ i ] . pBt ) , 0 ) ; 
line 77616: sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 3 ) ; 
line 77617: } 
line 77618: } else 
line 77620: if ( sqlite3StrICmp ( zLeft , "collation_list" ) == 0 ) { 
line 77621: int i = 0 ; 
line 77622: HashElem * p ; 
line 77623: sqlite3VdbeSetNumCols ( v , 2 ) ; 
line 77624: pParse -> nMem = 2 ; 
line 77625: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "seq" , SQLITE_STATIC ) ; 
line 77626: sqlite3VdbeSetColName ( v , 1 , COLNAME_NAME , "name" , SQLITE_STATIC ) ; 
line 77627: for ( p = sqliteHashFirst ( & db -> aCollSeq ) ; p ; p = sqliteHashNext ( p ) ) { 
line 77628: CollSeq * pColl = ( CollSeq * ) sqliteHashData ( p ) ; 
line 77629: sqlite3VdbeAddOp2 ( v , OP_Integer , i ++ , 1 ) ; 
line 77630: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 2 , 0 , pColl -> zName , 0 ) ; 
line 77631: sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 2 ) ; 
line 77632: } 
line 77633: } else 
line 77634: # endif 
line 77636: # ifndef SQLITE_OMIT_FOREIGN_KEY 
line 77637: if ( sqlite3StrICmp ( zLeft , "foreign_key_list" ) == 0 && zRight ) { 
line 77638: FKey * pFK ; 
line 77639: Table * pTab ; 
line 77640: if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; 
line 77641: pTab = sqlite3FindTable ( db , zRight , zDb ) ; 
line 77642: if ( pTab ) { 
line 77643: v = sqlite3GetVdbe ( pParse ) ; 
line 77644: pFK = pTab -> pFKey ; 
line 77645: if ( pFK ) { 
line 77646: int i = 0 ; 
line 77647: sqlite3VdbeSetNumCols ( v , 8 ) ; 
line 77648: pParse -> nMem = 8 ; 
line 77649: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "id" , SQLITE_STATIC ) ; 
line 77650: sqlite3VdbeSetColName ( v , 1 , COLNAME_NAME , "seq" , SQLITE_STATIC ) ; 
line 77651: sqlite3VdbeSetColName ( v , 2 , COLNAME_NAME , "table" , SQLITE_STATIC ) ; 
line 77652: sqlite3VdbeSetColName ( v , 3 , COLNAME_NAME , "from" , SQLITE_STATIC ) ; 
line 77653: sqlite3VdbeSetColName ( v , 4 , COLNAME_NAME , "to" , SQLITE_STATIC ) ; 
line 77654: sqlite3VdbeSetColName ( v , 5 , COLNAME_NAME , "on_update" , SQLITE_STATIC ) ; 
line 77655: sqlite3VdbeSetColName ( v , 6 , COLNAME_NAME , "on_delete" , SQLITE_STATIC ) ; 
line 77656: sqlite3VdbeSetColName ( v , 7 , COLNAME_NAME , "match" , SQLITE_STATIC ) ; 
line 77657: while ( pFK ) { 
line 77658: int j ; 
line 77659: for ( j = 0 ; j < pFK -> nCol ; j ++ ) { 
line 77660: char * zCol = pFK -> aCol [ j ] . zCol ; 
line 77661: char * zOnDelete = ( char * ) actionName ( pFK -> aAction [ 0 ] ) ; 
line 77662: char * zOnUpdate = ( char * ) actionName ( pFK -> aAction [ 1 ] ) ; 
line 77663: sqlite3VdbeAddOp2 ( v , OP_Integer , i , 1 ) ; 
line 77664: sqlite3VdbeAddOp2 ( v , OP_Integer , j , 2 ) ; 
line 77665: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , pFK -> zTo , 0 ) ; 
line 77666: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 4 , 0 , 
line 77667: pTab -> aCol [ pFK -> aCol [ j ] . iFrom ] . zName , 0 ) ; 
line 77668: sqlite3VdbeAddOp4 ( v , zCol ? OP_String8 : OP_Null , 0 , 5 , 0 , zCol , 0 ) ; 
line 77669: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 6 , 0 , zOnUpdate , 0 ) ; 
line 77670: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 7 , 0 , zOnDelete , 0 ) ; 
line 77671: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 8 , 0 , "NONE" , 0 ) ; 
line 77672: sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 8 ) ; 
line 77673: } 
line 77674: ++ i ; 
line 77675: pFK = pFK -> pNextFrom ; 
line 77676: } 
line 77677: } 
line 77678: } 
line 77679: } else 
line 77680: # endif 
line 77682: # ifndef NDEBUG 
line 77683: if ( sqlite3StrICmp ( zLeft , "parser_trace" ) == 0 ) { 
line 77684: if ( zRight ) { 
line 77685: if ( getBoolean ( zRight ) ) { 
line 77686: sqlite3ParserTrace ( stderr , "parser: " ) ; 
line 77687: } else { 
line 77688: sqlite3ParserTrace ( 0 , 0 ) ; 
line 77689: } 
line 77690: } 
line 77691: } else 
line 77692: # endif 
line 77697: if ( sqlite3StrICmp ( zLeft , "case_sensitive_like" ) == 0 ) { 
line 77698: if ( zRight ) { 
line 77699: sqlite3RegisterLikeFunctions ( db , getBoolean ( zRight ) ) ; 
line 77700: } 
line 77701: } else 
line 77703: # ifndef SQLITE_INTEGRITY_CHECK_ERROR_MAX 
line 77704: # define SQLITE_INTEGRITY_CHECK_ERROR_MAX 100 
line 77705: # endif 
line 77707: # ifndef SQLITE_OMIT_INTEGRITY_CHECK 
line 77712: if ( sqlite3StrICmp ( zLeft , "integrity_check" ) == 0 
line 77713: || sqlite3StrICmp ( zLeft , "quick_check" ) == 0 
line 77714: ) { 
line 77715: int i , j , addr , mxErr ; 
line 77721: static const VdbeOpList endCode [ ] = { 
line 77722: { OP_AddImm , 1 , 0 , 0 } , 
line 77723: { OP_IfNeg , 1 , 0 , 0 } , 
line 77724: { OP_String8 , 0 , 3 , 0 } , 
line 77725: { OP_ResultRow , 3 , 1 , 0 } , 
line 77726: } ; 
line 77728: int isQuick = ( zLeft [ 0 ] == 'q' ) ; 
line 77731: if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; 
line 77732: pParse -> nMem = 6 ; 
line 77733: sqlite3VdbeSetNumCols ( v , 1 ) ; 
line 77734: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "integrity_check" , SQLITE_STATIC ) ; 
line 77737: mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX ; 
line 77738: if ( zRight ) { 
line 77739: mxErr = atoi ( zRight ) ; 
line 77740: if ( mxErr <= 0 ) { 
line 77741: mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX ; 
line 77742: } 
line 77743: } 
line 77744: sqlite3VdbeAddOp2 ( v , OP_Integer , mxErr , 1 ) ; 
line 77747: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 77748: HashElem * x ; 
line 77749: Hash * pTbls ; 
line 77750: int cnt = 0 ; 
line 77752: if ( OMIT_TEMPDB && i == 1 ) continue ; 
line 77754: sqlite3CodeVerifySchema ( pParse , i ) ; 
line 77755: addr = sqlite3VdbeAddOp1 ( v , OP_IfPos , 1 ) ; 
line 77756: sqlite3VdbeAddOp2 ( v , OP_Halt , 0 , 0 ) ; 
line 77757: sqlite3VdbeJumpHere ( v , addr ) ; 
line 77764: pTbls = & db -> aDb [ i ] . pSchema -> tblHash ; 
line 77765: for ( x = sqliteHashFirst ( pTbls ) ; x ; x = sqliteHashNext ( x ) ) { 
line 77766: Table * pTab = sqliteHashData ( x ) ; 
line 77767: Index * pIdx ; 
line 77768: sqlite3VdbeAddOp2 ( v , OP_Integer , pTab -> tnum , 2 + cnt ) ; 
line 77769: cnt ++ ; 
line 77770: for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { 
line 77771: sqlite3VdbeAddOp2 ( v , OP_Integer , pIdx -> tnum , 2 + cnt ) ; 
line 77772: cnt ++ ; 
line 77773: } 
line 77774: } 
line 77777: if ( pParse -> nMem < cnt + 4 ) { 
line 77778: pParse -> nMem = cnt + 4 ; 
line 77779: } 
line 77782: sqlite3VdbeAddOp3 ( v , OP_IntegrityCk , 2 , cnt , 1 ) ; 
line 77783: sqlite3VdbeChangeP5 ( v , ( u8 ) i ) ; 
line 77784: addr = sqlite3VdbeAddOp1 ( v , OP_IsNull , 2 ) ; 
line 77785: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , 
line 77786: sqlite3MPrintf ( db , "*** in database %s ***\n" , db -> aDb [ i ] . zName ) , 
line 77787: P4_DYNAMIC ) ; 
line 77788: sqlite3VdbeAddOp3 ( v , OP_Move , 2 , 4 , 1 ) ; 
line 77789: sqlite3VdbeAddOp3 ( v , OP_Concat , 4 , 3 , 2 ) ; 
line 77790: sqlite3VdbeAddOp2 ( v , OP_ResultRow , 2 , 1 ) ; 
line 77791: sqlite3VdbeJumpHere ( v , addr ) ; 
line 77795: for ( x = sqliteHashFirst ( pTbls ) ; x && ! isQuick ; x = sqliteHashNext ( x ) ) { 
line 77796: Table * pTab = sqliteHashData ( x ) ; 
line 77797: Index * pIdx ; 
line 77798: int loopTop ; 
line 77800: if ( pTab -> pIndex == 0 ) continue ; 
line 77801: addr = sqlite3VdbeAddOp1 ( v , OP_IfPos , 1 ) ; 
line 77802: sqlite3VdbeAddOp2 ( v , OP_Halt , 0 , 0 ) ; 
line 77803: sqlite3VdbeJumpHere ( v , addr ) ; 
line 77804: sqlite3OpenTableAndIndices ( pParse , pTab , 1 , OP_OpenRead ) ; 
line 77805: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , 2 ) ; 
line 77806: loopTop = sqlite3VdbeAddOp2 ( v , OP_Rewind , 1 , 0 ) ; 
line 77807: sqlite3VdbeAddOp2 ( v , OP_AddImm , 2 , 1 ) ; 
line 77808: for ( j = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , j ++ ) { 
line 77809: int jmp2 ; 
line 77810: int r1 ; 
line 77811: static const VdbeOpList idxErr [ ] = { 
line 77812: { OP_AddImm , 1 , - 1 , 0 } , 
line 77813: { OP_String8 , 0 , 3 , 0 } , 
line 77814: { OP_Rowid , 1 , 4 , 0 } , 
line 77815: { OP_String8 , 0 , 5 , 0 } , 
line 77816: { OP_String8 , 0 , 6 , 0 } , 
line 77817: { OP_Concat , 4 , 3 , 3 } , 
line 77818: { OP_Concat , 5 , 3 , 3 } , 
line 77819: { OP_Concat , 6 , 3 , 3 } , 
line 77820: { OP_ResultRow , 3 , 1 , 0 } , 
line 77821: { OP_IfPos , 1 , 0 , 0 } , 
line 77822: { OP_Halt , 0 , 0 , 0 } , 
line 77823: } ; 
line 77824: r1 = sqlite3GenerateIndexKey ( pParse , pIdx , 1 , 3 , 0 ) ; 
line 77825: jmp2 = sqlite3VdbeAddOp4Int ( v , OP_Found , j + 2 , 0 , r1 , pIdx -> nColumn + 1 ) ; 
line 77826: addr = sqlite3VdbeAddOpList ( v , ArraySize ( idxErr ) , idxErr ) ; 
line 77827: sqlite3VdbeChangeP4 ( v , addr + 1 , "rowid " , P4_STATIC ) ; 
line 77828: sqlite3VdbeChangeP4 ( v , addr + 3 , " missing from index " , P4_STATIC ) ; 
line 77829: sqlite3VdbeChangeP4 ( v , addr + 4 , pIdx -> zName , P4_STATIC ) ; 
line 77830: sqlite3VdbeJumpHere ( v , addr + 9 ) ; 
line 77831: sqlite3VdbeJumpHere ( v , jmp2 ) ; 
line 77832: } 
line 77833: sqlite3VdbeAddOp2 ( v , OP_Next , 1 , loopTop + 1 ) ; 
line 77834: sqlite3VdbeJumpHere ( v , loopTop ) ; 
line 77835: for ( j = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , j ++ ) { 
line 77836: static const VdbeOpList cntIdx [ ] = { 
line 77837: { OP_Integer , 0 , 3 , 0 } , 
line 77838: { OP_Rewind , 0 , 0 , 0 } , 
line 77839: { OP_AddImm , 3 , 1 , 0 } , 
line 77840: { OP_Next , 0 , 0 , 0 } , 
line 77841: { OP_Eq , 2 , 0 , 3 } , 
line 77842: { OP_AddImm , 1 , - 1 , 0 } , 
line 77843: { OP_String8 , 0 , 2 , 0 } , 
line 77844: { OP_String8 , 0 , 3 , 0 } , 
line 77845: { OP_Concat , 3 , 2 , 2 } , 
line 77846: { OP_ResultRow , 2 , 1 , 0 } , 
line 77847: } ; 
line 77848: addr = sqlite3VdbeAddOp1 ( v , OP_IfPos , 1 ) ; 
line 77849: sqlite3VdbeAddOp2 ( v , OP_Halt , 0 , 0 ) ; 
line 77850: sqlite3VdbeJumpHere ( v , addr ) ; 
line 77851: addr = sqlite3VdbeAddOpList ( v , ArraySize ( cntIdx ) , cntIdx ) ; 
line 77852: sqlite3VdbeChangeP1 ( v , addr + 1 , j + 2 ) ; 
line 77853: sqlite3VdbeChangeP2 ( v , addr + 1 , addr + 4 ) ; 
line 77854: sqlite3VdbeChangeP1 ( v , addr + 3 , j + 2 ) ; 
line 77855: sqlite3VdbeChangeP2 ( v , addr + 3 , addr + 2 ) ; 
line 77856: sqlite3VdbeJumpHere ( v , addr + 4 ) ; 
line 77857: sqlite3VdbeChangeP4 ( v , addr + 6 , 
line 77858: "wrong # of entries in index " , P4_STATIC ) ; 
line 77859: sqlite3VdbeChangeP4 ( v , addr + 7 , pIdx -> zName , P4_STATIC ) ; 
line 77860: } 
line 77861: } 
line 77862: } 
line 77863: addr = sqlite3VdbeAddOpList ( v , ArraySize ( endCode ) , endCode ) ; 
line 77864: sqlite3VdbeChangeP2 ( v , addr , - mxErr ) ; 
line 77865: sqlite3VdbeJumpHere ( v , addr + 1 ) ; 
line 77866: sqlite3VdbeChangeP4 ( v , addr + 2 , "ok" , P4_STATIC ) ; 
line 77867: } else 
line 77868: # endif 
line 77870: # ifndef SQLITE_OMIT_UTF16 
line 77893: if ( sqlite3StrICmp ( zLeft , "encoding" ) == 0 ) { 
line 77894: static const struct EncName { 
line 77895: char * zName ; 
line 77896: u8 enc ; 
line 77897: } encnames [ ] = { 
line 77898: { "UTF8" , SQLITE_UTF8 } , 
line 77899: { "UTF-8" , SQLITE_UTF8 } , 
line 77900: { "UTF-16le" , SQLITE_UTF16LE } , 
line 77901: { "UTF-16be" , SQLITE_UTF16BE } , 
line 77902: { "UTF16le" , SQLITE_UTF16LE } , 
line 77903: { "UTF16be" , SQLITE_UTF16BE } , 
line 77904: { "UTF-16" , 0 } , 
line 77905: { "UTF16" , 0 } , 
line 77906: { 0 , 0 } 
line 77907: } ; 
line 77908: const struct EncName * pEnc ; 
line 77909: if ( ! zRight ) { 
line 77910: if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; 
line 77911: sqlite3VdbeSetNumCols ( v , 1 ) ; 
line 77912: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "encoding" , SQLITE_STATIC ) ; 
line 77913: sqlite3VdbeAddOp2 ( v , OP_String8 , 0 , 1 ) ; 
line 77914: assert ( encnames [ SQLITE_UTF8 ] . enc == SQLITE_UTF8 ) ; 
line 77915: assert ( encnames [ SQLITE_UTF16LE ] . enc == SQLITE_UTF16LE ) ; 
line 77916: assert ( encnames [ SQLITE_UTF16BE ] . enc == SQLITE_UTF16BE ) ; 
line 77917: sqlite3VdbeChangeP4 ( v , - 1 , encnames [ ENC ( pParse -> db ) ] . zName , P4_STATIC ) ; 
line 77918: sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ) ; 
line 77919: } else { 
line 77925: if ( 
line 77926: ! ( DbHasProperty ( db , 0 , DB_SchemaLoaded ) ) || 
line 77927: DbHasProperty ( db , 0 , DB_Empty ) 
line 77928: ) { 
line 77929: for ( pEnc = & encnames [ 0 ] ; pEnc -> zName ; pEnc ++ ) { 
line 77930: if ( 0 == sqlite3StrICmp ( zRight , pEnc -> zName ) ) { 
line 77931: ENC ( pParse -> db ) = pEnc -> enc ? pEnc -> enc : SQLITE_UTF16NATIVE ; 
line 77932: break ; 
line 77933: } 
line 77934: } 
line 77935: if ( ! pEnc -> zName ) { 
line 77936: sqlite3ErrorMsg ( pParse , "unsupported encoding: %s" , zRight ) ; 
line 77937: } 
line 77938: } 
line 77939: } 
line 77940: } else 
line 77941: # endif 
line 77943: # ifndef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS 
line 77969: if ( sqlite3StrICmp ( zLeft , "schema_version" ) == 0 
line 77970: || sqlite3StrICmp ( zLeft , "user_version" ) == 0 
line 77971: || sqlite3StrICmp ( zLeft , "freelist_count" ) == 0 
line 77972: ) { 
line 77973: int iCookie ; 
line 77974: sqlite3VdbeUsesBtree ( v , iDb ) ; 
line 77975: switch ( zLeft [ 0 ] ) { 
line 77976: case 'f' : case 'F' : 
line 77977: iCookie = BTREE_FREE_PAGE_COUNT ; 
line 77978: break ; 
line 77979: case 's' : case 'S' : 
line 77980: iCookie = BTREE_SCHEMA_VERSION ; 
line 77981: break ; 
line 77982: default : 
line 77983: iCookie = BTREE_USER_VERSION ; 
line 77984: break ; 
line 77985: } 
line 77987: if ( zRight && iCookie != BTREE_FREE_PAGE_COUNT ) { 
line 77989: static const VdbeOpList setCookie [ ] = { 
line 77990: { OP_Transaction , 0 , 1 , 0 } , 
line 77991: { OP_Integer , 0 , 1 , 0 } , 
line 77992: { OP_SetCookie , 0 , 0 , 1 } , 
line 77993: } ; 
line 77994: int addr = sqlite3VdbeAddOpList ( v , ArraySize ( setCookie ) , setCookie ) ; 
line 77995: sqlite3VdbeChangeP1 ( v , addr , iDb ) ; 
line 77996: sqlite3VdbeChangeP1 ( v , addr + 1 , atoi ( zRight ) ) ; 
line 77997: sqlite3VdbeChangeP1 ( v , addr + 2 , iDb ) ; 
line 77998: sqlite3VdbeChangeP2 ( v , addr + 2 , iCookie ) ; 
line 77999: } else { 
line 78001: static const VdbeOpList readCookie [ ] = { 
line 78002: { OP_Transaction , 0 , 0 , 0 } , 
line 78003: { OP_ReadCookie , 0 , 1 , 0 } , 
line 78004: { OP_ResultRow , 1 , 1 , 0 } 
line 78005: } ; 
line 78006: int addr = sqlite3VdbeAddOpList ( v , ArraySize ( readCookie ) , readCookie ) ; 
line 78007: sqlite3VdbeChangeP1 ( v , addr , iDb ) ; 
line 78008: sqlite3VdbeChangeP1 ( v , addr + 1 , iDb ) ; 
line 78009: sqlite3VdbeChangeP3 ( v , addr + 1 , iCookie ) ; 
line 78010: sqlite3VdbeSetNumCols ( v , 1 ) ; 
line 78011: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , zLeft , SQLITE_TRANSIENT ) ; 
line 78012: } 
line 78013: } else 
line 78014: # endif 
line 78016: # if defined ( SQLITE_DEBUG ) || defined ( SQLITE_TEST ) 
line 78020: if ( sqlite3StrICmp ( zLeft , "lock_status" ) == 0 ) { 
line 78021: static const char * const azLockName [ ] = { 
line 78022: "unlocked" , "shared" , "reserved" , "pending" , "exclusive" 
line 78023: } ; 
line 78024: int i ; 
line 78025: sqlite3VdbeSetNumCols ( v , 2 ) ; 
line 78026: pParse -> nMem = 2 ; 
line 78027: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "database" , SQLITE_STATIC ) ; 
line 78028: sqlite3VdbeSetColName ( v , 1 , COLNAME_NAME , "status" , SQLITE_STATIC ) ; 
line 78029: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 78030: Btree * pBt ; 
line 78031: Pager * pPager ; 
line 78032: const char * zState = "unknown" ; 
line 78033: int j ; 
line 78034: if ( db -> aDb [ i ] . zName == 0 ) continue ; 
line 78035: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 1 , 0 , db -> aDb [ i ] . zName , P4_STATIC ) ; 
line 78036: pBt = db -> aDb [ i ] . pBt ; 
line 78037: if ( pBt == 0 || ( pPager = sqlite3BtreePager ( pBt ) ) == 0 ) { 
line 78038: zState = "closed" ; 
line 78039: } else if ( sqlite3_file_control ( db , i ? db -> aDb [ i ] . zName : 0 , 
line 78040: SQLITE_FCNTL_LOCKSTATE , & j ) == SQLITE_OK ) { 
line 78041: zState = azLockName [ j ] ; 
line 78042: } 
line 78043: sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 2 , 0 , zState , P4_STATIC ) ; 
line 78044: sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 2 ) ; 
line 78045: } 
line 78047: } else 
line 78048: # endif 
line 78050: # if SQLITE_HAS_CODEC 
line 78051: if ( sqlite3StrICmp ( zLeft , "key" ) == 0 && zRight ) { 
line 78052: sqlite3_key ( db , zRight , sqlite3Strlen30 ( zRight ) ) ; 
line 78053: } else 
line 78054: if ( sqlite3StrICmp ( zLeft , "rekey" ) == 0 && zRight ) { 
line 78055: sqlite3_rekey ( db , zRight , sqlite3Strlen30 ( zRight ) ) ; 
line 78056: } else 
line 78057: if ( zRight && ( sqlite3StrICmp ( zLeft , "hexkey" ) == 0 || 
line 78058: sqlite3StrICmp ( zLeft , "hexrekey" ) == 0 ) ) { 
line 78059: int i , h1 , h2 ; 
line 78060: char zKey [ 40 ] ; 
line 78061: for ( i = 0 ; ( h1 = zRight [ i ] ) != 0 && ( h2 = zRight [ i + 1 ] ) != 0 ; i += 2 ) { 
line 78062: h1 += 9 * ( 1 & ( h1 >> 6 ) ) ; 
line 78063: h2 += 9 * ( 1 & ( h2 >> 6 ) ) ; 
line 78064: zKey [ i / 2 ] = ( h2 & 0x0f ) | ( ( h1 & 0xf ) << 4 ) ; 
line 78065: } 
line 78066: if ( ( zLeft [ 3 ] & 0xf ) == 0xb ) { 
line 78067: sqlite3_key ( db , zKey , i / 2 ) ; 
line 78068: } else { 
line 78069: sqlite3_rekey ( db , zKey , i / 2 ) ; 
line 78070: } 
line 78071: } else 
line 78072: # endif 
line 78073: # if SQLITE_HAS_CODEC || defined ( SQLITE_ENABLE_CEROD ) 
line 78074: if ( sqlite3StrICmp ( zLeft , "activate_extensions" ) == 0 ) { 
line 78075: # if SQLITE_HAS_CODEC 
line 78076: if ( sqlite3StrNICmp ( zRight , "see-" , 4 ) == 0 ) { 
line 78077: extern void sqlite3_activate_see ( const char * ) ; 
line 78078: sqlite3_activate_see ( & zRight [ 4 ] ) ; 
line 78079: } 
line 78080: # endif 
line 78081: # ifdef SQLITE_ENABLE_CEROD 
line 78082: if ( sqlite3StrNICmp ( zRight , "cerod-" , 6 ) == 0 ) { 
line 78083: extern void sqlite3_activate_cerod ( const char * ) ; 
line 78084: sqlite3_activate_cerod ( & zRight [ 6 ] ) ; 
line 78085: } 
line 78086: # endif 
line 78087: } else 
line 78088: # endif 
line 78091: { } 
line 78097: sqlite3VdbeAddOp2 ( v , OP_Expire , 1 , 0 ) ; 
line 78103: # ifndef SQLITE_OMIT_PAGER_PRAGMAS 
line 78104: if ( db -> autoCommit ) { 
line 78105: sqlite3BtreeSetSafetyLevel ( pDb -> pBt , pDb -> safety_level , 
line 78106: ( db -> flags & SQLITE_FullFSync ) != 0 ) ; 
line 78107: } 
line 78108: # endif 
line 78109: pragma_out : 
line 78110: sqlite3DbFree ( db , zLeft ) ; 
line 78111: sqlite3DbFree ( db , zRight ) ; 
line 78112: } 
line 78114: # endif 
line 78138: static void corruptSchema ( 
line 78139: InitData * pData , 
line 78140: const char * zObj , 
line 78141: const char * zExtra 
line 78142: ) { 
line 78143: sqlite3 * db = pData -> db ; 
line 78144: if ( ! db -> mallocFailed && ( db -> flags & SQLITE_RecoveryMode ) == 0 ) { 
line 78145: if ( zObj == 0 ) zObj = "?" ; 
line 78146: sqlite3SetString ( pData -> pzErrMsg , db , 
line 78147: "malformed database schema (%s)" , zObj ) ; 
line 78148: if ( zExtra ) { 
line 78149: * pData -> pzErrMsg = sqlite3MAppendf ( db , * pData -> pzErrMsg , 
line 78150: "%s - %s" , * pData -> pzErrMsg , zExtra ) ; 
line 78151: } 
line 78152: } 
line 78153: pData -> rc = db -> mallocFailed ? SQLITE_NOMEM : SQLITE_CORRUPT ; 
line 78154: } 
line 78168: SQLITE_PRIVATE int sqlite3InitCallback ( void * pInit , int argc , char * * argv , char * * NotUsed ) { 
line 78169: InitData * pData = ( InitData * ) pInit ; 
line 78170: sqlite3 * db = pData -> db ; 
line 78171: int iDb = pData -> iDb ; 
line 78173: assert ( argc == 3 ) ; 
line 78174: UNUSED_PARAMETER2 ( NotUsed , argc ) ; 
line 78175: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 78176: DbClearProperty ( db , iDb , DB_Empty ) ; 
line 78177: if ( db -> mallocFailed ) { 
line 78178: corruptSchema ( pData , argv [ 0 ] , 0 ) ; 
line 78179: return 1 ; 
line 78180: } 
line 78182: assert ( iDb >= 0 && iDb < db -> nDb ) ; 
line 78183: if ( argv == 0 ) return 0 ; 
line 78184: if ( argv [ 1 ] == 0 ) { 
line 78185: corruptSchema ( pData , argv [ 0 ] , 0 ) ; 
line 78186: } else if ( argv [ 2 ] && argv [ 2 ] [ 0 ] ) { 
line 78192: char * zErr ; 
line 78193: int rc ; 
line 78194: assert ( db -> init . busy ) ; 
line 78195: db -> init . iDb = iDb ; 
line 78196: db -> init . newTnum = atoi ( argv [ 1 ] ) ; 
line 78197: db -> init . orphanTrigger = 0 ; 
line 78198: rc = sqlite3_exec ( db , argv [ 2 ] , 0 , 0 , & zErr ) ; 
line 78199: db -> init . iDb = 0 ; 
line 78200: assert ( rc != SQLITE_OK || zErr == 0 ) ; 
line 78201: if ( SQLITE_OK != rc ) { 
line 78202: if ( db -> init . orphanTrigger ) { 
line 78203: assert ( iDb == 1 ) ; 
line 78204: } else { 
line 78205: pData -> rc = rc ; 
line 78206: if ( rc == SQLITE_NOMEM ) { 
line 78207: db -> mallocFailed = 1 ; 
line 78208: } else if ( rc != SQLITE_INTERRUPT && rc != SQLITE_LOCKED ) { 
line 78209: corruptSchema ( pData , argv [ 0 ] , zErr ) ; 
line 78210: } 
line 78211: } 
line 78212: sqlite3DbFree ( db , zErr ) ; 
line 78213: } 
line 78214: } else if ( argv [ 0 ] == 0 ) { 
line 78215: corruptSchema ( pData , 0 , 0 ) ; 
line 78216: } else { 
line 78223: Index * pIndex ; 
line 78224: pIndex = sqlite3FindIndex ( db , argv [ 0 ] , db -> aDb [ iDb ] . zName ) ; 
line 78225: if ( pIndex == 0 ) { 
line 78231: ; 
line 78232: } else if ( sqlite3GetInt32 ( argv [ 1 ] , & pIndex -> tnum ) == 0 ) { 
line 78233: corruptSchema ( pData , argv [ 0 ] , "invalid rootpage" ) ; 
line 78234: } 
line 78235: } 
line 78236: return 0 ; 
line 78237: } 
line 78247: static int sqlite3InitOne ( sqlite3 * db , int iDb , char * * pzErrMsg ) { 
line 78248: int rc ; 
line 78249: int i ; 
line 78250: int size ; 
line 78251: Table * pTab ; 
line 78252: Db * pDb ; 
line 78253: char const * azArg [ 4 ] ; 
line 78254: int meta [ 5 ] ; 
line 78255: InitData initData ; 
line 78256: char const * zMasterSchema ; 
line 78257: char const * zMasterName = SCHEMA_TABLE ( iDb ) ; 
line 78258: int openedTransaction = 0 ; 
line 78263: static const char master_schema [ ] = 
line 78264: "CREATE TABLE sqlite_master(\n" 
line 78265: "  type text,\n" 
line 78266: "  name text,\n" 
line 78267: "  tbl_name text,\n" 
line 78268: "  rootpage integer,\n" 
line 78269: "  sql text\n" 
line 78270: ")" 
line 78271: ; 
line 78272: # ifndef SQLITE_OMIT_TEMPDB 
line 78273: static const char temp_master_schema [ ] = 
line 78274: "CREATE TEMP TABLE sqlite_temp_master(\n" 
line 78275: "  type text,\n" 
line 78276: "  name text,\n" 
line 78277: "  tbl_name text,\n" 
line 78278: "  rootpage integer,\n" 
line 78279: "  sql text\n" 
line 78280: ")" 
line 78281: ; 
line 78282: # else 
line 78283: # define temp_master_schema 0 
line 78284: # endif 
line 78286: assert ( iDb >= 0 && iDb < db -> nDb ) ; 
line 78287: assert ( db -> aDb [ iDb ] . pSchema ) ; 
line 78288: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 78289: assert ( iDb == 1 || sqlite3BtreeHoldsMutex ( db -> aDb [ iDb ] . pBt ) ) ; 
line 78295: if ( ! OMIT_TEMPDB && iDb == 1 ) { 
line 78296: zMasterSchema = temp_master_schema ; 
line 78297: } else { 
line 78298: zMasterSchema = master_schema ; 
line 78299: } 
line 78300: zMasterName = SCHEMA_TABLE ( iDb ) ; 
line 78303: azArg [ 0 ] = zMasterName ; 
line 78304: azArg [ 1 ] = "1" ; 
line 78305: azArg [ 2 ] = zMasterSchema ; 
line 78306: azArg [ 3 ] = 0 ; 
line 78307: initData . db = db ; 
line 78308: initData . iDb = iDb ; 
line 78309: initData . rc = SQLITE_OK ; 
line 78310: initData . pzErrMsg = pzErrMsg ; 
line 78311: ( void ) sqlite3SafetyOff ( db ) ; 
line 78312: sqlite3InitCallback ( & initData , 3 , ( char * * ) azArg , 0 ) ; 
line 78313: ( void ) sqlite3SafetyOn ( db ) ; 
line 78314: if ( initData . rc ) { 
line 78315: rc = initData . rc ; 
line 78316: goto error_out ; 
line 78317: } 
line 78318: pTab = sqlite3FindTable ( db , zMasterName , db -> aDb [ iDb ] . zName ) ; 
line 78319: if ( ALWAYS ( pTab ) ) { 
line 78320: pTab -> tabFlags |= TF_Readonly ; 
line 78321: } 
line 78325: pDb = & db -> aDb [ iDb ] ; 
line 78326: if ( pDb -> pBt == 0 ) { 
line 78327: if ( ! OMIT_TEMPDB && ALWAYS ( iDb == 1 ) ) { 
line 78328: DbSetProperty ( db , 1 , DB_SchemaLoaded ) ; 
line 78329: } 
line 78330: return SQLITE_OK ; 
line 78331: } 
line 78336: sqlite3BtreeEnter ( pDb -> pBt ) ; 
line 78337: if ( ! sqlite3BtreeIsInReadTrans ( pDb -> pBt ) ) { 
line 78338: rc = sqlite3BtreeBeginTrans ( pDb -> pBt , 0 ) ; 
line 78339: if ( rc != SQLITE_OK ) { 
line 78340: sqlite3SetString ( pzErrMsg , db , "%s" , sqlite3ErrStr ( rc ) ) ; 
line 78341: goto initone_error_out ; 
line 78342: } 
line 78343: openedTransaction = 1 ; 
line 78344: } 
line 78363: for ( i = 0 ; i < ArraySize ( meta ) ; i ++ ) { 
line 78364: sqlite3BtreeGetMeta ( pDb -> pBt , i + 1 , ( u32 * ) & meta [ i ] ) ; 
line 78365: } 
line 78366: pDb -> pSchema -> schema_cookie = meta [ BTREE_SCHEMA_VERSION - 1 ] ; 
line 78373: if ( meta [ BTREE_TEXT_ENCODING - 1 ] ) { 
line 78374: if ( iDb == 0 ) { 
line 78375: u8 encoding ; 
line 78377: encoding = ( u8 ) meta [ BTREE_TEXT_ENCODING - 1 ] & 3 ; 
line 78378: if ( encoding == 0 ) encoding = SQLITE_UTF8 ; 
line 78379: ENC ( db ) = encoding ; 
line 78380: db -> pDfltColl = sqlite3FindCollSeq ( db , SQLITE_UTF8 , "BINARY" , 0 ) ; 
line 78381: } else { 
line 78383: if ( meta [ BTREE_TEXT_ENCODING - 1 ] != ENC ( db ) ) { 
line 78384: sqlite3SetString ( pzErrMsg , db , "attached databases must use the same" 
line 78385: " text encoding as main database" ) ; 
line 78386: rc = SQLITE_ERROR ; 
line 78387: goto initone_error_out ; 
line 78388: } 
line 78389: } 
line 78390: } else { 
line 78391: DbSetProperty ( db , iDb , DB_Empty ) ; 
line 78392: } 
line 78393: pDb -> pSchema -> enc = ENC ( db ) ; 
line 78395: if ( pDb -> pSchema -> cache_size == 0 ) { 
line 78396: size = meta [ BTREE_DEFAULT_CACHE_SIZE - 1 ] ; 
line 78397: if ( size == 0 ) { size = SQLITE_DEFAULT_CACHE_SIZE ; } 
line 78398: if ( size < 0 ) size = - size ; 
line 78399: pDb -> pSchema -> cache_size = size ; 
line 78400: sqlite3BtreeSetCacheSize ( pDb -> pBt , pDb -> pSchema -> cache_size ) ; 
line 78401: } 
line 78409: pDb -> pSchema -> file_format = ( u8 ) meta [ BTREE_FILE_FORMAT - 1 ] ; 
line 78410: if ( pDb -> pSchema -> file_format == 0 ) { 
line 78411: pDb -> pSchema -> file_format = 1 ; 
line 78412: } 
line 78413: if ( pDb -> pSchema -> file_format > SQLITE_MAX_FILE_FORMAT ) { 
line 78414: sqlite3SetString ( pzErrMsg , db , "unsupported file format" ) ; 
line 78415: rc = SQLITE_ERROR ; 
line 78416: goto initone_error_out ; 
line 78417: } 
line 78424: if ( iDb == 0 && meta [ BTREE_FILE_FORMAT - 1 ] >= 4 ) { 
line 78425: db -> flags &= ~ SQLITE_LegacyFileFmt ; 
line 78426: } 
line 78430: assert ( db -> init . busy ) ; 
line 78431: { 
line 78432: char * zSql ; 
line 78433: zSql = sqlite3MPrintf ( db , 
line 78434: "SELECT name, rootpage, sql FROM '%q'.%s" , 
line 78435: db -> aDb [ iDb ] . zName , zMasterName ) ; 
line 78436: ( void ) sqlite3SafetyOff ( db ) ; 
line 78437: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 78438: { 
line 78439: int ( * xAuth ) ( void * , int , const char * , const char * , const char * , const char * ) ; 
line 78440: xAuth = db -> xAuth ; 
line 78441: db -> xAuth = 0 ; 
line 78442: # endif 
line 78443: rc = sqlite3_exec ( db , zSql , sqlite3InitCallback , & initData , 0 ) ; 
line 78444: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 78445: db -> xAuth = xAuth ; 
line 78446: } 
line 78447: # endif 
line 78448: if ( rc == SQLITE_OK ) rc = initData . rc ; 
line 78449: ( void ) sqlite3SafetyOn ( db ) ; 
line 78450: sqlite3DbFree ( db , zSql ) ; 
line 78451: # ifndef SQLITE_OMIT_ANALYZE 
line 78452: if ( rc == SQLITE_OK ) { 
line 78453: sqlite3AnalysisLoad ( db , iDb ) ; 
line 78454: } 
line 78455: # endif 
line 78456: } 
line 78457: if ( db -> mallocFailed ) { 
line 78458: rc = SQLITE_NOMEM ; 
line 78459: sqlite3ResetInternalSchema ( db , 0 ) ; 
line 78460: } 
line 78461: if ( rc == SQLITE_OK || ( db -> flags & SQLITE_RecoveryMode ) ) { 
line 78470: DbSetProperty ( db , iDb , DB_SchemaLoaded ) ; 
line 78471: rc = SQLITE_OK ; 
line 78472: } 
line 78478: initone_error_out : 
line 78479: if ( openedTransaction ) { 
line 78480: sqlite3BtreeCommit ( pDb -> pBt ) ; 
line 78481: } 
line 78482: sqlite3BtreeLeave ( pDb -> pBt ) ; 
line 78484: error_out : 
line 78485: if ( rc == SQLITE_NOMEM || rc == SQLITE_IOERR_NOMEM ) { 
line 78486: db -> mallocFailed = 1 ; 
line 78487: } 
line 78488: return rc ; 
line 78489: } 
line 78501: SQLITE_PRIVATE int sqlite3Init ( sqlite3 * db , char * * pzErrMsg ) { 
line 78502: int i , rc ; 
line 78503: int commit_internal = ! ( db -> flags & SQLITE_InternChanges ) ; 
line 78505: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 78506: rc = SQLITE_OK ; 
line 78507: db -> init . busy = 1 ; 
line 78508: for ( i = 0 ; rc == SQLITE_OK && i < db -> nDb ; i ++ ) { 
line 78509: if ( DbHasProperty ( db , i , DB_SchemaLoaded ) || i == 1 ) continue ; 
line 78510: rc = sqlite3InitOne ( db , i , pzErrMsg ) ; 
line 78511: if ( rc ) { 
line 78512: sqlite3ResetInternalSchema ( db , i ) ; 
line 78513: } 
line 78514: } 
line 78520: # ifndef SQLITE_OMIT_TEMPDB 
line 78521: if ( rc == SQLITE_OK && ALWAYS ( db -> nDb > 1 ) 
line 78522: && ! DbHasProperty ( db , 1 , DB_SchemaLoaded ) ) { 
line 78523: rc = sqlite3InitOne ( db , 1 , pzErrMsg ) ; 
line 78524: if ( rc ) { 
line 78525: sqlite3ResetInternalSchema ( db , 1 ) ; 
line 78526: } 
line 78527: } 
line 78528: # endif 
line 78530: db -> init . busy = 0 ; 
line 78531: if ( rc == SQLITE_OK && commit_internal ) { 
line 78532: sqlite3CommitInternalChanges ( db ) ; 
line 78533: } 
line 78535: return rc ; 
line 78536: } 
line 78542: SQLITE_PRIVATE int sqlite3ReadSchema ( Parse * pParse ) { 
line 78543: int rc = SQLITE_OK ; 
line 78544: sqlite3 * db = pParse -> db ; 
line 78545: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 78546: if ( ! db -> init . busy ) { 
line 78547: rc = sqlite3Init ( db , & pParse -> zErrMsg ) ; 
line 78548: } 
line 78549: if ( rc != SQLITE_OK ) { 
line 78550: pParse -> rc = rc ; 
line 78551: pParse -> nErr ++ ; 
line 78552: } 
line 78553: return rc ; 
line 78554: } 
line 78562: static void schemaIsValid ( Parse * pParse ) { 
line 78563: sqlite3 * db = pParse -> db ; 
line 78564: int iDb ; 
line 78565: int rc ; 
line 78566: int cookie ; 
line 78568: assert ( pParse -> checkSchema ) ; 
line 78569: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 78570: for ( iDb = 0 ; iDb < db -> nDb ; iDb ++ ) { 
line 78571: int openedTransaction = 0 ; 
line 78572: Btree * pBt = db -> aDb [ iDb ] . pBt ; 
line 78573: if ( pBt == 0 ) continue ; 
line 78578: if ( ! sqlite3BtreeIsInReadTrans ( pBt ) ) { 
line 78579: rc = sqlite3BtreeBeginTrans ( pBt , 0 ) ; 
line 78580: if ( rc == SQLITE_NOMEM || rc == SQLITE_IOERR_NOMEM ) { 
line 78581: db -> mallocFailed = 1 ; 
line 78582: } 
line 78583: if ( rc != SQLITE_OK ) return ; 
line 78584: openedTransaction = 1 ; 
line 78585: } 
line 78590: sqlite3BtreeGetMeta ( pBt , BTREE_SCHEMA_VERSION , ( u32 * ) & cookie ) ; 
line 78591: if ( cookie != db -> aDb [ iDb ] . pSchema -> schema_cookie ) { 
line 78592: pParse -> rc = SQLITE_SCHEMA ; 
line 78593: } 
line 78596: if ( openedTransaction ) { 
line 78597: sqlite3BtreeCommit ( pBt ) ; 
line 78598: } 
line 78599: } 
line 78600: } 
line 78609: SQLITE_PRIVATE int sqlite3SchemaToIndex ( sqlite3 * db , Schema * pSchema ) { 
line 78610: int i = - 1000000 ; 
line 78622: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 78623: if ( pSchema ) { 
line 78624: for ( i = 0 ; ALWAYS ( i < db -> nDb ) ; i ++ ) { 
line 78625: if ( db -> aDb [ i ] . pSchema == pSchema ) { 
line 78626: break ; 
line 78627: } 
line 78628: } 
line 78629: assert ( i >= 0 && i < db -> nDb ) ; 
line 78630: } 
line 78631: return i ; 
line 78632: } 
line 78637: static int sqlite3Prepare ( 
line 78638: sqlite3 * db , 
line 78639: const char * zSql , 
line 78640: int nBytes , 
line 78641: int saveSqlFlag , 
line 78642: Vdbe * pReprepare , 
line 78643: sqlite3_stmt * * ppStmt , 
line 78644: const char * * pzTail 
line 78645: ) { 
line 78646: Parse * pParse ; 
line 78647: char * zErrMsg = 0 ; 
line 78648: int rc = SQLITE_OK ; 
line 78649: int i ; 
line 78652: pParse = sqlite3StackAllocZero ( db , sizeof ( * pParse ) ) ; 
line 78653: if ( pParse == 0 ) { 
line 78654: rc = SQLITE_NOMEM ; 
line 78655: goto end_prepare ; 
line 78656: } 
line 78657: pParse -> pReprepare = pReprepare ; 
line 78659: if ( sqlite3SafetyOn ( db ) ) { 
line 78660: rc = SQLITE_MISUSE ; 
line 78661: goto end_prepare ; 
line 78662: } 
line 78663: assert ( ppStmt && * ppStmt == 0 ) ; 
line 78664: assert ( ! db -> mallocFailed ) ; 
line 78665: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 78690: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 78691: Btree * pBt = db -> aDb [ i ] . pBt ; 
line 78692: if ( pBt ) { 
line 78693: assert ( sqlite3BtreeHoldsMutex ( pBt ) ) ; 
line 78694: rc = sqlite3BtreeSchemaLocked ( pBt ) ; 
line 78695: if ( rc ) { 
line 78696: const char * zDb = db -> aDb [ i ] . zName ; 
line 78697: sqlite3Error ( db , rc , "database schema is locked: %s" , zDb ) ; 
line 78698: ( void ) sqlite3SafetyOff ( db ) ; 
line 78699: testcase ( db -> flags & SQLITE_ReadUncommitted ) ; 
line 78700: goto end_prepare ; 
line 78701: } 
line 78702: } 
line 78703: } 
line 78705: sqlite3VtabUnlockList ( db ) ; 
line 78707: pParse -> db = db ; 
line 78708: if ( nBytes >= 0 && ( nBytes == 0 || zSql [ nBytes - 1 ] != 0 ) ) { 
line 78709: char * zSqlCopy ; 
line 78710: int mxLen = db -> aLimit [ SQLITE_LIMIT_SQL_LENGTH ] ; 
line 78711: testcase ( nBytes == mxLen ) ; 
line 78712: testcase ( nBytes == mxLen + 1 ) ; 
line 78713: if ( nBytes > mxLen ) { 
line 78714: sqlite3Error ( db , SQLITE_TOOBIG , "statement too long" ) ; 
line 78715: ( void ) sqlite3SafetyOff ( db ) ; 
line 78716: rc = sqlite3ApiExit ( db , SQLITE_TOOBIG ) ; 
line 78717: goto end_prepare ; 
line 78718: } 
line 78719: zSqlCopy = sqlite3DbStrNDup ( db , zSql , nBytes ) ; 
line 78720: if ( zSqlCopy ) { 
line 78721: sqlite3RunParser ( pParse , zSqlCopy , & zErrMsg ) ; 
line 78722: sqlite3DbFree ( db , zSqlCopy ) ; 
line 78723: pParse -> zTail = & zSql [ pParse -> zTail - zSqlCopy ] ; 
line 78724: } else { 
line 78725: pParse -> zTail = & zSql [ nBytes ] ; 
line 78726: } 
line 78727: } else { 
line 78728: sqlite3RunParser ( pParse , zSql , & zErrMsg ) ; 
line 78729: } 
line 78731: if ( db -> mallocFailed ) { 
line 78732: pParse -> rc = SQLITE_NOMEM ; 
line 78733: } 
line 78734: if ( pParse -> rc == SQLITE_DONE ) pParse -> rc = SQLITE_OK ; 
line 78735: if ( pParse -> checkSchema ) { 
line 78736: schemaIsValid ( pParse ) ; 
line 78737: } 
line 78738: if ( pParse -> rc == SQLITE_SCHEMA ) { 
line 78739: sqlite3ResetInternalSchema ( db , 0 ) ; 
line 78740: } 
line 78741: if ( db -> mallocFailed ) { 
line 78742: pParse -> rc = SQLITE_NOMEM ; 
line 78743: } 
line 78744: if ( pzTail ) { 
line 78745: * pzTail = pParse -> zTail ; 
line 78746: } 
line 78747: rc = pParse -> rc ; 
line 78749: # ifndef SQLITE_OMIT_EXPLAIN 
line 78750: if ( rc == SQLITE_OK && pParse -> pVdbe && pParse -> explain ) { 
line 78751: static const char * const azColName [ ] = { 
line 78752: "addr" , "opcode" , "p1" , "p2" , "p3" , "p4" , "p5" , "comment" , 
line 78753: "order" , "from" , "detail" 
line 78754: } ; 
line 78755: int iFirst , mx ; 
line 78756: if ( pParse -> explain == 2 ) { 
line 78757: sqlite3VdbeSetNumCols ( pParse -> pVdbe , 3 ) ; 
line 78758: iFirst = 8 ; 
line 78759: mx = 11 ; 
line 78760: } else { 
line 78761: sqlite3VdbeSetNumCols ( pParse -> pVdbe , 8 ) ; 
line 78762: iFirst = 0 ; 
line 78763: mx = 8 ; 
line 78764: } 
line 78765: for ( i = iFirst ; i < mx ; i ++ ) { 
line 78766: sqlite3VdbeSetColName ( pParse -> pVdbe , i - iFirst , COLNAME_NAME , 
line 78767: azColName [ i ] , SQLITE_STATIC ) ; 
line 78768: } 
line 78769: } 
line 78770: # endif 
line 78772: if ( sqlite3SafetyOff ( db ) ) { 
line 78773: rc = SQLITE_MISUSE ; 
line 78774: } 
line 78776: assert ( db -> init . busy == 0 || saveSqlFlag == 0 ) ; 
line 78777: if ( db -> init . busy == 0 ) { 
line 78778: Vdbe * pVdbe = pParse -> pVdbe ; 
line 78779: sqlite3VdbeSetSql ( pVdbe , zSql , ( int ) ( pParse -> zTail - zSql ) , saveSqlFlag ) ; 
line 78780: } 
line 78781: if ( pParse -> pVdbe && ( rc != SQLITE_OK || db -> mallocFailed ) ) { 
line 78782: sqlite3VdbeFinalize ( pParse -> pVdbe ) ; 
line 78783: assert ( ! ( * ppStmt ) ) ; 
line 78784: } else { 
line 78785: * ppStmt = ( sqlite3_stmt * ) pParse -> pVdbe ; 
line 78786: } 
line 78788: if ( zErrMsg ) { 
line 78789: sqlite3Error ( db , rc , "%s" , zErrMsg ) ; 
line 78790: sqlite3DbFree ( db , zErrMsg ) ; 
line 78791: } else { 
line 78792: sqlite3Error ( db , rc , 0 ) ; 
line 78793: } 
line 78796: while ( pParse -> pTriggerPrg ) { 
line 78797: TriggerPrg * pT = pParse -> pTriggerPrg ; 
line 78798: pParse -> pTriggerPrg = pT -> pNext ; 
line 78799: sqlite3VdbeProgramDelete ( db , pT -> pProgram , 0 ) ; 
line 78800: sqlite3DbFree ( db , pT ) ; 
line 78801: } 
line 78803: end_prepare : 
line 78805: sqlite3StackFree ( db , pParse ) ; 
line 78806: rc = sqlite3ApiExit ( db , rc ) ; 
line 78807: assert ( ( rc & db -> errMask ) == rc ) ; 
line 78808: return rc ; 
line 78809: } 
line 78810: static int sqlite3LockAndPrepare ( 
line 78811: sqlite3 * db , 
line 78812: const char * zSql , 
line 78813: int nBytes , 
line 78814: int saveSqlFlag , 
line 78815: Vdbe * pOld , 
line 78816: sqlite3_stmt * * ppStmt , 
line 78817: const char * * pzTail 
line 78818: ) { 
line 78819: int rc ; 
line 78820: assert ( ppStmt != 0 ) ; 
line 78821: * ppStmt = 0 ; 
line 78822: if ( ! sqlite3SafetyCheckOk ( db ) ) { 
line 78823: return SQLITE_MISUSE ; 
line 78824: } 
line 78825: sqlite3_mutex_enter ( db -> mutex ) ; 
line 78826: sqlite3BtreeEnterAll ( db ) ; 
line 78827: rc = sqlite3Prepare ( db , zSql , nBytes , saveSqlFlag , pOld , ppStmt , pzTail ) ; 
line 78828: if ( rc == SQLITE_SCHEMA ) { 
line 78829: sqlite3_finalize ( * ppStmt ) ; 
line 78830: rc = sqlite3Prepare ( db , zSql , nBytes , saveSqlFlag , pOld , ppStmt , pzTail ) ; 
line 78831: } 
line 78832: sqlite3BtreeLeaveAll ( db ) ; 
line 78833: sqlite3_mutex_leave ( db -> mutex ) ; 
line 78834: return rc ; 
line 78835: } 
line 78845: SQLITE_PRIVATE int sqlite3Reprepare ( Vdbe * p ) { 
line 78846: int rc ; 
line 78847: sqlite3_stmt * pNew ; 
line 78848: const char * zSql ; 
line 78849: sqlite3 * db ; 
line 78851: assert ( sqlite3_mutex_held ( sqlite3VdbeDb ( p ) -> mutex ) ) ; 
line 78852: zSql = sqlite3_sql ( ( sqlite3_stmt * ) p ) ; 
line 78853: assert ( zSql != 0 ) ; 
line 78854: db = sqlite3VdbeDb ( p ) ; 
line 78855: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 78856: rc = sqlite3LockAndPrepare ( db , zSql , - 1 , 0 , p , & pNew , 0 ) ; 
line 78857: if ( rc ) { 
line 78858: if ( rc == SQLITE_NOMEM ) { 
line 78859: db -> mallocFailed = 1 ; 
line 78860: } 
line 78861: assert ( pNew == 0 ) ; 
line 78862: return ( rc == SQLITE_LOCKED ) ? SQLITE_LOCKED : SQLITE_SCHEMA ; 
line 78863: } else { 
line 78864: assert ( pNew != 0 ) ; 
line 78865: } 
line 78866: sqlite3VdbeSwap ( ( Vdbe * ) pNew , p ) ; 
line 78867: sqlite3TransferBindings ( pNew , ( sqlite3_stmt * ) p ) ; 
line 78868: sqlite3VdbeResetStepResult ( ( Vdbe * ) pNew ) ; 
line 78869: sqlite3VdbeFinalize ( ( Vdbe * ) pNew ) ; 
line 78870: return SQLITE_OK ; 
line 78871: } 
line 78882: SQLITE_API int sqlite3_prepare ( 
line 78883: sqlite3 * db , 
line 78884: const char * zSql , 
line 78885: int nBytes , 
line 78886: sqlite3_stmt * * ppStmt , 
line 78887: const char * * pzTail 
line 78888: ) { 
line 78889: int rc ; 
line 78890: rc = sqlite3LockAndPrepare ( db , zSql , nBytes , 0 , 0 , ppStmt , pzTail ) ; 
line 78891: assert ( rc == SQLITE_OK || ppStmt == 0 || * ppStmt == 0 ) ; 
line 78892: return rc ; 
line 78893: } 
line 78894: SQLITE_API int sqlite3_prepare_v2 ( 
line 78895: sqlite3 * db , 
line 78896: const char * zSql , 
line 78897: int nBytes , 
line 78898: sqlite3_stmt * * ppStmt , 
line 78899: const char * * pzTail 
line 78900: ) { 
line 78901: int rc ; 
line 78902: rc = sqlite3LockAndPrepare ( db , zSql , nBytes , 1 , 0 , ppStmt , pzTail ) ; 
line 78903: assert ( rc == SQLITE_OK || ppStmt == 0 || * ppStmt == 0 ) ; 
line 78904: return rc ; 
line 78905: } 
line 78908: # ifndef SQLITE_OMIT_UTF16 
line 78912: static int sqlite3Prepare16 ( 
line 78913: sqlite3 * db , 
line 78914: const void * zSql , 
line 78915: int nBytes , 
line 78916: int saveSqlFlag , 
line 78917: sqlite3_stmt * * ppStmt , 
line 78918: const void * * pzTail 
line 78919: ) { 
line 78924: char * zSql8 ; 
line 78925: const char * zTail8 = 0 ; 
line 78926: int rc = SQLITE_OK ; 
line 78928: assert ( ppStmt ) ; 
line 78929: * ppStmt = 0 ; 
line 78930: if ( ! sqlite3SafetyCheckOk ( db ) ) { 
line 78931: return SQLITE_MISUSE ; 
line 78932: } 
line 78933: sqlite3_mutex_enter ( db -> mutex ) ; 
line 78934: zSql8 = sqlite3Utf16to8 ( db , zSql , nBytes ) ; 
line 78935: if ( zSql8 ) { 
line 78936: rc = sqlite3LockAndPrepare ( db , zSql8 , - 1 , saveSqlFlag , 0 , ppStmt , & zTail8 ) ; 
line 78937: } 
line 78939: if ( zTail8 && pzTail ) { 
line 78945: int chars_parsed = sqlite3Utf8CharLen ( zSql8 , ( int ) ( zTail8 - zSql8 ) ) ; 
line 78946: * pzTail = ( u8 * ) zSql + sqlite3Utf16ByteLen ( zSql , chars_parsed ) ; 
line 78947: } 
line 78948: sqlite3DbFree ( db , zSql8 ) ; 
line 78949: rc = sqlite3ApiExit ( db , rc ) ; 
line 78950: sqlite3_mutex_leave ( db -> mutex ) ; 
line 78951: return rc ; 
line 78952: } 
line 78962: SQLITE_API int sqlite3_prepare16 ( 
line 78963: sqlite3 * db , 
line 78964: const void * zSql , 
line 78965: int nBytes , 
line 78966: sqlite3_stmt * * ppStmt , 
line 78967: const void * * pzTail 
line 78968: ) { 
line 78969: int rc ; 
line 78970: rc = sqlite3Prepare16 ( db , zSql , nBytes , 0 , ppStmt , pzTail ) ; 
line 78971: assert ( rc == SQLITE_OK || ppStmt == 0 || * ppStmt == 0 ) ; 
line 78972: return rc ; 
line 78973: } 
line 78974: SQLITE_API int sqlite3_prepare16_v2 ( 
line 78975: sqlite3 * db , 
line 78976: const void * zSql , 
line 78977: int nBytes , 
line 78978: sqlite3_stmt * * ppStmt , 
line 78979: const void * * pzTail 
line 78980: ) { 
line 78981: int rc ; 
line 78982: rc = sqlite3Prepare16 ( db , zSql , nBytes , 1 , ppStmt , pzTail ) ; 
line 78983: assert ( rc == SQLITE_OK || ppStmt == 0 || * ppStmt == 0 ) ; 
line 78984: return rc ; 
line 78985: } 
line 78987: # endif 
line 79011: static void clearSelect ( sqlite3 * db , Select * p ) { 
line 79012: sqlite3ExprListDelete ( db , p -> pEList ) ; 
line 79013: sqlite3SrcListDelete ( db , p -> pSrc ) ; 
line 79014: sqlite3ExprDelete ( db , p -> pWhere ) ; 
line 79015: sqlite3ExprListDelete ( db , p -> pGroupBy ) ; 
line 79016: sqlite3ExprDelete ( db , p -> pHaving ) ; 
line 79017: sqlite3ExprListDelete ( db , p -> pOrderBy ) ; 
line 79018: sqlite3SelectDelete ( db , p -> pPrior ) ; 
line 79019: sqlite3ExprDelete ( db , p -> pLimit ) ; 
line 79020: sqlite3ExprDelete ( db , p -> pOffset ) ; 
line 79021: } 
line 79026: SQLITE_PRIVATE void sqlite3SelectDestInit ( SelectDest * pDest , int eDest , int iParm ) { 
line 79027: pDest -> eDest = ( u8 ) eDest ; 
line 79028: pDest -> iParm = iParm ; 
line 79029: pDest -> affinity = 0 ; 
line 79030: pDest -> iMem = 0 ; 
line 79031: pDest -> nMem = 0 ; 
line 79032: } 
line 79039: SQLITE_PRIVATE Select * sqlite3SelectNew ( 
line 79040: Parse * pParse , 
line 79041: ExprList * pEList , 
line 79042: SrcList * pSrc , 
line 79043: Expr * pWhere , 
line 79044: ExprList * pGroupBy , 
line 79045: Expr * pHaving , 
line 79046: ExprList * pOrderBy , 
line 79047: int isDistinct , 
line 79048: Expr * pLimit , 
line 79049: Expr * pOffset 
line 79050: ) { 
line 79051: Select * pNew ; 
line 79052: Select standin ; 
line 79053: sqlite3 * db = pParse -> db ; 
line 79054: pNew = sqlite3DbMallocZero ( db , sizeof ( * pNew ) ) ; 
line 79055: assert ( db -> mallocFailed || ! pOffset || pLimit ) ; 
line 79056: if ( pNew == 0 ) { 
line 79057: pNew = & standin ; 
line 79058: memset ( pNew , 0 , sizeof ( * pNew ) ) ; 
line 79059: } 
line 79060: if ( pEList == 0 ) { 
line 79061: pEList = sqlite3ExprListAppend ( pParse , 0 , sqlite3Expr ( db , TK_ALL , 0 ) ) ; 
line 79062: } 
line 79063: pNew -> pEList = pEList ; 
line 79064: pNew -> pSrc = pSrc ; 
line 79065: pNew -> pWhere = pWhere ; 
line 79066: pNew -> pGroupBy = pGroupBy ; 
line 79067: pNew -> pHaving = pHaving ; 
line 79068: pNew -> pOrderBy = pOrderBy ; 
line 79069: pNew -> selFlags = isDistinct ? SF_Distinct : 0 ; 
line 79070: pNew -> op = TK_SELECT ; 
line 79071: pNew -> pLimit = pLimit ; 
line 79072: pNew -> pOffset = pOffset ; 
line 79073: assert ( pOffset == 0 || pLimit != 0 ) ; 
line 79074: pNew -> addrOpenEphm [ 0 ] = - 1 ; 
line 79075: pNew -> addrOpenEphm [ 1 ] = - 1 ; 
line 79076: pNew -> addrOpenEphm [ 2 ] = - 1 ; 
line 79077: if ( db -> mallocFailed ) { 
line 79078: clearSelect ( db , pNew ) ; 
line 79079: if ( pNew != & standin ) sqlite3DbFree ( db , pNew ) ; 
line 79080: pNew = 0 ; 
line 79081: } 
line 79082: return pNew ; 
line 79083: } 
line 79088: SQLITE_PRIVATE void sqlite3SelectDelete ( sqlite3 * db , Select * p ) { 
line 79089: if ( p ) { 
line 79090: clearSelect ( db , p ) ; 
line 79091: sqlite3DbFree ( db , p ) ; 
line 79092: } 
line 79093: } 
line 79112: SQLITE_PRIVATE int sqlite3JoinType ( Parse * pParse , Token * pA , Token * pB , Token * pC ) { 
line 79113: int jointype = 0 ; 
line 79114: Token * apAll [ 3 ] ; 
line 79115: Token * p ; 
line 79117: static const char zKeyText [ ] = "naturaleftouterightfullinnercross" ; 
line 79118: static const struct { 
line 79119: u8 i ; 
line 79120: u8 nChar ; 
line 79121: u8 code ; 
line 79122: } aKeyword [ ] = { 
line 79123: { 0 , 7 , JT_NATURAL } , 
line 79124: { 6 , 4 , JT_LEFT | JT_OUTER } , 
line 79125: { 10 , 5 , JT_OUTER } , 
line 79126: { 14 , 5 , JT_RIGHT | JT_OUTER } , 
line 79127: { 19 , 4 , JT_LEFT | JT_RIGHT | JT_OUTER } , 
line 79128: { 23 , 5 , JT_INNER } , 
line 79129: { 28 , 5 , JT_INNER | JT_CROSS } , 
line 79130: } ; 
line 79131: int i , j ; 
line 79132: apAll [ 0 ] = pA ; 
line 79133: apAll [ 1 ] = pB ; 
line 79134: apAll [ 2 ] = pC ; 
line 79135: for ( i = 0 ; i < 3 && apAll [ i ] ; i ++ ) { 
line 79136: p = apAll [ i ] ; 
line 79137: for ( j = 0 ; j < ArraySize ( aKeyword ) ; j ++ ) { 
line 79138: if ( p -> n == aKeyword [ j ] . nChar 
line 79139: && sqlite3StrNICmp ( ( char * ) p -> z , & zKeyText [ aKeyword [ j ] . i ] , p -> n ) == 0 ) { 
line 79140: jointype |= aKeyword [ j ] . code ; 
line 79141: break ; 
line 79142: } 
line 79143: } 
line 79144: testcase ( j == 0 || j == 1 || j == 2 || j == 3 || j == 4 || j == 5 || j == 6 ) ; 
line 79145: if ( j >= ArraySize ( aKeyword ) ) { 
line 79146: jointype |= JT_ERROR ; 
line 79147: break ; 
line 79148: } 
line 79149: } 
line 79150: if ( 
line 79151: ( jointype & ( JT_INNER | JT_OUTER ) ) == ( JT_INNER | JT_OUTER ) || 
line 79152: ( jointype & JT_ERROR ) != 0 
line 79153: ) { 
line 79154: const char * zSp = " " ; 
line 79155: assert ( pB != 0 ) ; 
line 79156: if ( pC == 0 ) { zSp ++ ; } 
line 79157: sqlite3ErrorMsg ( pParse , "unknown or unsupported join type: " 
line 79158: "%T %T%s%T" , pA , pB , zSp , pC ) ; 
line 79159: jointype = JT_INNER ; 
line 79160: } else if ( ( jointype & JT_OUTER ) != 0 
line 79161: && ( jointype & ( JT_LEFT | JT_RIGHT ) ) != JT_LEFT ) { 
line 79162: sqlite3ErrorMsg ( pParse , 
line 79163: "RIGHT and FULL OUTER JOINs are not currently supported" ) ; 
line 79164: jointype = JT_INNER ; 
line 79165: } 
line 79166: return jointype ; 
line 79167: } 
line 79173: static int columnIndex ( Table * pTab , const char * zCol ) { 
line 79174: int i ; 
line 79175: for ( i = 0 ; i < pTab -> nCol ; i ++ ) { 
line 79176: if ( sqlite3StrICmp ( pTab -> aCol [ i ] . zName , zCol ) == 0 ) return i ; 
line 79177: } 
line 79178: return - 1 ; 
line 79179: } 
line 79190: static int tableAndColumnIndex ( 
line 79191: SrcList * pSrc , 
line 79192: int N , 
line 79193: const char * zCol , 
line 79194: int * piTab , 
line 79195: int * piCol 
line 79196: ) { 
line 79197: int i ; 
line 79198: int iCol ; 
line 79200: assert ( ( piTab == 0 ) == ( piCol == 0 ) ) ; 
line 79201: for ( i = 0 ; i < N ; i ++ ) { 
line 79202: iCol = columnIndex ( pSrc -> a [ i ] . pTab , zCol ) ; 
line 79203: if ( iCol >= 0 ) { 
line 79204: if ( piTab ) { 
line 79205: * piTab = i ; 
line 79206: * piCol = iCol ; 
line 79207: } 
line 79208: return 1 ; 
line 79209: } 
line 79210: } 
line 79211: return 0 ; 
line 79212: } 
line 79225: static void addWhereTerm ( 
line 79226: Parse * pParse , 
line 79227: SrcList * pSrc , 
line 79228: int iLeft , 
line 79229: int iColLeft , 
line 79230: int iRight , 
line 79231: int iColRight , 
line 79232: int isOuterJoin , 
line 79233: Expr * * ppWhere 
line 79234: ) { 
line 79235: sqlite3 * db = pParse -> db ; 
line 79236: Expr * pE1 ; 
line 79237: Expr * pE2 ; 
line 79238: Expr * pEq ; 
line 79240: assert ( iLeft < iRight ) ; 
line 79241: assert ( pSrc -> nSrc > iRight ) ; 
line 79242: assert ( pSrc -> a [ iLeft ] . pTab ) ; 
line 79243: assert ( pSrc -> a [ iRight ] . pTab ) ; 
line 79245: pE1 = sqlite3CreateColumnExpr ( db , pSrc , iLeft , iColLeft ) ; 
line 79246: pE2 = sqlite3CreateColumnExpr ( db , pSrc , iRight , iColRight ) ; 
line 79248: pEq = sqlite3PExpr ( pParse , TK_EQ , pE1 , pE2 , 0 ) ; 
line 79249: if ( pEq && isOuterJoin ) { 
line 79250: ExprSetProperty ( pEq , EP_FromJoin ) ; 
line 79251: assert ( ! ExprHasAnyProperty ( pEq , EP_TokenOnly | EP_Reduced ) ) ; 
line 79252: ExprSetIrreducible ( pEq ) ; 
line 79253: pEq -> iRightJoinTable = ( i16 ) pE2 -> iTable ; 
line 79254: } 
line 79255: * ppWhere = sqlite3ExprAnd ( db , * ppWhere , pEq ) ; 
line 79256: } 
line 79284: static void setJoinExpr ( Expr * p , int iTable ) { 
line 79285: while ( p ) { 
line 79286: ExprSetProperty ( p , EP_FromJoin ) ; 
line 79287: assert ( ! ExprHasAnyProperty ( p , EP_TokenOnly | EP_Reduced ) ) ; 
line 79288: ExprSetIrreducible ( p ) ; 
line 79289: p -> iRightJoinTable = ( i16 ) iTable ; 
line 79290: setJoinExpr ( p -> pLeft , iTable ) ; 
line 79291: p = p -> pRight ; 
line 79292: } 
line 79293: } 
line 79309: static int sqliteProcessJoin ( Parse * pParse , Select * p ) { 
line 79310: SrcList * pSrc ; 
line 79311: int i , j ; 
line 79312: struct SrcList_item * pLeft ; 
line 79313: struct SrcList_item * pRight ; 
line 79315: pSrc = p -> pSrc ; 
line 79316: pLeft = & pSrc -> a [ 0 ] ; 
line 79317: pRight = & pLeft [ 1 ] ; 
line 79318: for ( i = 0 ; i < pSrc -> nSrc - 1 ; i ++ , pRight ++ , pLeft ++ ) { 
line 79319: Table * pLeftTab = pLeft -> pTab ; 
line 79320: Table * pRightTab = pRight -> pTab ; 
line 79321: int isOuter ; 
line 79323: if ( NEVER ( pLeftTab == 0 || pRightTab == 0 ) ) continue ; 
line 79324: isOuter = ( pRight -> jointype & JT_OUTER ) != 0 ; 
line 79329: if ( pRight -> jointype & JT_NATURAL ) { 
line 79330: if ( pRight -> pOn || pRight -> pUsing ) { 
line 79331: sqlite3ErrorMsg ( pParse , "a NATURAL join may not have " 
line 79332: "an ON or USING clause" , 0 ) ; 
line 79333: return 1 ; 
line 79334: } 
line 79335: for ( j = 0 ; j < pRightTab -> nCol ; j ++ ) { 
line 79336: char * zName ; 
line 79337: int iLeft ; 
line 79338: int iLeftCol ; 
line 79340: zName = pRightTab -> aCol [ j ] . zName ; 
line 79341: if ( tableAndColumnIndex ( pSrc , i + 1 , zName , & iLeft , & iLeftCol ) ) { 
line 79342: addWhereTerm ( pParse , pSrc , iLeft , iLeftCol , i + 1 , j , 
line 79343: isOuter , & p -> pWhere ) ; 
line 79344: } 
line 79345: } 
line 79346: } 
line 79350: if ( pRight -> pOn && pRight -> pUsing ) { 
line 79351: sqlite3ErrorMsg ( pParse , "cannot have both ON and USING " 
line 79352: "clauses in the same join" ) ; 
line 79353: return 1 ; 
line 79354: } 
line 79359: if ( pRight -> pOn ) { 
line 79360: if ( isOuter ) setJoinExpr ( pRight -> pOn , pRight -> iCursor ) ; 
line 79361: p -> pWhere = sqlite3ExprAnd ( pParse -> db , p -> pWhere , pRight -> pOn ) ; 
line 79362: pRight -> pOn = 0 ; 
line 79363: } 
line 79372: if ( pRight -> pUsing ) { 
line 79373: IdList * pList = pRight -> pUsing ; 
line 79374: for ( j = 0 ; j < pList -> nId ; j ++ ) { 
line 79375: char * zName ; 
line 79376: int iLeft ; 
line 79377: int iLeftCol ; 
line 79378: int iRightCol ; 
line 79380: zName = pList -> a [ j ] . zName ; 
line 79381: iRightCol = columnIndex ( pRightTab , zName ) ; 
line 79382: if ( iRightCol < 0 
line 79383: || ! tableAndColumnIndex ( pSrc , i + 1 , zName , & iLeft , & iLeftCol ) 
line 79384: ) { 
line 79385: sqlite3ErrorMsg ( pParse , "cannot join using column %s - column " 
line 79386: "not present in both tables" , zName ) ; 
line 79387: return 1 ; 
line 79388: } 
line 79389: addWhereTerm ( pParse , pSrc , iLeft , iLeftCol , i + 1 , iRightCol , 
line 79390: isOuter , & p -> pWhere ) ; 
line 79391: } 
line 79392: } 
line 79393: } 
line 79394: return 0 ; 
line 79395: } 
line 79401: static void pushOntoSorter ( 
line 79402: Parse * pParse , 
line 79403: ExprList * pOrderBy , 
line 79404: Select * pSelect , 
line 79405: int regData 
line 79406: ) { 
line 79407: Vdbe * v = pParse -> pVdbe ; 
line 79408: int nExpr = pOrderBy -> nExpr ; 
line 79409: int regBase = sqlite3GetTempRange ( pParse , nExpr + 2 ) ; 
line 79410: int regRecord = sqlite3GetTempReg ( pParse ) ; 
line 79411: sqlite3ExprCacheClear ( pParse ) ; 
line 79412: sqlite3ExprCodeExprList ( pParse , pOrderBy , regBase , 0 ) ; 
line 79413: sqlite3VdbeAddOp2 ( v , OP_Sequence , pOrderBy -> iECursor , regBase + nExpr ) ; 
line 79414: sqlite3ExprCodeMove ( pParse , regData , regBase + nExpr + 1 , 1 ) ; 
line 79415: sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nExpr + 2 , regRecord ) ; 
line 79416: sqlite3VdbeAddOp2 ( v , OP_IdxInsert , pOrderBy -> iECursor , regRecord ) ; 
line 79417: sqlite3ReleaseTempReg ( pParse , regRecord ) ; 
line 79418: sqlite3ReleaseTempRange ( pParse , regBase , nExpr + 2 ) ; 
line 79419: if ( pSelect -> iLimit ) { 
line 79420: int addr1 , addr2 ; 
line 79421: int iLimit ; 
line 79422: if ( pSelect -> iOffset ) { 
line 79423: iLimit = pSelect -> iOffset + 1 ; 
line 79424: } else { 
line 79425: iLimit = pSelect -> iLimit ; 
line 79426: } 
line 79427: addr1 = sqlite3VdbeAddOp1 ( v , OP_IfZero , iLimit ) ; 
line 79428: sqlite3VdbeAddOp2 ( v , OP_AddImm , iLimit , - 1 ) ; 
line 79429: addr2 = sqlite3VdbeAddOp0 ( v , OP_Goto ) ; 
line 79430: sqlite3VdbeJumpHere ( v , addr1 ) ; 
line 79431: sqlite3VdbeAddOp1 ( v , OP_Last , pOrderBy -> iECursor ) ; 
line 79432: sqlite3VdbeAddOp1 ( v , OP_Delete , pOrderBy -> iECursor ) ; 
line 79433: sqlite3VdbeJumpHere ( v , addr2 ) ; 
line 79434: pSelect -> iLimit = 0 ; 
line 79435: } 
line 79436: } 
line 79441: static void codeOffset ( 
line 79442: Vdbe * v , 
line 79443: Select * p , 
line 79444: int iContinue 
line 79445: ) { 
line 79446: if ( p -> iOffset && iContinue != 0 ) { 
line 79447: int addr ; 
line 79448: sqlite3VdbeAddOp2 ( v , OP_AddImm , p -> iOffset , - 1 ) ; 
line 79449: addr = sqlite3VdbeAddOp1 ( v , OP_IfNeg , p -> iOffset ) ; 
line 79450: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iContinue ) ; 
line 79451: VdbeComment ( ( v , "skip OFFSET records" ) ) ; 
line 79452: sqlite3VdbeJumpHere ( v , addr ) ; 
line 79453: } 
line 79454: } 
line 79465: static void codeDistinct ( 
line 79466: Parse * pParse , 
line 79467: int iTab , 
line 79468: int addrRepeat , 
line 79469: int N , 
line 79470: int iMem 
line 79471: ) { 
line 79472: Vdbe * v ; 
line 79473: int r1 ; 
line 79475: v = pParse -> pVdbe ; 
line 79476: r1 = sqlite3GetTempReg ( pParse ) ; 
line 79477: sqlite3VdbeAddOp4Int ( v , OP_Found , iTab , addrRepeat , iMem , N ) ; 
line 79478: sqlite3VdbeAddOp3 ( v , OP_MakeRecord , iMem , N , r1 ) ; 
line 79479: sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iTab , r1 ) ; 
line 79480: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 79481: } 
line 79489: static int checkForMultiColumnSelectError ( 
line 79490: Parse * pParse , 
line 79491: SelectDest * pDest , 
line 79492: int nExpr 
line 79493: ) { 
line 79494: int eDest = pDest -> eDest ; 
line 79495: if ( nExpr > 1 && ( eDest == SRT_Mem || eDest == SRT_Set ) ) { 
line 79496: sqlite3ErrorMsg ( pParse , "only a single result allowed for " 
line 79497: "a SELECT that is part of an expression" ) ; 
line 79498: return 1 ; 
line 79499: } else { 
line 79500: return 0 ; 
line 79501: } 
line 79502: } 
line 79513: static void selectInnerLoop ( 
line 79514: Parse * pParse , 
line 79515: Select * p , 
line 79516: ExprList * pEList , 
line 79517: int srcTab , 
line 79518: int nColumn , 
line 79519: ExprList * pOrderBy , 
line 79520: int distinct , 
line 79521: SelectDest * pDest , 
line 79522: int iContinue , 
line 79523: int iBreak 
line 79524: ) { 
line 79525: Vdbe * v = pParse -> pVdbe ; 
line 79526: int i ; 
line 79527: int hasDistinct ; 
line 79528: int regResult ; 
line 79529: int eDest = pDest -> eDest ; 
line 79530: int iParm = pDest -> iParm ; 
line 79531: int nResultCol ; 
line 79533: assert ( v ) ; 
line 79534: if ( NEVER ( v == 0 ) ) return ; 
line 79535: assert ( pEList != 0 ) ; 
line 79536: hasDistinct = distinct >= 0 ; 
line 79537: if ( pOrderBy == 0 && ! hasDistinct ) { 
line 79538: codeOffset ( v , p , iContinue ) ; 
line 79539: } 
line 79543: if ( nColumn > 0 ) { 
line 79544: nResultCol = nColumn ; 
line 79545: } else { 
line 79546: nResultCol = pEList -> nExpr ; 
line 79547: } 
line 79548: if ( pDest -> iMem == 0 ) { 
line 79549: pDest -> iMem = pParse -> nMem + 1 ; 
line 79550: pDest -> nMem = nResultCol ; 
line 79551: pParse -> nMem += nResultCol ; 
line 79552: } else { 
line 79553: assert ( pDest -> nMem == nResultCol ) ; 
line 79554: } 
line 79555: regResult = pDest -> iMem ; 
line 79556: if ( nColumn > 0 ) { 
line 79557: for ( i = 0 ; i < nColumn ; i ++ ) { 
line 79558: sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ) ; 
line 79559: } 
line 79560: } else if ( eDest != SRT_Exists ) { 
line 79564: sqlite3ExprCacheClear ( pParse ) ; 
line 79565: sqlite3ExprCodeExprList ( pParse , pEList , regResult , eDest == SRT_Output ) ; 
line 79566: } 
line 79567: nColumn = nResultCol ; 
line 79573: if ( hasDistinct ) { 
line 79574: assert ( pEList != 0 ) ; 
line 79575: assert ( pEList -> nExpr == nColumn ) ; 
line 79576: codeDistinct ( pParse , distinct , iContinue , nColumn , regResult ) ; 
line 79577: if ( pOrderBy == 0 ) { 
line 79578: codeOffset ( v , p , iContinue ) ; 
line 79579: } 
line 79580: } 
line 79582: if ( checkForMultiColumnSelectError ( pParse , pDest , pEList -> nExpr ) ) { 
line 79583: return ; 
line 79584: } 
line 79586: switch ( eDest ) { 
line 79590: # ifndef SQLITE_OMIT_COMPOUND_SELECT 
line 79591: case SRT_Union : { 
line 79592: int r1 ; 
line 79593: r1 = sqlite3GetTempReg ( pParse ) ; 
line 79594: sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nColumn , r1 ) ; 
line 79595: sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm , r1 ) ; 
line 79596: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 79597: break ; 
line 79598: } 
line 79604: case SRT_Except : { 
line 79605: sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nColumn ) ; 
line 79606: break ; 
line 79607: } 
line 79608: # endif 
line 79612: case SRT_Table : 
line 79613: case SRT_EphemTab : { 
line 79614: int r1 = sqlite3GetTempReg ( pParse ) ; 
line 79615: testcase ( eDest == SRT_Table ) ; 
line 79616: testcase ( eDest == SRT_EphemTab ) ; 
line 79617: sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nColumn , r1 ) ; 
line 79618: if ( pOrderBy ) { 
line 79619: pushOntoSorter ( pParse , pOrderBy , p , r1 ) ; 
line 79620: } else { 
line 79621: int r2 = sqlite3GetTempReg ( pParse ) ; 
line 79622: sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ) ; 
line 79623: sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ) ; 
line 79624: sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ) ; 
line 79625: sqlite3ReleaseTempReg ( pParse , r2 ) ; 
line 79626: } 
line 79627: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 79628: break ; 
line 79629: } 
line 79631: # ifndef SQLITE_OMIT_SUBQUERY 
line 79636: case SRT_Set : { 
line 79637: assert ( nColumn == 1 ) ; 
line 79638: p -> affinity = sqlite3CompareAffinity ( pEList -> a [ 0 ] . pExpr , pDest -> affinity ) ; 
line 79639: if ( pOrderBy ) { 
line 79644: pushOntoSorter ( pParse , pOrderBy , p , regResult ) ; 
line 79645: } else { 
line 79646: int r1 = sqlite3GetTempReg ( pParse ) ; 
line 79647: sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , 1 , r1 , & p -> affinity , 1 ) ; 
line 79648: sqlite3ExprCacheAffinityChange ( pParse , regResult , 1 ) ; 
line 79649: sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm , r1 ) ; 
line 79650: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 79651: } 
line 79652: break ; 
line 79653: } 
line 79657: case SRT_Exists : { 
line 79658: sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ) ; 
line 79660: break ; 
line 79661: } 
line 79667: case SRT_Mem : { 
line 79668: assert ( nColumn == 1 ) ; 
line 79669: if ( pOrderBy ) { 
line 79670: pushOntoSorter ( pParse , pOrderBy , p , regResult ) ; 
line 79671: } else { 
line 79672: sqlite3ExprCodeMove ( pParse , regResult , iParm , 1 ) ; 
line 79674: } 
line 79675: break ; 
line 79676: } 
line 79677: # endif 
line 79683: case SRT_Coroutine : 
line 79684: case SRT_Output : { 
line 79685: testcase ( eDest == SRT_Coroutine ) ; 
line 79686: testcase ( eDest == SRT_Output ) ; 
line 79687: if ( pOrderBy ) { 
line 79688: int r1 = sqlite3GetTempReg ( pParse ) ; 
line 79689: sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nColumn , r1 ) ; 
line 79690: pushOntoSorter ( pParse , pOrderBy , p , r1 ) ; 
line 79691: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 79692: } else if ( eDest == SRT_Coroutine ) { 
line 79693: sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iParm ) ; 
line 79694: } else { 
line 79695: sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nColumn ) ; 
line 79696: sqlite3ExprCacheAffinityChange ( pParse , regResult , nColumn ) ; 
line 79697: } 
line 79698: break ; 
line 79699: } 
line 79701: # if ! defined ( SQLITE_OMIT_TRIGGER ) 
line 79707: default : { 
line 79708: assert ( eDest == SRT_Discard ) ; 
line 79709: break ; 
line 79710: } 
line 79711: # endif 
line 79712: } 
line 79716: if ( p -> iLimit ) { 
line 79717: assert ( pOrderBy == 0 ) ; 
line 79719: sqlite3VdbeAddOp3 ( v , OP_IfZero , p -> iLimit , iBreak , - 1 ) ; 
line 79720: } 
line 79721: } 
line 79738: static KeyInfo * keyInfoFromExprList ( Parse * pParse , ExprList * pList ) { 
line 79739: sqlite3 * db = pParse -> db ; 
line 79740: int nExpr ; 
line 79741: KeyInfo * pInfo ; 
line 79742: struct ExprList_item * pItem ; 
line 79743: int i ; 
line 79745: nExpr = pList -> nExpr ; 
line 79746: pInfo = sqlite3DbMallocZero ( db , sizeof ( * pInfo ) + nExpr * ( sizeof ( CollSeq * ) + 1 ) ) ; 
line 79747: if ( pInfo ) { 
line 79748: pInfo -> aSortOrder = ( u8 * ) & pInfo -> aColl [ nExpr ] ; 
line 79749: pInfo -> nField = ( u16 ) nExpr ; 
line 79750: pInfo -> enc = ENC ( db ) ; 
line 79751: pInfo -> db = db ; 
line 79752: for ( i = 0 , pItem = pList -> a ; i < nExpr ; i ++ , pItem ++ ) { 
line 79753: CollSeq * pColl ; 
line 79754: pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ) ; 
line 79755: if ( ! pColl ) { 
line 79756: pColl = db -> pDfltColl ; 
line 79757: } 
line 79758: pInfo -> aColl [ i ] = pColl ; 
line 79759: pInfo -> aSortOrder [ i ] = pItem -> sortOrder ; 
line 79760: } 
line 79761: } 
line 79762: return pInfo ; 
line 79763: } 
line 79772: static void generateSortTail ( 
line 79773: Parse * pParse , 
line 79774: Select * p , 
line 79775: Vdbe * v , 
line 79776: int nColumn , 
line 79777: SelectDest * pDest 
line 79778: ) { 
line 79779: int addrBreak = sqlite3VdbeMakeLabel ( v ) ; 
line 79780: int addrContinue = sqlite3VdbeMakeLabel ( v ) ; 
line 79781: int addr ; 
line 79782: int iTab ; 
line 79783: int pseudoTab = 0 ; 
line 79784: ExprList * pOrderBy = p -> pOrderBy ; 
line 79786: int eDest = pDest -> eDest ; 
line 79787: int iParm = pDest -> iParm ; 
line 79789: int regRow ; 
line 79790: int regRowid ; 
line 79792: iTab = pOrderBy -> iECursor ; 
line 79793: regRow = sqlite3GetTempReg ( pParse ) ; 
line 79794: if ( eDest == SRT_Output || eDest == SRT_Coroutine ) { 
line 79795: pseudoTab = pParse -> nTab ++ ; 
line 79796: sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , pseudoTab , regRow , nColumn ) ; 
line 79797: regRowid = 0 ; 
line 79798: } else { 
line 79799: regRowid = sqlite3GetTempReg ( pParse ) ; 
line 79800: } 
line 79801: addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ) ; 
line 79802: codeOffset ( v , p , addrContinue ) ; 
line 79803: sqlite3VdbeAddOp3 ( v , OP_Column , iTab , pOrderBy -> nExpr + 1 , regRow ) ; 
line 79804: switch ( eDest ) { 
line 79805: case SRT_Table : 
line 79806: case SRT_EphemTab : { 
line 79807: testcase ( eDest == SRT_Table ) ; 
line 79808: testcase ( eDest == SRT_EphemTab ) ; 
line 79809: sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ) ; 
line 79810: sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ) ; 
line 79811: sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ) ; 
line 79812: break ; 
line 79813: } 
line 79814: # ifndef SQLITE_OMIT_SUBQUERY 
line 79815: case SRT_Set : { 
line 79816: assert ( nColumn == 1 ) ; 
line 79817: sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , 1 , regRowid , & p -> affinity , 1 ) ; 
line 79818: sqlite3ExprCacheAffinityChange ( pParse , regRow , 1 ) ; 
line 79819: sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm , regRowid ) ; 
line 79820: break ; 
line 79821: } 
line 79822: case SRT_Mem : { 
line 79823: assert ( nColumn == 1 ) ; 
line 79824: sqlite3ExprCodeMove ( pParse , regRow , iParm , 1 ) ; 
line 79826: break ; 
line 79827: } 
line 79828: # endif 
line 79829: default : { 
line 79830: int i ; 
line 79831: assert ( eDest == SRT_Output || eDest == SRT_Coroutine ) ; 
line 79832: testcase ( eDest == SRT_Output ) ; 
line 79833: testcase ( eDest == SRT_Coroutine ) ; 
line 79834: for ( i = 0 ; i < nColumn ; i ++ ) { 
line 79835: assert ( regRow != pDest -> iMem + i ) ; 
line 79836: sqlite3VdbeAddOp3 ( v , OP_Column , pseudoTab , i , pDest -> iMem + i ) ; 
line 79837: if ( i == 0 ) { 
line 79838: sqlite3VdbeChangeP5 ( v , OPFLAG_CLEARCACHE ) ; 
line 79839: } 
line 79840: } 
line 79841: if ( eDest == SRT_Output ) { 
line 79842: sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iMem , nColumn ) ; 
line 79843: sqlite3ExprCacheAffinityChange ( pParse , pDest -> iMem , nColumn ) ; 
line 79844: } else { 
line 79845: sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iParm ) ; 
line 79846: } 
line 79847: break ; 
line 79848: } 
line 79849: } 
line 79850: sqlite3ReleaseTempReg ( pParse , regRow ) ; 
line 79851: sqlite3ReleaseTempReg ( pParse , regRowid ) ; 
line 79855: assert ( p -> iLimit == 0 ) ; 
line 79859: sqlite3VdbeResolveLabel ( v , addrContinue ) ; 
line 79860: sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ) ; 
line 79861: sqlite3VdbeResolveLabel ( v , addrBreak ) ; 
line 79862: if ( eDest == SRT_Output || eDest == SRT_Coroutine ) { 
line 79863: sqlite3VdbeAddOp2 ( v , OP_Close , pseudoTab , 0 ) ; 
line 79864: } 
line 79865: } 
line 79885: static const char * columnType ( 
line 79886: NameContext * pNC , 
line 79887: Expr * pExpr , 
line 79888: const char * * pzOriginDb , 
line 79889: const char * * pzOriginTab , 
line 79890: const char * * pzOriginCol 
line 79891: ) { 
line 79892: char const * zType = 0 ; 
line 79893: char const * zOriginDb = 0 ; 
line 79894: char const * zOriginTab = 0 ; 
line 79895: char const * zOriginCol = 0 ; 
line 79896: int j ; 
line 79897: if ( NEVER ( pExpr == 0 ) || pNC -> pSrcList == 0 ) return 0 ; 
line 79899: switch ( pExpr -> op ) { 
line 79900: case TK_AGG_COLUMN : 
line 79901: case TK_COLUMN : { 
line 79906: Table * pTab = 0 ; 
line 79907: Select * pS = 0 ; 
line 79908: int iCol = pExpr -> iColumn ; 
line 79909: testcase ( pExpr -> op == TK_AGG_COLUMN ) ; 
line 79910: testcase ( pExpr -> op == TK_COLUMN ) ; 
line 79911: while ( pNC && ! pTab ) { 
line 79912: SrcList * pTabList = pNC -> pSrcList ; 
line 79913: for ( j = 0 ; j < pTabList -> nSrc && pTabList -> a [ j ] . iCursor != pExpr -> iTable ; j ++ ) ; 
line 79914: if ( j < pTabList -> nSrc ) { 
line 79915: pTab = pTabList -> a [ j ] . pTab ; 
line 79916: pS = pTabList -> a [ j ] . pSelect ; 
line 79917: } else { 
line 79918: pNC = pNC -> pNext ; 
line 79919: } 
line 79920: } 
line 79922: if ( pTab == 0 ) { 
line 79940: break ; 
line 79941: } 
line 79943: assert ( pTab && pExpr -> pTab == pTab ) ; 
line 79944: if ( pS ) { 
line 79949: if ( iCol >= 0 && ALWAYS ( iCol < pS -> pEList -> nExpr ) ) { 
line 79954: NameContext sNC ; 
line 79955: Expr * p = pS -> pEList -> a [ iCol ] . pExpr ; 
line 79956: sNC . pSrcList = pS -> pSrc ; 
line 79957: sNC . pNext = pNC ; 
line 79958: sNC . pParse = pNC -> pParse ; 
line 79959: zType = columnType ( & sNC , p , & zOriginDb , & zOriginTab , & zOriginCol ) ; 
line 79960: } 
line 79961: } else if ( ALWAYS ( pTab -> pSchema ) ) { 
line 79963: assert ( ! pS ) ; 
line 79964: if ( iCol < 0 ) iCol = pTab -> iPKey ; 
line 79965: assert ( iCol == - 1 || ( iCol >= 0 && iCol < pTab -> nCol ) ) ; 
line 79966: if ( iCol < 0 ) { 
line 79967: zType = "INTEGER" ; 
line 79968: zOriginCol = "rowid" ; 
line 79969: } else { 
line 79970: zType = pTab -> aCol [ iCol ] . zType ; 
line 79971: zOriginCol = pTab -> aCol [ iCol ] . zName ; 
line 79972: } 
line 79973: zOriginTab = pTab -> zName ; 
line 79974: if ( pNC -> pParse ) { 
line 79975: int iDb = sqlite3SchemaToIndex ( pNC -> pParse -> db , pTab -> pSchema ) ; 
line 79976: zOriginDb = pNC -> pParse -> db -> aDb [ iDb ] . zName ; 
line 79977: } 
line 79978: } 
line 79979: break ; 
line 79980: } 
line 79981: # ifndef SQLITE_OMIT_SUBQUERY 
line 79982: case TK_SELECT : { 
line 79987: NameContext sNC ; 
line 79988: Select * pS = pExpr -> x . pSelect ; 
line 79989: Expr * p = pS -> pEList -> a [ 0 ] . pExpr ; 
line 79990: assert ( ExprHasProperty ( pExpr , EP_xIsSelect ) ) ; 
line 79991: sNC . pSrcList = pS -> pSrc ; 
line 79992: sNC . pNext = pNC ; 
line 79993: sNC . pParse = pNC -> pParse ; 
line 79994: zType = columnType ( & sNC , p , & zOriginDb , & zOriginTab , & zOriginCol ) ; 
line 79995: break ; 
line 79996: } 
line 79997: # endif 
line 79998: } 
line 80000: if ( pzOriginDb ) { 
line 80001: assert ( pzOriginTab && pzOriginCol ) ; 
line 80002: * pzOriginDb = zOriginDb ; 
line 80003: * pzOriginTab = zOriginTab ; 
line 80004: * pzOriginCol = zOriginCol ; 
line 80005: } 
line 80006: return zType ; 
line 80007: } 
line 80013: static void generateColumnTypes ( 
line 80014: Parse * pParse , 
line 80015: SrcList * pTabList , 
line 80016: ExprList * pEList 
line 80017: ) { 
line 80018: # ifndef SQLITE_OMIT_DECLTYPE 
line 80019: Vdbe * v = pParse -> pVdbe ; 
line 80020: int i ; 
line 80021: NameContext sNC ; 
line 80022: sNC . pSrcList = pTabList ; 
line 80023: sNC . pParse = pParse ; 
line 80024: for ( i = 0 ; i < pEList -> nExpr ; i ++ ) { 
line 80025: Expr * p = pEList -> a [ i ] . pExpr ; 
line 80026: const char * zType ; 
line 80027: # ifdef SQLITE_ENABLE_COLUMN_METADATA 
line 80028: const char * zOrigDb = 0 ; 
line 80029: const char * zOrigTab = 0 ; 
line 80030: const char * zOrigCol = 0 ; 
line 80031: zType = columnType ( & sNC , p , & zOrigDb , & zOrigTab , & zOrigCol ) ; 
line 80037: sqlite3VdbeSetColName ( v , i , COLNAME_DATABASE , zOrigDb , SQLITE_TRANSIENT ) ; 
line 80038: sqlite3VdbeSetColName ( v , i , COLNAME_TABLE , zOrigTab , SQLITE_TRANSIENT ) ; 
line 80039: sqlite3VdbeSetColName ( v , i , COLNAME_COLUMN , zOrigCol , SQLITE_TRANSIENT ) ; 
line 80040: # else 
line 80041: zType = columnType ( & sNC , p , 0 , 0 , 0 ) ; 
line 80042: # endif 
line 80043: sqlite3VdbeSetColName ( v , i , COLNAME_DECLTYPE , zType , SQLITE_TRANSIENT ) ; 
line 80044: } 
line 80045: # endif 
line 80046: } 
line 80053: static void generateColumnNames ( 
line 80054: Parse * pParse , 
line 80055: SrcList * pTabList , 
line 80056: ExprList * pEList 
line 80057: ) { 
line 80058: Vdbe * v = pParse -> pVdbe ; 
line 80059: int i , j ; 
line 80060: sqlite3 * db = pParse -> db ; 
line 80061: int fullNames , shortNames ; 
line 80063: # ifndef SQLITE_OMIT_EXPLAIN 
line 80065: if ( pParse -> explain ) { 
line 80066: return ; 
line 80067: } 
line 80068: # endif 
line 80070: if ( pParse -> colNamesSet || NEVER ( v == 0 ) || db -> mallocFailed ) return ; 
line 80071: pParse -> colNamesSet = 1 ; 
line 80072: fullNames = ( db -> flags & SQLITE_FullColNames ) != 0 ; 
line 80073: shortNames = ( db -> flags & SQLITE_ShortColNames ) != 0 ; 
line 80074: sqlite3VdbeSetNumCols ( v , pEList -> nExpr ) ; 
line 80075: for ( i = 0 ; i < pEList -> nExpr ; i ++ ) { 
line 80076: Expr * p ; 
line 80077: p = pEList -> a [ i ] . pExpr ; 
line 80078: if ( NEVER ( p == 0 ) ) continue ; 
line 80079: if ( pEList -> a [ i ] . zName ) { 
line 80080: char * zName = pEList -> a [ i ] . zName ; 
line 80081: sqlite3VdbeSetColName ( v , i , COLNAME_NAME , zName , SQLITE_TRANSIENT ) ; 
line 80082: } else if ( ( p -> op == TK_COLUMN || p -> op == TK_AGG_COLUMN ) && pTabList ) { 
line 80083: Table * pTab ; 
line 80084: char * zCol ; 
line 80085: int iCol = p -> iColumn ; 
line 80086: for ( j = 0 ; ALWAYS ( j < pTabList -> nSrc ) ; j ++ ) { 
line 80087: if ( pTabList -> a [ j ] . iCursor == p -> iTable ) break ; 
line 80088: } 
line 80089: assert ( j < pTabList -> nSrc ) ; 
line 80090: pTab = pTabList -> a [ j ] . pTab ; 
line 80091: if ( iCol < 0 ) iCol = pTab -> iPKey ; 
line 80092: assert ( iCol == - 1 || ( iCol >= 0 && iCol < pTab -> nCol ) ) ; 
line 80093: if ( iCol < 0 ) { 
line 80094: zCol = "rowid" ; 
line 80095: } else { 
line 80096: zCol = pTab -> aCol [ iCol ] . zName ; 
line 80097: } 
line 80098: if ( ! shortNames && ! fullNames ) { 
line 80099: sqlite3VdbeSetColName ( v , i , COLNAME_NAME , 
line 80100: sqlite3DbStrDup ( db , pEList -> a [ i ] . zSpan ) , SQLITE_DYNAMIC ) ; 
line 80101: } else if ( fullNames ) { 
line 80102: char * zName = 0 ; 
line 80103: zName = sqlite3MPrintf ( db , "%s.%s" , pTab -> zName , zCol ) ; 
line 80104: sqlite3VdbeSetColName ( v , i , COLNAME_NAME , zName , SQLITE_DYNAMIC ) ; 
line 80105: } else { 
line 80106: sqlite3VdbeSetColName ( v , i , COLNAME_NAME , zCol , SQLITE_TRANSIENT ) ; 
line 80107: } 
line 80108: } else { 
line 80109: sqlite3VdbeSetColName ( v , i , COLNAME_NAME , 
line 80110: sqlite3DbStrDup ( db , pEList -> a [ i ] . zSpan ) , SQLITE_DYNAMIC ) ; 
line 80111: } 
line 80112: } 
line 80113: generateColumnTypes ( pParse , pTabList , pEList ) ; 
line 80114: } 
line 80116: # ifndef SQLITE_OMIT_COMPOUND_SELECT 
line 80120: static const char * selectOpName ( int id ) { 
line 80121: char * z ; 
line 80122: switch ( id ) { 
line 80123: case TK_ALL : z = "UNION ALL" ; break ; 
line 80124: case TK_INTERSECT : z = "INTERSECT" ; break ; 
line 80125: case TK_EXCEPT : z = "EXCEPT" ; break ; 
line 80126: default : z = "UNION" ; break ; 
line 80127: } 
line 80128: return z ; 
line 80129: } 
line 80130: # endif 
line 80145: static int selectColumnsFromExprList ( 
line 80146: Parse * pParse , 
line 80147: ExprList * pEList , 
line 80148: int * pnCol , 
line 80149: Column * * paCol 
line 80150: ) { 
line 80151: sqlite3 * db = pParse -> db ; 
line 80152: int i , j ; 
line 80153: int cnt ; 
line 80154: Column * aCol , * pCol ; 
line 80155: int nCol ; 
line 80156: Expr * p ; 
line 80157: char * zName ; 
line 80158: int nName ; 
line 80160: * pnCol = nCol = pEList -> nExpr ; 
line 80161: aCol = * paCol = sqlite3DbMallocZero ( db , sizeof ( aCol [ 0 ] ) * nCol ) ; 
line 80162: if ( aCol == 0 ) return SQLITE_NOMEM ; 
line 80163: for ( i = 0 , pCol = aCol ; i < nCol ; i ++ , pCol ++ ) { 
line 80166: p = pEList -> a [ i ] . pExpr ; 
line 80167: assert ( p -> pRight == 0 || ExprHasProperty ( p -> pRight , EP_IntValue ) 
line 80168: || p -> pRight -> u . zToken == 0 || p -> pRight -> u . zToken [ 0 ] != 0 ) ; 
line 80169: if ( ( zName = pEList -> a [ i ] . zName ) != 0 ) { 
line 80171: zName = sqlite3DbStrDup ( db , zName ) ; 
line 80172: } else { 
line 80173: Expr * pColExpr = p ; 
line 80174: Table * pTab ; 
line 80175: while ( pColExpr -> op == TK_DOT ) pColExpr = pColExpr -> pRight ; 
line 80176: if ( pColExpr -> op == TK_COLUMN && ALWAYS ( pColExpr -> pTab != 0 ) ) { 
line 80178: int iCol = pColExpr -> iColumn ; 
line 80179: pTab = pColExpr -> pTab ; 
line 80180: if ( iCol < 0 ) iCol = pTab -> iPKey ; 
line 80181: zName = sqlite3MPrintf ( db , "%s" , 
line 80182: iCol >= 0 ? pTab -> aCol [ iCol ] . zName : "rowid" ) ; 
line 80183: } else if ( pColExpr -> op == TK_ID ) { 
line 80184: assert ( ! ExprHasProperty ( pColExpr , EP_IntValue ) ) ; 
line 80185: zName = sqlite3MPrintf ( db , "%s" , pColExpr -> u . zToken ) ; 
line 80186: } else { 
line 80188: zName = sqlite3MPrintf ( db , "%s" , pEList -> a [ i ] . zSpan ) ; 
line 80189: } 
line 80190: } 
line 80191: if ( db -> mallocFailed ) { 
line 80192: sqlite3DbFree ( db , zName ) ; 
line 80193: break ; 
line 80194: } 
line 80199: nName = sqlite3Strlen30 ( zName ) ; 
line 80200: for ( j = cnt = 0 ; j < i ; j ++ ) { 
line 80201: if ( sqlite3StrICmp ( aCol [ j ] . zName , zName ) == 0 ) { 
line 80202: char * zNewName ; 
line 80203: zName [ nName ] = 0 ; 
line 80204: zNewName = sqlite3MPrintf ( db , "%s:%d" , zName , ++ cnt ) ; 
line 80205: sqlite3DbFree ( db , zName ) ; 
line 80206: zName = zNewName ; 
line 80207: j = - 1 ; 
line 80208: if ( zName == 0 ) break ; 
line 80209: } 
line 80210: } 
line 80211: pCol -> zName = zName ; 
line 80212: } 
line 80213: if ( db -> mallocFailed ) { 
line 80214: for ( j = 0 ; j < i ; j ++ ) { 
line 80215: sqlite3DbFree ( db , aCol [ j ] . zName ) ; 
line 80216: } 
line 80217: sqlite3DbFree ( db , aCol ) ; 
line 80218: * paCol = 0 ; 
line 80219: * pnCol = 0 ; 
line 80220: return SQLITE_NOMEM ; 
line 80221: } 
line 80222: return SQLITE_OK ; 
line 80223: } 
line 80236: static void selectAddColumnTypeAndCollation ( 
line 80237: Parse * pParse , 
line 80238: int nCol , 
line 80239: Column * aCol , 
line 80240: Select * pSelect 
line 80241: ) { 
line 80242: sqlite3 * db = pParse -> db ; 
line 80243: NameContext sNC ; 
line 80244: Column * pCol ; 
line 80245: CollSeq * pColl ; 
line 80246: int i ; 
line 80247: Expr * p ; 
line 80248: struct ExprList_item * a ; 
line 80250: assert ( pSelect != 0 ) ; 
line 80251: assert ( ( pSelect -> selFlags & SF_Resolved ) != 0 ) ; 
line 80252: assert ( nCol == pSelect -> pEList -> nExpr || db -> mallocFailed ) ; 
line 80253: if ( db -> mallocFailed ) return ; 
line 80254: memset ( & sNC , 0 , sizeof ( sNC ) ) ; 
line 80255: sNC . pSrcList = pSelect -> pSrc ; 
line 80256: a = pSelect -> pEList -> a ; 
line 80257: for ( i = 0 , pCol = aCol ; i < nCol ; i ++ , pCol ++ ) { 
line 80258: p = a [ i ] . pExpr ; 
line 80259: pCol -> zType = sqlite3DbStrDup ( db , columnType ( & sNC , p , 0 , 0 , 0 ) ) ; 
line 80260: pCol -> affinity = sqlite3ExprAffinity ( p ) ; 
line 80261: if ( pCol -> affinity == 0 ) pCol -> affinity = SQLITE_AFF_NONE ; 
line 80262: pColl = sqlite3ExprCollSeq ( pParse , p ) ; 
line 80263: if ( pColl ) { 
line 80264: pCol -> zColl = sqlite3DbStrDup ( db , pColl -> zName ) ; 
line 80265: } 
line 80266: } 
line 80267: } 
line 80273: SQLITE_PRIVATE Table * sqlite3ResultSetOfSelect ( Parse * pParse , Select * pSelect ) { 
line 80274: Table * pTab ; 
line 80275: sqlite3 * db = pParse -> db ; 
line 80276: int savedFlags ; 
line 80278: savedFlags = db -> flags ; 
line 80279: db -> flags &= ~ SQLITE_FullColNames ; 
line 80280: db -> flags |= SQLITE_ShortColNames ; 
line 80281: sqlite3SelectPrep ( pParse , pSelect , 0 ) ; 
line 80282: if ( pParse -> nErr ) return 0 ; 
line 80283: while ( pSelect -> pPrior ) pSelect = pSelect -> pPrior ; 
line 80284: db -> flags = savedFlags ; 
line 80285: pTab = sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; 
line 80286: if ( pTab == 0 ) { 
line 80287: return 0 ; 
line 80288: } 
line 80291: assert ( db -> lookaside . bEnabled == 0 ) ; 
line 80292: pTab -> dbMem = 0 ; 
line 80293: pTab -> nRef = 1 ; 
line 80294: pTab -> zName = 0 ; 
line 80295: selectColumnsFromExprList ( pParse , pSelect -> pEList , & pTab -> nCol , & pTab -> aCol ) ; 
line 80296: selectAddColumnTypeAndCollation ( pParse , pTab -> nCol , pTab -> aCol , pSelect ) ; 
line 80297: pTab -> iPKey = - 1 ; 
line 80298: if ( db -> mallocFailed ) { 
line 80299: sqlite3DeleteTable ( pTab ) ; 
line 80300: return 0 ; 
line 80301: } 
line 80302: return pTab ; 
line 80303: } 
line 80309: SQLITE_PRIVATE Vdbe * sqlite3GetVdbe ( Parse * pParse ) { 
line 80310: Vdbe * v = pParse -> pVdbe ; 
line 80311: if ( v == 0 ) { 
line 80312: v = pParse -> pVdbe = sqlite3VdbeCreate ( pParse -> db ) ; 
line 80313: # ifndef SQLITE_OMIT_TRACE 
line 80314: if ( v ) { 
line 80315: sqlite3VdbeAddOp0 ( v , OP_Trace ) ; 
line 80316: } 
line 80317: # endif 
line 80318: } 
line 80319: return v ; 
line 80320: } 
line 80341: static void computeLimitRegisters ( Parse * pParse , Select * p , int iBreak ) { 
line 80342: Vdbe * v = 0 ; 
line 80343: int iLimit = 0 ; 
line 80344: int iOffset ; 
line 80345: int addr1 , n ; 
line 80346: if ( p -> iLimit ) return ; 
line 80354: sqlite3ExprCacheClear ( pParse ) ; 
line 80355: assert ( p -> pOffset == 0 || p -> pLimit != 0 ) ; 
line 80356: if ( p -> pLimit ) { 
line 80357: p -> iLimit = iLimit = ++ pParse -> nMem ; 
line 80358: v = sqlite3GetVdbe ( pParse ) ; 
line 80359: if ( NEVER ( v == 0 ) ) return ; 
line 80360: if ( sqlite3ExprIsInteger ( p -> pLimit , & n ) ) { 
line 80361: sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ) ; 
line 80362: VdbeComment ( ( v , "LIMIT counter" ) ) ; 
line 80363: if ( n == 0 ) { 
line 80364: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ) ; 
line 80365: } 
line 80366: } else { 
line 80367: sqlite3ExprCode ( pParse , p -> pLimit , iLimit ) ; 
line 80368: sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ) ; 
line 80369: VdbeComment ( ( v , "LIMIT counter" ) ) ; 
line 80370: sqlite3VdbeAddOp2 ( v , OP_IfZero , iLimit , iBreak ) ; 
line 80371: } 
line 80372: if ( p -> pOffset ) { 
line 80373: p -> iOffset = iOffset = ++ pParse -> nMem ; 
line 80374: pParse -> nMem ++ ; 
line 80375: sqlite3ExprCode ( pParse , p -> pOffset , iOffset ) ; 
line 80376: sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ) ; 
line 80377: VdbeComment ( ( v , "OFFSET counter" ) ) ; 
line 80378: addr1 = sqlite3VdbeAddOp1 ( v , OP_IfPos , iOffset ) ; 
line 80379: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iOffset ) ; 
line 80380: sqlite3VdbeJumpHere ( v , addr1 ) ; 
line 80381: sqlite3VdbeAddOp3 ( v , OP_Add , iLimit , iOffset , iOffset + 1 ) ; 
line 80382: VdbeComment ( ( v , "LIMIT+OFFSET" ) ) ; 
line 80383: addr1 = sqlite3VdbeAddOp1 ( v , OP_IfPos , iLimit ) ; 
line 80384: sqlite3VdbeAddOp2 ( v , OP_Integer , - 1 , iOffset + 1 ) ; 
line 80385: sqlite3VdbeJumpHere ( v , addr1 ) ; 
line 80386: } 
line 80387: } 
line 80388: } 
line 80390: # ifndef SQLITE_OMIT_COMPOUND_SELECT 
line 80399: static CollSeq * multiSelectCollSeq ( Parse * pParse , Select * p , int iCol ) { 
line 80400: CollSeq * pRet ; 
line 80401: if ( p -> pPrior ) { 
line 80402: pRet = multiSelectCollSeq ( pParse , p -> pPrior , iCol ) ; 
line 80403: } else { 
line 80404: pRet = 0 ; 
line 80405: } 
line 80406: assert ( iCol >= 0 ) ; 
line 80407: if ( pRet == 0 && iCol < p -> pEList -> nExpr ) { 
line 80408: pRet = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ iCol ] . pExpr ) ; 
line 80409: } 
line 80410: return pRet ; 
line 80411: } 
line 80412: # endif 
line 80415: static int multiSelectOrderBy ( 
line 80416: Parse * pParse , 
line 80417: Select * p , 
line 80418: SelectDest * pDest 
line 80419: ) ; 
line 80422: # ifndef SQLITE_OMIT_COMPOUND_SELECT 
line 80454: static int multiSelect ( 
line 80455: Parse * pParse , 
line 80456: Select * p , 
line 80457: SelectDest * pDest 
line 80458: ) { 
line 80459: int rc = SQLITE_OK ; 
line 80460: Select * pPrior ; 
line 80461: Vdbe * v ; 
line 80462: SelectDest dest ; 
line 80463: Select * pDelete = 0 ; 
line 80464: sqlite3 * db ; 
line 80469: assert ( p && p -> pPrior ) ; 
line 80470: db = pParse -> db ; 
line 80471: pPrior = p -> pPrior ; 
line 80472: assert ( pPrior -> pRightmost != pPrior ) ; 
line 80473: assert ( pPrior -> pRightmost == p -> pRightmost ) ; 
line 80474: dest = * pDest ; 
line 80475: if ( pPrior -> pOrderBy ) { 
line 80476: sqlite3ErrorMsg ( pParse , "ORDER BY clause should come after %s not before" , 
line 80477: selectOpName ( p -> op ) ) ; 
line 80478: rc = 1 ; 
line 80479: goto multi_select_end ; 
line 80480: } 
line 80481: if ( pPrior -> pLimit ) { 
line 80482: sqlite3ErrorMsg ( pParse , "LIMIT clause should come after %s not before" , 
line 80483: selectOpName ( p -> op ) ) ; 
line 80484: rc = 1 ; 
line 80485: goto multi_select_end ; 
line 80486: } 
line 80488: v = sqlite3GetVdbe ( pParse ) ; 
line 80489: assert ( v != 0 ) ; 
line 80493: if ( dest . eDest == SRT_EphemTab ) { 
line 80494: assert ( p -> pEList ) ; 
line 80495: sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , dest . iParm , p -> pEList -> nExpr ) ; 
line 80496: dest . eDest = SRT_Table ; 
line 80497: } 
line 80502: assert ( p -> pEList && pPrior -> pEList ) ; 
line 80503: if ( p -> pEList -> nExpr != pPrior -> pEList -> nExpr ) { 
line 80504: sqlite3ErrorMsg ( pParse , "SELECTs to the left and right of %s" 
line 80505: " do not have the same number of result columns" , selectOpName ( p -> op ) ) ; 
line 80506: rc = 1 ; 
line 80507: goto multi_select_end ; 
line 80508: } 
line 80512: if ( p -> pOrderBy ) { 
line 80513: return multiSelectOrderBy ( pParse , p , pDest ) ; 
line 80514: } 
line 80518: switch ( p -> op ) { 
line 80519: case TK_ALL : { 
line 80520: int addr = 0 ; 
line 80521: assert ( ! pPrior -> pLimit ) ; 
line 80522: pPrior -> pLimit = p -> pLimit ; 
line 80523: pPrior -> pOffset = p -> pOffset ; 
line 80524: rc = sqlite3Select ( pParse , pPrior , & dest ) ; 
line 80525: p -> pLimit = 0 ; 
line 80526: p -> pOffset = 0 ; 
line 80527: if ( rc ) { 
line 80528: goto multi_select_end ; 
line 80529: } 
line 80530: p -> pPrior = 0 ; 
line 80531: p -> iLimit = pPrior -> iLimit ; 
line 80532: p -> iOffset = pPrior -> iOffset ; 
line 80533: if ( p -> iLimit ) { 
line 80534: addr = sqlite3VdbeAddOp1 ( v , OP_IfZero , p -> iLimit ) ; 
line 80535: VdbeComment ( ( v , "Jump ahead if LIMIT reached" ) ) ; 
line 80536: } 
line 80537: rc = sqlite3Select ( pParse , p , & dest ) ; 
line 80538: testcase ( rc != SQLITE_OK ) ; 
line 80539: pDelete = p -> pPrior ; 
line 80540: p -> pPrior = pPrior ; 
line 80541: if ( addr ) { 
line 80542: sqlite3VdbeJumpHere ( v , addr ) ; 
line 80543: } 
line 80544: break ; 
line 80545: } 
line 80546: case TK_EXCEPT : 
line 80547: case TK_UNION : { 
line 80548: int unionTab ; 
line 80549: u8 op = 0 ; 
line 80550: int priorOp ; 
line 80551: Expr * pLimit , * pOffset ; 
line 80552: int addr ; 
line 80553: SelectDest uniondest ; 
line 80555: testcase ( p -> op == TK_EXCEPT ) ; 
line 80556: testcase ( p -> op == TK_UNION ) ; 
line 80557: priorOp = SRT_Union ; 
line 80558: if ( dest . eDest == priorOp && ALWAYS ( ! p -> pLimit && ! p -> pOffset ) ) { 
line 80562: assert ( p -> pRightmost != p ) ; 
line 80564: assert ( p -> pLimit == 0 ) ; 
line 80565: assert ( p -> pOffset == 0 ) ; 
line 80566: unionTab = dest . iParm ; 
line 80567: } else { 
line 80571: unionTab = pParse -> nTab ++ ; 
line 80572: assert ( p -> pOrderBy == 0 ) ; 
line 80573: addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ) ; 
line 80574: assert ( p -> addrOpenEphm [ 0 ] == - 1 ) ; 
line 80575: p -> addrOpenEphm [ 0 ] = addr ; 
line 80576: p -> pRightmost -> selFlags |= SF_UsesEphemeral ; 
line 80577: assert ( p -> pEList ) ; 
line 80578: } 
line 80582: assert ( ! pPrior -> pOrderBy ) ; 
line 80583: sqlite3SelectDestInit ( & uniondest , priorOp , unionTab ) ; 
line 80584: rc = sqlite3Select ( pParse , pPrior , & uniondest ) ; 
line 80585: if ( rc ) { 
line 80586: goto multi_select_end ; 
line 80587: } 
line 80591: if ( p -> op == TK_EXCEPT ) { 
line 80592: op = SRT_Except ; 
line 80593: } else { 
line 80594: assert ( p -> op == TK_UNION ) ; 
line 80595: op = SRT_Union ; 
line 80596: } 
line 80597: p -> pPrior = 0 ; 
line 80598: pLimit = p -> pLimit ; 
line 80599: p -> pLimit = 0 ; 
line 80600: pOffset = p -> pOffset ; 
line 80601: p -> pOffset = 0 ; 
line 80602: uniondest . eDest = op ; 
line 80603: rc = sqlite3Select ( pParse , p , & uniondest ) ; 
line 80604: testcase ( rc != SQLITE_OK ) ; 
line 80607: sqlite3ExprListDelete ( db , p -> pOrderBy ) ; 
line 80608: pDelete = p -> pPrior ; 
line 80609: p -> pPrior = pPrior ; 
line 80610: p -> pOrderBy = 0 ; 
line 80611: sqlite3ExprDelete ( db , p -> pLimit ) ; 
line 80612: p -> pLimit = pLimit ; 
line 80613: p -> pOffset = pOffset ; 
line 80614: p -> iLimit = 0 ; 
line 80615: p -> iOffset = 0 ; 
line 80620: assert ( unionTab == dest . iParm || dest . eDest != priorOp ) ; 
line 80621: if ( dest . eDest != priorOp ) { 
line 80622: int iCont , iBreak , iStart ; 
line 80623: assert ( p -> pEList ) ; 
line 80624: if ( dest . eDest == SRT_Output ) { 
line 80625: Select * pFirst = p ; 
line 80626: while ( pFirst -> pPrior ) pFirst = pFirst -> pPrior ; 
line 80627: generateColumnNames ( pParse , 0 , pFirst -> pEList ) ; 
line 80628: } 
line 80629: iBreak = sqlite3VdbeMakeLabel ( v ) ; 
line 80630: iCont = sqlite3VdbeMakeLabel ( v ) ; 
line 80631: computeLimitRegisters ( pParse , p , iBreak ) ; 
line 80632: sqlite3VdbeAddOp2 ( v , OP_Rewind , unionTab , iBreak ) ; 
line 80633: iStart = sqlite3VdbeCurrentAddr ( v ) ; 
line 80634: selectInnerLoop ( pParse , p , p -> pEList , unionTab , p -> pEList -> nExpr , 
line 80635: 0 , - 1 , & dest , iCont , iBreak ) ; 
line 80636: sqlite3VdbeResolveLabel ( v , iCont ) ; 
line 80637: sqlite3VdbeAddOp2 ( v , OP_Next , unionTab , iStart ) ; 
line 80638: sqlite3VdbeResolveLabel ( v , iBreak ) ; 
line 80639: sqlite3VdbeAddOp2 ( v , OP_Close , unionTab , 0 ) ; 
line 80640: } 
line 80641: break ; 
line 80642: } 
line 80643: default : assert ( p -> op == TK_INTERSECT ) ; { 
line 80644: int tab1 , tab2 ; 
line 80645: int iCont , iBreak , iStart ; 
line 80646: Expr * pLimit , * pOffset ; 
line 80647: int addr ; 
line 80648: SelectDest intersectdest ; 
line 80649: int r1 ; 
line 80655: tab1 = pParse -> nTab ++ ; 
line 80656: tab2 = pParse -> nTab ++ ; 
line 80657: assert ( p -> pOrderBy == 0 ) ; 
line 80659: addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , tab1 , 0 ) ; 
line 80660: assert ( p -> addrOpenEphm [ 0 ] == - 1 ) ; 
line 80661: p -> addrOpenEphm [ 0 ] = addr ; 
line 80662: p -> pRightmost -> selFlags |= SF_UsesEphemeral ; 
line 80663: assert ( p -> pEList ) ; 
line 80667: sqlite3SelectDestInit ( & intersectdest , SRT_Union , tab1 ) ; 
line 80668: rc = sqlite3Select ( pParse , pPrior , & intersectdest ) ; 
line 80669: if ( rc ) { 
line 80670: goto multi_select_end ; 
line 80671: } 
line 80675: addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , tab2 , 0 ) ; 
line 80676: assert ( p -> addrOpenEphm [ 1 ] == - 1 ) ; 
line 80677: p -> addrOpenEphm [ 1 ] = addr ; 
line 80678: p -> pPrior = 0 ; 
line 80679: pLimit = p -> pLimit ; 
line 80680: p -> pLimit = 0 ; 
line 80681: pOffset = p -> pOffset ; 
line 80682: p -> pOffset = 0 ; 
line 80683: intersectdest . iParm = tab2 ; 
line 80684: rc = sqlite3Select ( pParse , p , & intersectdest ) ; 
line 80685: testcase ( rc != SQLITE_OK ) ; 
line 80686: pDelete = p -> pPrior ; 
line 80687: p -> pPrior = pPrior ; 
line 80688: sqlite3ExprDelete ( db , p -> pLimit ) ; 
line 80689: p -> pLimit = pLimit ; 
line 80690: p -> pOffset = pOffset ; 
line 80695: assert ( p -> pEList ) ; 
line 80696: if ( dest . eDest == SRT_Output ) { 
line 80697: Select * pFirst = p ; 
line 80698: while ( pFirst -> pPrior ) pFirst = pFirst -> pPrior ; 
line 80699: generateColumnNames ( pParse , 0 , pFirst -> pEList ) ; 
line 80700: } 
line 80701: iBreak = sqlite3VdbeMakeLabel ( v ) ; 
line 80702: iCont = sqlite3VdbeMakeLabel ( v ) ; 
line 80703: computeLimitRegisters ( pParse , p , iBreak ) ; 
line 80704: sqlite3VdbeAddOp2 ( v , OP_Rewind , tab1 , iBreak ) ; 
line 80705: r1 = sqlite3GetTempReg ( pParse ) ; 
line 80706: iStart = sqlite3VdbeAddOp2 ( v , OP_RowKey , tab1 , r1 ) ; 
line 80707: sqlite3VdbeAddOp4Int ( v , OP_NotFound , tab2 , iCont , r1 , 0 ) ; 
line 80708: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 80709: selectInnerLoop ( pParse , p , p -> pEList , tab1 , p -> pEList -> nExpr , 
line 80710: 0 , - 1 , & dest , iCont , iBreak ) ; 
line 80711: sqlite3VdbeResolveLabel ( v , iCont ) ; 
line 80712: sqlite3VdbeAddOp2 ( v , OP_Next , tab1 , iStart ) ; 
line 80713: sqlite3VdbeResolveLabel ( v , iBreak ) ; 
line 80714: sqlite3VdbeAddOp2 ( v , OP_Close , tab2 , 0 ) ; 
line 80715: sqlite3VdbeAddOp2 ( v , OP_Close , tab1 , 0 ) ; 
line 80716: break ; 
line 80717: } 
line 80718: } 
line 80729: if ( p -> selFlags & SF_UsesEphemeral ) { 
line 80730: int i ; 
line 80731: KeyInfo * pKeyInfo ; 
line 80732: Select * pLoop ; 
line 80733: CollSeq * * apColl ; 
line 80734: int nCol ; 
line 80736: assert ( p -> pRightmost == p ) ; 
line 80737: nCol = p -> pEList -> nExpr ; 
line 80738: pKeyInfo = sqlite3DbMallocZero ( db , 
line 80739: sizeof ( * pKeyInfo ) + nCol * ( sizeof ( CollSeq * ) + 1 ) ) ; 
line 80740: if ( ! pKeyInfo ) { 
line 80741: rc = SQLITE_NOMEM ; 
line 80742: goto multi_select_end ; 
line 80743: } 
line 80745: pKeyInfo -> enc = ENC ( db ) ; 
line 80746: pKeyInfo -> nField = ( u16 ) nCol ; 
line 80748: for ( i = 0 , apColl = pKeyInfo -> aColl ; i < nCol ; i ++ , apColl ++ ) { 
line 80749: * apColl = multiSelectCollSeq ( pParse , p , i ) ; 
line 80750: if ( 0 == * apColl ) { 
line 80751: * apColl = db -> pDfltColl ; 
line 80752: } 
line 80753: } 
line 80755: for ( pLoop = p ; pLoop ; pLoop = pLoop -> pPrior ) { 
line 80756: for ( i = 0 ; i < 2 ; i ++ ) { 
line 80757: int addr = pLoop -> addrOpenEphm [ i ] ; 
line 80758: if ( addr < 0 ) { 
line 80761: assert ( pLoop -> addrOpenEphm [ 1 ] < 0 ) ; 
line 80762: break ; 
line 80763: } 
line 80764: sqlite3VdbeChangeP2 ( v , addr , nCol ) ; 
line 80765: sqlite3VdbeChangeP4 ( v , addr , ( char * ) pKeyInfo , P4_KEYINFO ) ; 
line 80766: pLoop -> addrOpenEphm [ i ] = - 1 ; 
line 80767: } 
line 80768: } 
line 80769: sqlite3DbFree ( db , pKeyInfo ) ; 
line 80770: } 
line 80772: multi_select_end : 
line 80773: pDest -> iMem = dest . iMem ; 
line 80774: pDest -> nMem = dest . nMem ; 
line 80775: sqlite3SelectDelete ( db , pDelete ) ; 
line 80776: return rc ; 
line 80777: } 
line 80778: # endif 
line 80800: static int generateOutputSubroutine ( 
line 80801: Parse * pParse , 
line 80802: Select * p , 
line 80803: SelectDest * pIn , 
line 80804: SelectDest * pDest , 
line 80805: int regReturn , 
line 80806: int regPrev , 
line 80807: KeyInfo * pKeyInfo , 
line 80808: int p4type , 
line 80809: int iBreak 
line 80810: ) { 
line 80811: Vdbe * v = pParse -> pVdbe ; 
line 80812: int iContinue ; 
line 80813: int addr ; 
line 80815: addr = sqlite3VdbeCurrentAddr ( v ) ; 
line 80816: iContinue = sqlite3VdbeMakeLabel ( v ) ; 
line 80820: if ( regPrev ) { 
line 80821: int j1 , j2 ; 
line 80822: j1 = sqlite3VdbeAddOp1 ( v , OP_IfNot , regPrev ) ; 
line 80823: j2 = sqlite3VdbeAddOp4 ( v , OP_Compare , pIn -> iMem , regPrev + 1 , pIn -> nMem , 
line 80824: ( char * ) pKeyInfo , p4type ) ; 
line 80825: sqlite3VdbeAddOp3 ( v , OP_Jump , j2 + 2 , iContinue , j2 + 2 ) ; 
line 80826: sqlite3VdbeJumpHere ( v , j1 ) ; 
line 80827: sqlite3ExprCodeCopy ( pParse , pIn -> iMem , regPrev + 1 , pIn -> nMem ) ; 
line 80828: sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regPrev ) ; 
line 80829: } 
line 80830: if ( pParse -> db -> mallocFailed ) return 0 ; 
line 80834: codeOffset ( v , p , iContinue ) ; 
line 80836: switch ( pDest -> eDest ) { 
line 80839: case SRT_Table : 
line 80840: case SRT_EphemTab : { 
line 80841: int r1 = sqlite3GetTempReg ( pParse ) ; 
line 80842: int r2 = sqlite3GetTempReg ( pParse ) ; 
line 80843: testcase ( pDest -> eDest == SRT_Table ) ; 
line 80844: testcase ( pDest -> eDest == SRT_EphemTab ) ; 
line 80845: sqlite3VdbeAddOp3 ( v , OP_MakeRecord , pIn -> iMem , pIn -> nMem , r1 ) ; 
line 80846: sqlite3VdbeAddOp2 ( v , OP_NewRowid , pDest -> iParm , r2 ) ; 
line 80847: sqlite3VdbeAddOp3 ( v , OP_Insert , pDest -> iParm , r1 , r2 ) ; 
line 80848: sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ) ; 
line 80849: sqlite3ReleaseTempReg ( pParse , r2 ) ; 
line 80850: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 80851: break ; 
line 80852: } 
line 80854: # ifndef SQLITE_OMIT_SUBQUERY 
line 80859: case SRT_Set : { 
line 80860: int r1 ; 
line 80861: assert ( pIn -> nMem == 1 ) ; 
line 80862: p -> affinity = 
line 80863: sqlite3CompareAffinity ( p -> pEList -> a [ 0 ] . pExpr , pDest -> affinity ) ; 
line 80864: r1 = sqlite3GetTempReg ( pParse ) ; 
line 80865: sqlite3VdbeAddOp4 ( v , OP_MakeRecord , pIn -> iMem , 1 , r1 , & p -> affinity , 1 ) ; 
line 80866: sqlite3ExprCacheAffinityChange ( pParse , pIn -> iMem , 1 ) ; 
line 80867: sqlite3VdbeAddOp2 ( v , OP_IdxInsert , pDest -> iParm , r1 ) ; 
line 80868: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 80869: break ; 
line 80870: } 
line 80872: # if 0 
line 80875: case SRT_Exists : { 
line 80876: sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , pDest -> iParm ) ; 
line 80878: break ; 
line 80879: } 
line 80880: # endif 
line 80886: case SRT_Mem : { 
line 80887: assert ( pIn -> nMem == 1 ) ; 
line 80888: sqlite3ExprCodeMove ( pParse , pIn -> iMem , pDest -> iParm , 1 ) ; 
line 80890: break ; 
line 80891: } 
line 80892: # endif 
line 80897: case SRT_Coroutine : { 
line 80898: if ( pDest -> iMem == 0 ) { 
line 80899: pDest -> iMem = sqlite3GetTempRange ( pParse , pIn -> nMem ) ; 
line 80900: pDest -> nMem = pIn -> nMem ; 
line 80901: } 
line 80902: sqlite3ExprCodeMove ( pParse , pIn -> iMem , pDest -> iMem , pDest -> nMem ) ; 
line 80903: sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iParm ) ; 
line 80904: break ; 
line 80905: } 
line 80915: default : { 
line 80916: assert ( pDest -> eDest == SRT_Output ) ; 
line 80917: sqlite3VdbeAddOp2 ( v , OP_ResultRow , pIn -> iMem , pIn -> nMem ) ; 
line 80918: sqlite3ExprCacheAffinityChange ( pParse , pIn -> iMem , pIn -> nMem ) ; 
line 80919: break ; 
line 80920: } 
line 80921: } 
line 80925: if ( p -> iLimit ) { 
line 80926: sqlite3VdbeAddOp3 ( v , OP_IfZero , p -> iLimit , iBreak , - 1 ) ; 
line 80927: } 
line 80931: sqlite3VdbeResolveLabel ( v , iContinue ) ; 
line 80932: sqlite3VdbeAddOp1 ( v , OP_Return , regReturn ) ; 
line 80934: return addr ; 
line 80935: } 
line 81022: # ifndef SQLITE_OMIT_COMPOUND_SELECT 
line 81023: static int multiSelectOrderBy ( 
line 81024: Parse * pParse , 
line 81025: Select * p , 
line 81026: SelectDest * pDest 
line 81027: ) { 
line 81028: int i , j ; 
line 81029: Select * pPrior ; 
line 81030: Vdbe * v ; 
line 81031: SelectDest destA ; 
line 81032: SelectDest destB ; 
line 81033: int regAddrA ; 
line 81034: int regEofA ; 
line 81035: int regAddrB ; 
line 81036: int regEofB ; 
line 81037: int addrSelectA ; 
line 81038: int addrSelectB ; 
line 81039: int regOutA ; 
line 81040: int regOutB ; 
line 81041: int addrOutA ; 
line 81042: int addrOutB = 0 ; 
line 81043: int addrEofA ; 
line 81044: int addrEofB ; 
line 81045: int addrAltB ; 
line 81046: int addrAeqB ; 
line 81047: int addrAgtB ; 
line 81048: int regLimitA ; 
line 81049: int regLimitB ; 
line 81050: int regPrev ; 
line 81051: int savedLimit ; 
line 81052: int savedOffset ; 
line 81053: int labelCmpr ; 
line 81054: int labelEnd ; 
line 81055: int j1 ; 
line 81056: int op ; 
line 81057: KeyInfo * pKeyDup = 0 ; 
line 81058: KeyInfo * pKeyMerge ; 
line 81059: sqlite3 * db ; 
line 81060: ExprList * pOrderBy ; 
line 81061: int nOrderBy ; 
line 81062: int * aPermute ; 
line 81064: assert ( p -> pOrderBy != 0 ) ; 
line 81065: assert ( pKeyDup == 0 ) ; 
line 81066: db = pParse -> db ; 
line 81067: v = pParse -> pVdbe ; 
line 81068: assert ( v != 0 ) ; 
line 81069: labelEnd = sqlite3VdbeMakeLabel ( v ) ; 
line 81070: labelCmpr = sqlite3VdbeMakeLabel ( v ) ; 
line 81075: op = p -> op ; 
line 81076: pPrior = p -> pPrior ; 
line 81077: assert ( pPrior -> pOrderBy == 0 ) ; 
line 81078: pOrderBy = p -> pOrderBy ; 
line 81079: assert ( pOrderBy ) ; 
line 81080: nOrderBy = pOrderBy -> nExpr ; 
line 81086: if ( op != TK_ALL ) { 
line 81087: for ( i = 1 ; db -> mallocFailed == 0 && i <= p -> pEList -> nExpr ; i ++ ) { 
line 81088: struct ExprList_item * pItem ; 
line 81089: for ( j = 0 , pItem = pOrderBy -> a ; j < nOrderBy ; j ++ , pItem ++ ) { 
line 81090: assert ( pItem -> iCol > 0 ) ; 
line 81091: if ( pItem -> iCol == i ) break ; 
line 81092: } 
line 81093: if ( j == nOrderBy ) { 
line 81094: Expr * pNew = sqlite3Expr ( db , TK_INTEGER , 0 ) ; 
line 81095: if ( pNew == 0 ) return SQLITE_NOMEM ; 
line 81096: pNew -> flags |= EP_IntValue ; 
line 81097: pNew -> u . iValue = i ; 
line 81098: pOrderBy = sqlite3ExprListAppend ( pParse , pOrderBy , pNew ) ; 
line 81099: pOrderBy -> a [ nOrderBy ++ ] . iCol = ( u16 ) i ; 
line 81100: } 
line 81101: } 
line 81102: } 
line 81111: aPermute = sqlite3DbMallocRaw ( db , sizeof ( int ) * nOrderBy ) ; 
line 81112: if ( aPermute ) { 
line 81113: struct ExprList_item * pItem ; 
line 81114: for ( i = 0 , pItem = pOrderBy -> a ; i < nOrderBy ; i ++ , pItem ++ ) { 
line 81115: assert ( pItem -> iCol > 0 && pItem -> iCol <= p -> pEList -> nExpr ) ; 
line 81116: aPermute [ i ] = pItem -> iCol - 1 ; 
line 81117: } 
line 81118: pKeyMerge = 
line 81119: sqlite3DbMallocRaw ( db , sizeof ( * pKeyMerge ) + nOrderBy * ( sizeof ( CollSeq * ) + 1 ) ) ; 
line 81120: if ( pKeyMerge ) { 
line 81121: pKeyMerge -> aSortOrder = ( u8 * ) & pKeyMerge -> aColl [ nOrderBy ] ; 
line 81122: pKeyMerge -> nField = ( u16 ) nOrderBy ; 
line 81123: pKeyMerge -> enc = ENC ( db ) ; 
line 81124: for ( i = 0 ; i < nOrderBy ; i ++ ) { 
line 81125: CollSeq * pColl ; 
line 81126: Expr * pTerm = pOrderBy -> a [ i ] . pExpr ; 
line 81127: if ( pTerm -> flags & EP_ExpCollate ) { 
line 81128: pColl = pTerm -> pColl ; 
line 81129: } else { 
line 81130: pColl = multiSelectCollSeq ( pParse , p , aPermute [ i ] ) ; 
line 81131: pTerm -> flags |= EP_ExpCollate ; 
line 81132: pTerm -> pColl = pColl ; 
line 81133: } 
line 81134: pKeyMerge -> aColl [ i ] = pColl ; 
line 81135: pKeyMerge -> aSortOrder [ i ] = pOrderBy -> a [ i ] . sortOrder ; 
line 81136: } 
line 81137: } 
line 81138: } else { 
line 81139: pKeyMerge = 0 ; 
line 81140: } 
line 81144: p -> pOrderBy = pOrderBy ; 
line 81145: pPrior -> pOrderBy = sqlite3ExprListDup ( pParse -> db , pOrderBy , 0 ) ; 
line 81151: if ( op == TK_ALL ) { 
line 81152: regPrev = 0 ; 
line 81153: } else { 
line 81154: int nExpr = p -> pEList -> nExpr ; 
line 81155: assert ( nOrderBy >= nExpr || db -> mallocFailed ) ; 
line 81156: regPrev = sqlite3GetTempRange ( pParse , nExpr + 1 ) ; 
line 81157: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regPrev ) ; 
line 81158: pKeyDup = sqlite3DbMallocZero ( db , 
line 81159: sizeof ( * pKeyDup ) + nExpr * ( sizeof ( CollSeq * ) + 1 ) ) ; 
line 81160: if ( pKeyDup ) { 
line 81161: pKeyDup -> aSortOrder = ( u8 * ) & pKeyDup -> aColl [ nExpr ] ; 
line 81162: pKeyDup -> nField = ( u16 ) nExpr ; 
line 81163: pKeyDup -> enc = ENC ( db ) ; 
line 81164: for ( i = 0 ; i < nExpr ; i ++ ) { 
line 81165: pKeyDup -> aColl [ i ] = multiSelectCollSeq ( pParse , p , i ) ; 
line 81166: pKeyDup -> aSortOrder [ i ] = 0 ; 
line 81167: } 
line 81168: } 
line 81169: } 
line 81173: p -> pPrior = 0 ; 
line 81174: pPrior -> pRightmost = 0 ; 
line 81175: sqlite3ResolveOrderGroupBy ( pParse , p , p -> pOrderBy , "ORDER" ) ; 
line 81176: if ( pPrior -> pPrior == 0 ) { 
line 81177: sqlite3ResolveOrderGroupBy ( pParse , pPrior , pPrior -> pOrderBy , "ORDER" ) ; 
line 81178: } 
line 81181: computeLimitRegisters ( pParse , p , labelEnd ) ; 
line 81182: if ( p -> iLimit && op == TK_ALL ) { 
line 81183: regLimitA = ++ pParse -> nMem ; 
line 81184: regLimitB = ++ pParse -> nMem ; 
line 81185: sqlite3VdbeAddOp2 ( v , OP_Copy , p -> iOffset ? p -> iOffset + 1 : p -> iLimit , 
line 81186: regLimitA ) ; 
line 81187: sqlite3VdbeAddOp2 ( v , OP_Copy , regLimitA , regLimitB ) ; 
line 81188: } else { 
line 81189: regLimitA = regLimitB = 0 ; 
line 81190: } 
line 81191: sqlite3ExprDelete ( db , p -> pLimit ) ; 
line 81192: p -> pLimit = 0 ; 
line 81193: sqlite3ExprDelete ( db , p -> pOffset ) ; 
line 81194: p -> pOffset = 0 ; 
line 81196: regAddrA = ++ pParse -> nMem ; 
line 81197: regEofA = ++ pParse -> nMem ; 
line 81198: regAddrB = ++ pParse -> nMem ; 
line 81199: regEofB = ++ pParse -> nMem ; 
line 81200: regOutA = ++ pParse -> nMem ; 
line 81201: regOutB = ++ pParse -> nMem ; 
line 81202: sqlite3SelectDestInit ( & destA , SRT_Coroutine , regAddrA ) ; 
line 81203: sqlite3SelectDestInit ( & destB , SRT_Coroutine , regAddrB ) ; 
line 81208: j1 = sqlite3VdbeAddOp0 ( v , OP_Goto ) ; 
line 81209: addrSelectA = sqlite3VdbeCurrentAddr ( v ) ; 
line 81215: VdbeNoopComment ( ( v , "Begin coroutine for left SELECT" ) ) ; 
line 81216: pPrior -> iLimit = regLimitA ; 
line 81217: sqlite3Select ( pParse , pPrior , & destA ) ; 
line 81218: sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regEofA ) ; 
line 81219: sqlite3VdbeAddOp1 ( v , OP_Yield , regAddrA ) ; 
line 81220: VdbeNoopComment ( ( v , "End coroutine for left SELECT" ) ) ; 
line 81225: addrSelectB = sqlite3VdbeCurrentAddr ( v ) ; 
line 81226: VdbeNoopComment ( ( v , "Begin coroutine for right SELECT" ) ) ; 
line 81227: savedLimit = p -> iLimit ; 
line 81228: savedOffset = p -> iOffset ; 
line 81229: p -> iLimit = regLimitB ; 
line 81230: p -> iOffset = 0 ; 
line 81231: sqlite3Select ( pParse , p , & destB ) ; 
line 81232: p -> iLimit = savedLimit ; 
line 81233: p -> iOffset = savedOffset ; 
line 81234: sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regEofB ) ; 
line 81235: sqlite3VdbeAddOp1 ( v , OP_Yield , regAddrB ) ; 
line 81236: VdbeNoopComment ( ( v , "End coroutine for right SELECT" ) ) ; 
line 81241: VdbeNoopComment ( ( v , "Output routine for A" ) ) ; 
line 81242: addrOutA = generateOutputSubroutine ( pParse , 
line 81243: p , & destA , pDest , regOutA , 
line 81244: regPrev , pKeyDup , P4_KEYINFO_HANDOFF , labelEnd ) ; 
line 81249: if ( op == TK_ALL || op == TK_UNION ) { 
line 81250: VdbeNoopComment ( ( v , "Output routine for B" ) ) ; 
line 81251: addrOutB = generateOutputSubroutine ( pParse , 
line 81252: p , & destB , pDest , regOutB , 
line 81253: regPrev , pKeyDup , P4_KEYINFO_STATIC , labelEnd ) ; 
line 81254: } 
line 81259: VdbeNoopComment ( ( v , "eof-A subroutine" ) ) ; 
line 81260: if ( op == TK_EXCEPT || op == TK_INTERSECT ) { 
line 81261: addrEofA = sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , labelEnd ) ; 
line 81262: } else { 
line 81263: addrEofA = sqlite3VdbeAddOp2 ( v , OP_If , regEofB , labelEnd ) ; 
line 81264: sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ) ; 
line 81265: sqlite3VdbeAddOp1 ( v , OP_Yield , regAddrB ) ; 
line 81266: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , addrEofA ) ; 
line 81267: } 
line 81272: if ( op == TK_INTERSECT ) { 
line 81273: addrEofB = addrEofA ; 
line 81274: } else { 
line 81275: VdbeNoopComment ( ( v , "eof-B subroutine" ) ) ; 
line 81276: addrEofB = sqlite3VdbeAddOp2 ( v , OP_If , regEofA , labelEnd ) ; 
line 81277: sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ) ; 
line 81278: sqlite3VdbeAddOp1 ( v , OP_Yield , regAddrA ) ; 
line 81279: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , addrEofB ) ; 
line 81280: } 
line 81284: VdbeNoopComment ( ( v , "A-lt-B subroutine" ) ) ; 
line 81285: addrAltB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ) ; 
line 81286: sqlite3VdbeAddOp1 ( v , OP_Yield , regAddrA ) ; 
line 81287: sqlite3VdbeAddOp2 ( v , OP_If , regEofA , addrEofA ) ; 
line 81288: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , labelCmpr ) ; 
line 81292: if ( op == TK_ALL ) { 
line 81293: addrAeqB = addrAltB ; 
line 81294: } else if ( op == TK_INTERSECT ) { 
line 81295: addrAeqB = addrAltB ; 
line 81296: addrAltB ++ ; 
line 81297: } else { 
line 81298: VdbeNoopComment ( ( v , "A-eq-B subroutine" ) ) ; 
line 81299: addrAeqB = 
line 81300: sqlite3VdbeAddOp1 ( v , OP_Yield , regAddrA ) ; 
line 81301: sqlite3VdbeAddOp2 ( v , OP_If , regEofA , addrEofA ) ; 
line 81302: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , labelCmpr ) ; 
line 81303: } 
line 81307: VdbeNoopComment ( ( v , "A-gt-B subroutine" ) ) ; 
line 81308: addrAgtB = sqlite3VdbeCurrentAddr ( v ) ; 
line 81309: if ( op == TK_ALL || op == TK_UNION ) { 
line 81310: sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ) ; 
line 81311: } 
line 81312: sqlite3VdbeAddOp1 ( v , OP_Yield , regAddrB ) ; 
line 81313: sqlite3VdbeAddOp2 ( v , OP_If , regEofB , addrEofB ) ; 
line 81314: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , labelCmpr ) ; 
line 81318: sqlite3VdbeJumpHere ( v , j1 ) ; 
line 81319: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regEofA ) ; 
line 81320: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regEofB ) ; 
line 81321: sqlite3VdbeAddOp2 ( v , OP_Gosub , regAddrA , addrSelectA ) ; 
line 81322: sqlite3VdbeAddOp2 ( v , OP_Gosub , regAddrB , addrSelectB ) ; 
line 81323: sqlite3VdbeAddOp2 ( v , OP_If , regEofA , addrEofA ) ; 
line 81324: sqlite3VdbeAddOp2 ( v , OP_If , regEofB , addrEofB ) ; 
line 81328: sqlite3VdbeResolveLabel ( v , labelCmpr ) ; 
line 81329: sqlite3VdbeAddOp4 ( v , OP_Permutation , 0 , 0 , 0 , ( char * ) aPermute , P4_INTARRAY ) ; 
line 81330: sqlite3VdbeAddOp4 ( v , OP_Compare , destA . iMem , destB . iMem , nOrderBy , 
line 81331: ( char * ) pKeyMerge , P4_KEYINFO_HANDOFF ) ; 
line 81332: sqlite3VdbeAddOp3 ( v , OP_Jump , addrAltB , addrAeqB , addrAgtB ) ; 
line 81336: if ( regPrev ) { 
line 81337: sqlite3ReleaseTempRange ( pParse , regPrev , nOrderBy + 1 ) ; 
line 81338: } 
line 81342: sqlite3VdbeResolveLabel ( v , labelEnd ) ; 
line 81346: if ( pDest -> eDest == SRT_Output ) { 
line 81347: Select * pFirst = pPrior ; 
line 81348: while ( pFirst -> pPrior ) pFirst = pFirst -> pPrior ; 
line 81349: generateColumnNames ( pParse , 0 , pFirst -> pEList ) ; 
line 81350: } 
line 81354: if ( p -> pPrior ) { 
line 81355: sqlite3SelectDelete ( db , p -> pPrior ) ; 
line 81356: } 
line 81357: p -> pPrior = pPrior ; 
line 81361: return SQLITE_OK ; 
line 81362: } 
line 81363: # endif 
line 81365: # if ! defined ( SQLITE_OMIT_SUBQUERY ) || ! defined ( SQLITE_OMIT_VIEW ) 
line 81367: static void substExprList ( sqlite3 * , ExprList * , int , ExprList * ) ; 
line 81368: static void substSelect ( sqlite3 * , Select * , int , ExprList * ) ; 
line 81383: static Expr * substExpr ( 
line 81384: sqlite3 * db , 
line 81385: Expr * pExpr , 
line 81386: int iTable , 
line 81387: ExprList * pEList 
line 81388: ) { 
line 81389: if ( pExpr == 0 ) return 0 ; 
line 81390: if ( pExpr -> op == TK_COLUMN && pExpr -> iTable == iTable ) { 
line 81391: if ( pExpr -> iColumn < 0 ) { 
line 81392: pExpr -> op = TK_NULL ; 
line 81393: } else { 
line 81394: Expr * pNew ; 
line 81395: assert ( pEList != 0 && pExpr -> iColumn < pEList -> nExpr ) ; 
line 81396: assert ( pExpr -> pLeft == 0 && pExpr -> pRight == 0 ) ; 
line 81397: pNew = sqlite3ExprDup ( db , pEList -> a [ pExpr -> iColumn ] . pExpr , 0 ) ; 
line 81398: if ( pNew && pExpr -> pColl ) { 
line 81399: pNew -> pColl = pExpr -> pColl ; 
line 81400: } 
line 81401: sqlite3ExprDelete ( db , pExpr ) ; 
line 81402: pExpr = pNew ; 
line 81403: } 
line 81404: } else { 
line 81405: pExpr -> pLeft = substExpr ( db , pExpr -> pLeft , iTable , pEList ) ; 
line 81406: pExpr -> pRight = substExpr ( db , pExpr -> pRight , iTable , pEList ) ; 
line 81407: if ( ExprHasProperty ( pExpr , EP_xIsSelect ) ) { 
line 81408: substSelect ( db , pExpr -> x . pSelect , iTable , pEList ) ; 
line 81409: } else { 
line 81410: substExprList ( db , pExpr -> x . pList , iTable , pEList ) ; 
line 81411: } 
line 81412: } 
line 81413: return pExpr ; 
line 81414: } 
line 81415: static void substExprList ( 
line 81416: sqlite3 * db , 
line 81417: ExprList * pList , 
line 81418: int iTable , 
line 81419: ExprList * pEList 
line 81420: ) { 
line 81421: int i ; 
line 81422: if ( pList == 0 ) return ; 
line 81423: for ( i = 0 ; i < pList -> nExpr ; i ++ ) { 
line 81424: pList -> a [ i ] . pExpr = substExpr ( db , pList -> a [ i ] . pExpr , iTable , pEList ) ; 
line 81425: } 
line 81426: } 
line 81427: static void substSelect ( 
line 81428: sqlite3 * db , 
line 81429: Select * p , 
line 81430: int iTable , 
line 81431: ExprList * pEList 
line 81432: ) { 
line 81433: SrcList * pSrc ; 
line 81434: struct SrcList_item * pItem ; 
line 81435: int i ; 
line 81436: if ( ! p ) return ; 
line 81437: substExprList ( db , p -> pEList , iTable , pEList ) ; 
line 81438: substExprList ( db , p -> pGroupBy , iTable , pEList ) ; 
line 81439: substExprList ( db , p -> pOrderBy , iTable , pEList ) ; 
line 81440: p -> pHaving = substExpr ( db , p -> pHaving , iTable , pEList ) ; 
line 81441: p -> pWhere = substExpr ( db , p -> pWhere , iTable , pEList ) ; 
line 81442: substSelect ( db , p -> pPrior , iTable , pEList ) ; 
line 81443: pSrc = p -> pSrc ; 
line 81444: assert ( pSrc ) ; 
line 81445: if ( ALWAYS ( pSrc ) ) { 
line 81446: for ( i = pSrc -> nSrc , pItem = pSrc -> a ; i > 0 ; i -- , pItem ++ ) { 
line 81447: substSelect ( db , pItem -> pSelect , iTable , pEList ) ; 
line 81448: } 
line 81449: } 
line 81450: } 
line 81451: # endif 
line 81453: # if ! defined ( SQLITE_OMIT_SUBQUERY ) || ! defined ( SQLITE_OMIT_VIEW ) 
line 81560: static int flattenSubquery ( 
line 81561: Parse * pParse , 
line 81562: Select * p , 
line 81563: int iFrom , 
line 81564: int isAgg , 
line 81565: int subqueryIsAgg 
line 81566: ) { 
line 81567: const char * zSavedAuthContext = pParse -> zAuthContext ; 
line 81568: Select * pParent ; 
line 81569: Select * pSub ; 
line 81570: Select * pSub1 ; 
line 81571: SrcList * pSrc ; 
line 81572: SrcList * pSubSrc ; 
line 81573: ExprList * pList ; 
line 81574: int iParent ; 
line 81575: int i ; 
line 81576: Expr * pWhere ; 
line 81577: struct SrcList_item * pSubitem ; 
line 81578: sqlite3 * db = pParse -> db ; 
line 81582: assert ( p != 0 ) ; 
line 81583: assert ( p -> pPrior == 0 ) ; 
line 81584: if ( db -> flags & SQLITE_QueryFlattener ) return 0 ; 
line 81585: pSrc = p -> pSrc ; 
line 81586: assert ( pSrc && iFrom >= 0 && iFrom < pSrc -> nSrc ) ; 
line 81587: pSubitem = & pSrc -> a [ iFrom ] ; 
line 81588: iParent = pSubitem -> iCursor ; 
line 81589: pSub = pSubitem -> pSelect ; 
line 81590: assert ( pSub != 0 ) ; 
line 81591: if ( isAgg && subqueryIsAgg ) return 0 ; 
line 81592: if ( subqueryIsAgg && pSrc -> nSrc > 1 ) return 0 ; 
line 81593: pSubSrc = pSub -> pSrc ; 
line 81594: assert ( pSubSrc ) ; 
line 81600: if ( pSub -> pLimit && p -> pLimit ) return 0 ; 
line 81601: if ( pSub -> pOffset ) return 0 ; 
line 81602: if ( p -> pRightmost && pSub -> pLimit && pSub -> pOrderBy ) { 
line 81603: return 0 ; 
line 81604: } 
line 81605: if ( pSubSrc -> nSrc == 0 ) return 0 ; 
line 81606: if ( ( ( pSub -> selFlags & SF_Distinct ) != 0 || pSub -> pLimit ) 
line 81607: && ( pSrc -> nSrc > 1 || isAgg ) ) { 
line 81608: return 0 ; 
line 81609: } 
line 81610: if ( ( p -> selFlags & SF_Distinct ) != 0 && subqueryIsAgg ) { 
line 81611: return 0 ; 
line 81612: } 
line 81613: if ( p -> pOrderBy && pSub -> pOrderBy ) { 
line 81614: return 0 ; 
line 81615: } 
line 81616: if ( isAgg && pSub -> pOrderBy ) return 0 ; 
line 81617: if ( pSub -> pLimit && p -> pWhere ) return 0 ; 
line 81651: if ( ( pSubitem -> jointype & JT_OUTER ) != 0 ) { 
line 81652: return 0 ; 
line 81653: } 
line 81660: if ( pSub -> pPrior ) { 
line 81661: if ( pSub -> pOrderBy ) { 
line 81662: return 0 ; 
line 81663: } 
line 81664: if ( isAgg || ( p -> selFlags & SF_Distinct ) != 0 || pSrc -> nSrc != 1 ) { 
line 81665: return 0 ; 
line 81666: } 
line 81667: for ( pSub1 = pSub ; pSub1 ; pSub1 = pSub1 -> pPrior ) { 
line 81668: testcase ( ( pSub1 -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct ) ; 
line 81669: testcase ( ( pSub1 -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Aggregate ) ; 
line 81670: if ( ( pSub1 -> selFlags & ( SF_Distinct | SF_Aggregate ) ) != 0 
line 81671: || ( pSub1 -> pPrior && pSub1 -> op != TK_ALL ) 
line 81672: || NEVER ( pSub1 -> pSrc == 0 ) || pSub1 -> pSrc -> nSrc != 1 
line 81673: ) { 
line 81674: return 0 ; 
line 81675: } 
line 81676: } 
line 81679: if ( p -> pOrderBy ) { 
line 81680: int ii ; 
line 81681: for ( ii = 0 ; ii < p -> pOrderBy -> nExpr ; ii ++ ) { 
line 81682: if ( p -> pOrderBy -> a [ ii ] . iCol == 0 ) return 0 ; 
line 81683: } 
line 81684: } 
line 81685: } 
line 81690: pParse -> zAuthContext = pSubitem -> zName ; 
line 81691: sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) ; 
line 81692: pParse -> zAuthContext = zSavedAuthContext ; 
line 81727: for ( pSub = pSub -> pPrior ; pSub ; pSub = pSub -> pPrior ) { 
line 81728: Select * pNew ; 
line 81729: ExprList * pOrderBy = p -> pOrderBy ; 
line 81730: Expr * pLimit = p -> pLimit ; 
line 81731: Select * pPrior = p -> pPrior ; 
line 81732: p -> pOrderBy = 0 ; 
line 81733: p -> pSrc = 0 ; 
line 81734: p -> pPrior = 0 ; 
line 81735: p -> pLimit = 0 ; 
line 81736: pNew = sqlite3SelectDup ( db , p , 0 ) ; 
line 81737: p -> pLimit = pLimit ; 
line 81738: p -> pOrderBy = pOrderBy ; 
line 81739: p -> pSrc = pSrc ; 
line 81740: p -> op = TK_ALL ; 
line 81741: p -> pRightmost = 0 ; 
line 81742: if ( pNew == 0 ) { 
line 81743: pNew = pPrior ; 
line 81744: } else { 
line 81745: pNew -> pPrior = pPrior ; 
line 81746: pNew -> pRightmost = 0 ; 
line 81747: } 
line 81748: p -> pPrior = pNew ; 
line 81749: if ( db -> mallocFailed ) return 1 ; 
line 81750: } 
line 81755: pSub = pSub1 = pSubitem -> pSelect ; 
line 81760: sqlite3DbFree ( db , pSubitem -> zDatabase ) ; 
line 81761: sqlite3DbFree ( db , pSubitem -> zName ) ; 
line 81762: sqlite3DbFree ( db , pSubitem -> zAlias ) ; 
line 81763: pSubitem -> zDatabase = 0 ; 
line 81764: pSubitem -> zName = 0 ; 
line 81765: pSubitem -> zAlias = 0 ; 
line 81766: pSubitem -> pSelect = 0 ; 
line 81775: if ( ALWAYS ( pSubitem -> pTab != 0 ) ) { 
line 81776: Table * pTabToDel = pSubitem -> pTab ; 
line 81777: if ( pTabToDel -> nRef == 1 ) { 
line 81778: Parse * pToplevel = sqlite3ParseToplevel ( pParse ) ; 
line 81779: pTabToDel -> pNextZombie = pToplevel -> pZombieTab ; 
line 81780: pToplevel -> pZombieTab = pTabToDel ; 
line 81781: } else { 
line 81782: pTabToDel -> nRef -- ; 
line 81783: } 
line 81784: pSubitem -> pTab = 0 ; 
line 81785: } 
line 81800: for ( pParent = p ; pParent ; pParent = pParent -> pPrior , pSub = pSub -> pPrior ) { 
line 81801: int nSubSrc ; 
line 81802: u8 jointype = 0 ; 
line 81803: pSubSrc = pSub -> pSrc ; 
line 81804: nSubSrc = pSubSrc -> nSrc ; 
line 81805: pSrc = pParent -> pSrc ; 
line 81807: if ( pSrc ) { 
line 81808: assert ( pParent == p ) ; 
line 81809: jointype = pSubitem -> jointype ; 
line 81810: } else { 
line 81811: assert ( pParent != p ) ; 
line 81812: pSrc = pParent -> pSrc = sqlite3SrcListAppend ( db , 0 , 0 , 0 ) ; 
line 81813: if ( pSrc == 0 ) { 
line 81814: assert ( db -> mallocFailed ) ; 
line 81815: break ; 
line 81816: } 
line 81817: } 
line 81834: if ( nSubSrc > 1 ) { 
line 81835: pParent -> pSrc = pSrc = sqlite3SrcListEnlarge ( db , pSrc , nSubSrc - 1 , iFrom + 1 ) ; 
line 81836: if ( db -> mallocFailed ) { 
line 81837: break ; 
line 81838: } 
line 81839: } 
line 81844: for ( i = 0 ; i < nSubSrc ; i ++ ) { 
line 81845: sqlite3IdListDelete ( db , pSrc -> a [ i + iFrom ] . pUsing ) ; 
line 81846: pSrc -> a [ i + iFrom ] = pSubSrc -> a [ i ] ; 
line 81847: memset ( & pSubSrc -> a [ i ] , 0 , sizeof ( pSubSrc -> a [ i ] ) ) ; 
line 81848: } 
line 81849: pSrc -> a [ iFrom ] . jointype = jointype ; 
line 81863: pList = pParent -> pEList ; 
line 81864: for ( i = 0 ; i < pList -> nExpr ; i ++ ) { 
line 81865: if ( pList -> a [ i ] . zName == 0 ) { 
line 81866: const char * zSpan = pList -> a [ i ] . zSpan ; 
line 81867: if ( ALWAYS ( zSpan ) ) { 
line 81868: pList -> a [ i ] . zName = sqlite3DbStrDup ( db , zSpan ) ; 
line 81869: } 
line 81870: } 
line 81871: } 
line 81872: substExprList ( db , pParent -> pEList , iParent , pSub -> pEList ) ; 
line 81873: if ( isAgg ) { 
line 81874: substExprList ( db , pParent -> pGroupBy , iParent , pSub -> pEList ) ; 
line 81875: pParent -> pHaving = substExpr ( db , pParent -> pHaving , iParent , pSub -> pEList ) ; 
line 81876: } 
line 81877: if ( pSub -> pOrderBy ) { 
line 81878: assert ( pParent -> pOrderBy == 0 ) ; 
line 81879: pParent -> pOrderBy = pSub -> pOrderBy ; 
line 81880: pSub -> pOrderBy = 0 ; 
line 81881: } else if ( pParent -> pOrderBy ) { 
line 81882: substExprList ( db , pParent -> pOrderBy , iParent , pSub -> pEList ) ; 
line 81883: } 
line 81884: if ( pSub -> pWhere ) { 
line 81885: pWhere = sqlite3ExprDup ( db , pSub -> pWhere , 0 ) ; 
line 81886: } else { 
line 81887: pWhere = 0 ; 
line 81888: } 
line 81889: if ( subqueryIsAgg ) { 
line 81890: assert ( pParent -> pHaving == 0 ) ; 
line 81891: pParent -> pHaving = pParent -> pWhere ; 
line 81892: pParent -> pWhere = pWhere ; 
line 81893: pParent -> pHaving = substExpr ( db , pParent -> pHaving , iParent , pSub -> pEList ) ; 
line 81894: pParent -> pHaving = sqlite3ExprAnd ( db , pParent -> pHaving , 
line 81895: sqlite3ExprDup ( db , pSub -> pHaving , 0 ) ) ; 
line 81896: assert ( pParent -> pGroupBy == 0 ) ; 
line 81897: pParent -> pGroupBy = sqlite3ExprListDup ( db , pSub -> pGroupBy , 0 ) ; 
line 81898: } else { 
line 81899: pParent -> pWhere = substExpr ( db , pParent -> pWhere , iParent , pSub -> pEList ) ; 
line 81900: pParent -> pWhere = sqlite3ExprAnd ( db , pParent -> pWhere , pWhere ) ; 
line 81901: } 
line 81906: pParent -> selFlags |= pSub -> selFlags & SF_Distinct ; 
line 81914: if ( pSub -> pLimit ) { 
line 81915: pParent -> pLimit = pSub -> pLimit ; 
line 81916: pSub -> pLimit = 0 ; 
line 81917: } 
line 81918: } 
line 81923: sqlite3SelectDelete ( db , pSub1 ) ; 
line 81925: return 1 ; 
line 81926: } 
line 81927: # endif 
line 81940: static u8 minMaxQuery ( Select * p ) { 
line 81941: Expr * pExpr ; 
line 81942: ExprList * pEList = p -> pEList ; 
line 81944: if ( pEList -> nExpr != 1 ) return WHERE_ORDERBY_NORMAL ; 
line 81945: pExpr = pEList -> a [ 0 ] . pExpr ; 
line 81946: if ( pExpr -> op != TK_AGG_FUNCTION ) return 0 ; 
line 81947: if ( NEVER ( ExprHasProperty ( pExpr , EP_xIsSelect ) ) ) return 0 ; 
line 81948: pEList = pExpr -> x . pList ; 
line 81949: if ( pEList == 0 || pEList -> nExpr != 1 ) return 0 ; 
line 81950: if ( pEList -> a [ 0 ] . pExpr -> op != TK_AGG_COLUMN ) return WHERE_ORDERBY_NORMAL ; 
line 81951: assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; 
line 81952: if ( sqlite3StrICmp ( pExpr -> u . zToken , "min" ) == 0 ) { 
line 81953: return WHERE_ORDERBY_MIN ; 
line 81954: } else if ( sqlite3StrICmp ( pExpr -> u . zToken , "max" ) == 0 ) { 
line 81955: return WHERE_ORDERBY_MAX ; 
line 81956: } 
line 81957: return WHERE_ORDERBY_NORMAL ; 
line 81958: } 
line 81971: static Table * isSimpleCount ( Select * p , AggInfo * pAggInfo ) { 
line 81972: Table * pTab ; 
line 81973: Expr * pExpr ; 
line 81975: assert ( ! p -> pGroupBy ) ; 
line 81977: if ( p -> pWhere || p -> pEList -> nExpr != 1 
line 81978: || p -> pSrc -> nSrc != 1 || p -> pSrc -> a [ 0 ] . pSelect 
line 81979: ) { 
line 81980: return 0 ; 
line 81981: } 
line 81982: pTab = p -> pSrc -> a [ 0 ] . pTab ; 
line 81983: pExpr = p -> pEList -> a [ 0 ] . pExpr ; 
line 81984: assert ( pTab && ! pTab -> pSelect && pExpr ) ; 
line 81986: if ( IsVirtual ( pTab ) ) return 0 ; 
line 81987: if ( pExpr -> op != TK_AGG_FUNCTION ) return 0 ; 
line 81988: if ( ( pAggInfo -> aFunc [ 0 ] . pFunc -> flags & SQLITE_FUNC_COUNT ) == 0 ) return 0 ; 
line 81989: if ( pExpr -> flags & EP_Distinct ) return 0 ; 
line 81991: return pTab ; 
line 81992: } 
line 82001: SQLITE_PRIVATE int sqlite3IndexedByLookup ( Parse * pParse , struct SrcList_item * pFrom ) { 
line 82002: if ( pFrom -> pTab && pFrom -> zIndex ) { 
line 82003: Table * pTab = pFrom -> pTab ; 
line 82004: char * zIndex = pFrom -> zIndex ; 
line 82005: Index * pIdx ; 
line 82006: for ( pIdx = pTab -> pIndex ; 
line 82007: pIdx && sqlite3StrICmp ( pIdx -> zName , zIndex ) ; 
line 82008: pIdx = pIdx -> pNext 
line 82009: ) ; 
line 82010: if ( ! pIdx ) { 
line 82011: sqlite3ErrorMsg ( pParse , "no such index: %s" , zIndex , 0 ) ; 
line 82012: return SQLITE_ERROR ; 
line 82013: } 
line 82014: pFrom -> pIndex = pIdx ; 
line 82015: } 
line 82016: return SQLITE_OK ; 
line 82017: } 
line 82043: static int selectExpander ( Walker * pWalker , Select * p ) { 
line 82044: Parse * pParse = pWalker -> pParse ; 
line 82045: int i , j , k ; 
line 82046: SrcList * pTabList ; 
line 82047: ExprList * pEList ; 
line 82048: struct SrcList_item * pFrom ; 
line 82049: sqlite3 * db = pParse -> db ; 
line 82051: if ( db -> mallocFailed ) { 
line 82052: return WRC_Abort ; 
line 82053: } 
line 82054: if ( NEVER ( p -> pSrc == 0 ) || ( p -> selFlags & SF_Expanded ) != 0 ) { 
line 82055: return WRC_Prune ; 
line 82056: } 
line 82057: p -> selFlags |= SF_Expanded ; 
line 82058: pTabList = p -> pSrc ; 
line 82059: pEList = p -> pEList ; 
line 82064: sqlite3SrcListAssignCursors ( pParse , pTabList ) ; 
line 82070: for ( i = 0 , pFrom = pTabList -> a ; i < pTabList -> nSrc ; i ++ , pFrom ++ ) { 
line 82071: Table * pTab ; 
line 82072: if ( pFrom -> pTab != 0 ) { 
line 82075: assert ( i == 0 ) ; 
line 82076: return WRC_Prune ; 
line 82077: } 
line 82078: if ( pFrom -> zName == 0 ) { 
line 82079: # ifndef SQLITE_OMIT_SUBQUERY 
line 82080: Select * pSel = pFrom -> pSelect ; 
line 82082: assert ( pSel != 0 ) ; 
line 82083: assert ( pFrom -> pTab == 0 ) ; 
line 82084: sqlite3WalkSelect ( pWalker , pSel ) ; 
line 82085: pFrom -> pTab = pTab = sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; 
line 82086: if ( pTab == 0 ) return WRC_Abort ; 
line 82087: pTab -> dbMem = db -> lookaside . bEnabled ? db : 0 ; 
line 82088: pTab -> nRef = 1 ; 
line 82089: pTab -> zName = sqlite3MPrintf ( db , "sqlite_subquery_%p_" , ( void * ) pTab ) ; 
line 82090: while ( pSel -> pPrior ) { pSel = pSel -> pPrior ; } 
line 82091: selectColumnsFromExprList ( pParse , pSel -> pEList , & pTab -> nCol , & pTab -> aCol ) ; 
line 82092: pTab -> iPKey = - 1 ; 
line 82093: pTab -> tabFlags |= TF_Ephemeral ; 
line 82094: # endif 
line 82095: } else { 
line 82097: assert ( pFrom -> pTab == 0 ) ; 
line 82098: pFrom -> pTab = pTab = 
line 82099: sqlite3LocateTable ( pParse , 0 , pFrom -> zName , pFrom -> zDatabase ) ; 
line 82100: if ( pTab == 0 ) return WRC_Abort ; 
line 82101: pTab -> nRef ++ ; 
line 82102: # if ! defined ( SQLITE_OMIT_VIEW ) || ! defined ( SQLITE_OMIT_VIRTUALTABLE ) 
line 82103: if ( pTab -> pSelect || IsVirtual ( pTab ) ) { 
line 82105: if ( sqlite3ViewGetColumnNames ( pParse , pTab ) ) return WRC_Abort ; 
line 82106: assert ( pFrom -> pSelect == 0 ) ; 
line 82107: pFrom -> pSelect = sqlite3SelectDup ( db , pTab -> pSelect , 0 ) ; 
line 82108: sqlite3WalkSelect ( pWalker , pFrom -> pSelect ) ; 
line 82109: } 
line 82110: # endif 
line 82111: } 
line 82114: if ( sqlite3IndexedByLookup ( pParse , pFrom ) ) { 
line 82115: return WRC_Abort ; 
line 82116: } 
line 82117: } 
line 82121: if ( db -> mallocFailed || sqliteProcessJoin ( pParse , p ) ) { 
line 82122: return WRC_Abort ; 
line 82123: } 
line 82135: for ( k = 0 ; k < pEList -> nExpr ; k ++ ) { 
line 82136: Expr * pE = pEList -> a [ k ] . pExpr ; 
line 82137: if ( pE -> op == TK_ALL ) break ; 
line 82138: assert ( pE -> op != TK_DOT || pE -> pRight != 0 ) ; 
line 82139: assert ( pE -> op != TK_DOT || ( pE -> pLeft != 0 && pE -> pLeft -> op == TK_ID ) ) ; 
line 82140: if ( pE -> op == TK_DOT && pE -> pRight -> op == TK_ALL ) break ; 
line 82141: } 
line 82142: if ( k < pEList -> nExpr ) { 
line 82148: struct ExprList_item * a = pEList -> a ; 
line 82149: ExprList * pNew = 0 ; 
line 82150: int flags = pParse -> db -> flags ; 
line 82151: int longNames = ( flags & SQLITE_FullColNames ) != 0 
line 82152: && ( flags & SQLITE_ShortColNames ) == 0 ; 
line 82154: for ( k = 0 ; k < pEList -> nExpr ; k ++ ) { 
line 82155: Expr * pE = a [ k ] . pExpr ; 
line 82156: assert ( pE -> op != TK_DOT || pE -> pRight != 0 ) ; 
line 82157: if ( pE -> op != TK_ALL && ( pE -> op != TK_DOT || pE -> pRight -> op != TK_ALL ) ) { 
line 82160: pNew = sqlite3ExprListAppend ( pParse , pNew , a [ k ] . pExpr ) ; 
line 82161: if ( pNew ) { 
line 82162: pNew -> a [ pNew -> nExpr - 1 ] . zName = a [ k ] . zName ; 
line 82163: pNew -> a [ pNew -> nExpr - 1 ] . zSpan = a [ k ] . zSpan ; 
line 82164: a [ k ] . zName = 0 ; 
line 82165: a [ k ] . zSpan = 0 ; 
line 82166: } 
line 82167: a [ k ] . pExpr = 0 ; 
line 82168: } else { 
line 82171: int tableSeen = 0 ; 
line 82172: char * zTName ; 
line 82173: if ( pE -> op == TK_DOT ) { 
line 82174: assert ( pE -> pLeft != 0 ) ; 
line 82175: assert ( ! ExprHasProperty ( pE -> pLeft , EP_IntValue ) ) ; 
line 82176: zTName = pE -> pLeft -> u . zToken ; 
line 82177: } else { 
line 82178: zTName = 0 ; 
line 82179: } 
line 82180: for ( i = 0 , pFrom = pTabList -> a ; i < pTabList -> nSrc ; i ++ , pFrom ++ ) { 
line 82181: Table * pTab = pFrom -> pTab ; 
line 82182: char * zTabName = pFrom -> zAlias ; 
line 82183: if ( zTabName == 0 ) { 
line 82184: zTabName = pTab -> zName ; 
line 82185: } 
line 82186: if ( db -> mallocFailed ) break ; 
line 82187: if ( zTName && sqlite3StrICmp ( zTName , zTabName ) != 0 ) { 
line 82188: continue ; 
line 82189: } 
line 82190: tableSeen = 1 ; 
line 82191: for ( j = 0 ; j < pTab -> nCol ; j ++ ) { 
line 82192: Expr * pExpr , * pRight ; 
line 82193: char * zName = pTab -> aCol [ j ] . zName ; 
line 82194: char * zColname ; 
line 82195: char * zToFree ; 
line 82196: Token sColname ; 
line 82202: if ( IsHiddenColumn ( & pTab -> aCol [ j ] ) ) { 
line 82203: assert ( IsVirtual ( pTab ) ) ; 
line 82204: continue ; 
line 82205: } 
line 82207: if ( i > 0 && zTName == 0 ) { 
line 82208: if ( ( pFrom -> jointype & JT_NATURAL ) != 0 
line 82209: && tableAndColumnIndex ( pTabList , i , zName , 0 , 0 ) 
line 82210: ) { 
line 82213: continue ; 
line 82214: } 
line 82215: if ( sqlite3IdListIndex ( pFrom -> pUsing , zName ) >= 0 ) { 
line 82218: continue ; 
line 82219: } 
line 82220: } 
line 82221: pRight = sqlite3Expr ( db , TK_ID , zName ) ; 
line 82222: zColname = zName ; 
line 82223: zToFree = 0 ; 
line 82224: if ( longNames || pTabList -> nSrc > 1 ) { 
line 82225: Expr * pLeft ; 
line 82226: pLeft = sqlite3Expr ( db , TK_ID , zTabName ) ; 
line 82227: pExpr = sqlite3PExpr ( pParse , TK_DOT , pLeft , pRight , 0 ) ; 
line 82228: if ( longNames ) { 
line 82229: zColname = sqlite3MPrintf ( db , "%s.%s" , zTabName , zName ) ; 
line 82230: zToFree = zColname ; 
line 82231: } 
line 82232: } else { 
line 82233: pExpr = pRight ; 
line 82234: } 
line 82235: pNew = sqlite3ExprListAppend ( pParse , pNew , pExpr ) ; 
line 82236: sColname . z = zColname ; 
line 82237: sColname . n = sqlite3Strlen30 ( zColname ) ; 
line 82238: sqlite3ExprListSetName ( pParse , pNew , & sColname , 0 ) ; 
line 82239: sqlite3DbFree ( db , zToFree ) ; 
line 82240: } 
line 82241: } 
line 82242: if ( ! tableSeen ) { 
line 82243: if ( zTName ) { 
line 82244: sqlite3ErrorMsg ( pParse , "no such table: %s" , zTName ) ; 
line 82245: } else { 
line 82246: sqlite3ErrorMsg ( pParse , "no tables specified" ) ; 
line 82247: } 
line 82248: } 
line 82249: } 
line 82250: } 
line 82251: sqlite3ExprListDelete ( db , pEList ) ; 
line 82252: p -> pEList = pNew ; 
line 82253: } 
line 82254: # if SQLITE_MAX_COLUMN 
line 82255: if ( p -> pEList && p -> pEList -> nExpr > db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) { 
line 82256: sqlite3ErrorMsg ( pParse , "too many columns in result set" ) ; 
line 82257: } 
line 82258: # endif 
line 82259: return WRC_Continue ; 
line 82260: } 
line 82271: static int exprWalkNoop ( Walker * NotUsed , Expr * NotUsed2 ) { 
line 82272: UNUSED_PARAMETER2 ( NotUsed , NotUsed2 ) ; 
line 82273: return WRC_Continue ; 
line 82274: } 
line 82289: static void sqlite3SelectExpand ( Parse * pParse , Select * pSelect ) { 
line 82290: Walker w ; 
line 82291: w . xSelectCallback = selectExpander ; 
line 82292: w . xExprCallback = exprWalkNoop ; 
line 82293: w . pParse = pParse ; 
line 82294: sqlite3WalkSelect ( & w , pSelect ) ; 
line 82295: } 
line 82298: # ifndef SQLITE_OMIT_SUBQUERY 
line 82312: static int selectAddSubqueryTypeInfo ( Walker * pWalker , Select * p ) { 
line 82313: Parse * pParse ; 
line 82314: int i ; 
line 82315: SrcList * pTabList ; 
line 82316: struct SrcList_item * pFrom ; 
line 82318: assert ( p -> selFlags & SF_Resolved ) ; 
line 82319: assert ( ( p -> selFlags & SF_HasTypeInfo ) == 0 ) ; 
line 82320: p -> selFlags |= SF_HasTypeInfo ; 
line 82321: pParse = pWalker -> pParse ; 
line 82322: pTabList = p -> pSrc ; 
line 82323: for ( i = 0 , pFrom = pTabList -> a ; i < pTabList -> nSrc ; i ++ , pFrom ++ ) { 
line 82324: Table * pTab = pFrom -> pTab ; 
line 82325: if ( ALWAYS ( pTab != 0 ) && ( pTab -> tabFlags & TF_Ephemeral ) != 0 ) { 
line 82327: Select * pSel = pFrom -> pSelect ; 
line 82328: assert ( pSel ) ; 
line 82329: while ( pSel -> pPrior ) pSel = pSel -> pPrior ; 
line 82330: selectAddColumnTypeAndCollation ( pParse , pTab -> nCol , pTab -> aCol , pSel ) ; 
line 82331: } 
line 82332: } 
line 82333: return WRC_Continue ; 
line 82334: } 
line 82335: # endif 
line 82345: static void sqlite3SelectAddTypeInfo ( Parse * pParse , Select * pSelect ) { 
line 82346: # ifndef SQLITE_OMIT_SUBQUERY 
line 82347: Walker w ; 
line 82348: w . xSelectCallback = selectAddSubqueryTypeInfo ; 
line 82349: w . xExprCallback = exprWalkNoop ; 
line 82350: w . pParse = pParse ; 
line 82351: sqlite3WalkSelect ( & w , pSelect ) ; 
line 82352: # endif 
line 82353: } 
line 82368: SQLITE_PRIVATE void sqlite3SelectPrep ( 
line 82369: Parse * pParse , 
line 82370: Select * p , 
line 82371: NameContext * pOuterNC 
line 82372: ) { 
line 82373: sqlite3 * db ; 
line 82374: if ( NEVER ( p == 0 ) ) return ; 
line 82375: db = pParse -> db ; 
line 82376: if ( p -> selFlags & SF_HasTypeInfo ) return ; 
line 82377: sqlite3SelectExpand ( pParse , p ) ; 
line 82378: if ( pParse -> nErr || db -> mallocFailed ) return ; 
line 82379: sqlite3ResolveSelectNames ( pParse , p , pOuterNC ) ; 
line 82380: if ( pParse -> nErr || db -> mallocFailed ) return ; 
line 82381: sqlite3SelectAddTypeInfo ( pParse , p ) ; 
line 82382: } 
line 82391: static void resetAccumulator ( Parse * pParse , AggInfo * pAggInfo ) { 
line 82392: Vdbe * v = pParse -> pVdbe ; 
line 82393: int i ; 
line 82394: struct AggInfo_func * pFunc ; 
line 82395: if ( pAggInfo -> nFunc + pAggInfo -> nColumn == 0 ) { 
line 82396: return ; 
line 82397: } 
line 82398: for ( i = 0 ; i < pAggInfo -> nColumn ; i ++ ) { 
line 82399: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , pAggInfo -> aCol [ i ] . iMem ) ; 
line 82400: } 
line 82401: for ( pFunc = pAggInfo -> aFunc , i = 0 ; i < pAggInfo -> nFunc ; i ++ , pFunc ++ ) { 
line 82402: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , pFunc -> iMem ) ; 
line 82403: if ( pFunc -> iDistinct >= 0 ) { 
line 82404: Expr * pE = pFunc -> pExpr ; 
line 82405: assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ) ; 
line 82406: if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 ) { 
line 82407: sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one " 
line 82408: "argument" ) ; 
line 82409: pFunc -> iDistinct = - 1 ; 
line 82410: } else { 
line 82411: KeyInfo * pKeyInfo = keyInfoFromExprList ( pParse , pE -> x . pList ) ; 
line 82412: sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , 
line 82413: ( char * ) pKeyInfo , P4_KEYINFO_HANDOFF ) ; 
line 82414: } 
line 82415: } 
line 82416: } 
line 82417: } 
line 82423: static void finalizeAggFunctions ( Parse * pParse , AggInfo * pAggInfo ) { 
line 82424: Vdbe * v = pParse -> pVdbe ; 
line 82425: int i ; 
line 82426: struct AggInfo_func * pF ; 
line 82427: for ( i = 0 , pF = pAggInfo -> aFunc ; i < pAggInfo -> nFunc ; i ++ , pF ++ ) { 
line 82428: ExprList * pList = pF -> pExpr -> x . pList ; 
line 82429: assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ) ; 
line 82430: sqlite3VdbeAddOp4 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 , 0 , 
line 82431: ( void * ) pF -> pFunc , P4_FUNCDEF ) ; 
line 82432: } 
line 82433: } 
line 82439: static void updateAccumulator ( Parse * pParse , AggInfo * pAggInfo ) { 
line 82440: Vdbe * v = pParse -> pVdbe ; 
line 82441: int i ; 
line 82442: struct AggInfo_func * pF ; 
line 82443: struct AggInfo_col * pC ; 
line 82445: pAggInfo -> directMode = 1 ; 
line 82446: sqlite3ExprCacheClear ( pParse ) ; 
line 82447: for ( i = 0 , pF = pAggInfo -> aFunc ; i < pAggInfo -> nFunc ; i ++ , pF ++ ) { 
line 82448: int nArg ; 
line 82449: int addrNext = 0 ; 
line 82450: int regAgg ; 
line 82451: ExprList * pList = pF -> pExpr -> x . pList ; 
line 82452: assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ) ; 
line 82453: if ( pList ) { 
line 82454: nArg = pList -> nExpr ; 
line 82455: regAgg = sqlite3GetTempRange ( pParse , nArg ) ; 
line 82456: sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 ) ; 
line 82457: } else { 
line 82458: nArg = 0 ; 
line 82459: regAgg = 0 ; 
line 82460: } 
line 82461: if ( pF -> iDistinct >= 0 ) { 
line 82462: addrNext = sqlite3VdbeMakeLabel ( v ) ; 
line 82463: assert ( nArg == 1 ) ; 
line 82464: codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ) ; 
line 82465: } 
line 82466: if ( pF -> pFunc -> flags & SQLITE_FUNC_NEEDCOLL ) { 
line 82467: CollSeq * pColl = 0 ; 
line 82468: struct ExprList_item * pItem ; 
line 82469: int j ; 
line 82470: assert ( pList != 0 ) ; 
line 82471: for ( j = 0 , pItem = pList -> a ; ! pColl && j < nArg ; j ++ , pItem ++ ) { 
line 82472: pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ) ; 
line 82473: } 
line 82474: if ( ! pColl ) { 
line 82475: pColl = pParse -> db -> pDfltColl ; 
line 82476: } 
line 82477: sqlite3VdbeAddOp4 ( v , OP_CollSeq , 0 , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ) ; 
line 82478: } 
line 82479: sqlite3VdbeAddOp4 ( v , OP_AggStep , 0 , regAgg , pF -> iMem , 
line 82480: ( void * ) pF -> pFunc , P4_FUNCDEF ) ; 
line 82481: sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ) ; 
line 82482: sqlite3ExprCacheAffinityChange ( pParse , regAgg , nArg ) ; 
line 82483: sqlite3ReleaseTempRange ( pParse , regAgg , nArg ) ; 
line 82484: if ( addrNext ) { 
line 82485: sqlite3VdbeResolveLabel ( v , addrNext ) ; 
line 82486: sqlite3ExprCacheClear ( pParse ) ; 
line 82487: } 
line 82488: } 
line 82489: for ( i = 0 , pC = pAggInfo -> aCol ; i < pAggInfo -> nAccumulator ; i ++ , pC ++ ) { 
line 82490: sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ) ; 
line 82491: } 
line 82492: pAggInfo -> directMode = 0 ; 
line 82493: sqlite3ExprCacheClear ( pParse ) ; 
line 82494: } 
line 82550: SQLITE_PRIVATE int sqlite3Select ( 
line 82551: Parse * pParse , 
line 82552: Select * p , 
line 82553: SelectDest * pDest 
line 82554: ) { 
line 82555: int i , j ; 
line 82556: WhereInfo * pWInfo ; 
line 82557: Vdbe * v ; 
line 82558: int isAgg ; 
line 82559: ExprList * pEList ; 
line 82560: SrcList * pTabList ; 
line 82561: Expr * pWhere ; 
line 82562: ExprList * pOrderBy ; 
line 82563: ExprList * pGroupBy ; 
line 82564: Expr * pHaving ; 
line 82565: int isDistinct ; 
line 82566: int distinct ; 
line 82567: int rc = 1 ; 
line 82568: int addrSortIndex ; 
line 82569: AggInfo sAggInfo ; 
line 82570: int iEnd ; 
line 82571: sqlite3 * db ; 
line 82573: db = pParse -> db ; 
line 82574: if ( p == 0 || db -> mallocFailed || pParse -> nErr ) { 
line 82575: return 1 ; 
line 82576: } 
line 82577: if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) ) return 1 ; 
line 82578: memset ( & sAggInfo , 0 , sizeof ( sAggInfo ) ) ; 
line 82580: if ( IgnorableOrderby ( pDest ) ) { 
line 82581: assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || 
line 82582: pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard ) ; 
line 82585: sqlite3ExprListDelete ( db , p -> pOrderBy ) ; 
line 82586: p -> pOrderBy = 0 ; 
line 82587: p -> selFlags &= ~ SF_Distinct ; 
line 82588: } 
line 82589: sqlite3SelectPrep ( pParse , p , 0 ) ; 
line 82590: pOrderBy = p -> pOrderBy ; 
line 82591: pTabList = p -> pSrc ; 
line 82592: pEList = p -> pEList ; 
line 82593: if ( pParse -> nErr || db -> mallocFailed ) { 
line 82594: goto select_end ; 
line 82595: } 
line 82596: isAgg = ( p -> selFlags & SF_Aggregate ) != 0 ; 
line 82597: assert ( pEList != 0 ) ; 
line 82601: v = sqlite3GetVdbe ( pParse ) ; 
line 82602: if ( v == 0 ) goto select_end ; 
line 82606: # if ! defined ( SQLITE_OMIT_SUBQUERY ) || ! defined ( SQLITE_OMIT_VIEW ) 
line 82607: for ( i = 0 ; ! p -> pPrior && i < pTabList -> nSrc ; i ++ ) { 
line 82608: struct SrcList_item * pItem = & pTabList -> a [ i ] ; 
line 82609: SelectDest dest ; 
line 82610: Select * pSub = pItem -> pSelect ; 
line 82611: int isAggSub ; 
line 82613: if ( pSub == 0 || pItem -> isPopulated ) continue ; 
line 82622: pParse -> nHeight += sqlite3SelectExprHeight ( p ) ; 
line 82625: isAggSub = ( pSub -> selFlags & SF_Aggregate ) != 0 ; 
line 82626: if ( flattenSubquery ( pParse , p , i , isAgg , isAggSub ) ) { 
line 82627: if ( isAggSub ) { 
line 82628: isAgg = 1 ; 
line 82629: p -> selFlags |= SF_Aggregate ; 
line 82630: } 
line 82631: i = - 1 ; 
line 82632: } else { 
line 82633: sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ) ; 
line 82634: assert ( pItem -> isPopulated == 0 ) ; 
line 82635: sqlite3Select ( pParse , pSub , & dest ) ; 
line 82636: pItem -> isPopulated = 1 ; 
line 82637: } 
line 82638: if ( db -> mallocFailed ) { 
line 82639: goto select_end ; 
line 82640: } 
line 82641: pParse -> nHeight -= sqlite3SelectExprHeight ( p ) ; 
line 82642: pTabList = p -> pSrc ; 
line 82643: if ( ! IgnorableOrderby ( pDest ) ) { 
line 82644: pOrderBy = p -> pOrderBy ; 
line 82645: } 
line 82646: } 
line 82647: pEList = p -> pEList ; 
line 82648: # endif 
line 82649: pWhere = p -> pWhere ; 
line 82650: pGroupBy = p -> pGroupBy ; 
line 82651: pHaving = p -> pHaving ; 
line 82652: isDistinct = ( p -> selFlags & SF_Distinct ) != 0 ; 
line 82654: # ifndef SQLITE_OMIT_COMPOUND_SELECT 
line 82657: if ( p -> pPrior ) { 
line 82658: if ( p -> pRightmost == 0 ) { 
line 82659: Select * pLoop , * pRight = 0 ; 
line 82660: int cnt = 0 ; 
line 82661: int mxSelect ; 
line 82662: for ( pLoop = p ; pLoop ; pLoop = pLoop -> pPrior , cnt ++ ) { 
line 82663: pLoop -> pRightmost = p ; 
line 82664: pLoop -> pNext = pRight ; 
line 82665: pRight = pLoop ; 
line 82666: } 
line 82667: mxSelect = db -> aLimit [ SQLITE_LIMIT_COMPOUND_SELECT ] ; 
line 82668: if ( mxSelect && cnt > mxSelect ) { 
line 82669: sqlite3ErrorMsg ( pParse , "too many terms in compound SELECT" ) ; 
line 82670: return 1 ; 
line 82671: } 
line 82672: } 
line 82673: return multiSelect ( pParse , p , pDest ) ; 
line 82674: } 
line 82675: # endif 
line 82680: # ifndef SQLITE_OMIT_SUBQUERY 
line 82681: if ( checkForMultiColumnSelectError ( pParse , pDest , pEList -> nExpr ) ) { 
line 82682: goto select_end ; 
line 82683: } 
line 82684: # endif 
line 82689: assert ( p -> pGroupBy == 0 || ( p -> selFlags & SF_Aggregate ) != 0 ) ; 
line 82690: if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct ) { 
line 82691: p -> pGroupBy = sqlite3ExprListDup ( db , p -> pEList , 0 ) ; 
line 82692: pGroupBy = p -> pGroupBy ; 
line 82693: p -> selFlags &= ~ SF_Distinct ; 
line 82694: isDistinct = 0 ; 
line 82695: } 
line 82704: if ( pOrderBy ) { 
line 82705: KeyInfo * pKeyInfo ; 
line 82706: pKeyInfo = keyInfoFromExprList ( pParse , pOrderBy ) ; 
line 82707: pOrderBy -> iECursor = pParse -> nTab ++ ; 
line 82708: p -> addrOpenEphm [ 2 ] = addrSortIndex = 
line 82709: sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , 
line 82710: pOrderBy -> iECursor , pOrderBy -> nExpr + 2 , 0 , 
line 82711: ( char * ) pKeyInfo , P4_KEYINFO_HANDOFF ) ; 
line 82712: } else { 
line 82713: addrSortIndex = - 1 ; 
line 82714: } 
line 82718: if ( pDest -> eDest == SRT_EphemTab ) { 
line 82719: sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iParm , pEList -> nExpr ) ; 
line 82720: } 
line 82724: iEnd = sqlite3VdbeMakeLabel ( v ) ; 
line 82725: computeLimitRegisters ( pParse , p , iEnd ) ; 
line 82729: if ( isDistinct ) { 
line 82730: KeyInfo * pKeyInfo ; 
line 82731: assert ( isAgg || pGroupBy ) ; 
line 82732: distinct = pParse -> nTab ++ ; 
line 82733: pKeyInfo = keyInfoFromExprList ( pParse , p -> pEList ) ; 
line 82734: sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , distinct , 0 , 0 , 
line 82735: ( char * ) pKeyInfo , P4_KEYINFO_HANDOFF ) ; 
line 82736: } else { 
line 82737: distinct = - 1 ; 
line 82738: } 
line 82741: if ( ! isAgg && pGroupBy == 0 ) { 
line 82745: pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , & pOrderBy , 0 ) ; 
line 82746: if ( pWInfo == 0 ) goto select_end ; 
line 82752: if ( addrSortIndex >= 0 && pOrderBy == 0 ) { 
line 82753: sqlite3VdbeChangeToNoop ( v , addrSortIndex , 1 ) ; 
line 82754: p -> addrOpenEphm [ 2 ] = - 1 ; 
line 82755: } 
line 82759: assert ( ! isDistinct ) ; 
line 82760: selectInnerLoop ( pParse , p , pEList , 0 , 0 , pOrderBy , - 1 , pDest , 
line 82761: pWInfo -> iContinue , pWInfo -> iBreak ) ; 
line 82765: sqlite3WhereEnd ( pWInfo ) ; 
line 82766: } else { 
line 82768: NameContext sNC ; 
line 82769: int iAMem ; 
line 82770: int iBMem ; 
line 82771: int iUseFlag ; 
line 82774: int iAbortFlag ; 
line 82775: int groupBySort ; 
line 82776: int addrEnd ; 
line 82781: if ( pGroupBy ) { 
line 82782: int k ; 
line 82783: struct ExprList_item * pItem ; 
line 82785: for ( k = p -> pEList -> nExpr , pItem = p -> pEList -> a ; k > 0 ; k -- , pItem ++ ) { 
line 82786: pItem -> iAlias = 0 ; 
line 82787: } 
line 82788: for ( k = pGroupBy -> nExpr , pItem = pGroupBy -> a ; k > 0 ; k -- , pItem ++ ) { 
line 82789: pItem -> iAlias = 0 ; 
line 82790: } 
line 82791: } 
line 82795: addrEnd = sqlite3VdbeMakeLabel ( v ) ; 
line 82801: memset ( & sNC , 0 , sizeof ( sNC ) ) ; 
line 82802: sNC . pParse = pParse ; 
line 82803: sNC . pSrcList = pTabList ; 
line 82804: sNC . pAggInfo = & sAggInfo ; 
line 82805: sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr + 1 : 0 ; 
line 82806: sAggInfo . pGroupBy = pGroupBy ; 
line 82807: sqlite3ExprAnalyzeAggList ( & sNC , pEList ) ; 
line 82808: sqlite3ExprAnalyzeAggList ( & sNC , pOrderBy ) ; 
line 82809: if ( pHaving ) { 
line 82810: sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ) ; 
line 82811: } 
line 82812: sAggInfo . nAccumulator = sAggInfo . nColumn ; 
line 82813: for ( i = 0 ; i < sAggInfo . nFunc ; i ++ ) { 
line 82814: assert ( ! ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_xIsSelect ) ) ; 
line 82815: sqlite3ExprAnalyzeAggList ( & sNC , sAggInfo . aFunc [ i ] . pExpr -> x . pList ) ; 
line 82816: } 
line 82817: if ( db -> mallocFailed ) goto select_end ; 
line 82822: if ( pGroupBy ) { 
line 82823: KeyInfo * pKeyInfo ; 
line 82824: int j1 ; 
line 82825: int addrOutputRow ; 
line 82826: int regOutputRow ; 
line 82827: int addrSetAbort ; 
line 82828: int addrTopOfLoop ; 
line 82829: int addrSortingIdx ; 
line 82830: int addrReset ; 
line 82831: int regReset ; 
line 82838: sAggInfo . sortingIdx = pParse -> nTab ++ ; 
line 82839: pKeyInfo = keyInfoFromExprList ( pParse , pGroupBy ) ; 
line 82840: addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , 
line 82841: sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 
line 82842: 0 , ( char * ) pKeyInfo , P4_KEYINFO_HANDOFF ) ; 
line 82846: iUseFlag = ++ pParse -> nMem ; 
line 82847: iAbortFlag = ++ pParse -> nMem ; 
line 82848: regOutputRow = ++ pParse -> nMem ; 
line 82849: addrOutputRow = sqlite3VdbeMakeLabel ( v ) ; 
line 82850: regReset = ++ pParse -> nMem ; 
line 82851: addrReset = sqlite3VdbeMakeLabel ( v ) ; 
line 82852: iAMem = pParse -> nMem + 1 ; 
line 82853: pParse -> nMem += pGroupBy -> nExpr ; 
line 82854: iBMem = pParse -> nMem + 1 ; 
line 82855: pParse -> nMem += pGroupBy -> nExpr ; 
line 82856: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ) ; 
line 82857: VdbeComment ( ( v , "clear abort flag" ) ) ; 
line 82858: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ) ; 
line 82859: VdbeComment ( ( v , "indicate accumulator empty" ) ) ; 
line 82866: sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ) ; 
line 82867: pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , & pGroupBy , 0 ) ; 
line 82868: if ( pWInfo == 0 ) goto select_end ; 
line 82869: if ( pGroupBy == 0 ) { 
line 82874: pGroupBy = p -> pGroupBy ; 
line 82875: groupBySort = 0 ; 
line 82876: } else { 
line 82882: int regBase ; 
line 82883: int regRecord ; 
line 82884: int nCol ; 
line 82885: int nGroupBy ; 
line 82887: groupBySort = 1 ; 
line 82888: nGroupBy = pGroupBy -> nExpr ; 
line 82889: nCol = nGroupBy + 1 ; 
line 82890: j = nGroupBy + 1 ; 
line 82891: for ( i = 0 ; i < sAggInfo . nColumn ; i ++ ) { 
line 82892: if ( sAggInfo . aCol [ i ] . iSorterColumn >= j ) { 
line 82893: nCol ++ ; 
line 82894: j ++ ; 
line 82895: } 
line 82896: } 
line 82897: regBase = sqlite3GetTempRange ( pParse , nCol ) ; 
line 82898: sqlite3ExprCacheClear ( pParse ) ; 
line 82899: sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 ) ; 
line 82900: sqlite3VdbeAddOp2 ( v , OP_Sequence , sAggInfo . sortingIdx , regBase + nGroupBy ) ; 
line 82901: j = nGroupBy + 1 ; 
line 82902: for ( i = 0 ; i < sAggInfo . nColumn ; i ++ ) { 
line 82903: struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; 
line 82904: if ( pCol -> iSorterColumn >= j ) { 
line 82905: int r1 = j + regBase ; 
line 82906: int r2 ; 
line 82908: r2 = sqlite3ExprCodeGetColumn ( pParse , 
line 82909: pCol -> pTab , pCol -> iColumn , pCol -> iTable , r1 ) ; 
line 82910: if ( r1 != r2 ) { 
line 82911: sqlite3VdbeAddOp2 ( v , OP_SCopy , r2 , r1 ) ; 
line 82912: } 
line 82913: j ++ ; 
line 82914: } 
line 82915: } 
line 82916: regRecord = sqlite3GetTempReg ( pParse ) ; 
line 82917: sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ) ; 
line 82918: sqlite3VdbeAddOp2 ( v , OP_IdxInsert , sAggInfo . sortingIdx , regRecord ) ; 
line 82919: sqlite3ReleaseTempReg ( pParse , regRecord ) ; 
line 82920: sqlite3ReleaseTempRange ( pParse , regBase , nCol ) ; 
line 82921: sqlite3WhereEnd ( pWInfo ) ; 
line 82922: sqlite3VdbeAddOp2 ( v , OP_Sort , sAggInfo . sortingIdx , addrEnd ) ; 
line 82923: VdbeComment ( ( v , "GROUP BY sort" ) ) ; 
line 82924: sAggInfo . useSortingIdx = 1 ; 
line 82925: sqlite3ExprCacheClear ( pParse ) ; 
line 82926: } 
line 82933: addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ) ; 
line 82934: sqlite3ExprCacheClear ( pParse ) ; 
line 82935: for ( j = 0 ; j < pGroupBy -> nExpr ; j ++ ) { 
line 82936: if ( groupBySort ) { 
line 82937: sqlite3VdbeAddOp3 ( v , OP_Column , sAggInfo . sortingIdx , j , iBMem + j ) ; 
line 82938: } else { 
line 82939: sAggInfo . directMode = 1 ; 
line 82940: sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ) ; 
line 82941: } 
line 82942: } 
line 82943: sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , 
line 82944: ( char * ) pKeyInfo , P4_KEYINFO ) ; 
line 82945: j1 = sqlite3VdbeCurrentAddr ( v ) ; 
line 82946: sqlite3VdbeAddOp3 ( v , OP_Jump , j1 + 1 , 0 , j1 + 1 ) ; 
line 82957: sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ) ; 
line 82958: sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ) ; 
line 82959: VdbeComment ( ( v , "output one row" ) ) ; 
line 82960: sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ) ; 
line 82961: VdbeComment ( ( v , "check abort flag" ) ) ; 
line 82962: sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ) ; 
line 82963: VdbeComment ( ( v , "reset accumulator" ) ) ; 
line 82968: sqlite3VdbeJumpHere ( v , j1 ) ; 
line 82969: updateAccumulator ( pParse , & sAggInfo ) ; 
line 82970: sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ) ; 
line 82971: VdbeComment ( ( v , "indicate data in accumulator" ) ) ; 
line 82975: if ( groupBySort ) { 
line 82976: sqlite3VdbeAddOp2 ( v , OP_Next , sAggInfo . sortingIdx , addrTopOfLoop ) ; 
line 82977: } else { 
line 82978: sqlite3WhereEnd ( pWInfo ) ; 
line 82979: sqlite3VdbeChangeToNoop ( v , addrSortingIdx , 1 ) ; 
line 82980: } 
line 82984: sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ) ; 
line 82985: VdbeComment ( ( v , "output final row" ) ) ; 
line 82989: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , addrEnd ) ; 
line 82998: addrSetAbort = sqlite3VdbeCurrentAddr ( v ) ; 
line 82999: sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ) ; 
line 83000: VdbeComment ( ( v , "set abort flag" ) ) ; 
line 83001: sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ) ; 
line 83002: sqlite3VdbeResolveLabel ( v , addrOutputRow ) ; 
line 83003: addrOutputRow = sqlite3VdbeCurrentAddr ( v ) ; 
line 83004: sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ) ; 
line 83005: VdbeComment ( ( v , "Groupby result generator entry point" ) ) ; 
line 83006: sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ) ; 
line 83007: finalizeAggFunctions ( pParse , & sAggInfo ) ; 
line 83008: sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ) ; 
line 83009: selectInnerLoop ( pParse , p , p -> pEList , 0 , 0 , pOrderBy , 
line 83010: distinct , pDest , 
line 83011: addrOutputRow + 1 , addrSetAbort ) ; 
line 83012: sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ) ; 
line 83013: VdbeComment ( ( v , "end groupby result generator" ) ) ; 
line 83017: sqlite3VdbeResolveLabel ( v , addrReset ) ; 
line 83018: resetAccumulator ( pParse , & sAggInfo ) ; 
line 83019: sqlite3VdbeAddOp1 ( v , OP_Return , regReset ) ; 
line 83021: } 
line 83022: else { 
line 83023: ExprList * pDel = 0 ; 
line 83024: # ifndef SQLITE_OMIT_BTREECOUNT 
line 83025: Table * pTab ; 
line 83026: if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 ) { 
line 83040: const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; 
line 83041: const int iCsr = pParse -> nTab ++ ; 
line 83042: Index * pIdx ; 
line 83043: KeyInfo * pKeyInfo = 0 ; 
line 83044: Index * pBest = 0 ; 
line 83045: int iRoot = pTab -> tnum ; 
line 83047: sqlite3CodeVerifySchema ( pParse , iDb ) ; 
line 83048: sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ) ; 
line 83061: for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { 
line 83062: if ( ! pBest || pIdx -> nColumn < pBest -> nColumn ) { 
line 83063: pBest = pIdx ; 
line 83064: } 
line 83065: } 
line 83066: if ( pBest && pBest -> nColumn < pTab -> nCol ) { 
line 83067: iRoot = pBest -> tnum ; 
line 83068: pKeyInfo = sqlite3IndexKeyinfo ( pParse , pBest ) ; 
line 83069: } 
line 83072: sqlite3VdbeAddOp3 ( v , OP_OpenRead , iCsr , iRoot , iDb ) ; 
line 83073: if ( pKeyInfo ) { 
line 83074: sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO_HANDOFF ) ; 
line 83075: } 
line 83076: sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ) ; 
line 83077: sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ) ; 
line 83078: } else 
line 83079: # endif 
line 83080: { 
line 83106: ExprList * pMinMax = 0 ; 
line 83107: u8 flag = minMaxQuery ( p ) ; 
line 83108: if ( flag ) { 
line 83109: assert ( ! ExprHasProperty ( p -> pEList -> a [ 0 ] . pExpr , EP_xIsSelect ) ) ; 
line 83110: pMinMax = sqlite3ExprListDup ( db , p -> pEList -> a [ 0 ] . pExpr -> x . pList , 0 ) ; 
line 83111: pDel = pMinMax ; 
line 83112: if ( pMinMax && ! db -> mallocFailed ) { 
line 83113: pMinMax -> a [ 0 ] . sortOrder = flag != WHERE_ORDERBY_MIN ? 1 : 0 ; 
line 83114: pMinMax -> a [ 0 ] . pExpr -> op = TK_COLUMN ; 
line 83115: } 
line 83116: } 
line 83122: resetAccumulator ( pParse , & sAggInfo ) ; 
line 83123: pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , & pMinMax , flag ) ; 
line 83124: if ( pWInfo == 0 ) { 
line 83125: sqlite3ExprListDelete ( db , pDel ) ; 
line 83126: goto select_end ; 
line 83127: } 
line 83128: updateAccumulator ( pParse , & sAggInfo ) ; 
line 83129: if ( ! pMinMax && flag ) { 
line 83130: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , pWInfo -> iBreak ) ; 
line 83131: VdbeComment ( ( v , "%s() by index" , 
line 83132: ( flag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ) ; 
line 83133: } 
line 83134: sqlite3WhereEnd ( pWInfo ) ; 
line 83135: finalizeAggFunctions ( pParse , & sAggInfo ) ; 
line 83136: } 
line 83138: pOrderBy = 0 ; 
line 83139: sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ) ; 
line 83140: selectInnerLoop ( pParse , p , p -> pEList , 0 , 0 , 0 , - 1 , 
line 83141: pDest , addrEnd , addrEnd ) ; 
line 83142: sqlite3ExprListDelete ( db , pDel ) ; 
line 83143: } 
line 83144: sqlite3VdbeResolveLabel ( v , addrEnd ) ; 
line 83146: } 
line 83151: if ( pOrderBy ) { 
line 83152: generateSortTail ( pParse , p , v , pEList -> nExpr , pDest ) ; 
line 83153: } 
line 83157: sqlite3VdbeResolveLabel ( v , iEnd ) ; 
line 83162: rc = 0 ; 
line 83167: select_end : 
line 83171: if ( rc == SQLITE_OK && pDest -> eDest == SRT_Output ) { 
line 83172: generateColumnNames ( pParse , pTabList , pEList ) ; 
line 83173: } 
line 83175: sqlite3DbFree ( db , sAggInfo . aCol ) ; 
line 83176: sqlite3DbFree ( db , sAggInfo . aFunc ) ; 
line 83177: return rc ; 
line 83178: } 
line 83180: # if defined ( SQLITE_DEBUG ) 
line 83195: SQLITE_PRIVATE void sqlite3PrintExpr ( Expr * p ) { 
line 83196: if ( ! ExprHasProperty ( p , EP_IntValue ) && p -> u . zToken ) { 
line 83197: sqlite3DebugPrintf ( "(%s" , p -> u . zToken ) ; 
line 83198: } else { 
line 83199: sqlite3DebugPrintf ( "(%d" , p -> op ) ; 
line 83200: } 
line 83201: if ( p -> pLeft ) { 
line 83202: sqlite3DebugPrintf ( " " ) ; 
line 83203: sqlite3PrintExpr ( p -> pLeft ) ; 
line 83204: } 
line 83205: if ( p -> pRight ) { 
line 83206: sqlite3DebugPrintf ( " " ) ; 
line 83207: sqlite3PrintExpr ( p -> pRight ) ; 
line 83208: } 
line 83209: sqlite3DebugPrintf ( ")" ) ; 
line 83210: } 
line 83211: SQLITE_PRIVATE void sqlite3PrintExprList ( ExprList * pList ) { 
line 83212: int i ; 
line 83213: for ( i = 0 ; i < pList -> nExpr ; i ++ ) { 
line 83214: sqlite3PrintExpr ( pList -> a [ i ] . pExpr ) ; 
line 83215: if ( i < pList -> nExpr - 1 ) { 
line 83216: sqlite3DebugPrintf ( ", " ) ; 
line 83217: } 
line 83218: } 
line 83219: } 
line 83220: SQLITE_PRIVATE void sqlite3PrintSelect ( Select * p , int indent ) { 
line 83221: sqlite3DebugPrintf ( "%*sSELECT(%p) " , indent , "" , p ) ; 
line 83222: sqlite3PrintExprList ( p -> pEList ) ; 
line 83223: sqlite3DebugPrintf ( "\n" ) ; 
line 83224: if ( p -> pSrc ) { 
line 83225: char * zPrefix ; 
line 83226: int i ; 
line 83227: zPrefix = "FROM" ; 
line 83228: for ( i = 0 ; i < p -> pSrc -> nSrc ; i ++ ) { 
line 83229: struct SrcList_item * pItem = & p -> pSrc -> a [ i ] ; 
line 83230: sqlite3DebugPrintf ( "%*s " , indent + 6 , zPrefix ) ; 
line 83231: zPrefix = "" ; 
line 83232: if ( pItem -> pSelect ) { 
line 83233: sqlite3DebugPrintf ( "(\n" ) ; 
line 83234: sqlite3PrintSelect ( pItem -> pSelect , indent + 10 ) ; 
line 83235: sqlite3DebugPrintf ( "%*s)" , indent + 8 , "" ) ; 
line 83236: } else if ( pItem -> zName ) { 
line 83237: sqlite3DebugPrintf ( "%s" , pItem -> zName ) ; 
line 83238: } 
line 83239: if ( pItem -> pTab ) { 
line 83240: sqlite3DebugPrintf ( "(table: %s)" , pItem -> pTab -> zName ) ; 
line 83241: } 
line 83242: if ( pItem -> zAlias ) { 
line 83243: sqlite3DebugPrintf ( " AS %s" , pItem -> zAlias ) ; 
line 83244: } 
line 83245: if ( i < p -> pSrc -> nSrc - 1 ) { 
line 83246: sqlite3DebugPrintf ( "," ) ; 
line 83247: } 
line 83248: sqlite3DebugPrintf ( "\n" ) ; 
line 83249: } 
line 83250: } 
line 83251: if ( p -> pWhere ) { 
line 83252: sqlite3DebugPrintf ( "%*s WHERE " , indent , "" ) ; 
line 83253: sqlite3PrintExpr ( p -> pWhere ) ; 
line 83254: sqlite3DebugPrintf ( "\n" ) ; 
line 83255: } 
line 83256: if ( p -> pGroupBy ) { 
line 83257: sqlite3DebugPrintf ( "%*s GROUP BY " , indent , "" ) ; 
line 83258: sqlite3PrintExprList ( p -> pGroupBy ) ; 
line 83259: sqlite3DebugPrintf ( "\n" ) ; 
line 83260: } 
line 83261: if ( p -> pHaving ) { 
line 83262: sqlite3DebugPrintf ( "%*s HAVING " , indent , "" ) ; 
line 83263: sqlite3PrintExpr ( p -> pHaving ) ; 
line 83264: sqlite3DebugPrintf ( "\n" ) ; 
line 83265: } 
line 83266: if ( p -> pOrderBy ) { 
line 83267: sqlite3DebugPrintf ( "%*s ORDER BY " , indent , "" ) ; 
line 83268: sqlite3PrintExprList ( p -> pOrderBy ) ; 
line 83269: sqlite3DebugPrintf ( "\n" ) ; 
line 83270: } 
line 83271: } 
line 83274: # endif 
line 83297: # ifndef SQLITE_OMIT_GET_TABLE 
line 83303: typedef struct TabResult { 
line 83304: char * * azResult ; 
line 83305: char * zErrMsg ; 
line 83306: int nAlloc ; 
line 83307: int nRow ; 
line 83308: int nColumn ; 
line 83309: int nData ; 
line 83310: int rc ; 
line 83311: } TabResult ; 
line 83318: static int sqlite3_get_table_cb ( void * pArg , int nCol , char * * argv , char * * colv ) { 
line 83319: TabResult * p = ( TabResult * ) pArg ; 
line 83320: int need ; 
line 83321: int i ; 
line 83322: char * z ; 
line 83327: if ( p -> nRow == 0 && argv != 0 ) { 
line 83328: need = nCol * 2 ; 
line 83329: } else { 
line 83330: need = nCol ; 
line 83331: } 
line 83332: if ( p -> nData + need > p -> nAlloc ) { 
line 83333: char * * azNew ; 
line 83334: p -> nAlloc = p -> nAlloc * 2 + need ; 
line 83335: azNew = sqlite3_realloc ( p -> azResult , sizeof ( char * ) * p -> nAlloc ) ; 
line 83336: if ( azNew == 0 ) goto malloc_failed ; 
line 83337: p -> azResult = azNew ; 
line 83338: } 
line 83343: if ( p -> nRow == 0 ) { 
line 83344: p -> nColumn = nCol ; 
line 83345: for ( i = 0 ; i < nCol ; i ++ ) { 
line 83346: z = sqlite3_mprintf ( "%s" , colv [ i ] ) ; 
line 83347: if ( z == 0 ) goto malloc_failed ; 
line 83348: p -> azResult [ p -> nData ++ ] = z ; 
line 83349: } 
line 83350: } else if ( p -> nColumn != nCol ) { 
line 83351: sqlite3_free ( p -> zErrMsg ) ; 
line 83352: p -> zErrMsg = sqlite3_mprintf ( 
line 83353: "sqlite3_get_table() called with two or more incompatible queries" 
line 83354: ) ; 
line 83355: p -> rc = SQLITE_ERROR ; 
line 83356: return 1 ; 
line 83357: } 
line 83361: if ( argv != 0 ) { 
line 83362: for ( i = 0 ; i < nCol ; i ++ ) { 
line 83363: if ( argv [ i ] == 0 ) { 
line 83364: z = 0 ; 
line 83365: } else { 
line 83366: int n = sqlite3Strlen30 ( argv [ i ] ) + 1 ; 
line 83367: z = sqlite3_malloc ( n ) ; 
line 83368: if ( z == 0 ) goto malloc_failed ; 
line 83369: memcpy ( z , argv [ i ] , n ) ; 
line 83370: } 
line 83371: p -> azResult [ p -> nData ++ ] = z ; 
line 83372: } 
line 83373: p -> nRow ++ ; 
line 83374: } 
line 83375: return 0 ; 
line 83377: malloc_failed : 
line 83378: p -> rc = SQLITE_NOMEM ; 
line 83379: return 1 ; 
line 83380: } 
line 83392: SQLITE_API int sqlite3_get_table ( 
line 83393: sqlite3 * db , 
line 83394: const char * zSql , 
line 83395: char * * * pazResult , 
line 83396: int * pnRow , 
line 83397: int * pnColumn , 
line 83398: char * * pzErrMsg 
line 83399: ) { 
line 83400: int rc ; 
line 83401: TabResult res ; 
line 83403: * pazResult = 0 ; 
line 83404: if ( pnColumn ) * pnColumn = 0 ; 
line 83405: if ( pnRow ) * pnRow = 0 ; 
line 83406: if ( pzErrMsg ) * pzErrMsg = 0 ; 
line 83407: res . zErrMsg = 0 ; 
line 83408: res . nRow = 0 ; 
line 83409: res . nColumn = 0 ; 
line 83410: res . nData = 1 ; 
line 83411: res . nAlloc = 20 ; 
line 83412: res . rc = SQLITE_OK ; 
line 83413: res . azResult = sqlite3_malloc ( sizeof ( char * ) * res . nAlloc ) ; 
line 83414: if ( res . azResult == 0 ) { 
line 83415: db -> errCode = SQLITE_NOMEM ; 
line 83416: return SQLITE_NOMEM ; 
line 83417: } 
line 83418: res . azResult [ 0 ] = 0 ; 
line 83419: rc = sqlite3_exec ( db , zSql , sqlite3_get_table_cb , & res , pzErrMsg ) ; 
line 83420: assert ( sizeof ( res . azResult [ 0 ] ) >= sizeof ( res . nData ) ) ; 
line 83421: res . azResult [ 0 ] = SQLITE_INT_TO_PTR ( res . nData ) ; 
line 83422: if ( ( rc & 0xff ) == SQLITE_ABORT ) { 
line 83423: sqlite3_free_table ( & res . azResult [ 1 ] ) ; 
line 83424: if ( res . zErrMsg ) { 
line 83425: if ( pzErrMsg ) { 
line 83426: sqlite3_free ( * pzErrMsg ) ; 
line 83427: * pzErrMsg = sqlite3_mprintf ( "%s" , res . zErrMsg ) ; 
line 83428: } 
line 83429: sqlite3_free ( res . zErrMsg ) ; 
line 83430: } 
line 83431: db -> errCode = res . rc ; 
line 83432: return res . rc ; 
line 83433: } 
line 83434: sqlite3_free ( res . zErrMsg ) ; 
line 83435: if ( rc != SQLITE_OK ) { 
line 83436: sqlite3_free_table ( & res . azResult [ 1 ] ) ; 
line 83437: return rc ; 
line 83438: } 
line 83439: if ( res . nAlloc > res . nData ) { 
line 83440: char * * azNew ; 
line 83441: azNew = sqlite3_realloc ( res . azResult , sizeof ( char * ) * res . nData ) ; 
line 83442: if ( azNew == 0 ) { 
line 83443: sqlite3_free_table ( & res . azResult [ 1 ] ) ; 
line 83444: db -> errCode = SQLITE_NOMEM ; 
line 83445: return SQLITE_NOMEM ; 
line 83446: } 
line 83447: res . azResult = azNew ; 
line 83448: } 
line 83449: * pazResult = & res . azResult [ 1 ] ; 
line 83450: if ( pnColumn ) * pnColumn = res . nColumn ; 
line 83451: if ( pnRow ) * pnRow = res . nRow ; 
line 83452: return rc ; 
line 83453: } 
line 83458: SQLITE_API void sqlite3_free_table ( 
line 83459: char * * azResult 
line 83460: ) { 
line 83461: if ( azResult ) { 
line 83462: int i , n ; 
line 83463: azResult -- ; 
line 83464: assert ( azResult != 0 ) ; 
line 83465: n = SQLITE_PTR_TO_INT ( azResult [ 0 ] ) ; 
line 83466: for ( i = 1 ; i < n ; i ++ ) { if ( azResult [ i ] ) sqlite3_free ( azResult [ i ] ) ; } 
line 83467: sqlite3_free ( azResult ) ; 
line 83468: } 
line 83469: } 
line 83471: # endif 
line 83488: # ifndef SQLITE_OMIT_TRIGGER 
line 83492: SQLITE_PRIVATE void sqlite3DeleteTriggerStep ( sqlite3 * db , TriggerStep * pTriggerStep ) { 
line 83493: while ( pTriggerStep ) { 
line 83494: TriggerStep * pTmp = pTriggerStep ; 
line 83495: pTriggerStep = pTriggerStep -> pNext ; 
line 83497: sqlite3ExprDelete ( db , pTmp -> pWhere ) ; 
line 83498: sqlite3ExprListDelete ( db , pTmp -> pExprList ) ; 
line 83499: sqlite3SelectDelete ( db , pTmp -> pSelect ) ; 
line 83500: sqlite3IdListDelete ( db , pTmp -> pIdList ) ; 
line 83502: sqlite3DbFree ( db , pTmp ) ; 
line 83503: } 
line 83504: } 
line 83520: SQLITE_PRIVATE Trigger * sqlite3TriggerList ( Parse * pParse , Table * pTab ) { 
line 83521: Schema * const pTmpSchema = pParse -> db -> aDb [ 1 ] . pSchema ; 
line 83522: Trigger * pList = 0 ; 
line 83524: if ( pParse -> disableTriggers ) { 
line 83525: return 0 ; 
line 83526: } 
line 83528: if ( pTmpSchema != pTab -> pSchema ) { 
line 83529: HashElem * p ; 
line 83530: for ( p = sqliteHashFirst ( & pTmpSchema -> trigHash ) ; p ; p = sqliteHashNext ( p ) ) { 
line 83531: Trigger * pTrig = ( Trigger * ) sqliteHashData ( p ) ; 
line 83532: if ( pTrig -> pTabSchema == pTab -> pSchema 
line 83533: && 0 == sqlite3StrICmp ( pTrig -> table , pTab -> zName ) 
line 83534: ) { 
line 83535: pTrig -> pNext = ( pList ? pList : pTab -> pTrigger ) ; 
line 83536: pList = pTrig ; 
line 83537: } 
line 83538: } 
line 83539: } 
line 83541: return ( pList ? pList : pTab -> pTrigger ) ; 
line 83542: } 
line 83552: SQLITE_PRIVATE void sqlite3BeginTrigger ( 
line 83553: Parse * pParse , 
line 83554: Token * pName1 , 
line 83555: Token * pName2 , 
line 83556: int tr_tm , 
line 83557: int op , 
line 83558: IdList * pColumns , 
line 83559: SrcList * pTableName , 
line 83560: Expr * pWhen , 
line 83561: int isTemp , 
line 83562: int noErr 
line 83563: ) { 
line 83564: Trigger * pTrigger = 0 ; 
line 83565: Table * pTab ; 
line 83566: char * zName = 0 ; 
line 83567: sqlite3 * db = pParse -> db ; 
line 83568: int iDb ; 
line 83569: Token * pName ; 
line 83570: DbFixer sFix ; 
line 83571: int iTabDb ; 
line 83573: assert ( pName1 != 0 ) ; 
line 83574: assert ( pName2 != 0 ) ; 
line 83575: assert ( op == TK_INSERT || op == TK_UPDATE || op == TK_DELETE ) ; 
line 83576: assert ( op > 0 && op < 0xff ) ; 
line 83577: if ( isTemp ) { 
line 83579: if ( pName2 -> n > 0 ) { 
line 83580: sqlite3ErrorMsg ( pParse , "temporary trigger may not have qualified name" ) ; 
line 83581: goto trigger_cleanup ; 
line 83582: } 
line 83583: iDb = 1 ; 
line 83584: pName = pName1 ; 
line 83585: } else { 
line 83587: iDb = sqlite3TwoPartName ( pParse , pName1 , pName2 , & pName ) ; 
line 83588: if ( iDb < 0 ) { 
line 83589: goto trigger_cleanup ; 
line 83590: } 
line 83591: } 
line 83598: if ( ! pTableName || db -> mallocFailed ) { 
line 83599: goto trigger_cleanup ; 
line 83600: } 
line 83601: pTab = sqlite3SrcListLookup ( pParse , pTableName ) ; 
line 83602: if ( pName2 -> n == 0 && pTab && pTab -> pSchema == db -> aDb [ 1 ] . pSchema ) { 
line 83603: iDb = 1 ; 
line 83604: } 
line 83607: if ( db -> mallocFailed ) goto trigger_cleanup ; 
line 83608: assert ( pTableName -> nSrc == 1 ) ; 
line 83609: if ( sqlite3FixInit ( & sFix , pParse , iDb , "trigger" , pName ) && 
line 83610: sqlite3FixSrcList ( & sFix , pTableName ) ) { 
line 83611: goto trigger_cleanup ; 
line 83612: } 
line 83613: pTab = sqlite3SrcListLookup ( pParse , pTableName ) ; 
line 83614: if ( ! pTab ) { 
line 83616: if ( db -> init . iDb == 1 ) { 
line 83625: db -> init . orphanTrigger = 1 ; 
line 83626: } 
line 83627: goto trigger_cleanup ; 
line 83628: } 
line 83629: if ( IsVirtual ( pTab ) ) { 
line 83630: sqlite3ErrorMsg ( pParse , "cannot create triggers on virtual tables" ) ; 
line 83631: goto trigger_cleanup ; 
line 83632: } 
line 83636: zName = sqlite3NameFromToken ( db , pName ) ; 
line 83637: if ( ! zName || SQLITE_OK != sqlite3CheckObjectName ( pParse , zName ) ) { 
line 83638: goto trigger_cleanup ; 
line 83639: } 
line 83640: if ( sqlite3HashFind ( & ( db -> aDb [ iDb ] . pSchema -> trigHash ) , 
line 83641: zName , sqlite3Strlen30 ( zName ) ) ) { 
line 83642: if ( ! noErr ) { 
line 83643: sqlite3ErrorMsg ( pParse , "trigger %T already exists" , pName ) ; 
line 83644: } 
line 83645: goto trigger_cleanup ; 
line 83646: } 
line 83649: if ( sqlite3StrNICmp ( pTab -> zName , "sqlite_" , 7 ) == 0 ) { 
line 83650: sqlite3ErrorMsg ( pParse , "cannot create trigger on system table" ) ; 
line 83651: pParse -> nErr ++ ; 
line 83652: goto trigger_cleanup ; 
line 83653: } 
line 83658: if ( pTab -> pSelect && tr_tm != TK_INSTEAD ) { 
line 83659: sqlite3ErrorMsg ( pParse , "cannot create %s trigger on view: %S" , 
line 83660: ( tr_tm == TK_BEFORE ) ? "BEFORE" : "AFTER" , pTableName , 0 ) ; 
line 83661: goto trigger_cleanup ; 
line 83662: } 
line 83663: if ( ! pTab -> pSelect && tr_tm == TK_INSTEAD ) { 
line 83664: sqlite3ErrorMsg ( pParse , "cannot create INSTEAD OF" 
line 83665: " trigger on table: %S" , pTableName , 0 ) ; 
line 83666: goto trigger_cleanup ; 
line 83667: } 
line 83668: iTabDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; 
line 83670: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 83671: { 
line 83672: int code = SQLITE_CREATE_TRIGGER ; 
line 83673: const char * zDb = db -> aDb [ iTabDb ] . zName ; 
line 83674: const char * zDbTrig = isTemp ? db -> aDb [ 1 ] . zName : zDb ; 
line 83675: if ( iTabDb == 1 || isTemp ) code = SQLITE_CREATE_TEMP_TRIGGER ; 
line 83676: if ( sqlite3AuthCheck ( pParse , code , zName , pTab -> zName , zDbTrig ) ) { 
line 83677: goto trigger_cleanup ; 
line 83678: } 
line 83679: if ( sqlite3AuthCheck ( pParse , SQLITE_INSERT , SCHEMA_TABLE ( iTabDb ) , 0 , zDb ) ) { 
line 83680: goto trigger_cleanup ; 
line 83681: } 
line 83682: } 
line 83683: # endif 
line 83690: if ( tr_tm == TK_INSTEAD ) { 
line 83691: tr_tm = TK_BEFORE ; 
line 83692: } 
line 83695: pTrigger = ( Trigger * ) sqlite3DbMallocZero ( db , sizeof ( Trigger ) ) ; 
line 83696: if ( pTrigger == 0 ) goto trigger_cleanup ; 
line 83697: pTrigger -> zName = zName ; 
line 83698: zName = 0 ; 
line 83699: pTrigger -> table = sqlite3DbStrDup ( db , pTableName -> a [ 0 ] . zName ) ; 
line 83700: pTrigger -> pSchema = db -> aDb [ iDb ] . pSchema ; 
line 83701: pTrigger -> pTabSchema = pTab -> pSchema ; 
line 83702: pTrigger -> op = ( u8 ) op ; 
line 83703: pTrigger -> tr_tm = tr_tm == TK_BEFORE ? TRIGGER_BEFORE : TRIGGER_AFTER ; 
line 83704: pTrigger -> pWhen = sqlite3ExprDup ( db , pWhen , EXPRDUP_REDUCE ) ; 
line 83705: pTrigger -> pColumns = sqlite3IdListDup ( db , pColumns ) ; 
line 83706: assert ( pParse -> pNewTrigger == 0 ) ; 
line 83707: pParse -> pNewTrigger = pTrigger ; 
line 83709: trigger_cleanup : 
line 83710: sqlite3DbFree ( db , zName ) ; 
line 83711: sqlite3SrcListDelete ( db , pTableName ) ; 
line 83712: sqlite3IdListDelete ( db , pColumns ) ; 
line 83713: sqlite3ExprDelete ( db , pWhen ) ; 
line 83714: if ( ! pParse -> pNewTrigger ) { 
line 83715: sqlite3DeleteTrigger ( db , pTrigger ) ; 
line 83716: } else { 
line 83717: assert ( pParse -> pNewTrigger == pTrigger ) ; 
line 83718: } 
line 83719: } 
line 83725: SQLITE_PRIVATE void sqlite3FinishTrigger ( 
line 83726: Parse * pParse , 
line 83727: TriggerStep * pStepList , 
line 83728: Token * pAll 
line 83729: ) { 
line 83730: Trigger * pTrig = pParse -> pNewTrigger ; 
line 83731: char * zName ; 
line 83732: sqlite3 * db = pParse -> db ; 
line 83733: DbFixer sFix ; 
line 83734: int iDb ; 
line 83735: Token nameToken ; 
line 83737: pTrig = pParse -> pNewTrigger ; 
line 83738: pParse -> pNewTrigger = 0 ; 
line 83739: if ( NEVER ( pParse -> nErr ) || ! pTrig ) goto triggerfinish_cleanup ; 
line 83740: zName = pTrig -> zName ; 
line 83741: iDb = sqlite3SchemaToIndex ( pParse -> db , pTrig -> pSchema ) ; 
line 83742: pTrig -> step_list = pStepList ; 
line 83743: while ( pStepList ) { 
line 83744: pStepList -> pTrig = pTrig ; 
line 83745: pStepList = pStepList -> pNext ; 
line 83746: } 
line 83747: nameToken . z = pTrig -> zName ; 
line 83748: nameToken . n = sqlite3Strlen30 ( nameToken . z ) ; 
line 83749: if ( sqlite3FixInit ( & sFix , pParse , iDb , "trigger" , & nameToken ) 
line 83750: && sqlite3FixTriggerStep ( & sFix , pTrig -> step_list ) ) { 
line 83751: goto triggerfinish_cleanup ; 
line 83752: } 
line 83757: if ( ! db -> init . busy ) { 
line 83758: Vdbe * v ; 
line 83759: char * z ; 
line 83762: v = sqlite3GetVdbe ( pParse ) ; 
line 83763: if ( v == 0 ) goto triggerfinish_cleanup ; 
line 83764: sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; 
line 83765: z = sqlite3DbStrNDup ( db , ( char * ) pAll -> z , pAll -> n ) ; 
line 83766: sqlite3NestedParse ( pParse , 
line 83767: "INSERT INTO %Q.%s VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')" , 
line 83768: db -> aDb [ iDb ] . zName , SCHEMA_TABLE ( iDb ) , zName , 
line 83769: pTrig -> table , z ) ; 
line 83770: sqlite3DbFree ( db , z ) ; 
line 83771: sqlite3ChangeCookie ( pParse , iDb ) ; 
line 83772: sqlite3VdbeAddOp4 ( v , OP_ParseSchema , iDb , 0 , 0 , sqlite3MPrintf ( 
line 83773: db , "type='trigger' AND name='%q'" , zName ) , P4_DYNAMIC 
line 83774: ) ; 
line 83775: } 
line 83777: if ( db -> init . busy ) { 
line 83778: Trigger * pLink = pTrig ; 
line 83779: Hash * pHash = & db -> aDb [ iDb ] . pSchema -> trigHash ; 
line 83780: pTrig = sqlite3HashInsert ( pHash , zName , sqlite3Strlen30 ( zName ) , pTrig ) ; 
line 83781: if ( pTrig ) { 
line 83782: db -> mallocFailed = 1 ; 
line 83783: } else if ( pLink -> pSchema == pLink -> pTabSchema ) { 
line 83784: Table * pTab ; 
line 83785: int n = sqlite3Strlen30 ( pLink -> table ) ; 
line 83786: pTab = sqlite3HashFind ( & pLink -> pTabSchema -> tblHash , pLink -> table , n ) ; 
line 83787: assert ( pTab != 0 ) ; 
line 83788: pLink -> pNext = pTab -> pTrigger ; 
line 83789: pTab -> pTrigger = pLink ; 
line 83790: } 
line 83791: } 
line 83793: triggerfinish_cleanup : 
line 83794: sqlite3DeleteTrigger ( db , pTrig ) ; 
line 83795: assert ( ! pParse -> pNewTrigger ) ; 
line 83796: sqlite3DeleteTriggerStep ( db , pStepList ) ; 
line 83797: } 
line 83806: SQLITE_PRIVATE TriggerStep * sqlite3TriggerSelectStep ( sqlite3 * db , Select * pSelect ) { 
line 83807: TriggerStep * pTriggerStep = sqlite3DbMallocZero ( db , sizeof ( TriggerStep ) ) ; 
line 83808: if ( pTriggerStep == 0 ) { 
line 83809: sqlite3SelectDelete ( db , pSelect ) ; 
line 83810: return 0 ; 
line 83811: } 
line 83812: pTriggerStep -> op = TK_SELECT ; 
line 83813: pTriggerStep -> pSelect = pSelect ; 
line 83814: pTriggerStep -> orconf = OE_Default ; 
line 83815: return pTriggerStep ; 
line 83816: } 
line 83824: static TriggerStep * triggerStepAllocate ( 
line 83825: sqlite3 * db , 
line 83826: u8 op , 
line 83827: Token * pName 
line 83828: ) { 
line 83829: TriggerStep * pTriggerStep ; 
line 83831: pTriggerStep = sqlite3DbMallocZero ( db , sizeof ( TriggerStep ) + pName -> n ) ; 
line 83832: if ( pTriggerStep ) { 
line 83833: char * z = ( char * ) & pTriggerStep [ 1 ] ; 
line 83834: memcpy ( z , pName -> z , pName -> n ) ; 
line 83835: pTriggerStep -> target . z = z ; 
line 83836: pTriggerStep -> target . n = pName -> n ; 
line 83837: pTriggerStep -> op = op ; 
line 83838: } 
line 83839: return pTriggerStep ; 
line 83840: } 
line 83849: SQLITE_PRIVATE TriggerStep * sqlite3TriggerInsertStep ( 
line 83850: sqlite3 * db , 
line 83851: Token * pTableName , 
line 83852: IdList * pColumn , 
line 83853: ExprList * pEList , 
line 83854: Select * pSelect , 
line 83855: u8 orconf 
line 83856: ) { 
line 83857: TriggerStep * pTriggerStep ; 
line 83859: assert ( pEList == 0 || pSelect == 0 ) ; 
line 83860: assert ( pEList != 0 || pSelect != 0 || db -> mallocFailed ) ; 
line 83862: pTriggerStep = triggerStepAllocate ( db , TK_INSERT , pTableName ) ; 
line 83863: if ( pTriggerStep ) { 
line 83864: pTriggerStep -> pSelect = sqlite3SelectDup ( db , pSelect , EXPRDUP_REDUCE ) ; 
line 83865: pTriggerStep -> pIdList = pColumn ; 
line 83866: pTriggerStep -> pExprList = sqlite3ExprListDup ( db , pEList , EXPRDUP_REDUCE ) ; 
line 83867: pTriggerStep -> orconf = orconf ; 
line 83868: } else { 
line 83869: sqlite3IdListDelete ( db , pColumn ) ; 
line 83870: } 
line 83871: sqlite3ExprListDelete ( db , pEList ) ; 
line 83872: sqlite3SelectDelete ( db , pSelect ) ; 
line 83874: return pTriggerStep ; 
line 83875: } 
line 83882: SQLITE_PRIVATE TriggerStep * sqlite3TriggerUpdateStep ( 
line 83883: sqlite3 * db , 
line 83884: Token * pTableName , 
line 83885: ExprList * pEList , 
line 83886: Expr * pWhere , 
line 83887: u8 orconf 
line 83888: ) { 
line 83889: TriggerStep * pTriggerStep ; 
line 83891: pTriggerStep = triggerStepAllocate ( db , TK_UPDATE , pTableName ) ; 
line 83892: if ( pTriggerStep ) { 
line 83893: pTriggerStep -> pExprList = sqlite3ExprListDup ( db , pEList , EXPRDUP_REDUCE ) ; 
line 83894: pTriggerStep -> pWhere = sqlite3ExprDup ( db , pWhere , EXPRDUP_REDUCE ) ; 
line 83895: pTriggerStep -> orconf = orconf ; 
line 83896: } 
line 83897: sqlite3ExprListDelete ( db , pEList ) ; 
line 83898: sqlite3ExprDelete ( db , pWhere ) ; 
line 83899: return pTriggerStep ; 
line 83900: } 
line 83907: SQLITE_PRIVATE TriggerStep * sqlite3TriggerDeleteStep ( 
line 83908: sqlite3 * db , 
line 83909: Token * pTableName , 
line 83910: Expr * pWhere 
line 83911: ) { 
line 83912: TriggerStep * pTriggerStep ; 
line 83914: pTriggerStep = triggerStepAllocate ( db , TK_DELETE , pTableName ) ; 
line 83915: if ( pTriggerStep ) { 
line 83916: pTriggerStep -> pWhere = sqlite3ExprDup ( db , pWhere , EXPRDUP_REDUCE ) ; 
line 83917: pTriggerStep -> orconf = OE_Default ; 
line 83918: } 
line 83919: sqlite3ExprDelete ( db , pWhere ) ; 
line 83920: return pTriggerStep ; 
line 83921: } 
line 83926: SQLITE_PRIVATE void sqlite3DeleteTrigger ( sqlite3 * db , Trigger * pTrigger ) { 
line 83927: if ( pTrigger == 0 ) return ; 
line 83928: sqlite3DeleteTriggerStep ( db , pTrigger -> step_list ) ; 
line 83929: sqlite3DbFree ( db , pTrigger -> zName ) ; 
line 83930: sqlite3DbFree ( db , pTrigger -> table ) ; 
line 83931: sqlite3ExprDelete ( db , pTrigger -> pWhen ) ; 
line 83932: sqlite3IdListDelete ( db , pTrigger -> pColumns ) ; 
line 83933: sqlite3DbFree ( db , pTrigger ) ; 
line 83934: } 
line 83944: SQLITE_PRIVATE void sqlite3DropTrigger ( Parse * pParse , SrcList * pName , int noErr ) { 
line 83945: Trigger * pTrigger = 0 ; 
line 83946: int i ; 
line 83947: const char * zDb ; 
line 83948: const char * zName ; 
line 83949: int nName ; 
line 83950: sqlite3 * db = pParse -> db ; 
line 83952: if ( db -> mallocFailed ) goto drop_trigger_cleanup ; 
line 83953: if ( SQLITE_OK != sqlite3ReadSchema ( pParse ) ) { 
line 83954: goto drop_trigger_cleanup ; 
line 83955: } 
line 83957: assert ( pName -> nSrc == 1 ) ; 
line 83958: zDb = pName -> a [ 0 ] . zDatabase ; 
line 83959: zName = pName -> a [ 0 ] . zName ; 
line 83960: nName = sqlite3Strlen30 ( zName ) ; 
line 83961: for ( i = OMIT_TEMPDB ; i < db -> nDb ; i ++ ) { 
line 83962: int j = ( i < 2 ) ? i ^ 1 : i ; 
line 83963: if ( zDb && sqlite3StrICmp ( db -> aDb [ j ] . zName , zDb ) ) continue ; 
line 83964: pTrigger = sqlite3HashFind ( & ( db -> aDb [ j ] . pSchema -> trigHash ) , zName , nName ) ; 
line 83965: if ( pTrigger ) break ; 
line 83966: } 
line 83967: if ( ! pTrigger ) { 
line 83968: if ( ! noErr ) { 
line 83969: sqlite3ErrorMsg ( pParse , "no such trigger: %S" , pName , 0 ) ; 
line 83970: } 
line 83971: goto drop_trigger_cleanup ; 
line 83972: } 
line 83973: sqlite3DropTriggerPtr ( pParse , pTrigger ) ; 
line 83975: drop_trigger_cleanup : 
line 83976: sqlite3SrcListDelete ( db , pName ) ; 
line 83977: } 
line 83983: static Table * tableOfTrigger ( Trigger * pTrigger ) { 
line 83984: int n = sqlite3Strlen30 ( pTrigger -> table ) ; 
line 83985: return sqlite3HashFind ( & pTrigger -> pTabSchema -> tblHash , pTrigger -> table , n ) ; 
line 83986: } 
line 83992: SQLITE_PRIVATE void sqlite3DropTriggerPtr ( Parse * pParse , Trigger * pTrigger ) { 
line 83993: Table * pTable ; 
line 83994: Vdbe * v ; 
line 83995: sqlite3 * db = pParse -> db ; 
line 83996: int iDb ; 
line 83998: iDb = sqlite3SchemaToIndex ( pParse -> db , pTrigger -> pSchema ) ; 
line 83999: assert ( iDb >= 0 && iDb < db -> nDb ) ; 
line 84000: pTable = tableOfTrigger ( pTrigger ) ; 
line 84001: assert ( pTable ) ; 
line 84002: assert ( pTable -> pSchema == pTrigger -> pSchema || iDb == 1 ) ; 
line 84003: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 84004: { 
line 84005: int code = SQLITE_DROP_TRIGGER ; 
line 84006: const char * zDb = db -> aDb [ iDb ] . zName ; 
line 84007: const char * zTab = SCHEMA_TABLE ( iDb ) ; 
line 84008: if ( iDb == 1 ) code = SQLITE_DROP_TEMP_TRIGGER ; 
line 84009: if ( sqlite3AuthCheck ( pParse , code , pTrigger -> zName , pTable -> zName , zDb ) || 
line 84010: sqlite3AuthCheck ( pParse , SQLITE_DELETE , zTab , 0 , zDb ) ) { 
line 84011: return ; 
line 84012: } 
line 84013: } 
line 84014: # endif 
line 84018: assert ( pTable != 0 ) ; 
line 84019: if ( ( v = sqlite3GetVdbe ( pParse ) ) != 0 ) { 
line 84020: int base ; 
line 84021: static const VdbeOpList dropTrigger [ ] = { 
line 84022: { OP_Rewind , 0 , ADDR ( 9 ) , 0 } , 
line 84023: { OP_String8 , 0 , 1 , 0 } , 
line 84024: { OP_Column , 0 , 1 , 2 } , 
line 84025: { OP_Ne , 2 , ADDR ( 8 ) , 1 } , 
line 84026: { OP_String8 , 0 , 1 , 0 } , 
line 84027: { OP_Column , 0 , 0 , 2 } , 
line 84028: { OP_Ne , 2 , ADDR ( 8 ) , 1 } , 
line 84029: { OP_Delete , 0 , 0 , 0 } , 
line 84030: { OP_Next , 0 , ADDR ( 1 ) , 0 } , 
line 84031: } ; 
line 84033: sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; 
line 84034: sqlite3OpenMasterTable ( pParse , iDb ) ; 
line 84035: base = sqlite3VdbeAddOpList ( v , ArraySize ( dropTrigger ) , dropTrigger ) ; 
line 84036: sqlite3VdbeChangeP4 ( v , base + 1 , pTrigger -> zName , 0 ) ; 
line 84037: sqlite3VdbeChangeP4 ( v , base + 4 , "trigger" , P4_STATIC ) ; 
line 84038: sqlite3ChangeCookie ( pParse , iDb ) ; 
line 84039: sqlite3VdbeAddOp2 ( v , OP_Close , 0 , 0 ) ; 
line 84040: sqlite3VdbeAddOp4 ( v , OP_DropTrigger , iDb , 0 , 0 , pTrigger -> zName , 0 ) ; 
line 84041: if ( pParse -> nMem < 3 ) { 
line 84042: pParse -> nMem = 3 ; 
line 84043: } 
line 84044: } 
line 84045: } 
line 84050: SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTrigger ( sqlite3 * db , int iDb , const char * zName ) { 
line 84051: Hash * pHash = & ( db -> aDb [ iDb ] . pSchema -> trigHash ) ; 
line 84052: Trigger * pTrigger ; 
line 84053: pTrigger = sqlite3HashInsert ( pHash , zName , sqlite3Strlen30 ( zName ) , 0 ) ; 
line 84054: if ( ALWAYS ( pTrigger ) ) { 
line 84055: if ( pTrigger -> pSchema == pTrigger -> pTabSchema ) { 
line 84056: Table * pTab = tableOfTrigger ( pTrigger ) ; 
line 84057: Trigger * * pp ; 
line 84058: for ( pp = & pTab -> pTrigger ; * pp != pTrigger ; pp = & ( ( * pp ) -> pNext ) ) ; 
line 84059: * pp = ( * pp ) -> pNext ; 
line 84060: } 
line 84061: sqlite3DeleteTrigger ( db , pTrigger ) ; 
line 84062: db -> flags |= SQLITE_InternChanges ; 
line 84063: } 
line 84064: } 
line 84075: static int checkColumnOverlap ( IdList * pIdList , ExprList * pEList ) { 
line 84076: int e ; 
line 84077: if ( pIdList == 0 || NEVER ( pEList == 0 ) ) return 1 ; 
line 84078: for ( e = 0 ; e < pEList -> nExpr ; e ++ ) { 
line 84079: if ( sqlite3IdListIndex ( pIdList , pEList -> a [ e ] . zName ) >= 0 ) return 1 ; 
line 84080: } 
line 84081: return 0 ; 
line 84082: } 
line 84090: SQLITE_PRIVATE Trigger * sqlite3TriggersExist ( 
line 84091: Parse * pParse , 
line 84092: Table * pTab , 
line 84093: int op , 
line 84094: ExprList * pChanges , 
line 84095: int * pMask 
line 84096: ) { 
line 84097: int mask = 0 ; 
line 84098: Trigger * pList = sqlite3TriggerList ( pParse , pTab ) ; 
line 84099: Trigger * p ; 
line 84100: assert ( pList == 0 || IsVirtual ( pTab ) == 0 ) ; 
line 84101: for ( p = pList ; p ; p = p -> pNext ) { 
line 84102: if ( p -> op == op && checkColumnOverlap ( p -> pColumns , pChanges ) ) { 
line 84103: mask |= p -> tr_tm ; 
line 84104: } 
line 84105: } 
line 84106: if ( pMask ) { 
line 84107: * pMask = mask ; 
line 84108: } 
line 84109: return ( mask ? pList : 0 ) ; 
line 84110: } 
line 84122: static SrcList * targetSrcList ( 
line 84123: Parse * pParse , 
line 84124: TriggerStep * pStep 
line 84125: ) { 
line 84126: int iDb ; 
line 84127: SrcList * pSrc ; 
line 84129: pSrc = sqlite3SrcListAppend ( pParse -> db , 0 , & pStep -> target , 0 ) ; 
line 84130: if ( pSrc ) { 
line 84131: assert ( pSrc -> nSrc > 0 ) ; 
line 84132: assert ( pSrc -> a != 0 ) ; 
line 84133: iDb = sqlite3SchemaToIndex ( pParse -> db , pStep -> pTrig -> pSchema ) ; 
line 84134: if ( iDb == 0 || iDb >= 2 ) { 
line 84135: sqlite3 * db = pParse -> db ; 
line 84136: assert ( iDb < pParse -> db -> nDb ) ; 
line 84137: pSrc -> a [ pSrc -> nSrc - 1 ] . zDatabase = sqlite3DbStrDup ( db , db -> aDb [ iDb ] . zName ) ; 
line 84138: } 
line 84139: } 
line 84140: return pSrc ; 
line 84141: } 
line 84147: static int codeTriggerProgram ( 
line 84148: Parse * pParse , 
line 84149: TriggerStep * pStepList , 
line 84150: int orconf 
line 84151: ) { 
line 84152: TriggerStep * pStep ; 
line 84153: Vdbe * v = pParse -> pVdbe ; 
line 84154: sqlite3 * db = pParse -> db ; 
line 84156: assert ( pParse -> pTriggerTab && pParse -> pToplevel ) ; 
line 84157: assert ( pStepList ) ; 
line 84158: assert ( v != 0 ) ; 
line 84159: for ( pStep = pStepList ; pStep ; pStep = pStep -> pNext ) { 
line 84173: pParse -> eOrconf = ( orconf == OE_Default ) ? pStep -> orconf : ( u8 ) orconf ; 
line 84175: switch ( pStep -> op ) { 
line 84176: case TK_UPDATE : { 
line 84177: sqlite3Update ( pParse , 
line 84178: targetSrcList ( pParse , pStep ) , 
line 84179: sqlite3ExprListDup ( db , pStep -> pExprList , 0 ) , 
line 84180: sqlite3ExprDup ( db , pStep -> pWhere , 0 ) , 
line 84181: pParse -> eOrconf 
line 84182: ) ; 
line 84183: break ; 
line 84184: } 
line 84185: case TK_INSERT : { 
line 84186: sqlite3Insert ( pParse , 
line 84187: targetSrcList ( pParse , pStep ) , 
line 84188: sqlite3ExprListDup ( db , pStep -> pExprList , 0 ) , 
line 84189: sqlite3SelectDup ( db , pStep -> pSelect , 0 ) , 
line 84190: sqlite3IdListDup ( db , pStep -> pIdList ) , 
line 84191: pParse -> eOrconf 
line 84192: ) ; 
line 84193: break ; 
line 84194: } 
line 84195: case TK_DELETE : { 
line 84196: sqlite3DeleteFrom ( pParse , 
line 84197: targetSrcList ( pParse , pStep ) , 
line 84198: sqlite3ExprDup ( db , pStep -> pWhere , 0 ) 
line 84199: ) ; 
line 84200: break ; 
line 84201: } 
line 84202: default : assert ( pStep -> op == TK_SELECT ) ; { 
line 84203: SelectDest sDest ; 
line 84204: Select * pSelect = sqlite3SelectDup ( db , pStep -> pSelect , 0 ) ; 
line 84205: sqlite3SelectDestInit ( & sDest , SRT_Discard , 0 ) ; 
line 84206: sqlite3Select ( pParse , pSelect , & sDest ) ; 
line 84207: sqlite3SelectDelete ( db , pSelect ) ; 
line 84208: break ; 
line 84209: } 
line 84210: } 
line 84211: if ( pStep -> op != TK_SELECT ) { 
line 84212: sqlite3VdbeAddOp0 ( v , OP_ResetCount ) ; 
line 84213: } 
line 84214: } 
line 84216: return 0 ; 
line 84217: } 
line 84219: # ifdef SQLITE_DEBUG 
line 84224: static const char * onErrorText ( int onError ) { 
line 84225: switch ( onError ) { 
line 84226: case OE_Abort : return "abort" ; 
line 84227: case OE_Rollback : return "rollback" ; 
line 84228: case OE_Fail : return "fail" ; 
line 84229: case OE_Replace : return "replace" ; 
line 84230: case OE_Ignore : return "ignore" ; 
line 84231: case OE_Default : return "default" ; 
line 84232: } 
line 84233: return "n/a" ; 
line 84234: } 
line 84235: # endif 
line 84242: static void transferParseError ( Parse * pTo , Parse * pFrom ) { 
line 84243: assert ( pFrom -> zErrMsg == 0 || pFrom -> nErr ) ; 
line 84244: assert ( pTo -> zErrMsg == 0 || pTo -> nErr ) ; 
line 84245: if ( pTo -> nErr == 0 ) { 
line 84246: pTo -> zErrMsg = pFrom -> zErrMsg ; 
line 84247: pTo -> nErr = pFrom -> nErr ; 
line 84248: } else { 
line 84249: sqlite3DbFree ( pFrom -> db , pFrom -> zErrMsg ) ; 
line 84250: } 
line 84251: } 
line 84257: static TriggerPrg * codeRowTrigger ( 
line 84258: Parse * pParse , 
line 84259: Trigger * pTrigger , 
line 84260: Table * pTab , 
line 84261: int orconf 
line 84262: ) { 
line 84263: Parse * pTop = sqlite3ParseToplevel ( pParse ) ; 
line 84264: sqlite3 * db = pParse -> db ; 
line 84265: TriggerPrg * pPrg ; 
line 84266: Expr * pWhen = 0 ; 
line 84267: Vdbe * v ; 
line 84268: NameContext sNC ; 
line 84269: SubProgram * pProgram = 0 ; 
line 84270: Parse * pSubParse ; 
line 84271: int iEndTrigger = 0 ; 
line 84273: assert ( pTrigger -> zName == 0 || pTab == tableOfTrigger ( pTrigger ) ) ; 
line 84278: pPrg = sqlite3DbMallocZero ( db , sizeof ( TriggerPrg ) ) ; 
line 84279: if ( ! pPrg ) return 0 ; 
line 84280: pPrg -> pNext = pTop -> pTriggerPrg ; 
line 84281: pTop -> pTriggerPrg = pPrg ; 
line 84282: pPrg -> pProgram = pProgram = sqlite3DbMallocZero ( db , sizeof ( SubProgram ) ) ; 
line 84283: if ( ! pProgram ) return 0 ; 
line 84284: pProgram -> nRef = 1 ; 
line 84285: pPrg -> pTrigger = pTrigger ; 
line 84286: pPrg -> orconf = orconf ; 
line 84287: pPrg -> aColmask [ 0 ] = 0xffffffff ; 
line 84288: pPrg -> aColmask [ 1 ] = 0xffffffff ; 
line 84292: pSubParse = sqlite3StackAllocZero ( db , sizeof ( Parse ) ) ; 
line 84293: if ( ! pSubParse ) return 0 ; 
line 84294: memset ( & sNC , 0 , sizeof ( sNC ) ) ; 
line 84295: sNC . pParse = pSubParse ; 
line 84296: pSubParse -> db = db ; 
line 84297: pSubParse -> pTriggerTab = pTab ; 
line 84298: pSubParse -> pToplevel = pTop ; 
line 84299: pSubParse -> zAuthContext = pTrigger -> zName ; 
line 84300: pSubParse -> eTriggerOp = pTrigger -> op ; 
line 84302: v = sqlite3GetVdbe ( pSubParse ) ; 
line 84303: if ( v ) { 
line 84304: VdbeComment ( ( v , "Start: %s.%s (%s %s%s%s ON %s)" , 
line 84305: pTrigger -> zName , onErrorText ( orconf ) , 
line 84306: ( pTrigger -> tr_tm == TRIGGER_BEFORE ? "BEFORE" : "AFTER" ) , 
line 84307: ( pTrigger -> op == TK_UPDATE ? "UPDATE" : "" ) , 
line 84308: ( pTrigger -> op == TK_INSERT ? "INSERT" : "" ) , 
line 84309: ( pTrigger -> op == TK_DELETE ? "DELETE" : "" ) , 
line 84310: pTab -> zName 
line 84311: ) ) ; 
line 84312: # ifndef SQLITE_OMIT_TRACE 
line 84313: sqlite3VdbeChangeP4 ( v , - 1 , 
line 84314: sqlite3MPrintf ( db , "-- TRIGGER %s" , pTrigger -> zName ) , P4_DYNAMIC 
line 84315: ) ; 
line 84316: # endif 
line 84321: if ( pTrigger -> pWhen ) { 
line 84322: pWhen = sqlite3ExprDup ( db , pTrigger -> pWhen , 0 ) ; 
line 84323: if ( SQLITE_OK == sqlite3ResolveExprNames ( & sNC , pWhen ) 
line 84324: && db -> mallocFailed == 0 
line 84325: ) { 
line 84326: iEndTrigger = sqlite3VdbeMakeLabel ( v ) ; 
line 84327: sqlite3ExprIfFalse ( pSubParse , pWhen , iEndTrigger , SQLITE_JUMPIFNULL ) ; 
line 84328: } 
line 84329: sqlite3ExprDelete ( db , pWhen ) ; 
line 84330: } 
line 84333: codeTriggerProgram ( pSubParse , pTrigger -> step_list , orconf ) ; 
line 84336: if ( iEndTrigger ) { 
line 84337: sqlite3VdbeResolveLabel ( v , iEndTrigger ) ; 
line 84338: } 
line 84339: sqlite3VdbeAddOp0 ( v , OP_Halt ) ; 
line 84340: VdbeComment ( ( v , "End: %s.%s" , pTrigger -> zName , onErrorText ( orconf ) ) ) ; 
line 84342: transferParseError ( pParse , pSubParse ) ; 
line 84343: if ( db -> mallocFailed == 0 ) { 
line 84344: pProgram -> aOp = sqlite3VdbeTakeOpArray ( v , & pProgram -> nOp , & pTop -> nMaxArg ) ; 
line 84345: } 
line 84346: pProgram -> nMem = pSubParse -> nMem ; 
line 84347: pProgram -> nCsr = pSubParse -> nTab ; 
line 84348: pProgram -> token = ( void * ) pTrigger ; 
line 84349: pPrg -> aColmask [ 0 ] = pSubParse -> oldmask ; 
line 84350: pPrg -> aColmask [ 1 ] = pSubParse -> newmask ; 
line 84351: sqlite3VdbeDelete ( v ) ; 
line 84352: } 
line 84354: assert ( ! pSubParse -> pAinc && ! pSubParse -> pZombieTab ) ; 
line 84355: assert ( ! pSubParse -> pTriggerPrg && ! pSubParse -> nMaxArg ) ; 
line 84356: sqlite3StackFree ( db , pSubParse ) ; 
line 84358: return pPrg ; 
line 84359: } 
line 84367: static TriggerPrg * getRowTrigger ( 
line 84368: Parse * pParse , 
line 84369: Trigger * pTrigger , 
line 84370: Table * pTab , 
line 84371: int orconf 
line 84372: ) { 
line 84373: Parse * pRoot = sqlite3ParseToplevel ( pParse ) ; 
line 84374: TriggerPrg * pPrg ; 
line 84376: assert ( pTrigger -> zName == 0 || pTab == tableOfTrigger ( pTrigger ) ) ; 
line 84382: for ( pPrg = pRoot -> pTriggerPrg ; 
line 84383: pPrg && ( pPrg -> pTrigger != pTrigger || pPrg -> orconf != orconf ) ; 
line 84384: pPrg = pPrg -> pNext 
line 84385: ) ; 
line 84388: if ( ! pPrg ) { 
line 84389: pPrg = codeRowTrigger ( pParse , pTrigger , pTab , orconf ) ; 
line 84390: } 
line 84392: return pPrg ; 
line 84393: } 
line 84401: SQLITE_PRIVATE void sqlite3CodeRowTriggerDirect ( 
line 84402: Parse * pParse , 
line 84403: Trigger * p , 
line 84404: Table * pTab , 
line 84405: int reg , 
line 84406: int orconf , 
line 84407: int ignoreJump 
line 84408: ) { 
line 84409: Vdbe * v = sqlite3GetVdbe ( pParse ) ; 
line 84410: TriggerPrg * pPrg ; 
line 84411: pPrg = getRowTrigger ( pParse , p , pTab , orconf ) ; 
line 84412: assert ( pPrg || pParse -> nErr || pParse -> db -> mallocFailed ) ; 
line 84416: if ( pPrg ) { 
line 84417: sqlite3VdbeAddOp3 ( v , OP_Program , reg , ignoreJump , ++ pParse -> nMem ) ; 
line 84418: pPrg -> pProgram -> nRef ++ ; 
line 84419: sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pPrg -> pProgram , P4_SUBPROGRAM ) ; 
line 84420: VdbeComment ( 
line 84421: ( v , "Call: %s.%s" , ( p -> zName ? p -> zName : "fkey" ) , onErrorText ( orconf ) ) ) ; 
line 84428: sqlite3VdbeChangeP5 ( v , ( u8 ) ( p -> zName && ! ( pParse -> db -> flags & SQLITE_RecTriggers ) ) ) ; 
line 84429: } 
line 84430: } 
line 84472: SQLITE_PRIVATE void sqlite3CodeRowTrigger ( 
line 84473: Parse * pParse , 
line 84474: Trigger * pTrigger , 
line 84475: int op , 
line 84476: ExprList * pChanges , 
line 84477: int tr_tm , 
line 84478: Table * pTab , 
line 84479: int reg , 
line 84480: int orconf , 
line 84481: int ignoreJump 
line 84482: ) { 
line 84483: Trigger * p ; 
line 84485: assert ( op == TK_UPDATE || op == TK_INSERT || op == TK_DELETE ) ; 
line 84486: assert ( tr_tm == TRIGGER_BEFORE || tr_tm == TRIGGER_AFTER ) ; 
line 84487: assert ( ( op == TK_UPDATE ) == ( pChanges != 0 ) ) ; 
line 84489: for ( p = pTrigger ; p ; p = p -> pNext ) { 
line 84494: assert ( p -> pSchema != 0 ) ; 
line 84495: assert ( p -> pTabSchema != 0 ) ; 
line 84496: assert ( p -> pSchema == p -> pTabSchema 
line 84497: || p -> pSchema == pParse -> db -> aDb [ 1 ] . pSchema ) ; 
line 84500: if ( p -> op == op 
line 84501: && p -> tr_tm == tr_tm 
line 84502: && checkColumnOverlap ( p -> pColumns , pChanges ) 
line 84503: ) { 
line 84504: sqlite3CodeRowTriggerDirect ( pParse , p , pTab , reg , orconf , ignoreJump ) ; 
line 84505: } 
line 84506: } 
line 84507: } 
line 84534: SQLITE_PRIVATE u32 sqlite3TriggerColmask ( 
line 84535: Parse * pParse , 
line 84536: Trigger * pTrigger , 
line 84537: ExprList * pChanges , 
line 84538: int isNew , 
line 84539: int tr_tm , 
line 84540: Table * pTab , 
line 84541: int orconf 
line 84542: ) { 
line 84543: const int op = pChanges ? TK_UPDATE : TK_DELETE ; 
line 84544: u32 mask = 0 ; 
line 84545: Trigger * p ; 
line 84547: assert ( isNew == 1 || isNew == 0 ) ; 
line 84548: for ( p = pTrigger ; p ; p = p -> pNext ) { 
line 84549: if ( p -> op == op && ( tr_tm & p -> tr_tm ) 
line 84550: && checkColumnOverlap ( p -> pColumns , pChanges ) 
line 84551: ) { 
line 84552: TriggerPrg * pPrg ; 
line 84553: pPrg = getRowTrigger ( pParse , p , pTab , orconf ) ; 
line 84554: if ( pPrg ) { 
line 84555: mask |= pPrg -> aColmask [ isNew ] ; 
line 84556: } 
line 84557: } 
line 84558: } 
line 84560: return mask ; 
line 84561: } 
line 84563: # endif 
line 84582: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 84584: static void updateVirtualTable ( 
line 84585: Parse * pParse , 
line 84586: SrcList * pSrc , 
line 84587: Table * pTab , 
line 84588: ExprList * pChanges , 
line 84589: Expr * pRowidExpr , 
line 84590: int * aXRef , 
line 84591: Expr * pWhere 
line 84592: ) ; 
line 84593: # endif 
line 84625: SQLITE_PRIVATE void sqlite3ColumnDefault ( Vdbe * v , Table * pTab , int i , int iReg ) { 
line 84626: assert ( pTab != 0 ) ; 
line 84627: if ( ! pTab -> pSelect ) { 
line 84628: sqlite3_value * pValue ; 
line 84629: u8 enc = ENC ( sqlite3VdbeDb ( v ) ) ; 
line 84630: Column * pCol = & pTab -> aCol [ i ] ; 
line 84631: VdbeComment ( ( v , "%s.%s" , pTab -> zName , pCol -> zName ) ) ; 
line 84632: assert ( i < pTab -> nCol ) ; 
line 84633: sqlite3ValueFromExpr ( sqlite3VdbeDb ( v ) , pCol -> pDflt , enc , 
line 84634: pCol -> affinity , & pValue ) ; 
line 84635: if ( pValue ) { 
line 84636: sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pValue , P4_MEM ) ; 
line 84637: } 
line 84638: # ifndef SQLITE_OMIT_FLOATING_POINT 
line 84639: if ( iReg >= 0 && pTab -> aCol [ i ] . affinity == SQLITE_AFF_REAL ) { 
line 84640: sqlite3VdbeAddOp1 ( v , OP_RealAffinity , iReg ) ; 
line 84641: } 
line 84642: # endif 
line 84643: } 
line 84644: } 
line 84653: SQLITE_PRIVATE void sqlite3Update ( 
line 84654: Parse * pParse , 
line 84655: SrcList * pTabList , 
line 84656: ExprList * pChanges , 
line 84657: Expr * pWhere , 
line 84658: int onError 
line 84659: ) { 
line 84660: int i , j ; 
line 84661: Table * pTab ; 
line 84662: int addr = 0 ; 
line 84663: WhereInfo * pWInfo ; 
line 84664: Vdbe * v ; 
line 84665: Index * pIdx ; 
line 84666: int nIdx ; 
line 84667: int iCur ; 
line 84668: sqlite3 * db ; 
line 84669: int * aRegIdx = 0 ; 
line 84670: int * aXRef = 0 ; 
line 84673: int chngRowid ; 
line 84674: Expr * pRowidExpr = 0 ; 
line 84675: int openAll = 0 ; 
line 84676: AuthContext sContext ; 
line 84677: NameContext sNC ; 
line 84678: int iDb ; 
line 84679: int okOnePass ; 
line 84680: int hasFK ; 
line 84682: # ifndef SQLITE_OMIT_TRIGGER 
line 84683: int isView ; 
line 84684: Trigger * pTrigger ; 
line 84685: int tmask ; 
line 84686: # endif 
line 84687: int newmask ; 
line 84690: int regRowCount = 0 ; 
line 84691: int regOldRowid ; 
line 84692: int regNewRowid ; 
line 84693: int regNew ; 
line 84694: int regOld = 0 ; 
line 84695: int regRowSet = 0 ; 
line 84696: int regRec ; 
line 84698: memset ( & sContext , 0 , sizeof ( sContext ) ) ; 
line 84699: db = pParse -> db ; 
line 84700: if ( pParse -> nErr || db -> mallocFailed ) { 
line 84701: goto update_cleanup ; 
line 84702: } 
line 84703: assert ( pTabList -> nSrc == 1 ) ; 
line 84707: pTab = sqlite3SrcListLookup ( pParse , pTabList ) ; 
line 84708: if ( pTab == 0 ) goto update_cleanup ; 
line 84709: iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; 
line 84714: # ifndef SQLITE_OMIT_TRIGGER 
line 84715: pTrigger = sqlite3TriggersExist ( pParse , pTab , TK_UPDATE , pChanges , & tmask ) ; 
line 84716: isView = pTab -> pSelect != 0 ; 
line 84717: assert ( pTrigger || tmask == 0 ) ; 
line 84718: # else 
line 84719: # define pTrigger 0 
line 84720: # define isView 0 
line 84721: # define tmask 0 
line 84722: # endif 
line 84723: # ifdef SQLITE_OMIT_VIEW 
line 84724: # undef isView 
line 84725: # define isView 0 
line 84726: # endif 
line 84728: if ( sqlite3ViewGetColumnNames ( pParse , pTab ) ) { 
line 84729: goto update_cleanup ; 
line 84730: } 
line 84731: if ( sqlite3IsReadOnly ( pParse , pTab , tmask ) ) { 
line 84732: goto update_cleanup ; 
line 84733: } 
line 84734: aXRef = sqlite3DbMallocRaw ( db , sizeof ( int ) * pTab -> nCol ) ; 
line 84735: if ( aXRef == 0 ) goto update_cleanup ; 
line 84736: for ( i = 0 ; i < pTab -> nCol ; i ++ ) aXRef [ i ] = - 1 ; 
line 84743: pTabList -> a [ 0 ] . iCursor = iCur = pParse -> nTab ++ ; 
line 84744: for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { 
line 84745: pParse -> nTab ++ ; 
line 84746: } 
line 84749: memset ( & sNC , 0 , sizeof ( sNC ) ) ; 
line 84750: sNC . pParse = pParse ; 
line 84751: sNC . pSrcList = pTabList ; 
line 84759: chngRowid = 0 ; 
line 84760: for ( i = 0 ; i < pChanges -> nExpr ; i ++ ) { 
line 84761: if ( sqlite3ResolveExprNames ( & sNC , pChanges -> a [ i ] . pExpr ) ) { 
line 84762: goto update_cleanup ; 
line 84763: } 
line 84764: for ( j = 0 ; j < pTab -> nCol ; j ++ ) { 
line 84765: if ( sqlite3StrICmp ( pTab -> aCol [ j ] . zName , pChanges -> a [ i ] . zName ) == 0 ) { 
line 84766: if ( j == pTab -> iPKey ) { 
line 84767: chngRowid = 1 ; 
line 84768: pRowidExpr = pChanges -> a [ i ] . pExpr ; 
line 84769: } 
line 84770: aXRef [ j ] = i ; 
line 84771: break ; 
line 84772: } 
line 84773: } 
line 84774: if ( j >= pTab -> nCol ) { 
line 84775: if ( sqlite3IsRowid ( pChanges -> a [ i ] . zName ) ) { 
line 84776: chngRowid = 1 ; 
line 84777: pRowidExpr = pChanges -> a [ i ] . pExpr ; 
line 84778: } else { 
line 84779: sqlite3ErrorMsg ( pParse , "no such column: %s" , pChanges -> a [ i ] . zName ) ; 
line 84780: goto update_cleanup ; 
line 84781: } 
line 84782: } 
line 84783: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 84784: { 
line 84785: int rc ; 
line 84786: rc = sqlite3AuthCheck ( pParse , SQLITE_UPDATE , pTab -> zName , 
line 84787: pTab -> aCol [ j ] . zName , db -> aDb [ iDb ] . zName ) ; 
line 84788: if ( rc == SQLITE_DENY ) { 
line 84789: goto update_cleanup ; 
line 84790: } else if ( rc == SQLITE_IGNORE ) { 
line 84791: aXRef [ j ] = - 1 ; 
line 84792: } 
line 84793: } 
line 84794: # endif 
line 84795: } 
line 84797: hasFK = sqlite3FkRequired ( pParse , pTab , aXRef , chngRowid ) ; 
line 84804: for ( nIdx = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , nIdx ++ ) { } 
line 84805: if ( nIdx > 0 ) { 
line 84806: aRegIdx = sqlite3DbMallocRaw ( db , sizeof ( Index * ) * nIdx ) ; 
line 84807: if ( aRegIdx == 0 ) goto update_cleanup ; 
line 84808: } 
line 84809: for ( j = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , j ++ ) { 
line 84810: int reg ; 
line 84811: if ( chngRowid ) { 
line 84812: reg = ++ pParse -> nMem ; 
line 84813: } else { 
line 84814: reg = 0 ; 
line 84815: for ( i = 0 ; i < pIdx -> nColumn ; i ++ ) { 
line 84816: if ( aXRef [ pIdx -> aiColumn [ i ] ] >= 0 ) { 
line 84817: reg = ++ pParse -> nMem ; 
line 84818: break ; 
line 84819: } 
line 84820: } 
line 84821: } 
line 84822: aRegIdx [ j ] = reg ; 
line 84823: } 
line 84826: v = sqlite3GetVdbe ( pParse ) ; 
line 84827: if ( v == 0 ) goto update_cleanup ; 
line 84828: if ( pParse -> nested == 0 ) sqlite3VdbeCountChanges ( v ) ; 
line 84829: sqlite3BeginWriteOperation ( pParse , 1 , iDb ) ; 
line 84831: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 84833: if ( IsVirtual ( pTab ) ) { 
line 84834: updateVirtualTable ( pParse , pTabList , pTab , pChanges , pRowidExpr , aXRef , 
line 84835: pWhere ) ; 
line 84836: pWhere = 0 ; 
line 84837: pTabList = 0 ; 
line 84838: goto update_cleanup ; 
line 84839: } 
line 84840: # endif 
line 84843: regOldRowid = regNewRowid = ++ pParse -> nMem ; 
line 84844: if ( pTrigger || hasFK ) { 
line 84845: regOld = pParse -> nMem + 1 ; 
line 84846: pParse -> nMem += pTab -> nCol ; 
line 84847: } 
line 84848: if ( chngRowid || pTrigger || hasFK ) { 
line 84849: regNewRowid = ++ pParse -> nMem ; 
line 84850: } 
line 84851: regNew = pParse -> nMem + 1 ; 
line 84852: pParse -> nMem += pTab -> nCol ; 
line 84853: regRec = ++ pParse -> nMem ; 
line 84856: if ( isView ) { 
line 84857: sqlite3AuthContextPush ( pParse , & sContext , pTab -> zName ) ; 
line 84858: } 
line 84863: # if ! defined ( SQLITE_OMIT_VIEW ) && ! defined ( SQLITE_OMIT_TRIGGER ) 
line 84864: if ( isView ) { 
line 84865: sqlite3MaterializeView ( pParse , pTab , pWhere , iCur ) ; 
line 84866: } 
line 84867: # endif 
line 84872: if ( sqlite3ResolveExprNames ( & sNC , pWhere ) ) { 
line 84873: goto update_cleanup ; 
line 84874: } 
line 84878: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , regOldRowid ) ; 
line 84879: pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , 0 , WHERE_ONEPASS_DESIRED ) ; 
line 84880: if ( pWInfo == 0 ) goto update_cleanup ; 
line 84881: okOnePass = pWInfo -> okOnePass ; 
line 84885: sqlite3VdbeAddOp2 ( v , OP_Rowid , iCur , regOldRowid ) ; 
line 84886: if ( ! okOnePass ) { 
line 84887: regRowSet = ++ pParse -> nMem ; 
line 84888: sqlite3VdbeAddOp2 ( v , OP_RowSetAdd , regRowSet , regOldRowid ) ; 
line 84889: } 
line 84893: sqlite3WhereEnd ( pWInfo ) ; 
line 84897: if ( ( db -> flags & SQLITE_CountRows ) && ! pParse -> pTriggerTab ) { 
line 84898: regRowCount = ++ pParse -> nMem ; 
line 84899: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regRowCount ) ; 
line 84900: } 
line 84902: if ( ! isView ) { 
line 84909: if ( ! okOnePass ) sqlite3OpenTable ( pParse , iCur , iDb , pTab , OP_OpenWrite ) ; 
line 84910: if ( onError == OE_Replace ) { 
line 84911: openAll = 1 ; 
line 84912: } else { 
line 84913: openAll = 0 ; 
line 84914: for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { 
line 84915: if ( pIdx -> onError == OE_Replace ) { 
line 84916: openAll = 1 ; 
line 84917: break ; 
line 84918: } 
line 84919: } 
line 84920: } 
line 84921: for ( i = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , i ++ ) { 
line 84922: if ( openAll || aRegIdx [ i ] > 0 ) { 
line 84923: KeyInfo * pKey = sqlite3IndexKeyinfo ( pParse , pIdx ) ; 
line 84924: sqlite3VdbeAddOp4 ( v , OP_OpenWrite , iCur + i + 1 , pIdx -> tnum , iDb , 
line 84925: ( char * ) pKey , P4_KEYINFO_HANDOFF ) ; 
line 84926: assert ( pParse -> nTab > iCur + i + 1 ) ; 
line 84927: } 
line 84928: } 
line 84929: } 
line 84932: if ( okOnePass ) { 
line 84933: int a1 = sqlite3VdbeAddOp1 ( v , OP_NotNull , regOldRowid ) ; 
line 84934: addr = sqlite3VdbeAddOp0 ( v , OP_Goto ) ; 
line 84935: sqlite3VdbeJumpHere ( v , a1 ) ; 
line 84936: } else { 
line 84937: addr = sqlite3VdbeAddOp3 ( v , OP_RowSetRead , regRowSet , 0 , regOldRowid ) ; 
line 84938: } 
line 84943: sqlite3VdbeAddOp3 ( v , OP_NotExists , iCur , addr , regOldRowid ) ; 
line 84949: assert ( chngRowid || pTrigger || hasFK || regOldRowid == regNewRowid ) ; 
line 84950: if ( chngRowid ) { 
line 84951: sqlite3ExprCode ( pParse , pRowidExpr , regNewRowid ) ; 
line 84952: sqlite3VdbeAddOp1 ( v , OP_MustBeInt , regNewRowid ) ; 
line 84953: } 
line 84957: if ( hasFK || pTrigger ) { 
line 84958: u32 oldmask = ( hasFK ? sqlite3FkOldmask ( pParse , pTab ) : 0 ) ; 
line 84959: oldmask |= sqlite3TriggerColmask ( pParse , 
line 84960: pTrigger , pChanges , 0 , TRIGGER_BEFORE | TRIGGER_AFTER , pTab , onError 
line 84961: ) ; 
line 84962: for ( i = 0 ; i < pTab -> nCol ; i ++ ) { 
line 84963: if ( aXRef [ i ] < 0 || oldmask == 0xffffffff || ( oldmask & ( 1 << i ) ) ) { 
line 84964: sqlite3VdbeAddOp3 ( v , OP_Column , iCur , i , regOld + i ) ; 
line 84965: sqlite3ColumnDefault ( v , pTab , i , regOld + i ) ; 
line 84966: } else { 
line 84967: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , regOld + i ) ; 
line 84968: } 
line 84969: } 
line 84970: if ( chngRowid == 0 ) { 
line 84971: sqlite3VdbeAddOp2 ( v , OP_Copy , regOldRowid , regNewRowid ) ; 
line 84972: } 
line 84973: } 
line 84988: newmask = sqlite3TriggerColmask ( 
line 84989: pParse , pTrigger , pChanges , 1 , TRIGGER_BEFORE , pTab , onError 
line 84990: ) ; 
line 84991: for ( i = 0 ; i < pTab -> nCol ; i ++ ) { 
line 84992: if ( i == pTab -> iPKey ) { 
line 84993: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , regNew + i ) ; 
line 84994: } else { 
line 84995: j = aXRef [ i ] ; 
line 84996: if ( j >= 0 ) { 
line 84997: sqlite3ExprCode ( pParse , pChanges -> a [ j ] . pExpr , regNew + i ) ; 
line 84998: } else if ( 0 == ( tmask & TRIGGER_BEFORE ) || i > 31 || ( newmask & ( 1 << i ) ) ) { 
line 85004: testcase ( i == 31 ) ; 
line 85005: testcase ( i == 32 ) ; 
line 85006: sqlite3VdbeAddOp3 ( v , OP_Column , iCur , i , regNew + i ) ; 
line 85007: sqlite3ColumnDefault ( v , pTab , i , regNew + i ) ; 
line 85008: } 
line 85009: } 
line 85010: } 
line 85015: if ( tmask & TRIGGER_BEFORE ) { 
line 85016: sqlite3VdbeAddOp2 ( v , OP_Affinity , regNew , pTab -> nCol ) ; 
line 85017: sqlite3TableAffinityStr ( v , pTab ) ; 
line 85018: sqlite3CodeRowTrigger ( pParse , pTrigger , TK_UPDATE , pChanges , 
line 85019: TRIGGER_BEFORE , pTab , regOldRowid , onError , addr ) ; 
line 85027: sqlite3VdbeAddOp3 ( v , OP_NotExists , iCur , addr , regOldRowid ) ; 
line 85034: for ( i = 0 ; i < pTab -> nCol ; i ++ ) { 
line 85035: if ( aXRef [ i ] < 0 && i != pTab -> iPKey ) { 
line 85036: sqlite3VdbeAddOp3 ( v , OP_Column , iCur , i , regNew + i ) ; 
line 85037: sqlite3ColumnDefault ( v , pTab , i , regNew + i ) ; 
line 85038: } 
line 85039: } 
line 85040: } 
line 85042: if ( ! isView ) { 
line 85043: int j1 ; 
line 85046: sqlite3GenerateConstraintChecks ( pParse , pTab , iCur , regNewRowid , 
line 85047: aRegIdx , ( chngRowid ? regOldRowid : 0 ) , 1 , onError , addr , 0 ) ; 
line 85050: if ( hasFK ) { 
line 85051: sqlite3FkCheck ( pParse , pTab , regOldRowid , 0 ) ; 
line 85052: } 
line 85055: j1 = sqlite3VdbeAddOp3 ( v , OP_NotExists , iCur , 0 , regOldRowid ) ; 
line 85056: sqlite3GenerateRowIndexDelete ( pParse , pTab , iCur , aRegIdx ) ; 
line 85059: if ( hasFK || chngRowid ) { 
line 85060: sqlite3VdbeAddOp2 ( v , OP_Delete , iCur , 0 ) ; 
line 85061: } 
line 85062: sqlite3VdbeJumpHere ( v , j1 ) ; 
line 85064: if ( hasFK ) { 
line 85065: sqlite3FkCheck ( pParse , pTab , 0 , regNewRowid ) ; 
line 85066: } 
line 85069: sqlite3CompleteInsertion ( pParse , pTab , iCur , regNewRowid , aRegIdx , 1 , 0 , 0 ) ; 
line 85074: if ( hasFK ) { 
line 85075: sqlite3FkActions ( pParse , pTab , pChanges , regOldRowid ) ; 
line 85076: } 
line 85077: } 
line 85081: if ( ( db -> flags & SQLITE_CountRows ) && ! pParse -> pTriggerTab ) { 
line 85082: sqlite3VdbeAddOp2 ( v , OP_AddImm , regRowCount , 1 ) ; 
line 85083: } 
line 85085: sqlite3CodeRowTrigger ( pParse , pTrigger , TK_UPDATE , pChanges , 
line 85086: TRIGGER_AFTER , pTab , regOldRowid , onError , addr ) ; 
line 85091: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , addr ) ; 
line 85092: sqlite3VdbeJumpHere ( v , addr ) ; 
line 85095: for ( i = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , i ++ ) { 
line 85096: if ( openAll || aRegIdx [ i ] > 0 ) { 
line 85097: sqlite3VdbeAddOp2 ( v , OP_Close , iCur + i + 1 , 0 ) ; 
line 85098: } 
line 85099: } 
line 85100: sqlite3VdbeAddOp2 ( v , OP_Close , iCur , 0 ) ; 
line 85106: if ( pParse -> nested == 0 && pParse -> pTriggerTab == 0 ) { 
line 85107: sqlite3AutoincrementEnd ( pParse ) ; 
line 85108: } 
line 85115: if ( ( db -> flags & SQLITE_CountRows ) && ! pParse -> pTriggerTab && ! pParse -> nested ) { 
line 85116: sqlite3VdbeAddOp2 ( v , OP_ResultRow , regRowCount , 1 ) ; 
line 85117: sqlite3VdbeSetNumCols ( v , 1 ) ; 
line 85118: sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "rows updated" , SQLITE_STATIC ) ; 
line 85119: } 
line 85121: update_cleanup : 
line 85122: sqlite3AuthContextPop ( & sContext ) ; 
line 85123: sqlite3DbFree ( db , aRegIdx ) ; 
line 85124: sqlite3DbFree ( db , aXRef ) ; 
line 85125: sqlite3SrcListDelete ( db , pTabList ) ; 
line 85126: sqlite3ExprListDelete ( db , pChanges ) ; 
line 85127: sqlite3ExprDelete ( db , pWhere ) ; 
line 85128: return ; 
line 85129: } 
line 85133: # ifdef isView 
line 85134: # undef isView 
line 85135: # endif 
line 85136: # ifdef pTrigger 
line 85137: # undef pTrigger 
line 85138: # endif 
line 85140: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 85160: static void updateVirtualTable ( 
line 85161: Parse * pParse , 
line 85162: SrcList * pSrc , 
line 85163: Table * pTab , 
line 85164: ExprList * pChanges , 
line 85165: Expr * pRowid , 
line 85166: int * aXRef , 
line 85167: Expr * pWhere 
line 85168: ) { 
line 85169: Vdbe * v = pParse -> pVdbe ; 
line 85170: ExprList * pEList = 0 ; 
line 85171: Select * pSelect = 0 ; 
line 85172: Expr * pExpr ; 
line 85173: int ephemTab ; 
line 85174: int i ; 
line 85175: int addr ; 
line 85176: int iReg ; 
line 85177: sqlite3 * db = pParse -> db ; 
line 85178: const char * pVTab = ( const char * ) sqlite3GetVTable ( db , pTab ) ; 
line 85179: SelectDest dest ; 
line 85184: pEList = sqlite3ExprListAppend ( pParse , 0 , sqlite3Expr ( db , TK_ID , "_rowid_" ) ) ; 
line 85185: if ( pRowid ) { 
line 85186: pEList = sqlite3ExprListAppend ( pParse , pEList , 
line 85187: sqlite3ExprDup ( db , pRowid , 0 ) ) ; 
line 85188: } 
line 85189: assert ( pTab -> iPKey < 0 ) ; 
line 85190: for ( i = 0 ; i < pTab -> nCol ; i ++ ) { 
line 85191: if ( aXRef [ i ] >= 0 ) { 
line 85192: pExpr = sqlite3ExprDup ( db , pChanges -> a [ aXRef [ i ] ] . pExpr , 0 ) ; 
line 85193: } else { 
line 85194: pExpr = sqlite3Expr ( db , TK_ID , pTab -> aCol [ i ] . zName ) ; 
line 85195: } 
line 85196: pEList = sqlite3ExprListAppend ( pParse , pEList , pExpr ) ; 
line 85197: } 
line 85198: pSelect = sqlite3SelectNew ( pParse , pEList , pSrc , pWhere , 0 , 0 , 0 , 0 , 0 , 0 ) ; 
line 85203: assert ( v ) ; 
line 85204: ephemTab = pParse -> nTab ++ ; 
line 85205: sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , ephemTab , pTab -> nCol + 1 + ( pRowid != 0 ) ) ; 
line 85209: sqlite3SelectDestInit ( & dest , SRT_Table , ephemTab ) ; 
line 85210: sqlite3Select ( pParse , pSelect , & dest ) ; 
line 85213: iReg = ++ pParse -> nMem ; 
line 85214: pParse -> nMem += pTab -> nCol + 1 ; 
line 85215: addr = sqlite3VdbeAddOp2 ( v , OP_Rewind , ephemTab , 0 ) ; 
line 85216: sqlite3VdbeAddOp3 ( v , OP_Column , ephemTab , 0 , iReg ) ; 
line 85217: sqlite3VdbeAddOp3 ( v , OP_Column , ephemTab , ( pRowid ? 1 : 0 ) , iReg + 1 ) ; 
line 85218: for ( i = 0 ; i < pTab -> nCol ; i ++ ) { 
line 85219: sqlite3VdbeAddOp3 ( v , OP_Column , ephemTab , i + 1 + ( pRowid != 0 ) , iReg + 2 + i ) ; 
line 85220: } 
line 85221: sqlite3VtabMakeWritable ( pParse , pTab ) ; 
line 85222: sqlite3VdbeAddOp4 ( v , OP_VUpdate , 0 , pTab -> nCol + 2 , iReg , pVTab , P4_VTAB ) ; 
line 85223: sqlite3MayAbort ( pParse ) ; 
line 85224: sqlite3VdbeAddOp2 ( v , OP_Next , ephemTab , addr + 1 ) ; 
line 85225: sqlite3VdbeJumpHere ( v , addr ) ; 
line 85226: sqlite3VdbeAddOp2 ( v , OP_Close , ephemTab , 0 ) ; 
line 85229: sqlite3SelectDelete ( db , pSelect ) ; 
line 85230: } 
line 85231: # endif 
line 85252: # if ! defined ( SQLITE_OMIT_VACUUM ) && ! defined ( SQLITE_OMIT_ATTACH ) 
line 85256: static int execSql ( sqlite3 * db , const char * zSql ) { 
line 85257: sqlite3_stmt * pStmt ; 
line 85258: VVA_ONLY ( int rc ; ) 
line 85259: if ( ! zSql ) { 
line 85260: return SQLITE_NOMEM ; 
line 85261: } 
line 85262: if ( SQLITE_OK != sqlite3_prepare ( db , zSql , - 1 , & pStmt , 0 ) ) { 
line 85263: return sqlite3_errcode ( db ) ; 
line 85264: } 
line 85265: VVA_ONLY ( rc = ) sqlite3_step ( pStmt ) ; 
line 85266: assert ( rc != SQLITE_ROW ) ; 
line 85267: return sqlite3_finalize ( pStmt ) ; 
line 85268: } 
line 85274: static int execExecSql ( sqlite3 * db , const char * zSql ) { 
line 85275: sqlite3_stmt * pStmt ; 
line 85276: int rc ; 
line 85278: rc = sqlite3_prepare ( db , zSql , - 1 , & pStmt , 0 ) ; 
line 85279: if ( rc != SQLITE_OK ) return rc ; 
line 85281: while ( SQLITE_ROW == sqlite3_step ( pStmt ) ) { 
line 85282: rc = execSql ( db , ( char * ) sqlite3_column_text ( pStmt , 0 ) ) ; 
line 85283: if ( rc != SQLITE_OK ) { 
line 85284: sqlite3_finalize ( pStmt ) ; 
line 85285: return rc ; 
line 85286: } 
line 85287: } 
line 85289: return sqlite3_finalize ( pStmt ) ; 
line 85290: } 
line 85302: SQLITE_PRIVATE void sqlite3Vacuum ( Parse * pParse ) { 
line 85303: Vdbe * v = sqlite3GetVdbe ( pParse ) ; 
line 85304: if ( v ) { 
line 85305: sqlite3VdbeAddOp2 ( v , OP_Vacuum , 0 , 0 ) ; 
line 85306: } 
line 85307: return ; 
line 85308: } 
line 85313: SQLITE_PRIVATE int sqlite3RunVacuum ( char * * pzErrMsg , sqlite3 * db ) { 
line 85314: int rc = SQLITE_OK ; 
line 85315: Btree * pMain ; 
line 85316: Btree * pTemp ; 
line 85317: char * zSql = 0 ; 
line 85318: int saved_flags ; 
line 85319: int saved_nChange ; 
line 85320: int saved_nTotalChange ; 
line 85321: void ( * saved_xTrace ) ( void * , const char * ) ; 
line 85322: Db * pDb = 0 ; 
line 85323: int isMemDb ; 
line 85324: int nRes ; 
line 85326: if ( ! db -> autoCommit ) { 
line 85327: sqlite3SetString ( pzErrMsg , db , "cannot VACUUM from within a transaction" ) ; 
line 85328: return SQLITE_ERROR ; 
line 85329: } 
line 85334: saved_flags = db -> flags ; 
line 85335: saved_nChange = db -> nChange ; 
line 85336: saved_nTotalChange = db -> nTotalChange ; 
line 85337: saved_xTrace = db -> xTrace ; 
line 85338: db -> flags |= SQLITE_WriteSchema | SQLITE_IgnoreChecks ; 
line 85339: db -> flags &= ~ SQLITE_ForeignKeys ; 
line 85340: db -> xTrace = 0 ; 
line 85342: pMain = db -> aDb [ 0 ] . pBt ; 
line 85343: isMemDb = sqlite3PagerIsMemdb ( sqlite3BtreePager ( pMain ) ) ; 
line 85359: zSql = "ATTACH '' AS vacuum_db;" ; 
line 85360: rc = execSql ( db , zSql ) ; 
line 85361: if ( rc != SQLITE_OK ) goto end_of_vacuum ; 
line 85362: pDb = & db -> aDb [ db -> nDb - 1 ] ; 
line 85363: assert ( strcmp ( db -> aDb [ db -> nDb - 1 ] . zName , "vacuum_db" ) == 0 ) ; 
line 85364: pTemp = db -> aDb [ db -> nDb - 1 ] . pBt ; 
line 85370: sqlite3BtreeCommit ( pTemp ) ; 
line 85372: nRes = sqlite3BtreeGetReserve ( pMain ) ; 
line 85375: # ifdef SQLITE_HAS_CODEC 
line 85376: if ( db -> nextPagesize ) { 
line 85377: extern void sqlite3CodecGetKey ( sqlite3 * , int , void * * , int * ) ; 
line 85378: int nKey ; 
line 85379: char * zKey ; 
line 85380: sqlite3CodecGetKey ( db , 0 , ( void * * ) & zKey , & nKey ) ; 
line 85381: if ( nKey ) db -> nextPagesize = 0 ; 
line 85382: } 
line 85383: # endif 
line 85385: if ( sqlite3BtreeSetPageSize ( pTemp , sqlite3BtreeGetPageSize ( pMain ) , nRes , 0 ) 
line 85386: || ( ! isMemDb && sqlite3BtreeSetPageSize ( pTemp , db -> nextPagesize , nRes , 0 ) ) 
line 85387: || NEVER ( db -> mallocFailed ) 
line 85388: ) { 
line 85389: rc = SQLITE_NOMEM ; 
line 85390: goto end_of_vacuum ; 
line 85391: } 
line 85392: rc = execSql ( db , "PRAGMA vacuum_db.synchronous=OFF" ) ; 
line 85393: if ( rc != SQLITE_OK ) { 
line 85394: goto end_of_vacuum ; 
line 85395: } 
line 85397: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 85398: sqlite3BtreeSetAutoVacuum ( pTemp , db -> nextAutovac >= 0 ? db -> nextAutovac : 
line 85399: sqlite3BtreeGetAutoVacuum ( pMain ) ) ; 
line 85400: # endif 
line 85403: rc = execSql ( db , "BEGIN EXCLUSIVE;" ) ; 
line 85404: if ( rc != SQLITE_OK ) goto end_of_vacuum ; 
line 85409: rc = execExecSql ( db , 
line 85410: "SELECT 'CREATE TABLE vacuum_db.' || substr(sql,14) " 
line 85411: "  FROM sqlite_master WHERE type='table' AND name!='sqlite_sequence'" 
line 85412: "   AND rootpage>0" 
line 85413: ) ; 
line 85414: if ( rc != SQLITE_OK ) goto end_of_vacuum ; 
line 85415: rc = execExecSql ( db , 
line 85416: "SELECT 'CREATE INDEX vacuum_db.' || substr(sql,14)" 
line 85417: "  FROM sqlite_master WHERE sql LIKE 'CREATE INDEX %' " ) ; 
line 85418: if ( rc != SQLITE_OK ) goto end_of_vacuum ; 
line 85419: rc = execExecSql ( db , 
line 85420: "SELECT 'CREATE UNIQUE INDEX vacuum_db.' || substr(sql,21) " 
line 85421: "  FROM sqlite_master WHERE sql LIKE 'CREATE UNIQUE INDEX %'" ) ; 
line 85422: if ( rc != SQLITE_OK ) goto end_of_vacuum ; 
line 85428: rc = execExecSql ( db , 
line 85429: "SELECT 'INSERT INTO vacuum_db.' || quote(name) " 
line 85430: "|| ' SELECT * FROM main.' || quote(name) || ';'" 
line 85431: "FROM main.sqlite_master " 
line 85432: "WHERE type = 'table' AND name!='sqlite_sequence' " 
line 85433: "  AND rootpage>0" 
line 85435: ) ; 
line 85436: if ( rc != SQLITE_OK ) goto end_of_vacuum ; 
line 85440: rc = execExecSql ( db , 
line 85441: "SELECT 'DELETE FROM vacuum_db.' || quote(name) || ';' " 
line 85442: "FROM vacuum_db.sqlite_master WHERE name='sqlite_sequence' " 
line 85443: ) ; 
line 85444: if ( rc != SQLITE_OK ) goto end_of_vacuum ; 
line 85445: rc = execExecSql ( db , 
line 85446: "SELECT 'INSERT INTO vacuum_db.' || quote(name) " 
line 85447: "|| ' SELECT * FROM main.' || quote(name) || ';' " 
line 85448: "FROM vacuum_db.sqlite_master WHERE name=='sqlite_sequence';" 
line 85449: ) ; 
line 85450: if ( rc != SQLITE_OK ) goto end_of_vacuum ; 
line 85458: rc = execSql ( db , 
line 85459: "INSERT INTO vacuum_db.sqlite_master " 
line 85460: "  SELECT type, name, tbl_name, rootpage, sql" 
line 85461: "    FROM main.sqlite_master" 
line 85462: "   WHERE type='view' OR type='trigger'" 
line 85463: "      OR (type='table' AND rootpage=0)" 
line 85464: ) ; 
line 85465: if ( rc ) goto end_of_vacuum ; 
line 85475: { 
line 85476: u32 meta ; 
line 85477: int i ; 
line 85485: static const unsigned char aCopy [ ] = { 
line 85486: BTREE_SCHEMA_VERSION , 1 , 
line 85487: BTREE_DEFAULT_CACHE_SIZE , 0 , 
line 85488: BTREE_TEXT_ENCODING , 0 , 
line 85489: BTREE_USER_VERSION , 0 , 
line 85490: } ; 
line 85492: assert ( 1 == sqlite3BtreeIsInTrans ( pTemp ) ) ; 
line 85493: assert ( 1 == sqlite3BtreeIsInTrans ( pMain ) ) ; 
line 85496: for ( i = 0 ; i < ArraySize ( aCopy ) ; i += 2 ) { 
line 85499: sqlite3BtreeGetMeta ( pMain , aCopy [ i ] , & meta ) ; 
line 85500: rc = sqlite3BtreeUpdateMeta ( pTemp , aCopy [ i ] , meta + aCopy [ i + 1 ] ) ; 
line 85501: if ( NEVER ( rc != SQLITE_OK ) ) goto end_of_vacuum ; 
line 85502: } 
line 85504: rc = sqlite3BtreeCopyFile ( pMain , pTemp ) ; 
line 85505: if ( rc != SQLITE_OK ) goto end_of_vacuum ; 
line 85506: rc = sqlite3BtreeCommit ( pTemp ) ; 
line 85507: if ( rc != SQLITE_OK ) goto end_of_vacuum ; 
line 85508: # ifndef SQLITE_OMIT_AUTOVACUUM 
line 85509: sqlite3BtreeSetAutoVacuum ( pMain , sqlite3BtreeGetAutoVacuum ( pTemp ) ) ; 
line 85510: # endif 
line 85511: } 
line 85513: assert ( rc == SQLITE_OK ) ; 
line 85514: rc = sqlite3BtreeSetPageSize ( pMain , sqlite3BtreeGetPageSize ( pTemp ) , nRes , 1 ) ; 
line 85516: end_of_vacuum : 
line 85518: db -> flags = saved_flags ; 
line 85519: db -> nChange = saved_nChange ; 
line 85520: db -> nTotalChange = saved_nTotalChange ; 
line 85521: db -> xTrace = saved_xTrace ; 
line 85530: db -> autoCommit = 1 ; 
line 85532: if ( pDb ) { 
line 85533: sqlite3BtreeClose ( pDb -> pBt ) ; 
line 85534: pDb -> pBt = 0 ; 
line 85535: pDb -> pSchema = 0 ; 
line 85536: } 
line 85538: sqlite3ResetInternalSchema ( db , 0 ) ; 
line 85540: return rc ; 
line 85541: } 
line 85542: # endif 
line 85559: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 85566: static int createModule ( 
line 85567: sqlite3 * db , 
line 85568: const char * zName , 
line 85569: const sqlite3_module * pModule , 
line 85570: void * pAux , 
line 85571: void ( * xDestroy ) ( void * ) 
line 85572: ) { 
line 85573: int rc , nName ; 
line 85574: Module * pMod ; 
line 85576: sqlite3_mutex_enter ( db -> mutex ) ; 
line 85577: nName = sqlite3Strlen30 ( zName ) ; 
line 85578: pMod = ( Module * ) sqlite3DbMallocRaw ( db , sizeof ( Module ) + nName + 1 ) ; 
line 85579: if ( pMod ) { 
line 85580: Module * pDel ; 
line 85581: char * zCopy = ( char * ) ( & pMod [ 1 ] ) ; 
line 85582: memcpy ( zCopy , zName , nName + 1 ) ; 
line 85583: pMod -> zName = zCopy ; 
line 85584: pMod -> pModule = pModule ; 
line 85585: pMod -> pAux = pAux ; 
line 85586: pMod -> xDestroy = xDestroy ; 
line 85587: pDel = ( Module * ) sqlite3HashInsert ( & db -> aModule , zCopy , nName , ( void * ) pMod ) ; 
line 85588: if ( pDel && pDel -> xDestroy ) { 
line 85589: pDel -> xDestroy ( pDel -> pAux ) ; 
line 85590: } 
line 85591: sqlite3DbFree ( db , pDel ) ; 
line 85592: if ( pDel == pMod ) { 
line 85593: db -> mallocFailed = 1 ; 
line 85594: } 
line 85595: sqlite3ResetInternalSchema ( db , 0 ) ; 
line 85596: } else if ( xDestroy ) { 
line 85597: xDestroy ( pAux ) ; 
line 85598: } 
line 85599: rc = sqlite3ApiExit ( db , SQLITE_OK ) ; 
line 85600: sqlite3_mutex_leave ( db -> mutex ) ; 
line 85601: return rc ; 
line 85602: } 
line 85608: SQLITE_API int sqlite3_create_module ( 
line 85609: sqlite3 * db , 
line 85610: const char * zName , 
line 85611: const sqlite3_module * pModule , 
line 85612: void * pAux 
line 85613: ) { 
line 85614: return createModule ( db , zName , pModule , pAux , 0 ) ; 
line 85615: } 
line 85620: SQLITE_API int sqlite3_create_module_v2 ( 
line 85621: sqlite3 * db , 
line 85622: const char * zName , 
line 85623: const sqlite3_module * pModule , 
line 85624: void * pAux , 
line 85625: void ( * xDestroy ) ( void * ) 
line 85626: ) { 
line 85627: return createModule ( db , zName , pModule , pAux , xDestroy ) ; 
line 85628: } 
line 85638: SQLITE_PRIVATE void sqlite3VtabLock ( VTable * pVTab ) { 
line 85639: pVTab -> nRef ++ ; 
line 85640: } 
line 85648: SQLITE_PRIVATE VTable * sqlite3GetVTable ( sqlite3 * db , Table * pTab ) { 
line 85649: VTable * pVtab ; 
line 85650: assert ( IsVirtual ( pTab ) ) ; 
line 85651: for ( pVtab = pTab -> pVTable ; pVtab && pVtab -> db != db ; pVtab = pVtab -> pNext ) ; 
line 85652: return pVtab ; 
line 85653: } 
line 85659: SQLITE_PRIVATE void sqlite3VtabUnlock ( VTable * pVTab ) { 
line 85660: sqlite3 * db = pVTab -> db ; 
line 85662: assert ( db ) ; 
line 85663: assert ( pVTab -> nRef > 0 ) ; 
line 85664: assert ( sqlite3SafetyCheckOk ( db ) ) ; 
line 85666: pVTab -> nRef -- ; 
line 85667: if ( pVTab -> nRef == 0 ) { 
line 85668: sqlite3_vtab * p = pVTab -> pVtab ; 
line 85669: if ( p ) { 
line 85670: # ifdef SQLITE_DEBUG 
line 85671: if ( pVTab -> db -> magic == SQLITE_MAGIC_BUSY ) { 
line 85672: ( void ) sqlite3SafetyOff ( db ) ; 
line 85673: p -> pModule -> xDisconnect ( p ) ; 
line 85674: ( void ) sqlite3SafetyOn ( db ) ; 
line 85675: } else 
line 85676: # endif 
line 85677: { 
line 85678: p -> pModule -> xDisconnect ( p ) ; 
line 85679: } 
line 85680: } 
line 85681: sqlite3DbFree ( db , pVTab ) ; 
line 85682: } 
line 85683: } 
line 85692: static VTable * vtabDisconnectAll ( sqlite3 * db , Table * p ) { 
line 85693: VTable * pRet = 0 ; 
line 85694: VTable * pVTable = p -> pVTable ; 
line 85695: p -> pVTable = 0 ; 
line 85702: assert ( db == 0 || 
line 85703: sqlite3BtreeHoldsMutex ( db -> aDb [ sqlite3SchemaToIndex ( db , p -> pSchema ) ] . pBt ) 
line 85704: ) ; 
line 85706: while ( pVTable ) { 
line 85707: sqlite3 * db2 = pVTable -> db ; 
line 85708: VTable * pNext = pVTable -> pNext ; 
line 85709: assert ( db2 ) ; 
line 85710: if ( db2 == db ) { 
line 85711: pRet = pVTable ; 
line 85712: p -> pVTable = pRet ; 
line 85713: pRet -> pNext = 0 ; 
line 85714: } else { 
line 85715: pVTable -> pNext = db2 -> pDisconnect ; 
line 85716: db2 -> pDisconnect = pVTable ; 
line 85717: } 
line 85718: pVTable = pNext ; 
line 85719: } 
line 85721: assert ( ! db || pRet ) ; 
line 85722: return pRet ; 
line 85723: } 
line 85746: SQLITE_PRIVATE void sqlite3VtabUnlockList ( sqlite3 * db ) { 
line 85747: VTable * p = db -> pDisconnect ; 
line 85748: db -> pDisconnect = 0 ; 
line 85750: assert ( sqlite3BtreeHoldsAllMutexes ( db ) ) ; 
line 85751: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 85753: if ( p ) { 
line 85754: sqlite3ExpirePreparedStatements ( db ) ; 
line 85755: do { 
line 85756: VTable * pNext = p -> pNext ; 
line 85757: sqlite3VtabUnlock ( p ) ; 
line 85758: p = pNext ; 
line 85759: } while ( p ) ; 
line 85760: } 
line 85761: } 
line 85777: SQLITE_PRIVATE void sqlite3VtabClear ( Table * p ) { 
line 85778: vtabDisconnectAll ( 0 , p ) ; 
line 85779: if ( p -> azModuleArg ) { 
line 85780: int i ; 
line 85781: for ( i = 0 ; i < p -> nModuleArg ; i ++ ) { 
line 85782: sqlite3DbFree ( p -> dbMem , p -> azModuleArg [ i ] ) ; 
line 85783: } 
line 85784: sqlite3DbFree ( p -> dbMem , p -> azModuleArg ) ; 
line 85785: } 
line 85786: } 
line 85794: static void addModuleArgument ( sqlite3 * db , Table * pTable , char * zArg ) { 
line 85795: int i = pTable -> nModuleArg ++ ; 
line 85796: int nBytes = sizeof ( char * ) * ( 1 + pTable -> nModuleArg ) ; 
line 85797: char * * azModuleArg ; 
line 85798: azModuleArg = sqlite3DbRealloc ( db , pTable -> azModuleArg , nBytes ) ; 
line 85799: if ( azModuleArg == 0 ) { 
line 85800: int j ; 
line 85801: for ( j = 0 ; j < i ; j ++ ) { 
line 85802: sqlite3DbFree ( db , pTable -> azModuleArg [ j ] ) ; 
line 85803: } 
line 85804: sqlite3DbFree ( db , zArg ) ; 
line 85805: sqlite3DbFree ( db , pTable -> azModuleArg ) ; 
line 85806: pTable -> nModuleArg = 0 ; 
line 85807: } else { 
line 85808: azModuleArg [ i ] = zArg ; 
line 85809: azModuleArg [ i + 1 ] = 0 ; 
line 85810: } 
line 85811: pTable -> azModuleArg = azModuleArg ; 
line 85812: } 
line 85819: SQLITE_PRIVATE void sqlite3VtabBeginParse ( 
line 85820: Parse * pParse , 
line 85821: Token * pName1 , 
line 85822: Token * pName2 , 
line 85823: Token * pModuleName 
line 85824: ) { 
line 85825: int iDb ; 
line 85826: Table * pTable ; 
line 85827: sqlite3 * db ; 
line 85829: sqlite3StartTable ( pParse , pName1 , pName2 , 0 , 0 , 1 , 0 ) ; 
line 85830: pTable = pParse -> pNewTable ; 
line 85831: if ( pTable == 0 ) return ; 
line 85832: assert ( 0 == pTable -> pIndex ) ; 
line 85834: db = pParse -> db ; 
line 85835: iDb = sqlite3SchemaToIndex ( db , pTable -> pSchema ) ; 
line 85836: assert ( iDb >= 0 ) ; 
line 85838: pTable -> tabFlags |= TF_Virtual ; 
line 85839: pTable -> nModuleArg = 0 ; 
line 85840: addModuleArgument ( db , pTable , sqlite3NameFromToken ( db , pModuleName ) ) ; 
line 85841: addModuleArgument ( db , pTable , sqlite3DbStrDup ( db , db -> aDb [ iDb ] . zName ) ) ; 
line 85842: addModuleArgument ( db , pTable , sqlite3DbStrDup ( db , pTable -> zName ) ) ; 
line 85843: pParse -> sNameToken . n = ( int ) ( & pModuleName -> z [ pModuleName -> n ] - pName1 -> z ) ; 
line 85845: # ifndef SQLITE_OMIT_AUTHORIZATION 
line 85851: if ( pTable -> azModuleArg ) { 
line 85852: sqlite3AuthCheck ( pParse , SQLITE_CREATE_VTABLE , pTable -> zName , 
line 85853: pTable -> azModuleArg [ 0 ] , pParse -> db -> aDb [ iDb ] . zName ) ; 
line 85854: } 
line 85855: # endif 
line 85856: } 
line 85863: static void addArgumentToVtab ( Parse * pParse ) { 
line 85864: if ( pParse -> sArg . z && ALWAYS ( pParse -> pNewTable ) ) { 
line 85865: const char * z = ( const char * ) pParse -> sArg . z ; 
line 85866: int n = pParse -> sArg . n ; 
line 85867: sqlite3 * db = pParse -> db ; 
line 85868: addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ; 
line 85869: } 
line 85870: } 
line 85876: SQLITE_PRIVATE void sqlite3VtabFinishParse ( Parse * pParse , Token * pEnd ) { 
line 85877: Table * pTab = pParse -> pNewTable ; 
line 85878: sqlite3 * db = pParse -> db ; 
line 85880: if ( pTab == 0 ) return ; 
line 85881: addArgumentToVtab ( pParse ) ; 
line 85882: pParse -> sArg . z = 0 ; 
line 85883: if ( pTab -> nModuleArg < 1 ) return ; 
line 85891: if ( ! db -> init . busy ) { 
line 85892: char * zStmt ; 
line 85893: char * zWhere ; 
line 85894: int iDb ; 
line 85895: Vdbe * v ; 
line 85898: if ( pEnd ) { 
line 85899: pParse -> sNameToken . n = ( int ) ( pEnd -> z - pParse -> sNameToken . z ) + pEnd -> n ; 
line 85900: } 
line 85901: zStmt = sqlite3MPrintf ( db , "CREATE VIRTUAL TABLE %T" , & pParse -> sNameToken ) ; 
line 85911: iDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; 
line 85912: sqlite3NestedParse ( pParse , 
line 85913: "UPDATE %Q.%s " 
line 85914: "SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q " 
line 85915: "WHERE rowid=#%d" , 
line 85916: db -> aDb [ iDb ] . zName , SCHEMA_TABLE ( iDb ) , 
line 85917: pTab -> zName , 
line 85918: pTab -> zName , 
line 85919: zStmt , 
line 85920: pParse -> regRowid 
line 85921: ) ; 
line 85922: sqlite3DbFree ( db , zStmt ) ; 
line 85923: v = sqlite3GetVdbe ( pParse ) ; 
line 85924: sqlite3ChangeCookie ( pParse , iDb ) ; 
line 85926: sqlite3VdbeAddOp2 ( v , OP_Expire , 0 , 0 ) ; 
line 85927: zWhere = sqlite3MPrintf ( db , "name='%q'" , pTab -> zName ) ; 
line 85928: sqlite3VdbeAddOp4 ( v , OP_ParseSchema , iDb , 1 , 0 , zWhere , P4_DYNAMIC ) ; 
line 85929: sqlite3VdbeAddOp4 ( v , OP_VCreate , iDb , 0 , 0 , 
line 85930: pTab -> zName , sqlite3Strlen30 ( pTab -> zName ) + 1 ) ; 
line 85931: } 
line 85938: else { 
line 85939: Table * pOld ; 
line 85940: Schema * pSchema = pTab -> pSchema ; 
line 85941: const char * zName = pTab -> zName ; 
line 85942: int nName = sqlite3Strlen30 ( zName ) ; 
line 85943: pOld = sqlite3HashInsert ( & pSchema -> tblHash , zName , nName , pTab ) ; 
line 85944: if ( pOld ) { 
line 85945: db -> mallocFailed = 1 ; 
line 85946: assert ( pTab == pOld ) ; 
line 85947: return ; 
line 85948: } 
line 85949: pSchema -> db = pParse -> db ; 
line 85950: pParse -> pNewTable = 0 ; 
line 85951: } 
line 85952: } 
line 85958: SQLITE_PRIVATE void sqlite3VtabArgInit ( Parse * pParse ) { 
line 85959: addArgumentToVtab ( pParse ) ; 
line 85960: pParse -> sArg . z = 0 ; 
line 85961: pParse -> sArg . n = 0 ; 
line 85962: } 
line 85968: SQLITE_PRIVATE void sqlite3VtabArgExtend ( Parse * pParse , Token * p ) { 
line 85969: Token * pArg = & pParse -> sArg ; 
line 85970: if ( pArg -> z == 0 ) { 
line 85971: pArg -> z = p -> z ; 
line 85972: pArg -> n = p -> n ; 
line 85973: } else { 
line 85974: assert ( pArg -> z < p -> z ) ; 
line 85975: pArg -> n = ( int ) ( & p -> z [ p -> n ] - pArg -> z ) ; 
line 85976: } 
line 85977: } 
line 85984: static int vtabCallConstructor ( 
line 85985: sqlite3 * db , 
line 85986: Table * pTab , 
line 85987: Module * pMod , 
line 85988: int ( * xConstruct ) ( sqlite3 * , void * , int , const char * const * , sqlite3_vtab * * , char * * ) , 
line 85989: char * * pzErr 
line 85990: ) { 
line 85991: VTable * pVTable ; 
line 85992: int rc ; 
line 85993: const char * const * azArg = ( const char * const * ) pTab -> azModuleArg ; 
line 85994: int nArg = pTab -> nModuleArg ; 
line 85995: char * zErr = 0 ; 
line 85996: char * zModuleName = sqlite3MPrintf ( db , "%s" , pTab -> zName ) ; 
line 85998: if ( ! zModuleName ) { 
line 85999: return SQLITE_NOMEM ; 
line 86000: } 
line 86002: pVTable = sqlite3DbMallocZero ( db , sizeof ( VTable ) ) ; 
line 86003: if ( ! pVTable ) { 
line 86004: sqlite3DbFree ( db , zModuleName ) ; 
line 86005: return SQLITE_NOMEM ; 
line 86006: } 
line 86007: pVTable -> db = db ; 
line 86008: pVTable -> pMod = pMod ; 
line 86010: assert ( ! db -> pVTab ) ; 
line 86011: assert ( xConstruct ) ; 
line 86012: db -> pVTab = pTab ; 
line 86015: ( void ) sqlite3SafetyOff ( db ) ; 
line 86016: rc = xConstruct ( db , pMod -> pAux , nArg , azArg , & pVTable -> pVtab , & zErr ) ; 
line 86017: ( void ) sqlite3SafetyOn ( db ) ; 
line 86018: if ( rc == SQLITE_NOMEM ) db -> mallocFailed = 1 ; 
line 86020: if ( SQLITE_OK != rc ) { 
line 86021: if ( zErr == 0 ) { 
line 86022: * pzErr = sqlite3MPrintf ( db , "vtable constructor failed: %s" , zModuleName ) ; 
line 86023: } else { 
line 86024: * pzErr = sqlite3MPrintf ( db , "%s" , zErr ) ; 
line 86025: sqlite3DbFree ( db , zErr ) ; 
line 86026: } 
line 86027: sqlite3DbFree ( db , pVTable ) ; 
line 86028: } else if ( ALWAYS ( pVTable -> pVtab ) ) { 
line 86031: pVTable -> pVtab -> pModule = pMod -> pModule ; 
line 86032: pVTable -> nRef = 1 ; 
line 86033: if ( db -> pVTab ) { 
line 86034: const char * zFormat = "vtable constructor did not declare schema: %s" ; 
line 86035: * pzErr = sqlite3MPrintf ( db , zFormat , pTab -> zName ) ; 
line 86036: sqlite3VtabUnlock ( pVTable ) ; 
line 86037: rc = SQLITE_ERROR ; 
line 86038: } else { 
line 86039: int iCol ; 
line 86045: pVTable -> pNext = pTab -> pVTable ; 
line 86046: pTab -> pVTable = pVTable ; 
line 86048: for ( iCol = 0 ; iCol < pTab -> nCol ; iCol ++ ) { 
line 86049: char * zType = pTab -> aCol [ iCol ] . zType ; 
line 86050: int nType ; 
line 86051: int i = 0 ; 
line 86052: if ( ! zType ) continue ; 
line 86053: nType = sqlite3Strlen30 ( zType ) ; 
line 86054: if ( sqlite3StrNICmp ( "hidden" , zType , 6 ) || ( zType [ 6 ] && zType [ 6 ] != ' ' ) ) { 
line 86055: for ( i = 0 ; i < nType ; i ++ ) { 
line 86056: if ( ( 0 == sqlite3StrNICmp ( " hidden" , & zType [ i ] , 7 ) ) 
line 86057: && ( zType [ i + 7 ] == '\0' || zType [ i + 7 ] == ' ' ) 
line 86058: ) { 
line 86059: i ++ ; 
line 86060: break ; 
line 86061: } 
line 86062: } 
line 86063: } 
line 86064: if ( i < nType ) { 
line 86065: int j ; 
line 86066: int nDel = 6 + ( zType [ i + 6 ] ? 1 : 0 ) ; 
line 86067: for ( j = i ; ( j + nDel ) <= nType ; j ++ ) { 
line 86068: zType [ j ] = zType [ j + nDel ] ; 
line 86069: } 
line 86070: if ( zType [ i ] == '\0' && i > 0 ) { 
line 86071: assert ( zType [ i - 1 ] == ' ' ) ; 
line 86072: zType [ i - 1 ] = '\0' ; 
line 86073: } 
line 86074: pTab -> aCol [ iCol ] . isHidden = 1 ; 
line 86075: } 
line 86076: } 
line 86077: } 
line 86078: } 
line 86080: sqlite3DbFree ( db , zModuleName ) ; 
line 86081: db -> pVTab = 0 ; 
line 86082: return rc ; 
line 86083: } 
line 86092: SQLITE_PRIVATE int sqlite3VtabCallConnect ( Parse * pParse , Table * pTab ) { 
line 86093: sqlite3 * db = pParse -> db ; 
line 86094: const char * zMod ; 
line 86095: Module * pMod ; 
line 86096: int rc ; 
line 86098: assert ( pTab ) ; 
line 86099: if ( ( pTab -> tabFlags & TF_Virtual ) == 0 || sqlite3GetVTable ( db , pTab ) ) { 
line 86100: return SQLITE_OK ; 
line 86101: } 
line 86104: zMod = pTab -> azModuleArg [ 0 ] ; 
line 86105: pMod = ( Module * ) sqlite3HashFind ( & db -> aModule , zMod , sqlite3Strlen30 ( zMod ) ) ; 
line 86107: if ( ! pMod ) { 
line 86108: const char * zModule = pTab -> azModuleArg [ 0 ] ; 
line 86109: sqlite3ErrorMsg ( pParse , "no such module: %s" , zModule ) ; 
line 86110: rc = SQLITE_ERROR ; 
line 86111: } else { 
line 86112: char * zErr = 0 ; 
line 86113: rc = vtabCallConstructor ( db , pTab , pMod , pMod -> pModule -> xConnect , & zErr ) ; 
line 86114: if ( rc != SQLITE_OK ) { 
line 86115: sqlite3ErrorMsg ( pParse , "%s" , zErr ) ; 
line 86116: } 
line 86117: sqlite3DbFree ( db , zErr ) ; 
line 86118: } 
line 86120: return rc ; 
line 86121: } 
line 86126: static int addToVTrans ( sqlite3 * db , VTable * pVTab ) { 
line 86127: const int ARRAY_INCR = 5 ; 
line 86130: if ( ( db -> nVTrans % ARRAY_INCR ) == 0 ) { 
line 86131: VTable * * aVTrans ; 
line 86132: int nBytes = sizeof ( sqlite3_vtab * ) * ( db -> nVTrans + ARRAY_INCR ) ; 
line 86133: aVTrans = sqlite3DbRealloc ( db , ( void * ) db -> aVTrans , nBytes ) ; 
line 86134: if ( ! aVTrans ) { 
line 86135: return SQLITE_NOMEM ; 
line 86136: } 
line 86137: memset ( & aVTrans [ db -> nVTrans ] , 0 , sizeof ( sqlite3_vtab * ) * ARRAY_INCR ) ; 
line 86138: db -> aVTrans = aVTrans ; 
line 86139: } 
line 86142: db -> aVTrans [ db -> nVTrans ++ ] = pVTab ; 
line 86143: sqlite3VtabLock ( pVTab ) ; 
line 86144: return SQLITE_OK ; 
line 86145: } 
line 86155: SQLITE_PRIVATE int sqlite3VtabCallCreate ( sqlite3 * db , int iDb , const char * zTab , char * * pzErr ) { 
line 86156: int rc = SQLITE_OK ; 
line 86157: Table * pTab ; 
line 86158: Module * pMod ; 
line 86159: const char * zMod ; 
line 86161: pTab = sqlite3FindTable ( db , zTab , db -> aDb [ iDb ] . zName ) ; 
line 86162: assert ( pTab && ( pTab -> tabFlags & TF_Virtual ) != 0 && ! pTab -> pVTable ) ; 
line 86165: zMod = pTab -> azModuleArg [ 0 ] ; 
line 86166: pMod = ( Module * ) sqlite3HashFind ( & db -> aModule , zMod , sqlite3Strlen30 ( zMod ) ) ; 
line 86172: if ( ! pMod ) { 
line 86173: * pzErr = sqlite3MPrintf ( db , "no such module: %s" , zMod ) ; 
line 86174: rc = SQLITE_ERROR ; 
line 86175: } else { 
line 86176: rc = vtabCallConstructor ( db , pTab , pMod , pMod -> pModule -> xCreate , pzErr ) ; 
line 86177: } 
line 86181: if ( rc == SQLITE_OK && ALWAYS ( sqlite3GetVTable ( db , pTab ) ) ) { 
line 86182: rc = addToVTrans ( db , sqlite3GetVTable ( db , pTab ) ) ; 
line 86183: } 
line 86185: return rc ; 
line 86186: } 
line 86193: SQLITE_API int sqlite3_declare_vtab ( sqlite3 * db , const char * zCreateTable ) { 
line 86194: Parse * pParse ; 
line 86196: int rc = SQLITE_OK ; 
line 86197: Table * pTab ; 
line 86198: char * zErr = 0 ; 
line 86200: sqlite3_mutex_enter ( db -> mutex ) ; 
line 86201: pTab = db -> pVTab ; 
line 86202: if ( ! pTab ) { 
line 86203: sqlite3Error ( db , SQLITE_MISUSE , 0 ) ; 
line 86204: sqlite3_mutex_leave ( db -> mutex ) ; 
line 86205: return SQLITE_MISUSE ; 
line 86206: } 
line 86207: assert ( ( pTab -> tabFlags & TF_Virtual ) != 0 ) ; 
line 86209: pParse = sqlite3StackAllocZero ( db , sizeof ( * pParse ) ) ; 
line 86210: if ( pParse == 0 ) { 
line 86211: rc = SQLITE_NOMEM ; 
line 86212: } else { 
line 86213: pParse -> declareVtab = 1 ; 
line 86214: pParse -> db = db ; 
line 86216: if ( SQLITE_OK == sqlite3RunParser ( pParse , zCreateTable , & zErr ) 
line 86217: && pParse -> pNewTable 
line 86218: && ! db -> mallocFailed 
line 86219: && ! pParse -> pNewTable -> pSelect 
line 86220: && ( pParse -> pNewTable -> tabFlags & TF_Virtual ) == 0 
line 86221: ) { 
line 86222: if ( ! pTab -> aCol ) { 
line 86223: pTab -> aCol = pParse -> pNewTable -> aCol ; 
line 86224: pTab -> nCol = pParse -> pNewTable -> nCol ; 
line 86225: pParse -> pNewTable -> nCol = 0 ; 
line 86226: pParse -> pNewTable -> aCol = 0 ; 
line 86227: } 
line 86228: db -> pVTab = 0 ; 
line 86229: } else { 
line 86230: sqlite3Error ( db , SQLITE_ERROR , zErr ) ; 
line 86231: sqlite3DbFree ( db , zErr ) ; 
line 86232: rc = SQLITE_ERROR ; 
line 86233: } 
line 86234: pParse -> declareVtab = 0 ; 
line 86236: if ( pParse -> pVdbe ) { 
line 86237: sqlite3VdbeFinalize ( pParse -> pVdbe ) ; 
line 86238: } 
line 86239: sqlite3DeleteTable ( pParse -> pNewTable ) ; 
line 86240: sqlite3StackFree ( db , pParse ) ; 
line 86241: } 
line 86243: assert ( ( rc & 0xff ) == rc ) ; 
line 86244: rc = sqlite3ApiExit ( db , rc ) ; 
line 86245: sqlite3_mutex_leave ( db -> mutex ) ; 
line 86246: return rc ; 
line 86247: } 
line 86256: SQLITE_PRIVATE int sqlite3VtabCallDestroy ( sqlite3 * db , int iDb , const char * zTab ) { 
line 86257: int rc = SQLITE_OK ; 
line 86258: Table * pTab ; 
line 86260: pTab = sqlite3FindTable ( db , zTab , db -> aDb [ iDb ] . zName ) ; 
line 86261: if ( ALWAYS ( pTab != 0 && pTab -> pVTable != 0 ) ) { 
line 86262: VTable * p = vtabDisconnectAll ( db , pTab ) ; 
line 86264: rc = sqlite3SafetyOff ( db ) ; 
line 86265: assert ( rc == SQLITE_OK ) ; 
line 86266: rc = p -> pMod -> pModule -> xDestroy ( p -> pVtab ) ; 
line 86267: ( void ) sqlite3SafetyOn ( db ) ; 
line 86270: if ( rc == SQLITE_OK ) { 
line 86271: assert ( pTab -> pVTable == p && p -> pNext == 0 ) ; 
line 86272: p -> pVtab = 0 ; 
line 86273: pTab -> pVTable = 0 ; 
line 86274: sqlite3VtabUnlock ( p ) ; 
line 86275: } 
line 86276: } 
line 86278: return rc ; 
line 86279: } 
line 86289: static void callFinaliser ( sqlite3 * db , int offset ) { 
line 86290: int i ; 
line 86291: if ( db -> aVTrans ) { 
line 86292: for ( i = 0 ; i < db -> nVTrans ; i ++ ) { 
line 86293: VTable * pVTab = db -> aVTrans [ i ] ; 
line 86294: sqlite3_vtab * p = pVTab -> pVtab ; 
line 86295: if ( p ) { 
line 86296: int ( * x ) ( sqlite3_vtab * ) ; 
line 86297: x = * ( int ( * * ) ( sqlite3_vtab * ) ) ( ( char * ) p -> pModule + offset ) ; 
line 86298: if ( x ) x ( p ) ; 
line 86299: } 
line 86300: sqlite3VtabUnlock ( pVTab ) ; 
line 86301: } 
line 86302: sqlite3DbFree ( db , db -> aVTrans ) ; 
line 86303: db -> nVTrans = 0 ; 
line 86304: db -> aVTrans = 0 ; 
line 86305: } 
line 86306: } 
line 86316: SQLITE_PRIVATE int sqlite3VtabSync ( sqlite3 * db , char * * pzErrmsg ) { 
line 86317: int i ; 
line 86318: int rc = SQLITE_OK ; 
line 86319: int rcsafety ; 
line 86320: VTable * * aVTrans = db -> aVTrans ; 
line 86322: rc = sqlite3SafetyOff ( db ) ; 
line 86323: db -> aVTrans = 0 ; 
line 86324: for ( i = 0 ; rc == SQLITE_OK && i < db -> nVTrans ; i ++ ) { 
line 86325: int ( * x ) ( sqlite3_vtab * ) ; 
line 86326: sqlite3_vtab * pVtab = aVTrans [ i ] -> pVtab ; 
line 86327: if ( pVtab && ( x = pVtab -> pModule -> xSync ) != 0 ) { 
line 86328: rc = x ( pVtab ) ; 
line 86329: sqlite3DbFree ( db , * pzErrmsg ) ; 
line 86330: * pzErrmsg = pVtab -> zErrMsg ; 
line 86331: pVtab -> zErrMsg = 0 ; 
line 86332: } 
line 86333: } 
line 86334: db -> aVTrans = aVTrans ; 
line 86335: rcsafety = sqlite3SafetyOn ( db ) ; 
line 86337: if ( rc == SQLITE_OK ) { 
line 86338: rc = rcsafety ; 
line 86339: } 
line 86340: return rc ; 
line 86341: } 
line 86347: SQLITE_PRIVATE int sqlite3VtabRollback ( sqlite3 * db ) { 
line 86348: callFinaliser ( db , offsetof ( sqlite3_module , xRollback ) ) ; 
line 86349: return SQLITE_OK ; 
line 86350: } 
line 86356: SQLITE_PRIVATE int sqlite3VtabCommit ( sqlite3 * db ) { 
line 86357: callFinaliser ( db , offsetof ( sqlite3_module , xCommit ) ) ; 
line 86358: return SQLITE_OK ; 
line 86359: } 
line 86369: SQLITE_PRIVATE int sqlite3VtabBegin ( sqlite3 * db , VTable * pVTab ) { 
line 86370: int rc = SQLITE_OK ; 
line 86371: const sqlite3_module * pModule ; 
line 86378: if ( sqlite3VtabInSync ( db ) ) { 
line 86379: return SQLITE_LOCKED ; 
line 86380: } 
line 86381: if ( ! pVTab ) { 
line 86382: return SQLITE_OK ; 
line 86383: } 
line 86384: pModule = pVTab -> pVtab -> pModule ; 
line 86386: if ( pModule -> xBegin ) { 
line 86387: int i ; 
line 86391: for ( i = 0 ; i < db -> nVTrans ; i ++ ) { 
line 86392: if ( db -> aVTrans [ i ] == pVTab ) { 
line 86393: return SQLITE_OK ; 
line 86394: } 
line 86395: } 
line 86398: rc = pModule -> xBegin ( pVTab -> pVtab ) ; 
line 86399: if ( rc == SQLITE_OK ) { 
line 86400: rc = addToVTrans ( db , pVTab ) ; 
line 86401: } 
line 86402: } 
line 86403: return rc ; 
line 86404: } 
line 86419: SQLITE_PRIVATE FuncDef * sqlite3VtabOverloadFunction ( 
line 86420: sqlite3 * db , 
line 86421: FuncDef * pDef , 
line 86422: int nArg , 
line 86423: Expr * pExpr 
line 86424: ) { 
line 86425: Table * pTab ; 
line 86426: sqlite3_vtab * pVtab ; 
line 86427: sqlite3_module * pMod ; 
line 86428: void ( * xFunc ) ( sqlite3_context * , int , sqlite3_value * * ) = 0 ; 
line 86429: void * pArg = 0 ; 
line 86430: FuncDef * pNew ; 
line 86431: int rc = 0 ; 
line 86432: char * zLowerName ; 
line 86433: unsigned char * z ; 
line 86437: if ( NEVER ( pExpr == 0 ) ) return pDef ; 
line 86438: if ( pExpr -> op != TK_COLUMN ) return pDef ; 
line 86439: pTab = pExpr -> pTab ; 
line 86440: if ( NEVER ( pTab == 0 ) ) return pDef ; 
line 86441: if ( ( pTab -> tabFlags & TF_Virtual ) == 0 ) return pDef ; 
line 86442: pVtab = sqlite3GetVTable ( db , pTab ) -> pVtab ; 
line 86443: assert ( pVtab != 0 ) ; 
line 86444: assert ( pVtab -> pModule != 0 ) ; 
line 86445: pMod = ( sqlite3_module * ) pVtab -> pModule ; 
line 86446: if ( pMod -> xFindFunction == 0 ) return pDef ; 
line 86451: zLowerName = sqlite3DbStrDup ( db , pDef -> zName ) ; 
line 86452: if ( zLowerName ) { 
line 86453: for ( z = ( unsigned char * ) zLowerName ; * z ; z ++ ) { 
line 86454: * z = sqlite3UpperToLower [ * z ] ; 
line 86455: } 
line 86456: rc = pMod -> xFindFunction ( pVtab , nArg , zLowerName , & xFunc , & pArg ) ; 
line 86457: sqlite3DbFree ( db , zLowerName ) ; 
line 86458: } 
line 86459: if ( rc == 0 ) { 
line 86460: return pDef ; 
line 86461: } 
line 86465: pNew = sqlite3DbMallocZero ( db , sizeof ( * pNew ) 
line 86466: + sqlite3Strlen30 ( pDef -> zName ) + 1 ) ; 
line 86467: if ( pNew == 0 ) { 
line 86468: return pDef ; 
line 86469: } 
line 86470: * pNew = * pDef ; 
line 86471: pNew -> zName = ( char * ) & pNew [ 1 ] ; 
line 86472: memcpy ( pNew -> zName , pDef -> zName , sqlite3Strlen30 ( pDef -> zName ) + 1 ) ; 
line 86473: pNew -> xFunc = xFunc ; 
line 86474: pNew -> pUserData = pArg ; 
line 86475: pNew -> flags |= SQLITE_FUNC_EPHEM ; 
line 86476: return pNew ; 
line 86477: } 
line 86485: SQLITE_PRIVATE void sqlite3VtabMakeWritable ( Parse * pParse , Table * pTab ) { 
line 86486: Parse * pToplevel = sqlite3ParseToplevel ( pParse ) ; 
line 86487: int i , n ; 
line 86488: Table * * apVtabLock ; 
line 86490: assert ( IsVirtual ( pTab ) ) ; 
line 86491: for ( i = 0 ; i < pToplevel -> nVtabLock ; i ++ ) { 
line 86492: if ( pTab == pToplevel -> apVtabLock [ i ] ) return ; 
line 86493: } 
line 86494: n = ( pToplevel -> nVtabLock + 1 ) * sizeof ( pToplevel -> apVtabLock [ 0 ] ) ; 
line 86495: apVtabLock = sqlite3_realloc ( pToplevel -> apVtabLock , n ) ; 
line 86496: if ( apVtabLock ) { 
line 86497: pToplevel -> apVtabLock = apVtabLock ; 
line 86498: pToplevel -> apVtabLock [ pToplevel -> nVtabLock ++ ] = pTab ; 
line 86499: } else { 
line 86500: pToplevel -> db -> mallocFailed = 1 ; 
line 86501: } 
line 86502: } 
line 86504: # endif 
line 86530: # if defined ( SQLITE_TEST ) || defined ( SQLITE_DEBUG ) 
line 86531: SQLITE_PRIVATE int sqlite3WhereTrace = 0 ; 
line 86532: # endif 
line 86533: # if defined ( SQLITE_TEST ) && defined ( SQLITE_DEBUG ) 
line 86534: # define WHERETRACE ( X ) if ( sqlite3WhereTrace ) sqlite3DebugPrintf X 
line 86535: # else 
line 86536: # define WHERETRACE ( X ) 
line 86537: # endif 
line 86541: typedef struct WhereClause WhereClause ; 
line 86542: typedef struct WhereMaskSet WhereMaskSet ; 
line 86543: typedef struct WhereOrInfo WhereOrInfo ; 
line 86544: typedef struct WhereAndInfo WhereAndInfo ; 
line 86545: typedef struct WhereCost WhereCost ; 
line 86598: typedef struct WhereTerm WhereTerm ; 
line 86599: struct WhereTerm { 
line 86600: Expr * pExpr ; 
line 86601: int iParent ; 
line 86602: int leftCursor ; 
line 86603: union { 
line 86604: int leftColumn ; 
line 86605: WhereOrInfo * pOrInfo ; 
line 86606: WhereAndInfo * pAndInfo ; 
line 86607: } u ; 
line 86608: u16 eOperator ; 
line 86609: u8 wtFlags ; 
line 86610: u8 nChild ; 
line 86611: WhereClause * pWC ; 
line 86612: Bitmask prereqRight ; 
line 86613: Bitmask prereqAll ; 
line 86614: } ; 
line 86619: # define TERM_DYNAMIC 0x01 
line 86620: # define TERM_VIRTUAL 0x02 
line 86621: # define TERM_CODED 0x04 
line 86622: # define TERM_COPIED 0x08 
line 86623: # define TERM_ORINFO 0x10 
line 86624: # define TERM_ANDINFO 0x20 
line 86625: # define TERM_OR_OK 0x40 
line 86631: struct WhereClause { 
line 86632: Parse * pParse ; 
line 86633: WhereMaskSet * pMaskSet ; 
line 86634: Bitmask vmask ; 
line 86635: u8 op ; 
line 86636: int nTerm ; 
line 86637: int nSlot ; 
line 86638: WhereTerm * a ; 
line 86639: # if defined ( SQLITE_SMALL_STACK ) 
line 86640: WhereTerm aStatic [ 1 ] ; 
line 86641: # else 
line 86642: WhereTerm aStatic [ 8 ] ; 
line 86643: # endif 
line 86644: } ; 
line 86650: struct WhereOrInfo { 
line 86651: WhereClause wc ; 
line 86652: Bitmask indexable ; 
line 86653: } ; 
line 86659: struct WhereAndInfo { 
line 86660: WhereClause wc ; 
line 86661: } ; 
line 86689: struct WhereMaskSet { 
line 86690: int n ; 
line 86691: int ix [ BMS ] ; 
line 86692: } ; 
line 86698: struct WhereCost { 
line 86699: WherePlan plan ; 
line 86700: double rCost ; 
line 86701: double nRow ; 
line 86702: Bitmask used ; 
line 86703: } ; 
line 86710: # define WO_IN 0x001 
line 86711: # define WO_EQ 0x002 
line 86712: # define WO_LT ( WO_EQ << ( TK_LT - TK_EQ ) ) 
line 86713: # define WO_LE ( WO_EQ << ( TK_LE - TK_EQ ) ) 
line 86714: # define WO_GT ( WO_EQ << ( TK_GT - TK_EQ ) ) 
line 86715: # define WO_GE ( WO_EQ << ( TK_GE - TK_EQ ) ) 
line 86716: # define WO_MATCH 0x040 
line 86717: # define WO_ISNULL 0x080 
line 86718: # define WO_OR 0x100 
line 86719: # define WO_AND 0x200 
line 86721: # define WO_ALL 0xfff 
line 86722: # define WO_SINGLE 0x0ff 
line 86737: # define WHERE_ROWID_EQ 0x00001000 
line 86738: # define WHERE_ROWID_RANGE 0x00002000 
line 86739: # define WHERE_COLUMN_EQ 0x00010000 
line 86740: # define WHERE_COLUMN_RANGE 0x00020000 
line 86741: # define WHERE_COLUMN_IN 0x00040000 
line 86742: # define WHERE_COLUMN_NULL 0x00080000 
line 86743: # define WHERE_INDEXED 0x000f0000 
line 86744: # define WHERE_IN_ABLE 0x000f1000 
line 86745: # define WHERE_TOP_LIMIT 0x00100000 
line 86746: # define WHERE_BTM_LIMIT 0x00200000 
line 86747: # define WHERE_IDX_ONLY 0x00800000 
line 86748: # define WHERE_ORDERBY 0x01000000 
line 86749: # define WHERE_REVERSE 0x02000000 
line 86750: # define WHERE_UNIQUE 0x04000000 
line 86751: # define WHERE_VIRTUALTABLE 0x08000000 
line 86752: # define WHERE_MULTI_OR 0x10000000 
line 86757: static void whereClauseInit ( 
line 86758: WhereClause * pWC , 
line 86759: Parse * pParse , 
line 86760: WhereMaskSet * pMaskSet 
line 86761: ) { 
line 86762: pWC -> pParse = pParse ; 
line 86763: pWC -> pMaskSet = pMaskSet ; 
line 86764: pWC -> nTerm = 0 ; 
line 86765: pWC -> nSlot = ArraySize ( pWC -> aStatic ) ; 
line 86766: pWC -> a = pWC -> aStatic ; 
line 86767: pWC -> vmask = 0 ; 
line 86768: } 
line 86771: static void whereClauseClear ( WhereClause * ) ; 
line 86776: static void whereOrInfoDelete ( sqlite3 * db , WhereOrInfo * p ) { 
line 86777: whereClauseClear ( & p -> wc ) ; 
line 86778: sqlite3DbFree ( db , p ) ; 
line 86779: } 
line 86784: static void whereAndInfoDelete ( sqlite3 * db , WhereAndInfo * p ) { 
line 86785: whereClauseClear ( & p -> wc ) ; 
line 86786: sqlite3DbFree ( db , p ) ; 
line 86787: } 
line 86793: static void whereClauseClear ( WhereClause * pWC ) { 
line 86794: int i ; 
line 86795: WhereTerm * a ; 
line 86796: sqlite3 * db = pWC -> pParse -> db ; 
line 86797: for ( i = pWC -> nTerm - 1 , a = pWC -> a ; i >= 0 ; i -- , a ++ ) { 
line 86798: if ( a -> wtFlags & TERM_DYNAMIC ) { 
line 86799: sqlite3ExprDelete ( db , a -> pExpr ) ; 
line 86800: } 
line 86801: if ( a -> wtFlags & TERM_ORINFO ) { 
line 86802: whereOrInfoDelete ( db , a -> u . pOrInfo ) ; 
line 86803: } else if ( a -> wtFlags & TERM_ANDINFO ) { 
line 86804: whereAndInfoDelete ( db , a -> u . pAndInfo ) ; 
line 86805: } 
line 86806: } 
line 86807: if ( pWC -> a != pWC -> aStatic ) { 
line 86808: sqlite3DbFree ( db , pWC -> a ) ; 
line 86809: } 
line 86810: } 
line 86831: static int whereClauseInsert ( WhereClause * pWC , Expr * p , u8 wtFlags ) { 
line 86832: WhereTerm * pTerm ; 
line 86833: int idx ; 
line 86834: if ( pWC -> nTerm >= pWC -> nSlot ) { 
line 86835: WhereTerm * pOld = pWC -> a ; 
line 86836: sqlite3 * db = pWC -> pParse -> db ; 
line 86837: pWC -> a = sqlite3DbMallocRaw ( db , sizeof ( pWC -> a [ 0 ] ) * pWC -> nSlot * 2 ) ; 
line 86838: if ( pWC -> a == 0 ) { 
line 86839: if ( wtFlags & TERM_DYNAMIC ) { 
line 86840: sqlite3ExprDelete ( db , p ) ; 
line 86841: } 
line 86842: pWC -> a = pOld ; 
line 86843: return 0 ; 
line 86844: } 
line 86845: memcpy ( pWC -> a , pOld , sizeof ( pWC -> a [ 0 ] ) * pWC -> nTerm ) ; 
line 86846: if ( pOld != pWC -> aStatic ) { 
line 86847: sqlite3DbFree ( db , pOld ) ; 
line 86848: } 
line 86849: pWC -> nSlot = sqlite3DbMallocSize ( db , pWC -> a ) / sizeof ( pWC -> a [ 0 ] ) ; 
line 86850: } 
line 86851: pTerm = & pWC -> a [ idx = pWC -> nTerm ++ ] ; 
line 86852: pTerm -> pExpr = p ; 
line 86853: pTerm -> wtFlags = wtFlags ; 
line 86854: pTerm -> pWC = pWC ; 
line 86855: pTerm -> iParent = - 1 ; 
line 86856: return idx ; 
line 86857: } 
line 86876: static void whereSplit ( WhereClause * pWC , Expr * pExpr , int op ) { 
line 86877: pWC -> op = ( u8 ) op ; 
line 86878: if ( pExpr == 0 ) return ; 
line 86879: if ( pExpr -> op != op ) { 
line 86880: whereClauseInsert ( pWC , pExpr , 0 ) ; 
line 86881: } else { 
line 86882: whereSplit ( pWC , pExpr -> pLeft , op ) ; 
line 86883: whereSplit ( pWC , pExpr -> pRight , op ) ; 
line 86884: } 
line 86885: } 
line 86890: # define initMaskSet ( P ) memset ( P , 0 , sizeof ( * P ) ) 
line 86896: static Bitmask getMask ( WhereMaskSet * pMaskSet , int iCursor ) { 
line 86897: int i ; 
line 86898: assert ( pMaskSet -> n <= sizeof ( Bitmask ) * 8 ) ; 
line 86899: for ( i = 0 ; i < pMaskSet -> n ; i ++ ) { 
line 86900: if ( pMaskSet -> ix [ i ] == iCursor ) { 
line 86901: return ( ( Bitmask ) 1 ) << i ; 
line 86902: } 
line 86903: } 
line 86904: return 0 ; 
line 86905: } 
line 86915: static void createMask ( WhereMaskSet * pMaskSet , int iCursor ) { 
line 86916: assert ( pMaskSet -> n < ArraySize ( pMaskSet -> ix ) ) ; 
line 86917: pMaskSet -> ix [ pMaskSet -> n ++ ] = iCursor ; 
line 86918: } 
line 86934: static Bitmask exprListTableUsage ( WhereMaskSet * , ExprList * ) ; 
line 86935: static Bitmask exprSelectTableUsage ( WhereMaskSet * , Select * ) ; 
line 86936: static Bitmask exprTableUsage ( WhereMaskSet * pMaskSet , Expr * p ) { 
line 86937: Bitmask mask = 0 ; 
line 86938: if ( p == 0 ) return 0 ; 
line 86939: if ( p -> op == TK_COLUMN ) { 
line 86940: mask = getMask ( pMaskSet , p -> iTable ) ; 
line 86941: return mask ; 
line 86942: } 
line 86943: mask = exprTableUsage ( pMaskSet , p -> pRight ) ; 
line 86944: mask |= exprTableUsage ( pMaskSet , p -> pLeft ) ; 
line 86945: if ( ExprHasProperty ( p , EP_xIsSelect ) ) { 
line 86946: mask |= exprSelectTableUsage ( pMaskSet , p -> x . pSelect ) ; 
line 86947: } else { 
line 86948: mask |= exprListTableUsage ( pMaskSet , p -> x . pList ) ; 
line 86949: } 
line 86950: return mask ; 
line 86951: } 
line 86952: static Bitmask exprListTableUsage ( WhereMaskSet * pMaskSet , ExprList * pList ) { 
line 86953: int i ; 
line 86954: Bitmask mask = 0 ; 
line 86955: if ( pList ) { 
line 86956: for ( i = 0 ; i < pList -> nExpr ; i ++ ) { 
line 86957: mask |= exprTableUsage ( pMaskSet , pList -> a [ i ] . pExpr ) ; 
line 86958: } 
line 86959: } 
line 86960: return mask ; 
line 86961: } 
line 86962: static Bitmask exprSelectTableUsage ( WhereMaskSet * pMaskSet , Select * pS ) { 
line 86963: Bitmask mask = 0 ; 
line 86964: while ( pS ) { 
line 86965: mask |= exprListTableUsage ( pMaskSet , pS -> pEList ) ; 
line 86966: mask |= exprListTableUsage ( pMaskSet , pS -> pGroupBy ) ; 
line 86967: mask |= exprListTableUsage ( pMaskSet , pS -> pOrderBy ) ; 
line 86968: mask |= exprTableUsage ( pMaskSet , pS -> pWhere ) ; 
line 86969: mask |= exprTableUsage ( pMaskSet , pS -> pHaving ) ; 
line 86970: pS = pS -> pPrior ; 
line 86971: } 
line 86972: return mask ; 
line 86973: } 
line 86980: static int allowedOp ( int op ) { 
line 86981: assert ( TK_GT > TK_EQ && TK_GT < TK_GE ) ; 
line 86982: assert ( TK_LT > TK_EQ && TK_LT < TK_GE ) ; 
line 86983: assert ( TK_LE > TK_EQ && TK_LE < TK_GE ) ; 
line 86984: assert ( TK_GE == TK_EQ + 4 ) ; 
line 86985: return op == TK_IN || ( op >= TK_EQ && op <= TK_GE ) || op == TK_ISNULL ; 
line 86986: } 
line 86991: # define SWAP ( TYPE , A , B ) { TYPE t = A ; A = B ; B = t ; } 
line 87005: static void exprCommute ( Parse * pParse , Expr * pExpr ) { 
line 87006: u16 expRight = ( pExpr -> pRight -> flags & EP_ExpCollate ) ; 
line 87007: u16 expLeft = ( pExpr -> pLeft -> flags & EP_ExpCollate ) ; 
line 87008: assert ( allowedOp ( pExpr -> op ) && pExpr -> op != TK_IN ) ; 
line 87009: pExpr -> pRight -> pColl = sqlite3ExprCollSeq ( pParse , pExpr -> pRight ) ; 
line 87010: pExpr -> pLeft -> pColl = sqlite3ExprCollSeq ( pParse , pExpr -> pLeft ) ; 
line 87011: SWAP ( CollSeq * , pExpr -> pRight -> pColl , pExpr -> pLeft -> pColl ) ; 
line 87012: pExpr -> pRight -> flags = ( pExpr -> pRight -> flags & ~ EP_ExpCollate ) | expLeft ; 
line 87013: pExpr -> pLeft -> flags = ( pExpr -> pLeft -> flags & ~ EP_ExpCollate ) | expRight ; 
line 87014: SWAP ( Expr * , pExpr -> pRight , pExpr -> pLeft ) ; 
line 87015: if ( pExpr -> op >= TK_GT ) { 
line 87016: assert ( TK_LT == TK_GT + 2 ) ; 
line 87017: assert ( TK_GE == TK_LE + 2 ) ; 
line 87018: assert ( TK_GT > TK_EQ ) ; 
line 87019: assert ( TK_GT < TK_LE ) ; 
line 87020: assert ( pExpr -> op >= TK_GT && pExpr -> op <= TK_GE ) ; 
line 87021: pExpr -> op = ( ( pExpr -> op - TK_GT ) ^ 2 ) + TK_GT ; 
line 87022: } 
line 87023: } 
line 87028: static u16 operatorMask ( int op ) { 
line 87029: u16 c ; 
line 87030: assert ( allowedOp ( op ) ) ; 
line 87031: if ( op == TK_IN ) { 
line 87032: c = WO_IN ; 
line 87033: } else if ( op == TK_ISNULL ) { 
line 87034: c = WO_ISNULL ; 
line 87035: } else { 
line 87036: assert ( ( WO_EQ << ( op - TK_EQ ) ) < 0x7fff ) ; 
line 87037: c = ( u16 ) ( WO_EQ << ( op - TK_EQ ) ) ; 
line 87038: } 
line 87039: assert ( op != TK_ISNULL || c == WO_ISNULL ) ; 
line 87040: assert ( op != TK_IN || c == WO_IN ) ; 
line 87041: assert ( op != TK_EQ || c == WO_EQ ) ; 
line 87042: assert ( op != TK_LT || c == WO_LT ) ; 
line 87043: assert ( op != TK_LE || c == WO_LE ) ; 
line 87044: assert ( op != TK_GT || c == WO_GT ) ; 
line 87045: assert ( op != TK_GE || c == WO_GE ) ; 
line 87046: return c ; 
line 87047: } 
line 87055: static WhereTerm * findTerm ( 
line 87056: WhereClause * pWC , 
line 87057: int iCur , 
line 87058: int iColumn , 
line 87059: Bitmask notReady , 
line 87060: u32 op , 
line 87061: Index * pIdx 
line 87062: ) { 
line 87063: WhereTerm * pTerm ; 
line 87064: int k ; 
line 87065: assert ( iCur >= 0 ) ; 
line 87066: op &= WO_ALL ; 
line 87067: for ( pTerm = pWC -> a , k = pWC -> nTerm ; k ; k -- , pTerm ++ ) { 
line 87068: if ( pTerm -> leftCursor == iCur 
line 87069: && ( pTerm -> prereqRight & notReady ) == 0 
line 87070: && pTerm -> u . leftColumn == iColumn 
line 87071: && ( pTerm -> eOperator & op ) != 0 
line 87072: ) { 
line 87073: if ( pIdx && pTerm -> eOperator != WO_ISNULL ) { 
line 87074: Expr * pX = pTerm -> pExpr ; 
line 87075: CollSeq * pColl ; 
line 87076: char idxaff ; 
line 87077: int j ; 
line 87078: Parse * pParse = pWC -> pParse ; 
line 87080: idxaff = pIdx -> pTable -> aCol [ iColumn ] . affinity ; 
line 87081: if ( ! sqlite3IndexAffinityOk ( pX , idxaff ) ) continue ; 
line 87087: assert ( pX -> pLeft ) ; 
line 87088: pColl = sqlite3BinaryCompareCollSeq ( pParse , pX -> pLeft , pX -> pRight ) ; 
line 87089: assert ( pColl || pParse -> nErr ) ; 
line 87091: for ( j = 0 ; pIdx -> aiColumn [ j ] != iColumn ; j ++ ) { 
line 87092: if ( NEVER ( j >= pIdx -> nColumn ) ) return 0 ; 
line 87093: } 
line 87094: if ( pColl && sqlite3StrICmp ( pColl -> zName , pIdx -> azColl [ j ] ) ) continue ; 
line 87095: } 
line 87096: return pTerm ; 
line 87097: } 
line 87098: } 
line 87099: return 0 ; 
line 87100: } 
line 87103: static void exprAnalyze ( SrcList * , WhereClause * , int ) ; 
line 87110: static void exprAnalyzeAll ( 
line 87111: SrcList * pTabList , 
line 87112: WhereClause * pWC 
line 87113: ) { 
line 87114: int i ; 
line 87115: for ( i = pWC -> nTerm - 1 ; i >= 0 ; i -- ) { 
line 87116: exprAnalyze ( pTabList , pWC , i ) ; 
line 87117: } 
line 87118: } 
line 87120: # ifndef SQLITE_OMIT_LIKE_OPTIMIZATION 
line 87129: static int isLikeOrGlob ( 
line 87130: Parse * pParse , 
line 87131: Expr * pExpr , 
line 87132: Expr * * ppPrefix , 
line 87133: int * pisComplete , 
line 87134: int * pnoCase 
line 87135: ) { 
line 87136: const char * z = 0 ; 
line 87137: Expr * pRight , * pLeft ; 
line 87138: ExprList * pList ; 
line 87139: int c ; 
line 87140: int cnt ; 
line 87141: char wc [ 3 ] ; 
line 87142: CollSeq * pColl ; 
line 87143: sqlite3 * db = pParse -> db ; 
line 87144: sqlite3_value * pVal = 0 ; 
line 87145: int op ; 
line 87147: if ( ! sqlite3IsLikeFunction ( db , pExpr , pnoCase , wc ) ) { 
line 87148: return 0 ; 
line 87149: } 
line 87150: # ifdef SQLITE_EBCDIC 
line 87151: if ( * pnoCase ) return 0 ; 
line 87152: # endif 
line 87153: pList = pExpr -> x . pList ; 
line 87154: pLeft = pList -> a [ 1 ] . pExpr ; 
line 87155: if ( pLeft -> op != TK_COLUMN || sqlite3ExprAffinity ( pLeft ) != SQLITE_AFF_TEXT ) { 
line 87158: return 0 ; 
line 87159: } 
line 87160: assert ( pLeft -> iColumn != ( - 1 ) ) ; 
line 87161: pColl = sqlite3ExprCollSeq ( pParse , pLeft ) ; 
line 87162: assert ( pColl != 0 ) ; 
line 87163: if ( ( pColl -> type != SQLITE_COLL_BINARY || * pnoCase ) && 
line 87164: ( pColl -> type != SQLITE_COLL_NOCASE || ! * pnoCase ) ) { 
line 87172: return 0 ; 
line 87173: } 
line 87175: pRight = pList -> a [ 0 ] . pExpr ; 
line 87176: op = pRight -> op ; 
line 87177: if ( op == TK_REGISTER ) { 
line 87178: op = pRight -> op2 ; 
line 87179: } 
line 87180: if ( op == TK_VARIABLE ) { 
line 87181: Vdbe * pReprepare = pParse -> pReprepare ; 
line 87182: pVal = sqlite3VdbeGetValue ( pReprepare , pRight -> iColumn , SQLITE_AFF_NONE ) ; 
line 87183: if ( pVal && sqlite3_value_type ( pVal ) == SQLITE_TEXT ) { 
line 87184: z = ( char * ) sqlite3_value_text ( pVal ) ; 
line 87185: } 
line 87186: sqlite3VdbeSetVarmask ( pParse -> pVdbe , pRight -> iColumn ) ; 
line 87187: assert ( pRight -> op == TK_VARIABLE || pRight -> op == TK_REGISTER ) ; 
line 87188: } else if ( op == TK_STRING ) { 
line 87189: z = pRight -> u . zToken ; 
line 87190: } 
line 87191: if ( z ) { 
line 87192: cnt = 0 ; 
line 87193: while ( ( c = z [ cnt ] ) != 0 && c != wc [ 0 ] && c != wc [ 1 ] && c != wc [ 2 ] ) { 
line 87194: cnt ++ ; 
line 87195: } 
line 87196: if ( cnt != 0 && c != 0 && 255 != ( u8 ) z [ cnt - 1 ] ) { 
line 87197: Expr * pPrefix ; 
line 87198: * pisComplete = z [ cnt ] == wc [ 0 ] && z [ cnt + 1 ] == 0 ; 
line 87199: pPrefix = sqlite3Expr ( db , TK_STRING , z ) ; 
line 87200: if ( pPrefix ) pPrefix -> u . zToken [ cnt ] = 0 ; 
line 87201: * ppPrefix = pPrefix ; 
line 87202: if ( op == TK_VARIABLE ) { 
line 87203: Vdbe * v = pParse -> pVdbe ; 
line 87204: sqlite3VdbeSetVarmask ( v , pRight -> iColumn ) ; 
line 87205: if ( * pisComplete && pRight -> u . zToken [ 1 ] ) { 
line 87212: int r1 = sqlite3GetTempReg ( pParse ) ; 
line 87213: sqlite3ExprCodeTarget ( pParse , pRight , r1 ) ; 
line 87214: sqlite3VdbeChangeP3 ( v , sqlite3VdbeCurrentAddr ( v ) - 1 , 0 ) ; 
line 87215: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 87216: } 
line 87217: } 
line 87218: } else { 
line 87219: z = 0 ; 
line 87220: } 
line 87221: } 
line 87223: sqlite3ValueFree ( pVal ) ; 
line 87224: return ( z != 0 ) ; 
line 87225: } 
line 87226: # endif 
line 87229: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 87237: static int isMatchOfColumn ( 
line 87238: Expr * pExpr 
line 87239: ) { 
line 87240: ExprList * pList ; 
line 87242: if ( pExpr -> op != TK_FUNCTION ) { 
line 87243: return 0 ; 
line 87244: } 
line 87245: if ( sqlite3StrICmp ( pExpr -> u . zToken , "match" ) != 0 ) { 
line 87246: return 0 ; 
line 87247: } 
line 87248: pList = pExpr -> x . pList ; 
line 87249: if ( pList -> nExpr != 2 ) { 
line 87250: return 0 ; 
line 87251: } 
line 87252: if ( pList -> a [ 1 ] . pExpr -> op != TK_COLUMN ) { 
line 87253: return 0 ; 
line 87254: } 
line 87255: return 1 ; 
line 87256: } 
line 87257: # endif 
line 87263: static void transferJoinMarkings ( Expr * pDerived , Expr * pBase ) { 
line 87264: pDerived -> flags |= pBase -> flags & EP_FromJoin ; 
line 87265: pDerived -> iRightJoinTable = pBase -> iRightJoinTable ; 
line 87266: } 
line 87268: # if ! defined ( SQLITE_OMIT_OR_OPTIMIZATION ) && ! defined ( SQLITE_OMIT_SUBQUERY ) 
line 87345: static void exprAnalyzeOrTerm ( 
line 87346: SrcList * pSrc , 
line 87347: WhereClause * pWC , 
line 87348: int idxTerm 
line 87349: ) { 
line 87350: Parse * pParse = pWC -> pParse ; 
line 87351: sqlite3 * db = pParse -> db ; 
line 87352: WhereTerm * pTerm = & pWC -> a [ idxTerm ] ; 
line 87353: Expr * pExpr = pTerm -> pExpr ; 
line 87354: WhereMaskSet * pMaskSet = pWC -> pMaskSet ; 
line 87355: int i ; 
line 87356: WhereClause * pOrWc ; 
line 87357: WhereTerm * pOrTerm ; 
line 87358: WhereOrInfo * pOrInfo ; 
line 87359: Bitmask chngToIN ; 
line 87360: Bitmask indexable ; 
line 87367: assert ( ( pTerm -> wtFlags & ( TERM_DYNAMIC | TERM_ORINFO | TERM_ANDINFO ) ) == 0 ) ; 
line 87368: assert ( pExpr -> op == TK_OR ) ; 
line 87369: pTerm -> u . pOrInfo = pOrInfo = sqlite3DbMallocZero ( db , sizeof ( * pOrInfo ) ) ; 
line 87370: if ( pOrInfo == 0 ) return ; 
line 87371: pTerm -> wtFlags |= TERM_ORINFO ; 
line 87372: pOrWc = & pOrInfo -> wc ; 
line 87373: whereClauseInit ( pOrWc , pWC -> pParse , pMaskSet ) ; 
line 87374: whereSplit ( pOrWc , pExpr , TK_OR ) ; 
line 87375: exprAnalyzeAll ( pSrc , pOrWc ) ; 
line 87376: if ( db -> mallocFailed ) return ; 
line 87377: assert ( pOrWc -> nTerm >= 2 ) ; 
line 87382: indexable = ~ ( Bitmask ) 0 ; 
line 87383: chngToIN = ~ ( pWC -> vmask ) ; 
line 87384: for ( i = pOrWc -> nTerm - 1 , pOrTerm = pOrWc -> a ; i >= 0 && indexable ; i -- , pOrTerm ++ ) { 
line 87385: if ( ( pOrTerm -> eOperator & WO_SINGLE ) == 0 ) { 
line 87386: WhereAndInfo * pAndInfo ; 
line 87387: assert ( pOrTerm -> eOperator == 0 ) ; 
line 87388: assert ( ( pOrTerm -> wtFlags & ( TERM_ANDINFO | TERM_ORINFO ) ) == 0 ) ; 
line 87389: chngToIN = 0 ; 
line 87390: pAndInfo = sqlite3DbMallocRaw ( db , sizeof ( * pAndInfo ) ) ; 
line 87391: if ( pAndInfo ) { 
line 87392: WhereClause * pAndWC ; 
line 87393: WhereTerm * pAndTerm ; 
line 87394: int j ; 
line 87395: Bitmask b = 0 ; 
line 87396: pOrTerm -> u . pAndInfo = pAndInfo ; 
line 87397: pOrTerm -> wtFlags |= TERM_ANDINFO ; 
line 87398: pOrTerm -> eOperator = WO_AND ; 
line 87399: pAndWC = & pAndInfo -> wc ; 
line 87400: whereClauseInit ( pAndWC , pWC -> pParse , pMaskSet ) ; 
line 87401: whereSplit ( pAndWC , pOrTerm -> pExpr , TK_AND ) ; 
line 87402: exprAnalyzeAll ( pSrc , pAndWC ) ; 
line 87403: testcase ( db -> mallocFailed ) ; 
line 87404: if ( ! db -> mallocFailed ) { 
line 87405: for ( j = 0 , pAndTerm = pAndWC -> a ; j < pAndWC -> nTerm ; j ++ , pAndTerm ++ ) { 
line 87406: assert ( pAndTerm -> pExpr ) ; 
line 87407: if ( allowedOp ( pAndTerm -> pExpr -> op ) ) { 
line 87408: b |= getMask ( pMaskSet , pAndTerm -> leftCursor ) ; 
line 87409: } 
line 87410: } 
line 87411: } 
line 87412: indexable &= b ; 
line 87413: } 
line 87414: } else if ( pOrTerm -> wtFlags & TERM_COPIED ) { 
line 87417: } else { 
line 87418: Bitmask b ; 
line 87419: b = getMask ( pMaskSet , pOrTerm -> leftCursor ) ; 
line 87420: if ( pOrTerm -> wtFlags & TERM_VIRTUAL ) { 
line 87421: WhereTerm * pOther = & pOrWc -> a [ pOrTerm -> iParent ] ; 
line 87422: b |= getMask ( pMaskSet , pOther -> leftCursor ) ; 
line 87423: } 
line 87424: indexable &= b ; 
line 87425: if ( pOrTerm -> eOperator != WO_EQ ) { 
line 87426: chngToIN = 0 ; 
line 87427: } else { 
line 87428: chngToIN &= b ; 
line 87429: } 
line 87430: } 
line 87431: } 
line 87437: pOrInfo -> indexable = indexable ; 
line 87438: pTerm -> eOperator = indexable == 0 ? 0 : WO_OR ; 
line 87461: if ( chngToIN ) { 
line 87462: int okToChngToIN = 0 ; 
line 87463: int iColumn = - 1 ; 
line 87464: int iCursor = - 1 ; 
line 87465: int j = 0 ; 
line 87473: for ( j = 0 ; j < 2 && ! okToChngToIN ; j ++ ) { 
line 87474: pOrTerm = pOrWc -> a ; 
line 87475: for ( i = pOrWc -> nTerm - 1 ; i >= 0 ; i -- , pOrTerm ++ ) { 
line 87476: assert ( pOrTerm -> eOperator == WO_EQ ) ; 
line 87477: pOrTerm -> wtFlags &= ~ TERM_OR_OK ; 
line 87478: if ( pOrTerm -> leftCursor == iCursor ) { 
line 87481: assert ( j == 1 ) ; 
line 87482: continue ; 
line 87483: } 
line 87484: if ( ( chngToIN & getMask ( pMaskSet , pOrTerm -> leftCursor ) ) == 0 ) { 
line 87489: testcase ( pOrTerm -> wtFlags & TERM_COPIED ) ; 
line 87490: testcase ( pOrTerm -> wtFlags & TERM_VIRTUAL ) ; 
line 87491: assert ( pOrTerm -> wtFlags & ( TERM_COPIED | TERM_VIRTUAL ) ) ; 
line 87492: continue ; 
line 87493: } 
line 87494: iColumn = pOrTerm -> u . leftColumn ; 
line 87495: iCursor = pOrTerm -> leftCursor ; 
line 87496: break ; 
line 87497: } 
line 87498: if ( i < 0 ) { 
line 87501: assert ( j == 1 ) ; 
line 87502: assert ( ( chngToIN & ( chngToIN - 1 ) ) == 0 ) ; 
line 87503: assert ( chngToIN == getMask ( pMaskSet , iCursor ) ) ; 
line 87504: break ; 
line 87505: } 
line 87506: testcase ( j == 1 ) ; 
line 87510: okToChngToIN = 1 ; 
line 87511: for ( ; i >= 0 && okToChngToIN ; i -- , pOrTerm ++ ) { 
line 87512: assert ( pOrTerm -> eOperator == WO_EQ ) ; 
line 87513: if ( pOrTerm -> leftCursor != iCursor ) { 
line 87514: pOrTerm -> wtFlags &= ~ TERM_OR_OK ; 
line 87515: } else if ( pOrTerm -> u . leftColumn != iColumn ) { 
line 87516: okToChngToIN = 0 ; 
line 87517: } else { 
line 87518: int affLeft , affRight ; 
line 87523: affRight = sqlite3ExprAffinity ( pOrTerm -> pExpr -> pRight ) ; 
line 87524: affLeft = sqlite3ExprAffinity ( pOrTerm -> pExpr -> pLeft ) ; 
line 87525: if ( affRight != 0 && affRight != affLeft ) { 
line 87526: okToChngToIN = 0 ; 
line 87527: } else { 
line 87528: pOrTerm -> wtFlags |= TERM_OR_OK ; 
line 87529: } 
line 87530: } 
line 87531: } 
line 87532: } 
line 87538: if ( okToChngToIN ) { 
line 87539: Expr * pDup ; 
line 87540: ExprList * pList = 0 ; 
line 87541: Expr * pLeft = 0 ; 
line 87542: Expr * pNew ; 
line 87544: for ( i = pOrWc -> nTerm - 1 , pOrTerm = pOrWc -> a ; i >= 0 ; i -- , pOrTerm ++ ) { 
line 87545: if ( ( pOrTerm -> wtFlags & TERM_OR_OK ) == 0 ) continue ; 
line 87546: assert ( pOrTerm -> eOperator == WO_EQ ) ; 
line 87547: assert ( pOrTerm -> leftCursor == iCursor ) ; 
line 87548: assert ( pOrTerm -> u . leftColumn == iColumn ) ; 
line 87549: pDup = sqlite3ExprDup ( db , pOrTerm -> pExpr -> pRight , 0 ) ; 
line 87550: pList = sqlite3ExprListAppend ( pWC -> pParse , pList , pDup ) ; 
line 87551: pLeft = pOrTerm -> pExpr -> pLeft ; 
line 87552: } 
line 87553: assert ( pLeft != 0 ) ; 
line 87554: pDup = sqlite3ExprDup ( db , pLeft , 0 ) ; 
line 87555: pNew = sqlite3PExpr ( pParse , TK_IN , pDup , 0 , 0 ) ; 
line 87556: if ( pNew ) { 
line 87557: int idxNew ; 
line 87558: transferJoinMarkings ( pNew , pExpr ) ; 
line 87559: assert ( ! ExprHasProperty ( pNew , EP_xIsSelect ) ) ; 
line 87560: pNew -> x . pList = pList ; 
line 87561: idxNew = whereClauseInsert ( pWC , pNew , TERM_VIRTUAL | TERM_DYNAMIC ) ; 
line 87562: testcase ( idxNew == 0 ) ; 
line 87563: exprAnalyze ( pSrc , pWC , idxNew ) ; 
line 87564: pTerm = & pWC -> a [ idxTerm ] ; 
line 87565: pWC -> a [ idxNew ] . iParent = idxTerm ; 
line 87566: pTerm -> nChild = 1 ; 
line 87567: } else { 
line 87568: sqlite3ExprListDelete ( db , pList ) ; 
line 87569: } 
line 87570: pTerm -> eOperator = 0 ; 
line 87571: } 
line 87572: } 
line 87573: } 
line 87574: # endif 
line 87595: static void exprAnalyze ( 
line 87596: SrcList * pSrc , 
line 87597: WhereClause * pWC , 
line 87598: int idxTerm 
line 87599: ) { 
line 87600: WhereTerm * pTerm ; 
line 87601: WhereMaskSet * pMaskSet ; 
line 87602: Expr * pExpr ; 
line 87603: Bitmask prereqLeft ; 
line 87604: Bitmask prereqAll ; 
line 87605: Bitmask extraRight = 0 ; 
line 87606: Expr * pStr1 = 0 ; 
line 87607: int isComplete = 0 ; 
line 87608: int noCase = 0 ; 
line 87609: int op ; 
line 87610: Parse * pParse = pWC -> pParse ; 
line 87611: sqlite3 * db = pParse -> db ; 
line 87613: if ( db -> mallocFailed ) { 
line 87614: return ; 
line 87615: } 
line 87616: pTerm = & pWC -> a [ idxTerm ] ; 
line 87617: pMaskSet = pWC -> pMaskSet ; 
line 87618: pExpr = pTerm -> pExpr ; 
line 87619: prereqLeft = exprTableUsage ( pMaskSet , pExpr -> pLeft ) ; 
line 87620: op = pExpr -> op ; 
line 87621: if ( op == TK_IN ) { 
line 87622: assert ( pExpr -> pRight == 0 ) ; 
line 87623: if ( ExprHasProperty ( pExpr , EP_xIsSelect ) ) { 
line 87624: pTerm -> prereqRight = exprSelectTableUsage ( pMaskSet , pExpr -> x . pSelect ) ; 
line 87625: } else { 
line 87626: pTerm -> prereqRight = exprListTableUsage ( pMaskSet , pExpr -> x . pList ) ; 
line 87627: } 
line 87628: } else if ( op == TK_ISNULL ) { 
line 87629: pTerm -> prereqRight = 0 ; 
line 87630: } else { 
line 87631: pTerm -> prereqRight = exprTableUsage ( pMaskSet , pExpr -> pRight ) ; 
line 87632: } 
line 87633: prereqAll = exprTableUsage ( pMaskSet , pExpr ) ; 
line 87634: if ( ExprHasProperty ( pExpr , EP_FromJoin ) ) { 
line 87635: Bitmask x = getMask ( pMaskSet , pExpr -> iRightJoinTable ) ; 
line 87636: prereqAll |= x ; 
line 87637: extraRight = x - 1 ; 
line 87639: } 
line 87640: pTerm -> prereqAll = prereqAll ; 
line 87641: pTerm -> leftCursor = - 1 ; 
line 87642: pTerm -> iParent = - 1 ; 
line 87643: pTerm -> eOperator = 0 ; 
line 87644: if ( allowedOp ( op ) && ( pTerm -> prereqRight & prereqLeft ) == 0 ) { 
line 87645: Expr * pLeft = pExpr -> pLeft ; 
line 87646: Expr * pRight = pExpr -> pRight ; 
line 87647: if ( pLeft -> op == TK_COLUMN ) { 
line 87648: pTerm -> leftCursor = pLeft -> iTable ; 
line 87649: pTerm -> u . leftColumn = pLeft -> iColumn ; 
line 87650: pTerm -> eOperator = operatorMask ( op ) ; 
line 87651: } 
line 87652: if ( pRight && pRight -> op == TK_COLUMN ) { 
line 87653: WhereTerm * pNew ; 
line 87654: Expr * pDup ; 
line 87655: if ( pTerm -> leftCursor >= 0 ) { 
line 87656: int idxNew ; 
line 87657: pDup = sqlite3ExprDup ( db , pExpr , 0 ) ; 
line 87658: if ( db -> mallocFailed ) { 
line 87659: sqlite3ExprDelete ( db , pDup ) ; 
line 87660: return ; 
line 87661: } 
line 87662: idxNew = whereClauseInsert ( pWC , pDup , TERM_VIRTUAL | TERM_DYNAMIC ) ; 
line 87663: if ( idxNew == 0 ) return ; 
line 87664: pNew = & pWC -> a [ idxNew ] ; 
line 87665: pNew -> iParent = idxTerm ; 
line 87666: pTerm = & pWC -> a [ idxTerm ] ; 
line 87667: pTerm -> nChild = 1 ; 
line 87668: pTerm -> wtFlags |= TERM_COPIED ; 
line 87669: } else { 
line 87670: pDup = pExpr ; 
line 87671: pNew = pTerm ; 
line 87672: } 
line 87673: exprCommute ( pParse , pDup ) ; 
line 87674: pLeft = pDup -> pLeft ; 
line 87675: pNew -> leftCursor = pLeft -> iTable ; 
line 87676: pNew -> u . leftColumn = pLeft -> iColumn ; 
line 87677: pNew -> prereqRight = prereqLeft ; 
line 87678: pNew -> prereqAll = prereqAll ; 
line 87679: pNew -> eOperator = operatorMask ( pDup -> op ) ; 
line 87680: } 
line 87681: } 
line 87683: # ifndef SQLITE_OMIT_BETWEEN_OPTIMIZATION 
line 87699: else if ( pExpr -> op == TK_BETWEEN && pWC -> op == TK_AND ) { 
line 87700: ExprList * pList = pExpr -> x . pList ; 
line 87701: int i ; 
line 87702: static const u8 ops [ ] = { TK_GE , TK_LE } ; 
line 87703: assert ( pList != 0 ) ; 
line 87704: assert ( pList -> nExpr == 2 ) ; 
line 87705: for ( i = 0 ; i < 2 ; i ++ ) { 
line 87706: Expr * pNewExpr ; 
line 87707: int idxNew ; 
line 87708: pNewExpr = sqlite3PExpr ( pParse , ops [ i ] , 
line 87709: sqlite3ExprDup ( db , pExpr -> pLeft , 0 ) , 
line 87710: sqlite3ExprDup ( db , pList -> a [ i ] . pExpr , 0 ) , 0 ) ; 
line 87711: idxNew = whereClauseInsert ( pWC , pNewExpr , TERM_VIRTUAL | TERM_DYNAMIC ) ; 
line 87712: testcase ( idxNew == 0 ) ; 
line 87713: exprAnalyze ( pSrc , pWC , idxNew ) ; 
line 87714: pTerm = & pWC -> a [ idxTerm ] ; 
line 87715: pWC -> a [ idxNew ] . iParent = idxTerm ; 
line 87716: } 
line 87717: pTerm -> nChild = 2 ; 
line 87718: } 
line 87719: # endif 
line 87721: # if ! defined ( SQLITE_OMIT_OR_OPTIMIZATION ) && ! defined ( SQLITE_OMIT_SUBQUERY ) 
line 87725: else if ( pExpr -> op == TK_OR ) { 
line 87726: assert ( pWC -> op == TK_AND ) ; 
line 87727: exprAnalyzeOrTerm ( pSrc , pWC , idxTerm ) ; 
line 87728: pTerm = & pWC -> a [ idxTerm ] ; 
line 87729: } 
line 87730: # endif 
line 87732: # ifndef SQLITE_OMIT_LIKE_OPTIMIZATION 
line 87743: if ( pWC -> op == TK_AND 
line 87744: && isLikeOrGlob ( pParse , pExpr , & pStr1 , & isComplete , & noCase ) 
line 87745: ) { 
line 87746: Expr * pLeft ; 
line 87747: Expr * pStr2 ; 
line 87748: Expr * pNewExpr1 ; 
line 87749: Expr * pNewExpr2 ; 
line 87750: int idxNew1 ; 
line 87751: int idxNew2 ; 
line 87753: pLeft = pExpr -> x . pList -> a [ 1 ] . pExpr ; 
line 87754: pStr2 = sqlite3ExprDup ( db , pStr1 , 0 ) ; 
line 87755: if ( ! db -> mallocFailed ) { 
line 87756: u8 c , * pC ; 
line 87757: pC = ( u8 * ) & pStr2 -> u . zToken [ sqlite3Strlen30 ( pStr2 -> u . zToken ) - 1 ] ; 
line 87758: c = * pC ; 
line 87759: if ( noCase ) { 
line 87766: if ( c == 'A' - 1 ) isComplete = 0 ; 
line 87768: c = sqlite3UpperToLower [ c ] ; 
line 87769: } 
line 87770: * pC = c + 1 ; 
line 87771: } 
line 87772: pNewExpr1 = sqlite3PExpr ( pParse , TK_GE , sqlite3ExprDup ( db , pLeft , 0 ) , pStr1 , 0 ) ; 
line 87773: idxNew1 = whereClauseInsert ( pWC , pNewExpr1 , TERM_VIRTUAL | TERM_DYNAMIC ) ; 
line 87774: testcase ( idxNew1 == 0 ) ; 
line 87775: exprAnalyze ( pSrc , pWC , idxNew1 ) ; 
line 87776: pNewExpr2 = sqlite3PExpr ( pParse , TK_LT , sqlite3ExprDup ( db , pLeft , 0 ) , pStr2 , 0 ) ; 
line 87777: idxNew2 = whereClauseInsert ( pWC , pNewExpr2 , TERM_VIRTUAL | TERM_DYNAMIC ) ; 
line 87778: testcase ( idxNew2 == 0 ) ; 
line 87779: exprAnalyze ( pSrc , pWC , idxNew2 ) ; 
line 87780: pTerm = & pWC -> a [ idxTerm ] ; 
line 87781: if ( isComplete ) { 
line 87782: pWC -> a [ idxNew1 ] . iParent = idxTerm ; 
line 87783: pWC -> a [ idxNew2 ] . iParent = idxTerm ; 
line 87784: pTerm -> nChild = 2 ; 
line 87785: } 
line 87786: } 
line 87787: # endif 
line 87789: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 87796: if ( isMatchOfColumn ( pExpr ) ) { 
line 87797: int idxNew ; 
line 87798: Expr * pRight , * pLeft ; 
line 87799: WhereTerm * pNewTerm ; 
line 87800: Bitmask prereqColumn , prereqExpr ; 
line 87802: pRight = pExpr -> x . pList -> a [ 0 ] . pExpr ; 
line 87803: pLeft = pExpr -> x . pList -> a [ 1 ] . pExpr ; 
line 87804: prereqExpr = exprTableUsage ( pMaskSet , pRight ) ; 
line 87805: prereqColumn = exprTableUsage ( pMaskSet , pLeft ) ; 
line 87806: if ( ( prereqExpr & prereqColumn ) == 0 ) { 
line 87807: Expr * pNewExpr ; 
line 87808: pNewExpr = sqlite3PExpr ( pParse , TK_MATCH , 
line 87809: 0 , sqlite3ExprDup ( db , pRight , 0 ) , 0 ) ; 
line 87810: idxNew = whereClauseInsert ( pWC , pNewExpr , TERM_VIRTUAL | TERM_DYNAMIC ) ; 
line 87811: testcase ( idxNew == 0 ) ; 
line 87812: pNewTerm = & pWC -> a [ idxNew ] ; 
line 87813: pNewTerm -> prereqRight = prereqExpr ; 
line 87814: pNewTerm -> leftCursor = pLeft -> iTable ; 
line 87815: pNewTerm -> u . leftColumn = pLeft -> iColumn ; 
line 87816: pNewTerm -> eOperator = WO_MATCH ; 
line 87817: pNewTerm -> iParent = idxTerm ; 
line 87818: pTerm = & pWC -> a [ idxTerm ] ; 
line 87819: pTerm -> nChild = 1 ; 
line 87820: pTerm -> wtFlags |= TERM_COPIED ; 
line 87821: pNewTerm -> prereqAll = pTerm -> prereqAll ; 
line 87822: } 
line 87823: } 
line 87824: # endif 
line 87829: pTerm -> prereqRight |= extraRight ; 
line 87830: } 
line 87836: static int referencesOtherTables ( 
line 87837: ExprList * pList , 
line 87838: WhereMaskSet * pMaskSet , 
line 87839: int iFirst , 
line 87840: int iBase 
line 87841: ) { 
line 87842: Bitmask allowed = ~ getMask ( pMaskSet , iBase ) ; 
line 87843: while ( iFirst < pList -> nExpr ) { 
line 87844: if ( ( exprTableUsage ( pMaskSet , pList -> a [ iFirst ++ ] . pExpr ) & allowed ) != 0 ) { 
line 87845: return 1 ; 
line 87846: } 
line 87847: } 
line 87848: return 0 ; 
line 87849: } 
line 87871: static int isSortingIndex ( 
line 87872: Parse * pParse , 
line 87873: WhereMaskSet * pMaskSet , 
line 87874: Index * pIdx , 
line 87875: int base , 
line 87876: ExprList * pOrderBy , 
line 87877: int nEqCol , 
line 87878: int * pbRev 
line 87879: ) { 
line 87880: int i , j ; 
line 87881: int sortOrder = 0 ; 
line 87882: int nTerm ; 
line 87883: struct ExprList_item * pTerm ; 
line 87884: sqlite3 * db = pParse -> db ; 
line 87886: assert ( pOrderBy != 0 ) ; 
line 87887: nTerm = pOrderBy -> nExpr ; 
line 87888: assert ( nTerm > 0 ) ; 
line 87893: assert ( pIdx -> zName || ( pIdx -> nColumn == 1 && pIdx -> aiColumn [ 0 ] == - 1 ) ) ; 
line 87903: for ( i = j = 0 , pTerm = pOrderBy -> a ; j < nTerm && i <= pIdx -> nColumn ; i ++ ) { 
line 87904: Expr * pExpr ; 
line 87905: CollSeq * pColl ; 
line 87906: int termSortOrder ; 
line 87907: int iColumn ; 
line 87908: int iSortOrder ; 
line 87909: const char * zColl ; 
line 87911: pExpr = pTerm -> pExpr ; 
line 87912: if ( pExpr -> op != TK_COLUMN || pExpr -> iTable != base ) { 
line 87915: break ; 
line 87916: } 
line 87917: pColl = sqlite3ExprCollSeq ( pParse , pExpr ) ; 
line 87918: if ( ! pColl ) { 
line 87919: pColl = db -> pDfltColl ; 
line 87920: } 
line 87921: if ( pIdx -> zName && i < pIdx -> nColumn ) { 
line 87922: iColumn = pIdx -> aiColumn [ i ] ; 
line 87923: if ( iColumn == pIdx -> pTable -> iPKey ) { 
line 87924: iColumn = - 1 ; 
line 87925: } 
line 87926: iSortOrder = pIdx -> aSortOrder [ i ] ; 
line 87927: zColl = pIdx -> azColl [ i ] ; 
line 87928: } else { 
line 87929: iColumn = - 1 ; 
line 87930: iSortOrder = 0 ; 
line 87931: zColl = pColl -> zName ; 
line 87932: } 
line 87933: if ( pExpr -> iColumn != iColumn || sqlite3StrICmp ( pColl -> zName , zColl ) ) { 
line 87935: if ( i < nEqCol ) { 
line 87939: continue ; 
line 87940: } else if ( i == pIdx -> nColumn ) { 
line 87942: break ; 
line 87943: } else { 
line 87947: return 0 ; 
line 87948: } 
line 87949: } 
line 87950: assert ( pIdx -> aSortOrder != 0 || iColumn == - 1 ) ; 
line 87951: assert ( pTerm -> sortOrder == 0 || pTerm -> sortOrder == 1 ) ; 
line 87952: assert ( iSortOrder == 0 || iSortOrder == 1 ) ; 
line 87953: termSortOrder = iSortOrder ^ pTerm -> sortOrder ; 
line 87954: if ( i > nEqCol ) { 
line 87955: if ( termSortOrder != sortOrder ) { 
line 87958: return 0 ; 
line 87959: } 
line 87960: } else { 
line 87961: sortOrder = termSortOrder ; 
line 87962: } 
line 87963: j ++ ; 
line 87964: pTerm ++ ; 
line 87965: if ( iColumn < 0 && ! referencesOtherTables ( pOrderBy , pMaskSet , j , base ) ) { 
line 87972: j = nTerm ; 
line 87973: } 
line 87974: } 
line 87976: * pbRev = sortOrder != 0 ; 
line 87977: if ( j >= nTerm ) { 
line 87980: return 1 ; 
line 87981: } 
line 87982: if ( pIdx -> onError != OE_None && i == pIdx -> nColumn 
line 87983: && ! referencesOtherTables ( pOrderBy , pMaskSet , j , base ) ) { 
line 87988: return 1 ; 
line 87989: } 
line 87990: return 0 ; 
line 87991: } 
line 88000: static double estLog ( double N ) { 
line 88001: double logN = 1 ; 
line 88002: double x = 10 ; 
line 88003: while ( N > x ) { 
line 88004: logN += 1 ; 
line 88005: x *= 10 ; 
line 88006: } 
line 88007: return logN ; 
line 88008: } 
line 88016: # if ! defined ( SQLITE_OMIT_VIRTUALTABLE ) && defined ( SQLITE_DEBUG ) 
line 88017: static void TRACE_IDX_INPUTS ( sqlite3_index_info * p ) { 
line 88018: int i ; 
line 88019: if ( ! sqlite3WhereTrace ) return ; 
line 88020: for ( i = 0 ; i < p -> nConstraint ; i ++ ) { 
line 88021: sqlite3DebugPrintf ( "  constraint[%d]: col=%d termid=%d op=%d usabled=%d\n" , 
line 88022: i , 
line 88023: p -> aConstraint [ i ] . iColumn , 
line 88024: p -> aConstraint [ i ] . iTermOffset , 
line 88025: p -> aConstraint [ i ] . op , 
line 88026: p -> aConstraint [ i ] . usable ) ; 
line 88027: } 
line 88028: for ( i = 0 ; i < p -> nOrderBy ; i ++ ) { 
line 88029: sqlite3DebugPrintf ( "  orderby[%d]: col=%d desc=%d\n" , 
line 88030: i , 
line 88031: p -> aOrderBy [ i ] . iColumn , 
line 88032: p -> aOrderBy [ i ] . desc ) ; 
line 88033: } 
line 88034: } 
line 88035: static void TRACE_IDX_OUTPUTS ( sqlite3_index_info * p ) { 
line 88036: int i ; 
line 88037: if ( ! sqlite3WhereTrace ) return ; 
line 88038: for ( i = 0 ; i < p -> nConstraint ; i ++ ) { 
line 88039: sqlite3DebugPrintf ( "  usage[%d]: argvIdx=%d omit=%d\n" , 
line 88040: i , 
line 88041: p -> aConstraintUsage [ i ] . argvIndex , 
line 88042: p -> aConstraintUsage [ i ] . omit ) ; 
line 88043: } 
line 88044: sqlite3DebugPrintf ( "  idxNum=%d\n" , p -> idxNum ) ; 
line 88045: sqlite3DebugPrintf ( "  idxStr=%s\n" , p -> idxStr ) ; 
line 88046: sqlite3DebugPrintf ( "  orderByConsumed=%d\n" , p -> orderByConsumed ) ; 
line 88047: sqlite3DebugPrintf ( "  estimatedCost=%g\n" , p -> estimatedCost ) ; 
line 88048: } 
line 88049: # else 
line 88050: # define TRACE_IDX_INPUTS ( A ) 
line 88051: # define TRACE_IDX_OUTPUTS ( A ) 
line 88052: # endif 
line 88057: static void bestIndex ( 
line 88058: Parse * , WhereClause * , struct SrcList_item * , Bitmask , ExprList * , WhereCost * ) ; 
line 88067: static void bestOrClauseIndex ( 
line 88068: Parse * pParse , 
line 88069: WhereClause * pWC , 
line 88070: struct SrcList_item * pSrc , 
line 88071: Bitmask notReady , 
line 88072: ExprList * pOrderBy , 
line 88073: WhereCost * pCost 
line 88074: ) { 
line 88075: # ifndef SQLITE_OMIT_OR_OPTIMIZATION 
line 88076: const int iCur = pSrc -> iCursor ; 
line 88077: const Bitmask maskSrc = getMask ( pWC -> pMaskSet , iCur ) ; 
line 88078: WhereTerm * const pWCEnd = & pWC -> a [ pWC -> nTerm ] ; 
line 88079: WhereTerm * pTerm ; 
line 88082: for ( pTerm = pWC -> a ; pTerm < pWCEnd ; pTerm ++ ) { 
line 88083: if ( pTerm -> eOperator == WO_OR 
line 88084: && ( ( pTerm -> prereqAll & ~ maskSrc ) & notReady ) == 0 
line 88085: && ( pTerm -> u . pOrInfo -> indexable & maskSrc ) != 0 
line 88086: ) { 
line 88087: WhereClause * const pOrWC = & pTerm -> u . pOrInfo -> wc ; 
line 88088: WhereTerm * const pOrWCEnd = & pOrWC -> a [ pOrWC -> nTerm ] ; 
line 88089: WhereTerm * pOrTerm ; 
line 88090: int flags = WHERE_MULTI_OR ; 
line 88091: double rTotal = 0 ; 
line 88092: double nRow = 0 ; 
line 88093: Bitmask used = 0 ; 
line 88095: for ( pOrTerm = pOrWC -> a ; pOrTerm < pOrWCEnd ; pOrTerm ++ ) { 
line 88096: WhereCost sTermCost ; 
line 88097: WHERETRACE ( ( "... Multi-index OR testing for term %d of %d....\n" , 
line 88098: ( pOrTerm - pOrWC -> a ) , ( pTerm - pWC -> a ) 
line 88099: ) ) ; 
line 88100: if ( pOrTerm -> eOperator == WO_AND ) { 
line 88101: WhereClause * pAndWC = & pOrTerm -> u . pAndInfo -> wc ; 
line 88102: bestIndex ( pParse , pAndWC , pSrc , notReady , 0 , & sTermCost ) ; 
line 88103: } else if ( pOrTerm -> leftCursor == iCur ) { 
line 88104: WhereClause tempWC ; 
line 88105: tempWC . pParse = pWC -> pParse ; 
line 88106: tempWC . pMaskSet = pWC -> pMaskSet ; 
line 88107: tempWC . op = TK_AND ; 
line 88108: tempWC . a = pOrTerm ; 
line 88109: tempWC . nTerm = 1 ; 
line 88110: bestIndex ( pParse , & tempWC , pSrc , notReady , 0 , & sTermCost ) ; 
line 88111: } else { 
line 88112: continue ; 
line 88113: } 
line 88114: rTotal += sTermCost . rCost ; 
line 88115: nRow += sTermCost . nRow ; 
line 88116: used |= sTermCost . used ; 
line 88117: if ( rTotal >= pCost -> rCost ) break ; 
line 88118: } 
line 88122: if ( pOrderBy != 0 ) { 
line 88123: rTotal += nRow * estLog ( nRow ) ; 
line 88124: WHERETRACE ( ( "... sorting increases OR cost to %.9g\n" , rTotal ) ) ; 
line 88125: } 
line 88130: WHERETRACE ( ( "... multi-index OR cost=%.9g nrow=%.9g\n" , rTotal , nRow ) ) ; 
line 88131: if ( rTotal < pCost -> rCost ) { 
line 88132: pCost -> rCost = rTotal ; 
line 88133: pCost -> nRow = nRow ; 
line 88134: pCost -> used = used ; 
line 88135: pCost -> plan . wsFlags = flags ; 
line 88136: pCost -> plan . u . pTerm = pTerm ; 
line 88137: } 
line 88138: } 
line 88139: } 
line 88140: # endif 
line 88141: } 
line 88143: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 88149: static sqlite3_index_info * allocateIndexInfo ( 
line 88150: Parse * pParse , 
line 88151: WhereClause * pWC , 
line 88152: struct SrcList_item * pSrc , 
line 88153: ExprList * pOrderBy 
line 88154: ) { 
line 88155: int i , j ; 
line 88156: int nTerm ; 
line 88157: struct sqlite3_index_constraint * pIdxCons ; 
line 88158: struct sqlite3_index_orderby * pIdxOrderBy ; 
line 88159: struct sqlite3_index_constraint_usage * pUsage ; 
line 88160: WhereTerm * pTerm ; 
line 88161: int nOrderBy ; 
line 88162: sqlite3_index_info * pIdxInfo ; 
line 88164: WHERETRACE ( ( "Recomputing index info for %s...\n" , pSrc -> pTab -> zName ) ) ; 
line 88168: for ( i = nTerm = 0 , pTerm = pWC -> a ; i < pWC -> nTerm ; i ++ , pTerm ++ ) { 
line 88169: if ( pTerm -> leftCursor != pSrc -> iCursor ) continue ; 
line 88170: assert ( ( pTerm -> eOperator & ( pTerm -> eOperator - 1 ) ) == 0 ) ; 
line 88171: testcase ( pTerm -> eOperator == WO_IN ) ; 
line 88172: testcase ( pTerm -> eOperator == WO_ISNULL ) ; 
line 88173: if ( pTerm -> eOperator & ( WO_IN | WO_ISNULL ) ) continue ; 
line 88174: nTerm ++ ; 
line 88175: } 
line 88181: nOrderBy = 0 ; 
line 88182: if ( pOrderBy ) { 
line 88183: for ( i = 0 ; i < pOrderBy -> nExpr ; i ++ ) { 
line 88184: Expr * pExpr = pOrderBy -> a [ i ] . pExpr ; 
line 88185: if ( pExpr -> op != TK_COLUMN || pExpr -> iTable != pSrc -> iCursor ) break ; 
line 88186: } 
line 88187: if ( i == pOrderBy -> nExpr ) { 
line 88188: nOrderBy = pOrderBy -> nExpr ; 
line 88189: } 
line 88190: } 
line 88194: pIdxInfo = sqlite3DbMallocZero ( pParse -> db , sizeof ( * pIdxInfo ) 
line 88195: + ( sizeof ( * pIdxCons ) + sizeof ( * pUsage ) ) * nTerm 
line 88196: + sizeof ( * pIdxOrderBy ) * nOrderBy ) ; 
line 88197: if ( pIdxInfo == 0 ) { 
line 88198: sqlite3ErrorMsg ( pParse , "out of memory" ) ; 
line 88200: return 0 ; 
line 88201: } 
line 88208: pIdxCons = ( struct sqlite3_index_constraint * ) & pIdxInfo [ 1 ] ; 
line 88209: pIdxOrderBy = ( struct sqlite3_index_orderby * ) & pIdxCons [ nTerm ] ; 
line 88210: pUsage = ( struct sqlite3_index_constraint_usage * ) & pIdxOrderBy [ nOrderBy ] ; 
line 88211: * ( int * ) & pIdxInfo -> nConstraint = nTerm ; 
line 88212: * ( int * ) & pIdxInfo -> nOrderBy = nOrderBy ; 
line 88213: * ( struct sqlite3_index_constraint * * ) & pIdxInfo -> aConstraint = pIdxCons ; 
line 88214: * ( struct sqlite3_index_orderby * * ) & pIdxInfo -> aOrderBy = pIdxOrderBy ; 
line 88215: * ( struct sqlite3_index_constraint_usage * * ) & pIdxInfo -> aConstraintUsage = 
line 88216: pUsage ; 
line 88218: for ( i = j = 0 , pTerm = pWC -> a ; i < pWC -> nTerm ; i ++ , pTerm ++ ) { 
line 88219: if ( pTerm -> leftCursor != pSrc -> iCursor ) continue ; 
line 88220: assert ( ( pTerm -> eOperator & ( pTerm -> eOperator - 1 ) ) == 0 ) ; 
line 88221: testcase ( pTerm -> eOperator == WO_IN ) ; 
line 88222: testcase ( pTerm -> eOperator == WO_ISNULL ) ; 
line 88223: if ( pTerm -> eOperator & ( WO_IN | WO_ISNULL ) ) continue ; 
line 88224: pIdxCons [ j ] . iColumn = pTerm -> u . leftColumn ; 
line 88225: pIdxCons [ j ] . iTermOffset = i ; 
line 88226: pIdxCons [ j ] . op = ( u8 ) pTerm -> eOperator ; 
line 88230: assert ( WO_EQ == SQLITE_INDEX_CONSTRAINT_EQ ) ; 
line 88231: assert ( WO_LT == SQLITE_INDEX_CONSTRAINT_LT ) ; 
line 88232: assert ( WO_LE == SQLITE_INDEX_CONSTRAINT_LE ) ; 
line 88233: assert ( WO_GT == SQLITE_INDEX_CONSTRAINT_GT ) ; 
line 88234: assert ( WO_GE == SQLITE_INDEX_CONSTRAINT_GE ) ; 
line 88235: assert ( WO_MATCH == SQLITE_INDEX_CONSTRAINT_MATCH ) ; 
line 88236: assert ( pTerm -> eOperator & ( WO_EQ | WO_LT | WO_LE | WO_GT | WO_GE | WO_MATCH ) ) ; 
line 88237: j ++ ; 
line 88238: } 
line 88239: for ( i = 0 ; i < nOrderBy ; i ++ ) { 
line 88240: Expr * pExpr = pOrderBy -> a [ i ] . pExpr ; 
line 88241: pIdxOrderBy [ i ] . iColumn = pExpr -> iColumn ; 
line 88242: pIdxOrderBy [ i ] . desc = pOrderBy -> a [ i ] . sortOrder ; 
line 88243: } 
line 88245: return pIdxInfo ; 
line 88246: } 
line 88262: static int vtabBestIndex ( Parse * pParse , Table * pTab , sqlite3_index_info * p ) { 
line 88263: sqlite3_vtab * pVtab = sqlite3GetVTable ( pParse -> db , pTab ) -> pVtab ; 
line 88264: int i ; 
line 88265: int rc ; 
line 88267: ( void ) sqlite3SafetyOff ( pParse -> db ) ; 
line 88268: WHERETRACE ( ( "xBestIndex for %s\n" , pTab -> zName ) ) ; 
line 88269: TRACE_IDX_INPUTS ( p ) ; 
line 88270: rc = pVtab -> pModule -> xBestIndex ( pVtab , p ) ; 
line 88271: TRACE_IDX_OUTPUTS ( p ) ; 
line 88272: ( void ) sqlite3SafetyOn ( pParse -> db ) ; 
line 88274: if ( rc != SQLITE_OK ) { 
line 88275: if ( rc == SQLITE_NOMEM ) { 
line 88276: pParse -> db -> mallocFailed = 1 ; 
line 88277: } else if ( ! pVtab -> zErrMsg ) { 
line 88278: sqlite3ErrorMsg ( pParse , "%s" , sqlite3ErrStr ( rc ) ) ; 
line 88279: } else { 
line 88280: sqlite3ErrorMsg ( pParse , "%s" , pVtab -> zErrMsg ) ; 
line 88281: } 
line 88282: } 
line 88283: sqlite3DbFree ( pParse -> db , pVtab -> zErrMsg ) ; 
line 88284: pVtab -> zErrMsg = 0 ; 
line 88286: for ( i = 0 ; i < p -> nConstraint ; i ++ ) { 
line 88287: if ( ! p -> aConstraint [ i ] . usable && p -> aConstraintUsage [ i ] . argvIndex > 0 ) { 
line 88288: sqlite3ErrorMsg ( pParse , 
line 88289: "table %s: xBestIndex returned an invalid plan" , pTab -> zName ) ; 
line 88290: } 
line 88291: } 
line 88293: return pParse -> nErr ; 
line 88294: } 
line 88313: static void bestVirtualIndex ( 
line 88314: Parse * pParse , 
line 88315: WhereClause * pWC , 
line 88316: struct SrcList_item * pSrc , 
line 88317: Bitmask notReady , 
line 88318: ExprList * pOrderBy , 
line 88319: WhereCost * pCost , 
line 88320: sqlite3_index_info * * ppIdxInfo 
line 88321: ) { 
line 88322: Table * pTab = pSrc -> pTab ; 
line 88323: sqlite3_index_info * pIdxInfo ; 
line 88324: struct sqlite3_index_constraint * pIdxCons ; 
line 88325: struct sqlite3_index_constraint_usage * pUsage ; 
line 88326: WhereTerm * pTerm ; 
line 88327: int i , j ; 
line 88328: int nOrderBy ; 
line 88334: memset ( pCost , 0 , sizeof ( * pCost ) ) ; 
line 88335: pCost -> plan . wsFlags = WHERE_VIRTUALTABLE ; 
line 88340: pIdxInfo = * ppIdxInfo ; 
line 88341: if ( pIdxInfo == 0 ) { 
line 88342: * ppIdxInfo = pIdxInfo = allocateIndexInfo ( pParse , pWC , pSrc , pOrderBy ) ; 
line 88343: } 
line 88344: if ( pIdxInfo == 0 ) { 
line 88345: return ; 
line 88346: } 
line 88359: assert ( pTab -> azModuleArg && pTab -> azModuleArg [ 0 ] ) ; 
line 88360: assert ( sqlite3GetVTable ( pParse -> db , pTab ) ) ; 
line 88382: pIdxCons = * ( struct sqlite3_index_constraint * * ) & pIdxInfo -> aConstraint ; 
line 88383: pUsage = pIdxInfo -> aConstraintUsage ; 
line 88384: for ( i = 0 ; i < pIdxInfo -> nConstraint ; i ++ , pIdxCons ++ ) { 
line 88385: j = pIdxCons -> iTermOffset ; 
line 88386: pTerm = & pWC -> a [ j ] ; 
line 88387: pIdxCons -> usable = ( pTerm -> prereqRight & notReady ) ? 0 : 1 ; 
line 88388: } 
line 88389: memset ( pUsage , 0 , sizeof ( pUsage [ 0 ] ) * pIdxInfo -> nConstraint ) ; 
line 88390: if ( pIdxInfo -> needToFreeIdxStr ) { 
line 88391: sqlite3_free ( pIdxInfo -> idxStr ) ; 
line 88392: } 
line 88393: pIdxInfo -> idxStr = 0 ; 
line 88394: pIdxInfo -> idxNum = 0 ; 
line 88395: pIdxInfo -> needToFreeIdxStr = 0 ; 
line 88396: pIdxInfo -> orderByConsumed = 0 ; 
line 88398: pIdxInfo -> estimatedCost = SQLITE_BIG_DBL / ( ( double ) 2 ) ; 
line 88399: nOrderBy = pIdxInfo -> nOrderBy ; 
line 88400: if ( ! pOrderBy ) { 
line 88401: pIdxInfo -> nOrderBy = 0 ; 
line 88402: } 
line 88404: if ( vtabBestIndex ( pParse , pTab , pIdxInfo ) ) { 
line 88405: return ; 
line 88406: } 
line 88408: pIdxCons = * ( struct sqlite3_index_constraint * * ) & pIdxInfo -> aConstraint ; 
line 88409: for ( i = 0 ; i < pIdxInfo -> nConstraint ; i ++ ) { 
line 88410: if ( pUsage [ i ] . argvIndex > 0 ) { 
line 88411: pCost -> used |= pWC -> a [ pIdxCons [ i ] . iTermOffset ] . prereqRight ; 
line 88412: } 
line 88413: } 
line 88422: if ( ( SQLITE_BIG_DBL / ( ( double ) 2 ) ) < pIdxInfo -> estimatedCost ) { 
line 88423: pCost -> rCost = ( SQLITE_BIG_DBL / ( ( double ) 2 ) ) ; 
line 88424: } else { 
line 88425: pCost -> rCost = pIdxInfo -> estimatedCost ; 
line 88426: } 
line 88427: pCost -> plan . u . pVtabIdx = pIdxInfo ; 
line 88428: if ( pIdxInfo -> orderByConsumed ) { 
line 88429: pCost -> plan . wsFlags |= WHERE_ORDERBY ; 
line 88430: } 
line 88431: pCost -> plan . nEq = 0 ; 
line 88432: pIdxInfo -> nOrderBy = nOrderBy ; 
line 88437: bestOrClauseIndex ( pParse , pWC , pSrc , notReady , pOrderBy , pCost ) ; 
line 88438: } 
line 88439: # endif 
line 88456: # ifdef SQLITE_ENABLE_STAT2 
line 88457: static int whereRangeRegion ( 
line 88458: Parse * pParse , 
line 88459: Index * pIdx , 
line 88460: sqlite3_value * pVal , 
line 88461: int * piRegion 
line 88462: ) { 
line 88463: if ( ALWAYS ( pVal ) ) { 
line 88464: IndexSample * aSample = pIdx -> aSample ; 
line 88465: int i = 0 ; 
line 88466: int eType = sqlite3_value_type ( pVal ) ; 
line 88468: if ( eType == SQLITE_INTEGER || eType == SQLITE_FLOAT ) { 
line 88469: double r = sqlite3_value_double ( pVal ) ; 
line 88470: for ( i = 0 ; i < SQLITE_INDEX_SAMPLES ; i ++ ) { 
line 88471: if ( aSample [ i ] . eType == SQLITE_NULL ) continue ; 
line 88472: if ( aSample [ i ] . eType >= SQLITE_TEXT || aSample [ i ] . u . r > r ) break ; 
line 88473: } 
line 88474: } else { 
line 88475: sqlite3 * db = pParse -> db ; 
line 88476: CollSeq * pColl ; 
line 88477: const u8 * z ; 
line 88478: int n ; 
line 88481: assert ( eType == SQLITE_TEXT || eType == SQLITE_BLOB ) ; 
line 88483: if ( eType == SQLITE_BLOB ) { 
line 88484: z = ( const u8 * ) sqlite3_value_blob ( pVal ) ; 
line 88485: pColl = db -> pDfltColl ; 
line 88486: assert ( pColl -> enc == SQLITE_UTF8 ) ; 
line 88487: } else { 
line 88488: pColl = sqlite3GetCollSeq ( db , SQLITE_UTF8 , 0 , * pIdx -> azColl ) ; 
line 88489: if ( pColl == 0 ) { 
line 88490: sqlite3ErrorMsg ( pParse , "no such collation sequence: %s" , 
line 88491: * pIdx -> azColl ) ; 
line 88492: return SQLITE_ERROR ; 
line 88493: } 
line 88494: z = ( const u8 * ) sqlite3ValueText ( pVal , pColl -> enc ) ; 
line 88495: if ( ! z ) { 
line 88496: return SQLITE_NOMEM ; 
line 88497: } 
line 88498: assert ( z && pColl && pColl -> xCmp ) ; 
line 88499: } 
line 88500: n = sqlite3ValueBytes ( pVal , pColl -> enc ) ; 
line 88502: for ( i = 0 ; i < SQLITE_INDEX_SAMPLES ; i ++ ) { 
line 88503: int r ; 
line 88504: int eSampletype = aSample [ i ] . eType ; 
line 88505: if ( eSampletype == SQLITE_NULL || eSampletype < eType ) continue ; 
line 88506: if ( ( eSampletype != eType ) ) break ; 
line 88507: # ifndef SQLITE_OMIT_UTF16 
line 88508: if ( pColl -> enc != SQLITE_UTF8 ) { 
line 88509: int nSample ; 
line 88510: char * zSample = sqlite3Utf8to16 ( 
line 88511: db , pColl -> enc , aSample [ i ] . u . z , aSample [ i ] . nByte , & nSample 
line 88512: ) ; 
line 88513: if ( ! zSample ) { 
line 88514: assert ( db -> mallocFailed ) ; 
line 88515: return SQLITE_NOMEM ; 
line 88516: } 
line 88517: r = pColl -> xCmp ( pColl -> pUser , nSample , zSample , n , z ) ; 
line 88518: sqlite3DbFree ( db , zSample ) ; 
line 88519: } else 
line 88520: # endif 
line 88521: { 
line 88522: r = pColl -> xCmp ( pColl -> pUser , aSample [ i ] . nByte , aSample [ i ] . u . z , n , z ) ; 
line 88523: } 
line 88524: if ( r > 0 ) break ; 
line 88525: } 
line 88526: } 
line 88528: assert ( i >= 0 && i <= SQLITE_INDEX_SAMPLES ) ; 
line 88529: * piRegion = i ; 
line 88530: } 
line 88531: return SQLITE_OK ; 
line 88532: } 
line 88533: # endif 
line 88551: # ifdef SQLITE_ENABLE_STAT2 
line 88552: static int valueFromExpr ( 
line 88553: Parse * pParse , 
line 88554: Expr * pExpr , 
line 88555: u8 aff , 
line 88556: sqlite3_value * * pp 
line 88557: ) { 
line 88560: assert ( pExpr -> op != TK_VARIABLE ) ; 
line 88561: if ( pExpr -> op == TK_REGISTER && pExpr -> op2 == TK_VARIABLE ) { 
line 88562: int iVar = pExpr -> iColumn ; 
line 88563: sqlite3VdbeSetVarmask ( pParse -> pVdbe , iVar ) ; 
line 88564: * pp = sqlite3VdbeGetValue ( pParse -> pReprepare , iVar , aff ) ; 
line 88565: return SQLITE_OK ; 
line 88566: } 
line 88567: return sqlite3ValueFromExpr ( pParse -> db , pExpr , SQLITE_UTF8 , aff , pp ) ; 
line 88568: } 
line 88569: # endif 
line 88612: static int whereRangeScanEst ( 
line 88613: Parse * pParse , 
line 88614: Index * p , 
line 88615: int nEq , 
line 88616: WhereTerm * pLower , 
line 88617: WhereTerm * pUpper , 
line 88618: int * piEst 
line 88619: ) { 
line 88620: int rc = SQLITE_OK ; 
line 88622: # ifdef SQLITE_ENABLE_STAT2 
line 88624: if ( nEq == 0 && p -> aSample ) { 
line 88625: sqlite3_value * pLowerVal = 0 ; 
line 88626: sqlite3_value * pUpperVal = 0 ; 
line 88627: int iEst ; 
line 88628: int iLower = 0 ; 
line 88629: int iUpper = SQLITE_INDEX_SAMPLES ; 
line 88630: u8 aff = p -> pTable -> aCol [ p -> aiColumn [ 0 ] ] . affinity ; 
line 88632: if ( pLower ) { 
line 88633: Expr * pExpr = pLower -> pExpr -> pRight ; 
line 88634: rc = valueFromExpr ( pParse , pExpr , aff , & pLowerVal ) ; 
line 88635: } 
line 88636: if ( rc == SQLITE_OK && pUpper ) { 
line 88637: Expr * pExpr = pUpper -> pExpr -> pRight ; 
line 88638: rc = valueFromExpr ( pParse , pExpr , aff , & pUpperVal ) ; 
line 88639: } 
line 88641: if ( rc != SQLITE_OK || ( pLowerVal == 0 && pUpperVal == 0 ) ) { 
line 88642: sqlite3ValueFree ( pLowerVal ) ; 
line 88643: sqlite3ValueFree ( pUpperVal ) ; 
line 88644: goto range_est_fallback ; 
line 88645: } else if ( pLowerVal == 0 ) { 
line 88646: rc = whereRangeRegion ( pParse , p , pUpperVal , & iUpper ) ; 
line 88647: if ( pLower ) iLower = iUpper / 2 ; 
line 88648: } else if ( pUpperVal == 0 ) { 
line 88649: rc = whereRangeRegion ( pParse , p , pLowerVal , & iLower ) ; 
line 88650: if ( pUpper ) iUpper = ( iLower + SQLITE_INDEX_SAMPLES + 1 ) / 2 ; 
line 88651: } else { 
line 88652: rc = whereRangeRegion ( pParse , p , pUpperVal , & iUpper ) ; 
line 88653: if ( rc == SQLITE_OK ) { 
line 88654: rc = whereRangeRegion ( pParse , p , pLowerVal , & iLower ) ; 
line 88655: } 
line 88656: } 
line 88658: iEst = iUpper - iLower ; 
line 88659: testcase ( iEst == SQLITE_INDEX_SAMPLES ) ; 
line 88660: assert ( iEst <= SQLITE_INDEX_SAMPLES ) ; 
line 88661: if ( iEst < 1 ) { 
line 88662: iEst = 1 ; 
line 88663: } 
line 88665: sqlite3ValueFree ( pLowerVal ) ; 
line 88666: sqlite3ValueFree ( pUpperVal ) ; 
line 88667: * piEst = ( iEst * 100 ) / SQLITE_INDEX_SAMPLES ; 
line 88668: return rc ; 
line 88669: } 
line 88670: range_est_fallback : 
line 88671: # else 
line 88672: UNUSED_PARAMETER ( pParse ) ; 
line 88673: UNUSED_PARAMETER ( p ) ; 
line 88674: UNUSED_PARAMETER ( nEq ) ; 
line 88675: # endif 
line 88676: assert ( pLower || pUpper ) ; 
line 88677: if ( pLower && pUpper ) { 
line 88678: * piEst = 11 ; 
line 88679: } else { 
line 88680: * piEst = 33 ; 
line 88681: } 
line 88682: return rc ; 
line 88683: } 
line 88714: static void bestBtreeIndex ( 
line 88715: Parse * pParse , 
line 88716: WhereClause * pWC , 
line 88717: struct SrcList_item * pSrc , 
line 88718: Bitmask notReady , 
line 88719: ExprList * pOrderBy , 
line 88720: WhereCost * pCost 
line 88721: ) { 
line 88722: int iCur = pSrc -> iCursor ; 
line 88723: Index * pProbe ; 
line 88724: Index * pIdx ; 
line 88725: int eqTermMask ; 
line 88726: int idxEqTermMask ; 
line 88727: Index sPk ; 
line 88728: unsigned int aiRowEstPk [ 2 ] ; 
line 88729: int aiColumnPk = - 1 ; 
line 88730: int wsFlagMask ; 
line 88733: memset ( pCost , 0 , sizeof ( * pCost ) ) ; 
line 88734: pCost -> rCost = SQLITE_BIG_DBL ; 
line 88741: if ( pSrc -> jointype & JT_LEFT ) { 
line 88742: idxEqTermMask = WO_EQ | WO_IN ; 
line 88743: } else { 
line 88744: idxEqTermMask = WO_EQ | WO_IN | WO_ISNULL ; 
line 88745: } 
line 88747: if ( pSrc -> pIndex ) { 
line 88749: pIdx = pProbe = pSrc -> pIndex ; 
line 88750: wsFlagMask = ~ ( WHERE_ROWID_EQ | WHERE_ROWID_RANGE ) ; 
line 88751: eqTermMask = idxEqTermMask ; 
line 88752: } else { 
line 88755: Index * pFirst ; 
line 88756: memset ( & sPk , 0 , sizeof ( Index ) ) ; 
line 88757: sPk . nColumn = 1 ; 
line 88758: sPk . aiColumn = & aiColumnPk ; 
line 88759: sPk . aiRowEst = aiRowEstPk ; 
line 88760: aiRowEstPk [ 1 ] = 1 ; 
line 88761: sPk . onError = OE_Replace ; 
line 88762: sPk . pTable = pSrc -> pTab ; 
line 88763: pFirst = pSrc -> pTab -> pIndex ; 
line 88764: if ( pSrc -> notIndexed == 0 ) { 
line 88765: sPk . pNext = pFirst ; 
line 88766: } 
line 88771: if ( pFirst ) { 
line 88772: assert ( pFirst -> aiRowEst != 0 ) ; 
line 88773: aiRowEstPk [ 0 ] = pFirst -> aiRowEst [ 0 ] ; 
line 88774: } else { 
line 88775: aiRowEstPk [ 0 ] = 1000000 ; 
line 88776: } 
line 88777: pProbe = & sPk ; 
line 88778: wsFlagMask = ~ ( 
line 88779: WHERE_COLUMN_IN | WHERE_COLUMN_EQ | WHERE_COLUMN_NULL | WHERE_COLUMN_RANGE 
line 88780: ) ; 
line 88781: eqTermMask = WO_EQ | WO_IN ; 
line 88782: pIdx = 0 ; 
line 88783: } 
line 88787: for ( ; pProbe ; pIdx = pProbe = pProbe -> pNext ) { 
line 88788: const unsigned int * const aiRowEst = pProbe -> aiRowEst ; 
line 88789: double cost ; 
line 88790: double nRow ; 
line 88791: int rev ; 
line 88792: int wsFlags = 0 ; 
line 88793: Bitmask used = 0 ; 
line 88852: int nEq ; 
line 88853: int bInEst = 0 ; 
line 88854: int nInMul = 1 ; 
line 88855: int nBound = 100 ; 
line 88856: int bSort = 0 ; 
line 88857: int bLookup = 0 ; 
line 88860: for ( nEq = 0 ; nEq < pProbe -> nColumn ; nEq ++ ) { 
line 88861: WhereTerm * pTerm ; 
line 88862: int j = pProbe -> aiColumn [ nEq ] ; 
line 88863: pTerm = findTerm ( pWC , iCur , j , notReady , eqTermMask , pIdx ) ; 
line 88864: if ( pTerm == 0 ) break ; 
line 88865: wsFlags |= ( WHERE_COLUMN_EQ | WHERE_ROWID_EQ ) ; 
line 88866: if ( pTerm -> eOperator & WO_IN ) { 
line 88867: Expr * pExpr = pTerm -> pExpr ; 
line 88868: wsFlags |= WHERE_COLUMN_IN ; 
line 88869: if ( ExprHasProperty ( pExpr , EP_xIsSelect ) ) { 
line 88870: nInMul *= 25 ; 
line 88871: bInEst = 1 ; 
line 88872: } else if ( pExpr -> x . pList ) { 
line 88873: nInMul *= pExpr -> x . pList -> nExpr + 1 ; 
line 88874: } 
line 88875: } else if ( pTerm -> eOperator & WO_ISNULL ) { 
line 88876: wsFlags |= WHERE_COLUMN_NULL ; 
line 88877: } 
line 88878: used |= pTerm -> prereqRight ; 
line 88879: } 
line 88882: if ( nEq < pProbe -> nColumn ) { 
line 88883: int j = pProbe -> aiColumn [ nEq ] ; 
line 88884: if ( findTerm ( pWC , iCur , j , notReady , WO_LT | WO_LE | WO_GT | WO_GE , pIdx ) ) { 
line 88885: WhereTerm * pTop = findTerm ( pWC , iCur , j , notReady , WO_LT | WO_LE , pIdx ) ; 
line 88886: WhereTerm * pBtm = findTerm ( pWC , iCur , j , notReady , WO_GT | WO_GE , pIdx ) ; 
line 88887: whereRangeScanEst ( pParse , pProbe , nEq , pBtm , pTop , & nBound ) ; 
line 88888: if ( pTop ) { 
line 88889: wsFlags |= WHERE_TOP_LIMIT ; 
line 88890: used |= pTop -> prereqRight ; 
line 88891: } 
line 88892: if ( pBtm ) { 
line 88893: wsFlags |= WHERE_BTM_LIMIT ; 
line 88894: used |= pBtm -> prereqRight ; 
line 88895: } 
line 88896: wsFlags |= ( WHERE_COLUMN_RANGE | WHERE_ROWID_RANGE ) ; 
line 88897: } 
line 88898: } else if ( pProbe -> onError != OE_None ) { 
line 88899: testcase ( wsFlags & WHERE_COLUMN_IN ) ; 
line 88900: testcase ( wsFlags & WHERE_COLUMN_NULL ) ; 
line 88901: if ( ( wsFlags & ( WHERE_COLUMN_IN | WHERE_COLUMN_NULL ) ) == 0 ) { 
line 88902: wsFlags |= WHERE_UNIQUE ; 
line 88903: } 
line 88904: } 
line 88910: if ( pOrderBy ) { 
line 88911: if ( ( wsFlags & ( WHERE_COLUMN_IN | WHERE_COLUMN_NULL ) ) == 0 
line 88912: && isSortingIndex ( pParse , pWC -> pMaskSet , pProbe , iCur , pOrderBy , nEq , & rev ) 
line 88913: ) { 
line 88914: wsFlags |= WHERE_ROWID_RANGE | WHERE_COLUMN_RANGE | WHERE_ORDERBY ; 
line 88915: wsFlags |= ( rev ? WHERE_REVERSE : 0 ) ; 
line 88916: } else { 
line 88917: bSort = 1 ; 
line 88918: } 
line 88919: } 
line 88926: if ( pIdx && wsFlags ) { 
line 88927: Bitmask m = pSrc -> colUsed ; 
line 88928: int j ; 
line 88929: for ( j = 0 ; j < pIdx -> nColumn ; j ++ ) { 
line 88930: int x = pIdx -> aiColumn [ j ] ; 
line 88931: if ( x < BMS - 1 ) { 
line 88932: m &= ~ ( ( ( Bitmask ) 1 ) << x ) ; 
line 88933: } 
line 88934: } 
line 88935: if ( m == 0 ) { 
line 88936: wsFlags |= WHERE_IDX_ONLY ; 
line 88937: } else { 
line 88938: bLookup = 1 ; 
line 88939: } 
line 88940: } 
line 88947: nRow = ( double ) ( aiRowEst [ nEq ] * nInMul ) ; 
line 88948: if ( bInEst && nRow * 2 > aiRowEst [ 0 ] ) { 
line 88949: nRow = aiRowEst [ 0 ] / 2 ; 
line 88950: nInMul = ( int ) ( nRow / aiRowEst [ nEq ] ) ; 
line 88951: } 
line 88957: cost = nRow + nInMul * estLog ( aiRowEst [ 0 ] ) ; 
line 88962: nRow = ( nRow * ( double ) nBound ) / ( double ) 100 ; 
line 88963: cost = ( cost * ( double ) nBound ) / ( double ) 100 ; 
line 88967: if ( bSort ) { 
line 88968: cost += cost * estLog ( cost ) ; 
line 88969: } 
line 88975: if ( pIdx && bLookup == 0 ) { 
line 88976: cost /= ( double ) 2 ; 
line 88977: } 
line 88980: WHERETRACE ( ( 
line 88981: "tbl=%s idx=%s nEq=%d nInMul=%d nBound=%d bSort=%d bLookup=%d" 
line 88982: " wsFlags=%d   (nRow=%.2f cost=%.2f)\n" , 
line 88983: pSrc -> pTab -> zName , ( pIdx ? pIdx -> zName : "ipk" ) , 
line 88984: nEq , nInMul , nBound , bSort , bLookup , wsFlags , nRow , cost 
line 88985: ) ) ; 
line 88990: if ( ( ! pIdx || wsFlags ) && cost < pCost -> rCost ) { 
line 88991: pCost -> rCost = cost ; 
line 88992: pCost -> nRow = nRow ; 
line 88993: pCost -> used = used ; 
line 88994: pCost -> plan . wsFlags = ( wsFlags & wsFlagMask ) ; 
line 88995: pCost -> plan . nEq = nEq ; 
line 88996: pCost -> plan . u . pIdx = pIdx ; 
line 88997: } 
line 89001: if ( pSrc -> pIndex ) break ; 
line 89004: wsFlagMask = ~ ( WHERE_ROWID_EQ | WHERE_ROWID_RANGE ) ; 
line 89005: eqTermMask = idxEqTermMask ; 
line 89006: } 
line 89013: if ( ! pOrderBy && pParse -> db -> flags & SQLITE_ReverseOrder ) { 
line 89014: pCost -> plan . wsFlags |= WHERE_REVERSE ; 
line 89015: } 
line 89017: assert ( pOrderBy || ( pCost -> plan . wsFlags & WHERE_ORDERBY ) == 0 ) ; 
line 89018: assert ( pCost -> plan . u . pIdx == 0 || ( pCost -> plan . wsFlags & WHERE_ROWID_EQ ) == 0 ) ; 
line 89019: assert ( pSrc -> pIndex == 0 
line 89020: || pCost -> plan . u . pIdx == 0 
line 89021: || pCost -> plan . u . pIdx == pSrc -> pIndex 
line 89022: ) ; 
line 89024: WHERETRACE ( ( "best index is: %s\n" , 
line 89025: ( pCost -> plan . u . pIdx ? pCost -> plan . u . pIdx -> zName : "ipk" ) 
line 89026: ) ) ; 
line 89028: bestOrClauseIndex ( pParse , pWC , pSrc , notReady , pOrderBy , pCost ) ; 
line 89029: pCost -> plan . wsFlags |= eqTermMask ; 
line 89030: } 
line 89038: static void bestIndex ( 
line 89039: Parse * pParse , 
line 89040: WhereClause * pWC , 
line 89041: struct SrcList_item * pSrc , 
line 89042: Bitmask notReady , 
line 89043: ExprList * pOrderBy , 
line 89044: WhereCost * pCost 
line 89045: ) { 
line 89046: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 89047: if ( IsVirtual ( pSrc -> pTab ) ) { 
line 89048: sqlite3_index_info * p = 0 ; 
line 89049: bestVirtualIndex ( pParse , pWC , pSrc , notReady , pOrderBy , pCost , & p ) ; 
line 89050: if ( p -> needToFreeIdxStr ) { 
line 89051: sqlite3_free ( p -> idxStr ) ; 
line 89052: } 
line 89053: sqlite3DbFree ( pParse -> db , p ) ; 
line 89054: } else 
line 89055: # endif 
line 89056: { 
line 89057: bestBtreeIndex ( pParse , pWC , pSrc , notReady , pOrderBy , pCost ) ; 
line 89058: } 
line 89059: } 
line 89084: static void disableTerm ( WhereLevel * pLevel , WhereTerm * pTerm ) { 
line 89085: if ( pTerm 
line 89086: && ALWAYS ( ( pTerm -> wtFlags & TERM_CODED ) == 0 ) 
line 89087: && ( pLevel -> iLeftJoin == 0 || ExprHasProperty ( pTerm -> pExpr , EP_FromJoin ) ) 
line 89088: ) { 
line 89089: pTerm -> wtFlags |= TERM_CODED ; 
line 89090: if ( pTerm -> iParent >= 0 ) { 
line 89091: WhereTerm * pOther = & pTerm -> pWC -> a [ pTerm -> iParent ] ; 
line 89092: if ( ( -- pOther -> nChild ) == 0 ) { 
line 89093: disableTerm ( pLevel , pOther ) ; 
line 89094: } 
line 89095: } 
line 89096: } 
line 89097: } 
line 89110: static void codeApplyAffinity ( Parse * pParse , int base , int n , char * zAff ) { 
line 89111: Vdbe * v = pParse -> pVdbe ; 
line 89112: if ( zAff == 0 ) { 
line 89113: assert ( pParse -> db -> mallocFailed ) ; 
line 89114: return ; 
line 89115: } 
line 89116: assert ( v != 0 ) ; 
line 89121: while ( n > 0 && zAff [ 0 ] == SQLITE_AFF_NONE ) { 
line 89122: n -- ; 
line 89123: base ++ ; 
line 89124: zAff ++ ; 
line 89125: } 
line 89126: while ( n > 1 && zAff [ n - 1 ] == SQLITE_AFF_NONE ) { 
line 89127: n -- ; 
line 89128: } 
line 89131: if ( n > 0 ) { 
line 89132: sqlite3VdbeAddOp2 ( v , OP_Affinity , base , n ) ; 
line 89133: sqlite3VdbeChangeP4 ( v , - 1 , zAff , n ) ; 
line 89134: sqlite3ExprCacheAffinityChange ( pParse , base , n ) ; 
line 89135: } 
line 89136: } 
line 89150: static int codeEqualityTerm ( 
line 89151: Parse * pParse , 
line 89152: WhereTerm * pTerm , 
line 89153: WhereLevel * pLevel , 
line 89154: int iTarget 
line 89155: ) { 
line 89156: Expr * pX = pTerm -> pExpr ; 
line 89157: Vdbe * v = pParse -> pVdbe ; 
line 89158: int iReg ; 
line 89160: assert ( iTarget > 0 ) ; 
line 89161: if ( pX -> op == TK_EQ ) { 
line 89162: iReg = sqlite3ExprCodeTarget ( pParse , pX -> pRight , iTarget ) ; 
line 89163: } else if ( pX -> op == TK_ISNULL ) { 
line 89164: iReg = iTarget ; 
line 89165: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , iReg ) ; 
line 89166: # ifndef SQLITE_OMIT_SUBQUERY 
line 89167: } else { 
line 89168: int eType ; 
line 89169: int iTab ; 
line 89170: struct InLoop * pIn ; 
line 89172: assert ( pX -> op == TK_IN ) ; 
line 89173: iReg = iTarget ; 
line 89174: eType = sqlite3FindInIndex ( pParse , pX , 0 ) ; 
line 89175: iTab = pX -> iTable ; 
line 89176: sqlite3VdbeAddOp2 ( v , OP_Rewind , iTab , 0 ) ; 
line 89177: assert ( pLevel -> plan . wsFlags & WHERE_IN_ABLE ) ; 
line 89178: if ( pLevel -> u . in . nIn == 0 ) { 
line 89179: pLevel -> addrNxt = sqlite3VdbeMakeLabel ( v ) ; 
line 89180: } 
line 89181: pLevel -> u . in . nIn ++ ; 
line 89182: pLevel -> u . in . aInLoop = 
line 89183: sqlite3DbReallocOrFree ( pParse -> db , pLevel -> u . in . aInLoop , 
line 89184: sizeof ( pLevel -> u . in . aInLoop [ 0 ] ) * pLevel -> u . in . nIn ) ; 
line 89185: pIn = pLevel -> u . in . aInLoop ; 
line 89186: if ( pIn ) { 
line 89187: pIn += pLevel -> u . in . nIn - 1 ; 
line 89188: pIn -> iCur = iTab ; 
line 89189: if ( eType == IN_INDEX_ROWID ) { 
line 89190: pIn -> addrInTop = sqlite3VdbeAddOp2 ( v , OP_Rowid , iTab , iReg ) ; 
line 89191: } else { 
line 89192: pIn -> addrInTop = sqlite3VdbeAddOp3 ( v , OP_Column , iTab , 0 , iReg ) ; 
line 89193: } 
line 89194: sqlite3VdbeAddOp1 ( v , OP_IsNull , iReg ) ; 
line 89195: } else { 
line 89196: pLevel -> u . in . nIn = 0 ; 
line 89197: } 
line 89198: # endif 
line 89199: } 
line 89200: disableTerm ( pLevel , pTerm ) ; 
line 89201: return iReg ; 
line 89202: } 
line 89243: static int codeAllEqualityTerms ( 
line 89244: Parse * pParse , 
line 89245: WhereLevel * pLevel , 
line 89246: WhereClause * pWC , 
line 89247: Bitmask notReady , 
line 89248: int nExtraReg , 
line 89249: char * * pzAff 
line 89250: ) { 
line 89251: int nEq = pLevel -> plan . nEq ; 
line 89252: Vdbe * v = pParse -> pVdbe ; 
line 89253: Index * pIdx ; 
line 89254: int iCur = pLevel -> iTabCur ; 
line 89255: WhereTerm * pTerm ; 
line 89256: int j ; 
line 89257: int regBase ; 
line 89258: int nReg ; 
line 89259: char * zAff ; 
line 89262: assert ( pLevel -> plan . wsFlags & WHERE_INDEXED ) ; 
line 89263: pIdx = pLevel -> plan . u . pIdx ; 
line 89267: regBase = pParse -> nMem + 1 ; 
line 89268: nReg = pLevel -> plan . nEq + nExtraReg ; 
line 89269: pParse -> nMem += nReg ; 
line 89271: zAff = sqlite3DbStrDup ( pParse -> db , sqlite3IndexAffinityStr ( v , pIdx ) ) ; 
line 89272: if ( ! zAff ) { 
line 89273: pParse -> db -> mallocFailed = 1 ; 
line 89274: } 
line 89278: assert ( pIdx -> nColumn >= nEq ) ; 
line 89279: for ( j = 0 ; j < nEq ; j ++ ) { 
line 89280: int r1 ; 
line 89281: int k = pIdx -> aiColumn [ j ] ; 
line 89282: pTerm = findTerm ( pWC , iCur , k , notReady , pLevel -> plan . wsFlags , pIdx ) ; 
line 89283: if ( NEVER ( pTerm == 0 ) ) break ; 
line 89284: assert ( ( pTerm -> wtFlags & TERM_CODED ) == 0 ) ; 
line 89285: r1 = codeEqualityTerm ( pParse , pTerm , pLevel , regBase + j ) ; 
line 89286: if ( r1 != regBase + j ) { 
line 89287: if ( nReg == 1 ) { 
line 89288: sqlite3ReleaseTempReg ( pParse , regBase ) ; 
line 89289: regBase = r1 ; 
line 89290: } else { 
line 89291: sqlite3VdbeAddOp2 ( v , OP_SCopy , r1 , regBase + j ) ; 
line 89292: } 
line 89293: } 
line 89294: testcase ( pTerm -> eOperator & WO_ISNULL ) ; 
line 89295: testcase ( pTerm -> eOperator & WO_IN ) ; 
line 89296: if ( ( pTerm -> eOperator & ( WO_ISNULL | WO_IN ) ) == 0 ) { 
line 89297: Expr * pRight = pTerm -> pExpr -> pRight ; 
line 89298: sqlite3ExprCodeIsNullJump ( v , pRight , regBase + j , pLevel -> addrBrk ) ; 
line 89299: if ( zAff ) { 
line 89300: if ( sqlite3CompareAffinity ( pRight , zAff [ j ] ) == SQLITE_AFF_NONE ) { 
line 89301: zAff [ j ] = SQLITE_AFF_NONE ; 
line 89302: } 
line 89303: if ( sqlite3ExprNeedsNoAffinityChange ( pRight , zAff [ j ] ) ) { 
line 89304: zAff [ j ] = SQLITE_AFF_NONE ; 
line 89305: } 
line 89306: } 
line 89307: } 
line 89308: } 
line 89309: * pzAff = zAff ; 
line 89310: return regBase ; 
line 89311: } 
line 89317: static Bitmask codeOneLoopStart ( 
line 89318: WhereInfo * pWInfo , 
line 89319: int iLevel , 
line 89320: u16 wctrlFlags , 
line 89321: Bitmask notReady 
line 89322: ) { 
line 89323: int j , k ; 
line 89324: int iCur ; 
line 89325: int addrNxt ; 
line 89326: int omitTable ; 
line 89327: int bRev ; 
line 89328: WhereLevel * pLevel ; 
line 89329: WhereClause * pWC ; 
line 89330: WhereTerm * pTerm ; 
line 89331: Parse * pParse ; 
line 89332: Vdbe * v ; 
line 89333: struct SrcList_item * pTabItem ; 
line 89334: int addrBrk ; 
line 89335: int addrCont ; 
line 89336: int iRowidReg = 0 ; 
line 89337: int iReleaseReg = 0 ; 
line 89339: pParse = pWInfo -> pParse ; 
line 89340: v = pParse -> pVdbe ; 
line 89341: pWC = pWInfo -> pWC ; 
line 89342: pLevel = & pWInfo -> a [ iLevel ] ; 
line 89343: pTabItem = & pWInfo -> pTabList -> a [ pLevel -> iFrom ] ; 
line 89344: iCur = pTabItem -> iCursor ; 
line 89345: bRev = ( pLevel -> plan . wsFlags & WHERE_REVERSE ) != 0 ; 
line 89346: omitTable = ( pLevel -> plan . wsFlags & WHERE_IDX_ONLY ) != 0 
line 89347: && ( wctrlFlags & WHERE_FORCE_TABLE ) == 0 ; 
line 89359: addrBrk = pLevel -> addrBrk = pLevel -> addrNxt = sqlite3VdbeMakeLabel ( v ) ; 
line 89360: addrCont = pLevel -> addrCont = sqlite3VdbeMakeLabel ( v ) ; 
line 89366: if ( pLevel -> iFrom > 0 && ( pTabItem [ 0 ] . jointype & JT_LEFT ) != 0 ) { 
line 89367: pLevel -> iLeftJoin = ++ pParse -> nMem ; 
line 89368: sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pLevel -> iLeftJoin ) ; 
line 89369: VdbeComment ( ( v , "init LEFT JOIN no-match flag" ) ) ; 
line 89370: } 
line 89372: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 89373: if ( ( pLevel -> plan . wsFlags & WHERE_VIRTUALTABLE ) != 0 ) { 
line 89377: int iReg ; 
line 89378: sqlite3_index_info * pVtabIdx = pLevel -> plan . u . pVtabIdx ; 
line 89379: int nConstraint = pVtabIdx -> nConstraint ; 
line 89380: struct sqlite3_index_constraint_usage * aUsage = 
line 89381: pVtabIdx -> aConstraintUsage ; 
line 89382: const struct sqlite3_index_constraint * aConstraint = 
line 89383: pVtabIdx -> aConstraint ; 
line 89385: sqlite3ExprCachePush ( pParse ) ; 
line 89386: iReg = sqlite3GetTempRange ( pParse , nConstraint + 2 ) ; 
line 89387: for ( j = 1 ; j <= nConstraint ; j ++ ) { 
line 89388: for ( k = 0 ; k < nConstraint ; k ++ ) { 
line 89389: if ( aUsage [ k ] . argvIndex == j ) { 
line 89390: int iTerm = aConstraint [ k ] . iTermOffset ; 
line 89391: sqlite3ExprCode ( pParse , pWC -> a [ iTerm ] . pExpr -> pRight , iReg + j + 1 ) ; 
line 89392: break ; 
line 89393: } 
line 89394: } 
line 89395: if ( k == nConstraint ) break ; 
line 89396: } 
line 89397: sqlite3VdbeAddOp2 ( v , OP_Integer , pVtabIdx -> idxNum , iReg ) ; 
line 89398: sqlite3VdbeAddOp2 ( v , OP_Integer , j - 1 , iReg + 1 ) ; 
line 89399: sqlite3VdbeAddOp4 ( v , OP_VFilter , iCur , addrBrk , iReg , pVtabIdx -> idxStr , 
line 89400: pVtabIdx -> needToFreeIdxStr ? P4_MPRINTF : P4_STATIC ) ; 
line 89401: pVtabIdx -> needToFreeIdxStr = 0 ; 
line 89402: for ( j = 0 ; j < nConstraint ; j ++ ) { 
line 89403: if ( aUsage [ j ] . omit ) { 
line 89404: int iTerm = aConstraint [ j ] . iTermOffset ; 
line 89405: disableTerm ( pLevel , & pWC -> a [ iTerm ] ) ; 
line 89406: } 
line 89407: } 
line 89408: pLevel -> op = OP_VNext ; 
line 89409: pLevel -> p1 = iCur ; 
line 89410: pLevel -> p2 = sqlite3VdbeCurrentAddr ( v ) ; 
line 89411: sqlite3ReleaseTempRange ( pParse , iReg , nConstraint + 2 ) ; 
line 89412: sqlite3ExprCachePop ( pParse , 1 ) ; 
line 89413: } else 
line 89414: # endif 
line 89416: if ( pLevel -> plan . wsFlags & WHERE_ROWID_EQ ) { 
line 89422: iReleaseReg = sqlite3GetTempReg ( pParse ) ; 
line 89423: pTerm = findTerm ( pWC , iCur , - 1 , notReady , WO_EQ | WO_IN , 0 ) ; 
line 89424: assert ( pTerm != 0 ) ; 
line 89425: assert ( pTerm -> pExpr != 0 ) ; 
line 89426: assert ( pTerm -> leftCursor == iCur ) ; 
line 89427: assert ( omitTable == 0 ) ; 
line 89428: iRowidReg = codeEqualityTerm ( pParse , pTerm , pLevel , iReleaseReg ) ; 
line 89429: addrNxt = pLevel -> addrNxt ; 
line 89430: sqlite3VdbeAddOp2 ( v , OP_MustBeInt , iRowidReg , addrNxt ) ; 
line 89431: sqlite3VdbeAddOp3 ( v , OP_NotExists , iCur , addrNxt , iRowidReg ) ; 
line 89432: sqlite3ExprCacheStore ( pParse , iCur , - 1 , iRowidReg ) ; 
line 89433: VdbeComment ( ( v , "pk" ) ) ; 
line 89434: pLevel -> op = OP_Noop ; 
line 89435: } else if ( pLevel -> plan . wsFlags & WHERE_ROWID_RANGE ) { 
line 89438: int testOp = OP_Noop ; 
line 89439: int start ; 
line 89440: int memEndValue = 0 ; 
line 89441: WhereTerm * pStart , * pEnd ; 
line 89443: assert ( omitTable == 0 ) ; 
line 89444: pStart = findTerm ( pWC , iCur , - 1 , notReady , WO_GT | WO_GE , 0 ) ; 
line 89445: pEnd = findTerm ( pWC , iCur , - 1 , notReady , WO_LT | WO_LE , 0 ) ; 
line 89446: if ( bRev ) { 
line 89447: pTerm = pStart ; 
line 89448: pStart = pEnd ; 
line 89449: pEnd = pTerm ; 
line 89450: } 
line 89451: if ( pStart ) { 
line 89452: Expr * pX ; 
line 89453: int r1 , rTemp ; 
line 89458: const u8 aMoveOp [ ] = { 
line 89459: OP_SeekGt , 
line 89460: OP_SeekLe , 
line 89461: OP_SeekLt , 
line 89462: OP_SeekGe 
line 89463: } ; 
line 89464: assert ( TK_LE == TK_GT + 1 ) ; 
line 89465: assert ( TK_LT == TK_GT + 2 ) ; 
line 89466: assert ( TK_GE == TK_GT + 3 ) ; 
line 89468: pX = pStart -> pExpr ; 
line 89469: assert ( pX != 0 ) ; 
line 89470: assert ( pStart -> leftCursor == iCur ) ; 
line 89471: r1 = sqlite3ExprCodeTemp ( pParse , pX -> pRight , & rTemp ) ; 
line 89472: sqlite3VdbeAddOp3 ( v , aMoveOp [ pX -> op - TK_GT ] , iCur , addrBrk , r1 ) ; 
line 89473: VdbeComment ( ( v , "pk" ) ) ; 
line 89474: sqlite3ExprCacheAffinityChange ( pParse , r1 , 1 ) ; 
line 89475: sqlite3ReleaseTempReg ( pParse , rTemp ) ; 
line 89476: disableTerm ( pLevel , pStart ) ; 
line 89477: } else { 
line 89478: sqlite3VdbeAddOp2 ( v , bRev ? OP_Last : OP_Rewind , iCur , addrBrk ) ; 
line 89479: } 
line 89480: if ( pEnd ) { 
line 89481: Expr * pX ; 
line 89482: pX = pEnd -> pExpr ; 
line 89483: assert ( pX != 0 ) ; 
line 89484: assert ( pEnd -> leftCursor == iCur ) ; 
line 89485: memEndValue = ++ pParse -> nMem ; 
line 89486: sqlite3ExprCode ( pParse , pX -> pRight , memEndValue ) ; 
line 89487: if ( pX -> op == TK_LT || pX -> op == TK_GT ) { 
line 89488: testOp = bRev ? OP_Le : OP_Ge ; 
line 89489: } else { 
line 89490: testOp = bRev ? OP_Lt : OP_Gt ; 
line 89491: } 
line 89492: disableTerm ( pLevel , pEnd ) ; 
line 89493: } 
line 89494: start = sqlite3VdbeCurrentAddr ( v ) ; 
line 89495: pLevel -> op = bRev ? OP_Prev : OP_Next ; 
line 89496: pLevel -> p1 = iCur ; 
line 89497: pLevel -> p2 = start ; 
line 89498: pLevel -> p5 = ( pStart == 0 && pEnd == 0 ) ? 1 : 0 ; 
line 89499: if ( testOp != OP_Noop ) { 
line 89500: iRowidReg = iReleaseReg = sqlite3GetTempReg ( pParse ) ; 
line 89501: sqlite3VdbeAddOp2 ( v , OP_Rowid , iCur , iRowidReg ) ; 
line 89502: sqlite3ExprCacheStore ( pParse , iCur , - 1 , iRowidReg ) ; 
line 89503: sqlite3VdbeAddOp3 ( v , testOp , memEndValue , addrBrk , iRowidReg ) ; 
line 89504: sqlite3VdbeChangeP5 ( v , SQLITE_AFF_NUMERIC | SQLITE_JUMPIFNULL ) ; 
line 89505: } 
line 89506: } else if ( pLevel -> plan . wsFlags & ( WHERE_COLUMN_RANGE | WHERE_COLUMN_EQ ) ) { 
line 89538: int aStartOp [ ] = { 
line 89539: 0 , 
line 89540: 0 , 
line 89541: OP_Rewind , 
line 89542: OP_Last , 
line 89543: OP_SeekGt , 
line 89544: OP_SeekLt , 
line 89545: OP_SeekGe , 
line 89546: OP_SeekLe 
line 89547: } ; 
line 89548: int aEndOp [ ] = { 
line 89549: OP_Noop , 
line 89550: OP_IdxGE , 
line 89551: OP_IdxLT 
line 89552: } ; 
line 89553: int nEq = pLevel -> plan . nEq ; 
line 89554: int isMinQuery = 0 ; 
line 89555: int regBase ; 
line 89556: int r1 ; 
line 89557: WhereTerm * pRangeStart = 0 ; 
line 89558: WhereTerm * pRangeEnd = 0 ; 
line 89559: int startEq ; 
line 89560: int endEq ; 
line 89561: int start_constraints ; 
line 89562: int nConstraint ; 
line 89563: Index * pIdx ; 
line 89564: int iIdxCur ; 
line 89565: int nExtraReg = 0 ; 
line 89566: int op ; 
line 89567: char * zAff ; 
line 89569: pIdx = pLevel -> plan . u . pIdx ; 
line 89570: iIdxCur = pLevel -> iIdxCur ; 
line 89571: k = pIdx -> aiColumn [ nEq ] ; 
line 89581: if ( ( wctrlFlags & WHERE_ORDERBY_MIN ) != 0 
line 89582: && ( pLevel -> plan . wsFlags & WHERE_ORDERBY ) 
line 89583: && ( pIdx -> nColumn > nEq ) 
line 89584: ) { 
line 89587: isMinQuery = 1 ; 
line 89588: nExtraReg = 1 ; 
line 89589: } 
line 89594: if ( pLevel -> plan . wsFlags & WHERE_TOP_LIMIT ) { 
line 89595: pRangeEnd = findTerm ( pWC , iCur , k , notReady , ( WO_LT | WO_LE ) , pIdx ) ; 
line 89596: nExtraReg = 1 ; 
line 89597: } 
line 89598: if ( pLevel -> plan . wsFlags & WHERE_BTM_LIMIT ) { 
line 89599: pRangeStart = findTerm ( pWC , iCur , k , notReady , ( WO_GT | WO_GE ) , pIdx ) ; 
line 89600: nExtraReg = 1 ; 
line 89601: } 
line 89607: regBase = codeAllEqualityTerms ( 
line 89608: pParse , pLevel , pWC , notReady , nExtraReg , & zAff 
line 89609: ) ; 
line 89610: addrNxt = pLevel -> addrNxt ; 
line 89616: if ( bRev == ( pIdx -> aSortOrder [ nEq ] == SQLITE_SO_ASC ) ) { 
line 89617: SWAP ( WhereTerm * , pRangeEnd , pRangeStart ) ; 
line 89618: } 
line 89620: testcase ( pRangeStart && pRangeStart -> eOperator & WO_LE ) ; 
line 89621: testcase ( pRangeStart && pRangeStart -> eOperator & WO_GE ) ; 
line 89622: testcase ( pRangeEnd && pRangeEnd -> eOperator & WO_LE ) ; 
line 89623: testcase ( pRangeEnd && pRangeEnd -> eOperator & WO_GE ) ; 
line 89624: startEq = ! pRangeStart || pRangeStart -> eOperator & ( WO_LE | WO_GE ) ; 
line 89625: endEq = ! pRangeEnd || pRangeEnd -> eOperator & ( WO_LE | WO_GE ) ; 
line 89626: start_constraints = pRangeStart || nEq > 0 ; 
line 89629: nConstraint = nEq ; 
line 89630: if ( pRangeStart ) { 
line 89631: Expr * pRight = pRangeStart -> pExpr -> pRight ; 
line 89632: sqlite3ExprCode ( pParse , pRight , regBase + nEq ) ; 
line 89633: sqlite3ExprCodeIsNullJump ( v , pRight , regBase + nEq , addrNxt ) ; 
line 89634: if ( zAff ) { 
line 89635: if ( sqlite3CompareAffinity ( pRight , zAff [ nConstraint ] ) == SQLITE_AFF_NONE ) { 
line 89639: zAff [ nConstraint ] = SQLITE_AFF_NONE ; 
line 89640: } 
line 89641: if ( sqlite3ExprNeedsNoAffinityChange ( pRight , zAff [ nConstraint ] ) ) { 
line 89642: zAff [ nConstraint ] = SQLITE_AFF_NONE ; 
line 89643: } 
line 89644: } 
line 89645: nConstraint ++ ; 
line 89646: } else if ( isMinQuery ) { 
line 89647: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , regBase + nEq ) ; 
line 89648: nConstraint ++ ; 
line 89649: startEq = 0 ; 
line 89650: start_constraints = 1 ; 
line 89651: } 
line 89652: codeApplyAffinity ( pParse , regBase , nConstraint , zAff ) ; 
line 89653: op = aStartOp [ ( start_constraints << 2 ) + ( startEq << 1 ) + bRev ] ; 
line 89654: assert ( op != 0 ) ; 
line 89655: testcase ( op == OP_Rewind ) ; 
line 89656: testcase ( op == OP_Last ) ; 
line 89657: testcase ( op == OP_SeekGt ) ; 
line 89658: testcase ( op == OP_SeekGe ) ; 
line 89659: testcase ( op == OP_SeekLe ) ; 
line 89660: testcase ( op == OP_SeekLt ) ; 
line 89661: sqlite3VdbeAddOp4Int ( v , op , iIdxCur , addrNxt , regBase , nConstraint ) ; 
line 89666: nConstraint = nEq ; 
line 89667: if ( pRangeEnd ) { 
line 89668: Expr * pRight = pRangeEnd -> pExpr -> pRight ; 
line 89669: sqlite3ExprCacheRemove ( pParse , regBase + nEq , 1 ) ; 
line 89670: sqlite3ExprCode ( pParse , pRight , regBase + nEq ) ; 
line 89671: sqlite3ExprCodeIsNullJump ( v , pRight , regBase + nEq , addrNxt ) ; 
line 89672: if ( zAff ) { 
line 89673: if ( sqlite3CompareAffinity ( pRight , zAff [ nConstraint ] ) == SQLITE_AFF_NONE ) { 
line 89677: zAff [ nConstraint ] = SQLITE_AFF_NONE ; 
line 89678: } 
line 89679: if ( sqlite3ExprNeedsNoAffinityChange ( pRight , zAff [ nConstraint ] ) ) { 
line 89680: zAff [ nConstraint ] = SQLITE_AFF_NONE ; 
line 89681: } 
line 89682: } 
line 89683: codeApplyAffinity ( pParse , regBase , nEq + 1 , zAff ) ; 
line 89684: nConstraint ++ ; 
line 89685: } 
line 89686: sqlite3DbFree ( pParse -> db , zAff ) ; 
line 89689: pLevel -> p2 = sqlite3VdbeCurrentAddr ( v ) ; 
line 89692: op = aEndOp [ ( pRangeEnd || nEq ) * ( 1 + bRev ) ] ; 
line 89693: testcase ( op == OP_Noop ) ; 
line 89694: testcase ( op == OP_IdxGE ) ; 
line 89695: testcase ( op == OP_IdxLT ) ; 
line 89696: if ( op != OP_Noop ) { 
line 89697: sqlite3VdbeAddOp4Int ( v , op , iIdxCur , addrNxt , regBase , nConstraint ) ; 
line 89698: sqlite3VdbeChangeP5 ( v , endEq != bRev ? 1 : 0 ) ; 
line 89699: } 
line 89705: r1 = sqlite3GetTempReg ( pParse ) ; 
line 89706: testcase ( pLevel -> plan . wsFlags & WHERE_BTM_LIMIT ) ; 
line 89707: testcase ( pLevel -> plan . wsFlags & WHERE_TOP_LIMIT ) ; 
line 89708: if ( pLevel -> plan . wsFlags & ( WHERE_BTM_LIMIT | WHERE_TOP_LIMIT ) ) { 
line 89709: sqlite3VdbeAddOp3 ( v , OP_Column , iIdxCur , nEq , r1 ) ; 
line 89710: sqlite3VdbeAddOp2 ( v , OP_IsNull , r1 , addrCont ) ; 
line 89711: } 
line 89712: sqlite3ReleaseTempReg ( pParse , r1 ) ; 
line 89715: disableTerm ( pLevel , pRangeStart ) ; 
line 89716: disableTerm ( pLevel , pRangeEnd ) ; 
line 89717: if ( ! omitTable ) { 
line 89718: iRowidReg = iReleaseReg = sqlite3GetTempReg ( pParse ) ; 
line 89719: sqlite3VdbeAddOp2 ( v , OP_IdxRowid , iIdxCur , iRowidReg ) ; 
line 89720: sqlite3ExprCacheStore ( pParse , iCur , - 1 , iRowidReg ) ; 
line 89721: sqlite3VdbeAddOp2 ( v , OP_Seek , iCur , iRowidReg ) ; 
line 89722: } 
line 89727: pLevel -> op = bRev ? OP_Prev : OP_Next ; 
line 89728: pLevel -> p1 = iIdxCur ; 
line 89729: } else 
line 89731: # ifndef SQLITE_OMIT_OR_OPTIMIZATION 
line 89732: if ( pLevel -> plan . wsFlags & WHERE_MULTI_OR ) { 
line 89772: WhereClause * pOrWc ; 
line 89773: WhereTerm * pFinal ; 
line 89774: SrcList * pOrTab ; 
line 89776: int regReturn = ++ pParse -> nMem ; 
line 89777: int regRowset = 0 ; 
line 89778: int regRowid = 0 ; 
line 89779: int iLoopBody = sqlite3VdbeMakeLabel ( v ) ; 
line 89780: int iRetInit ; 
line 89781: int untestedTerms = 0 ; 
line 89782: int ii ; 
line 89784: pTerm = pLevel -> plan . u . pTerm ; 
line 89785: assert ( pTerm != 0 ) ; 
line 89786: assert ( pTerm -> eOperator == WO_OR ) ; 
line 89787: assert ( ( pTerm -> wtFlags & TERM_ORINFO ) != 0 ) ; 
line 89788: pOrWc = & pTerm -> u . pOrInfo -> wc ; 
line 89789: pFinal = & pOrWc -> a [ pOrWc -> nTerm - 1 ] ; 
line 89790: pLevel -> op = OP_Return ; 
line 89791: pLevel -> p1 = regReturn ; 
line 89797: if ( pWInfo -> nLevel > 1 ) { 
line 89798: int nNotReady ; 
line 89799: struct SrcList_item * origSrc ; 
line 89800: nNotReady = pWInfo -> nLevel - iLevel - 1 ; 
line 89801: pOrTab = sqlite3StackAllocRaw ( pParse -> db , 
line 89802: sizeof ( * pOrTab ) + nNotReady * sizeof ( pOrTab -> a [ 0 ] ) ) ; 
line 89803: if ( pOrTab == 0 ) return notReady ; 
line 89804: pOrTab -> nAlloc = ( i16 ) ( nNotReady + 1 ) ; 
line 89805: pOrTab -> nSrc = pOrTab -> nAlloc ; 
line 89806: memcpy ( pOrTab -> a , pTabItem , sizeof ( * pTabItem ) ) ; 
line 89807: origSrc = pWInfo -> pTabList -> a ; 
line 89808: for ( k = 1 ; k <= nNotReady ; k ++ ) { 
line 89809: memcpy ( & pOrTab -> a [ k ] , & origSrc [ pLevel [ k ] . iFrom ] , sizeof ( pOrTab -> a [ k ] ) ) ; 
line 89810: } 
line 89811: } else { 
line 89812: pOrTab = pWInfo -> pTabList ; 
line 89813: } 
line 89826: if ( ( wctrlFlags & WHERE_DUPLICATES_OK ) == 0 ) { 
line 89827: regRowset = ++ pParse -> nMem ; 
line 89828: regRowid = ++ pParse -> nMem ; 
line 89829: sqlite3VdbeAddOp2 ( v , OP_Null , 0 , regRowset ) ; 
line 89830: } 
line 89831: iRetInit = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regReturn ) ; 
line 89833: for ( ii = 0 ; ii < pOrWc -> nTerm ; ii ++ ) { 
line 89834: WhereTerm * pOrTerm = & pOrWc -> a [ ii ] ; 
line 89835: if ( pOrTerm -> leftCursor == iCur || pOrTerm -> eOperator == WO_AND ) { 
line 89836: WhereInfo * pSubWInfo ; 
line 89838: pSubWInfo = sqlite3WhereBegin ( pParse , pOrTab , pOrTerm -> pExpr , 0 , 
line 89839: WHERE_OMIT_OPEN | WHERE_OMIT_CLOSE | 
line 89840: WHERE_FORCE_TABLE | WHERE_ONETABLE_ONLY ) ; 
line 89841: if ( pSubWInfo ) { 
line 89842: if ( ( wctrlFlags & WHERE_DUPLICATES_OK ) == 0 ) { 
line 89843: int iSet = ( ( ii == pOrWc -> nTerm - 1 ) ? - 1 : ii ) ; 
line 89844: int r ; 
line 89845: r = sqlite3ExprCodeGetColumn ( pParse , pTabItem -> pTab , - 1 , iCur , 
line 89846: regRowid ) ; 
line 89847: sqlite3VdbeAddOp4Int ( v , OP_RowSetTest , regRowset , 
line 89848: sqlite3VdbeCurrentAddr ( v ) + 2 , r , iSet ) ; 
line 89849: } 
line 89850: sqlite3VdbeAddOp2 ( v , OP_Gosub , regReturn , iLoopBody ) ; 
line 89857: if ( pSubWInfo -> untestedTerms ) untestedTerms = 1 ; 
line 89860: sqlite3WhereEnd ( pSubWInfo ) ; 
line 89861: } 
line 89862: } 
line 89863: } 
line 89864: sqlite3VdbeChangeP1 ( v , iRetInit , sqlite3VdbeCurrentAddr ( v ) ) ; 
line 89865: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , pLevel -> addrBrk ) ; 
line 89866: sqlite3VdbeResolveLabel ( v , iLoopBody ) ; 
line 89868: if ( pWInfo -> nLevel > 1 ) sqlite3StackFree ( pParse -> db , pOrTab ) ; 
line 89869: if ( ! untestedTerms ) disableTerm ( pLevel , pTerm ) ; 
line 89870: } else 
line 89871: # endif 
line 89873: { 
line 89877: static const u8 aStep [ ] = { OP_Next , OP_Prev } ; 
line 89878: static const u8 aStart [ ] = { OP_Rewind , OP_Last } ; 
line 89879: assert ( bRev == 0 || bRev == 1 ) ; 
line 89880: assert ( omitTable == 0 ) ; 
line 89881: pLevel -> op = aStep [ bRev ] ; 
line 89882: pLevel -> p1 = iCur ; 
line 89883: pLevel -> p2 = 1 + sqlite3VdbeAddOp2 ( v , aStart [ bRev ] , iCur , addrBrk ) ; 
line 89884: pLevel -> p5 = SQLITE_STMTSTATUS_FULLSCAN_STEP ; 
line 89885: } 
line 89886: notReady &= ~ getMask ( pWC -> pMaskSet , iCur ) ; 
line 89891: k = 0 ; 
line 89892: for ( pTerm = pWC -> a , j = pWC -> nTerm ; j > 0 ; j -- , pTerm ++ ) { 
line 89893: Expr * pE ; 
line 89894: testcase ( pTerm -> wtFlags & TERM_VIRTUAL ) ; 
line 89895: testcase ( pTerm -> wtFlags & TERM_CODED ) ; 
line 89896: if ( pTerm -> wtFlags & ( TERM_VIRTUAL | TERM_CODED ) ) continue ; 
line 89897: if ( ( pTerm -> prereqAll & notReady ) != 0 ) { 
line 89898: testcase ( pWInfo -> untestedTerms == 0 
line 89899: && ( pWInfo -> wctrlFlags & WHERE_ONETABLE_ONLY ) != 0 ) ; 
line 89900: pWInfo -> untestedTerms = 1 ; 
line 89901: continue ; 
line 89902: } 
line 89903: pE = pTerm -> pExpr ; 
line 89904: assert ( pE != 0 ) ; 
line 89905: if ( pLevel -> iLeftJoin && ! ExprHasProperty ( pE , EP_FromJoin ) ) { 
line 89906: continue ; 
line 89907: } 
line 89908: sqlite3ExprIfFalse ( pParse , pE , addrCont , SQLITE_JUMPIFNULL ) ; 
line 89909: k = 1 ; 
line 89910: pTerm -> wtFlags |= TERM_CODED ; 
line 89911: } 
line 89916: if ( pLevel -> iLeftJoin ) { 
line 89917: pLevel -> addrFirst = sqlite3VdbeCurrentAddr ( v ) ; 
line 89918: sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , pLevel -> iLeftJoin ) ; 
line 89919: VdbeComment ( ( v , "record LEFT JOIN hit" ) ) ; 
line 89920: sqlite3ExprCacheClear ( pParse ) ; 
line 89921: for ( pTerm = pWC -> a , j = 0 ; j < pWC -> nTerm ; j ++ , pTerm ++ ) { 
line 89922: testcase ( pTerm -> wtFlags & TERM_VIRTUAL ) ; 
line 89923: testcase ( pTerm -> wtFlags & TERM_CODED ) ; 
line 89924: if ( pTerm -> wtFlags & ( TERM_VIRTUAL | TERM_CODED ) ) continue ; 
line 89925: if ( ( pTerm -> prereqAll & notReady ) != 0 ) { 
line 89926: assert ( pWInfo -> untestedTerms ) ; 
line 89927: continue ; 
line 89928: } 
line 89929: assert ( pTerm -> pExpr ) ; 
line 89930: sqlite3ExprIfFalse ( pParse , pTerm -> pExpr , addrCont , SQLITE_JUMPIFNULL ) ; 
line 89931: pTerm -> wtFlags |= TERM_CODED ; 
line 89932: } 
line 89933: } 
line 89934: sqlite3ReleaseTempReg ( pParse , iReleaseReg ) ; 
line 89936: return notReady ; 
line 89937: } 
line 89939: # if defined ( SQLITE_TEST ) 
line 89946: SQLITE_API char sqlite3_query_plan [ BMS * 2 * 40 ] ; 
line 89947: static int nQPlan = 0 ; 
line 89949: # endif 
line 89955: static void whereInfoFree ( sqlite3 * db , WhereInfo * pWInfo ) { 
line 89956: if ( pWInfo ) { 
line 89957: int i ; 
line 89958: for ( i = 0 ; i < pWInfo -> nLevel ; i ++ ) { 
line 89959: sqlite3_index_info * pInfo = pWInfo -> a [ i ] . pIdxInfo ; 
line 89960: if ( pInfo ) { 
line 89962: if ( pInfo -> needToFreeIdxStr ) { 
line 89963: sqlite3_free ( pInfo -> idxStr ) ; 
line 89964: } 
line 89965: sqlite3DbFree ( db , pInfo ) ; 
line 89966: } 
line 89967: } 
line 89968: whereClauseClear ( pWInfo -> pWC ) ; 
line 89969: sqlite3DbFree ( db , pWInfo ) ; 
line 89970: } 
line 89971: } 
line 90062: SQLITE_PRIVATE WhereInfo * sqlite3WhereBegin ( 
line 90063: Parse * pParse , 
line 90064: SrcList * pTabList , 
line 90065: Expr * pWhere , 
line 90066: ExprList * * ppOrderBy , 
line 90067: u16 wctrlFlags 
line 90068: ) { 
line 90069: int i ; 
line 90070: int nByteWInfo ; 
line 90071: int nTabList ; 
line 90072: WhereInfo * pWInfo ; 
line 90073: Vdbe * v = pParse -> pVdbe ; 
line 90074: Bitmask notReady ; 
line 90075: WhereMaskSet * pMaskSet ; 
line 90076: WhereClause * pWC ; 
line 90077: struct SrcList_item * pTabItem ; 
line 90078: WhereLevel * pLevel ; 
line 90079: int iFrom ; 
line 90080: int andFlags ; 
line 90081: sqlite3 * db ; 
line 90086: if ( pTabList -> nSrc > BMS ) { 
line 90087: sqlite3ErrorMsg ( pParse , "at most %d tables in a join" , BMS ) ; 
line 90088: return 0 ; 
line 90089: } 
line 90096: nTabList = ( wctrlFlags & WHERE_ONETABLE_ONLY ) ? 1 : pTabList -> nSrc ; 
line 90105: db = pParse -> db ; 
line 90106: nByteWInfo = ROUND8 ( sizeof ( WhereInfo ) + ( nTabList - 1 ) * sizeof ( WhereLevel ) ) ; 
line 90107: pWInfo = sqlite3DbMallocZero ( db , 
line 90108: nByteWInfo + 
line 90109: sizeof ( WhereClause ) + 
line 90110: sizeof ( WhereMaskSet ) 
line 90111: ) ; 
line 90112: if ( db -> mallocFailed ) { 
line 90113: goto whereBeginError ; 
line 90114: } 
line 90115: pWInfo -> nLevel = nTabList ; 
line 90116: pWInfo -> pParse = pParse ; 
line 90117: pWInfo -> pTabList = pTabList ; 
line 90118: pWInfo -> iBreak = sqlite3VdbeMakeLabel ( v ) ; 
line 90119: pWInfo -> pWC = pWC = ( WhereClause * ) & ( ( u8 * ) pWInfo ) [ nByteWInfo ] ; 
line 90120: pWInfo -> wctrlFlags = wctrlFlags ; 
line 90121: pMaskSet = ( WhereMaskSet * ) & pWC [ 1 ] ; 
line 90126: initMaskSet ( pMaskSet ) ; 
line 90127: whereClauseInit ( pWC , pParse , pMaskSet ) ; 
line 90128: sqlite3ExprCodeConstants ( pParse , pWhere ) ; 
line 90129: whereSplit ( pWC , pWhere , TK_AND ) ; 
line 90134: if ( pWhere && ( nTabList == 0 || sqlite3ExprIsConstantNotJoin ( pWhere ) ) ) { 
line 90135: sqlite3ExprIfFalse ( pParse , pWhere , pWInfo -> iBreak , SQLITE_JUMPIFNULL ) ; 
line 90136: pWhere = 0 ; 
line 90137: } 
line 90160: assert ( pWC -> vmask == 0 && pMaskSet -> n == 0 ) ; 
line 90161: for ( i = 0 ; i < pTabList -> nSrc ; i ++ ) { 
line 90162: createMask ( pMaskSet , pTabList -> a [ i ] . iCursor ) ; 
line 90163: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 90164: if ( ALWAYS ( pTabList -> a [ i ] . pTab ) && IsVirtual ( pTabList -> a [ i ] . pTab ) ) { 
line 90165: pWC -> vmask |= ( ( Bitmask ) 1 << i ) ; 
line 90166: } 
line 90167: # endif 
line 90168: } 
line 90169: # ifndef NDEBUG 
line 90170: { 
line 90171: Bitmask toTheLeft = 0 ; 
line 90172: for ( i = 0 ; i < pTabList -> nSrc ; i ++ ) { 
line 90173: Bitmask m = getMask ( pMaskSet , pTabList -> a [ i ] . iCursor ) ; 
line 90174: assert ( ( m - 1 ) == toTheLeft ) ; 
line 90175: toTheLeft |= m ; 
line 90176: } 
line 90177: } 
line 90178: # endif 
line 90185: exprAnalyzeAll ( pTabList , pWC ) ; 
line 90186: if ( db -> mallocFailed ) { 
line 90187: goto whereBeginError ; 
line 90188: } 
line 90205: notReady = ~ ( Bitmask ) 0 ; 
line 90206: pTabItem = pTabList -> a ; 
line 90207: pLevel = pWInfo -> a ; 
line 90208: andFlags = ~ 0 ; 
line 90209: WHERETRACE ( ( "*** Optimizer Start ***\n" ) ) ; 
line 90210: for ( i = iFrom = 0 , pLevel = pWInfo -> a ; i < nTabList ; i ++ , pLevel ++ ) { 
line 90211: WhereCost bestPlan ; 
line 90212: Index * pIdx ; 
line 90213: int j ; 
line 90214: int bestJ = - 1 ; 
line 90215: Bitmask m ; 
line 90216: int isOptimal ; 
line 90218: memset ( & bestPlan , 0 , sizeof ( bestPlan ) ) ; 
line 90219: bestPlan . rCost = SQLITE_BIG_DBL ; 
line 90253: for ( isOptimal = 1 ; isOptimal >= 0 && bestJ < 0 ; isOptimal -- ) { 
line 90254: Bitmask mask = ( isOptimal ? 0 : notReady ) ; 
line 90255: assert ( ( nTabList - iFrom ) > 1 || isOptimal ) ; 
line 90256: for ( j = iFrom , pTabItem = & pTabList -> a [ j ] ; j < nTabList ; j ++ , pTabItem ++ ) { 
line 90257: int doNotReorder ; 
line 90258: WhereCost sCost ; 
line 90259: ExprList * pOrderBy ; 
line 90261: doNotReorder = ( pTabItem -> jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ; 
line 90262: if ( j != iFrom && doNotReorder ) break ; 
line 90263: m = getMask ( pMaskSet , pTabItem -> iCursor ) ; 
line 90264: if ( ( m & notReady ) == 0 ) { 
line 90265: if ( j == iFrom ) iFrom ++ ; 
line 90266: continue ; 
line 90267: } 
line 90268: pOrderBy = ( ( i == 0 && ppOrderBy ) ? * ppOrderBy : 0 ) ; 
line 90270: assert ( pTabItem -> pTab ) ; 
line 90271: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 90272: if ( IsVirtual ( pTabItem -> pTab ) ) { 
line 90273: sqlite3_index_info * * pp = & pWInfo -> a [ j ] . pIdxInfo ; 
line 90274: bestVirtualIndex ( pParse , pWC , pTabItem , mask , pOrderBy , & sCost , pp ) ; 
line 90275: } else 
line 90276: # endif 
line 90277: { 
line 90278: bestBtreeIndex ( pParse , pWC , pTabItem , mask , pOrderBy , & sCost ) ; 
line 90279: } 
line 90280: assert ( isOptimal || ( sCost . used & notReady ) == 0 ) ; 
line 90282: if ( ( sCost . used & notReady ) == 0 
line 90283: && ( j == iFrom || sCost . rCost < bestPlan . rCost ) 
line 90284: ) { 
line 90285: bestPlan = sCost ; 
line 90286: bestJ = j ; 
line 90287: } 
line 90288: if ( doNotReorder ) break ; 
line 90289: } 
line 90290: } 
line 90291: assert ( bestJ >= 0 ) ; 
line 90292: assert ( notReady & getMask ( pMaskSet , pTabList -> a [ bestJ ] . iCursor ) ) ; 
line 90293: WHERETRACE ( ( "*** Optimizer selects table %d for loop %d\n" , bestJ , 
line 90294: pLevel - pWInfo -> a ) ) ; 
line 90295: if ( ( bestPlan . plan . wsFlags & WHERE_ORDERBY ) != 0 ) { 
line 90296: * ppOrderBy = 0 ; 
line 90297: } 
line 90298: andFlags &= bestPlan . plan . wsFlags ; 
line 90299: pLevel -> plan = bestPlan . plan ; 
line 90300: if ( bestPlan . plan . wsFlags & WHERE_INDEXED ) { 
line 90301: pLevel -> iIdxCur = pParse -> nTab ++ ; 
line 90302: } else { 
line 90303: pLevel -> iIdxCur = - 1 ; 
line 90304: } 
line 90305: notReady &= ~ getMask ( pMaskSet , pTabList -> a [ bestJ ] . iCursor ) ; 
line 90306: pLevel -> iFrom = ( u8 ) bestJ ; 
line 90313: pIdx = pTabList -> a [ bestJ ] . pIndex ; 
line 90314: if ( pIdx ) { 
line 90315: if ( ( bestPlan . plan . wsFlags & WHERE_INDEXED ) == 0 ) { 
line 90316: sqlite3ErrorMsg ( pParse , "cannot use index: %s" , pIdx -> zName ) ; 
line 90317: goto whereBeginError ; 
line 90318: } else { 
line 90322: assert ( bestPlan . plan . u . pIdx == pIdx ) ; 
line 90323: } 
line 90324: } 
line 90325: } 
line 90326: WHERETRACE ( ( "*** Optimizer Finished ***\n" ) ) ; 
line 90327: if ( pParse -> nErr || db -> mallocFailed ) { 
line 90328: goto whereBeginError ; 
line 90329: } 
line 90334: if ( ( andFlags & WHERE_UNIQUE ) != 0 && ppOrderBy ) { 
line 90335: * ppOrderBy = 0 ; 
line 90336: } 
line 90343: assert ( ( wctrlFlags & WHERE_ONEPASS_DESIRED ) == 0 || pWInfo -> nLevel == 1 ) ; 
line 90344: if ( ( wctrlFlags & WHERE_ONEPASS_DESIRED ) != 0 && ( andFlags & WHERE_UNIQUE ) != 0 ) { 
line 90345: pWInfo -> okOnePass = 1 ; 
line 90346: pWInfo -> a [ 0 ] . plan . wsFlags &= ~ WHERE_IDX_ONLY ; 
line 90347: } 
line 90352: sqlite3CodeVerifySchema ( pParse , - 1 ) ; 
line 90353: for ( i = 0 , pLevel = pWInfo -> a ; i < nTabList ; i ++ , pLevel ++ ) { 
line 90354: Table * pTab ; 
line 90355: int iDb ; 
line 90357: # ifndef SQLITE_OMIT_EXPLAIN 
line 90358: if ( pParse -> explain == 2 ) { 
line 90359: char * zMsg ; 
line 90360: struct SrcList_item * pItem = & pTabList -> a [ pLevel -> iFrom ] ; 
line 90361: zMsg = sqlite3MPrintf ( db , "TABLE %s" , pItem -> zName ) ; 
line 90362: if ( pItem -> zAlias ) { 
line 90363: zMsg = sqlite3MAppendf ( db , zMsg , "%s AS %s" , zMsg , pItem -> zAlias ) ; 
line 90364: } 
line 90365: if ( ( pLevel -> plan . wsFlags & WHERE_INDEXED ) != 0 ) { 
line 90366: zMsg = sqlite3MAppendf ( db , zMsg , "%s WITH INDEX %s" , 
line 90367: zMsg , pLevel -> plan . u . pIdx -> zName ) ; 
line 90368: } else if ( pLevel -> plan . wsFlags & WHERE_MULTI_OR ) { 
line 90369: zMsg = sqlite3MAppendf ( db , zMsg , "%s VIA MULTI-INDEX UNION" , zMsg ) ; 
line 90370: } else if ( pLevel -> plan . wsFlags & ( WHERE_ROWID_EQ | WHERE_ROWID_RANGE ) ) { 
line 90371: zMsg = sqlite3MAppendf ( db , zMsg , "%s USING PRIMARY KEY" , zMsg ) ; 
line 90372: } 
line 90373: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 90374: else if ( ( pLevel -> plan . wsFlags & WHERE_VIRTUALTABLE ) != 0 ) { 
line 90375: sqlite3_index_info * pVtabIdx = pLevel -> plan . u . pVtabIdx ; 
line 90376: zMsg = sqlite3MAppendf ( db , zMsg , "%s VIRTUAL TABLE INDEX %d:%s" , zMsg , 
line 90377: pVtabIdx -> idxNum , pVtabIdx -> idxStr ) ; 
line 90378: } 
line 90379: # endif 
line 90380: if ( pLevel -> plan . wsFlags & WHERE_ORDERBY ) { 
line 90381: zMsg = sqlite3MAppendf ( db , zMsg , "%s ORDER BY" , zMsg ) ; 
line 90382: } 
line 90383: sqlite3VdbeAddOp4 ( v , OP_Explain , i , pLevel -> iFrom , 0 , zMsg , P4_DYNAMIC ) ; 
line 90384: } 
line 90385: # endif 
line 90386: pTabItem = & pTabList -> a [ pLevel -> iFrom ] ; 
line 90387: pTab = pTabItem -> pTab ; 
line 90388: iDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; 
line 90389: if ( ( pTab -> tabFlags & TF_Ephemeral ) != 0 || pTab -> pSelect ) continue ; 
line 90390: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 90391: if ( ( pLevel -> plan . wsFlags & WHERE_VIRTUALTABLE ) != 0 ) { 
line 90392: const char * pVTab = ( const char * ) sqlite3GetVTable ( db , pTab ) ; 
line 90393: int iCur = pTabItem -> iCursor ; 
line 90394: sqlite3VdbeAddOp4 ( v , OP_VOpen , iCur , 0 , 0 , pVTab , P4_VTAB ) ; 
line 90395: } else 
line 90396: # endif 
line 90397: if ( ( pLevel -> plan . wsFlags & WHERE_IDX_ONLY ) == 0 
line 90398: && ( wctrlFlags & WHERE_OMIT_OPEN ) == 0 ) { 
line 90399: int op = pWInfo -> okOnePass ? OP_OpenWrite : OP_OpenRead ; 
line 90400: sqlite3OpenTable ( pParse , pTabItem -> iCursor , iDb , pTab , op ) ; 
line 90401: if ( ! pWInfo -> okOnePass && pTab -> nCol < BMS ) { 
line 90402: Bitmask b = pTabItem -> colUsed ; 
line 90403: int n = 0 ; 
line 90404: for ( ; b ; b = b >> 1 , n ++ ) { } 
line 90405: sqlite3VdbeChangeP4 ( v , sqlite3VdbeCurrentAddr ( v ) - 1 , 
line 90406: SQLITE_INT_TO_PTR ( n ) , P4_INT32 ) ; 
line 90407: assert ( n <= pTab -> nCol ) ; 
line 90408: } 
line 90409: } else { 
line 90410: sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ) ; 
line 90411: } 
line 90412: pLevel -> iTabCur = pTabItem -> iCursor ; 
line 90413: if ( ( pLevel -> plan . wsFlags & WHERE_INDEXED ) != 0 ) { 
line 90414: Index * pIx = pLevel -> plan . u . pIdx ; 
line 90415: KeyInfo * pKey = sqlite3IndexKeyinfo ( pParse , pIx ) ; 
line 90416: int iIdxCur = pLevel -> iIdxCur ; 
line 90417: assert ( pIx -> pSchema == pTab -> pSchema ) ; 
line 90418: assert ( iIdxCur >= 0 ) ; 
line 90419: sqlite3VdbeAddOp4 ( v , OP_OpenRead , iIdxCur , pIx -> tnum , iDb , 
line 90420: ( char * ) pKey , P4_KEYINFO_HANDOFF ) ; 
line 90421: VdbeComment ( ( v , "%s" , pIx -> zName ) ) ; 
line 90422: } 
line 90423: sqlite3CodeVerifySchema ( pParse , iDb ) ; 
line 90424: } 
line 90425: pWInfo -> iTop = sqlite3VdbeCurrentAddr ( v ) ; 
line 90431: notReady = ~ ( Bitmask ) 0 ; 
line 90432: for ( i = 0 ; i < nTabList ; i ++ ) { 
line 90433: notReady = codeOneLoopStart ( pWInfo , i , wctrlFlags , notReady ) ; 
line 90434: pWInfo -> iContinue = pWInfo -> a [ i ] . addrCont ; 
line 90435: } 
line 90437: # ifdef SQLITE_TEST 
line 90444: for ( i = 0 ; i < nTabList ; i ++ ) { 
line 90445: char * z ; 
line 90446: int n ; 
line 90447: pLevel = & pWInfo -> a [ i ] ; 
line 90448: pTabItem = & pTabList -> a [ pLevel -> iFrom ] ; 
line 90449: z = pTabItem -> zAlias ; 
line 90450: if ( z == 0 ) z = pTabItem -> pTab -> zName ; 
line 90451: n = sqlite3Strlen30 ( z ) ; 
line 90452: if ( n + nQPlan < sizeof ( sqlite3_query_plan ) - 10 ) { 
line 90453: if ( pLevel -> plan . wsFlags & WHERE_IDX_ONLY ) { 
line 90454: memcpy ( & sqlite3_query_plan [ nQPlan ] , "{}" , 2 ) ; 
line 90455: nQPlan += 2 ; 
line 90456: } else { 
line 90457: memcpy ( & sqlite3_query_plan [ nQPlan ] , z , n ) ; 
line 90458: nQPlan += n ; 
line 90459: } 
line 90460: sqlite3_query_plan [ nQPlan ++ ] = ' ' ; 
line 90461: } 
line 90462: testcase ( pLevel -> plan . wsFlags & WHERE_ROWID_EQ ) ; 
line 90463: testcase ( pLevel -> plan . wsFlags & WHERE_ROWID_RANGE ) ; 
line 90464: if ( pLevel -> plan . wsFlags & ( WHERE_ROWID_EQ | WHERE_ROWID_RANGE ) ) { 
line 90465: memcpy ( & sqlite3_query_plan [ nQPlan ] , "* " , 2 ) ; 
line 90466: nQPlan += 2 ; 
line 90467: } else if ( ( pLevel -> plan . wsFlags & WHERE_INDEXED ) != 0 ) { 
line 90468: n = sqlite3Strlen30 ( pLevel -> plan . u . pIdx -> zName ) ; 
line 90469: if ( n + nQPlan < sizeof ( sqlite3_query_plan ) - 2 ) { 
line 90470: memcpy ( & sqlite3_query_plan [ nQPlan ] , pLevel -> plan . u . pIdx -> zName , n ) ; 
line 90471: nQPlan += n ; 
line 90472: sqlite3_query_plan [ nQPlan ++ ] = ' ' ; 
line 90473: } 
line 90474: } else { 
line 90475: memcpy ( & sqlite3_query_plan [ nQPlan ] , "{} " , 3 ) ; 
line 90476: nQPlan += 3 ; 
line 90477: } 
line 90478: } 
line 90479: while ( nQPlan > 0 && sqlite3_query_plan [ nQPlan - 1 ] == ' ' ) { 
line 90480: sqlite3_query_plan [ -- nQPlan ] = 0 ; 
line 90481: } 
line 90482: sqlite3_query_plan [ nQPlan ] = 0 ; 
line 90483: nQPlan = 0 ; 
line 90484: # endif 
line 90489: return pWInfo ; 
line 90492: whereBeginError : 
line 90493: whereInfoFree ( db , pWInfo ) ; 
line 90494: return 0 ; 
line 90495: } 
line 90501: SQLITE_PRIVATE void sqlite3WhereEnd ( WhereInfo * pWInfo ) { 
line 90502: Parse * pParse = pWInfo -> pParse ; 
line 90503: Vdbe * v = pParse -> pVdbe ; 
line 90504: int i ; 
line 90505: WhereLevel * pLevel ; 
line 90506: SrcList * pTabList = pWInfo -> pTabList ; 
line 90507: sqlite3 * db = pParse -> db ; 
line 90511: sqlite3ExprCacheClear ( pParse ) ; 
line 90512: for ( i = pWInfo -> nLevel - 1 ; i >= 0 ; i -- ) { 
line 90513: pLevel = & pWInfo -> a [ i ] ; 
line 90514: sqlite3VdbeResolveLabel ( v , pLevel -> addrCont ) ; 
line 90515: if ( pLevel -> op != OP_Noop ) { 
line 90516: sqlite3VdbeAddOp2 ( v , pLevel -> op , pLevel -> p1 , pLevel -> p2 ) ; 
line 90517: sqlite3VdbeChangeP5 ( v , pLevel -> p5 ) ; 
line 90518: } 
line 90519: if ( pLevel -> plan . wsFlags & WHERE_IN_ABLE && pLevel -> u . in . nIn > 0 ) { 
line 90520: struct InLoop * pIn ; 
line 90521: int j ; 
line 90522: sqlite3VdbeResolveLabel ( v , pLevel -> addrNxt ) ; 
line 90523: for ( j = pLevel -> u . in . nIn , pIn = & pLevel -> u . in . aInLoop [ j - 1 ] ; j > 0 ; j -- , pIn -- ) { 
line 90524: sqlite3VdbeJumpHere ( v , pIn -> addrInTop + 1 ) ; 
line 90525: sqlite3VdbeAddOp2 ( v , OP_Next , pIn -> iCur , pIn -> addrInTop ) ; 
line 90526: sqlite3VdbeJumpHere ( v , pIn -> addrInTop - 1 ) ; 
line 90527: } 
line 90528: sqlite3DbFree ( db , pLevel -> u . in . aInLoop ) ; 
line 90529: } 
line 90530: sqlite3VdbeResolveLabel ( v , pLevel -> addrBrk ) ; 
line 90531: if ( pLevel -> iLeftJoin ) { 
line 90532: int addr ; 
line 90533: addr = sqlite3VdbeAddOp1 ( v , OP_IfPos , pLevel -> iLeftJoin ) ; 
line 90534: assert ( ( pLevel -> plan . wsFlags & WHERE_IDX_ONLY ) == 0 
line 90535: || ( pLevel -> plan . wsFlags & WHERE_INDEXED ) != 0 ) ; 
line 90536: if ( ( pLevel -> plan . wsFlags & WHERE_IDX_ONLY ) == 0 ) { 
line 90537: sqlite3VdbeAddOp1 ( v , OP_NullRow , pTabList -> a [ i ] . iCursor ) ; 
line 90538: } 
line 90539: if ( pLevel -> iIdxCur >= 0 ) { 
line 90540: sqlite3VdbeAddOp1 ( v , OP_NullRow , pLevel -> iIdxCur ) ; 
line 90541: } 
line 90542: if ( pLevel -> op == OP_Return ) { 
line 90543: sqlite3VdbeAddOp2 ( v , OP_Gosub , pLevel -> p1 , pLevel -> addrFirst ) ; 
line 90544: } else { 
line 90545: sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , pLevel -> addrFirst ) ; 
line 90546: } 
line 90547: sqlite3VdbeJumpHere ( v , addr ) ; 
line 90548: } 
line 90549: } 
line 90554: sqlite3VdbeResolveLabel ( v , pWInfo -> iBreak ) ; 
line 90558: assert ( pWInfo -> nLevel == 1 || pWInfo -> nLevel == pTabList -> nSrc ) ; 
line 90559: for ( i = 0 , pLevel = pWInfo -> a ; i < pWInfo -> nLevel ; i ++ , pLevel ++ ) { 
line 90560: struct SrcList_item * pTabItem = & pTabList -> a [ pLevel -> iFrom ] ; 
line 90561: Table * pTab = pTabItem -> pTab ; 
line 90562: assert ( pTab != 0 ) ; 
line 90563: if ( ( pTab -> tabFlags & TF_Ephemeral ) != 0 || pTab -> pSelect ) continue ; 
line 90564: if ( ( pWInfo -> wctrlFlags & WHERE_OMIT_CLOSE ) == 0 ) { 
line 90565: if ( ! pWInfo -> okOnePass && ( pLevel -> plan . wsFlags & WHERE_IDX_ONLY ) == 0 ) { 
line 90566: sqlite3VdbeAddOp1 ( v , OP_Close , pTabItem -> iCursor ) ; 
line 90567: } 
line 90568: if ( ( pLevel -> plan . wsFlags & WHERE_INDEXED ) != 0 ) { 
line 90569: sqlite3VdbeAddOp1 ( v , OP_Close , pLevel -> iIdxCur ) ; 
line 90570: } 
line 90571: } 
line 90586: if ( ( pLevel -> plan . wsFlags & WHERE_INDEXED ) != 0 && ! db -> mallocFailed ) { 
line 90587: int k , j , last ; 
line 90588: VdbeOp * pOp ; 
line 90589: Index * pIdx = pLevel -> plan . u . pIdx ; 
line 90591: assert ( pIdx != 0 ) ; 
line 90592: pOp = sqlite3VdbeGetOp ( v , pWInfo -> iTop ) ; 
line 90593: last = sqlite3VdbeCurrentAddr ( v ) ; 
line 90594: for ( k = pWInfo -> iTop ; k < last ; k ++ , pOp ++ ) { 
line 90595: if ( pOp -> p1 != pLevel -> iTabCur ) continue ; 
line 90596: if ( pOp -> opcode == OP_Column ) { 
line 90597: for ( j = 0 ; j < pIdx -> nColumn ; j ++ ) { 
line 90598: if ( pOp -> p2 == pIdx -> aiColumn [ j ] ) { 
line 90599: pOp -> p2 = j ; 
line 90600: pOp -> p1 = pLevel -> iIdxCur ; 
line 90601: break ; 
line 90602: } 
line 90603: } 
line 90604: assert ( ( pLevel -> plan . wsFlags & WHERE_IDX_ONLY ) == 0 
line 90605: || j < pIdx -> nColumn ) ; 
line 90606: } else if ( pOp -> opcode == OP_Rowid ) { 
line 90607: pOp -> p1 = pLevel -> iIdxCur ; 
line 90608: pOp -> opcode = OP_IdxRowid ; 
line 90609: } 
line 90610: } 
line 90611: } 
line 90612: } 
line 90616: whereInfoFree ( db , pWInfo ) ; 
line 90617: return ; 
line 90618: } 
line 90639: # define YYNOERRORRECOVERY 1 
line 90644: # define yytestcase ( X ) testcase ( X ) 
line 90650: struct LimitVal { 
line 90651: Expr * pLimit ; 
line 90652: Expr * pOffset ; 
line 90653: } ; 
line 90659: struct LikeOp { 
line 90660: Token eOperator ; 
line 90661: int not ; 
line 90662: } ; 
line 90673: struct TrigEvent { int a ; IdList * b ; } ; 
line 90678: struct AttachKey { int type ; Token key ; } ; 
line 90685: static void spanSet ( ExprSpan * pOut , Token * pStart , Token * pEnd ) { 
line 90686: pOut -> zStart = pStart -> z ; 
line 90687: pOut -> zEnd = & pEnd -> z [ pEnd -> n ] ; 
line 90688: } 
line 90694: static void spanExpr ( ExprSpan * pOut , Parse * pParse , int op , Token * pValue ) { 
line 90695: pOut -> pExpr = sqlite3PExpr ( pParse , op , 0 , 0 , pValue ) ; 
line 90696: pOut -> zStart = pValue -> z ; 
line 90697: pOut -> zEnd = & pValue -> z [ pValue -> n ] ; 
line 90698: } 
line 90703: static void spanBinaryExpr ( 
line 90704: ExprSpan * pOut , 
line 90705: Parse * pParse , 
line 90706: int op , 
line 90707: ExprSpan * pLeft , 
line 90708: ExprSpan * pRight 
line 90709: ) { 
line 90710: pOut -> pExpr = sqlite3PExpr ( pParse , op , pLeft -> pExpr , pRight -> pExpr , 0 ) ; 
line 90711: pOut -> zStart = pLeft -> zStart ; 
line 90712: pOut -> zEnd = pRight -> zEnd ; 
line 90713: } 
line 90717: static void spanUnaryPostfix ( 
line 90718: ExprSpan * pOut , 
line 90719: Parse * pParse , 
line 90720: int op , 
line 90721: ExprSpan * pOperand , 
line 90722: Token * pPostOp 
line 90723: ) { 
line 90724: pOut -> pExpr = sqlite3PExpr ( pParse , op , pOperand -> pExpr , 0 , 0 ) ; 
line 90725: pOut -> zStart = pOperand -> zStart ; 
line 90726: pOut -> zEnd = & pPostOp -> z [ pPostOp -> n ] ; 
line 90727: } 
line 90731: static void binaryToUnaryIfNull ( Parse * pParse , Expr * pY , Expr * pA , int op ) { 
line 90732: sqlite3 * db = pParse -> db ; 
line 90733: if ( db -> mallocFailed == 0 && pY -> op == TK_NULL ) { 
line 90734: pA -> op = ( u8 ) op ; 
line 90735: sqlite3ExprDelete ( db , pA -> pRight ) ; 
line 90736: pA -> pRight = 0 ; 
line 90737: } 
line 90738: } 
line 90742: static void spanUnaryPrefix ( 
line 90743: ExprSpan * pOut , 
line 90744: Parse * pParse , 
line 90745: int op , 
line 90746: ExprSpan * pOperand , 
line 90747: Token * pPreOp 
line 90748: ) { 
line 90749: pOut -> pExpr = sqlite3PExpr ( pParse , op , pOperand -> pExpr , 0 , 0 ) ; 
line 90750: pOut -> zStart = pPreOp -> z ; 
line 90751: pOut -> zEnd = pOperand -> zEnd ; 
line 90752: } 
line 90765: # ifndef INTERFACE 
line 90766: # define INTERFACE 1 
line 90767: # endif 
line 90802: # define YYCODETYPE unsigned char 
line 90803: # define YYNOCODE 254 
line 90804: # define YYACTIONTYPE unsigned short int 
line 90805: # define YYWILDCARD 67 
line 90806: # define sqlite3ParserTOKENTYPE Token 
line 90807: typedef union { 
line 90808: int yyinit ; 
line 90809: sqlite3ParserTOKENTYPE yy0 ; 
line 90810: Select * yy3 ; 
line 90811: ExprList * yy14 ; 
line 90812: SrcList * yy65 ; 
line 90813: struct LikeOp yy96 ; 
line 90814: Expr * yy132 ; 
line 90815: u8 yy186 ; 
line 90816: int yy328 ; 
line 90817: ExprSpan yy346 ; 
line 90818: struct TrigEvent yy378 ; 
line 90819: IdList * yy408 ; 
line 90820: struct { int value ; int mask ; } yy429 ; 
line 90821: TriggerStep * yy473 ; 
line 90822: struct LimitVal yy476 ; 
line 90823: } YYMINORTYPE ; 
line 90824: # ifndef YYSTACKDEPTH 
line 90825: # define YYSTACKDEPTH 100 
line 90826: # endif 
line 90827: # define sqlite3ParserARG_SDECL Parse * pParse ; 
line 90828: # define sqlite3ParserARG_PDECL , Parse * pParse 
line 90829: # define sqlite3ParserARG_FETCH Parse * pParse = yypParser -> pParse 
line 90830: # define sqlite3ParserARG_STORE yypParser -> pParse = pParse 
line 90831: # define YYNSTATE 631 
line 90832: # define YYNRULE 330 
line 90833: # define YYFALLBACK 1 
line 90834: # define YY_NO_ACTION ( YYNSTATE + YYNRULE + 2 ) 
line 90835: # define YY_ACCEPT_ACTION ( YYNSTATE + YYNRULE + 1 ) 
line 90836: # define YY_ERROR_ACTION ( YYNSTATE + YYNRULE ) 
line 90840: static const YYMINORTYPE yyzerominor = { 0 } ; 
line 90850: # ifndef yytestcase 
line 90851: # define yytestcase ( X ) 
line 90852: # endif 
line 90902: # define YY_ACTTAB_COUNT ( 1543 ) 
line 90903: static const YYACTIONTYPE yy_action [ ] = { 
line 90904: 313 , 49 , 556 , 46 , 147 , 172 , 628 , 598 , 55 , 55 , 
line 90905: 55 , 55 , 302 , 53 , 53 , 53 , 53 , 52 , 52 , 51 , 
line 90906: 51 , 51 , 50 , 238 , 603 , 66 , 624 , 623 , 604 , 598 , 
line 90907: 591 , 585 , 48 , 53 , 53 , 53 , 53 , 52 , 52 , 51 , 
line 90908: 51 , 51 , 50 , 238 , 51 , 51 , 51 , 50 , 238 , 56 , 
line 90909: 57 , 47 , 583 , 582 , 584 , 584 , 54 , 54 , 55 , 55 , 
line 90910: 55 , 55 , 609 , 53 , 53 , 53 , 53 , 52 , 52 , 51 , 
line 90911: 51 , 51 , 50 , 238 , 313 , 598 , 672 , 330 , 411 , 217 , 
line 90912: 32 , 53 , 53 , 53 , 53 , 52 , 52 , 51 , 51 , 51 , 
line 90913: 50 , 238 , 330 , 414 , 621 , 620 , 166 , 598 , 673 , 382 , 
line 90914: 379 , 378 , 602 , 73 , 591 , 585 , 307 , 424 , 166 , 58 , 
line 90915: 377 , 382 , 379 , 378 , 516 , 515 , 624 , 623 , 254 , 200 , 
line 90916: 199 , 198 , 377 , 56 , 57 , 47 , 583 , 582 , 584 , 584 , 
line 90917: 54 , 54 , 55 , 55 , 55 , 55 , 581 , 53 , 53 , 53 , 
line 90918: 53 , 52 , 52 , 51 , 51 , 51 , 50 , 238 , 313 , 270 , 
line 90919: 226 , 422 , 283 , 133 , 177 , 139 , 284 , 385 , 279 , 384 , 
line 90920: 169 , 197 , 251 , 282 , 253 , 226 , 411 , 275 , 440 , 167 , 
line 90921: 139 , 284 , 385 , 279 , 384 , 169 , 571 , 236 , 591 , 585 , 
line 90922: 240 , 414 , 275 , 622 , 621 , 620 , 674 , 437 , 441 , 442 , 
line 90923: 602 , 88 , 352 , 266 , 439 , 268 , 438 , 56 , 57 , 47 , 
line 90924: 583 , 582 , 584 , 584 , 54 , 54 , 55 , 55 , 55 , 55 , 
line 90925: 465 , 53 , 53 , 53 , 53 , 52 , 52 , 51 , 51 , 51 , 
line 90926: 50 , 238 , 313 , 471 , 52 , 52 , 51 , 51 , 51 , 50 , 
line 90927: 238 , 234 , 166 , 491 , 567 , 382 , 379 , 378 , 1 , 440 , 
line 90928: 252 , 176 , 624 , 623 , 608 , 67 , 377 , 513 , 622 , 443 , 
line 90929: 237 , 577 , 591 , 585 , 622 , 172 , 466 , 598 , 554 , 441 , 
line 90930: 340 , 409 , 526 , 580 , 580 , 349 , 596 , 553 , 194 , 482 , 
line 90931: 175 , 56 , 57 , 47 , 583 , 582 , 584 , 584 , 54 , 54 , 
line 90932: 55 , 55 , 55 , 55 , 562 , 53 , 53 , 53 , 53 , 52 , 
line 90933: 52 , 51 , 51 , 51 , 50 , 238 , 313 , 594 , 594 , 594 , 
line 90934: 561 , 578 , 469 , 65 , 259 , 351 , 258 , 411 , 624 , 623 , 
line 90935: 621 , 620 , 332 , 576 , 575 , 240 , 560 , 568 , 520 , 411 , 
line 90936: 341 , 237 , 414 , 624 , 623 , 598 , 591 , 585 , 542 , 519 , 
line 90937: 171 , 602 , 95 , 68 , 414 , 624 , 623 , 624 , 623 , 38 , 
line 90938: 877 , 506 , 507 , 602 , 88 , 56 , 57 , 47 , 583 , 582 , 
line 90939: 584 , 584 , 54 , 54 , 55 , 55 , 55 , 55 , 532 , 53 , 
line 90940: 53 , 53 , 53 , 52 , 52 , 51 , 51 , 51 , 50 , 238 , 
line 90941: 313 , 411 , 579 , 398 , 531 , 237 , 621 , 620 , 388 , 625 , 
line 90942: 500 , 206 , 167 , 396 , 233 , 312 , 414 , 387 , 569 , 492 , 
line 90943: 216 , 621 , 620 , 566 , 622 , 602 , 74 , 533 , 210 , 491 , 
line 90944: 591 , 585 , 548 , 621 , 620 , 621 , 620 , 300 , 598 , 466 , 
line 90945: 481 , 67 , 603 , 35 , 622 , 601 , 604 , 547 , 6 , 56 , 
line 90946: 57 , 47 , 583 , 582 , 584 , 584 , 54 , 54 , 55 , 55 , 
line 90947: 55 , 55 , 601 , 53 , 53 , 53 , 53 , 52 , 52 , 51 , 
line 90948: 51 , 51 , 50 , 238 , 313 , 411 , 184 , 409 , 528 , 580 , 
line 90949: 580 , 551 , 962 , 186 , 419 , 2 , 353 , 259 , 351 , 258 , 
line 90950: 414 , 409 , 411 , 580 , 580 , 44 , 411 , 544 , 240 , 602 , 
line 90951: 94 , 190 , 7 , 62 , 591 , 585 , 598 , 414 , 350 , 607 , 
line 90952: 493 , 414 , 409 , 317 , 580 , 580 , 602 , 95 , 496 , 565 , 
line 90953: 602 , 80 , 203 , 56 , 57 , 47 , 583 , 582 , 584 , 584 , 
line 90954: 54 , 54 , 55 , 55 , 55 , 55 , 535 , 53 , 53 , 53 , 
line 90955: 53 , 52 , 52 , 51 , 51 , 51 , 50 , 238 , 313 , 202 , 
line 90956: 564 , 293 , 511 , 49 , 562 , 46 , 147 , 411 , 394 , 183 , 
line 90957: 563 , 549 , 505 , 549 , 174 , 409 , 322 , 580 , 580 , 39 , 
line 90958: 561 , 37 , 414 , 624 , 623 , 192 , 473 , 383 , 591 , 585 , 
line 90959: 474 , 602 , 80 , 601 , 504 , 544 , 560 , 364 , 402 , 210 , 
line 90960: 421 , 952 , 361 , 952 , 365 , 201 , 144 , 56 , 57 , 47 , 
line 90961: 583 , 582 , 584 , 584 , 54 , 54 , 55 , 55 , 55 , 55 , 
line 90962: 559 , 53 , 53 , 53 , 53 , 52 , 52 , 51 , 51 , 51 , 
line 90963: 50 , 238 , 313 , 601 , 232 , 264 , 272 , 321 , 374 , 484 , 
line 90964: 510 , 146 , 342 , 146 , 328 , 425 , 485 , 407 , 576 , 575 , 
line 90965: 622 , 621 , 620 , 49 , 168 , 46 , 147 , 353 , 546 , 491 , 
line 90966: 204 , 240 , 591 , 585 , 421 , 951 , 549 , 951 , 549 , 168 , 
line 90967: 429 , 67 , 390 , 343 , 622 , 434 , 307 , 423 , 338 , 360 , 
line 90968: 391 , 56 , 57 , 47 , 583 , 582 , 584 , 584 , 54 , 54 , 
line 90969: 55 , 55 , 55 , 55 , 601 , 53 , 53 , 53 , 53 , 52 , 
line 90970: 52 , 51 , 51 , 51 , 50 , 238 , 313 , 34 , 318 , 425 , 
line 90971: 237 , 21 , 359 , 273 , 411 , 167 , 411 , 276 , 411 , 540 , 
line 90972: 411 , 422 , 13 , 318 , 619 , 618 , 617 , 622 , 275 , 414 , 
line 90973: 336 , 414 , 622 , 414 , 622 , 414 , 591 , 585 , 602 , 69 , 
line 90974: 602 , 97 , 602 , 100 , 602 , 98 , 631 , 629 , 334 , 475 , 
line 90975: 475 , 367 , 319 , 148 , 327 , 56 , 57 , 47 , 583 , 582 , 
line 90976: 584 , 584 , 54 , 54 , 55 , 55 , 55 , 55 , 411 , 53 , 
line 90977: 53 , 53 , 53 , 52 , 52 , 51 , 51 , 51 , 50 , 238 , 
line 90978: 313 , 411 , 331 , 414 , 411 , 49 , 276 , 46 , 147 , 569 , 
line 90979: 406 , 216 , 602 , 106 , 573 , 573 , 414 , 354 , 524 , 414 , 
line 90980: 411 , 622 , 411 , 224 , 4 , 602 , 104 , 605 , 602 , 108 , 
line 90981: 591 , 585 , 622 , 20 , 375 , 414 , 167 , 414 , 215 , 144 , 
line 90982: 470 , 239 , 167 , 225 , 602 , 109 , 602 , 134 , 18 , 56 , 
line 90983: 57 , 47 , 583 , 582 , 584 , 584 , 54 , 54 , 55 , 55 , 
line 90984: 55 , 55 , 411 , 53 , 53 , 53 , 53 , 52 , 52 , 51 , 
line 90985: 51 , 51 , 50 , 238 , 313 , 411 , 276 , 414 , 12 , 459 , 
line 90986: 276 , 171 , 411 , 16 , 223 , 189 , 602 , 135 , 354 , 170 , 
line 90987: 414 , 622 , 630 , 2 , 411 , 622 , 540 , 414 , 143 , 602 , 
line 90988: 61 , 359 , 132 , 622 , 591 , 585 , 602 , 105 , 458 , 414 , 
line 90989: 23 , 622 , 446 , 326 , 23 , 538 , 622 , 325 , 602 , 103 , 
line 90990: 427 , 530 , 309 , 56 , 57 , 47 , 583 , 582 , 584 , 584 , 
line 90991: 54 , 54 , 55 , 55 , 55 , 55 , 411 , 53 , 53 , 53 , 
line 90992: 53 , 52 , 52 , 51 , 51 , 51 , 50 , 238 , 313 , 411 , 
line 90993: 264 , 414 , 411 , 276 , 359 , 219 , 157 , 214 , 357 , 366 , 
line 90994: 602 , 96 , 522 , 521 , 414 , 622 , 358 , 414 , 622 , 622 , 
line 90995: 411 , 613 , 612 , 602 , 102 , 142 , 602 , 77 , 591 , 585 , 
line 90996: 529 , 540 , 231 , 426 , 308 , 414 , 622 , 622 , 468 , 521 , 
line 90997: 324 , 601 , 257 , 263 , 602 , 99 , 622 , 56 , 45 , 47 , 
line 90998: 583 , 582 , 584 , 584 , 54 , 54 , 55 , 55 , 55 , 55 , 
line 90999: 411 , 53 , 53 , 53 , 53 , 52 , 52 , 51 , 51 , 51 , 
line 91000: 50 , 238 , 313 , 264 , 264 , 414 , 411 , 213 , 209 , 544 , 
line 91001: 544 , 207 , 611 , 28 , 602 , 138 , 50 , 238 , 622 , 622 , 
line 91002: 381 , 414 , 503 , 140 , 323 , 222 , 274 , 622 , 590 , 589 , 
line 91003: 602 , 137 , 591 , 585 , 629 , 334 , 606 , 30 , 622 , 571 , 
line 91004: 236 , 601 , 601 , 130 , 496 , 601 , 453 , 451 , 288 , 286 , 
line 91005: 587 , 586 , 57 , 47 , 583 , 582 , 584 , 584 , 54 , 54 , 
line 91006: 55 , 55 , 55 , 55 , 411 , 53 , 53 , 53 , 53 , 52 , 
line 91007: 52 , 51 , 51 , 51 , 50 , 238 , 313 , 588 , 411 , 414 , 
line 91008: 411 , 264 , 410 , 129 , 595 , 400 , 27 , 376 , 602 , 136 , 
line 91009: 128 , 165 , 479 , 414 , 282 , 414 , 622 , 622 , 411 , 622 , 
line 91010: 622 , 411 , 602 , 76 , 602 , 93 , 591 , 585 , 188 , 372 , 
line 91011: 368 , 125 , 476 , 414 , 261 , 160 , 414 , 171 , 124 , 472 , 
line 91012: 123 , 15 , 602 , 92 , 450 , 602 , 75 , 47 , 583 , 582 , 
line 91013: 584 , 584 , 54 , 54 , 55 , 55 , 55 , 55 , 464 , 53 , 
line 91014: 53 , 53 , 53 , 52 , 52 , 51 , 51 , 51 , 50 , 238 , 
line 91015: 43 , 405 , 264 , 3 , 558 , 264 , 545 , 415 , 623 , 159 , 
line 91016: 541 , 158 , 539 , 278 , 25 , 461 , 121 , 622 , 408 , 622 , 
line 91017: 622 , 622 , 24 , 43 , 405 , 622 , 3 , 622 , 622 , 120 , 
line 91018: 415 , 623 , 11 , 456 , 411 , 156 , 452 , 403 , 509 , 277 , 
line 91019: 118 , 408 , 489 , 113 , 205 , 449 , 271 , 567 , 221 , 414 , 
line 91020: 269 , 267 , 155 , 622 , 622 , 111 , 411 , 622 , 602 , 95 , 
line 91021: 403 , 622 , 411 , 110 , 10 , 622 , 622 , 40 , 41 , 534 , 
line 91022: 567 , 414 , 64 , 264 , 42 , 413 , 412 , 414 , 601 , 596 , 
line 91023: 602 , 91 , 445 , 436 , 150 , 435 , 602 , 90 , 622 , 265 , 
line 91024: 40 , 41 , 337 , 242 , 411 , 191 , 333 , 42 , 413 , 412 , 
line 91025: 398 , 420 , 596 , 316 , 622 , 399 , 260 , 107 , 230 , 414 , 
line 91026: 594 , 594 , 594 , 593 , 592 , 14 , 220 , 411 , 602 , 101 , 
line 91027: 240 , 622 , 43 , 405 , 362 , 3 , 149 , 315 , 626 , 415 , 
line 91028: 623 , 127 , 414 , 594 , 594 , 594 , 593 , 592 , 14 , 622 , 
line 91029: 408 , 602 , 89 , 411 , 181 , 33 , 405 , 463 , 3 , 411 , 
line 91030: 264 , 462 , 415 , 623 , 616 , 615 , 614 , 355 , 414 , 403 , 
line 91031: 417 , 416 , 622 , 408 , 414 , 622 , 622 , 602 , 87 , 567 , 
line 91032: 418 , 627 , 622 , 602 , 86 , 8 , 241 , 180 , 126 , 255 , 
line 91033: 600 , 178 , 403 , 240 , 208 , 455 , 395 , 294 , 444 , 40 , 
line 91034: 41 , 297 , 567 , 248 , 622 , 296 , 42 , 413 , 412 , 247 , 
line 91035: 622 , 596 , 244 , 622 , 30 , 60 , 31 , 243 , 430 , 624 , 
line 91036: 623 , 292 , 40 , 41 , 622 , 295 , 145 , 622 , 601 , 42 , 
line 91037: 413 , 412 , 622 , 622 , 596 , 393 , 622 , 397 , 599 , 59 , 
line 91038: 235 , 622 , 594 , 594 , 594 , 593 , 592 , 14 , 218 , 291 , 
line 91039: 622 , 36 , 344 , 305 , 304 , 303 , 179 , 301 , 411 , 567 , 
line 91040: 454 , 557 , 173 , 185 , 622 , 594 , 594 , 594 , 593 , 592 , 
line 91041: 14 , 411 , 29 , 414 , 151 , 289 , 246 , 523 , 411 , 196 , 
line 91042: 195 , 335 , 602 , 85 , 411 , 245 , 414 , 526 , 392 , 543 , 
line 91043: 411 , 596 , 287 , 414 , 285 , 602 , 72 , 537 , 153 , 414 , 
line 91044: 466 , 411 , 602 , 71 , 154 , 414 , 411 , 152 , 602 , 84 , 
line 91045: 386 , 536 , 329 , 411 , 602 , 83 , 414 , 518 , 280 , 411 , 
line 91046: 513 , 414 , 594 , 594 , 594 , 602 , 82 , 517 , 414 , 311 , 
line 91047: 602 , 81 , 411 , 514 , 414 , 512 , 131 , 602 , 70 , 229 , 
line 91048: 228 , 227 , 494 , 602 , 17 , 411 , 488 , 414 , 259 , 346 , 
line 91049: 249 , 389 , 487 , 486 , 314 , 164 , 602 , 79 , 310 , 240 , 
line 91050: 414 , 373 , 480 , 163 , 262 , 371 , 414 , 162 , 369 , 602 , 
line 91051: 78 , 212 , 478 , 26 , 477 , 602 , 9 , 161 , 467 , 363 , 
line 91052: 141 , 122 , 339 , 187 , 119 , 457 , 348 , 117 , 347 , 116 , 
line 91053: 115 , 114 , 448 , 112 , 182 , 320 , 22 , 433 , 19 , 432 , 
line 91054: 431 , 63 , 428 , 610 , 193 , 298 , 597 , 574 , 572 , 404 , 
line 91055: 555 , 552 , 290 , 281 , 510 , 499 , 498 , 497 , 495 , 380 , 
line 91056: 356 , 460 , 256 , 250 , 345 , 447 , 306 , 5 , 570 , 550 , 
line 91057: 299 , 211 , 370 , 401 , 550 , 508 , 502 , 501 , 490 , 527 , 
line 91058: 525 , 483 , 238 , 
line 91059: } ; 
line 91060: static const YYCODETYPE yy_lookahead [ ] = { 
line 91061: 19 , 222 , 223 , 224 , 225 , 24 , 1 , 26 , 77 , 78 , 
line 91062: 79 , 80 , 15 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 
line 91063: 89 , 90 , 91 , 92 , 113 , 22 , 26 , 27 , 117 , 26 , 
line 91064: 49 , 50 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 
line 91065: 89 , 90 , 91 , 92 , 88 , 89 , 90 , 91 , 92 , 68 , 
line 91066: 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 
line 91067: 79 , 80 , 23 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 
line 91068: 89 , 90 , 91 , 92 , 19 , 94 , 118 , 19 , 150 , 22 , 
line 91069: 25 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 
line 91070: 91 , 92 , 19 , 165 , 94 , 95 , 96 , 94 , 118 , 99 , 
line 91071: 100 , 101 , 174 , 175 , 49 , 50 , 22 , 23 , 96 , 54 , 
line 91072: 110 , 99 , 100 , 101 , 7 , 8 , 26 , 27 , 16 , 105 , 
line 91073: 106 , 107 , 110 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 
line 91074: 75 , 76 , 77 , 78 , 79 , 80 , 113 , 82 , 83 , 84 , 
line 91075: 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 19 , 16 , 
line 91076: 92 , 67 , 98 , 24 , 96 , 97 , 98 , 99 , 100 , 101 , 
line 91077: 102 , 25 , 60 , 109 , 62 , 92 , 150 , 109 , 150 , 25 , 
line 91078: 97 , 98 , 99 , 100 , 101 , 102 , 86 , 87 , 49 , 50 , 
line 91079: 116 , 165 , 109 , 165 , 94 , 95 , 118 , 97 , 170 , 171 , 
line 91080: 174 , 175 , 128 , 60 , 104 , 62 , 106 , 68 , 69 , 70 , 
line 91081: 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 
line 91082: 11 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 
line 91083: 91 , 92 , 19 , 21 , 86 , 87 , 88 , 89 , 90 , 91 , 
line 91084: 92 , 215 , 96 , 150 , 66 , 99 , 100 , 101 , 22 , 150 , 
line 91085: 138 , 118 , 26 , 27 , 161 , 162 , 110 , 103 , 165 , 231 , 
line 91086: 232 , 23 , 49 , 50 , 165 , 24 , 57 , 26 , 32 , 170 , 
line 91087: 171 , 112 , 94 , 114 , 115 , 63 , 98 , 41 , 185 , 186 , 
line 91088: 118 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 
line 91089: 77 , 78 , 79 , 80 , 12 , 82 , 83 , 84 , 85 , 86 , 
line 91090: 87 , 88 , 89 , 90 , 91 , 92 , 19 , 129 , 130 , 131 , 
line 91091: 28 , 23 , 100 , 25 , 105 , 106 , 107 , 150 , 26 , 27 , 
line 91092: 94 , 95 , 169 , 170 , 171 , 116 , 44 , 23 , 46 , 150 , 
line 91093: 231 , 232 , 165 , 26 , 27 , 94 , 49 , 50 , 23 , 57 , 
line 91094: 25 , 174 , 175 , 22 , 165 , 26 , 27 , 26 , 27 , 136 , 
line 91095: 138 , 97 , 98 , 174 , 175 , 68 , 69 , 70 , 71 , 72 , 
line 91096: 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 23 , 82 , 
line 91097: 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 
line 91098: 19 , 150 , 23 , 216 , 23 , 232 , 94 , 95 , 221 , 150 , 
line 91099: 23 , 160 , 25 , 214 , 215 , 163 , 165 , 88 , 166 , 167 , 
line 91100: 168 , 94 , 95 , 23 , 165 , 174 , 175 , 88 , 160 , 150 , 
line 91101: 49 , 50 , 120 , 94 , 95 , 94 , 95 , 158 , 26 , 57 , 
line 91102: 161 , 162 , 113 , 136 , 165 , 194 , 117 , 120 , 22 , 68 , 
line 91103: 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 
line 91104: 79 , 80 , 194 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 
line 91105: 89 , 90 , 91 , 92 , 19 , 150 , 23 , 112 , 23 , 114 , 
line 91106: 115 , 25 , 142 , 143 , 144 , 145 , 218 , 105 , 106 , 107 , 
line 91107: 165 , 112 , 150 , 114 , 115 , 22 , 150 , 166 , 116 , 174 , 
line 91108: 175 , 22 , 76 , 235 , 49 , 50 , 94 , 165 , 240 , 172 , 
line 91109: 173 , 165 , 112 , 155 , 114 , 115 , 174 , 175 , 181 , 11 , 
line 91110: 174 , 175 , 22 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 
line 91111: 75 , 76 , 77 , 78 , 79 , 80 , 205 , 82 , 83 , 84 , 
line 91112: 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 19 , 160 , 
line 91113: 23 , 226 , 23 , 222 , 12 , 224 , 225 , 150 , 216 , 23 , 
line 91114: 23 , 25 , 36 , 25 , 25 , 112 , 220 , 114 , 115 , 135 , 
line 91115: 28 , 137 , 165 , 26 , 27 , 119 , 30 , 51 , 49 , 50 , 
line 91116: 34 , 174 , 175 , 194 , 58 , 166 , 44 , 229 , 46 , 160 , 
line 91117: 22 , 23 , 234 , 25 , 48 , 206 , 207 , 68 , 69 , 70 , 
line 91118: 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 
line 91119: 23 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 
line 91120: 91 , 92 , 19 , 194 , 205 , 150 , 23 , 220 , 19 , 181 , 
line 91121: 182 , 95 , 97 , 95 , 108 , 67 , 188 , 169 , 170 , 171 , 
line 91122: 165 , 94 , 95 , 222 , 50 , 224 , 225 , 218 , 120 , 150 , 
line 91123: 160 , 116 , 49 , 50 , 22 , 23 , 120 , 25 , 120 , 50 , 
line 91124: 161 , 162 , 19 , 128 , 165 , 244 , 22 , 23 , 193 , 240 , 
line 91125: 27 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 
line 91126: 77 , 78 , 79 , 80 , 194 , 82 , 83 , 84 , 85 , 86 , 
line 91127: 87 , 88 , 89 , 90 , 91 , 92 , 19 , 25 , 104 , 67 , 
line 91128: 232 , 24 , 150 , 23 , 150 , 25 , 150 , 150 , 150 , 150 , 
line 91129: 150 , 67 , 25 , 104 , 7 , 8 , 9 , 165 , 109 , 165 , 
line 91130: 245 , 165 , 165 , 165 , 165 , 165 , 49 , 50 , 174 , 175 , 
line 91131: 174 , 175 , 174 , 175 , 174 , 175 , 0 , 1 , 2 , 105 , 
line 91132: 106 , 107 , 248 , 249 , 187 , 68 , 69 , 70 , 71 , 72 , 
line 91133: 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 150 , 82 , 
line 91134: 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 
line 91135: 19 , 150 , 213 , 165 , 150 , 222 , 150 , 224 , 225 , 166 , 
line 91136: 167 , 168 , 174 , 175 , 129 , 130 , 165 , 150 , 165 , 165 , 
line 91137: 150 , 165 , 150 , 241 , 35 , 174 , 175 , 174 , 174 , 175 , 
line 91138: 49 , 50 , 165 , 52 , 23 , 165 , 25 , 165 , 206 , 207 , 
line 91139: 23 , 197 , 25 , 187 , 174 , 175 , 174 , 175 , 204 , 68 , 
line 91140: 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 
line 91141: 79 , 80 , 150 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 
line 91142: 89 , 90 , 91 , 92 , 19 , 150 , 150 , 165 , 35 , 23 , 
line 91143: 150 , 25 , 150 , 22 , 217 , 24 , 174 , 175 , 150 , 35 , 
line 91144: 165 , 165 , 144 , 145 , 150 , 165 , 150 , 165 , 118 , 174 , 
line 91145: 175 , 150 , 22 , 165 , 49 , 50 , 174 , 175 , 23 , 165 , 
line 91146: 25 , 165 , 23 , 187 , 25 , 27 , 165 , 187 , 174 , 175 , 
line 91147: 23 , 23 , 25 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 
line 91148: 75 , 76 , 77 , 78 , 79 , 80 , 150 , 82 , 83 , 84 , 
line 91149: 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 19 , 150 , 
line 91150: 150 , 165 , 150 , 150 , 150 , 217 , 25 , 160 , 19 , 213 , 
line 91151: 174 , 175 , 190 , 191 , 165 , 165 , 27 , 165 , 165 , 165 , 
line 91152: 150 , 150 , 150 , 174 , 175 , 39 , 174 , 175 , 49 , 50 , 
line 91153: 23 , 150 , 52 , 250 , 251 , 165 , 165 , 165 , 190 , 191 , 
line 91154: 187 , 194 , 241 , 193 , 174 , 175 , 165 , 68 , 69 , 70 , 
line 91155: 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 
line 91156: 150 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 
line 91157: 91 , 92 , 19 , 150 , 150 , 165 , 150 , 160 , 160 , 166 , 
line 91158: 166 , 160 , 150 , 22 , 174 , 175 , 91 , 92 , 165 , 165 , 
line 91159: 52 , 165 , 29 , 150 , 213 , 241 , 23 , 165 , 49 , 50 , 
line 91160: 174 , 175 , 49 , 50 , 1 , 2 , 173 , 126 , 165 , 86 , 
line 91161: 87 , 194 , 194 , 22 , 181 , 194 , 193 , 193 , 205 , 205 , 
line 91162: 71 , 72 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 
line 91163: 77 , 78 , 79 , 80 , 150 , 82 , 83 , 84 , 85 , 86 , 
line 91164: 87 , 88 , 89 , 90 , 91 , 92 , 19 , 98 , 150 , 165 , 
line 91165: 150 , 150 , 150 , 22 , 150 , 150 , 22 , 52 , 174 , 175 , 
line 91166: 22 , 102 , 20 , 165 , 109 , 165 , 165 , 165 , 150 , 165 , 
line 91167: 165 , 150 , 174 , 175 , 174 , 175 , 49 , 50 , 24 , 19 , 
line 91168: 43 , 104 , 59 , 165 , 138 , 104 , 165 , 25 , 53 , 53 , 
line 91169: 22 , 5 , 174 , 175 , 193 , 174 , 175 , 70 , 71 , 72 , 
line 91170: 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 1 , 82 , 
line 91171: 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 
line 91172: 19 , 20 , 150 , 22 , 150 , 150 , 150 , 26 , 27 , 118 , 
line 91173: 150 , 35 , 150 , 150 , 76 , 27 , 108 , 165 , 37 , 165 , 
line 91174: 165 , 165 , 76 , 19 , 20 , 165 , 22 , 165 , 165 , 127 , 
line 91175: 26 , 27 , 22 , 1 , 150 , 16 , 20 , 56 , 150 , 150 , 
line 91176: 119 , 37 , 150 , 119 , 160 , 193 , 150 , 66 , 193 , 165 , 
line 91177: 150 , 150 , 121 , 165 , 165 , 108 , 150 , 165 , 174 , 175 , 
line 91178: 56 , 165 , 150 , 127 , 22 , 165 , 165 , 86 , 87 , 88 , 
line 91179: 66 , 165 , 16 , 150 , 93 , 94 , 95 , 165 , 194 , 98 , 
line 91180: 174 , 175 , 128 , 23 , 15 , 23 , 174 , 175 , 165 , 150 , 
line 91181: 86 , 87 , 65 , 140 , 150 , 22 , 3 , 93 , 94 , 95 , 
line 91182: 216 , 4 , 98 , 252 , 165 , 221 , 150 , 164 , 180 , 165 , 
line 91183: 129 , 130 , 131 , 132 , 133 , 134 , 193 , 150 , 174 , 175 , 
line 91184: 116 , 165 , 19 , 20 , 150 , 22 , 249 , 252 , 149 , 26 , 
line 91185: 27 , 180 , 165 , 129 , 130 , 131 , 132 , 133 , 134 , 165 , 
line 91186: 37 , 174 , 175 , 150 , 6 , 19 , 20 , 150 , 22 , 150 , 
line 91187: 150 , 150 , 26 , 27 , 149 , 149 , 13 , 150 , 165 , 56 , 
line 91188: 149 , 159 , 165 , 37 , 165 , 165 , 165 , 174 , 175 , 66 , 
line 91189: 146 , 147 , 165 , 174 , 175 , 25 , 152 , 151 , 154 , 150 , 
line 91190: 194 , 151 , 56 , 116 , 160 , 150 , 123 , 202 , 150 , 86 , 
line 91191: 87 , 199 , 66 , 193 , 165 , 200 , 93 , 94 , 95 , 150 , 
line 91192: 165 , 98 , 150 , 165 , 126 , 22 , 124 , 150 , 150 , 26 , 
line 91193: 27 , 150 , 86 , 87 , 165 , 201 , 150 , 165 , 194 , 93 , 
line 91194: 94 , 95 , 165 , 165 , 98 , 150 , 165 , 122 , 203 , 125 , 
line 91195: 227 , 165 , 129 , 130 , 131 , 132 , 133 , 134 , 5 , 150 , 
line 91196: 165 , 135 , 218 , 10 , 11 , 12 , 13 , 14 , 150 , 66 , 
line 91197: 17 , 157 , 118 , 157 , 165 , 129 , 130 , 131 , 132 , 133 , 
line 91198: 134 , 150 , 104 , 165 , 31 , 210 , 33 , 176 , 150 , 86 , 
line 91199: 87 , 247 , 174 , 175 , 150 , 42 , 165 , 94 , 121 , 211 , 
line 91200: 150 , 98 , 210 , 165 , 210 , 174 , 175 , 211 , 55 , 165 , 
line 91201: 57 , 150 , 174 , 175 , 61 , 165 , 150 , 64 , 174 , 175 , 
line 91202: 104 , 211 , 47 , 150 , 174 , 175 , 165 , 176 , 176 , 150 , 
line 91203: 103 , 165 , 129 , 130 , 131 , 174 , 175 , 184 , 165 , 179 , 
line 91204: 174 , 175 , 150 , 178 , 165 , 176 , 22 , 174 , 175 , 230 , 
line 91205: 92 , 230 , 184 , 174 , 175 , 150 , 176 , 165 , 105 , 106 , 
line 91206: 107 , 150 , 176 , 176 , 111 , 156 , 174 , 175 , 179 , 116 , 
line 91207: 165 , 18 , 157 , 156 , 238 , 157 , 165 , 156 , 45 , 174 , 
line 91208: 175 , 157 , 157 , 135 , 239 , 174 , 175 , 156 , 189 , 157 , 
line 91209: 68 , 189 , 139 , 219 , 22 , 199 , 157 , 192 , 18 , 192 , 
line 91210: 192 , 192 , 199 , 189 , 219 , 157 , 243 , 40 , 243 , 157 , 
line 91211: 157 , 246 , 38 , 153 , 196 , 198 , 166 , 233 , 233 , 228 , 
line 91212: 177 , 177 , 209 , 177 , 182 , 177 , 166 , 177 , 166 , 178 , 
line 91213: 242 , 199 , 242 , 209 , 209 , 199 , 148 , 196 , 166 , 208 , 
line 91214: 195 , 236 , 237 , 191 , 208 , 183 , 183 , 183 , 186 , 174 , 
line 91215: 174 , 186 , 92 , 
line 91216: } ; 
line 91217: # define YY_SHIFT_USE_DFLT ( - 90 ) 
line 91218: # define YY_SHIFT_COUNT ( 418 ) 
line 91219: # define YY_SHIFT_MIN ( - 89 ) 
line 91220: # define YY_SHIFT_MAX ( 1470 ) 
line 91221: static const short yy_shift_ofst [ ] = { 
line 91222: 993 , 1114 , 1343 , 1114 , 1213 , 1213 , 90 , 90 , 0 , - 19 , 
line 91223: 1213 , 1213 , 1213 , 1213 , 1213 , 352 , 517 , 721 , 1091 , 1213 , 
line 91224: 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 
line 91225: 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 
line 91226: 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 1236 , 1213 , 1213 , 
line 91227: 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 1213 , 
line 91228: 1213 , - 49 , 199 , 517 , 517 , 913 , 913 , 382 , 1177 , 55 , 
line 91229: 647 , 573 , 499 , 425 , 351 , 277 , 203 , 129 , 795 , 795 , 
line 91230: 795 , 795 , 795 , 795 , 795 , 795 , 795 , 795 , 795 , 795 , 
line 91231: 795 , 795 , 795 , 795 , 795 , 795 , 869 , 795 , 943 , 1017 , 
line 91232: 1017 , - 69 , - 69 , - 69 , - 69 , - 1 , - 1 , 58 , 138 , - 44 , 
line 91233: 517 , 517 , 517 , 517 , 517 , 517 , 517 , 517 , 517 , 517 , 
line 91234: 517 , 517 , 517 , 517 , 517 , 517 , 202 , 579 , 517 , 517 , 
line 91235: 517 , 517 , 517 , 382 , 885 , 1450 , - 90 , - 90 , - 90 , 1293 , 
line 91236: 73 , 272 , 272 , 309 , 311 , 297 , 282 , 216 , 602 , 538 , 
line 91237: 517 , 517 , 517 , 517 , 517 , 517 , 517 , 517 , 517 , 517 , 
line 91238: 517 , 517 , 517 , 517 , 517 , 517 , 517 , 517 , 517 , 517 , 
line 91239: 517 , 517 , 517 , 517 , 517 , 517 , 517 , 517 , 517 , 517 , 
line 91240: 517 , 517 , 505 , 231 , 231 , 231 , 706 , 64 , 1177 , 1177 , 
line 91241: 1177 , - 90 , - 90 , - 90 , 136 , 168 , 168 , 12 , 496 , 496 , 
line 91242: 496 , 506 , 423 , 512 , 370 , 349 , 335 , 149 , 149 , 149 , 
line 91243: 149 , 604 , 516 , 149 , 149 , 508 , 3 , 299 , 677 , 871 , 
line 91244: 613 , 613 , 879 , 871 , 879 , 144 , 382 , 226 , 382 , 226 , 
line 91245: 564 , 226 , 613 , 226 , 226 , 404 , 625 , 625 , 382 , 426 , 
line 91246: - 89 , 801 , 1464 , 1244 , 1244 , 1457 , 1457 , 1244 , 1462 , 1412 , 
line 91247: 1188 , 1470 , 1470 , 1470 , 1470 , 1244 , 1188 , 1462 , 1412 , 1412 , 
line 91248: 1244 , 1443 , 1338 , 1423 , 1244 , 1244 , 1443 , 1244 , 1443 , 1244 , 
line 91249: 1443 , 1414 , 1306 , 1306 , 1306 , 1365 , 1348 , 1348 , 1414 , 1306 , 
line 91250: 1317 , 1306 , 1365 , 1306 , 1306 , 1267 , 1268 , 1267 , 1268 , 1267 , 
line 91251: 1268 , 1244 , 1244 , 1216 , 1214 , 1215 , 1192 , 1173 , 1188 , 1177 , 
line 91252: 1260 , 1253 , 1253 , 1248 , 1248 , 1248 , 1248 , - 90 , - 90 , - 90 , 
line 91253: - 90 , - 90 , - 90 , 939 , 102 , 614 , 84 , 133 , 14 , 837 , 
line 91254: 396 , 829 , 825 , 796 , 757 , 751 , 650 , 357 , 244 , 107 , 
line 91255: 54 , 305 , 278 , 1207 , 1203 , 1183 , 1063 , 1179 , 1137 , 1166 , 
line 91256: 1172 , 1170 , 1064 , 1152 , 1046 , 1057 , 1034 , 1126 , 1041 , 1129 , 
line 91257: 1142 , 1031 , 1120 , 1012 , 1056 , 1048 , 1018 , 1098 , 1086 , 1001 , 
line 91258: 1097 , 1076 , 1058 , 971 , 936 , 1026 , 1052 , 1025 , 1013 , 1027 , 
line 91259: 967 , 1044 , 1032 , 1050 , 945 , 949 , 1028 , 995 , 1024 , 1021 , 
line 91260: 963 , 981 , 928 , 953 , 951 , 870 , 876 , 897 , 838 , 720 , 
line 91261: 828 , 794 , 820 , 498 , 642 , 783 , 657 , 729 , 642 , 557 , 
line 91262: 507 , 509 , 497 , 470 , 478 , 449 , 294 , 228 , 443 , 23 , 
line 91263: 152 , 123 , 68 , - 20 , - 42 , 57 , 39 , - 3 , 5 , 
line 91264: } ; 
line 91265: # define YY_REDUCE_USE_DFLT ( - 222 ) 
line 91266: # define YY_REDUCE_COUNT ( 312 ) 
line 91267: # define YY_REDUCE_MIN ( - 221 ) 
line 91268: # define YY_REDUCE_MAX ( 1378 ) 
line 91269: static const short yy_reduce_ofst [ ] = { 
line 91270: 310 , 994 , 1134 , 221 , 169 , 157 , 89 , 18 , 83 , 301 , 
line 91271: 377 , 316 , 312 , 16 , 295 , 238 , 249 , 391 , 1301 , 1295 , 
line 91272: 1282 , 1269 , 1263 , 1256 , 1251 , 1240 , 1234 , 1228 , 1221 , 1208 , 
line 91273: 1109 , 1103 , 1077 , 1054 , 1022 , 1016 , 911 , 908 , 890 , 888 , 
line 91274: 874 , 816 , 800 , 760 , 742 , 739 , 726 , 684 , 672 , 665 , 
line 91275: 652 , 612 , 610 , 594 , 591 , 578 , 530 , 528 , 526 , 524 , 
line 91276: - 72 , - 221 , 399 , 469 , 445 , 438 , 143 , 222 , 359 , 523 , 
line 91277: 523 , 523 , 523 , 523 , 523 , 523 , 523 , 523 , 523 , 523 , 
line 91278: 523 , 523 , 523 , 523 , 523 , 523 , 523 , 523 , 523 , 523 , 
line 91279: 523 , 523 , 523 , 523 , 523 , 523 , 523 , 523 , 523 , 523 , 
line 91280: 523 , 523 , 523 , 523 , 523 , 523 , 523 , 307 , 523 , 523 , 
line 91281: 1110 , 678 , 1033 , 965 , 962 , 891 , 814 , 813 , 744 , 771 , 
line 91282: 691 , 607 , 522 , 743 , 686 , 740 , 328 , 418 , 670 , 666 , 
line 91283: 596 , 527 , 529 , 583 , 523 , 523 , 523 , 523 , 523 , 593 , 
line 91284: 823 , 738 , 712 , 892 , 1199 , 1185 , 1176 , 1171 , 673 , 673 , 
line 91285: 1168 , 1167 , 1162 , 1159 , 1148 , 1145 , 1139 , 1117 , 1111 , 1107 , 
line 91286: 1084 , 1066 , 1049 , 1011 , 1010 , 1006 , 1002 , 999 , 998 , 973 , 
line 91287: 972 , 970 , 966 , 964 , 895 , 894 , 892 , 833 , 822 , 762 , 
line 91288: 761 , 229 , 811 , 804 , 803 , 389 , 688 , 808 , 807 , 737 , 
line 91289: 460 , 464 , 572 , 584 , 1355 , 1366 , 1365 , 1352 , 1354 , 1353 , 
line 91290: 1352 , 1326 , 1335 , 1342 , 1335 , 1335 , 1335 , 1335 , 1335 , 1335 , 
line 91291: 1335 , 1295 , 1295 , 1335 , 1335 , 1321 , 1362 , 1331 , 1378 , 1326 , 
line 91292: 1315 , 1314 , 1280 , 1322 , 1278 , 1341 , 1352 , 1340 , 1350 , 1338 , 
line 91293: 1332 , 1336 , 1303 , 1334 , 1333 , 1281 , 1275 , 1274 , 1340 , 1307 , 
line 91294: 1308 , 1350 , 1255 , 1343 , 1342 , 1255 , 1253 , 1338 , 1275 , 1304 , 
line 91295: 1293 , 1299 , 1298 , 1297 , 1295 , 1329 , 1286 , 1264 , 1292 , 1289 , 
line 91296: 1322 , 1321 , 1235 , 1226 , 1315 , 1314 , 1311 , 1308 , 1307 , 1305 , 
line 91297: 1299 , 1279 , 1277 , 1276 , 1270 , 1258 , 1211 , 1209 , 1250 , 1259 , 
line 91298: 1255 , 1242 , 1243 , 1241 , 1201 , 1200 , 1184 , 1186 , 1182 , 1178 , 
line 91299: 1165 , 1206 , 1204 , 1113 , 1135 , 1095 , 1124 , 1105 , 1102 , 1096 , 
line 91300: 1112 , 1140 , 1136 , 1121 , 1116 , 1115 , 1089 , 985 , 961 , 987 , 
line 91301: 1061 , 1038 , 1053 , 
line 91302: } ; 
line 91303: static const YYACTIONTYPE yy_default [ ] = { 
line 91304: 636 , 872 , 961 , 961 , 961 , 872 , 901 , 901 , 961 , 760 , 
line 91305: 961 , 961 , 961 , 961 , 870 , 961 , 961 , 935 , 961 , 961 , 
line 91306: 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 
line 91307: 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 
line 91308: 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 
line 91309: 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 
line 91310: 961 , 844 , 961 , 961 , 961 , 901 , 901 , 675 , 764 , 795 , 
line 91311: 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 934 , 936 , 
line 91312: 810 , 809 , 803 , 802 , 914 , 775 , 800 , 793 , 786 , 797 , 
line 91313: 873 , 866 , 867 , 865 , 869 , 874 , 961 , 796 , 832 , 850 , 
line 91314: 831 , 849 , 856 , 848 , 834 , 843 , 833 , 667 , 835 , 836 , 
line 91315: 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 
line 91316: 961 , 961 , 961 , 961 , 961 , 961 , 662 , 729 , 961 , 961 , 
line 91317: 961 , 961 , 961 , 961 , 837 , 838 , 853 , 852 , 851 , 961 , 
line 91318: 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 
line 91319: 961 , 941 , 939 , 961 , 885 , 961 , 961 , 961 , 961 , 961 , 
line 91320: 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 
line 91321: 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 
line 91322: 961 , 642 , 961 , 760 , 760 , 760 , 636 , 961 , 961 , 961 , 
line 91323: 961 , 953 , 764 , 754 , 720 , 961 , 961 , 961 , 961 , 961 , 
line 91324: 961 , 961 , 961 , 961 , 961 , 961 , 961 , 805 , 743 , 924 , 
line 91325: 926 , 961 , 907 , 741 , 664 , 762 , 677 , 752 , 644 , 799 , 
line 91326: 777 , 777 , 919 , 799 , 919 , 701 , 961 , 789 , 961 , 789 , 
line 91327: 698 , 789 , 777 , 789 , 789 , 868 , 961 , 961 , 961 , 761 , 
line 91328: 752 , 961 , 946 , 768 , 768 , 938 , 938 , 768 , 811 , 733 , 
line 91329: 799 , 740 , 740 , 740 , 740 , 768 , 799 , 811 , 733 , 733 , 
line 91330: 768 , 659 , 913 , 911 , 768 , 768 , 659 , 768 , 659 , 768 , 
line 91331: 659 , 878 , 731 , 731 , 731 , 716 , 882 , 882 , 878 , 731 , 
line 91332: 701 , 731 , 716 , 731 , 731 , 781 , 776 , 781 , 776 , 781 , 
line 91333: 776 , 768 , 768 , 961 , 794 , 782 , 792 , 790 , 799 , 961 , 
line 91334: 719 , 652 , 652 , 641 , 641 , 641 , 641 , 958 , 958 , 953 , 
line 91335: 703 , 703 , 685 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 
line 91336: 887 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 
line 91337: 961 , 961 , 961 , 961 , 637 , 948 , 961 , 961 , 945 , 961 , 
line 91338: 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 
line 91339: 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 917 , 
line 91340: 961 , 961 , 961 , 961 , 961 , 961 , 910 , 909 , 961 , 961 , 
line 91341: 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 
line 91342: 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 
line 91343: 961 , 961 , 961 , 961 , 791 , 961 , 783 , 961 , 871 , 961 , 
line 91344: 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 961 , 746 , 
line 91345: 820 , 961 , 819 , 823 , 818 , 669 , 961 , 650 , 961 , 633 , 
line 91346: 638 , 957 , 960 , 959 , 956 , 955 , 954 , 949 , 947 , 944 , 
line 91347: 943 , 942 , 940 , 937 , 933 , 891 , 889 , 896 , 895 , 894 , 
line 91348: 893 , 892 , 890 , 888 , 886 , 806 , 804 , 801 , 798 , 932 , 
line 91349: 884 , 742 , 739 , 738 , 658 , 950 , 916 , 925 , 923 , 812 , 
line 91350: 922 , 921 , 920 , 918 , 915 , 902 , 808 , 807 , 734 , 876 , 
line 91351: 875 , 661 , 906 , 905 , 904 , 908 , 912 , 903 , 770 , 660 , 
line 91352: 657 , 666 , 723 , 722 , 730 , 728 , 727 , 726 , 725 , 724 , 
line 91353: 721 , 668 , 676 , 687 , 715 , 700 , 699 , 881 , 883 , 880 , 
line 91354: 879 , 708 , 707 , 713 , 712 , 711 , 710 , 709 , 706 , 705 , 
line 91355: 704 , 697 , 696 , 702 , 695 , 718 , 717 , 714 , 694 , 737 , 
line 91356: 736 , 735 , 732 , 693 , 692 , 691 , 823 , 690 , 689 , 829 , 
line 91357: 828 , 816 , 860 , 757 , 756 , 755 , 767 , 766 , 779 , 778 , 
line 91358: 814 , 813 , 780 , 765 , 759 , 758 , 774 , 773 , 772 , 771 , 
line 91359: 763 , 753 , 785 , 788 , 787 , 784 , 845 , 862 , 769 , 859 , 
line 91360: 931 , 930 , 929 , 928 , 927 , 864 , 863 , 830 , 827 , 680 , 
line 91361: 681 , 900 , 898 , 899 , 897 , 683 , 682 , 679 , 678 , 861 , 
line 91362: 748 , 747 , 857 , 854 , 846 , 841 , 858 , 855 , 847 , 842 , 
line 91363: 840 , 839 , 825 , 824 , 822 , 821 , 817 , 826 , 671 , 749 , 
line 91364: 745 , 744 , 815 , 751 , 750 , 688 , 686 , 684 , 665 , 663 , 
line 91365: 656 , 654 , 653 , 655 , 651 , 649 , 648 , 647 , 646 , 645 , 
line 91366: 674 , 673 , 672 , 670 , 669 , 643 , 640 , 639 , 635 , 634 , 
line 91367: 632 , 
line 91368: } ; 
line 91380: # ifdef YYFALLBACK 
line 91381: static const YYCODETYPE yyFallback [ ] = { 
line 91382: 0 , 
line 91383: 0 , 
line 91384: 26 , 
line 91385: 26 , 
line 91386: 26 , 
line 91387: 26 , 
line 91388: 0 , 
line 91389: 26 , 
line 91390: 26 , 
line 91391: 26 , 
line 91392: 0 , 
line 91393: 26 , 
line 91394: 26 , 
line 91395: 26 , 
line 91396: 26 , 
line 91397: 0 , 
line 91398: 0 , 
line 91399: 0 , 
line 91400: 26 , 
line 91401: 0 , 
line 91402: 0 , 
line 91403: 26 , 
line 91404: 0 , 
line 91405: 0 , 
line 91406: 0 , 
line 91407: 0 , 
line 91408: 0 , 
line 91409: 0 , 
line 91410: 26 , 
line 91411: 26 , 
line 91412: 26 , 
line 91413: 26 , 
line 91414: 26 , 
line 91415: 26 , 
line 91416: 26 , 
line 91417: 26 , 
line 91418: 26 , 
line 91419: 26 , 
line 91420: 26 , 
line 91421: 26 , 
line 91422: 26 , 
line 91423: 26 , 
line 91424: 26 , 
line 91425: 26 , 
line 91426: 26 , 
line 91427: 26 , 
line 91428: 26 , 
line 91429: 26 , 
line 91430: 26 , 
line 91431: 26 , 
line 91432: 26 , 
line 91433: 26 , 
line 91434: 26 , 
line 91435: 26 , 
line 91436: 26 , 
line 91437: 26 , 
line 91438: 26 , 
line 91439: 26 , 
line 91440: 26 , 
line 91441: 26 , 
line 91442: 26 , 
line 91443: 26 , 
line 91444: 26 , 
line 91445: 26 , 
line 91446: 26 , 
line 91447: 26 , 
line 91448: 26 , 
line 91449: } ; 
line 91450: # endif 
line 91464: struct yyStackEntry { 
line 91465: YYACTIONTYPE stateno ; 
line 91466: YYCODETYPE major ; 
line 91468: YYMINORTYPE minor ; 
line 91470: } ; 
line 91471: typedef struct yyStackEntry yyStackEntry ; 
line 91475: struct yyParser { 
line 91476: int yyidx ; 
line 91477: # ifdef YYTRACKMAXSTACKDEPTH 
line 91478: int yyidxMax ; 
line 91479: # endif 
line 91480: int yyerrcnt ; 
line 91481: sqlite3ParserARG_SDECL 
line 91482: # if YYSTACKDEPTH <= 0 
line 91483: int yystksz ; 
line 91484: yyStackEntry * yystack ; 
line 91485: # else 
line 91486: yyStackEntry yystack [ YYSTACKDEPTH ] ; 
line 91487: # endif 
line 91488: } ; 
line 91489: typedef struct yyParser yyParser ; 
line 91491: # ifndef NDEBUG 
line 91492: static FILE * yyTraceFILE = 0 ; 
line 91493: static char * yyTracePrompt = 0 ; 
line 91494: # endif 
line 91496: # ifndef NDEBUG 
line 91514: SQLITE_PRIVATE void sqlite3ParserTrace ( FILE * TraceFILE , char * zTracePrompt ) { 
line 91515: yyTraceFILE = TraceFILE ; 
line 91516: yyTracePrompt = zTracePrompt ; 
line 91517: if ( yyTraceFILE == 0 ) yyTracePrompt = 0 ; 
line 91518: else if ( yyTracePrompt == 0 ) yyTraceFILE = 0 ; 
line 91519: } 
line 91520: # endif 
line 91522: # ifndef NDEBUG 
line 91525: static const char * const yyTokenName [ ] = { 
line 91526: "$" , "SEMI" , "EXPLAIN" , "QUERY" , 
line 91527: "PLAN" , "BEGIN" , "TRANSACTION" , "DEFERRED" , 
line 91528: "IMMEDIATE" , "EXCLUSIVE" , "COMMIT" , "END" , 
line 91529: "ROLLBACK" , "SAVEPOINT" , "RELEASE" , "TO" , 
line 91530: "TABLE" , "CREATE" , "IF" , "NOT" , 
line 91531: "EXISTS" , "TEMP" , "LP" , "RP" , 
line 91532: "AS" , "COMMA" , "ID" , "INDEXED" , 
line 91533: "ABORT" , "ACTION" , "AFTER" , "ANALYZE" , 
line 91534: "ASC" , "ATTACH" , "BEFORE" , "BY" , 
line 91535: "CASCADE" , "CAST" , "COLUMNKW" , "CONFLICT" , 
line 91536: "DATABASE" , "DESC" , "DETACH" , "EACH" , 
line 91537: "FAIL" , "FOR" , "IGNORE" , "INITIALLY" , 
line 91538: "INSTEAD" , "LIKE_KW" , "MATCH" , "NO" , 
line 91539: "KEY" , "OF" , "OFFSET" , "PRAGMA" , 
line 91540: "RAISE" , "REPLACE" , "RESTRICT" , "ROW" , 
line 91541: "TRIGGER" , "VACUUM" , "VIEW" , "VIRTUAL" , 
line 91542: "REINDEX" , "RENAME" , "CTIME_KW" , "ANY" , 
line 91543: "OR" , "AND" , "IS" , "BETWEEN" , 
line 91544: "IN" , "ISNULL" , "NOTNULL" , "NE" , 
line 91545: "EQ" , "GT" , "LE" , "LT" , 
line 91546: "GE" , "ESCAPE" , "BITAND" , "BITOR" , 
line 91547: "LSHIFT" , "RSHIFT" , "PLUS" , "MINUS" , 
line 91548: "STAR" , "SLASH" , "REM" , "CONCAT" , 
line 91549: "COLLATE" , "BITNOT" , "STRING" , "JOIN_KW" , 
line 91550: "CONSTRAINT" , "DEFAULT" , "NULL" , "PRIMARY" , 
line 91551: "UNIQUE" , "CHECK" , "REFERENCES" , "AUTOINCR" , 
line 91552: "ON" , "INSERT" , "DELETE" , "UPDATE" , 
line 91553: "SET" , "DEFERRABLE" , "FOREIGN" , "DROP" , 
line 91554: "UNION" , "ALL" , "EXCEPT" , "INTERSECT" , 
line 91555: "SELECT" , "DISTINCT" , "DOT" , "FROM" , 
line 91556: "JOIN" , "USING" , "ORDER" , "GROUP" , 
line 91557: "HAVING" , "LIMIT" , "WHERE" , "INTO" , 
line 91558: "VALUES" , "INTEGER" , "FLOAT" , "BLOB" , 
line 91559: "REGISTER" , "VARIABLE" , "CASE" , "WHEN" , 
line 91560: "THEN" , "ELSE" , "INDEX" , "ALTER" , 
line 91561: "ADD" , "error" , "input" , "cmdlist" , 
line 91562: "ecmd" , "explain" , "cmdx" , "cmd" , 
line 91563: "transtype" , "trans_opt" , "nm" , "savepoint_opt" , 
line 91564: "create_table" , "create_table_args" , "createkw" , "temp" , 
line 91565: "ifnotexists" , "dbnm" , "columnlist" , "conslist_opt" , 
line 91566: "select" , "column" , "columnid" , "type" , 
line 91567: "carglist" , "id" , "ids" , "typetoken" , 
line 91568: "typename" , "signed" , "plus_num" , "minus_num" , 
line 91569: "carg" , "ccons" , "term" , "expr" , 
line 91570: "onconf" , "sortorder" , "autoinc" , "idxlist_opt" , 
line 91571: "refargs" , "defer_subclause" , "refarg" , "refact" , 
line 91572: "init_deferred_pred_opt" , "conslist" , "tcons" , "idxlist" , 
line 91573: "defer_subclause_opt" , "orconf" , "resolvetype" , "raisetype" , 
line 91574: "ifexists" , "fullname" , "oneselect" , "multiselect_op" , 
line 91575: "distinct" , "selcollist" , "from" , "where_opt" , 
line 91576: "groupby_opt" , "having_opt" , "orderby_opt" , "limit_opt" , 
line 91577: "sclp" , "as" , "seltablist" , "stl_prefix" , 
line 91578: "joinop" , "indexed_opt" , "on_opt" , "using_opt" , 
line 91579: "joinop2" , "inscollist" , "sortlist" , "sortitem" , 
line 91580: "nexprlist" , "setlist" , "insert_cmd" , "inscollist_opt" , 
line 91581: "itemlist" , "exprlist" , "likeop" , "escape" , 
line 91582: "between_op" , "in_op" , "case_operand" , "case_exprlist" , 
line 91583: "case_else" , "uniqueflag" , "collate" , "nmnum" , 
line 91584: "plus_opt" , "number" , "trigger_decl" , "trigger_cmd_list" , 
line 91585: "trigger_time" , "trigger_event" , "foreach_clause" , "when_clause" , 
line 91586: "trigger_cmd" , "trnm" , "tridxby" , "database_kw_opt" , 
line 91587: "key_opt" , "add_column_fullname" , "kwcolumn_opt" , "create_vtab" , 
line 91588: "vtabarglist" , "vtabarg" , "vtabargtoken" , "lp" , 
line 91589: "anylist" , 
line 91590: } ; 
line 91591: # endif 
line 91593: # ifndef NDEBUG 
line 91596: static const char * const yyRuleName [ ] = { 
line 91597: "input ::= cmdlist" , 
line 91598: "cmdlist ::= cmdlist ecmd" , 
line 91599: "cmdlist ::= ecmd" , 
line 91600: "ecmd ::= SEMI" , 
line 91601: "ecmd ::= explain cmdx SEMI" , 
line 91602: "explain ::=" , 
line 91603: "explain ::= EXPLAIN" , 
line 91604: "explain ::= EXPLAIN QUERY PLAN" , 
line 91605: "cmdx ::= cmd" , 
line 91606: "cmd ::= BEGIN transtype trans_opt" , 
line 91607: "trans_opt ::=" , 
line 91608: "trans_opt ::= TRANSACTION" , 
line 91609: "trans_opt ::= TRANSACTION nm" , 
line 91610: "transtype ::=" , 
line 91611: "transtype ::= DEFERRED" , 
line 91612: "transtype ::= IMMEDIATE" , 
line 91613: "transtype ::= EXCLUSIVE" , 
line 91614: "cmd ::= COMMIT trans_opt" , 
line 91615: "cmd ::= END trans_opt" , 
line 91616: "cmd ::= ROLLBACK trans_opt" , 
line 91617: "savepoint_opt ::= SAVEPOINT" , 
line 91618: "savepoint_opt ::=" , 
line 91619: "cmd ::= SAVEPOINT nm" , 
line 91620: "cmd ::= RELEASE savepoint_opt nm" , 
line 91621: "cmd ::= ROLLBACK trans_opt TO savepoint_opt nm" , 
line 91622: "cmd ::= create_table create_table_args" , 
line 91623: "create_table ::= createkw temp TABLE ifnotexists nm dbnm" , 
line 91624: "createkw ::= CREATE" , 
line 91625: "ifnotexists ::=" , 
line 91626: "ifnotexists ::= IF NOT EXISTS" , 
line 91627: "temp ::= TEMP" , 
line 91628: "temp ::=" , 
line 91629: "create_table_args ::= LP columnlist conslist_opt RP" , 
line 91630: "create_table_args ::= AS select" , 
line 91631: "columnlist ::= columnlist COMMA column" , 
line 91632: "columnlist ::= column" , 
line 91633: "column ::= columnid type carglist" , 
line 91634: "columnid ::= nm" , 
line 91635: "id ::= ID" , 
line 91636: "id ::= INDEXED" , 
line 91637: "ids ::= ID|STRING" , 
line 91638: "nm ::= id" , 
line 91639: "nm ::= STRING" , 
line 91640: "nm ::= JOIN_KW" , 
line 91641: "type ::=" , 
line 91642: "type ::= typetoken" , 
line 91643: "typetoken ::= typename" , 
line 91644: "typetoken ::= typename LP signed RP" , 
line 91645: "typetoken ::= typename LP signed COMMA signed RP" , 
line 91646: "typename ::= ids" , 
line 91647: "typename ::= typename ids" , 
line 91648: "signed ::= plus_num" , 
line 91649: "signed ::= minus_num" , 
line 91650: "carglist ::= carglist carg" , 
line 91651: "carglist ::=" , 
line 91652: "carg ::= CONSTRAINT nm ccons" , 
line 91653: "carg ::= ccons" , 
line 91654: "ccons ::= DEFAULT term" , 
line 91655: "ccons ::= DEFAULT LP expr RP" , 
line 91656: "ccons ::= DEFAULT PLUS term" , 
line 91657: "ccons ::= DEFAULT MINUS term" , 
line 91658: "ccons ::= DEFAULT id" , 
line 91659: "ccons ::= NULL onconf" , 
line 91660: "ccons ::= NOT NULL onconf" , 
line 91661: "ccons ::= PRIMARY KEY sortorder onconf autoinc" , 
line 91662: "ccons ::= UNIQUE onconf" , 
line 91663: "ccons ::= CHECK LP expr RP" , 
line 91664: "ccons ::= REFERENCES nm idxlist_opt refargs" , 
line 91665: "ccons ::= defer_subclause" , 
line 91666: "ccons ::= COLLATE ids" , 
line 91667: "autoinc ::=" , 
line 91668: "autoinc ::= AUTOINCR" , 
line 91669: "refargs ::=" , 
line 91670: "refargs ::= refargs refarg" , 
line 91671: "refarg ::= MATCH nm" , 
line 91672: "refarg ::= ON INSERT refact" , 
line 91673: "refarg ::= ON DELETE refact" , 
line 91674: "refarg ::= ON UPDATE refact" , 
line 91675: "refact ::= SET NULL" , 
line 91676: "refact ::= SET DEFAULT" , 
line 91677: "refact ::= CASCADE" , 
line 91678: "refact ::= RESTRICT" , 
line 91679: "refact ::= NO ACTION" , 
line 91680: "defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt" , 
line 91681: "defer_subclause ::= DEFERRABLE init_deferred_pred_opt" , 
line 91682: "init_deferred_pred_opt ::=" , 
line 91683: "init_deferred_pred_opt ::= INITIALLY DEFERRED" , 
line 91684: "init_deferred_pred_opt ::= INITIALLY IMMEDIATE" , 
line 91685: "conslist_opt ::=" , 
line 91686: "conslist_opt ::= COMMA conslist" , 
line 91687: "conslist ::= conslist COMMA tcons" , 
line 91688: "conslist ::= conslist tcons" , 
line 91689: "conslist ::= tcons" , 
line 91690: "tcons ::= CONSTRAINT nm" , 
line 91691: "tcons ::= PRIMARY KEY LP idxlist autoinc RP onconf" , 
line 91692: "tcons ::= UNIQUE LP idxlist RP onconf" , 
line 91693: "tcons ::= CHECK LP expr RP onconf" , 
line 91694: "tcons ::= FOREIGN KEY LP idxlist RP REFERENCES nm idxlist_opt refargs defer_subclause_opt" , 
line 91695: "defer_subclause_opt ::=" , 
line 91696: "defer_subclause_opt ::= defer_subclause" , 
line 91697: "onconf ::=" , 
line 91698: "onconf ::= ON CONFLICT resolvetype" , 
line 91699: "orconf ::=" , 
line 91700: "orconf ::= OR resolvetype" , 
line 91701: "resolvetype ::= raisetype" , 
line 91702: "resolvetype ::= IGNORE" , 
line 91703: "resolvetype ::= REPLACE" , 
line 91704: "cmd ::= DROP TABLE ifexists fullname" , 
line 91705: "ifexists ::= IF EXISTS" , 
line 91706: "ifexists ::=" , 
line 91707: "cmd ::= createkw temp VIEW ifnotexists nm dbnm AS select" , 
line 91708: "cmd ::= DROP VIEW ifexists fullname" , 
line 91709: "cmd ::= select" , 
line 91710: "select ::= oneselect" , 
line 91711: "select ::= select multiselect_op oneselect" , 
line 91712: "multiselect_op ::= UNION" , 
line 91713: "multiselect_op ::= UNION ALL" , 
line 91714: "multiselect_op ::= EXCEPT|INTERSECT" , 
line 91715: "oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt" , 
line 91716: "distinct ::= DISTINCT" , 
line 91717: "distinct ::= ALL" , 
line 91718: "distinct ::=" , 
line 91719: "sclp ::= selcollist COMMA" , 
line 91720: "sclp ::=" , 
line 91721: "selcollist ::= sclp expr as" , 
line 91722: "selcollist ::= sclp STAR" , 
line 91723: "selcollist ::= sclp nm DOT STAR" , 
line 91724: "as ::= AS nm" , 
line 91725: "as ::= ids" , 
line 91726: "as ::=" , 
line 91727: "from ::=" , 
line 91728: "from ::= FROM seltablist" , 
line 91729: "stl_prefix ::= seltablist joinop" , 
line 91730: "stl_prefix ::=" , 
line 91731: "seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt" , 
line 91732: "seltablist ::= stl_prefix LP select RP as on_opt using_opt" , 
line 91733: "seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt" , 
line 91734: "dbnm ::=" , 
line 91735: "dbnm ::= DOT nm" , 
line 91736: "fullname ::= nm dbnm" , 
line 91737: "joinop ::= COMMA|JOIN" , 
line 91738: "joinop ::= JOIN_KW JOIN" , 
line 91739: "joinop ::= JOIN_KW nm JOIN" , 
line 91740: "joinop ::= JOIN_KW nm nm JOIN" , 
line 91741: "on_opt ::= ON expr" , 
line 91742: "on_opt ::=" , 
line 91743: "indexed_opt ::=" , 
line 91744: "indexed_opt ::= INDEXED BY nm" , 
line 91745: "indexed_opt ::= NOT INDEXED" , 
line 91746: "using_opt ::= USING LP inscollist RP" , 
line 91747: "using_opt ::=" , 
line 91748: "orderby_opt ::=" , 
line 91749: "orderby_opt ::= ORDER BY sortlist" , 
line 91750: "sortlist ::= sortlist COMMA sortitem sortorder" , 
line 91751: "sortlist ::= sortitem sortorder" , 
line 91752: "sortitem ::= expr" , 
line 91753: "sortorder ::= ASC" , 
line 91754: "sortorder ::= DESC" , 
line 91755: "sortorder ::=" , 
line 91756: "groupby_opt ::=" , 
line 91757: "groupby_opt ::= GROUP BY nexprlist" , 
line 91758: "having_opt ::=" , 
line 91759: "having_opt ::= HAVING expr" , 
line 91760: "limit_opt ::=" , 
line 91761: "limit_opt ::= LIMIT expr" , 
line 91762: "limit_opt ::= LIMIT expr OFFSET expr" , 
line 91763: "limit_opt ::= LIMIT expr COMMA expr" , 
line 91764: "cmd ::= DELETE FROM fullname indexed_opt where_opt" , 
line 91765: "where_opt ::=" , 
line 91766: "where_opt ::= WHERE expr" , 
line 91767: "cmd ::= UPDATE orconf fullname indexed_opt SET setlist where_opt" , 
line 91768: "setlist ::= setlist COMMA nm EQ expr" , 
line 91769: "setlist ::= nm EQ expr" , 
line 91770: "cmd ::= insert_cmd INTO fullname inscollist_opt VALUES LP itemlist RP" , 
line 91771: "cmd ::= insert_cmd INTO fullname inscollist_opt select" , 
line 91772: "cmd ::= insert_cmd INTO fullname inscollist_opt DEFAULT VALUES" , 
line 91773: "insert_cmd ::= INSERT orconf" , 
line 91774: "insert_cmd ::= REPLACE" , 
line 91775: "itemlist ::= itemlist COMMA expr" , 
line 91776: "itemlist ::= expr" , 
line 91777: "inscollist_opt ::=" , 
line 91778: "inscollist_opt ::= LP inscollist RP" , 
line 91779: "inscollist ::= inscollist COMMA nm" , 
line 91780: "inscollist ::= nm" , 
line 91781: "expr ::= term" , 
line 91782: "expr ::= LP expr RP" , 
line 91783: "term ::= NULL" , 
line 91784: "expr ::= id" , 
line 91785: "expr ::= JOIN_KW" , 
line 91786: "expr ::= nm DOT nm" , 
line 91787: "expr ::= nm DOT nm DOT nm" , 
line 91788: "term ::= INTEGER|FLOAT|BLOB" , 
line 91789: "term ::= STRING" , 
line 91790: "expr ::= REGISTER" , 
line 91791: "expr ::= VARIABLE" , 
line 91792: "expr ::= expr COLLATE ids" , 
line 91793: "expr ::= CAST LP expr AS typetoken RP" , 
line 91794: "expr ::= ID LP distinct exprlist RP" , 
line 91795: "expr ::= ID LP STAR RP" , 
line 91796: "term ::= CTIME_KW" , 
line 91797: "expr ::= expr AND expr" , 
line 91798: "expr ::= expr OR expr" , 
line 91799: "expr ::= expr LT|GT|GE|LE expr" , 
line 91800: "expr ::= expr EQ|NE expr" , 
line 91801: "expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr" , 
line 91802: "expr ::= expr PLUS|MINUS expr" , 
line 91803: "expr ::= expr STAR|SLASH|REM expr" , 
line 91804: "expr ::= expr CONCAT expr" , 
line 91805: "likeop ::= LIKE_KW" , 
line 91806: "likeop ::= NOT LIKE_KW" , 
line 91807: "likeop ::= MATCH" , 
line 91808: "likeop ::= NOT MATCH" , 
line 91809: "escape ::= ESCAPE expr" , 
line 91810: "escape ::=" , 
line 91811: "expr ::= expr likeop expr escape" , 
line 91812: "expr ::= expr ISNULL|NOTNULL" , 
line 91813: "expr ::= expr NOT NULL" , 
line 91814: "expr ::= expr IS expr" , 
line 91815: "expr ::= expr IS NOT expr" , 
line 91816: "expr ::= NOT expr" , 
line 91817: "expr ::= BITNOT expr" , 
line 91818: "expr ::= MINUS expr" , 
line 91819: "expr ::= PLUS expr" , 
line 91820: "between_op ::= BETWEEN" , 
line 91821: "between_op ::= NOT BETWEEN" , 
line 91822: "expr ::= expr between_op expr AND expr" , 
line 91823: "in_op ::= IN" , 
line 91824: "in_op ::= NOT IN" , 
line 91825: "expr ::= expr in_op LP exprlist RP" , 
line 91826: "expr ::= LP select RP" , 
line 91827: "expr ::= expr in_op LP select RP" , 
line 91828: "expr ::= expr in_op nm dbnm" , 
line 91829: "expr ::= EXISTS LP select RP" , 
line 91830: "expr ::= CASE case_operand case_exprlist case_else END" , 
line 91831: "case_exprlist ::= case_exprlist WHEN expr THEN expr" , 
line 91832: "case_exprlist ::= WHEN expr THEN expr" , 
line 91833: "case_else ::= ELSE expr" , 
line 91834: "case_else ::=" , 
line 91835: "case_operand ::= expr" , 
line 91836: "case_operand ::=" , 
line 91837: "exprlist ::= nexprlist" , 
line 91838: "exprlist ::=" , 
line 91839: "nexprlist ::= nexprlist COMMA expr" , 
line 91840: "nexprlist ::= expr" , 
line 91841: "cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP idxlist RP" , 
line 91842: "uniqueflag ::= UNIQUE" , 
line 91843: "uniqueflag ::=" , 
line 91844: "idxlist_opt ::=" , 
line 91845: "idxlist_opt ::= LP idxlist RP" , 
line 91846: "idxlist ::= idxlist COMMA nm collate sortorder" , 
line 91847: "idxlist ::= nm collate sortorder" , 
line 91848: "collate ::=" , 
line 91849: "collate ::= COLLATE ids" , 
line 91850: "cmd ::= DROP INDEX ifexists fullname" , 
line 91851: "cmd ::= VACUUM" , 
line 91852: "cmd ::= VACUUM nm" , 
line 91853: "cmd ::= PRAGMA nm dbnm" , 
line 91854: "cmd ::= PRAGMA nm dbnm EQ nmnum" , 
line 91855: "cmd ::= PRAGMA nm dbnm LP nmnum RP" , 
line 91856: "cmd ::= PRAGMA nm dbnm EQ minus_num" , 
line 91857: "cmd ::= PRAGMA nm dbnm LP minus_num RP" , 
line 91858: "nmnum ::= plus_num" , 
line 91859: "nmnum ::= nm" , 
line 91860: "nmnum ::= ON" , 
line 91861: "nmnum ::= DELETE" , 
line 91862: "nmnum ::= DEFAULT" , 
line 91863: "plus_num ::= plus_opt number" , 
line 91864: "minus_num ::= MINUS number" , 
line 91865: "number ::= INTEGER|FLOAT" , 
line 91866: "plus_opt ::= PLUS" , 
line 91867: "plus_opt ::=" , 
line 91868: "cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END" , 
line 91869: "trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause" , 
line 91870: "trigger_time ::= BEFORE" , 
line 91871: "trigger_time ::= AFTER" , 
line 91872: "trigger_time ::= INSTEAD OF" , 
line 91873: "trigger_time ::=" , 
line 91874: "trigger_event ::= DELETE|INSERT" , 
line 91875: "trigger_event ::= UPDATE" , 
line 91876: "trigger_event ::= UPDATE OF inscollist" , 
line 91877: "foreach_clause ::=" , 
line 91878: "foreach_clause ::= FOR EACH ROW" , 
line 91879: "when_clause ::=" , 
line 91880: "when_clause ::= WHEN expr" , 
line 91881: "trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI" , 
line 91882: "trigger_cmd_list ::= trigger_cmd SEMI" , 
line 91883: "trnm ::= nm" , 
line 91884: "trnm ::= nm DOT nm" , 
line 91885: "tridxby ::=" , 
line 91886: "tridxby ::= INDEXED BY nm" , 
line 91887: "tridxby ::= NOT INDEXED" , 
line 91888: "trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt" , 
line 91889: "trigger_cmd ::= insert_cmd INTO trnm inscollist_opt VALUES LP itemlist RP" , 
line 91890: "trigger_cmd ::= insert_cmd INTO trnm inscollist_opt select" , 
line 91891: "trigger_cmd ::= DELETE FROM trnm tridxby where_opt" , 
line 91892: "trigger_cmd ::= select" , 
line 91893: "expr ::= RAISE LP IGNORE RP" , 
line 91894: "expr ::= RAISE LP raisetype COMMA nm RP" , 
line 91895: "raisetype ::= ROLLBACK" , 
line 91896: "raisetype ::= ABORT" , 
line 91897: "raisetype ::= FAIL" , 
line 91898: "cmd ::= DROP TRIGGER ifexists fullname" , 
line 91899: "cmd ::= ATTACH database_kw_opt expr AS expr key_opt" , 
line 91900: "cmd ::= DETACH database_kw_opt expr" , 
line 91901: "key_opt ::=" , 
line 91902: "key_opt ::= KEY expr" , 
line 91903: "database_kw_opt ::= DATABASE" , 
line 91904: "database_kw_opt ::=" , 
line 91905: "cmd ::= REINDEX" , 
line 91906: "cmd ::= REINDEX nm dbnm" , 
line 91907: "cmd ::= ANALYZE" , 
line 91908: "cmd ::= ANALYZE nm dbnm" , 
line 91909: "cmd ::= ALTER TABLE fullname RENAME TO nm" , 
line 91910: "cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column" , 
line 91911: "add_column_fullname ::= fullname" , 
line 91912: "kwcolumn_opt ::=" , 
line 91913: "kwcolumn_opt ::= COLUMNKW" , 
line 91914: "cmd ::= create_vtab" , 
line 91915: "cmd ::= create_vtab LP vtabarglist RP" , 
line 91916: "create_vtab ::= createkw VIRTUAL TABLE nm dbnm USING nm" , 
line 91917: "vtabarglist ::= vtabarg" , 
line 91918: "vtabarglist ::= vtabarglist COMMA vtabarg" , 
line 91919: "vtabarg ::=" , 
line 91920: "vtabarg ::= vtabarg vtabargtoken" , 
line 91921: "vtabargtoken ::= ANY" , 
line 91922: "vtabargtoken ::= lp anylist RP" , 
line 91923: "lp ::= LP" , 
line 91924: "anylist ::=" , 
line 91925: "anylist ::= anylist LP anylist RP" , 
line 91926: "anylist ::= anylist ANY" , 
line 91927: } ; 
line 91928: # endif 
line 91931: # if YYSTACKDEPTH <= 0 
line 91935: static void yyGrowStack ( yyParser * p ) { 
line 91936: int newSize ; 
line 91937: yyStackEntry * pNew ; 
line 91939: newSize = p -> yystksz * 2 + 100 ; 
line 91940: pNew = realloc ( p -> yystack , newSize * sizeof ( pNew [ 0 ] ) ) ; 
line 91941: if ( pNew ) { 
line 91942: p -> yystack = pNew ; 
line 91943: p -> yystksz = newSize ; 
line 91944: # ifndef NDEBUG 
line 91945: if ( yyTraceFILE ) { 
line 91946: fprintf ( yyTraceFILE , "%sStack grows to %d entries!\n" , 
line 91947: yyTracePrompt , p -> yystksz ) ; 
line 91948: } 
line 91949: # endif 
line 91950: } 
line 91951: } 
line 91952: # endif 
line 91966: SQLITE_PRIVATE void * sqlite3ParserAlloc ( void * ( * mallocProc ) ( size_t ) ) { 
line 91967: yyParser * pParser ; 
line 91968: pParser = ( yyParser * ) ( * mallocProc ) ( ( size_t ) sizeof ( yyParser ) ) ; 
line 91969: if ( pParser ) { 
line 91970: pParser -> yyidx = - 1 ; 
line 91971: # ifdef YYTRACKMAXSTACKDEPTH 
line 91972: pParser -> yyidxMax = 0 ; 
line 91973: # endif 
line 91974: # if YYSTACKDEPTH <= 0 
line 91975: pParser -> yystack = NULL ; 
line 91976: pParser -> yystksz = 0 ; 
line 91977: yyGrowStack ( pParser ) ; 
line 91978: # endif 
line 91979: } 
line 91980: return pParser ; 
line 91981: } 
line 91988: static void yy_destructor ( 
line 91989: yyParser * yypParser , 
line 91990: YYCODETYPE yymajor , 
line 91991: YYMINORTYPE * yypminor 
line 91992: ) { 
line 91993: sqlite3ParserARG_FETCH ; 
line 91994: switch ( yymajor ) { 
line 92005: case 160 : 
line 92006: case 194 : 
line 92007: { 
line 92008: sqlite3SelectDelete ( pParse -> db , ( yypminor -> yy3 ) ) ; 
line 92009: } 
line 92010: break ; 
line 92011: case 174 : 
line 92012: case 175 : 
line 92013: case 223 : 
line 92014: { 
line 92015: sqlite3ExprDelete ( pParse -> db , ( yypminor -> yy346 ) . pExpr ) ; 
line 92016: } 
line 92017: break ; 
line 92018: case 179 : 
line 92019: case 187 : 
line 92020: case 197 : 
line 92021: case 200 : 
line 92022: case 202 : 
line 92023: case 204 : 
line 92024: case 214 : 
line 92025: case 216 : 
line 92026: case 217 : 
line 92027: case 220 : 
line 92028: case 221 : 
line 92029: case 227 : 
line 92030: { 
line 92031: sqlite3ExprListDelete ( pParse -> db , ( yypminor -> yy14 ) ) ; 
line 92032: } 
line 92033: break ; 
line 92034: case 193 : 
line 92035: case 198 : 
line 92036: case 206 : 
line 92037: case 207 : 
line 92038: { 
line 92039: sqlite3SrcListDelete ( pParse -> db , ( yypminor -> yy65 ) ) ; 
line 92040: } 
line 92041: break ; 
line 92042: case 199 : 
line 92043: case 201 : 
line 92044: case 210 : 
line 92045: case 215 : 
line 92046: case 226 : 
line 92047: case 228 : 
line 92048: case 239 : 
line 92049: case 244 : 
line 92050: { 
line 92051: sqlite3ExprDelete ( pParse -> db , ( yypminor -> yy132 ) ) ; 
line 92052: } 
line 92053: break ; 
line 92054: case 211 : 
line 92055: case 213 : 
line 92056: case 219 : 
line 92057: { 
line 92058: sqlite3IdListDelete ( pParse -> db , ( yypminor -> yy408 ) ) ; 
line 92059: } 
line 92060: break ; 
line 92061: case 235 : 
line 92062: case 240 : 
line 92063: { 
line 92064: sqlite3DeleteTriggerStep ( pParse -> db , ( yypminor -> yy473 ) ) ; 
line 92065: } 
line 92066: break ; 
line 92067: case 237 : 
line 92068: { 
line 92069: sqlite3IdListDelete ( pParse -> db , ( yypminor -> yy378 ) . b ) ; 
line 92070: } 
line 92071: break ; 
line 92072: default : break ; 
line 92073: } 
line 92074: } 
line 92084: static int yy_pop_parser_stack ( yyParser * pParser ) { 
line 92085: YYCODETYPE yymajor ; 
line 92086: yyStackEntry * yytos = & pParser -> yystack [ pParser -> yyidx ] ; 
line 92090: if ( NEVER ( pParser -> yyidx < 0 ) ) return 0 ; 
line 92091: # ifndef NDEBUG 
line 92092: if ( yyTraceFILE && pParser -> yyidx >= 0 ) { 
line 92093: fprintf ( yyTraceFILE , "%sPopping %s\n" , 
line 92094: yyTracePrompt , 
line 92095: yyTokenName [ yytos -> major ] ) ; 
line 92096: } 
line 92097: # endif 
line 92098: yymajor = yytos -> major ; 
line 92099: yy_destructor ( pParser , yymajor , & yytos -> minor ) ; 
line 92100: pParser -> yyidx -- ; 
line 92101: return yymajor ; 
line 92102: } 
line 92116: SQLITE_PRIVATE void sqlite3ParserFree ( 
line 92117: void * p , 
line 92118: void ( * freeProc ) ( void * ) 
line 92119: ) { 
line 92120: yyParser * pParser = ( yyParser * ) p ; 
line 92123: if ( NEVER ( pParser == 0 ) ) return ; 
line 92124: while ( pParser -> yyidx >= 0 ) yy_pop_parser_stack ( pParser ) ; 
line 92125: # if YYSTACKDEPTH <= 0 
line 92126: free ( pParser -> yystack ) ; 
line 92127: # endif 
line 92128: ( * freeProc ) ( ( void * ) pParser ) ; 
line 92129: } 
line 92134: # ifdef YYTRACKMAXSTACKDEPTH 
line 92135: SQLITE_PRIVATE int sqlite3ParserStackPeak ( void * p ) { 
line 92136: yyParser * pParser = ( yyParser * ) p ; 
line 92137: return pParser -> yyidxMax ; 
line 92138: } 
line 92139: # endif 
line 92149: static int yy_find_shift_action ( 
line 92150: yyParser * pParser , 
line 92151: YYCODETYPE iLookAhead 
line 92152: ) { 
line 92153: int i ; 
line 92154: int stateno = pParser -> yystack [ pParser -> yyidx ] . stateno ; 
line 92156: if ( stateno > YY_SHIFT_COUNT 
line 92157: || ( i = yy_shift_ofst [ stateno ] ) == YY_SHIFT_USE_DFLT ) { 
line 92158: return yy_default [ stateno ] ; 
line 92159: } 
line 92160: assert ( iLookAhead != YYNOCODE ) ; 
line 92161: i += iLookAhead ; 
line 92162: if ( i < 0 || i >= YY_ACTTAB_COUNT || yy_lookahead [ i ] != iLookAhead ) { 
line 92163: if ( iLookAhead > 0 ) { 
line 92164: # ifdef YYFALLBACK 
line 92165: YYCODETYPE iFallback ; 
line 92166: if ( iLookAhead < sizeof ( yyFallback ) / sizeof ( yyFallback [ 0 ] ) 
line 92167: && ( iFallback = yyFallback [ iLookAhead ] ) != 0 ) { 
line 92168: # ifndef NDEBUG 
line 92169: if ( yyTraceFILE ) { 
line 92170: fprintf ( yyTraceFILE , "%sFALLBACK %s => %s\n" , 
line 92171: yyTracePrompt , yyTokenName [ iLookAhead ] , yyTokenName [ iFallback ] ) ; 
line 92172: } 
line 92173: # endif 
line 92174: return yy_find_shift_action ( pParser , iFallback ) ; 
line 92175: } 
line 92176: # endif 
line 92177: # ifdef YYWILDCARD 
line 92178: { 
line 92179: int j = i - iLookAhead + YYWILDCARD ; 
line 92180: if ( 
line 92181: # if YY_SHIFT_MIN + YYWILDCARD < 0 
line 92182: j >= 0 && 
line 92183: # endif 
line 92184: # if YY_SHIFT_MAX + YYWILDCARD >= YY_ACTTAB_COUNT 
line 92185: j < YY_ACTTAB_COUNT && 
line 92186: # endif 
line 92187: yy_lookahead [ j ] == YYWILDCARD 
line 92188: ) { 
line 92189: # ifndef NDEBUG 
line 92190: if ( yyTraceFILE ) { 
line 92191: fprintf ( yyTraceFILE , "%sWILDCARD %s => %s\n" , 
line 92192: yyTracePrompt , yyTokenName [ iLookAhead ] , yyTokenName [ YYWILDCARD ] ) ; 
line 92193: } 
line 92194: # endif 
line 92195: return yy_action [ j ] ; 
line 92196: } 
line 92197: } 
line 92198: # endif 
line 92199: } 
line 92200: return yy_default [ stateno ] ; 
line 92201: } else { 
line 92202: return yy_action [ i ] ; 
line 92203: } 
line 92204: } 
line 92214: static int yy_find_reduce_action ( 
line 92215: int stateno , 
line 92216: YYCODETYPE iLookAhead 
line 92217: ) { 
line 92218: int i ; 
line 92219: # ifdef YYERRORSYMBOL 
line 92220: if ( stateno > YY_REDUCE_COUNT ) { 
line 92221: return yy_default [ stateno ] ; 
line 92222: } 
line 92223: # else 
line 92224: assert ( stateno <= YY_REDUCE_COUNT ) ; 
line 92225: # endif 
line 92226: i = yy_reduce_ofst [ stateno ] ; 
line 92227: assert ( i != YY_REDUCE_USE_DFLT ) ; 
line 92228: assert ( iLookAhead != YYNOCODE ) ; 
line 92229: i += iLookAhead ; 
line 92230: # ifdef YYERRORSYMBOL 
line 92231: if ( i < 0 || i >= YY_ACTTAB_COUNT || yy_lookahead [ i ] != iLookAhead ) { 
line 92232: return yy_default [ stateno ] ; 
line 92233: } 
line 92234: # else 
line 92235: assert ( i >= 0 && i < YY_ACTTAB_COUNT ) ; 
line 92236: assert ( yy_lookahead [ i ] == iLookAhead ) ; 
line 92237: # endif 
line 92238: return yy_action [ i ] ; 
line 92239: } 
line 92244: static void yyStackOverflow ( yyParser * yypParser , YYMINORTYPE * yypMinor ) { 
line 92245: sqlite3ParserARG_FETCH ; 
line 92246: yypParser -> yyidx -- ; 
line 92247: # ifndef NDEBUG 
line 92248: if ( yyTraceFILE ) { 
line 92249: fprintf ( yyTraceFILE , "%sStack Overflow!\n" , yyTracePrompt ) ; 
line 92250: } 
line 92251: # endif 
line 92252: while ( yypParser -> yyidx >= 0 ) yy_pop_parser_stack ( yypParser ) ; 
line 92256: UNUSED_PARAMETER ( yypMinor ) ; 
line 92257: sqlite3ErrorMsg ( pParse , "parser stack overflow" ) ; 
line 92258: pParse -> parseError = 1 ; 
line 92259: sqlite3ParserARG_STORE ; 
line 92260: } 
line 92265: static void yy_shift ( 
line 92266: yyParser * yypParser , 
line 92267: int yyNewState , 
line 92268: int yyMajor , 
line 92269: YYMINORTYPE * yypMinor 
line 92270: ) { 
line 92271: yyStackEntry * yytos ; 
line 92272: yypParser -> yyidx ++ ; 
line 92273: # ifdef YYTRACKMAXSTACKDEPTH 
line 92274: if ( yypParser -> yyidx > yypParser -> yyidxMax ) { 
line 92275: yypParser -> yyidxMax = yypParser -> yyidx ; 
line 92276: } 
line 92277: # endif 
line 92278: # if YYSTACKDEPTH > 0 
line 92279: if ( yypParser -> yyidx >= YYSTACKDEPTH ) { 
line 92280: yyStackOverflow ( yypParser , yypMinor ) ; 
line 92281: return ; 
line 92282: } 
line 92283: # else 
line 92284: if ( yypParser -> yyidx >= yypParser -> yystksz ) { 
line 92285: yyGrowStack ( yypParser ) ; 
line 92286: if ( yypParser -> yyidx >= yypParser -> yystksz ) { 
line 92287: yyStackOverflow ( yypParser , yypMinor ) ; 
line 92288: return ; 
line 92289: } 
line 92290: } 
line 92291: # endif 
line 92292: yytos = & yypParser -> yystack [ yypParser -> yyidx ] ; 
line 92293: yytos -> stateno = ( YYACTIONTYPE ) yyNewState ; 
line 92294: yytos -> major = ( YYCODETYPE ) yyMajor ; 
line 92295: yytos -> minor = * yypMinor ; 
line 92296: # ifndef NDEBUG 
line 92297: if ( yyTraceFILE && yypParser -> yyidx > 0 ) { 
line 92298: int i ; 
line 92299: fprintf ( yyTraceFILE , "%sShift %d\n" , yyTracePrompt , yyNewState ) ; 
line 92300: fprintf ( yyTraceFILE , "%sStack:" , yyTracePrompt ) ; 
line 92301: for ( i = 1 ; i <= yypParser -> yyidx ; i ++ ) 
line 92302: fprintf ( yyTraceFILE , " %s" , yyTokenName [ yypParser -> yystack [ i ] . major ] ) ; 
line 92303: fprintf ( yyTraceFILE , "\n" ) ; 
line 92304: } 
line 92305: # endif 
line 92306: } 
line 92311: static const struct { 
line 92312: YYCODETYPE lhs ; 
line 92313: unsigned char nrhs ; 
line 92314: } yyRuleInfo [ ] = { 
line 92315: { 142 , 1 } , 
line 92316: { 143 , 2 } , 
line 92317: { 143 , 1 } , 
line 92318: { 144 , 1 } , 
line 92319: { 144 , 3 } , 
line 92320: { 145 , 0 } , 
line 92321: { 145 , 1 } , 
line 92322: { 145 , 3 } , 
line 92323: { 146 , 1 } , 
line 92324: { 147 , 3 } , 
line 92325: { 149 , 0 } , 
line 92326: { 149 , 1 } , 
line 92327: { 149 , 2 } , 
line 92328: { 148 , 0 } , 
line 92329: { 148 , 1 } , 
line 92330: { 148 , 1 } , 
line 92331: { 148 , 1 } , 
line 92332: { 147 , 2 } , 
line 92333: { 147 , 2 } , 
line 92334: { 147 , 2 } , 
line 92335: { 151 , 1 } , 
line 92336: { 151 , 0 } , 
line 92337: { 147 , 2 } , 
line 92338: { 147 , 3 } , 
line 92339: { 147 , 5 } , 
line 92340: { 147 , 2 } , 
line 92341: { 152 , 6 } , 
line 92342: { 154 , 1 } , 
line 92343: { 156 , 0 } , 
line 92344: { 156 , 3 } , 
line 92345: { 155 , 1 } , 
line 92346: { 155 , 0 } , 
line 92347: { 153 , 4 } , 
line 92348: { 153 , 2 } , 
line 92349: { 158 , 3 } , 
line 92350: { 158 , 1 } , 
line 92351: { 161 , 3 } , 
line 92352: { 162 , 1 } , 
line 92353: { 165 , 1 } , 
line 92354: { 165 , 1 } , 
line 92355: { 166 , 1 } , 
line 92356: { 150 , 1 } , 
line 92357: { 150 , 1 } , 
line 92358: { 150 , 1 } , 
line 92359: { 163 , 0 } , 
line 92360: { 163 , 1 } , 
line 92361: { 167 , 1 } , 
line 92362: { 167 , 4 } , 
line 92363: { 167 , 6 } , 
line 92364: { 168 , 1 } , 
line 92365: { 168 , 2 } , 
line 92366: { 169 , 1 } , 
line 92367: { 169 , 1 } , 
line 92368: { 164 , 2 } , 
line 92369: { 164 , 0 } , 
line 92370: { 172 , 3 } , 
line 92371: { 172 , 1 } , 
line 92372: { 173 , 2 } , 
line 92373: { 173 , 4 } , 
line 92374: { 173 , 3 } , 
line 92375: { 173 , 3 } , 
line 92376: { 173 , 2 } , 
line 92377: { 173 , 2 } , 
line 92378: { 173 , 3 } , 
line 92379: { 173 , 5 } , 
line 92380: { 173 , 2 } , 
line 92381: { 173 , 4 } , 
line 92382: { 173 , 4 } , 
line 92383: { 173 , 1 } , 
line 92384: { 173 , 2 } , 
line 92385: { 178 , 0 } , 
line 92386: { 178 , 1 } , 
line 92387: { 180 , 0 } , 
line 92388: { 180 , 2 } , 
line 92389: { 182 , 2 } , 
line 92390: { 182 , 3 } , 
line 92391: { 182 , 3 } , 
line 92392: { 182 , 3 } , 
line 92393: { 183 , 2 } , 
line 92394: { 183 , 2 } , 
line 92395: { 183 , 1 } , 
line 92396: { 183 , 1 } , 
line 92397: { 183 , 2 } , 
line 92398: { 181 , 3 } , 
line 92399: { 181 , 2 } , 
line 92400: { 184 , 0 } , 
line 92401: { 184 , 2 } , 
line 92402: { 184 , 2 } , 
line 92403: { 159 , 0 } , 
line 92404: { 159 , 2 } , 
line 92405: { 185 , 3 } , 
line 92406: { 185 , 2 } , 
line 92407: { 185 , 1 } , 
line 92408: { 186 , 2 } , 
line 92409: { 186 , 7 } , 
line 92410: { 186 , 5 } , 
line 92411: { 186 , 5 } , 
line 92412: { 186 , 10 } , 
line 92413: { 188 , 0 } , 
line 92414: { 188 , 1 } , 
line 92415: { 176 , 0 } , 
line 92416: { 176 , 3 } , 
line 92417: { 189 , 0 } , 
line 92418: { 189 , 2 } , 
line 92419: { 190 , 1 } , 
line 92420: { 190 , 1 } , 
line 92421: { 190 , 1 } , 
line 92422: { 147 , 4 } , 
line 92423: { 192 , 2 } , 
line 92424: { 192 , 0 } , 
line 92425: { 147 , 8 } , 
line 92426: { 147 , 4 } , 
line 92427: { 147 , 1 } , 
line 92428: { 160 , 1 } , 
line 92429: { 160 , 3 } , 
line 92430: { 195 , 1 } , 
line 92431: { 195 , 2 } , 
line 92432: { 195 , 1 } , 
line 92433: { 194 , 9 } , 
line 92434: { 196 , 1 } , 
line 92435: { 196 , 1 } , 
line 92436: { 196 , 0 } , 
line 92437: { 204 , 2 } , 
line 92438: { 204 , 0 } , 
line 92439: { 197 , 3 } , 
line 92440: { 197 , 2 } , 
line 92441: { 197 , 4 } , 
line 92442: { 205 , 2 } , 
line 92443: { 205 , 1 } , 
line 92444: { 205 , 0 } , 
line 92445: { 198 , 0 } , 
line 92446: { 198 , 2 } , 
line 92447: { 207 , 2 } , 
line 92448: { 207 , 0 } , 
line 92449: { 206 , 7 } , 
line 92450: { 206 , 7 } , 
line 92451: { 206 , 7 } , 
line 92452: { 157 , 0 } , 
line 92453: { 157 , 2 } , 
line 92454: { 193 , 2 } , 
line 92455: { 208 , 1 } , 
line 92456: { 208 , 2 } , 
line 92457: { 208 , 3 } , 
line 92458: { 208 , 4 } , 
line 92459: { 210 , 2 } , 
line 92460: { 210 , 0 } , 
line 92461: { 209 , 0 } , 
line 92462: { 209 , 3 } , 
line 92463: { 209 , 2 } , 
line 92464: { 211 , 4 } , 
line 92465: { 211 , 0 } , 
line 92466: { 202 , 0 } , 
line 92467: { 202 , 3 } , 
line 92468: { 214 , 4 } , 
line 92469: { 214 , 2 } , 
line 92470: { 215 , 1 } , 
line 92471: { 177 , 1 } , 
line 92472: { 177 , 1 } , 
line 92473: { 177 , 0 } , 
line 92474: { 200 , 0 } , 
line 92475: { 200 , 3 } , 
line 92476: { 201 , 0 } , 
line 92477: { 201 , 2 } , 
line 92478: { 203 , 0 } , 
line 92479: { 203 , 2 } , 
line 92480: { 203 , 4 } , 
line 92481: { 203 , 4 } , 
line 92482: { 147 , 5 } , 
line 92483: { 199 , 0 } , 
line 92484: { 199 , 2 } , 
line 92485: { 147 , 7 } , 
line 92486: { 217 , 5 } , 
line 92487: { 217 , 3 } , 
line 92488: { 147 , 8 } , 
line 92489: { 147 , 5 } , 
line 92490: { 147 , 6 } , 
line 92491: { 218 , 2 } , 
line 92492: { 218 , 1 } , 
line 92493: { 220 , 3 } , 
line 92494: { 220 , 1 } , 
line 92495: { 219 , 0 } , 
line 92496: { 219 , 3 } , 
line 92497: { 213 , 3 } , 
line 92498: { 213 , 1 } , 
line 92499: { 175 , 1 } , 
line 92500: { 175 , 3 } , 
line 92501: { 174 , 1 } , 
line 92502: { 175 , 1 } , 
line 92503: { 175 , 1 } , 
line 92504: { 175 , 3 } , 
line 92505: { 175 , 5 } , 
line 92506: { 174 , 1 } , 
line 92507: { 174 , 1 } , 
line 92508: { 175 , 1 } , 
line 92509: { 175 , 1 } , 
line 92510: { 175 , 3 } , 
line 92511: { 175 , 6 } , 
line 92512: { 175 , 5 } , 
line 92513: { 175 , 4 } , 
line 92514: { 174 , 1 } , 
line 92515: { 175 , 3 } , 
line 92516: { 175 , 3 } , 
line 92517: { 175 , 3 } , 
line 92518: { 175 , 3 } , 
line 92519: { 175 , 3 } , 
line 92520: { 175 , 3 } , 
line 92521: { 175 , 3 } , 
line 92522: { 175 , 3 } , 
line 92523: { 222 , 1 } , 
line 92524: { 222 , 2 } , 
line 92525: { 222 , 1 } , 
line 92526: { 222 , 2 } , 
line 92527: { 223 , 2 } , 
line 92528: { 223 , 0 } , 
line 92529: { 175 , 4 } , 
line 92530: { 175 , 2 } , 
line 92531: { 175 , 3 } , 
line 92532: { 175 , 3 } , 
line 92533: { 175 , 4 } , 
line 92534: { 175 , 2 } , 
line 92535: { 175 , 2 } , 
line 92536: { 175 , 2 } , 
line 92537: { 175 , 2 } , 
line 92538: { 224 , 1 } , 
line 92539: { 224 , 2 } , 
line 92540: { 175 , 5 } , 
line 92541: { 225 , 1 } , 
line 92542: { 225 , 2 } , 
line 92543: { 175 , 5 } , 
line 92544: { 175 , 3 } , 
line 92545: { 175 , 5 } , 
line 92546: { 175 , 4 } , 
line 92547: { 175 , 4 } , 
line 92548: { 175 , 5 } , 
line 92549: { 227 , 5 } , 
line 92550: { 227 , 4 } , 
line 92551: { 228 , 2 } , 
line 92552: { 228 , 0 } , 
line 92553: { 226 , 1 } , 
line 92554: { 226 , 0 } , 
line 92555: { 221 , 1 } , 
line 92556: { 221 , 0 } , 
line 92557: { 216 , 3 } , 
line 92558: { 216 , 1 } , 
line 92559: { 147 , 11 } , 
line 92560: { 229 , 1 } , 
line 92561: { 229 , 0 } , 
line 92562: { 179 , 0 } , 
line 92563: { 179 , 3 } , 
line 92564: { 187 , 5 } , 
line 92565: { 187 , 3 } , 
line 92566: { 230 , 0 } , 
line 92567: { 230 , 2 } , 
line 92568: { 147 , 4 } , 
line 92569: { 147 , 1 } , 
line 92570: { 147 , 2 } , 
line 92571: { 147 , 3 } , 
line 92572: { 147 , 5 } , 
line 92573: { 147 , 6 } , 
line 92574: { 147 , 5 } , 
line 92575: { 147 , 6 } , 
line 92576: { 231 , 1 } , 
line 92577: { 231 , 1 } , 
line 92578: { 231 , 1 } , 
line 92579: { 231 , 1 } , 
line 92580: { 231 , 1 } , 
line 92581: { 170 , 2 } , 
line 92582: { 171 , 2 } , 
line 92583: { 233 , 1 } , 
line 92584: { 232 , 1 } , 
line 92585: { 232 , 0 } , 
line 92586: { 147 , 5 } , 
line 92587: { 234 , 11 } , 
line 92588: { 236 , 1 } , 
line 92589: { 236 , 1 } , 
line 92590: { 236 , 2 } , 
line 92591: { 236 , 0 } , 
line 92592: { 237 , 1 } , 
line 92593: { 237 , 1 } , 
line 92594: { 237 , 3 } , 
line 92595: { 238 , 0 } , 
line 92596: { 238 , 3 } , 
line 92597: { 239 , 0 } , 
line 92598: { 239 , 2 } , 
line 92599: { 235 , 3 } , 
line 92600: { 235 , 2 } , 
line 92601: { 241 , 1 } , 
line 92602: { 241 , 3 } , 
line 92603: { 242 , 0 } , 
line 92604: { 242 , 3 } , 
line 92605: { 242 , 2 } , 
line 92606: { 240 , 7 } , 
line 92607: { 240 , 8 } , 
line 92608: { 240 , 5 } , 
line 92609: { 240 , 5 } , 
line 92610: { 240 , 1 } , 
line 92611: { 175 , 4 } , 
line 92612: { 175 , 6 } , 
line 92613: { 191 , 1 } , 
line 92614: { 191 , 1 } , 
line 92615: { 191 , 1 } , 
line 92616: { 147 , 4 } , 
line 92617: { 147 , 6 } , 
line 92618: { 147 , 3 } , 
line 92619: { 244 , 0 } , 
line 92620: { 244 , 2 } , 
line 92621: { 243 , 1 } , 
line 92622: { 243 , 0 } , 
line 92623: { 147 , 1 } , 
line 92624: { 147 , 3 } , 
line 92625: { 147 , 1 } , 
line 92626: { 147 , 3 } , 
line 92627: { 147 , 6 } , 
line 92628: { 147 , 6 } , 
line 92629: { 245 , 1 } , 
line 92630: { 246 , 0 } , 
line 92631: { 246 , 1 } , 
line 92632: { 147 , 1 } , 
line 92633: { 147 , 4 } , 
line 92634: { 247 , 7 } , 
line 92635: { 248 , 1 } , 
line 92636: { 248 , 3 } , 
line 92637: { 249 , 0 } , 
line 92638: { 249 , 2 } , 
line 92639: { 250 , 1 } , 
line 92640: { 250 , 3 } , 
line 92641: { 251 , 1 } , 
line 92642: { 252 , 0 } , 
line 92643: { 252 , 4 } , 
line 92644: { 252 , 2 } , 
line 92645: } ; 
line 92647: static void yy_accept ( yyParser * ) ; 
line 92653: static void yy_reduce ( 
line 92654: yyParser * yypParser , 
line 92655: int yyruleno 
line 92656: ) { 
line 92657: int yygoto ; 
line 92658: int yyact ; 
line 92659: YYMINORTYPE yygotominor ; 
line 92660: yyStackEntry * yymsp ; 
line 92661: int yysize ; 
line 92662: sqlite3ParserARG_FETCH ; 
line 92663: yymsp = & yypParser -> yystack [ yypParser -> yyidx ] ; 
line 92664: # ifndef NDEBUG 
line 92665: if ( yyTraceFILE && yyruleno >= 0 
line 92666: && yyruleno < ( int ) ( sizeof ( yyRuleName ) / sizeof ( yyRuleName [ 0 ] ) ) ) { 
line 92667: fprintf ( yyTraceFILE , "%sReduce [%s].\n" , yyTracePrompt , 
line 92668: yyRuleName [ yyruleno ] ) ; 
line 92669: } 
line 92670: # endif 
line 92687: yygotominor = yyzerominor ; 
line 92690: switch ( yyruleno ) { 
line 92699: case 5 : 
line 92700: { sqlite3BeginParse ( pParse , 0 ) ; } 
line 92701: break ; 
line 92702: case 6 : 
line 92703: { sqlite3BeginParse ( pParse , 1 ) ; } 
line 92704: break ; 
line 92705: case 7 : 
line 92706: { sqlite3BeginParse ( pParse , 2 ) ; } 
line 92707: break ; 
line 92708: case 8 : 
line 92709: { sqlite3FinishCoding ( pParse ) ; } 
line 92710: break ; 
line 92711: case 9 : 
line 92712: { sqlite3BeginTransaction ( pParse , yymsp [ - 1 ] . minor . yy328 ) ; } 
line 92713: break ; 
line 92714: case 13 : 
line 92715: { yygotominor . yy328 = TK_DEFERRED ; } 
line 92716: break ; 
line 92717: case 14 : 
line 92718: case 15 : yytestcase ( yyruleno == 15 ) ; 
line 92719: case 16 : yytestcase ( yyruleno == 16 ) ; 
line 92720: case 115 : yytestcase ( yyruleno == 115 ) ; 
line 92721: case 117 : yytestcase ( yyruleno == 117 ) ; 
line 92722: { yygotominor . yy328 = yymsp [ 0 ] . major ; } 
line 92723: break ; 
line 92724: case 17 : 
line 92725: case 18 : yytestcase ( yyruleno == 18 ) ; 
line 92726: { sqlite3CommitTransaction ( pParse ) ; } 
line 92727: break ; 
line 92728: case 19 : 
line 92729: { sqlite3RollbackTransaction ( pParse ) ; } 
line 92730: break ; 
line 92731: case 22 : 
line 92732: { 
line 92733: sqlite3Savepoint ( pParse , SAVEPOINT_BEGIN , & yymsp [ 0 ] . minor . yy0 ) ; 
line 92734: } 
line 92735: break ; 
line 92736: case 23 : 
line 92737: { 
line 92738: sqlite3Savepoint ( pParse , SAVEPOINT_RELEASE , & yymsp [ 0 ] . minor . yy0 ) ; 
line 92739: } 
line 92740: break ; 
line 92741: case 24 : 
line 92742: { 
line 92743: sqlite3Savepoint ( pParse , SAVEPOINT_ROLLBACK , & yymsp [ 0 ] . minor . yy0 ) ; 
line 92744: } 
line 92745: break ; 
line 92746: case 26 : 
line 92747: { 
line 92748: sqlite3StartTable ( pParse , & yymsp [ - 1 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 , yymsp [ - 4 ] . minor . yy328 , 0 , 0 , yymsp [ - 2 ] . minor . yy328 ) ; 
line 92749: } 
line 92750: break ; 
line 92751: case 27 : 
line 92752: { 
line 92753: pParse -> db -> lookaside . bEnabled = 0 ; 
line 92754: yygotominor . yy0 = yymsp [ 0 ] . minor . yy0 ; 
line 92755: } 
line 92756: break ; 
line 92757: case 28 : 
line 92758: case 31 : yytestcase ( yyruleno == 31 ) ; 
line 92759: case 70 : yytestcase ( yyruleno == 70 ) ; 
line 92760: case 83 : yytestcase ( yyruleno == 83 ) ; 
line 92761: case 85 : yytestcase ( yyruleno == 85 ) ; 
line 92762: case 87 : yytestcase ( yyruleno == 87 ) ; 
line 92763: case 98 : yytestcase ( yyruleno == 98 ) ; 
line 92764: case 109 : yytestcase ( yyruleno == 109 ) ; 
line 92765: case 120 : yytestcase ( yyruleno == 120 ) ; 
line 92766: case 121 : yytestcase ( yyruleno == 121 ) ; 
line 92767: case 223 : yytestcase ( yyruleno == 223 ) ; 
line 92768: case 226 : yytestcase ( yyruleno == 226 ) ; 
line 92769: { yygotominor . yy328 = 0 ; } 
line 92770: break ; 
line 92771: case 29 : 
line 92772: case 30 : yytestcase ( yyruleno == 30 ) ; 
line 92773: case 71 : yytestcase ( yyruleno == 71 ) ; 
line 92774: case 86 : yytestcase ( yyruleno == 86 ) ; 
line 92775: case 108 : yytestcase ( yyruleno == 108 ) ; 
line 92776: case 119 : yytestcase ( yyruleno == 119 ) ; 
line 92777: case 224 : yytestcase ( yyruleno == 224 ) ; 
line 92778: case 227 : yytestcase ( yyruleno == 227 ) ; 
line 92779: { yygotominor . yy328 = 1 ; } 
line 92780: break ; 
line 92781: case 32 : 
line 92782: { 
line 92783: sqlite3EndTable ( pParse , & yymsp [ - 1 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 , 0 ) ; 
line 92784: } 
line 92785: break ; 
line 92786: case 33 : 
line 92787: { 
line 92788: sqlite3EndTable ( pParse , 0 , 0 , yymsp [ 0 ] . minor . yy3 ) ; 
line 92789: sqlite3SelectDelete ( pParse -> db , yymsp [ 0 ] . minor . yy3 ) ; 
line 92790: } 
line 92791: break ; 
line 92792: case 36 : 
line 92793: { 
line 92794: yygotominor . yy0 . z = yymsp [ - 2 ] . minor . yy0 . z ; 
line 92795: yygotominor . yy0 . n = ( int ) ( pParse -> sLastToken . z - yymsp [ - 2 ] . minor . yy0 . z ) + pParse -> sLastToken . n ; 
line 92796: } 
line 92797: break ; 
line 92798: case 37 : 
line 92799: { 
line 92800: sqlite3AddColumn ( pParse , & yymsp [ 0 ] . minor . yy0 ) ; 
line 92801: yygotominor . yy0 = yymsp [ 0 ] . minor . yy0 ; 
line 92802: } 
line 92803: break ; 
line 92804: case 38 : 
line 92805: case 39 : yytestcase ( yyruleno == 39 ) ; 
line 92806: case 40 : yytestcase ( yyruleno == 40 ) ; 
line 92807: case 41 : yytestcase ( yyruleno == 41 ) ; 
line 92808: case 42 : yytestcase ( yyruleno == 42 ) ; 
line 92809: case 43 : yytestcase ( yyruleno == 43 ) ; 
line 92810: case 46 : yytestcase ( yyruleno == 46 ) ; 
line 92811: case 49 : yytestcase ( yyruleno == 49 ) ; 
line 92812: case 127 : yytestcase ( yyruleno == 127 ) ; 
line 92813: case 128 : yytestcase ( yyruleno == 128 ) ; 
line 92814: case 138 : yytestcase ( yyruleno == 138 ) ; 
line 92815: case 147 : yytestcase ( yyruleno == 147 ) ; 
line 92816: case 252 : yytestcase ( yyruleno == 252 ) ; 
line 92817: case 261 : yytestcase ( yyruleno == 261 ) ; 
line 92818: case 262 : yytestcase ( yyruleno == 262 ) ; 
line 92819: case 263 : yytestcase ( yyruleno == 263 ) ; 
line 92820: case 264 : yytestcase ( yyruleno == 264 ) ; 
line 92821: case 265 : yytestcase ( yyruleno == 265 ) ; 
line 92822: case 266 : yytestcase ( yyruleno == 266 ) ; 
line 92823: case 267 : yytestcase ( yyruleno == 267 ) ; 
line 92824: case 268 : yytestcase ( yyruleno == 268 ) ; 
line 92825: case 286 : yytestcase ( yyruleno == 286 ) ; 
line 92826: { yygotominor . yy0 = yymsp [ 0 ] . minor . yy0 ; } 
line 92827: break ; 
line 92828: case 45 : 
line 92829: { sqlite3AddColumnType ( pParse , & yymsp [ 0 ] . minor . yy0 ) ; } 
line 92830: break ; 
line 92831: case 47 : 
line 92832: { 
line 92833: yygotominor . yy0 . z = yymsp [ - 3 ] . minor . yy0 . z ; 
line 92834: yygotominor . yy0 . n = ( int ) ( & yymsp [ 0 ] . minor . yy0 . z [ yymsp [ 0 ] . minor . yy0 . n ] - yymsp [ - 3 ] . minor . yy0 . z ) ; 
line 92835: } 
line 92836: break ; 
line 92837: case 48 : 
line 92838: { 
line 92839: yygotominor . yy0 . z = yymsp [ - 5 ] . minor . yy0 . z ; 
line 92840: yygotominor . yy0 . n = ( int ) ( & yymsp [ 0 ] . minor . yy0 . z [ yymsp [ 0 ] . minor . yy0 . n ] - yymsp [ - 5 ] . minor . yy0 . z ) ; 
line 92841: } 
line 92842: break ; 
line 92843: case 50 : 
line 92844: { yygotominor . yy0 . z = yymsp [ - 1 ] . minor . yy0 . z ; yygotominor . yy0 . n = yymsp [ 0 ] . minor . yy0 . n + ( int ) ( yymsp [ 0 ] . minor . yy0 . z - yymsp [ - 1 ] . minor . yy0 . z ) ; } 
line 92845: break ; 
line 92846: case 57 : 
line 92847: case 59 : yytestcase ( yyruleno == 59 ) ; 
line 92848: { sqlite3AddDefaultValue ( pParse , & yymsp [ 0 ] . minor . yy346 ) ; } 
line 92849: break ; 
line 92850: case 58 : 
line 92851: { sqlite3AddDefaultValue ( pParse , & yymsp [ - 1 ] . minor . yy346 ) ; } 
line 92852: break ; 
line 92853: case 60 : 
line 92854: { 
line 92855: ExprSpan v ; 
line 92856: v . pExpr = sqlite3PExpr ( pParse , TK_UMINUS , yymsp [ 0 ] . minor . yy346 . pExpr , 0 , 0 ) ; 
line 92857: v . zStart = yymsp [ - 1 ] . minor . yy0 . z ; 
line 92858: v . zEnd = yymsp [ 0 ] . minor . yy346 . zEnd ; 
line 92859: sqlite3AddDefaultValue ( pParse , & v ) ; 
line 92860: } 
line 92861: break ; 
line 92862: case 61 : 
line 92863: { 
line 92864: ExprSpan v ; 
line 92865: spanExpr ( & v , pParse , TK_STRING , & yymsp [ 0 ] . minor . yy0 ) ; 
line 92866: sqlite3AddDefaultValue ( pParse , & v ) ; 
line 92867: } 
line 92868: break ; 
line 92869: case 63 : 
line 92870: { sqlite3AddNotNull ( pParse , yymsp [ 0 ] . minor . yy328 ) ; } 
line 92871: break ; 
line 92872: case 64 : 
line 92873: { sqlite3AddPrimaryKey ( pParse , 0 , yymsp [ - 1 ] . minor . yy328 , yymsp [ 0 ] . minor . yy328 , yymsp [ - 2 ] . minor . yy328 ) ; } 
line 92874: break ; 
line 92875: case 65 : 
line 92876: { sqlite3CreateIndex ( pParse , 0 , 0 , 0 , 0 , yymsp [ 0 ] . minor . yy328 , 0 , 0 , 0 , 0 ) ; } 
line 92877: break ; 
line 92878: case 66 : 
line 92879: { sqlite3AddCheckConstraint ( pParse , yymsp [ - 1 ] . minor . yy346 . pExpr ) ; } 
line 92880: break ; 
line 92881: case 67 : 
line 92882: { sqlite3CreateForeignKey ( pParse , 0 , & yymsp [ - 2 ] . minor . yy0 , yymsp [ - 1 ] . minor . yy14 , yymsp [ 0 ] . minor . yy328 ) ; } 
line 92883: break ; 
line 92884: case 68 : 
line 92885: { sqlite3DeferForeignKey ( pParse , yymsp [ 0 ] . minor . yy328 ) ; } 
line 92886: break ; 
line 92887: case 69 : 
line 92888: { sqlite3AddCollateType ( pParse , & yymsp [ 0 ] . minor . yy0 ) ; } 
line 92889: break ; 
line 92890: case 72 : 
line 92891: { yygotominor . yy328 = OE_None * 0x0101 ; } 
line 92892: break ; 
line 92893: case 73 : 
line 92894: { yygotominor . yy328 = ( yymsp [ - 1 ] . minor . yy328 & ~ yymsp [ 0 ] . minor . yy429 . mask ) | yymsp [ 0 ] . minor . yy429 . value ; } 
line 92895: break ; 
line 92896: case 74 : 
line 92897: case 75 : yytestcase ( yyruleno == 75 ) ; 
line 92898: { yygotominor . yy429 . value = 0 ; yygotominor . yy429 . mask = 0x000000 ; } 
line 92899: break ; 
line 92900: case 76 : 
line 92901: { yygotominor . yy429 . value = yymsp [ 0 ] . minor . yy328 ; yygotominor . yy429 . mask = 0x0000ff ; } 
line 92902: break ; 
line 92903: case 77 : 
line 92904: { yygotominor . yy429 . value = yymsp [ 0 ] . minor . yy328 << 8 ; yygotominor . yy429 . mask = 0x00ff00 ; } 
line 92905: break ; 
line 92906: case 78 : 
line 92907: { yygotominor . yy328 = OE_SetNull ; } 
line 92908: break ; 
line 92909: case 79 : 
line 92910: { yygotominor . yy328 = OE_SetDflt ; } 
line 92911: break ; 
line 92912: case 80 : 
line 92913: { yygotominor . yy328 = OE_Cascade ; } 
line 92914: break ; 
line 92915: case 81 : 
line 92916: { yygotominor . yy328 = OE_Restrict ; } 
line 92917: break ; 
line 92918: case 82 : 
line 92919: { yygotominor . yy328 = OE_None ; } 
line 92920: break ; 
line 92921: case 84 : 
line 92922: case 99 : yytestcase ( yyruleno == 99 ) ; 
line 92923: case 101 : yytestcase ( yyruleno == 101 ) ; 
line 92924: case 104 : yytestcase ( yyruleno == 104 ) ; 
line 92925: { yygotominor . yy328 = yymsp [ 0 ] . minor . yy328 ; } 
line 92926: break ; 
line 92927: case 88 : 
line 92928: { yygotominor . yy0 . n = 0 ; yygotominor . yy0 . z = 0 ; } 
line 92929: break ; 
line 92930: case 89 : 
line 92931: { yygotominor . yy0 = yymsp [ - 1 ] . minor . yy0 ; } 
line 92932: break ; 
line 92933: case 94 : 
line 92934: { sqlite3AddPrimaryKey ( pParse , yymsp [ - 3 ] . minor . yy14 , yymsp [ 0 ] . minor . yy328 , yymsp [ - 2 ] . minor . yy328 , 0 ) ; } 
line 92935: break ; 
line 92936: case 95 : 
line 92937: { sqlite3CreateIndex ( pParse , 0 , 0 , 0 , yymsp [ - 2 ] . minor . yy14 , yymsp [ 0 ] . minor . yy328 , 0 , 0 , 0 , 0 ) ; } 
line 92938: break ; 
line 92939: case 96 : 
line 92940: { sqlite3AddCheckConstraint ( pParse , yymsp [ - 2 ] . minor . yy346 . pExpr ) ; } 
line 92941: break ; 
line 92942: case 97 : 
line 92943: { 
line 92944: sqlite3CreateForeignKey ( pParse , yymsp [ - 6 ] . minor . yy14 , & yymsp [ - 3 ] . minor . yy0 , yymsp [ - 2 ] . minor . yy14 , yymsp [ - 1 ] . minor . yy328 ) ; 
line 92945: sqlite3DeferForeignKey ( pParse , yymsp [ 0 ] . minor . yy328 ) ; 
line 92946: } 
line 92947: break ; 
line 92948: case 100 : 
line 92949: { yygotominor . yy328 = OE_Default ; } 
line 92950: break ; 
line 92951: case 102 : 
line 92952: { yygotominor . yy186 = OE_Default ; } 
line 92953: break ; 
line 92954: case 103 : 
line 92955: { yygotominor . yy186 = ( u8 ) yymsp [ 0 ] . minor . yy328 ; } 
line 92956: break ; 
line 92957: case 105 : 
line 92958: { yygotominor . yy328 = OE_Ignore ; } 
line 92959: break ; 
line 92960: case 106 : 
line 92961: { yygotominor . yy328 = OE_Replace ; } 
line 92962: break ; 
line 92963: case 107 : 
line 92964: { 
line 92965: sqlite3DropTable ( pParse , yymsp [ 0 ] . minor . yy65 , 0 , yymsp [ - 1 ] . minor . yy328 ) ; 
line 92966: } 
line 92967: break ; 
line 92968: case 110 : 
line 92969: { 
line 92970: sqlite3CreateView ( pParse , & yymsp [ - 7 ] . minor . yy0 , & yymsp [ - 3 ] . minor . yy0 , & yymsp [ - 2 ] . minor . yy0 , yymsp [ 0 ] . minor . yy3 , yymsp [ - 6 ] . minor . yy328 , yymsp [ - 4 ] . minor . yy328 ) ; 
line 92971: } 
line 92972: break ; 
line 92973: case 111 : 
line 92974: { 
line 92975: sqlite3DropTable ( pParse , yymsp [ 0 ] . minor . yy65 , 1 , yymsp [ - 1 ] . minor . yy328 ) ; 
line 92976: } 
line 92977: break ; 
line 92978: case 112 : 
line 92979: { 
line 92980: SelectDest dest = { SRT_Output , 0 , 0 , 0 , 0 } ; 
line 92981: sqlite3Select ( pParse , yymsp [ 0 ] . minor . yy3 , & dest ) ; 
line 92982: sqlite3SelectDelete ( pParse -> db , yymsp [ 0 ] . minor . yy3 ) ; 
line 92983: } 
line 92984: break ; 
line 92985: case 113 : 
line 92986: { yygotominor . yy3 = yymsp [ 0 ] . minor . yy3 ; } 
line 92987: break ; 
line 92988: case 114 : 
line 92989: { 
line 92990: if ( yymsp [ 0 ] . minor . yy3 ) { 
line 92991: yymsp [ 0 ] . minor . yy3 -> op = ( u8 ) yymsp [ - 1 ] . minor . yy328 ; 
line 92992: yymsp [ 0 ] . minor . yy3 -> pPrior = yymsp [ - 2 ] . minor . yy3 ; 
line 92993: } else { 
line 92994: sqlite3SelectDelete ( pParse -> db , yymsp [ - 2 ] . minor . yy3 ) ; 
line 92995: } 
line 92996: yygotominor . yy3 = yymsp [ 0 ] . minor . yy3 ; 
line 92997: } 
line 92998: break ; 
line 92999: case 116 : 
line 93000: { yygotominor . yy328 = TK_ALL ; } 
line 93001: break ; 
line 93002: case 118 : 
line 93003: { 
line 93004: yygotominor . yy3 = sqlite3SelectNew ( pParse , yymsp [ - 6 ] . minor . yy14 , yymsp [ - 5 ] . minor . yy65 , yymsp [ - 4 ] . minor . yy132 , yymsp [ - 3 ] . minor . yy14 , yymsp [ - 2 ] . minor . yy132 , yymsp [ - 1 ] . minor . yy14 , yymsp [ - 7 ] . minor . yy328 , yymsp [ 0 ] . minor . yy476 . pLimit , yymsp [ 0 ] . minor . yy476 . pOffset ) ; 
line 93005: } 
line 93006: break ; 
line 93007: case 122 : 
line 93008: case 248 : yytestcase ( yyruleno == 248 ) ; 
line 93009: { yygotominor . yy14 = yymsp [ - 1 ] . minor . yy14 ; } 
line 93010: break ; 
line 93011: case 123 : 
line 93012: case 151 : yytestcase ( yyruleno == 151 ) ; 
line 93013: case 159 : yytestcase ( yyruleno == 159 ) ; 
line 93014: case 241 : yytestcase ( yyruleno == 241 ) ; 
line 93015: case 247 : yytestcase ( yyruleno == 247 ) ; 
line 93016: { yygotominor . yy14 = 0 ; } 
line 93017: break ; 
line 93018: case 124 : 
line 93019: { 
line 93020: yygotominor . yy14 = sqlite3ExprListAppend ( pParse , yymsp [ - 2 ] . minor . yy14 , yymsp [ - 1 ] . minor . yy346 . pExpr ) ; 
line 93021: if ( yymsp [ 0 ] . minor . yy0 . n > 0 ) sqlite3ExprListSetName ( pParse , yygotominor . yy14 , & yymsp [ 0 ] . minor . yy0 , 1 ) ; 
line 93022: sqlite3ExprListSetSpan ( pParse , yygotominor . yy14 , & yymsp [ - 1 ] . minor . yy346 ) ; 
line 93023: } 
line 93024: break ; 
line 93025: case 125 : 
line 93026: { 
line 93027: Expr * p = sqlite3Expr ( pParse -> db , TK_ALL , 0 ) ; 
line 93028: yygotominor . yy14 = sqlite3ExprListAppend ( pParse , yymsp [ - 1 ] . minor . yy14 , p ) ; 
line 93029: } 
line 93030: break ; 
line 93031: case 126 : 
line 93032: { 
line 93033: Expr * pRight = sqlite3PExpr ( pParse , TK_ALL , 0 , 0 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93034: Expr * pLeft = sqlite3PExpr ( pParse , TK_ID , 0 , 0 , & yymsp [ - 2 ] . minor . yy0 ) ; 
line 93035: Expr * pDot = sqlite3PExpr ( pParse , TK_DOT , pLeft , pRight , 0 ) ; 
line 93036: yygotominor . yy14 = sqlite3ExprListAppend ( pParse , yymsp [ - 3 ] . minor . yy14 , pDot ) ; 
line 93037: } 
line 93038: break ; 
line 93039: case 129 : 
line 93040: { yygotominor . yy0 . n = 0 ; } 
line 93041: break ; 
line 93042: case 130 : 
line 93043: { yygotominor . yy65 = sqlite3DbMallocZero ( pParse -> db , sizeof ( * yygotominor . yy65 ) ) ; } 
line 93044: break ; 
line 93045: case 131 : 
line 93046: { 
line 93047: yygotominor . yy65 = yymsp [ 0 ] . minor . yy65 ; 
line 93048: sqlite3SrcListShiftJoinType ( yygotominor . yy65 ) ; 
line 93049: } 
line 93050: break ; 
line 93051: case 132 : 
line 93052: { 
line 93053: yygotominor . yy65 = yymsp [ - 1 ] . minor . yy65 ; 
line 93054: if ( ALWAYS ( yygotominor . yy65 && yygotominor . yy65 -> nSrc > 0 ) ) yygotominor . yy65 -> a [ yygotominor . yy65 -> nSrc - 1 ] . jointype = ( u8 ) yymsp [ 0 ] . minor . yy328 ; 
line 93055: } 
line 93056: break ; 
line 93057: case 133 : 
line 93058: { yygotominor . yy65 = 0 ; } 
line 93059: break ; 
line 93060: case 134 : 
line 93061: { 
line 93062: yygotominor . yy65 = sqlite3SrcListAppendFromTerm ( pParse , yymsp [ - 6 ] . minor . yy65 , & yymsp [ - 5 ] . minor . yy0 , & yymsp [ - 4 ] . minor . yy0 , & yymsp [ - 3 ] . minor . yy0 , 0 , yymsp [ - 1 ] . minor . yy132 , yymsp [ 0 ] . minor . yy408 ) ; 
line 93063: sqlite3SrcListIndexedBy ( pParse , yygotominor . yy65 , & yymsp [ - 2 ] . minor . yy0 ) ; 
line 93064: } 
line 93065: break ; 
line 93066: case 135 : 
line 93067: { 
line 93068: yygotominor . yy65 = sqlite3SrcListAppendFromTerm ( pParse , yymsp [ - 6 ] . minor . yy65 , 0 , 0 , & yymsp [ - 2 ] . minor . yy0 , yymsp [ - 4 ] . minor . yy3 , yymsp [ - 1 ] . minor . yy132 , yymsp [ 0 ] . minor . yy408 ) ; 
line 93069: } 
line 93070: break ; 
line 93071: case 136 : 
line 93072: { 
line 93073: if ( yymsp [ - 6 ] . minor . yy65 == 0 && yymsp [ - 2 ] . minor . yy0 . n == 0 && yymsp [ - 1 ] . minor . yy132 == 0 && yymsp [ 0 ] . minor . yy408 == 0 ) { 
line 93074: yygotominor . yy65 = yymsp [ - 4 ] . minor . yy65 ; 
line 93075: } else { 
line 93076: Select * pSubquery ; 
line 93077: sqlite3SrcListShiftJoinType ( yymsp [ - 4 ] . minor . yy65 ) ; 
line 93078: pSubquery = sqlite3SelectNew ( pParse , 0 , yymsp [ - 4 ] . minor . yy65 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) ; 
line 93079: yygotominor . yy65 = sqlite3SrcListAppendFromTerm ( pParse , yymsp [ - 6 ] . minor . yy65 , 0 , 0 , & yymsp [ - 2 ] . minor . yy0 , pSubquery , yymsp [ - 1 ] . minor . yy132 , yymsp [ 0 ] . minor . yy408 ) ; 
line 93080: } 
line 93081: } 
line 93082: break ; 
line 93083: case 137 : 
line 93084: case 146 : yytestcase ( yyruleno == 146 ) ; 
line 93085: { yygotominor . yy0 . z = 0 ; yygotominor . yy0 . n = 0 ; } 
line 93086: break ; 
line 93087: case 139 : 
line 93088: { yygotominor . yy65 = sqlite3SrcListAppend ( pParse -> db , 0 , & yymsp [ - 1 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 ) ; } 
line 93089: break ; 
line 93090: case 140 : 
line 93091: { yygotominor . yy328 = JT_INNER ; } 
line 93092: break ; 
line 93093: case 141 : 
line 93094: { yygotominor . yy328 = sqlite3JoinType ( pParse , & yymsp [ - 1 ] . minor . yy0 , 0 , 0 ) ; } 
line 93095: break ; 
line 93096: case 142 : 
line 93097: { yygotominor . yy328 = sqlite3JoinType ( pParse , & yymsp [ - 2 ] . minor . yy0 , & yymsp [ - 1 ] . minor . yy0 , 0 ) ; } 
line 93098: break ; 
line 93099: case 143 : 
line 93100: { yygotominor . yy328 = sqlite3JoinType ( pParse , & yymsp [ - 3 ] . minor . yy0 , & yymsp [ - 2 ] . minor . yy0 , & yymsp [ - 1 ] . minor . yy0 ) ; } 
line 93101: break ; 
line 93102: case 144 : 
line 93103: case 155 : yytestcase ( yyruleno == 155 ) ; 
line 93104: case 162 : yytestcase ( yyruleno == 162 ) ; 
line 93105: case 169 : yytestcase ( yyruleno == 169 ) ; 
line 93106: case 236 : yytestcase ( yyruleno == 236 ) ; 
line 93107: case 238 : yytestcase ( yyruleno == 238 ) ; 
line 93108: { yygotominor . yy132 = yymsp [ 0 ] . minor . yy346 . pExpr ; } 
line 93109: break ; 
line 93110: case 145 : 
line 93111: case 161 : yytestcase ( yyruleno == 161 ) ; 
line 93112: case 168 : yytestcase ( yyruleno == 168 ) ; 
line 93113: case 237 : yytestcase ( yyruleno == 237 ) ; 
line 93114: case 239 : yytestcase ( yyruleno == 239 ) ; 
line 93115: { yygotominor . yy132 = 0 ; } 
line 93116: break ; 
line 93117: case 148 : 
line 93118: { yygotominor . yy0 . z = 0 ; yygotominor . yy0 . n = 1 ; } 
line 93119: break ; 
line 93120: case 149 : 
line 93121: case 181 : yytestcase ( yyruleno == 181 ) ; 
line 93122: { yygotominor . yy408 = yymsp [ - 1 ] . minor . yy408 ; } 
line 93123: break ; 
line 93124: case 150 : 
line 93125: case 180 : yytestcase ( yyruleno == 180 ) ; 
line 93126: { yygotominor . yy408 = 0 ; } 
line 93127: break ; 
line 93128: case 152 : 
line 93129: case 160 : yytestcase ( yyruleno == 160 ) ; 
line 93130: case 240 : yytestcase ( yyruleno == 240 ) ; 
line 93131: { yygotominor . yy14 = yymsp [ 0 ] . minor . yy14 ; } 
line 93132: break ; 
line 93133: case 153 : 
line 93134: { 
line 93135: yygotominor . yy14 = sqlite3ExprListAppend ( pParse , yymsp [ - 3 ] . minor . yy14 , yymsp [ - 1 ] . minor . yy132 ) ; 
line 93136: if ( yygotominor . yy14 ) yygotominor . yy14 -> a [ yygotominor . yy14 -> nExpr - 1 ] . sortOrder = ( u8 ) yymsp [ 0 ] . minor . yy328 ; 
line 93137: } 
line 93138: break ; 
line 93139: case 154 : 
line 93140: { 
line 93141: yygotominor . yy14 = sqlite3ExprListAppend ( pParse , 0 , yymsp [ - 1 ] . minor . yy132 ) ; 
line 93142: if ( yygotominor . yy14 && ALWAYS ( yygotominor . yy14 -> a ) ) yygotominor . yy14 -> a [ 0 ] . sortOrder = ( u8 ) yymsp [ 0 ] . minor . yy328 ; 
line 93143: } 
line 93144: break ; 
line 93145: case 156 : 
line 93146: case 158 : yytestcase ( yyruleno == 158 ) ; 
line 93147: { yygotominor . yy328 = SQLITE_SO_ASC ; } 
line 93148: break ; 
line 93149: case 157 : 
line 93150: { yygotominor . yy328 = SQLITE_SO_DESC ; } 
line 93151: break ; 
line 93152: case 163 : 
line 93153: { yygotominor . yy476 . pLimit = 0 ; yygotominor . yy476 . pOffset = 0 ; } 
line 93154: break ; 
line 93155: case 164 : 
line 93156: { yygotominor . yy476 . pLimit = yymsp [ 0 ] . minor . yy346 . pExpr ; yygotominor . yy476 . pOffset = 0 ; } 
line 93157: break ; 
line 93158: case 165 : 
line 93159: { yygotominor . yy476 . pLimit = yymsp [ - 2 ] . minor . yy346 . pExpr ; yygotominor . yy476 . pOffset = yymsp [ 0 ] . minor . yy346 . pExpr ; } 
line 93160: break ; 
line 93161: case 166 : 
line 93162: { yygotominor . yy476 . pOffset = yymsp [ - 2 ] . minor . yy346 . pExpr ; yygotominor . yy476 . pLimit = yymsp [ 0 ] . minor . yy346 . pExpr ; } 
line 93163: break ; 
line 93164: case 167 : 
line 93165: { 
line 93166: sqlite3SrcListIndexedBy ( pParse , yymsp [ - 2 ] . minor . yy65 , & yymsp [ - 1 ] . minor . yy0 ) ; 
line 93167: sqlite3DeleteFrom ( pParse , yymsp [ - 2 ] . minor . yy65 , yymsp [ 0 ] . minor . yy132 ) ; 
line 93168: } 
line 93169: break ; 
line 93170: case 170 : 
line 93171: { 
line 93172: sqlite3SrcListIndexedBy ( pParse , yymsp [ - 4 ] . minor . yy65 , & yymsp [ - 3 ] . minor . yy0 ) ; 
line 93173: sqlite3ExprListCheckLength ( pParse , yymsp [ - 1 ] . minor . yy14 , "set list" ) ; 
line 93174: sqlite3Update ( pParse , yymsp [ - 4 ] . minor . yy65 , yymsp [ - 1 ] . minor . yy14 , yymsp [ 0 ] . minor . yy132 , yymsp [ - 5 ] . minor . yy186 ) ; 
line 93175: } 
line 93176: break ; 
line 93177: case 171 : 
line 93178: { 
line 93179: yygotominor . yy14 = sqlite3ExprListAppend ( pParse , yymsp [ - 4 ] . minor . yy14 , yymsp [ 0 ] . minor . yy346 . pExpr ) ; 
line 93180: sqlite3ExprListSetName ( pParse , yygotominor . yy14 , & yymsp [ - 2 ] . minor . yy0 , 1 ) ; 
line 93181: } 
line 93182: break ; 
line 93183: case 172 : 
line 93184: { 
line 93185: yygotominor . yy14 = sqlite3ExprListAppend ( pParse , 0 , yymsp [ 0 ] . minor . yy346 . pExpr ) ; 
line 93186: sqlite3ExprListSetName ( pParse , yygotominor . yy14 , & yymsp [ - 2 ] . minor . yy0 , 1 ) ; 
line 93187: } 
line 93188: break ; 
line 93189: case 173 : 
line 93190: { sqlite3Insert ( pParse , yymsp [ - 5 ] . minor . yy65 , yymsp [ - 1 ] . minor . yy14 , 0 , yymsp [ - 4 ] . minor . yy408 , yymsp [ - 7 ] . minor . yy186 ) ; } 
line 93191: break ; 
line 93192: case 174 : 
line 93193: { sqlite3Insert ( pParse , yymsp [ - 2 ] . minor . yy65 , 0 , yymsp [ 0 ] . minor . yy3 , yymsp [ - 1 ] . minor . yy408 , yymsp [ - 4 ] . minor . yy186 ) ; } 
line 93194: break ; 
line 93195: case 175 : 
line 93196: { sqlite3Insert ( pParse , yymsp [ - 3 ] . minor . yy65 , 0 , 0 , yymsp [ - 2 ] . minor . yy408 , yymsp [ - 5 ] . minor . yy186 ) ; } 
line 93197: break ; 
line 93198: case 176 : 
line 93199: { yygotominor . yy186 = yymsp [ 0 ] . minor . yy186 ; } 
line 93200: break ; 
line 93201: case 177 : 
line 93202: { yygotominor . yy186 = OE_Replace ; } 
line 93203: break ; 
line 93204: case 178 : 
line 93205: case 242 : yytestcase ( yyruleno == 242 ) ; 
line 93206: { yygotominor . yy14 = sqlite3ExprListAppend ( pParse , yymsp [ - 2 ] . minor . yy14 , yymsp [ 0 ] . minor . yy346 . pExpr ) ; } 
line 93207: break ; 
line 93208: case 179 : 
line 93209: case 243 : yytestcase ( yyruleno == 243 ) ; 
line 93210: { yygotominor . yy14 = sqlite3ExprListAppend ( pParse , 0 , yymsp [ 0 ] . minor . yy346 . pExpr ) ; } 
line 93211: break ; 
line 93212: case 182 : 
line 93213: { yygotominor . yy408 = sqlite3IdListAppend ( pParse -> db , yymsp [ - 2 ] . minor . yy408 , & yymsp [ 0 ] . minor . yy0 ) ; } 
line 93214: break ; 
line 93215: case 183 : 
line 93216: { yygotominor . yy408 = sqlite3IdListAppend ( pParse -> db , 0 , & yymsp [ 0 ] . minor . yy0 ) ; } 
line 93217: break ; 
line 93218: case 184 : 
line 93219: case 212 : yytestcase ( yyruleno == 212 ) ; 
line 93220: { yygotominor . yy346 = yymsp [ 0 ] . minor . yy346 ; } 
line 93221: break ; 
line 93222: case 185 : 
line 93223: { yygotominor . yy346 . pExpr = yymsp [ - 1 ] . minor . yy346 . pExpr ; spanSet ( & yygotominor . yy346 , & yymsp [ - 2 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 ) ; } 
line 93224: break ; 
line 93225: case 186 : 
line 93226: case 191 : yytestcase ( yyruleno == 191 ) ; 
line 93227: case 192 : yytestcase ( yyruleno == 192 ) ; 
line 93228: { spanExpr ( & yygotominor . yy346 , pParse , yymsp [ 0 ] . major , & yymsp [ 0 ] . minor . yy0 ) ; } 
line 93229: break ; 
line 93230: case 187 : 
line 93231: case 188 : yytestcase ( yyruleno == 188 ) ; 
line 93232: { spanExpr ( & yygotominor . yy346 , pParse , TK_ID , & yymsp [ 0 ] . minor . yy0 ) ; } 
line 93233: break ; 
line 93234: case 189 : 
line 93235: { 
line 93236: Expr * temp1 = sqlite3PExpr ( pParse , TK_ID , 0 , 0 , & yymsp [ - 2 ] . minor . yy0 ) ; 
line 93237: Expr * temp2 = sqlite3PExpr ( pParse , TK_ID , 0 , 0 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93238: yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_DOT , temp1 , temp2 , 0 ) ; 
line 93239: spanSet ( & yygotominor . yy346 , & yymsp [ - 2 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93240: } 
line 93241: break ; 
line 93242: case 190 : 
line 93243: { 
line 93244: Expr * temp1 = sqlite3PExpr ( pParse , TK_ID , 0 , 0 , & yymsp [ - 4 ] . minor . yy0 ) ; 
line 93245: Expr * temp2 = sqlite3PExpr ( pParse , TK_ID , 0 , 0 , & yymsp [ - 2 ] . minor . yy0 ) ; 
line 93246: Expr * temp3 = sqlite3PExpr ( pParse , TK_ID , 0 , 0 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93247: Expr * temp4 = sqlite3PExpr ( pParse , TK_DOT , temp2 , temp3 , 0 ) ; 
line 93248: yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_DOT , temp1 , temp4 , 0 ) ; 
line 93249: spanSet ( & yygotominor . yy346 , & yymsp [ - 4 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93250: } 
line 93251: break ; 
line 93252: case 193 : 
line 93253: { 
line 93257: if ( pParse -> nested == 0 ) { 
line 93258: sqlite3ErrorMsg ( pParse , "near \"%T\": syntax error" , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93259: yygotominor . yy346 . pExpr = 0 ; 
line 93260: } else { 
line 93261: yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_REGISTER , 0 , 0 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93262: if ( yygotominor . yy346 . pExpr ) sqlite3GetInt32 ( & yymsp [ 0 ] . minor . yy0 . z [ 1 ] , & yygotominor . yy346 . pExpr -> iTable ) ; 
line 93263: } 
line 93264: spanSet ( & yygotominor . yy346 , & yymsp [ 0 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93265: } 
line 93266: break ; 
line 93267: case 194 : 
line 93268: { 
line 93269: spanExpr ( & yygotominor . yy346 , pParse , TK_VARIABLE , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93270: sqlite3ExprAssignVarNumber ( pParse , yygotominor . yy346 . pExpr ) ; 
line 93271: spanSet ( & yygotominor . yy346 , & yymsp [ 0 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93272: } 
line 93273: break ; 
line 93274: case 195 : 
line 93275: { 
line 93276: yygotominor . yy346 . pExpr = sqlite3ExprSetColl ( pParse , yymsp [ - 2 ] . minor . yy346 . pExpr , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93277: yygotominor . yy346 . zStart = yymsp [ - 2 ] . minor . yy346 . zStart ; 
line 93278: yygotominor . yy346 . zEnd = & yymsp [ 0 ] . minor . yy0 . z [ yymsp [ 0 ] . minor . yy0 . n ] ; 
line 93279: } 
line 93280: break ; 
line 93281: case 196 : 
line 93282: { 
line 93283: yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_CAST , yymsp [ - 3 ] . minor . yy346 . pExpr , 0 , & yymsp [ - 1 ] . minor . yy0 ) ; 
line 93284: spanSet ( & yygotominor . yy346 , & yymsp [ - 5 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93285: } 
line 93286: break ; 
line 93287: case 197 : 
line 93288: { 
line 93289: if ( yymsp [ - 1 ] . minor . yy14 && yymsp [ - 1 ] . minor . yy14 -> nExpr > pParse -> db -> aLimit [ SQLITE_LIMIT_FUNCTION_ARG ] ) { 
line 93290: sqlite3ErrorMsg ( pParse , "too many arguments on function %T" , & yymsp [ - 4 ] . minor . yy0 ) ; 
line 93291: } 
line 93292: yygotominor . yy346 . pExpr = sqlite3ExprFunction ( pParse , yymsp [ - 1 ] . minor . yy14 , & yymsp [ - 4 ] . minor . yy0 ) ; 
line 93293: spanSet ( & yygotominor . yy346 , & yymsp [ - 4 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93294: if ( yymsp [ - 2 ] . minor . yy328 && yygotominor . yy346 . pExpr ) { 
line 93295: yygotominor . yy346 . pExpr -> flags |= EP_Distinct ; 
line 93296: } 
line 93297: } 
line 93298: break ; 
line 93299: case 198 : 
line 93300: { 
line 93301: yygotominor . yy346 . pExpr = sqlite3ExprFunction ( pParse , 0 , & yymsp [ - 3 ] . minor . yy0 ) ; 
line 93302: spanSet ( & yygotominor . yy346 , & yymsp [ - 3 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93303: } 
line 93304: break ; 
line 93305: case 199 : 
line 93306: { 
line 93309: yygotominor . yy346 . pExpr = sqlite3ExprFunction ( pParse , 0 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93310: if ( yygotominor . yy346 . pExpr ) { 
line 93311: yygotominor . yy346 . pExpr -> op = TK_CONST_FUNC ; 
line 93312: } 
line 93313: spanSet ( & yygotominor . yy346 , & yymsp [ 0 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93314: } 
line 93315: break ; 
line 93316: case 200 : 
line 93317: case 201 : yytestcase ( yyruleno == 201 ) ; 
line 93318: case 202 : yytestcase ( yyruleno == 202 ) ; 
line 93319: case 203 : yytestcase ( yyruleno == 203 ) ; 
line 93320: case 204 : yytestcase ( yyruleno == 204 ) ; 
line 93321: case 205 : yytestcase ( yyruleno == 205 ) ; 
line 93322: case 206 : yytestcase ( yyruleno == 206 ) ; 
line 93323: case 207 : yytestcase ( yyruleno == 207 ) ; 
line 93324: { spanBinaryExpr ( & yygotominor . yy346 , pParse , yymsp [ - 1 ] . major , & yymsp [ - 2 ] . minor . yy346 , & yymsp [ 0 ] . minor . yy346 ) ; } 
line 93325: break ; 
line 93326: case 208 : 
line 93327: case 210 : yytestcase ( yyruleno == 210 ) ; 
line 93328: { yygotominor . yy96 . eOperator = yymsp [ 0 ] . minor . yy0 ; yygotominor . yy96 . not = 0 ; } 
line 93329: break ; 
line 93330: case 209 : 
line 93331: case 211 : yytestcase ( yyruleno == 211 ) ; 
line 93332: { yygotominor . yy96 . eOperator = yymsp [ 0 ] . minor . yy0 ; yygotominor . yy96 . not = 1 ; } 
line 93333: break ; 
line 93334: case 213 : 
line 93335: { memset ( & yygotominor . yy346 , 0 , sizeof ( yygotominor . yy346 ) ) ; } 
line 93336: break ; 
line 93337: case 214 : 
line 93338: { 
line 93339: ExprList * pList ; 
line 93340: pList = sqlite3ExprListAppend ( pParse , 0 , yymsp [ - 1 ] . minor . yy346 . pExpr ) ; 
line 93341: pList = sqlite3ExprListAppend ( pParse , pList , yymsp [ - 3 ] . minor . yy346 . pExpr ) ; 
line 93342: if ( yymsp [ 0 ] . minor . yy346 . pExpr ) { 
line 93343: pList = sqlite3ExprListAppend ( pParse , pList , yymsp [ 0 ] . minor . yy346 . pExpr ) ; 
line 93344: } 
line 93345: yygotominor . yy346 . pExpr = sqlite3ExprFunction ( pParse , pList , & yymsp [ - 2 ] . minor . yy96 . eOperator ) ; 
line 93346: if ( yymsp [ - 2 ] . minor . yy96 . not ) yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_NOT , yygotominor . yy346 . pExpr , 0 , 0 ) ; 
line 93347: yygotominor . yy346 . zStart = yymsp [ - 3 ] . minor . yy346 . zStart ; 
line 93348: yygotominor . yy346 . zEnd = yymsp [ - 1 ] . minor . yy346 . zEnd ; 
line 93349: if ( yygotominor . yy346 . pExpr ) yygotominor . yy346 . pExpr -> flags |= EP_InfixFunc ; 
line 93350: } 
line 93351: break ; 
line 93352: case 215 : 
line 93353: { spanUnaryPostfix ( & yygotominor . yy346 , pParse , yymsp [ 0 ] . major , & yymsp [ - 1 ] . minor . yy346 , & yymsp [ 0 ] . minor . yy0 ) ; } 
line 93354: break ; 
line 93355: case 216 : 
line 93356: { spanUnaryPostfix ( & yygotominor . yy346 , pParse , TK_NOTNULL , & yymsp [ - 2 ] . minor . yy346 , & yymsp [ 0 ] . minor . yy0 ) ; } 
line 93357: break ; 
line 93358: case 217 : 
line 93359: { 
line 93360: spanBinaryExpr ( & yygotominor . yy346 , pParse , TK_IS , & yymsp [ - 2 ] . minor . yy346 , & yymsp [ 0 ] . minor . yy346 ) ; 
line 93361: binaryToUnaryIfNull ( pParse , yymsp [ 0 ] . minor . yy346 . pExpr , yygotominor . yy346 . pExpr , TK_ISNULL ) ; 
line 93362: } 
line 93363: break ; 
line 93364: case 218 : 
line 93365: { 
line 93366: spanBinaryExpr ( & yygotominor . yy346 , pParse , TK_ISNOT , & yymsp [ - 3 ] . minor . yy346 , & yymsp [ 0 ] . minor . yy346 ) ; 
line 93367: binaryToUnaryIfNull ( pParse , yymsp [ 0 ] . minor . yy346 . pExpr , yygotominor . yy346 . pExpr , TK_NOTNULL ) ; 
line 93368: } 
line 93369: break ; 
line 93370: case 219 : 
line 93371: case 220 : yytestcase ( yyruleno == 220 ) ; 
line 93372: { spanUnaryPrefix ( & yygotominor . yy346 , pParse , yymsp [ - 1 ] . major , & yymsp [ 0 ] . minor . yy346 , & yymsp [ - 1 ] . minor . yy0 ) ; } 
line 93373: break ; 
line 93374: case 221 : 
line 93375: { spanUnaryPrefix ( & yygotominor . yy346 , pParse , TK_UMINUS , & yymsp [ 0 ] . minor . yy346 , & yymsp [ - 1 ] . minor . yy0 ) ; } 
line 93376: break ; 
line 93377: case 222 : 
line 93378: { spanUnaryPrefix ( & yygotominor . yy346 , pParse , TK_UPLUS , & yymsp [ 0 ] . minor . yy346 , & yymsp [ - 1 ] . minor . yy0 ) ; } 
line 93379: break ; 
line 93380: case 225 : 
line 93381: { 
line 93382: ExprList * pList = sqlite3ExprListAppend ( pParse , 0 , yymsp [ - 2 ] . minor . yy346 . pExpr ) ; 
line 93383: pList = sqlite3ExprListAppend ( pParse , pList , yymsp [ 0 ] . minor . yy346 . pExpr ) ; 
line 93384: yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_BETWEEN , yymsp [ - 4 ] . minor . yy346 . pExpr , 0 , 0 ) ; 
line 93385: if ( yygotominor . yy346 . pExpr ) { 
line 93386: yygotominor . yy346 . pExpr -> x . pList = pList ; 
line 93387: } else { 
line 93388: sqlite3ExprListDelete ( pParse -> db , pList ) ; 
line 93389: } 
line 93390: if ( yymsp [ - 3 ] . minor . yy328 ) yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_NOT , yygotominor . yy346 . pExpr , 0 , 0 ) ; 
line 93391: yygotominor . yy346 . zStart = yymsp [ - 4 ] . minor . yy346 . zStart ; 
line 93392: yygotominor . yy346 . zEnd = yymsp [ 0 ] . minor . yy346 . zEnd ; 
line 93393: } 
line 93394: break ; 
line 93395: case 228 : 
line 93396: { 
line 93397: yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_IN , yymsp [ - 4 ] . minor . yy346 . pExpr , 0 , 0 ) ; 
line 93398: if ( yygotominor . yy346 . pExpr ) { 
line 93399: yygotominor . yy346 . pExpr -> x . pList = yymsp [ - 1 ] . minor . yy14 ; 
line 93400: sqlite3ExprSetHeight ( pParse , yygotominor . yy346 . pExpr ) ; 
line 93401: } else { 
line 93402: sqlite3ExprListDelete ( pParse -> db , yymsp [ - 1 ] . minor . yy14 ) ; 
line 93403: } 
line 93404: if ( yymsp [ - 3 ] . minor . yy328 ) yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_NOT , yygotominor . yy346 . pExpr , 0 , 0 ) ; 
line 93405: yygotominor . yy346 . zStart = yymsp [ - 4 ] . minor . yy346 . zStart ; 
line 93406: yygotominor . yy346 . zEnd = & yymsp [ 0 ] . minor . yy0 . z [ yymsp [ 0 ] . minor . yy0 . n ] ; 
line 93407: } 
line 93408: break ; 
line 93409: case 229 : 
line 93410: { 
line 93411: yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_SELECT , 0 , 0 , 0 ) ; 
line 93412: if ( yygotominor . yy346 . pExpr ) { 
line 93413: yygotominor . yy346 . pExpr -> x . pSelect = yymsp [ - 1 ] . minor . yy3 ; 
line 93414: ExprSetProperty ( yygotominor . yy346 . pExpr , EP_xIsSelect ) ; 
line 93415: sqlite3ExprSetHeight ( pParse , yygotominor . yy346 . pExpr ) ; 
line 93416: } else { 
line 93417: sqlite3SelectDelete ( pParse -> db , yymsp [ - 1 ] . minor . yy3 ) ; 
line 93418: } 
line 93419: yygotominor . yy346 . zStart = yymsp [ - 2 ] . minor . yy0 . z ; 
line 93420: yygotominor . yy346 . zEnd = & yymsp [ 0 ] . minor . yy0 . z [ yymsp [ 0 ] . minor . yy0 . n ] ; 
line 93421: } 
line 93422: break ; 
line 93423: case 230 : 
line 93424: { 
line 93425: yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_IN , yymsp [ - 4 ] . minor . yy346 . pExpr , 0 , 0 ) ; 
line 93426: if ( yygotominor . yy346 . pExpr ) { 
line 93427: yygotominor . yy346 . pExpr -> x . pSelect = yymsp [ - 1 ] . minor . yy3 ; 
line 93428: ExprSetProperty ( yygotominor . yy346 . pExpr , EP_xIsSelect ) ; 
line 93429: sqlite3ExprSetHeight ( pParse , yygotominor . yy346 . pExpr ) ; 
line 93430: } else { 
line 93431: sqlite3SelectDelete ( pParse -> db , yymsp [ - 1 ] . minor . yy3 ) ; 
line 93432: } 
line 93433: if ( yymsp [ - 3 ] . minor . yy328 ) yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_NOT , yygotominor . yy346 . pExpr , 0 , 0 ) ; 
line 93434: yygotominor . yy346 . zStart = yymsp [ - 4 ] . minor . yy346 . zStart ; 
line 93435: yygotominor . yy346 . zEnd = & yymsp [ 0 ] . minor . yy0 . z [ yymsp [ 0 ] . minor . yy0 . n ] ; 
line 93436: } 
line 93437: break ; 
line 93438: case 231 : 
line 93439: { 
line 93440: SrcList * pSrc = sqlite3SrcListAppend ( pParse -> db , 0 , & yymsp [ - 1 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93441: yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_IN , yymsp [ - 3 ] . minor . yy346 . pExpr , 0 , 0 ) ; 
line 93442: if ( yygotominor . yy346 . pExpr ) { 
line 93443: yygotominor . yy346 . pExpr -> x . pSelect = sqlite3SelectNew ( pParse , 0 , pSrc , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) ; 
line 93444: ExprSetProperty ( yygotominor . yy346 . pExpr , EP_xIsSelect ) ; 
line 93445: sqlite3ExprSetHeight ( pParse , yygotominor . yy346 . pExpr ) ; 
line 93446: } else { 
line 93447: sqlite3SrcListDelete ( pParse -> db , pSrc ) ; 
line 93448: } 
line 93449: if ( yymsp [ - 2 ] . minor . yy328 ) yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_NOT , yygotominor . yy346 . pExpr , 0 , 0 ) ; 
line 93450: yygotominor . yy346 . zStart = yymsp [ - 3 ] . minor . yy346 . zStart ; 
line 93451: yygotominor . yy346 . zEnd = yymsp [ 0 ] . minor . yy0 . z ? & yymsp [ 0 ] . minor . yy0 . z [ yymsp [ 0 ] . minor . yy0 . n ] : & yymsp [ - 1 ] . minor . yy0 . z [ yymsp [ - 1 ] . minor . yy0 . n ] ; 
line 93452: } 
line 93453: break ; 
line 93454: case 232 : 
line 93455: { 
line 93456: Expr * p = yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_EXISTS , 0 , 0 , 0 ) ; 
line 93457: if ( p ) { 
line 93458: p -> x . pSelect = yymsp [ - 1 ] . minor . yy3 ; 
line 93459: ExprSetProperty ( p , EP_xIsSelect ) ; 
line 93460: sqlite3ExprSetHeight ( pParse , p ) ; 
line 93461: } else { 
line 93462: sqlite3SelectDelete ( pParse -> db , yymsp [ - 1 ] . minor . yy3 ) ; 
line 93463: } 
line 93464: yygotominor . yy346 . zStart = yymsp [ - 3 ] . minor . yy0 . z ; 
line 93465: yygotominor . yy346 . zEnd = & yymsp [ 0 ] . minor . yy0 . z [ yymsp [ 0 ] . minor . yy0 . n ] ; 
line 93466: } 
line 93467: break ; 
line 93468: case 233 : 
line 93469: { 
line 93470: yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_CASE , yymsp [ - 3 ] . minor . yy132 , yymsp [ - 1 ] . minor . yy132 , 0 ) ; 
line 93471: if ( yygotominor . yy346 . pExpr ) { 
line 93472: yygotominor . yy346 . pExpr -> x . pList = yymsp [ - 2 ] . minor . yy14 ; 
line 93473: sqlite3ExprSetHeight ( pParse , yygotominor . yy346 . pExpr ) ; 
line 93474: } else { 
line 93475: sqlite3ExprListDelete ( pParse -> db , yymsp [ - 2 ] . minor . yy14 ) ; 
line 93476: } 
line 93477: yygotominor . yy346 . zStart = yymsp [ - 4 ] . minor . yy0 . z ; 
line 93478: yygotominor . yy346 . zEnd = & yymsp [ 0 ] . minor . yy0 . z [ yymsp [ 0 ] . minor . yy0 . n ] ; 
line 93479: } 
line 93480: break ; 
line 93481: case 234 : 
line 93482: { 
line 93483: yygotominor . yy14 = sqlite3ExprListAppend ( pParse , yymsp [ - 4 ] . minor . yy14 , yymsp [ - 2 ] . minor . yy346 . pExpr ) ; 
line 93484: yygotominor . yy14 = sqlite3ExprListAppend ( pParse , yygotominor . yy14 , yymsp [ 0 ] . minor . yy346 . pExpr ) ; 
line 93485: } 
line 93486: break ; 
line 93487: case 235 : 
line 93488: { 
line 93489: yygotominor . yy14 = sqlite3ExprListAppend ( pParse , 0 , yymsp [ - 2 ] . minor . yy346 . pExpr ) ; 
line 93490: yygotominor . yy14 = sqlite3ExprListAppend ( pParse , yygotominor . yy14 , yymsp [ 0 ] . minor . yy346 . pExpr ) ; 
line 93491: } 
line 93492: break ; 
line 93493: case 244 : 
line 93494: { 
line 93495: sqlite3CreateIndex ( pParse , & yymsp [ - 6 ] . minor . yy0 , & yymsp [ - 5 ] . minor . yy0 , 
line 93496: sqlite3SrcListAppend ( pParse -> db , 0 , & yymsp [ - 3 ] . minor . yy0 , 0 ) , yymsp [ - 1 ] . minor . yy14 , yymsp [ - 9 ] . minor . yy328 , 
line 93497: & yymsp [ - 10 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 , SQLITE_SO_ASC , yymsp [ - 7 ] . minor . yy328 ) ; 
line 93498: } 
line 93499: break ; 
line 93500: case 245 : 
line 93501: case 299 : yytestcase ( yyruleno == 299 ) ; 
line 93502: { yygotominor . yy328 = OE_Abort ; } 
line 93503: break ; 
line 93504: case 246 : 
line 93505: { yygotominor . yy328 = OE_None ; } 
line 93506: break ; 
line 93507: case 249 : 
line 93508: { 
line 93509: Expr * p = 0 ; 
line 93510: if ( yymsp [ - 1 ] . minor . yy0 . n > 0 ) { 
line 93511: p = sqlite3Expr ( pParse -> db , TK_COLUMN , 0 ) ; 
line 93512: sqlite3ExprSetColl ( pParse , p , & yymsp [ - 1 ] . minor . yy0 ) ; 
line 93513: } 
line 93514: yygotominor . yy14 = sqlite3ExprListAppend ( pParse , yymsp [ - 4 ] . minor . yy14 , p ) ; 
line 93515: sqlite3ExprListSetName ( pParse , yygotominor . yy14 , & yymsp [ - 2 ] . minor . yy0 , 1 ) ; 
line 93516: sqlite3ExprListCheckLength ( pParse , yygotominor . yy14 , "index" ) ; 
line 93517: if ( yygotominor . yy14 ) yygotominor . yy14 -> a [ yygotominor . yy14 -> nExpr - 1 ] . sortOrder = ( u8 ) yymsp [ 0 ] . minor . yy328 ; 
line 93518: } 
line 93519: break ; 
line 93520: case 250 : 
line 93521: { 
line 93522: Expr * p = 0 ; 
line 93523: if ( yymsp [ - 1 ] . minor . yy0 . n > 0 ) { 
line 93524: p = sqlite3PExpr ( pParse , TK_COLUMN , 0 , 0 , 0 ) ; 
line 93525: sqlite3ExprSetColl ( pParse , p , & yymsp [ - 1 ] . minor . yy0 ) ; 
line 93526: } 
line 93527: yygotominor . yy14 = sqlite3ExprListAppend ( pParse , 0 , p ) ; 
line 93528: sqlite3ExprListSetName ( pParse , yygotominor . yy14 , & yymsp [ - 2 ] . minor . yy0 , 1 ) ; 
line 93529: sqlite3ExprListCheckLength ( pParse , yygotominor . yy14 , "index" ) ; 
line 93530: if ( yygotominor . yy14 ) yygotominor . yy14 -> a [ yygotominor . yy14 -> nExpr - 1 ] . sortOrder = ( u8 ) yymsp [ 0 ] . minor . yy328 ; 
line 93531: } 
line 93532: break ; 
line 93533: case 251 : 
line 93534: { yygotominor . yy0 . z = 0 ; yygotominor . yy0 . n = 0 ; } 
line 93535: break ; 
line 93536: case 253 : 
line 93537: { sqlite3DropIndex ( pParse , yymsp [ 0 ] . minor . yy65 , yymsp [ - 1 ] . minor . yy328 ) ; } 
line 93538: break ; 
line 93539: case 254 : 
line 93540: case 255 : yytestcase ( yyruleno == 255 ) ; 
line 93541: { sqlite3Vacuum ( pParse ) ; } 
line 93542: break ; 
line 93543: case 256 : 
line 93544: { sqlite3Pragma ( pParse , & yymsp [ - 1 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 , 0 , 0 ) ; } 
line 93545: break ; 
line 93546: case 257 : 
line 93547: { sqlite3Pragma ( pParse , & yymsp [ - 3 ] . minor . yy0 , & yymsp [ - 2 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 , 0 ) ; } 
line 93548: break ; 
line 93549: case 258 : 
line 93550: { sqlite3Pragma ( pParse , & yymsp [ - 4 ] . minor . yy0 , & yymsp [ - 3 ] . minor . yy0 , & yymsp [ - 1 ] . minor . yy0 , 0 ) ; } 
line 93551: break ; 
line 93552: case 259 : 
line 93553: { sqlite3Pragma ( pParse , & yymsp [ - 3 ] . minor . yy0 , & yymsp [ - 2 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 , 1 ) ; } 
line 93554: break ; 
line 93555: case 260 : 
line 93556: { sqlite3Pragma ( pParse , & yymsp [ - 4 ] . minor . yy0 , & yymsp [ - 3 ] . minor . yy0 , & yymsp [ - 1 ] . minor . yy0 , 1 ) ; } 
line 93557: break ; 
line 93558: case 271 : 
line 93559: { 
line 93560: Token all ; 
line 93561: all . z = yymsp [ - 3 ] . minor . yy0 . z ; 
line 93562: all . n = ( int ) ( yymsp [ 0 ] . minor . yy0 . z - yymsp [ - 3 ] . minor . yy0 . z ) + yymsp [ 0 ] . minor . yy0 . n ; 
line 93563: sqlite3FinishTrigger ( pParse , yymsp [ - 1 ] . minor . yy473 , & all ) ; 
line 93564: } 
line 93565: break ; 
line 93566: case 272 : 
line 93567: { 
line 93568: sqlite3BeginTrigger ( pParse , & yymsp [ - 7 ] . minor . yy0 , & yymsp [ - 6 ] . minor . yy0 , yymsp [ - 5 ] . minor . yy328 , yymsp [ - 4 ] . minor . yy378 . a , yymsp [ - 4 ] . minor . yy378 . b , yymsp [ - 2 ] . minor . yy65 , yymsp [ 0 ] . minor . yy132 , yymsp [ - 10 ] . minor . yy328 , yymsp [ - 8 ] . minor . yy328 ) ; 
line 93569: yygotominor . yy0 = ( yymsp [ - 6 ] . minor . yy0 . n == 0 ? yymsp [ - 7 ] . minor . yy0 : yymsp [ - 6 ] . minor . yy0 ) ; 
line 93570: } 
line 93571: break ; 
line 93572: case 273 : 
line 93573: case 276 : yytestcase ( yyruleno == 276 ) ; 
line 93574: { yygotominor . yy328 = TK_BEFORE ; } 
line 93575: break ; 
line 93576: case 274 : 
line 93577: { yygotominor . yy328 = TK_AFTER ; } 
line 93578: break ; 
line 93579: case 275 : 
line 93580: { yygotominor . yy328 = TK_INSTEAD ; } 
line 93581: break ; 
line 93582: case 277 : 
line 93583: case 278 : yytestcase ( yyruleno == 278 ) ; 
line 93584: { yygotominor . yy378 . a = yymsp [ 0 ] . major ; yygotominor . yy378 . b = 0 ; } 
line 93585: break ; 
line 93586: case 279 : 
line 93587: { yygotominor . yy378 . a = TK_UPDATE ; yygotominor . yy378 . b = yymsp [ 0 ] . minor . yy408 ; } 
line 93588: break ; 
line 93589: case 282 : 
line 93590: case 304 : yytestcase ( yyruleno == 304 ) ; 
line 93591: { yygotominor . yy132 = 0 ; } 
line 93592: break ; 
line 93593: case 283 : 
line 93594: case 305 : yytestcase ( yyruleno == 305 ) ; 
line 93595: { yygotominor . yy132 = yymsp [ 0 ] . minor . yy346 . pExpr ; } 
line 93596: break ; 
line 93597: case 284 : 
line 93598: { 
line 93599: assert ( yymsp [ - 2 ] . minor . yy473 != 0 ) ; 
line 93600: yymsp [ - 2 ] . minor . yy473 -> pLast -> pNext = yymsp [ - 1 ] . minor . yy473 ; 
line 93601: yymsp [ - 2 ] . minor . yy473 -> pLast = yymsp [ - 1 ] . minor . yy473 ; 
line 93602: yygotominor . yy473 = yymsp [ - 2 ] . minor . yy473 ; 
line 93603: } 
line 93604: break ; 
line 93605: case 285 : 
line 93606: { 
line 93607: assert ( yymsp [ - 1 ] . minor . yy473 != 0 ) ; 
line 93608: yymsp [ - 1 ] . minor . yy473 -> pLast = yymsp [ - 1 ] . minor . yy473 ; 
line 93609: yygotominor . yy473 = yymsp [ - 1 ] . minor . yy473 ; 
line 93610: } 
line 93611: break ; 
line 93612: case 287 : 
line 93613: { 
line 93614: yygotominor . yy0 = yymsp [ 0 ] . minor . yy0 ; 
line 93615: sqlite3ErrorMsg ( pParse , 
line 93616: "qualified table names are not allowed on INSERT, UPDATE, and DELETE " 
line 93617: "statements within triggers" ) ; 
line 93618: } 
line 93619: break ; 
line 93620: case 289 : 
line 93621: { 
line 93622: sqlite3ErrorMsg ( pParse , 
line 93623: "the INDEXED BY clause is not allowed on UPDATE or DELETE statements " 
line 93624: "within triggers" ) ; 
line 93625: } 
line 93626: break ; 
line 93627: case 290 : 
line 93628: { 
line 93629: sqlite3ErrorMsg ( pParse , 
line 93630: "the NOT INDEXED clause is not allowed on UPDATE or DELETE statements " 
line 93631: "within triggers" ) ; 
line 93632: } 
line 93633: break ; 
line 93634: case 291 : 
line 93635: { yygotominor . yy473 = sqlite3TriggerUpdateStep ( pParse -> db , & yymsp [ - 4 ] . minor . yy0 , yymsp [ - 1 ] . minor . yy14 , yymsp [ 0 ] . minor . yy132 , yymsp [ - 5 ] . minor . yy186 ) ; } 
line 93636: break ; 
line 93637: case 292 : 
line 93638: { yygotominor . yy473 = sqlite3TriggerInsertStep ( pParse -> db , & yymsp [ - 5 ] . minor . yy0 , yymsp [ - 4 ] . minor . yy408 , yymsp [ - 1 ] . minor . yy14 , 0 , yymsp [ - 7 ] . minor . yy186 ) ; } 
line 93639: break ; 
line 93640: case 293 : 
line 93641: { yygotominor . yy473 = sqlite3TriggerInsertStep ( pParse -> db , & yymsp [ - 2 ] . minor . yy0 , yymsp [ - 1 ] . minor . yy408 , 0 , yymsp [ 0 ] . minor . yy3 , yymsp [ - 4 ] . minor . yy186 ) ; } 
line 93642: break ; 
line 93643: case 294 : 
line 93644: { yygotominor . yy473 = sqlite3TriggerDeleteStep ( pParse -> db , & yymsp [ - 2 ] . minor . yy0 , yymsp [ 0 ] . minor . yy132 ) ; } 
line 93645: break ; 
line 93646: case 295 : 
line 93647: { yygotominor . yy473 = sqlite3TriggerSelectStep ( pParse -> db , yymsp [ 0 ] . minor . yy3 ) ; } 
line 93648: break ; 
line 93649: case 296 : 
line 93650: { 
line 93651: yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_RAISE , 0 , 0 , 0 ) ; 
line 93652: if ( yygotominor . yy346 . pExpr ) { 
line 93653: yygotominor . yy346 . pExpr -> affinity = OE_Ignore ; 
line 93654: } 
line 93655: yygotominor . yy346 . zStart = yymsp [ - 3 ] . minor . yy0 . z ; 
line 93656: yygotominor . yy346 . zEnd = & yymsp [ 0 ] . minor . yy0 . z [ yymsp [ 0 ] . minor . yy0 . n ] ; 
line 93657: } 
line 93658: break ; 
line 93659: case 297 : 
line 93660: { 
line 93661: yygotominor . yy346 . pExpr = sqlite3PExpr ( pParse , TK_RAISE , 0 , 0 , & yymsp [ - 1 ] . minor . yy0 ) ; 
line 93662: if ( yygotominor . yy346 . pExpr ) { 
line 93663: yygotominor . yy346 . pExpr -> affinity = ( char ) yymsp [ - 3 ] . minor . yy328 ; 
line 93664: } 
line 93665: yygotominor . yy346 . zStart = yymsp [ - 5 ] . minor . yy0 . z ; 
line 93666: yygotominor . yy346 . zEnd = & yymsp [ 0 ] . minor . yy0 . z [ yymsp [ 0 ] . minor . yy0 . n ] ; 
line 93667: } 
line 93668: break ; 
line 93669: case 298 : 
line 93670: { yygotominor . yy328 = OE_Rollback ; } 
line 93671: break ; 
line 93672: case 300 : 
line 93673: { yygotominor . yy328 = OE_Fail ; } 
line 93674: break ; 
line 93675: case 301 : 
line 93676: { 
line 93677: sqlite3DropTrigger ( pParse , yymsp [ 0 ] . minor . yy65 , yymsp [ - 1 ] . minor . yy328 ) ; 
line 93678: } 
line 93679: break ; 
line 93680: case 302 : 
line 93681: { 
line 93682: sqlite3Attach ( pParse , yymsp [ - 3 ] . minor . yy346 . pExpr , yymsp [ - 1 ] . minor . yy346 . pExpr , yymsp [ 0 ] . minor . yy132 ) ; 
line 93683: } 
line 93684: break ; 
line 93685: case 303 : 
line 93686: { 
line 93687: sqlite3Detach ( pParse , yymsp [ 0 ] . minor . yy346 . pExpr ) ; 
line 93688: } 
line 93689: break ; 
line 93690: case 308 : 
line 93691: { sqlite3Reindex ( pParse , 0 , 0 ) ; } 
line 93692: break ; 
line 93693: case 309 : 
line 93694: { sqlite3Reindex ( pParse , & yymsp [ - 1 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 ) ; } 
line 93695: break ; 
line 93696: case 310 : 
line 93697: { sqlite3Analyze ( pParse , 0 , 0 ) ; } 
line 93698: break ; 
line 93699: case 311 : 
line 93700: { sqlite3Analyze ( pParse , & yymsp [ - 1 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 ) ; } 
line 93701: break ; 
line 93702: case 312 : 
line 93703: { 
line 93704: sqlite3AlterRenameTable ( pParse , yymsp [ - 3 ] . minor . yy65 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93705: } 
line 93706: break ; 
line 93707: case 313 : 
line 93708: { 
line 93709: sqlite3AlterFinishAddColumn ( pParse , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93710: } 
line 93711: break ; 
line 93712: case 314 : 
line 93713: { 
line 93714: pParse -> db -> lookaside . bEnabled = 0 ; 
line 93715: sqlite3AlterBeginAddColumn ( pParse , yymsp [ 0 ] . minor . yy65 ) ; 
line 93716: } 
line 93717: break ; 
line 93718: case 317 : 
line 93719: { sqlite3VtabFinishParse ( pParse , 0 ) ; } 
line 93720: break ; 
line 93721: case 318 : 
line 93722: { sqlite3VtabFinishParse ( pParse , & yymsp [ 0 ] . minor . yy0 ) ; } 
line 93723: break ; 
line 93724: case 319 : 
line 93725: { 
line 93726: sqlite3VtabBeginParse ( pParse , & yymsp [ - 3 ] . minor . yy0 , & yymsp [ - 2 ] . minor . yy0 , & yymsp [ 0 ] . minor . yy0 ) ; 
line 93727: } 
line 93728: break ; 
line 93729: case 322 : 
line 93730: { sqlite3VtabArgInit ( pParse ) ; } 
line 93731: break ; 
line 93732: case 324 : 
line 93733: case 325 : yytestcase ( yyruleno == 325 ) ; 
line 93734: case 326 : yytestcase ( yyruleno == 326 ) ; 
line 93735: { sqlite3VtabArgExtend ( pParse , & yymsp [ 0 ] . minor . yy0 ) ; } 
line 93736: break ; 
line 93737: default : 
line 93738: yytestcase ( yyruleno == 0 ) ; 
line 93739: yytestcase ( yyruleno == 1 ) ; 
line 93740: yytestcase ( yyruleno == 2 ) ; 
line 93741: yytestcase ( yyruleno == 3 ) ; 
line 93742: yytestcase ( yyruleno == 4 ) ; 
line 93743: yytestcase ( yyruleno == 10 ) ; 
line 93744: yytestcase ( yyruleno == 11 ) ; 
line 93745: yytestcase ( yyruleno == 12 ) ; 
line 93746: yytestcase ( yyruleno == 20 ) ; 
line 93747: yytestcase ( yyruleno == 21 ) ; 
line 93748: yytestcase ( yyruleno == 25 ) ; 
line 93749: yytestcase ( yyruleno == 34 ) ; 
line 93750: yytestcase ( yyruleno == 35 ) ; 
line 93751: yytestcase ( yyruleno == 44 ) ; 
line 93752: yytestcase ( yyruleno == 51 ) ; 
line 93753: yytestcase ( yyruleno == 52 ) ; 
line 93754: yytestcase ( yyruleno == 53 ) ; 
line 93755: yytestcase ( yyruleno == 54 ) ; 
line 93756: yytestcase ( yyruleno == 55 ) ; 
line 93757: yytestcase ( yyruleno == 56 ) ; 
line 93758: yytestcase ( yyruleno == 62 ) ; 
line 93759: yytestcase ( yyruleno == 90 ) ; 
line 93760: yytestcase ( yyruleno == 91 ) ; 
line 93761: yytestcase ( yyruleno == 92 ) ; 
line 93762: yytestcase ( yyruleno == 93 ) ; 
line 93763: yytestcase ( yyruleno == 269 ) ; 
line 93764: yytestcase ( yyruleno == 270 ) ; 
line 93765: yytestcase ( yyruleno == 280 ) ; 
line 93766: yytestcase ( yyruleno == 281 ) ; 
line 93767: yytestcase ( yyruleno == 288 ) ; 
line 93768: yytestcase ( yyruleno == 306 ) ; 
line 93769: yytestcase ( yyruleno == 307 ) ; 
line 93770: yytestcase ( yyruleno == 315 ) ; 
line 93771: yytestcase ( yyruleno == 316 ) ; 
line 93772: yytestcase ( yyruleno == 320 ) ; 
line 93773: yytestcase ( yyruleno == 321 ) ; 
line 93774: yytestcase ( yyruleno == 323 ) ; 
line 93775: yytestcase ( yyruleno == 327 ) ; 
line 93776: yytestcase ( yyruleno == 328 ) ; 
line 93777: yytestcase ( yyruleno == 329 ) ; 
line 93778: break ; 
line 93779: } ; 
line 93780: yygoto = yyRuleInfo [ yyruleno ] . lhs ; 
line 93781: yysize = yyRuleInfo [ yyruleno ] . nrhs ; 
line 93782: yypParser -> yyidx -= yysize ; 
line 93783: yyact = yy_find_reduce_action ( yymsp [ - yysize ] . stateno , ( YYCODETYPE ) yygoto ) ; 
line 93784: if ( yyact < YYNSTATE ) { 
line 93785: # ifdef NDEBUG 
line 93790: if ( yysize ) { 
line 93791: yypParser -> yyidx ++ ; 
line 93792: yymsp -= yysize - 1 ; 
line 93793: yymsp -> stateno = ( YYACTIONTYPE ) yyact ; 
line 93794: yymsp -> major = ( YYCODETYPE ) yygoto ; 
line 93795: yymsp -> minor = yygotominor ; 
line 93796: } else 
line 93797: # endif 
line 93798: { 
line 93799: yy_shift ( yypParser , yyact , yygoto , & yygotominor ) ; 
line 93800: } 
line 93801: } else { 
line 93802: assert ( yyact == YYNSTATE + YYNRULE + 1 ) ; 
line 93803: yy_accept ( yypParser ) ; 
line 93804: } 
line 93805: } 
line 93810: # ifndef YYNOERRORRECOVERY 
line 93811: static void yy_parse_failed ( 
line 93812: yyParser * yypParser 
line 93813: ) { 
line 93814: sqlite3ParserARG_FETCH ; 
line 93815: # ifndef NDEBUG 
line 93816: if ( yyTraceFILE ) { 
line 93817: fprintf ( yyTraceFILE , "%sFail!\n" , yyTracePrompt ) ; 
line 93818: } 
line 93819: # endif 
line 93820: while ( yypParser -> yyidx >= 0 ) yy_pop_parser_stack ( yypParser ) ; 
line 93823: sqlite3ParserARG_STORE ; 
line 93824: } 
line 93825: # endif 
line 93830: static void yy_syntax_error ( 
line 93831: yyParser * yypParser , 
line 93832: int yymajor , 
line 93833: YYMINORTYPE yyminor 
line 93834: ) { 
line 93835: sqlite3ParserARG_FETCH ; 
line 93836: # define TOKEN ( yyminor . yy0 ) 
line 93838: UNUSED_PARAMETER ( yymajor ) ; 
line 93839: assert ( TOKEN . z [ 0 ] ) ; 
line 93840: sqlite3ErrorMsg ( pParse , "near \"%T\": syntax error" , & TOKEN ) ; 
line 93841: pParse -> parseError = 1 ; 
line 93842: sqlite3ParserARG_STORE ; 
line 93843: } 
line 93848: static void yy_accept ( 
line 93849: yyParser * yypParser 
line 93850: ) { 
line 93851: sqlite3ParserARG_FETCH ; 
line 93852: # ifndef NDEBUG 
line 93853: if ( yyTraceFILE ) { 
line 93854: fprintf ( yyTraceFILE , "%sAccept!\n" , yyTracePrompt ) ; 
line 93855: } 
line 93856: # endif 
line 93857: while ( yypParser -> yyidx >= 0 ) yy_pop_parser_stack ( yypParser ) ; 
line 93860: sqlite3ParserARG_STORE ; 
line 93861: } 
line 93882: SQLITE_PRIVATE void sqlite3Parser ( 
line 93883: void * yyp , 
line 93884: int yymajor , 
line 93885: sqlite3ParserTOKENTYPE yyminor 
line 93886: sqlite3ParserARG_PDECL 
line 93887: ) { 
line 93888: YYMINORTYPE yyminorunion ; 
line 93889: int yyact ; 
line 93890: int yyendofinput ; 
line 93891: # ifdef YYERRORSYMBOL 
line 93892: int yyerrorhit = 0 ; 
line 93893: # endif 
line 93894: yyParser * yypParser ; 
line 93897: yypParser = ( yyParser * ) yyp ; 
line 93898: if ( yypParser -> yyidx < 0 ) { 
line 93899: # if YYSTACKDEPTH <= 0 
line 93900: if ( yypParser -> yystksz <= 0 ) { 
line 93902: yyminorunion = yyzerominor ; 
line 93903: yyStackOverflow ( yypParser , & yyminorunion ) ; 
line 93904: return ; 
line 93905: } 
line 93906: # endif 
line 93907: yypParser -> yyidx = 0 ; 
line 93908: yypParser -> yyerrcnt = - 1 ; 
line 93909: yypParser -> yystack [ 0 ] . stateno = 0 ; 
line 93910: yypParser -> yystack [ 0 ] . major = 0 ; 
line 93911: } 
line 93912: yyminorunion . yy0 = yyminor ; 
line 93913: yyendofinput = ( yymajor == 0 ) ; 
line 93914: sqlite3ParserARG_STORE ; 
line 93916: # ifndef NDEBUG 
line 93917: if ( yyTraceFILE ) { 
line 93918: fprintf ( yyTraceFILE , "%sInput %s\n" , yyTracePrompt , yyTokenName [ yymajor ] ) ; 
line 93919: } 
line 93920: # endif 
line 93922: do { 
line 93923: yyact = yy_find_shift_action ( yypParser , ( YYCODETYPE ) yymajor ) ; 
line 93924: if ( yyact < YYNSTATE ) { 
line 93925: assert ( ! yyendofinput ) ; 
line 93926: yy_shift ( yypParser , yyact , yymajor , & yyminorunion ) ; 
line 93927: yypParser -> yyerrcnt -- ; 
line 93928: yymajor = YYNOCODE ; 
line 93929: } else if ( yyact < YYNSTATE + YYNRULE ) { 
line 93930: yy_reduce ( yypParser , yyact - YYNSTATE ) ; 
line 93931: } else { 
line 93932: assert ( yyact == YY_ERROR_ACTION ) ; 
line 93933: # ifdef YYERRORSYMBOL 
line 93934: int yymx ; 
line 93935: # endif 
line 93936: # ifndef NDEBUG 
line 93937: if ( yyTraceFILE ) { 
line 93938: fprintf ( yyTraceFILE , "%sSyntax Error!\n" , yyTracePrompt ) ; 
line 93939: } 
line 93940: # endif 
line 93941: # ifdef YYERRORSYMBOL 
line 93961: if ( yypParser -> yyerrcnt < 0 ) { 
line 93962: yy_syntax_error ( yypParser , yymajor , yyminorunion ) ; 
line 93963: } 
line 93964: yymx = yypParser -> yystack [ yypParser -> yyidx ] . major ; 
line 93965: if ( yymx == YYERRORSYMBOL || yyerrorhit ) { 
line 93966: # ifndef NDEBUG 
line 93967: if ( yyTraceFILE ) { 
line 93968: fprintf ( yyTraceFILE , "%sDiscard input token %s\n" , 
line 93969: yyTracePrompt , yyTokenName [ yymajor ] ) ; 
line 93970: } 
line 93971: # endif 
line 93972: yy_destructor ( yypParser , ( YYCODETYPE ) yymajor , & yyminorunion ) ; 
line 93973: yymajor = YYNOCODE ; 
line 93974: } else { 
line 93975: while ( 
line 93976: yypParser -> yyidx >= 0 && 
line 93977: yymx != YYERRORSYMBOL && 
line 93978: ( yyact = yy_find_reduce_action ( 
line 93979: yypParser -> yystack [ yypParser -> yyidx ] . stateno , 
line 93980: YYERRORSYMBOL ) ) >= YYNSTATE 
line 93981: ) { 
line 93982: yy_pop_parser_stack ( yypParser ) ; 
line 93983: } 
line 93984: if ( yypParser -> yyidx < 0 || yymajor == 0 ) { 
line 93985: yy_destructor ( yypParser , ( YYCODETYPE ) yymajor , & yyminorunion ) ; 
line 93986: yy_parse_failed ( yypParser ) ; 
line 93987: yymajor = YYNOCODE ; 
line 93988: } else if ( yymx != YYERRORSYMBOL ) { 
line 93989: YYMINORTYPE u2 ; 
line 93990: u2 . YYERRSYMDT = 0 ; 
line 93991: yy_shift ( yypParser , yyact , YYERRORSYMBOL , & u2 ) ; 
line 93992: } 
line 93993: } 
line 93994: yypParser -> yyerrcnt = 3 ; 
line 93995: yyerrorhit = 1 ; 
line 93996: # elif defined ( YYNOERRORRECOVERY ) 
line 94004: yy_syntax_error ( yypParser , yymajor , yyminorunion ) ; 
line 94005: yy_destructor ( yypParser , ( YYCODETYPE ) yymajor , & yyminorunion ) ; 
line 94006: yymajor = YYNOCODE ; 
line 94008: # else 
line 94018: if ( yypParser -> yyerrcnt <= 0 ) { 
line 94019: yy_syntax_error ( yypParser , yymajor , yyminorunion ) ; 
line 94020: } 
line 94021: yypParser -> yyerrcnt = 3 ; 
line 94022: yy_destructor ( yypParser , ( YYCODETYPE ) yymajor , & yyminorunion ) ; 
line 94023: if ( yyendofinput ) { 
line 94024: yy_parse_failed ( yypParser ) ; 
line 94025: } 
line 94026: yymajor = YYNOCODE ; 
line 94027: # endif 
line 94028: } 
line 94029: } while ( yymajor != YYNOCODE && yypParser -> yyidx >= 0 ) ; 
line 94030: return ; 
line 94031: } 
line 94060: # ifdef SQLITE_ASCII 
line 94061: # define charMap ( X ) sqlite3UpperToLower [ ( unsigned char ) X ] 
line 94062: # endif 
line 94063: # ifdef SQLITE_EBCDIC 
line 94064: # define charMap ( X ) ebcdicToAscii [ ( unsigned char ) X ] 
line 94065: const unsigned char ebcdicToAscii [ ] = { 
line 94067: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94068: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94069: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94070: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94071: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94072: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94073: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 95 , 0 , 0 , 
line 94074: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94075: 0 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94076: 0 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94077: 0 , 0 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94078: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94079: 0 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94080: 0 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94081: 0 , 0 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94082: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94083: } ; 
line 94084: # endif 
line 94113: static int keywordCode ( const char * z , int n ) { 
line 94125: static const char zText [ 540 ] = { 
line 94126: 'R' , 'E' , 'I' , 'N' , 'D' , 'E' , 'X' , 'E' , 'D' , 'E' , 'S' , 'C' , 'A' , 'P' , 'E' , 'A' , 'C' , 'H' , 
line 94127: 'E' , 'C' , 'K' , 'E' , 'Y' , 'B' , 'E' , 'F' , 'O' , 'R' , 'E' , 'I' , 'G' , 'N' , 'O' , 'R' , 'E' , 'G' , 
line 94128: 'E' , 'X' , 'P' , 'L' , 'A' , 'I' , 'N' , 'S' , 'T' , 'E' , 'A' , 'D' , 'D' , 'A' , 'T' , 'A' , 'B' , 'A' , 
line 94129: 'S' , 'E' , 'L' , 'E' , 'C' , 'T' , 'A' , 'B' , 'L' , 'E' , 'F' , 'T' , 'H' , 'E' , 'N' , 'D' , 'E' , 'F' , 
line 94130: 'E' , 'R' , 'R' , 'A' , 'B' , 'L' , 'E' , 'L' , 'S' , 'E' , 'X' , 'C' , 'E' , 'P' , 'T' , 'R' , 'A' , 'N' , 
line 94131: 'S' , 'A' , 'C' , 'T' , 'I' , 'O' , 'N' , 'A' , 'T' , 'U' , 'R' , 'A' , 'L' , 'T' , 'E' , 'R' , 'A' , 'I' , 
line 94132: 'S' , 'E' , 'X' , 'C' , 'L' , 'U' , 'S' , 'I' , 'V' , 'E' , 'X' , 'I' , 'S' , 'T' , 'S' , 'A' , 'V' , 'E' , 
line 94133: 'P' , 'O' , 'I' , 'N' , 'T' , 'E' , 'R' , 'S' , 'E' , 'C' , 'T' , 'R' , 'I' , 'G' , 'G' , 'E' , 'R' , 'E' , 
line 94134: 'F' , 'E' , 'R' , 'E' , 'N' , 'C' , 'E' , 'S' , 'C' , 'O' , 'N' , 'S' , 'T' , 'R' , 'A' , 'I' , 'N' , 'T' , 
line 94135: 'O' , 'F' , 'F' , 'S' , 'E' , 'T' , 'E' , 'M' , 'P' , 'O' , 'R' , 'A' , 'R' , 'Y' , 'U' , 'N' , 'I' , 'Q' , 
line 94136: 'U' , 'E' , 'R' , 'Y' , 'A' , 'T' , 'T' , 'A' , 'C' , 'H' , 'A' , 'V' , 'I' , 'N' , 'G' , 'R' , 'O' , 'U' , 
line 94137: 'P' , 'D' , 'A' , 'T' , 'E' , 'B' , 'E' , 'G' , 'I' , 'N' , 'N' , 'E' , 'R' , 'E' , 'L' , 'E' , 'A' , 'S' , 
line 94138: 'E' , 'B' , 'E' , 'T' , 'W' , 'E' , 'E' , 'N' , 'O' , 'T' , 'N' , 'U' , 'L' , 'L' , 'I' , 'K' , 'E' , 'C' , 
line 94139: 'A' , 'S' , 'C' , 'A' , 'D' , 'E' , 'L' , 'E' , 'T' , 'E' , 'C' , 'A' , 'S' , 'E' , 'C' , 'O' , 'L' , 'L' , 
line 94140: 'A' , 'T' , 'E' , 'C' , 'R' , 'E' , 'A' , 'T' , 'E' , 'C' , 'U' , 'R' , 'R' , 'E' , 'N' , 'T' , '_' , 'D' , 
line 94141: 'A' , 'T' , 'E' , 'D' , 'E' , 'T' , 'A' , 'C' , 'H' , 'I' , 'M' , 'M' , 'E' , 'D' , 'I' , 'A' , 'T' , 'E' , 
line 94142: 'J' , 'O' , 'I' , 'N' , 'S' , 'E' , 'R' , 'T' , 'M' , 'A' , 'T' , 'C' , 'H' , 'P' , 'L' , 'A' , 'N' , 'A' , 
line 94143: 'L' , 'Y' , 'Z' , 'E' , 'P' , 'R' , 'A' , 'G' , 'M' , 'A' , 'B' , 'O' , 'R' , 'T' , 'V' , 'A' , 'L' , 'U' , 
line 94144: 'E' , 'S' , 'V' , 'I' , 'R' , 'T' , 'U' , 'A' , 'L' , 'I' , 'M' , 'I' , 'T' , 'W' , 'H' , 'E' , 'N' , 'W' , 
line 94145: 'H' , 'E' , 'R' , 'E' , 'N' , 'A' , 'M' , 'E' , 'A' , 'F' , 'T' , 'E' , 'R' , 'E' , 'P' , 'L' , 'A' , 'C' , 
line 94146: 'E' , 'A' , 'N' , 'D' , 'E' , 'F' , 'A' , 'U' , 'L' , 'T' , 'A' , 'U' , 'T' , 'O' , 'I' , 'N' , 'C' , 'R' , 
line 94147: 'E' , 'M' , 'E' , 'N' , 'T' , 'C' , 'A' , 'S' , 'T' , 'C' , 'O' , 'L' , 'U' , 'M' , 'N' , 'C' , 'O' , 'M' , 
line 94148: 'M' , 'I' , 'T' , 'C' , 'O' , 'N' , 'F' , 'L' , 'I' , 'C' , 'T' , 'C' , 'R' , 'O' , 'S' , 'S' , 'C' , 'U' , 
line 94149: 'R' , 'R' , 'E' , 'N' , 'T' , '_' , 'T' , 'I' , 'M' , 'E' , 'S' , 'T' , 'A' , 'M' , 'P' , 'R' , 'I' , 'M' , 
line 94150: 'A' , 'R' , 'Y' , 'D' , 'E' , 'F' , 'E' , 'R' , 'R' , 'E' , 'D' , 'I' , 'S' , 'T' , 'I' , 'N' , 'C' , 'T' , 
line 94151: 'D' , 'R' , 'O' , 'P' , 'F' , 'A' , 'I' , 'L' , 'F' , 'R' , 'O' , 'M' , 'F' , 'U' , 'L' , 'L' , 'G' , 'L' , 
line 94152: 'O' , 'B' , 'Y' , 'I' , 'F' , 'I' , 'S' , 'N' , 'U' , 'L' , 'L' , 'O' , 'R' , 'D' , 'E' , 'R' , 'E' , 'S' , 
line 94153: 'T' , 'R' , 'I' , 'C' , 'T' , 'O' , 'U' , 'T' , 'E' , 'R' , 'I' , 'G' , 'H' , 'T' , 'R' , 'O' , 'L' , 'L' , 
line 94154: 'B' , 'A' , 'C' , 'K' , 'R' , 'O' , 'W' , 'U' , 'N' , 'I' , 'O' , 'N' , 'U' , 'S' , 'I' , 'N' , 'G' , 'V' , 
line 94155: 'A' , 'C' , 'U' , 'U' , 'M' , 'V' , 'I' , 'E' , 'W' , 'I' , 'N' , 'I' , 'T' , 'I' , 'A' , 'L' , 'L' , 'Y' , 
line 94156: } ; 
line 94157: static const unsigned char aHash [ 127 ] = { 
line 94158: 72 , 101 , 114 , 70 , 0 , 45 , 0 , 0 , 78 , 0 , 73 , 0 , 0 , 
line 94159: 42 , 12 , 74 , 15 , 0 , 113 , 81 , 50 , 108 , 0 , 19 , 0 , 0 , 
line 94160: 118 , 0 , 116 , 111 , 0 , 22 , 89 , 0 , 9 , 0 , 0 , 66 , 67 , 
line 94161: 0 , 65 , 6 , 0 , 48 , 86 , 98 , 0 , 115 , 97 , 0 , 0 , 44 , 
line 94162: 0 , 99 , 24 , 0 , 17 , 0 , 119 , 49 , 23 , 0 , 5 , 106 , 25 , 
line 94163: 92 , 0 , 0 , 121 , 102 , 56 , 120 , 53 , 28 , 51 , 0 , 87 , 0 , 
line 94164: 96 , 26 , 0 , 95 , 0 , 0 , 0 , 91 , 88 , 93 , 84 , 105 , 14 , 
line 94165: 39 , 104 , 0 , 77 , 0 , 18 , 85 , 107 , 32 , 0 , 117 , 76 , 109 , 
line 94166: 58 , 46 , 80 , 0 , 0 , 90 , 40 , 0 , 112 , 0 , 36 , 0 , 0 , 
line 94167: 29 , 0 , 82 , 59 , 60 , 0 , 20 , 57 , 0 , 52 , 
line 94168: } ; 
line 94169: static const unsigned char aNext [ 121 ] = { 
line 94170: 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94171: 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 13 , 0 , 0 , 0 , 0 , 
line 94172: 0 , 7 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94173: 0 , 0 , 0 , 0 , 33 , 0 , 21 , 0 , 0 , 0 , 43 , 3 , 47 , 
line 94174: 0 , 0 , 0 , 0 , 30 , 0 , 54 , 0 , 38 , 0 , 0 , 0 , 1 , 
line 94175: 62 , 0 , 0 , 63 , 0 , 41 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94176: 61 , 0 , 0 , 0 , 0 , 31 , 55 , 16 , 34 , 10 , 0 , 0 , 0 , 
line 94177: 0 , 0 , 0 , 0 , 11 , 68 , 75 , 0 , 8 , 0 , 100 , 94 , 0 , 
line 94178: 103 , 0 , 83 , 0 , 71 , 0 , 0 , 110 , 27 , 37 , 69 , 79 , 0 , 
line 94179: 35 , 64 , 0 , 0 , 
line 94180: } ; 
line 94181: static const unsigned char aLen [ 121 ] = { 
line 94182: 7 , 7 , 5 , 4 , 6 , 4 , 5 , 3 , 6 , 7 , 3 , 6 , 6 , 
line 94183: 7 , 7 , 3 , 8 , 2 , 6 , 5 , 4 , 4 , 3 , 10 , 4 , 6 , 
line 94184: 11 , 6 , 2 , 7 , 5 , 5 , 9 , 6 , 9 , 9 , 7 , 10 , 10 , 
line 94185: 4 , 6 , 2 , 3 , 9 , 4 , 2 , 6 , 5 , 6 , 6 , 5 , 6 , 
line 94186: 5 , 5 , 7 , 7 , 7 , 3 , 2 , 4 , 4 , 7 , 3 , 6 , 4 , 
line 94187: 7 , 6 , 12 , 6 , 9 , 4 , 6 , 5 , 4 , 7 , 6 , 5 , 6 , 
line 94188: 7 , 5 , 4 , 5 , 6 , 5 , 7 , 3 , 7 , 13 , 2 , 2 , 4 , 
line 94189: 6 , 6 , 8 , 5 , 17 , 12 , 7 , 8 , 8 , 2 , 4 , 4 , 4 , 
line 94190: 4 , 4 , 2 , 2 , 6 , 5 , 8 , 5 , 5 , 8 , 3 , 5 , 5 , 
line 94191: 6 , 4 , 9 , 3 , 
line 94192: } ; 
line 94193: static const unsigned short int aOffset [ 121 ] = { 
line 94194: 0 , 2 , 2 , 8 , 9 , 14 , 16 , 20 , 23 , 25 , 25 , 29 , 33 , 
line 94195: 36 , 41 , 46 , 48 , 53 , 54 , 59 , 62 , 65 , 67 , 69 , 78 , 81 , 
line 94196: 86 , 91 , 95 , 96 , 101 , 105 , 109 , 117 , 122 , 128 , 136 , 142 , 152 , 
line 94197: 159 , 162 , 162 , 165 , 167 , 167 , 171 , 176 , 179 , 184 , 189 , 194 , 197 , 
line 94198: 203 , 206 , 210 , 217 , 223 , 223 , 223 , 226 , 229 , 233 , 234 , 238 , 244 , 
line 94199: 248 , 255 , 261 , 273 , 279 , 288 , 290 , 296 , 301 , 303 , 310 , 315 , 320 , 
line 94200: 326 , 332 , 337 , 341 , 344 , 350 , 354 , 361 , 363 , 370 , 372 , 374 , 383 , 
line 94201: 387 , 393 , 399 , 407 , 412 , 412 , 428 , 435 , 442 , 443 , 450 , 454 , 458 , 
line 94202: 462 , 466 , 469 , 471 , 473 , 479 , 483 , 491 , 495 , 500 , 508 , 511 , 516 , 
line 94203: 521 , 527 , 531 , 536 , 
line 94204: } ; 
line 94205: static const unsigned char aCode [ 121 ] = { 
line 94206: TK_REINDEX , TK_INDEXED , TK_INDEX , TK_DESC , TK_ESCAPE , 
line 94207: TK_EACH , TK_CHECK , TK_KEY , TK_BEFORE , TK_FOREIGN , 
line 94208: TK_FOR , TK_IGNORE , TK_LIKE_KW , TK_EXPLAIN , TK_INSTEAD , 
line 94209: TK_ADD , TK_DATABASE , TK_AS , TK_SELECT , TK_TABLE , 
line 94210: TK_JOIN_KW , TK_THEN , TK_END , TK_DEFERRABLE , TK_ELSE , 
line 94211: TK_EXCEPT , TK_TRANSACTION , TK_ACTION , TK_ON , TK_JOIN_KW , 
line 94212: TK_ALTER , TK_RAISE , TK_EXCLUSIVE , TK_EXISTS , TK_SAVEPOINT , 
line 94213: TK_INTERSECT , TK_TRIGGER , TK_REFERENCES , TK_CONSTRAINT , TK_INTO , 
line 94214: TK_OFFSET , TK_OF , TK_SET , TK_TEMP , TK_TEMP , 
line 94215: TK_OR , TK_UNIQUE , TK_QUERY , TK_ATTACH , TK_HAVING , 
line 94216: TK_GROUP , TK_UPDATE , TK_BEGIN , TK_JOIN_KW , TK_RELEASE , 
line 94217: TK_BETWEEN , TK_NOTNULL , TK_NOT , TK_NO , TK_NULL , 
line 94218: TK_LIKE_KW , TK_CASCADE , TK_ASC , TK_DELETE , TK_CASE , 
line 94219: TK_COLLATE , TK_CREATE , TK_CTIME_KW , TK_DETACH , TK_IMMEDIATE , 
line 94220: TK_JOIN , TK_INSERT , TK_MATCH , TK_PLAN , TK_ANALYZE , 
line 94221: TK_PRAGMA , TK_ABORT , TK_VALUES , TK_VIRTUAL , TK_LIMIT , 
line 94222: TK_WHEN , TK_WHERE , TK_RENAME , TK_AFTER , TK_REPLACE , 
line 94223: TK_AND , TK_DEFAULT , TK_AUTOINCR , TK_TO , TK_IN , 
line 94224: TK_CAST , TK_COLUMNKW , TK_COMMIT , TK_CONFLICT , TK_JOIN_KW , 
line 94225: TK_CTIME_KW , TK_CTIME_KW , TK_PRIMARY , TK_DEFERRED , TK_DISTINCT , 
line 94226: TK_IS , TK_DROP , TK_FAIL , TK_FROM , TK_JOIN_KW , 
line 94227: TK_LIKE_KW , TK_BY , TK_IF , TK_ISNULL , TK_ORDER , 
line 94228: TK_RESTRICT , TK_JOIN_KW , TK_JOIN_KW , TK_ROLLBACK , TK_ROW , 
line 94229: TK_UNION , TK_USING , TK_VACUUM , TK_VIEW , TK_INITIALLY , 
line 94230: TK_ALL , 
line 94231: } ; 
line 94232: int h , i ; 
line 94233: if ( n < 2 ) return TK_ID ; 
line 94234: h = ( ( charMap ( z [ 0 ] ) * 4 ) ^ 
line 94235: ( charMap ( z [ n - 1 ] ) * 3 ) ^ 
line 94236: n ) % 127 ; 
line 94237: for ( i = ( ( int ) aHash [ h ] ) - 1 ; i >= 0 ; i = ( ( int ) aNext [ i ] ) - 1 ) { 
line 94238: if ( aLen [ i ] == n && sqlite3StrNICmp ( & zText [ aOffset [ i ] ] , z , n ) == 0 ) { 
line 94239: testcase ( i == 0 ) ; 
line 94240: testcase ( i == 1 ) ; 
line 94241: testcase ( i == 2 ) ; 
line 94242: testcase ( i == 3 ) ; 
line 94243: testcase ( i == 4 ) ; 
line 94244: testcase ( i == 5 ) ; 
line 94245: testcase ( i == 6 ) ; 
line 94246: testcase ( i == 7 ) ; 
line 94247: testcase ( i == 8 ) ; 
line 94248: testcase ( i == 9 ) ; 
line 94249: testcase ( i == 10 ) ; 
line 94250: testcase ( i == 11 ) ; 
line 94251: testcase ( i == 12 ) ; 
line 94252: testcase ( i == 13 ) ; 
line 94253: testcase ( i == 14 ) ; 
line 94254: testcase ( i == 15 ) ; 
line 94255: testcase ( i == 16 ) ; 
line 94256: testcase ( i == 17 ) ; 
line 94257: testcase ( i == 18 ) ; 
line 94258: testcase ( i == 19 ) ; 
line 94259: testcase ( i == 20 ) ; 
line 94260: testcase ( i == 21 ) ; 
line 94261: testcase ( i == 22 ) ; 
line 94262: testcase ( i == 23 ) ; 
line 94263: testcase ( i == 24 ) ; 
line 94264: testcase ( i == 25 ) ; 
line 94265: testcase ( i == 26 ) ; 
line 94266: testcase ( i == 27 ) ; 
line 94267: testcase ( i == 28 ) ; 
line 94268: testcase ( i == 29 ) ; 
line 94269: testcase ( i == 30 ) ; 
line 94270: testcase ( i == 31 ) ; 
line 94271: testcase ( i == 32 ) ; 
line 94272: testcase ( i == 33 ) ; 
line 94273: testcase ( i == 34 ) ; 
line 94274: testcase ( i == 35 ) ; 
line 94275: testcase ( i == 36 ) ; 
line 94276: testcase ( i == 37 ) ; 
line 94277: testcase ( i == 38 ) ; 
line 94278: testcase ( i == 39 ) ; 
line 94279: testcase ( i == 40 ) ; 
line 94280: testcase ( i == 41 ) ; 
line 94281: testcase ( i == 42 ) ; 
line 94282: testcase ( i == 43 ) ; 
line 94283: testcase ( i == 44 ) ; 
line 94284: testcase ( i == 45 ) ; 
line 94285: testcase ( i == 46 ) ; 
line 94286: testcase ( i == 47 ) ; 
line 94287: testcase ( i == 48 ) ; 
line 94288: testcase ( i == 49 ) ; 
line 94289: testcase ( i == 50 ) ; 
line 94290: testcase ( i == 51 ) ; 
line 94291: testcase ( i == 52 ) ; 
line 94292: testcase ( i == 53 ) ; 
line 94293: testcase ( i == 54 ) ; 
line 94294: testcase ( i == 55 ) ; 
line 94295: testcase ( i == 56 ) ; 
line 94296: testcase ( i == 57 ) ; 
line 94297: testcase ( i == 58 ) ; 
line 94298: testcase ( i == 59 ) ; 
line 94299: testcase ( i == 60 ) ; 
line 94300: testcase ( i == 61 ) ; 
line 94301: testcase ( i == 62 ) ; 
line 94302: testcase ( i == 63 ) ; 
line 94303: testcase ( i == 64 ) ; 
line 94304: testcase ( i == 65 ) ; 
line 94305: testcase ( i == 66 ) ; 
line 94306: testcase ( i == 67 ) ; 
line 94307: testcase ( i == 68 ) ; 
line 94308: testcase ( i == 69 ) ; 
line 94309: testcase ( i == 70 ) ; 
line 94310: testcase ( i == 71 ) ; 
line 94311: testcase ( i == 72 ) ; 
line 94312: testcase ( i == 73 ) ; 
line 94313: testcase ( i == 74 ) ; 
line 94314: testcase ( i == 75 ) ; 
line 94315: testcase ( i == 76 ) ; 
line 94316: testcase ( i == 77 ) ; 
line 94317: testcase ( i == 78 ) ; 
line 94318: testcase ( i == 79 ) ; 
line 94319: testcase ( i == 80 ) ; 
line 94320: testcase ( i == 81 ) ; 
line 94321: testcase ( i == 82 ) ; 
line 94322: testcase ( i == 83 ) ; 
line 94323: testcase ( i == 84 ) ; 
line 94324: testcase ( i == 85 ) ; 
line 94325: testcase ( i == 86 ) ; 
line 94326: testcase ( i == 87 ) ; 
line 94327: testcase ( i == 88 ) ; 
line 94328: testcase ( i == 89 ) ; 
line 94329: testcase ( i == 90 ) ; 
line 94330: testcase ( i == 91 ) ; 
line 94331: testcase ( i == 92 ) ; 
line 94332: testcase ( i == 93 ) ; 
line 94333: testcase ( i == 94 ) ; 
line 94334: testcase ( i == 95 ) ; 
line 94335: testcase ( i == 96 ) ; 
line 94336: testcase ( i == 97 ) ; 
line 94337: testcase ( i == 98 ) ; 
line 94338: testcase ( i == 99 ) ; 
line 94339: testcase ( i == 100 ) ; 
line 94340: testcase ( i == 101 ) ; 
line 94341: testcase ( i == 102 ) ; 
line 94342: testcase ( i == 103 ) ; 
line 94343: testcase ( i == 104 ) ; 
line 94344: testcase ( i == 105 ) ; 
line 94345: testcase ( i == 106 ) ; 
line 94346: testcase ( i == 107 ) ; 
line 94347: testcase ( i == 108 ) ; 
line 94348: testcase ( i == 109 ) ; 
line 94349: testcase ( i == 110 ) ; 
line 94350: testcase ( i == 111 ) ; 
line 94351: testcase ( i == 112 ) ; 
line 94352: testcase ( i == 113 ) ; 
line 94353: testcase ( i == 114 ) ; 
line 94354: testcase ( i == 115 ) ; 
line 94355: testcase ( i == 116 ) ; 
line 94356: testcase ( i == 117 ) ; 
line 94357: testcase ( i == 118 ) ; 
line 94358: testcase ( i == 119 ) ; 
line 94359: testcase ( i == 120 ) ; 
line 94360: return aCode [ i ] ; 
line 94361: } 
line 94362: } 
line 94363: return TK_ID ; 
line 94364: } 
line 94365: SQLITE_PRIVATE int sqlite3KeywordCode ( const unsigned char * z , int n ) { 
line 94366: return keywordCode ( ( char * ) z , n ) ; 
line 94367: } 
line 94368: # define SQLITE_N_KEYWORD 121 
line 94390: # ifdef SQLITE_ASCII 
line 94391: # define IdChar ( C ) ( ( sqlite3CtypeMap [ ( unsigned char ) C ] & 0x46 ) != 0 ) 
line 94392: # endif 
line 94393: # ifdef SQLITE_EBCDIC 
line 94394: SQLITE_PRIVATE const char sqlite3IsEbcdicIdChar [ ] = { 
line 94396: 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94397: 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 
line 94398: 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 
line 94399: 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94400: 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 
line 94401: 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 
line 94402: 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 
line 94403: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 94404: 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 
line 94405: 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 
line 94406: 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 
line 94407: 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 
line 94408: } ; 
line 94409: # define IdChar ( C ) ( ( ( c = C ) >= 0x42 && sqlite3IsEbcdicIdChar [ c - 0x40 ] ) ) 
line 94410: # endif 
line 94417: SQLITE_PRIVATE int sqlite3GetToken ( const unsigned char * z , int * tokenType ) { 
line 94418: int i , c ; 
line 94419: switch ( * z ) { 
line 94420: case ' ' : case '\t' : case '\n' : case '\f' : case '\r' : { 
line 94421: testcase ( z [ 0 ] == ' ' ) ; 
line 94422: testcase ( z [ 0 ] == '\t' ) ; 
line 94423: testcase ( z [ 0 ] == '\n' ) ; 
line 94424: testcase ( z [ 0 ] == '\f' ) ; 
line 94425: testcase ( z [ 0 ] == '\r' ) ; 
line 94426: for ( i = 1 ; sqlite3Isspace ( z [ i ] ) ; i ++ ) { } 
line 94427: * tokenType = TK_SPACE ; 
line 94428: return i ; 
line 94429: } 
line 94430: case '-' : { 
line 94431: if ( z [ 1 ] == '-' ) { 
line 94433: for ( i = 2 ; ( c = z [ i ] ) != 0 && c != '\n' ; i ++ ) { } 
line 94434: * tokenType = TK_SPACE ; 
line 94435: return i ; 
line 94436: } 
line 94437: * tokenType = TK_MINUS ; 
line 94438: return 1 ; 
line 94439: } 
line 94440: case '(' : { 
line 94441: * tokenType = TK_LP ; 
line 94442: return 1 ; 
line 94443: } 
line 94444: case ')' : { 
line 94445: * tokenType = TK_RP ; 
line 94446: return 1 ; 
line 94447: } 
line 94448: case ';' : { 
line 94449: * tokenType = TK_SEMI ; 
line 94450: return 1 ; 
line 94451: } 
line 94452: case '+' : { 
line 94453: * tokenType = TK_PLUS ; 
line 94454: return 1 ; 
line 94455: } 
line 94456: case '*' : { 
line 94457: * tokenType = TK_STAR ; 
line 94458: return 1 ; 
line 94459: } 
line 94460: case '/' : { 
line 94461: if ( z [ 1 ] != '*' || z [ 2 ] == 0 ) { 
line 94462: * tokenType = TK_SLASH ; 
line 94463: return 1 ; 
line 94464: } 
line 94466: for ( i = 3 , c = z [ 2 ] ; ( c != '*' || z [ i ] != '/' ) && ( c = z [ i ] ) != 0 ; i ++ ) { } 
line 94467: if ( c ) i ++ ; 
line 94468: * tokenType = TK_SPACE ; 
line 94469: return i ; 
line 94470: } 
line 94471: case '%' : { 
line 94472: * tokenType = TK_REM ; 
line 94473: return 1 ; 
line 94474: } 
line 94475: case '=' : { 
line 94476: * tokenType = TK_EQ ; 
line 94477: return 1 + ( z [ 1 ] == '=' ) ; 
line 94478: } 
line 94479: case '<' : { 
line 94480: if ( ( c = z [ 1 ] ) == '=' ) { 
line 94481: * tokenType = TK_LE ; 
line 94482: return 2 ; 
line 94483: } else if ( c == '>' ) { 
line 94484: * tokenType = TK_NE ; 
line 94485: return 2 ; 
line 94486: } else if ( c == '<' ) { 
line 94487: * tokenType = TK_LSHIFT ; 
line 94488: return 2 ; 
line 94489: } else { 
line 94490: * tokenType = TK_LT ; 
line 94491: return 1 ; 
line 94492: } 
line 94493: } 
line 94494: case '>' : { 
line 94495: if ( ( c = z [ 1 ] ) == '=' ) { 
line 94496: * tokenType = TK_GE ; 
line 94497: return 2 ; 
line 94498: } else if ( c == '>' ) { 
line 94499: * tokenType = TK_RSHIFT ; 
line 94500: return 2 ; 
line 94501: } else { 
line 94502: * tokenType = TK_GT ; 
line 94503: return 1 ; 
line 94504: } 
line 94505: } 
line 94506: case '!' : { 
line 94507: if ( z [ 1 ] != '=' ) { 
line 94508: * tokenType = TK_ILLEGAL ; 
line 94509: return 2 ; 
line 94510: } else { 
line 94511: * tokenType = TK_NE ; 
line 94512: return 2 ; 
line 94513: } 
line 94514: } 
line 94515: case '|' : { 
line 94516: if ( z [ 1 ] != '|' ) { 
line 94517: * tokenType = TK_BITOR ; 
line 94518: return 1 ; 
line 94519: } else { 
line 94520: * tokenType = TK_CONCAT ; 
line 94521: return 2 ; 
line 94522: } 
line 94523: } 
line 94524: case ',' : { 
line 94525: * tokenType = TK_COMMA ; 
line 94526: return 1 ; 
line 94527: } 
line 94528: case '&' : { 
line 94529: * tokenType = TK_BITAND ; 
line 94530: return 1 ; 
line 94531: } 
line 94532: case '~' : { 
line 94533: * tokenType = TK_BITNOT ; 
line 94534: return 1 ; 
line 94535: } 
line 94536: case '`' : 
line 94537: case '\'' : 
line 94538: case '"' : { 
line 94539: int delim = z [ 0 ] ; 
line 94540: testcase ( delim == '`' ) ; 
line 94541: testcase ( delim == '\'' ) ; 
line 94542: testcase ( delim == '"' ) ; 
line 94543: for ( i = 1 ; ( c = z [ i ] ) != 0 ; i ++ ) { 
line 94544: if ( c == delim ) { 
line 94545: if ( z [ i + 1 ] == delim ) { 
line 94546: i ++ ; 
line 94547: } else { 
line 94548: break ; 
line 94549: } 
line 94550: } 
line 94551: } 
line 94552: if ( c == '\'' ) { 
line 94553: * tokenType = TK_STRING ; 
line 94554: return i + 1 ; 
line 94555: } else if ( c != 0 ) { 
line 94556: * tokenType = TK_ID ; 
line 94557: return i + 1 ; 
line 94558: } else { 
line 94559: * tokenType = TK_ILLEGAL ; 
line 94560: return i ; 
line 94561: } 
line 94562: } 
line 94563: case '.' : { 
line 94564: # ifndef SQLITE_OMIT_FLOATING_POINT 
line 94565: if ( ! sqlite3Isdigit ( z [ 1 ] ) ) 
line 94566: # endif 
line 94567: { 
line 94568: * tokenType = TK_DOT ; 
line 94569: return 1 ; 
line 94570: } 
line 94573: } 
line 94574: case '0' : case '1' : case '2' : case '3' : case '4' : 
line 94575: case '5' : case '6' : case '7' : case '8' : case '9' : { 
line 94576: testcase ( z [ 0 ] == '0' ) ; testcase ( z [ 0 ] == '1' ) ; testcase ( z [ 0 ] == '2' ) ; 
line 94577: testcase ( z [ 0 ] == '3' ) ; testcase ( z [ 0 ] == '4' ) ; testcase ( z [ 0 ] == '5' ) ; 
line 94578: testcase ( z [ 0 ] == '6' ) ; testcase ( z [ 0 ] == '7' ) ; testcase ( z [ 0 ] == '8' ) ; 
line 94579: testcase ( z [ 0 ] == '9' ) ; 
line 94580: * tokenType = TK_INTEGER ; 
line 94581: for ( i = 0 ; sqlite3Isdigit ( z [ i ] ) ; i ++ ) { } 
line 94582: # ifndef SQLITE_OMIT_FLOATING_POINT 
line 94583: if ( z [ i ] == '.' ) { 
line 94584: i ++ ; 
line 94585: while ( sqlite3Isdigit ( z [ i ] ) ) { i ++ ; } 
line 94586: * tokenType = TK_FLOAT ; 
line 94587: } 
line 94588: if ( ( z [ i ] == 'e' || z [ i ] == 'E' ) && 
line 94589: ( sqlite3Isdigit ( z [ i + 1 ] ) 
line 94590: || ( ( z [ i + 1 ] == '+' || z [ i + 1 ] == '-' ) && sqlite3Isdigit ( z [ i + 2 ] ) ) 
line 94591: ) 
line 94592: ) { 
line 94593: i += 2 ; 
line 94594: while ( sqlite3Isdigit ( z [ i ] ) ) { i ++ ; } 
line 94595: * tokenType = TK_FLOAT ; 
line 94596: } 
line 94597: # endif 
line 94598: while ( IdChar ( z [ i ] ) ) { 
line 94599: * tokenType = TK_ILLEGAL ; 
line 94600: i ++ ; 
line 94601: } 
line 94602: return i ; 
line 94603: } 
line 94604: case '[' : { 
line 94605: for ( i = 1 , c = z [ 0 ] ; c != ']' && ( c = z [ i ] ) != 0 ; i ++ ) { } 
line 94606: * tokenType = c == ']' ? TK_ID : TK_ILLEGAL ; 
line 94607: return i ; 
line 94608: } 
line 94609: case '?' : { 
line 94610: * tokenType = TK_VARIABLE ; 
line 94611: for ( i = 1 ; sqlite3Isdigit ( z [ i ] ) ; i ++ ) { } 
line 94612: return i ; 
line 94613: } 
line 94614: case '#' : { 
line 94615: for ( i = 1 ; sqlite3Isdigit ( z [ i ] ) ; i ++ ) { } 
line 94616: if ( i > 1 ) { 
line 94619: * tokenType = TK_REGISTER ; 
line 94620: return i ; 
line 94621: } 
line 94624: } 
line 94625: # ifndef SQLITE_OMIT_TCL_VARIABLE 
line 94626: case '$' : 
line 94627: # endif 
line 94628: case '@' : 
line 94629: case ':' : { 
line 94630: int n = 0 ; 
line 94631: testcase ( z [ 0 ] == '$' ) ; testcase ( z [ 0 ] == '@' ) ; testcase ( z [ 0 ] == ':' ) ; 
line 94632: * tokenType = TK_VARIABLE ; 
line 94633: for ( i = 1 ; ( c = z [ i ] ) != 0 ; i ++ ) { 
line 94634: if ( IdChar ( c ) ) { 
line 94635: n ++ ; 
line 94636: # ifndef SQLITE_OMIT_TCL_VARIABLE 
line 94637: } else if ( c == '(' && n > 0 ) { 
line 94638: do { 
line 94639: i ++ ; 
line 94640: } while ( ( c = z [ i ] ) != 0 && ! sqlite3Isspace ( c ) && c != ')' ) ; 
line 94641: if ( c == ')' ) { 
line 94642: i ++ ; 
line 94643: } else { 
line 94644: * tokenType = TK_ILLEGAL ; 
line 94645: } 
line 94646: break ; 
line 94647: } else if ( c == ':' && z [ i + 1 ] == ':' ) { 
line 94648: i ++ ; 
line 94649: # endif 
line 94650: } else { 
line 94651: break ; 
line 94652: } 
line 94653: } 
line 94654: if ( n == 0 ) * tokenType = TK_ILLEGAL ; 
line 94655: return i ; 
line 94656: } 
line 94657: # ifndef SQLITE_OMIT_BLOB_LITERAL 
line 94658: case 'x' : case 'X' : { 
line 94659: testcase ( z [ 0 ] == 'x' ) ; testcase ( z [ 0 ] == 'X' ) ; 
line 94660: if ( z [ 1 ] == '\'' ) { 
line 94661: * tokenType = TK_BLOB ; 
line 94662: for ( i = 2 ; ( c = z [ i ] ) != 0 && c != '\'' ; i ++ ) { 
line 94663: if ( ! sqlite3Isxdigit ( c ) ) { 
line 94664: * tokenType = TK_ILLEGAL ; 
line 94665: } 
line 94666: } 
line 94667: if ( i % 2 || ! c ) * tokenType = TK_ILLEGAL ; 
line 94668: if ( c ) i ++ ; 
line 94669: return i ; 
line 94670: } 
line 94672: } 
line 94673: # endif 
line 94674: default : { 
line 94675: if ( ! IdChar ( * z ) ) { 
line 94676: break ; 
line 94677: } 
line 94678: for ( i = 1 ; IdChar ( z [ i ] ) ; i ++ ) { } 
line 94679: * tokenType = keywordCode ( ( char * ) z , i ) ; 
line 94680: return i ; 
line 94681: } 
line 94682: } 
line 94683: * tokenType = TK_ILLEGAL ; 
line 94684: return 1 ; 
line 94685: } 
line 94694: SQLITE_PRIVATE int sqlite3RunParser ( Parse * pParse , const char * zSql , char * * pzErrMsg ) { 
line 94695: int nErr = 0 ; 
line 94696: int i ; 
line 94697: void * pEngine ; 
line 94698: int tokenType ; 
line 94699: int lastTokenParsed = - 1 ; 
line 94700: u8 enableLookaside ; 
line 94701: sqlite3 * db = pParse -> db ; 
line 94702: int mxSqlLen ; 
line 94705: mxSqlLen = db -> aLimit [ SQLITE_LIMIT_SQL_LENGTH ] ; 
line 94706: if ( db -> activeVdbeCnt == 0 ) { 
line 94707: db -> u1 . isInterrupted = 0 ; 
line 94708: } 
line 94709: pParse -> rc = SQLITE_OK ; 
line 94710: pParse -> zTail = zSql ; 
line 94711: i = 0 ; 
line 94712: assert ( pzErrMsg != 0 ) ; 
line 94713: pEngine = sqlite3ParserAlloc ( ( void * ( * ) ( size_t ) ) sqlite3Malloc ) ; 
line 94714: if ( pEngine == 0 ) { 
line 94715: db -> mallocFailed = 1 ; 
line 94716: return SQLITE_NOMEM ; 
line 94717: } 
line 94718: assert ( pParse -> pNewTable == 0 ) ; 
line 94719: assert ( pParse -> pNewTrigger == 0 ) ; 
line 94720: assert ( pParse -> nVar == 0 ) ; 
line 94721: assert ( pParse -> nVarExpr == 0 ) ; 
line 94722: assert ( pParse -> nVarExprAlloc == 0 ) ; 
line 94723: assert ( pParse -> apVarExpr == 0 ) ; 
line 94724: enableLookaside = db -> lookaside . bEnabled ; 
line 94725: if ( db -> lookaside . pStart ) db -> lookaside . bEnabled = 1 ; 
line 94726: while ( ! db -> mallocFailed && zSql [ i ] != 0 ) { 
line 94727: assert ( i >= 0 ) ; 
line 94728: pParse -> sLastToken . z = & zSql [ i ] ; 
line 94729: pParse -> sLastToken . n = sqlite3GetToken ( ( unsigned char * ) & zSql [ i ] , & tokenType ) ; 
line 94730: i += pParse -> sLastToken . n ; 
line 94731: if ( i > mxSqlLen ) { 
line 94732: pParse -> rc = SQLITE_TOOBIG ; 
line 94733: break ; 
line 94734: } 
line 94735: switch ( tokenType ) { 
line 94736: case TK_SPACE : { 
line 94737: if ( db -> u1 . isInterrupted ) { 
line 94738: sqlite3ErrorMsg ( pParse , "interrupt" ) ; 
line 94739: pParse -> rc = SQLITE_INTERRUPT ; 
line 94740: goto abort_parse ; 
line 94741: } 
line 94742: break ; 
line 94743: } 
line 94744: case TK_ILLEGAL : { 
line 94745: sqlite3DbFree ( db , * pzErrMsg ) ; 
line 94746: * pzErrMsg = sqlite3MPrintf ( db , "unrecognized token: \"%T\"" , 
line 94747: & pParse -> sLastToken ) ; 
line 94748: nErr ++ ; 
line 94749: goto abort_parse ; 
line 94750: } 
line 94751: case TK_SEMI : { 
line 94752: pParse -> zTail = & zSql [ i ] ; 
line 94754: } 
line 94755: default : { 
line 94756: sqlite3Parser ( pEngine , tokenType , pParse -> sLastToken , pParse ) ; 
line 94757: lastTokenParsed = tokenType ; 
line 94758: if ( pParse -> rc != SQLITE_OK ) { 
line 94759: goto abort_parse ; 
line 94760: } 
line 94761: break ; 
line 94762: } 
line 94763: } 
line 94764: } 
line 94765: abort_parse : 
line 94766: if ( zSql [ i ] == 0 && nErr == 0 && pParse -> rc == SQLITE_OK ) { 
line 94767: if ( lastTokenParsed != TK_SEMI ) { 
line 94768: sqlite3Parser ( pEngine , TK_SEMI , pParse -> sLastToken , pParse ) ; 
line 94769: pParse -> zTail = & zSql [ i ] ; 
line 94770: } 
line 94771: sqlite3Parser ( pEngine , 0 , pParse -> sLastToken , pParse ) ; 
line 94772: } 
line 94773: # ifdef YYTRACKMAXSTACKDEPTH 
line 94774: sqlite3StatusSet ( SQLITE_STATUS_PARSER_STACK , 
line 94775: sqlite3ParserStackPeak ( pEngine ) 
line 94776: ) ; 
line 94777: # endif 
line 94778: sqlite3ParserFree ( pEngine , sqlite3_free ) ; 
line 94779: db -> lookaside . bEnabled = enableLookaside ; 
line 94780: if ( db -> mallocFailed ) { 
line 94781: pParse -> rc = SQLITE_NOMEM ; 
line 94782: } 
line 94783: if ( pParse -> rc != SQLITE_OK && pParse -> rc != SQLITE_DONE && pParse -> zErrMsg == 0 ) { 
line 94784: sqlite3SetString ( & pParse -> zErrMsg , db , "%s" , sqlite3ErrStr ( pParse -> rc ) ) ; 
line 94785: } 
line 94786: assert ( pzErrMsg != 0 ) ; 
line 94787: if ( pParse -> zErrMsg ) { 
line 94788: * pzErrMsg = pParse -> zErrMsg ; 
line 94789: pParse -> zErrMsg = 0 ; 
line 94790: nErr ++ ; 
line 94791: } 
line 94792: if ( pParse -> pVdbe && pParse -> nErr > 0 && pParse -> nested == 0 ) { 
line 94793: sqlite3VdbeDelete ( pParse -> pVdbe ) ; 
line 94794: pParse -> pVdbe = 0 ; 
line 94795: } 
line 94796: # ifndef SQLITE_OMIT_SHARED_CACHE 
line 94797: if ( pParse -> nested == 0 ) { 
line 94798: sqlite3DbFree ( db , pParse -> aTableLock ) ; 
line 94799: pParse -> aTableLock = 0 ; 
line 94800: pParse -> nTableLock = 0 ; 
line 94801: } 
line 94802: # endif 
line 94803: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 94804: sqlite3DbFree ( db , pParse -> apVtabLock ) ; 
line 94805: # endif 
line 94807: if ( ! IN_DECLARE_VTAB ) { 
line 94812: sqlite3DeleteTable ( pParse -> pNewTable ) ; 
line 94813: } 
line 94815: sqlite3DeleteTrigger ( db , pParse -> pNewTrigger ) ; 
line 94816: sqlite3DbFree ( db , pParse -> apVarExpr ) ; 
line 94817: sqlite3DbFree ( db , pParse -> aAlias ) ; 
line 94818: while ( pParse -> pAinc ) { 
line 94819: AutoincInfo * p = pParse -> pAinc ; 
line 94820: pParse -> pAinc = p -> pNext ; 
line 94821: sqlite3DbFree ( db , p ) ; 
line 94822: } 
line 94823: while ( pParse -> pZombieTab ) { 
line 94824: Table * p = pParse -> pZombieTab ; 
line 94825: pParse -> pZombieTab = p -> pNextZombie ; 
line 94826: sqlite3DeleteTable ( p ) ; 
line 94827: } 
line 94828: if ( nErr > 0 && pParse -> rc == SQLITE_OK ) { 
line 94829: pParse -> rc = SQLITE_ERROR ; 
line 94830: } 
line 94831: return nErr ; 
line 94832: } 
line 94854: # ifndef SQLITE_OMIT_COMPLETE 
line 94859: # ifndef SQLITE_AMALGAMATION 
line 94860: # ifdef SQLITE_ASCII 
line 94861: # define IdChar ( C ) ( ( sqlite3CtypeMap [ ( unsigned char ) C ] & 0x46 ) != 0 ) 
line 94862: # endif 
line 94863: # ifdef SQLITE_EBCDIC 
line 94864: SQLITE_PRIVATE const char sqlite3IsEbcdicIdChar [ ] ; 
line 94865: # define IdChar ( C ) ( ( ( c = C ) >= 0x42 && sqlite3IsEbcdicIdChar [ c - 0x40 ] ) ) 
line 94866: # endif 
line 94867: # endif 
line 94874: # define tkSEMI 0 
line 94875: # define tkWS 1 
line 94876: # define tkOTHER 2 
line 94877: # ifndef SQLITE_OMIT_TRIGGER 
line 94878: # define tkEXPLAIN 3 
line 94879: # define tkCREATE 4 
line 94880: # define tkTEMP 5 
line 94881: # define tkTRIGGER 6 
line 94882: # define tkEND 7 
line 94883: # endif 
line 94938: SQLITE_API int sqlite3_complete ( const char * zSql ) { 
line 94939: u8 state = 0 ; 
line 94940: u8 token ; 
line 94942: # ifndef SQLITE_OMIT_TRIGGER 
line 94946: static const u8 trans [ 8 ] [ 8 ] = { 
line 94949: { 1 , 0 , 2 , 3 , 4 , 2 , 2 , 2 , } , 
line 94950: { 1 , 1 , 2 , 3 , 4 , 2 , 2 , 2 , } , 
line 94951: { 1 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , } , 
line 94952: { 1 , 3 , 3 , 2 , 4 , 2 , 2 , 2 , } , 
line 94953: { 1 , 4 , 2 , 2 , 2 , 4 , 5 , 2 , } , 
line 94954: { 6 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , } , 
line 94955: { 6 , 6 , 5 , 5 , 5 , 5 , 5 , 7 , } , 
line 94956: { 1 , 7 , 5 , 5 , 5 , 5 , 5 , 5 , } , 
line 94957: } ; 
line 94958: # else 
line 94962: static const u8 trans [ 3 ] [ 3 ] = { 
line 94965: { 1 , 0 , 2 , } , 
line 94966: { 1 , 1 , 2 , } , 
line 94967: { 1 , 2 , 2 , } , 
line 94968: } ; 
line 94969: # endif 
line 94971: while ( * zSql ) { 
line 94972: switch ( * zSql ) { 
line 94973: case ';' : { 
line 94974: token = tkSEMI ; 
line 94975: break ; 
line 94976: } 
line 94977: case ' ' : 
line 94978: case '\r' : 
line 94979: case '\t' : 
line 94980: case '\n' : 
line 94981: case '\f' : { 
line 94982: token = tkWS ; 
line 94983: break ; 
line 94984: } 
line 94985: case '/' : { 
line 94986: if ( zSql [ 1 ] != '*' ) { 
line 94987: token = tkOTHER ; 
line 94988: break ; 
line 94989: } 
line 94990: zSql += 2 ; 
line 94991: while ( zSql [ 0 ] && ( zSql [ 0 ] != '*' || zSql [ 1 ] != '/' ) ) { zSql ++ ; } 
line 94992: if ( zSql [ 0 ] == 0 ) return 0 ; 
line 94993: zSql ++ ; 
line 94994: token = tkWS ; 
line 94995: break ; 
line 94996: } 
line 94997: case '-' : { 
line 94998: if ( zSql [ 1 ] != '-' ) { 
line 94999: token = tkOTHER ; 
line 95000: break ; 
line 95001: } 
line 95002: while ( * zSql && * zSql != '\n' ) { zSql ++ ; } 
line 95003: if ( * zSql == 0 ) return state == 1 ; 
line 95004: token = tkWS ; 
line 95005: break ; 
line 95006: } 
line 95007: case '[' : { 
line 95008: zSql ++ ; 
line 95009: while ( * zSql && * zSql != ']' ) { zSql ++ ; } 
line 95010: if ( * zSql == 0 ) return 0 ; 
line 95011: token = tkOTHER ; 
line 95012: break ; 
line 95013: } 
line 95014: case '`' : 
line 95015: case '"' : 
line 95016: case '\'' : { 
line 95017: int c = * zSql ; 
line 95018: zSql ++ ; 
line 95019: while ( * zSql && * zSql != c ) { zSql ++ ; } 
line 95020: if ( * zSql == 0 ) return 0 ; 
line 95021: token = tkOTHER ; 
line 95022: break ; 
line 95023: } 
line 95024: default : { 
line 95025: # ifdef SQLITE_EBCDIC 
line 95026: unsigned char c ; 
line 95027: # endif 
line 95028: if ( IdChar ( ( u8 ) * zSql ) ) { 
line 95030: int nId ; 
line 95031: for ( nId = 1 ; IdChar ( zSql [ nId ] ) ; nId ++ ) { } 
line 95032: # ifdef SQLITE_OMIT_TRIGGER 
line 95033: token = tkOTHER ; 
line 95034: # else 
line 95035: switch ( * zSql ) { 
line 95036: case 'c' : case 'C' : { 
line 95037: if ( nId == 6 && sqlite3StrNICmp ( zSql , "create" , 6 ) == 0 ) { 
line 95038: token = tkCREATE ; 
line 95039: } else { 
line 95040: token = tkOTHER ; 
line 95041: } 
line 95042: break ; 
line 95043: } 
line 95044: case 't' : case 'T' : { 
line 95045: if ( nId == 7 && sqlite3StrNICmp ( zSql , "trigger" , 7 ) == 0 ) { 
line 95046: token = tkTRIGGER ; 
line 95047: } else if ( nId == 4 && sqlite3StrNICmp ( zSql , "temp" , 4 ) == 0 ) { 
line 95048: token = tkTEMP ; 
line 95049: } else if ( nId == 9 && sqlite3StrNICmp ( zSql , "temporary" , 9 ) == 0 ) { 
line 95050: token = tkTEMP ; 
line 95051: } else { 
line 95052: token = tkOTHER ; 
line 95053: } 
line 95054: break ; 
line 95055: } 
line 95056: case 'e' : case 'E' : { 
line 95057: if ( nId == 3 && sqlite3StrNICmp ( zSql , "end" , 3 ) == 0 ) { 
line 95058: token = tkEND ; 
line 95059: } else 
line 95060: # ifndef SQLITE_OMIT_EXPLAIN 
line 95061: if ( nId == 7 && sqlite3StrNICmp ( zSql , "explain" , 7 ) == 0 ) { 
line 95062: token = tkEXPLAIN ; 
line 95063: } else 
line 95064: # endif 
line 95065: { 
line 95066: token = tkOTHER ; 
line 95067: } 
line 95068: break ; 
line 95069: } 
line 95070: default : { 
line 95071: token = tkOTHER ; 
line 95072: break ; 
line 95073: } 
line 95074: } 
line 95075: # endif 
line 95076: zSql += nId - 1 ; 
line 95077: } else { 
line 95079: token = tkOTHER ; 
line 95080: } 
line 95081: break ; 
line 95082: } 
line 95083: } 
line 95084: state = trans [ state ] [ token ] ; 
line 95085: zSql ++ ; 
line 95086: } 
line 95087: return state == 1 ; 
line 95088: } 
line 95090: # ifndef SQLITE_OMIT_UTF16 
line 95096: SQLITE_API int sqlite3_complete16 ( const void * zSql ) { 
line 95097: sqlite3_value * pVal ; 
line 95098: char const * zSql8 ; 
line 95099: int rc = SQLITE_NOMEM ; 
line 95101: # ifndef SQLITE_OMIT_AUTOINIT 
line 95102: rc = sqlite3_initialize ( ) ; 
line 95103: if ( rc ) return rc ; 
line 95104: # endif 
line 95105: pVal = sqlite3ValueNew ( 0 ) ; 
line 95106: sqlite3ValueSetStr ( pVal , - 1 , zSql , SQLITE_UTF16NATIVE , SQLITE_STATIC ) ; 
line 95107: zSql8 = sqlite3ValueText ( pVal , SQLITE_UTF8 ) ; 
line 95108: if ( zSql8 ) { 
line 95109: rc = sqlite3_complete ( zSql8 ) ; 
line 95110: } else { 
line 95111: rc = SQLITE_NOMEM ; 
line 95112: } 
line 95113: sqlite3ValueFree ( pVal ) ; 
line 95114: return sqlite3ApiExit ( 0 , rc ) ; 
line 95115: } 
line 95116: # endif 
line 95117: # endif 
line 95138: # ifdef SQLITE_ENABLE_FTS3 
line 95157: # if 0 
line 95158: extern "C" { 
line 95159: # endif 
line 95161: SQLITE_PRIVATE int sqlite3Fts3Init ( sqlite3 * db ) ; 
line 95163: # if 0 
line 95164: } 
line 95165: # endif 
line 95169: # endif 
line 95170: # ifdef SQLITE_ENABLE_RTREE 
line 95189: # if 0 
line 95190: extern "C" { 
line 95191: # endif 
line 95193: SQLITE_PRIVATE int sqlite3RtreeInit ( sqlite3 * db ) ; 
line 95195: # if 0 
line 95196: } 
line 95197: # endif 
line 95201: # endif 
line 95202: # ifdef SQLITE_ENABLE_ICU 
line 95221: # if 0 
line 95222: extern "C" { 
line 95223: # endif 
line 95225: SQLITE_PRIVATE int sqlite3IcuInit ( sqlite3 * db ) ; 
line 95227: # if 0 
line 95228: } 
line 95229: # endif 
line 95234: # endif 
line 95239: # ifndef SQLITE_AMALGAMATION 
line 95240: SQLITE_API const char sqlite3_version [ ] = SQLITE_VERSION ; 
line 95241: # endif 
line 95242: SQLITE_API const char * sqlite3_libversion ( void ) { return sqlite3_version ; } 
line 95243: SQLITE_API const char * sqlite3_sourceid ( void ) { return SQLITE_SOURCE_ID ; } 
line 95244: SQLITE_API int sqlite3_libversion_number ( void ) { return SQLITE_VERSION_NUMBER ; } 
line 95245: SQLITE_API int sqlite3_threadsafe ( void ) { return SQLITE_THREADSAFE ; } 
line 95247: # if ! defined ( SQLITE_OMIT_TRACE ) && defined ( SQLITE_ENABLE_IOTRACE ) 
line 95254: SQLITE_PRIVATE void ( * sqlite3IoTrace ) ( const char * , ... ) = 0 ; 
line 95255: # endif 
line 95264: SQLITE_API char * sqlite3_temp_directory = 0 ; 
line 95297: SQLITE_API int sqlite3_initialize ( void ) { 
line 95298: sqlite3_mutex * pMaster ; 
line 95299: int rc ; 
line 95301: # ifdef SQLITE_OMIT_WSD 
line 95302: rc = sqlite3_wsd_init ( 4096 , 24 ) ; 
line 95303: if ( rc != SQLITE_OK ) { 
line 95304: return rc ; 
line 95305: } 
line 95306: # endif 
line 95313: if ( sqlite3GlobalConfig . isInit ) return SQLITE_OK ; 
line 95323: rc = sqlite3MutexInit ( ) ; 
line 95324: if ( rc ) return rc ; 
line 95332: pMaster = sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ; 
line 95333: sqlite3_mutex_enter ( pMaster ) ; 
line 95334: sqlite3GlobalConfig . isMutexInit = 1 ; 
line 95335: if ( ! sqlite3GlobalConfig . isMallocInit ) { 
line 95336: rc = sqlite3MallocInit ( ) ; 
line 95337: } 
line 95338: if ( rc == SQLITE_OK ) { 
line 95339: sqlite3GlobalConfig . isMallocInit = 1 ; 
line 95340: if ( ! sqlite3GlobalConfig . pInitMutex ) { 
line 95341: sqlite3GlobalConfig . pInitMutex = 
line 95342: sqlite3MutexAlloc ( SQLITE_MUTEX_RECURSIVE ) ; 
line 95343: if ( sqlite3GlobalConfig . bCoreMutex && ! sqlite3GlobalConfig . pInitMutex ) { 
line 95344: rc = SQLITE_NOMEM ; 
line 95345: } 
line 95346: } 
line 95347: } 
line 95348: if ( rc == SQLITE_OK ) { 
line 95349: sqlite3GlobalConfig . nRefInitMutex ++ ; 
line 95350: } 
line 95351: sqlite3_mutex_leave ( pMaster ) ; 
line 95356: if ( rc != SQLITE_OK ) { 
line 95357: return rc ; 
line 95358: } 
line 95366: sqlite3_mutex_enter ( sqlite3GlobalConfig . pInitMutex ) ; 
line 95367: if ( sqlite3GlobalConfig . isInit == 0 && sqlite3GlobalConfig . inProgress == 0 ) { 
line 95368: FuncDefHash * pHash = & GLOBAL ( FuncDefHash , sqlite3GlobalFunctions ) ; 
line 95369: sqlite3GlobalConfig . inProgress = 1 ; 
line 95370: memset ( pHash , 0 , sizeof ( sqlite3GlobalFunctions ) ) ; 
line 95371: sqlite3RegisterGlobalFunctions ( ) ; 
line 95372: if ( sqlite3GlobalConfig . isPCacheInit == 0 ) { 
line 95373: rc = sqlite3PcacheInitialize ( ) ; 
line 95374: } 
line 95375: if ( rc == SQLITE_OK ) { 
line 95376: sqlite3GlobalConfig . isPCacheInit = 1 ; 
line 95377: rc = sqlite3OsInit ( ) ; 
line 95378: } 
line 95379: if ( rc == SQLITE_OK ) { 
line 95380: sqlite3PCacheBufferSetup ( sqlite3GlobalConfig . pPage , 
line 95381: sqlite3GlobalConfig . szPage , sqlite3GlobalConfig . nPage ) ; 
line 95382: sqlite3GlobalConfig . isInit = 1 ; 
line 95383: } 
line 95384: sqlite3GlobalConfig . inProgress = 0 ; 
line 95385: } 
line 95386: sqlite3_mutex_leave ( sqlite3GlobalConfig . pInitMutex ) ; 
line 95391: sqlite3_mutex_enter ( pMaster ) ; 
line 95392: sqlite3GlobalConfig . nRefInitMutex -- ; 
line 95393: if ( sqlite3GlobalConfig . nRefInitMutex <= 0 ) { 
line 95394: assert ( sqlite3GlobalConfig . nRefInitMutex == 0 ) ; 
line 95395: sqlite3_mutex_free ( sqlite3GlobalConfig . pInitMutex ) ; 
line 95396: sqlite3GlobalConfig . pInitMutex = 0 ; 
line 95397: } 
line 95398: sqlite3_mutex_leave ( pMaster ) ; 
line 95405: # ifndef NDEBUG 
line 95406: # ifndef SQLITE_OMIT_FLOATING_POINT 
line 95408: if ( rc == SQLITE_OK ) { 
line 95409: u64 x = ( ( ( u64 ) 1 ) << 63 ) - 1 ; 
line 95410: double y ; 
line 95411: assert ( sizeof ( x ) == 8 ) ; 
line 95412: assert ( sizeof ( x ) == sizeof ( y ) ) ; 
line 95413: memcpy ( & y , & x , 8 ) ; 
line 95414: assert ( sqlite3IsNaN ( y ) ) ; 
line 95415: } 
line 95416: # endif 
line 95417: # endif 
line 95419: return rc ; 
line 95420: } 
line 95430: SQLITE_API int sqlite3_shutdown ( void ) { 
line 95431: if ( sqlite3GlobalConfig . isInit ) { 
line 95432: sqlite3_os_end ( ) ; 
line 95433: sqlite3_reset_auto_extension ( ) ; 
line 95434: sqlite3GlobalConfig . isInit = 0 ; 
line 95435: } 
line 95436: if ( sqlite3GlobalConfig . isPCacheInit ) { 
line 95437: sqlite3PcacheShutdown ( ) ; 
line 95438: sqlite3GlobalConfig . isPCacheInit = 0 ; 
line 95439: } 
line 95440: if ( sqlite3GlobalConfig . isMallocInit ) { 
line 95441: sqlite3MallocEnd ( ) ; 
line 95442: sqlite3GlobalConfig . isMallocInit = 0 ; 
line 95443: } 
line 95444: if ( sqlite3GlobalConfig . isMutexInit ) { 
line 95445: sqlite3MutexEnd ( ) ; 
line 95446: sqlite3GlobalConfig . isMutexInit = 0 ; 
line 95447: } 
line 95449: return SQLITE_OK ; 
line 95450: } 
line 95461: SQLITE_API int sqlite3_config ( int op , ... ) { 
line 95462: va_list ap ; 
line 95463: int rc = SQLITE_OK ; 
line 95467: if ( sqlite3GlobalConfig . isInit ) return SQLITE_MISUSE ; 
line 95469: va_start ( ap , op ) ; 
line 95470: switch ( op ) { 
line 95475: # if defined ( SQLITE_THREADSAFE ) && SQLITE_THREADSAFE > 0 
line 95476: case SQLITE_CONFIG_SINGLETHREAD : { 
line 95478: sqlite3GlobalConfig . bCoreMutex = 0 ; 
line 95479: sqlite3GlobalConfig . bFullMutex = 0 ; 
line 95480: break ; 
line 95481: } 
line 95482: case SQLITE_CONFIG_MULTITHREAD : { 
line 95485: sqlite3GlobalConfig . bCoreMutex = 1 ; 
line 95486: sqlite3GlobalConfig . bFullMutex = 0 ; 
line 95487: break ; 
line 95488: } 
line 95489: case SQLITE_CONFIG_SERIALIZED : { 
line 95491: sqlite3GlobalConfig . bCoreMutex = 1 ; 
line 95492: sqlite3GlobalConfig . bFullMutex = 1 ; 
line 95493: break ; 
line 95494: } 
line 95495: case SQLITE_CONFIG_MUTEX : { 
line 95497: sqlite3GlobalConfig . mutex = * va_arg ( ap , sqlite3_mutex_methods * ) ; 
line 95498: break ; 
line 95499: } 
line 95500: case SQLITE_CONFIG_GETMUTEX : { 
line 95502: * va_arg ( ap , sqlite3_mutex_methods * ) = sqlite3GlobalConfig . mutex ; 
line 95503: break ; 
line 95504: } 
line 95505: # endif 
line 95508: case SQLITE_CONFIG_MALLOC : { 
line 95510: sqlite3GlobalConfig . m = * va_arg ( ap , sqlite3_mem_methods * ) ; 
line 95511: break ; 
line 95512: } 
line 95513: case SQLITE_CONFIG_GETMALLOC : { 
line 95515: if ( sqlite3GlobalConfig . m . xMalloc == 0 ) sqlite3MemSetDefault ( ) ; 
line 95516: * va_arg ( ap , sqlite3_mem_methods * ) = sqlite3GlobalConfig . m ; 
line 95517: break ; 
line 95518: } 
line 95519: case SQLITE_CONFIG_MEMSTATUS : { 
line 95521: sqlite3GlobalConfig . bMemstat = va_arg ( ap , int ) ; 
line 95522: break ; 
line 95523: } 
line 95524: case SQLITE_CONFIG_SCRATCH : { 
line 95526: sqlite3GlobalConfig . pScratch = va_arg ( ap , void * ) ; 
line 95527: sqlite3GlobalConfig . szScratch = va_arg ( ap , int ) ; 
line 95528: sqlite3GlobalConfig . nScratch = va_arg ( ap , int ) ; 
line 95529: break ; 
line 95530: } 
line 95531: case SQLITE_CONFIG_PAGECACHE : { 
line 95533: sqlite3GlobalConfig . pPage = va_arg ( ap , void * ) ; 
line 95534: sqlite3GlobalConfig . szPage = va_arg ( ap , int ) ; 
line 95535: sqlite3GlobalConfig . nPage = va_arg ( ap , int ) ; 
line 95536: break ; 
line 95537: } 
line 95539: case SQLITE_CONFIG_PCACHE : { 
line 95541: sqlite3GlobalConfig . pcache = * va_arg ( ap , sqlite3_pcache_methods * ) ; 
line 95542: break ; 
line 95543: } 
line 95545: case SQLITE_CONFIG_GETPCACHE : { 
line 95546: if ( sqlite3GlobalConfig . pcache . xInit == 0 ) { 
line 95547: sqlite3PCacheSetDefault ( ) ; 
line 95548: } 
line 95549: * va_arg ( ap , sqlite3_pcache_methods * ) = sqlite3GlobalConfig . pcache ; 
line 95550: break ; 
line 95551: } 
line 95553: # if defined ( SQLITE_ENABLE_MEMSYS3 ) || defined ( SQLITE_ENABLE_MEMSYS5 ) 
line 95554: case SQLITE_CONFIG_HEAP : { 
line 95556: sqlite3GlobalConfig . pHeap = va_arg ( ap , void * ) ; 
line 95557: sqlite3GlobalConfig . nHeap = va_arg ( ap , int ) ; 
line 95558: sqlite3GlobalConfig . mnReq = va_arg ( ap , int ) ; 
line 95560: if ( sqlite3GlobalConfig . pHeap == 0 ) { 
line 95566: memset ( & sqlite3GlobalConfig . m , 0 , sizeof ( sqlite3GlobalConfig . m ) ) ; 
line 95567: } else { 
line 95572: # ifdef SQLITE_ENABLE_MEMSYS3 
line 95573: sqlite3GlobalConfig . m = * sqlite3MemGetMemsys3 ( ) ; 
line 95574: # endif 
line 95575: # ifdef SQLITE_ENABLE_MEMSYS5 
line 95576: sqlite3GlobalConfig . m = * sqlite3MemGetMemsys5 ( ) ; 
line 95577: # endif 
line 95578: } 
line 95579: break ; 
line 95580: } 
line 95581: # endif 
line 95583: case SQLITE_CONFIG_LOOKASIDE : { 
line 95584: sqlite3GlobalConfig . szLookaside = va_arg ( ap , int ) ; 
line 95585: sqlite3GlobalConfig . nLookaside = va_arg ( ap , int ) ; 
line 95586: break ; 
line 95587: } 
line 95589: default : { 
line 95590: rc = SQLITE_ERROR ; 
line 95591: break ; 
line 95592: } 
line 95593: } 
line 95594: va_end ( ap ) ; 
line 95595: return rc ; 
line 95596: } 
line 95609: static int setupLookaside ( sqlite3 * db , void * pBuf , int sz , int cnt ) { 
line 95610: void * pStart ; 
line 95611: if ( db -> lookaside . nOut ) { 
line 95612: return SQLITE_BUSY ; 
line 95613: } 
line 95618: if ( db -> lookaside . bMalloced ) { 
line 95619: sqlite3_free ( db -> lookaside . pStart ) ; 
line 95620: } 
line 95624: if ( sz <= ( int ) sizeof ( LookasideSlot * ) ) sz = 0 ; 
line 95625: if ( cnt < 0 ) cnt = 0 ; 
line 95626: if ( sz == 0 || cnt == 0 ) { 
line 95627: sz = 0 ; 
line 95628: pStart = 0 ; 
line 95629: } else if ( pBuf == 0 ) { 
line 95630: sz = ROUND8 ( sz ) ; 
line 95631: sqlite3BeginBenignMalloc ( ) ; 
line 95632: pStart = sqlite3Malloc ( sz * cnt ) ; 
line 95633: sqlite3EndBenignMalloc ( ) ; 
line 95634: } else { 
line 95635: sz = ROUNDDOWN8 ( sz ) ; 
line 95636: pStart = pBuf ; 
line 95637: } 
line 95638: db -> lookaside . pStart = pStart ; 
line 95639: db -> lookaside . pFree = 0 ; 
line 95640: db -> lookaside . sz = ( u16 ) sz ; 
line 95641: if ( pStart ) { 
line 95642: int i ; 
line 95643: LookasideSlot * p ; 
line 95644: assert ( sz > ( int ) sizeof ( LookasideSlot * ) ) ; 
line 95645: p = ( LookasideSlot * ) pStart ; 
line 95646: for ( i = cnt - 1 ; i >= 0 ; i -- ) { 
line 95647: p -> pNext = db -> lookaside . pFree ; 
line 95648: db -> lookaside . pFree = p ; 
line 95649: p = ( LookasideSlot * ) & ( ( u8 * ) p ) [ sz ] ; 
line 95650: } 
line 95651: db -> lookaside . pEnd = p ; 
line 95652: db -> lookaside . bEnabled = 1 ; 
line 95653: db -> lookaside . bMalloced = pBuf == 0 ? 1 : 0 ; 
line 95654: } else { 
line 95655: db -> lookaside . pEnd = 0 ; 
line 95656: db -> lookaside . bEnabled = 0 ; 
line 95657: db -> lookaside . bMalloced = 0 ; 
line 95658: } 
line 95659: return SQLITE_OK ; 
line 95660: } 
line 95665: SQLITE_API sqlite3_mutex * sqlite3_db_mutex ( sqlite3 * db ) { 
line 95666: return db -> mutex ; 
line 95667: } 
line 95672: SQLITE_API int sqlite3_db_config ( sqlite3 * db , int op , ... ) { 
line 95673: va_list ap ; 
line 95674: int rc ; 
line 95675: va_start ( ap , op ) ; 
line 95676: switch ( op ) { 
line 95677: case SQLITE_DBCONFIG_LOOKASIDE : { 
line 95678: void * pBuf = va_arg ( ap , void * ) ; 
line 95679: int sz = va_arg ( ap , int ) ; 
line 95680: int cnt = va_arg ( ap , int ) ; 
line 95681: rc = setupLookaside ( db , pBuf , sz , cnt ) ; 
line 95682: break ; 
line 95683: } 
line 95684: default : { 
line 95685: rc = SQLITE_ERROR ; 
line 95686: break ; 
line 95687: } 
line 95688: } 
line 95689: va_end ( ap ) ; 
line 95690: return rc ; 
line 95691: } 
line 95697: static int allSpaces ( const char * z , int n ) { 
line 95698: while ( n > 0 && z [ n - 1 ] == ' ' ) { n -- ; } 
line 95699: return n == 0 ; 
line 95700: } 
line 95709: static int binCollFunc ( 
line 95710: void * padFlag , 
line 95711: int nKey1 , const void * pKey1 , 
line 95712: int nKey2 , const void * pKey2 
line 95713: ) { 
line 95714: int rc , n ; 
line 95715: n = nKey1 < nKey2 ? nKey1 : nKey2 ; 
line 95716: rc = memcmp ( pKey1 , pKey2 , n ) ; 
line 95717: if ( rc == 0 ) { 
line 95718: if ( padFlag 
line 95719: && allSpaces ( ( ( char * ) pKey1 ) + n , nKey1 - n ) 
line 95720: && allSpaces ( ( ( char * ) pKey2 ) + n , nKey2 - n ) 
line 95721: ) { 
line 95723: } else { 
line 95724: rc = nKey1 - nKey2 ; 
line 95725: } 
line 95726: } 
line 95727: return rc ; 
line 95728: } 
line 95739: static int nocaseCollatingFunc ( 
line 95740: void * NotUsed , 
line 95741: int nKey1 , const void * pKey1 , 
line 95742: int nKey2 , const void * pKey2 
line 95743: ) { 
line 95744: int r = sqlite3StrNICmp ( 
line 95745: ( const char * ) pKey1 , ( const char * ) pKey2 , ( nKey1 < nKey2 ) ? nKey1 : nKey2 ) ; 
line 95746: UNUSED_PARAMETER ( NotUsed ) ; 
line 95747: if ( 0 == r ) { 
line 95748: r = nKey1 - nKey2 ; 
line 95749: } 
line 95750: return r ; 
line 95751: } 
line 95756: SQLITE_API sqlite_int64 sqlite3_last_insert_rowid ( sqlite3 * db ) { 
line 95757: return db -> lastRowid ; 
line 95758: } 
line 95763: SQLITE_API int sqlite3_changes ( sqlite3 * db ) { 
line 95764: return db -> nChange ; 
line 95765: } 
line 95770: SQLITE_API int sqlite3_total_changes ( sqlite3 * db ) { 
line 95771: return db -> nTotalChange ; 
line 95772: } 
line 95779: SQLITE_PRIVATE void sqlite3CloseSavepoints ( sqlite3 * db ) { 
line 95780: while ( db -> pSavepoint ) { 
line 95781: Savepoint * pTmp = db -> pSavepoint ; 
line 95782: db -> pSavepoint = pTmp -> pNext ; 
line 95783: sqlite3DbFree ( db , pTmp ) ; 
line 95784: } 
line 95785: db -> nSavepoint = 0 ; 
line 95786: db -> nStatement = 0 ; 
line 95787: db -> isTransactionSavepoint = 0 ; 
line 95788: } 
line 95793: SQLITE_API int sqlite3_close ( sqlite3 * db ) { 
line 95794: HashElem * i ; 
line 95795: int j ; 
line 95797: if ( ! db ) { 
line 95798: return SQLITE_OK ; 
line 95799: } 
line 95800: if ( ! sqlite3SafetyCheckSickOrOk ( db ) ) { 
line 95801: return SQLITE_MISUSE ; 
line 95802: } 
line 95803: sqlite3_mutex_enter ( db -> mutex ) ; 
line 95805: sqlite3ResetInternalSchema ( db , 0 ) ; 
line 95814: sqlite3VtabRollback ( db ) ; 
line 95817: if ( db -> pVdbe ) { 
line 95818: sqlite3Error ( db , SQLITE_BUSY , 
line 95819: "unable to close due to unfinalised statements" ) ; 
line 95820: sqlite3_mutex_leave ( db -> mutex ) ; 
line 95821: return SQLITE_BUSY ; 
line 95822: } 
line 95823: assert ( sqlite3SafetyCheckSickOrOk ( db ) ) ; 
line 95825: for ( j = 0 ; j < db -> nDb ; j ++ ) { 
line 95826: Btree * pBt = db -> aDb [ j ] . pBt ; 
line 95827: if ( pBt && sqlite3BtreeIsInBackup ( pBt ) ) { 
line 95828: sqlite3Error ( db , SQLITE_BUSY , 
line 95829: "unable to close due to unfinished backup operation" ) ; 
line 95830: sqlite3_mutex_leave ( db -> mutex ) ; 
line 95831: return SQLITE_BUSY ; 
line 95832: } 
line 95833: } 
line 95836: sqlite3CloseSavepoints ( db ) ; 
line 95838: for ( j = 0 ; j < db -> nDb ; j ++ ) { 
line 95839: struct Db * pDb = & db -> aDb [ j ] ; 
line 95840: if ( pDb -> pBt ) { 
line 95841: sqlite3BtreeClose ( pDb -> pBt ) ; 
line 95842: pDb -> pBt = 0 ; 
line 95843: if ( j != 1 ) { 
line 95844: pDb -> pSchema = 0 ; 
line 95845: } 
line 95846: } 
line 95847: } 
line 95848: sqlite3ResetInternalSchema ( db , 0 ) ; 
line 95853: sqlite3ConnectionClosed ( db ) ; 
line 95855: assert ( db -> nDb <= 2 ) ; 
line 95856: assert ( db -> aDb == db -> aDbStatic ) ; 
line 95857: for ( j = 0 ; j < ArraySize ( db -> aFunc . a ) ; j ++ ) { 
line 95858: FuncDef * pNext , * pHash , * p ; 
line 95859: for ( p = db -> aFunc . a [ j ] ; p ; p = pHash ) { 
line 95860: pHash = p -> pHash ; 
line 95861: while ( p ) { 
line 95862: pNext = p -> pNext ; 
line 95863: sqlite3DbFree ( db , p ) ; 
line 95864: p = pNext ; 
line 95865: } 
line 95866: } 
line 95867: } 
line 95868: for ( i = sqliteHashFirst ( & db -> aCollSeq ) ; i ; i = sqliteHashNext ( i ) ) { 
line 95869: CollSeq * pColl = ( CollSeq * ) sqliteHashData ( i ) ; 
line 95871: for ( j = 0 ; j < 3 ; j ++ ) { 
line 95872: if ( pColl [ j ] . xDel ) { 
line 95873: pColl [ j ] . xDel ( pColl [ j ] . pUser ) ; 
line 95874: } 
line 95875: } 
line 95876: sqlite3DbFree ( db , pColl ) ; 
line 95877: } 
line 95878: sqlite3HashClear ( & db -> aCollSeq ) ; 
line 95879: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 95880: for ( i = sqliteHashFirst ( & db -> aModule ) ; i ; i = sqliteHashNext ( i ) ) { 
line 95881: Module * pMod = ( Module * ) sqliteHashData ( i ) ; 
line 95882: if ( pMod -> xDestroy ) { 
line 95883: pMod -> xDestroy ( pMod -> pAux ) ; 
line 95884: } 
line 95885: sqlite3DbFree ( db , pMod ) ; 
line 95886: } 
line 95887: sqlite3HashClear ( & db -> aModule ) ; 
line 95888: # endif 
line 95890: sqlite3Error ( db , SQLITE_OK , 0 ) ; 
line 95891: if ( db -> pErr ) { 
line 95892: sqlite3ValueFree ( db -> pErr ) ; 
line 95893: } 
line 95894: sqlite3CloseExtensions ( db ) ; 
line 95896: db -> magic = SQLITE_MAGIC_ERROR ; 
line 95904: sqlite3DbFree ( db , db -> aDb [ 1 ] . pSchema ) ; 
line 95905: sqlite3_mutex_leave ( db -> mutex ) ; 
line 95906: db -> magic = SQLITE_MAGIC_CLOSED ; 
line 95907: sqlite3_mutex_free ( db -> mutex ) ; 
line 95908: assert ( db -> lookaside . nOut == 0 ) ; 
line 95909: if ( db -> lookaside . bMalloced ) { 
line 95910: sqlite3_free ( db -> lookaside . pStart ) ; 
line 95911: } 
line 95912: sqlite3_free ( db ) ; 
line 95913: return SQLITE_OK ; 
line 95914: } 
line 95919: SQLITE_PRIVATE void sqlite3RollbackAll ( sqlite3 * db ) { 
line 95920: int i ; 
line 95921: int inTrans = 0 ; 
line 95922: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 95923: sqlite3BeginBenignMalloc ( ) ; 
line 95924: for ( i = 0 ; i < db -> nDb ; i ++ ) { 
line 95925: if ( db -> aDb [ i ] . pBt ) { 
line 95926: if ( sqlite3BtreeIsInTrans ( db -> aDb [ i ] . pBt ) ) { 
line 95927: inTrans = 1 ; 
line 95928: } 
line 95929: sqlite3BtreeRollback ( db -> aDb [ i ] . pBt ) ; 
line 95930: db -> aDb [ i ] . inTrans = 0 ; 
line 95931: } 
line 95932: } 
line 95933: sqlite3VtabRollback ( db ) ; 
line 95934: sqlite3EndBenignMalloc ( ) ; 
line 95936: if ( db -> flags & SQLITE_InternChanges ) { 
line 95937: sqlite3ExpirePreparedStatements ( db ) ; 
line 95938: sqlite3ResetInternalSchema ( db , 0 ) ; 
line 95939: } 
line 95942: db -> nDeferredCons = 0 ; 
line 95945: if ( db -> xRollbackCallback && ( inTrans || ! db -> autoCommit ) ) { 
line 95946: db -> xRollbackCallback ( db -> pRollbackArg ) ; 
line 95947: } 
line 95948: } 
line 95954: SQLITE_PRIVATE const char * sqlite3ErrStr ( int rc ) { 
line 95955: static const char * const aMsg [ ] = { 
line 95956: "not an error" , 
line 95957: "SQL logic error or missing database" , 
line 95958: 0 , 
line 95959: "access permission denied" , 
line 95960: "callback requested query abort" , 
line 95961: "database is locked" , 
line 95962: "database table is locked" , 
line 95963: "out of memory" , 
line 95964: "attempt to write a readonly database" , 
line 95965: "interrupted" , 
line 95966: "disk I/O error" , 
line 95967: "database disk image is malformed" , 
line 95968: 0 , 
line 95969: "database or disk is full" , 
line 95970: "unable to open database file" , 
line 95971: 0 , 
line 95972: "table contains no data" , 
line 95973: "database schema has changed" , 
line 95974: "string or blob too big" , 
line 95975: "constraint failed" , 
line 95976: "datatype mismatch" , 
line 95977: "library routine called out of sequence" , 
line 95978: "large file support is disabled" , 
line 95979: "authorization denied" , 
line 95980: "auxiliary database format error" , 
line 95981: "bind or column index out of range" , 
line 95982: "file is encrypted or is not a database" , 
line 95983: } ; 
line 95984: rc &= 0xff ; 
line 95985: if ( ALWAYS ( rc >= 0 ) && rc < ( int ) ( sizeof ( aMsg ) / sizeof ( aMsg [ 0 ] ) ) && aMsg [ rc ] != 0 ) { 
line 95986: return aMsg [ rc ] ; 
line 95987: } else { 
line 95988: return "unknown error" ; 
line 95989: } 
line 95990: } 
line 95998: static int sqliteDefaultBusyCallback ( 
line 95999: void * ptr , 
line 96000: int count 
line 96001: ) { 
line 96002: # if SQLITE_OS_WIN || ( defined ( HAVE_USLEEP ) && HAVE_USLEEP ) 
line 96003: static const u8 delays [ ] = 
line 96004: { 1 , 2 , 5 , 10 , 15 , 20 , 25 , 25 , 25 , 50 , 50 , 100 } ; 
line 96005: static const u8 totals [ ] = 
line 96006: { 0 , 1 , 3 , 8 , 18 , 33 , 53 , 78 , 103 , 128 , 178 , 228 } ; 
line 96007: # define NDELAY ( sizeof ( delays ) / sizeof ( delays [ 0 ] ) ) 
line 96008: sqlite3 * db = ( sqlite3 * ) ptr ; 
line 96009: int timeout = db -> busyTimeout ; 
line 96010: int delay , prior ; 
line 96012: assert ( count >= 0 ) ; 
line 96013: if ( count < NDELAY ) { 
line 96014: delay = delays [ count ] ; 
line 96015: prior = totals [ count ] ; 
line 96016: } else { 
line 96017: delay = delays [ NDELAY - 1 ] ; 
line 96018: prior = totals [ NDELAY - 1 ] + delay * ( count - ( NDELAY - 1 ) ) ; 
line 96019: } 
line 96020: if ( prior + delay > timeout ) { 
line 96021: delay = timeout - prior ; 
line 96022: if ( delay <= 0 ) return 0 ; 
line 96023: } 
line 96024: sqlite3OsSleep ( db -> pVfs , delay * 1000 ) ; 
line 96025: return 1 ; 
line 96026: # else 
line 96027: sqlite3 * db = ( sqlite3 * ) ptr ; 
line 96028: int timeout = ( ( sqlite3 * ) ptr ) -> busyTimeout ; 
line 96029: if ( ( count + 1 ) * 1000 > timeout ) { 
line 96030: return 0 ; 
line 96031: } 
line 96032: sqlite3OsSleep ( db -> pVfs , 1000000 ) ; 
line 96033: return 1 ; 
line 96034: # endif 
line 96035: } 
line 96044: SQLITE_PRIVATE int sqlite3InvokeBusyHandler ( BusyHandler * p ) { 
line 96045: int rc ; 
line 96046: if ( NEVER ( p == 0 ) || p -> xFunc == 0 || p -> nBusy < 0 ) return 0 ; 
line 96047: rc = p -> xFunc ( p -> pArg , p -> nBusy ) ; 
line 96048: if ( rc == 0 ) { 
line 96049: p -> nBusy = - 1 ; 
line 96050: } else { 
line 96051: p -> nBusy ++ ; 
line 96052: } 
line 96053: return rc ; 
line 96054: } 
line 96060: SQLITE_API int sqlite3_busy_handler ( 
line 96061: sqlite3 * db , 
line 96062: int ( * xBusy ) ( void * , int ) , 
line 96063: void * pArg 
line 96064: ) { 
line 96065: sqlite3_mutex_enter ( db -> mutex ) ; 
line 96066: db -> busyHandler . xFunc = xBusy ; 
line 96067: db -> busyHandler . pArg = pArg ; 
line 96068: db -> busyHandler . nBusy = 0 ; 
line 96069: sqlite3_mutex_leave ( db -> mutex ) ; 
line 96070: return SQLITE_OK ; 
line 96071: } 
line 96073: # ifndef SQLITE_OMIT_PROGRESS_CALLBACK 
line 96079: SQLITE_API void sqlite3_progress_handler ( 
line 96080: sqlite3 * db , 
line 96081: int nOps , 
line 96082: int ( * xProgress ) ( void * ) , 
line 96083: void * pArg 
line 96084: ) { 
line 96085: sqlite3_mutex_enter ( db -> mutex ) ; 
line 96086: if ( nOps > 0 ) { 
line 96087: db -> xProgress = xProgress ; 
line 96088: db -> nProgressOps = nOps ; 
line 96089: db -> pProgressArg = pArg ; 
line 96090: } else { 
line 96091: db -> xProgress = 0 ; 
line 96092: db -> nProgressOps = 0 ; 
line 96093: db -> pProgressArg = 0 ; 
line 96094: } 
line 96095: sqlite3_mutex_leave ( db -> mutex ) ; 
line 96096: } 
line 96097: # endif 
line 96104: SQLITE_API int sqlite3_busy_timeout ( sqlite3 * db , int ms ) { 
line 96105: if ( ms > 0 ) { 
line 96106: db -> busyTimeout = ms ; 
line 96107: sqlite3_busy_handler ( db , sqliteDefaultBusyCallback , ( void * ) db ) ; 
line 96108: } else { 
line 96109: sqlite3_busy_handler ( db , 0 , 0 ) ; 
line 96110: } 
line 96111: return SQLITE_OK ; 
line 96112: } 
line 96117: SQLITE_API void sqlite3_interrupt ( sqlite3 * db ) { 
line 96118: db -> u1 . isInterrupted = 1 ; 
line 96119: } 
line 96128: SQLITE_PRIVATE int sqlite3CreateFunc ( 
line 96129: sqlite3 * db , 
line 96130: const char * zFunctionName , 
line 96131: int nArg , 
line 96132: int enc , 
line 96133: void * pUserData , 
line 96134: void ( * xFunc ) ( sqlite3_context * , int , sqlite3_value * * ) , 
line 96135: void ( * xStep ) ( sqlite3_context * , int , sqlite3_value * * ) , 
line 96136: void ( * xFinal ) ( sqlite3_context * ) 
line 96137: ) { 
line 96138: FuncDef * p ; 
line 96139: int nName ; 
line 96141: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 96142: if ( zFunctionName == 0 || 
line 96143: ( xFunc && ( xFinal || xStep ) ) || 
line 96144: ( ! xFunc && ( xFinal && ! xStep ) ) || 
line 96145: ( ! xFunc && ( ! xFinal && xStep ) ) || 
line 96146: ( nArg < - 1 || nArg > SQLITE_MAX_FUNCTION_ARG ) || 
line 96147: ( 255 < ( nName = sqlite3Strlen30 ( zFunctionName ) ) ) ) { 
line 96148: return SQLITE_MISUSE ; 
line 96149: } 
line 96151: # ifndef SQLITE_OMIT_UTF16 
line 96159: if ( enc == SQLITE_UTF16 ) { 
line 96160: enc = SQLITE_UTF16NATIVE ; 
line 96161: } else if ( enc == SQLITE_ANY ) { 
line 96162: int rc ; 
line 96163: rc = sqlite3CreateFunc ( db , zFunctionName , nArg , SQLITE_UTF8 , 
line 96164: pUserData , xFunc , xStep , xFinal ) ; 
line 96165: if ( rc == SQLITE_OK ) { 
line 96166: rc = sqlite3CreateFunc ( db , zFunctionName , nArg , SQLITE_UTF16LE , 
line 96167: pUserData , xFunc , xStep , xFinal ) ; 
line 96168: } 
line 96169: if ( rc != SQLITE_OK ) { 
line 96170: return rc ; 
line 96171: } 
line 96172: enc = SQLITE_UTF16BE ; 
line 96173: } 
line 96174: # else 
line 96175: enc = SQLITE_UTF8 ; 
line 96176: # endif 
line 96183: p = sqlite3FindFunction ( db , zFunctionName , nName , nArg , ( u8 ) enc , 0 ) ; 
line 96184: if ( p && p -> iPrefEnc == enc && p -> nArg == nArg ) { 
line 96185: if ( db -> activeVdbeCnt ) { 
line 96186: sqlite3Error ( db , SQLITE_BUSY , 
line 96187: "unable to delete/modify user-function due to active statements" ) ; 
line 96188: assert ( ! db -> mallocFailed ) ; 
line 96189: return SQLITE_BUSY ; 
line 96190: } else { 
line 96191: sqlite3ExpirePreparedStatements ( db ) ; 
line 96192: } 
line 96193: } 
line 96195: p = sqlite3FindFunction ( db , zFunctionName , nName , nArg , ( u8 ) enc , 1 ) ; 
line 96196: assert ( p || db -> mallocFailed ) ; 
line 96197: if ( ! p ) { 
line 96198: return SQLITE_NOMEM ; 
line 96199: } 
line 96200: p -> flags = 0 ; 
line 96201: p -> xFunc = xFunc ; 
line 96202: p -> xStep = xStep ; 
line 96203: p -> xFinalize = xFinal ; 
line 96204: p -> pUserData = pUserData ; 
line 96205: p -> nArg = ( u16 ) nArg ; 
line 96206: return SQLITE_OK ; 
line 96207: } 
line 96212: SQLITE_API int sqlite3_create_function ( 
line 96213: sqlite3 * db , 
line 96214: const char * zFunctionName , 
line 96215: int nArg , 
line 96216: int enc , 
line 96217: void * p , 
line 96218: void ( * xFunc ) ( sqlite3_context * , int , sqlite3_value * * ) , 
line 96219: void ( * xStep ) ( sqlite3_context * , int , sqlite3_value * * ) , 
line 96220: void ( * xFinal ) ( sqlite3_context * ) 
line 96221: ) { 
line 96222: int rc ; 
line 96223: sqlite3_mutex_enter ( db -> mutex ) ; 
line 96224: rc = sqlite3CreateFunc ( db , zFunctionName , nArg , enc , p , xFunc , xStep , xFinal ) ; 
line 96225: rc = sqlite3ApiExit ( db , rc ) ; 
line 96226: sqlite3_mutex_leave ( db -> mutex ) ; 
line 96227: return rc ; 
line 96228: } 
line 96230: # ifndef SQLITE_OMIT_UTF16 
line 96231: SQLITE_API int sqlite3_create_function16 ( 
line 96232: sqlite3 * db , 
line 96233: const void * zFunctionName , 
line 96234: int nArg , 
line 96235: int eTextRep , 
line 96236: void * p , 
line 96237: void ( * xFunc ) ( sqlite3_context * , int , sqlite3_value * * ) , 
line 96238: void ( * xStep ) ( sqlite3_context * , int , sqlite3_value * * ) , 
line 96239: void ( * xFinal ) ( sqlite3_context * ) 
line 96240: ) { 
line 96241: int rc ; 
line 96242: char * zFunc8 ; 
line 96243: sqlite3_mutex_enter ( db -> mutex ) ; 
line 96244: assert ( ! db -> mallocFailed ) ; 
line 96245: zFunc8 = sqlite3Utf16to8 ( db , zFunctionName , - 1 ) ; 
line 96246: rc = sqlite3CreateFunc ( db , zFunc8 , nArg , eTextRep , p , xFunc , xStep , xFinal ) ; 
line 96247: sqlite3DbFree ( db , zFunc8 ) ; 
line 96248: rc = sqlite3ApiExit ( db , rc ) ; 
line 96249: sqlite3_mutex_leave ( db -> mutex ) ; 
line 96250: return rc ; 
line 96251: } 
line 96252: # endif 
line 96267: SQLITE_API int sqlite3_overload_function ( 
line 96268: sqlite3 * db , 
line 96269: const char * zName , 
line 96270: int nArg 
line 96271: ) { 
line 96272: int nName = sqlite3Strlen30 ( zName ) ; 
line 96273: int rc ; 
line 96274: sqlite3_mutex_enter ( db -> mutex ) ; 
line 96275: if ( sqlite3FindFunction ( db , zName , nName , nArg , SQLITE_UTF8 , 0 ) == 0 ) { 
line 96276: sqlite3CreateFunc ( db , zName , nArg , SQLITE_UTF8 , 
line 96277: 0 , sqlite3InvalidFunction , 0 , 0 ) ; 
line 96278: } 
line 96279: rc = sqlite3ApiExit ( db , SQLITE_OK ) ; 
line 96280: sqlite3_mutex_leave ( db -> mutex ) ; 
line 96281: return rc ; 
line 96282: } 
line 96284: # ifndef SQLITE_OMIT_TRACE 
line 96293: SQLITE_API void * sqlite3_trace ( sqlite3 * db , void ( * xTrace ) ( void * , const char * ) , void * pArg ) { 
line 96294: void * pOld ; 
line 96295: sqlite3_mutex_enter ( db -> mutex ) ; 
line 96296: pOld = db -> pTraceArg ; 
line 96297: db -> xTrace = xTrace ; 
line 96298: db -> pTraceArg = pArg ; 
line 96299: sqlite3_mutex_leave ( db -> mutex ) ; 
line 96300: return pOld ; 
line 96301: } 
line 96310: SQLITE_API void * sqlite3_profile ( 
line 96311: sqlite3 * db , 
line 96312: void ( * xProfile ) ( void * , const char * , sqlite_uint64 ) , 
line 96313: void * pArg 
line 96314: ) { 
line 96315: void * pOld ; 
line 96316: sqlite3_mutex_enter ( db -> mutex ) ; 
line 96317: pOld = db -> pProfileArg ; 
line 96318: db -> xProfile = xProfile ; 
line 96319: db -> pProfileArg = pArg ; 
line 96320: sqlite3_mutex_leave ( db -> mutex ) ; 
line 96321: return pOld ; 
line 96322: } 
line 96323: # endif 
line 96331: SQLITE_API void * sqlite3_commit_hook ( 
line 96332: sqlite3 * db , 
line 96333: int ( * xCallback ) ( void * ) , 
line 96334: void * pArg 
line 96335: ) { 
line 96336: void * pOld ; 
line 96337: sqlite3_mutex_enter ( db -> mutex ) ; 
line 96338: pOld = db -> pCommitArg ; 
line 96339: db -> xCommitCallback = xCallback ; 
line 96340: db -> pCommitArg = pArg ; 
line 96341: sqlite3_mutex_leave ( db -> mutex ) ; 
line 96342: return pOld ; 
line 96343: } 
line 96349: SQLITE_API void * sqlite3_update_hook ( 
line 96350: sqlite3 * db , 
line 96351: void ( * xCallback ) ( void * , int , char const * , char const * , sqlite_int64 ) , 
line 96352: void * pArg 
line 96353: ) { 
line 96354: void * pRet ; 
line 96355: sqlite3_mutex_enter ( db -> mutex ) ; 
line 96356: pRet = db -> pUpdateArg ; 
line 96357: db -> xUpdateCallback = xCallback ; 
line 96358: db -> pUpdateArg = pArg ; 
line 96359: sqlite3_mutex_leave ( db -> mutex ) ; 
line 96360: return pRet ; 
line 96361: } 
line 96367: SQLITE_API void * sqlite3_rollback_hook ( 
line 96368: sqlite3 * db , 
line 96369: void ( * xCallback ) ( void * ) , 
line 96370: void * pArg 
line 96371: ) { 
line 96372: void * pRet ; 
line 96373: sqlite3_mutex_enter ( db -> mutex ) ; 
line 96374: pRet = db -> pRollbackArg ; 
line 96375: db -> xRollbackCallback = xCallback ; 
line 96376: db -> pRollbackArg = pArg ; 
line 96377: sqlite3_mutex_leave ( db -> mutex ) ; 
line 96378: return pRet ; 
line 96379: } 
line 96400: SQLITE_PRIVATE int sqlite3TempInMemory ( const sqlite3 * db ) { 
line 96401: # if SQLITE_TEMP_STORE == 1 
line 96402: return ( db -> temp_store == 2 ) ; 
line 96403: # endif 
line 96404: # if SQLITE_TEMP_STORE == 2 
line 96405: return ( db -> temp_store != 1 ) ; 
line 96406: # endif 
line 96407: # if SQLITE_TEMP_STORE == 3 
line 96408: return 1 ; 
line 96409: # endif 
line 96410: # if SQLITE_TEMP_STORE < 1 || SQLITE_TEMP_STORE > 3 
line 96411: return 0 ; 
line 96412: # endif 
line 96413: } 
line 96428: SQLITE_PRIVATE int sqlite3BtreeFactory ( 
line 96429: sqlite3 * db , 
line 96430: const char * zFilename , 
line 96431: int omitJournal , 
line 96432: int nCache , 
line 96433: int vfsFlags , 
line 96434: Btree * * ppBtree 
line 96435: ) { 
line 96436: int btFlags = 0 ; 
line 96437: int rc ; 
line 96439: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 96440: assert ( ppBtree != 0 ) ; 
line 96441: if ( omitJournal ) { 
line 96442: btFlags |= BTREE_OMIT_JOURNAL ; 
line 96443: } 
line 96444: if ( db -> flags & SQLITE_NoReadlock ) { 
line 96445: btFlags |= BTREE_NO_READLOCK ; 
line 96446: } 
line 96447: # ifndef SQLITE_OMIT_MEMORYDB 
line 96448: if ( zFilename == 0 && sqlite3TempInMemory ( db ) ) { 
line 96449: zFilename = ":memory:" ; 
line 96450: } 
line 96451: # endif 
line 96453: if ( ( vfsFlags & SQLITE_OPEN_MAIN_DB ) != 0 && ( zFilename == 0 || * zFilename == 0 ) ) { 
line 96454: vfsFlags = ( vfsFlags & ~ SQLITE_OPEN_MAIN_DB ) | SQLITE_OPEN_TEMP_DB ; 
line 96455: } 
line 96456: rc = sqlite3BtreeOpen ( zFilename , ( sqlite3 * ) db , ppBtree , btFlags , vfsFlags ) ; 
line 96463: if ( rc == SQLITE_OK && 0 == sqlite3BtreeSchema ( * ppBtree , 0 , 0 ) ) { 
line 96464: sqlite3BtreeSetCacheSize ( * ppBtree , nCache ) ; 
line 96465: } 
line 96466: return rc ; 
line 96467: } 
line 96473: SQLITE_API const char * sqlite3_errmsg ( sqlite3 * db ) { 
line 96474: const char * z ; 
line 96475: if ( ! db ) { 
line 96476: return sqlite3ErrStr ( SQLITE_NOMEM ) ; 
line 96477: } 
line 96478: if ( ! sqlite3SafetyCheckSickOrOk ( db ) ) { 
line 96479: return sqlite3ErrStr ( SQLITE_MISUSE ) ; 
line 96480: } 
line 96481: sqlite3_mutex_enter ( db -> mutex ) ; 
line 96482: if ( db -> mallocFailed ) { 
line 96483: z = sqlite3ErrStr ( SQLITE_NOMEM ) ; 
line 96484: } else { 
line 96485: z = ( char * ) sqlite3_value_text ( db -> pErr ) ; 
line 96486: assert ( ! db -> mallocFailed ) ; 
line 96487: if ( z == 0 ) { 
line 96488: z = sqlite3ErrStr ( db -> errCode ) ; 
line 96489: } 
line 96490: } 
line 96491: sqlite3_mutex_leave ( db -> mutex ) ; 
line 96492: return z ; 
line 96493: } 
line 96495: # ifndef SQLITE_OMIT_UTF16 
line 96500: SQLITE_API const void * sqlite3_errmsg16 ( sqlite3 * db ) { 
line 96501: static const u16 outOfMem [ ] = { 
line 96502: 'o' , 'u' , 't' , ' ' , 'o' , 'f' , ' ' , 'm' , 'e' , 'm' , 'o' , 'r' , 'y' , 0 
line 96503: } ; 
line 96504: static const u16 misuse [ ] = { 
line 96505: 'l' , 'i' , 'b' , 'r' , 'a' , 'r' , 'y' , ' ' , 
line 96506: 'r' , 'o' , 'u' , 't' , 'i' , 'n' , 'e' , ' ' , 
line 96507: 'c' , 'a' , 'l' , 'l' , 'e' , 'd' , ' ' , 
line 96508: 'o' , 'u' , 't' , ' ' , 
line 96509: 'o' , 'f' , ' ' , 
line 96510: 's' , 'e' , 'q' , 'u' , 'e' , 'n' , 'c' , 'e' , 0 
line 96511: } ; 
line 96513: const void * z ; 
line 96514: if ( ! db ) { 
line 96515: return ( void * ) outOfMem ; 
line 96516: } 
line 96517: if ( ! sqlite3SafetyCheckSickOrOk ( db ) ) { 
line 96518: return ( void * ) misuse ; 
line 96519: } 
line 96520: sqlite3_mutex_enter ( db -> mutex ) ; 
line 96521: if ( db -> mallocFailed ) { 
line 96522: z = ( void * ) outOfMem ; 
line 96523: } else { 
line 96524: z = sqlite3_value_text16 ( db -> pErr ) ; 
line 96525: if ( z == 0 ) { 
line 96526: sqlite3ValueSetStr ( db -> pErr , - 1 , sqlite3ErrStr ( db -> errCode ) , 
line 96527: SQLITE_UTF8 , SQLITE_STATIC ) ; 
line 96528: z = sqlite3_value_text16 ( db -> pErr ) ; 
line 96529: } 
line 96535: db -> mallocFailed = 0 ; 
line 96536: } 
line 96537: sqlite3_mutex_leave ( db -> mutex ) ; 
line 96538: return z ; 
line 96539: } 
line 96540: # endif 
line 96546: SQLITE_API int sqlite3_errcode ( sqlite3 * db ) { 
line 96547: if ( db && ! sqlite3SafetyCheckSickOrOk ( db ) ) { 
line 96548: return SQLITE_MISUSE ; 
line 96549: } 
line 96550: if ( ! db || db -> mallocFailed ) { 
line 96551: return SQLITE_NOMEM ; 
line 96552: } 
line 96553: return db -> errCode & db -> errMask ; 
line 96554: } 
line 96555: SQLITE_API int sqlite3_extended_errcode ( sqlite3 * db ) { 
line 96556: if ( db && ! sqlite3SafetyCheckSickOrOk ( db ) ) { 
line 96557: return SQLITE_MISUSE ; 
line 96558: } 
line 96559: if ( ! db || db -> mallocFailed ) { 
line 96560: return SQLITE_NOMEM ; 
line 96561: } 
line 96562: return db -> errCode ; 
line 96563: } 
line 96569: static int createCollation ( 
line 96570: sqlite3 * db , 
line 96571: const char * zName , 
line 96572: u8 enc , 
line 96573: u8 collType , 
line 96574: void * pCtx , 
line 96575: int ( * xCompare ) ( void * , int , const void * , int , const void * ) , 
line 96576: void ( * xDel ) ( void * ) 
line 96577: ) { 
line 96578: CollSeq * pColl ; 
line 96579: int enc2 ; 
line 96580: int nName = sqlite3Strlen30 ( zName ) ; 
line 96582: assert ( sqlite3_mutex_held ( db -> mutex ) ) ; 
line 96588: enc2 = enc ; 
line 96589: testcase ( enc2 == SQLITE_UTF16 ) ; 
line 96590: testcase ( enc2 == SQLITE_UTF16_ALIGNED ) ; 
line 96591: if ( enc2 == SQLITE_UTF16 || enc2 == SQLITE_UTF16_ALIGNED ) { 
line 96592: enc2 = SQLITE_UTF16NATIVE ; 
line 96593: } 
line 96594: if ( enc2 < SQLITE_UTF8 || enc2 > SQLITE_UTF16BE ) { 
line 96595: return SQLITE_MISUSE ; 
line 96596: } 
line 96602: pColl = sqlite3FindCollSeq ( db , ( u8 ) enc2 , zName , 0 ) ; 
line 96603: if ( pColl && pColl -> xCmp ) { 
line 96604: if ( db -> activeVdbeCnt ) { 
line 96605: sqlite3Error ( db , SQLITE_BUSY , 
line 96606: "unable to delete/modify collation sequence due to active statements" ) ; 
line 96607: return SQLITE_BUSY ; 
line 96608: } 
line 96609: sqlite3ExpirePreparedStatements ( db ) ; 
line 96617: if ( ( pColl -> enc & ~ SQLITE_UTF16_ALIGNED ) == enc2 ) { 
line 96618: CollSeq * aColl = sqlite3HashFind ( & db -> aCollSeq , zName , nName ) ; 
line 96619: int j ; 
line 96620: for ( j = 0 ; j < 3 ; j ++ ) { 
line 96621: CollSeq * p = & aColl [ j ] ; 
line 96622: if ( p -> enc == pColl -> enc ) { 
line 96623: if ( p -> xDel ) { 
line 96624: p -> xDel ( p -> pUser ) ; 
line 96625: } 
line 96626: p -> xCmp = 0 ; 
line 96627: } 
line 96628: } 
line 96629: } 
line 96630: } 
line 96632: pColl = sqlite3FindCollSeq ( db , ( u8 ) enc2 , zName , 1 ) ; 
line 96633: if ( pColl ) { 
line 96634: pColl -> xCmp = xCompare ; 
line 96635: pColl -> pUser = pCtx ; 
line 96636: pColl -> xDel = xDel ; 
line 96637: pColl -> enc = ( u8 ) ( enc2 | ( enc & SQLITE_UTF16_ALIGNED ) ) ; 
line 96638: pColl -> type = collType ; 
line 96639: } 
line 96640: sqlite3Error ( db , SQLITE_OK , 0 ) ; 
line 96641: return SQLITE_OK ; 
line 96642: } 
line 96650: static const int aHardLimit [ ] = { 
line 96651: SQLITE_MAX_LENGTH , 
line 96652: SQLITE_MAX_SQL_LENGTH , 
line 96653: SQLITE_MAX_COLUMN , 
line 96654: SQLITE_MAX_EXPR_DEPTH , 
line 96655: SQLITE_MAX_COMPOUND_SELECT , 
line 96656: SQLITE_MAX_VDBE_OP , 
line 96657: SQLITE_MAX_FUNCTION_ARG , 
line 96658: SQLITE_MAX_ATTACHED , 
line 96659: SQLITE_MAX_LIKE_PATTERN_LENGTH , 
line 96660: SQLITE_MAX_VARIABLE_NUMBER , 
line 96661: SQLITE_MAX_TRIGGER_DEPTH , 
line 96662: } ; 
line 96667: # if SQLITE_MAX_LENGTH < 100 
line 96668: # error SQLITE_MAX_LENGTH must be at least 100 
line 96669: # endif 
line 96670: # if SQLITE_MAX_SQL_LENGTH < 100 
line 96671: # error SQLITE_MAX_SQL_LENGTH must be at least 100 
line 96672: # endif 
line 96673: # if SQLITE_MAX_SQL_LENGTH > SQLITE_MAX_LENGTH 
line 96674: # error SQLITE_MAX_SQL_LENGTH must not be greater than SQLITE_MAX_LENGTH 
line 96675: # endif 
line 96676: # if SQLITE_MAX_COMPOUND_SELECT < 2 
line 96677: # error SQLITE_MAX_COMPOUND_SELECT must be at least 2 
line 96678: # endif 
line 96679: # if SQLITE_MAX_VDBE_OP < 40 
line 96680: # error SQLITE_MAX_VDBE_OP must be at least 40 
line 96681: # endif 
line 96682: # if SQLITE_MAX_FUNCTION_ARG < 0 || SQLITE_MAX_FUNCTION_ARG > 1000 
line 96683: # error SQLITE_MAX_FUNCTION_ARG must be between 0 and 1000 
line 96684: # endif 
line 96685: # if SQLITE_MAX_ATTACHED < 0 || SQLITE_MAX_ATTACHED > 30 
line 96686: # error SQLITE_MAX_ATTACHED must be between 0 and 30 
line 96687: # endif 
line 96688: # if SQLITE_MAX_LIKE_PATTERN_LENGTH < 1 
line 96689: # error SQLITE_MAX_LIKE_PATTERN_LENGTH must be at least 1 
line 96690: # endif 
line 96691: # if SQLITE_MAX_COLUMN > 32767 
line 96692: # error SQLITE_MAX_COLUMN must not exceed 32767 
line 96693: # endif 
line 96694: # if SQLITE_MAX_TRIGGER_DEPTH < 1 
line 96695: # error SQLITE_MAX_TRIGGER_DEPTH must be at least 1 
line 96696: # endif 
line 96709: SQLITE_API int sqlite3_limit ( sqlite3 * db , int limitId , int newLimit ) { 
line 96710: int oldLimit ; 
line 96711: if ( limitId < 0 || limitId >= SQLITE_N_LIMIT ) { 
line 96712: return - 1 ; 
line 96713: } 
line 96714: oldLimit = db -> aLimit [ limitId ] ; 
line 96715: if ( newLimit >= 0 ) { 
line 96716: if ( newLimit > aHardLimit [ limitId ] ) { 
line 96717: newLimit = aHardLimit [ limitId ] ; 
line 96718: } 
line 96719: db -> aLimit [ limitId ] = newLimit ; 
line 96720: } 
line 96721: return oldLimit ; 
line 96722: } 
line 96729: static int openDatabase ( 
line 96730: const char * zFilename , 
line 96731: sqlite3 * * ppDb , 
line 96732: unsigned flags , 
line 96733: const char * zVfs 
line 96734: ) { 
line 96735: sqlite3 * db ; 
line 96736: int rc ; 
line 96737: int isThreadsafe ; 
line 96739: * ppDb = 0 ; 
line 96740: # ifndef SQLITE_OMIT_AUTOINIT 
line 96741: rc = sqlite3_initialize ( ) ; 
line 96742: if ( rc ) return rc ; 
line 96743: # endif 
line 96745: if ( sqlite3GlobalConfig . bCoreMutex == 0 ) { 
line 96746: isThreadsafe = 0 ; 
line 96747: } else if ( flags & SQLITE_OPEN_NOMUTEX ) { 
line 96748: isThreadsafe = 0 ; 
line 96749: } else if ( flags & SQLITE_OPEN_FULLMUTEX ) { 
line 96750: isThreadsafe = 1 ; 
line 96751: } else { 
line 96752: isThreadsafe = sqlite3GlobalConfig . bFullMutex ; 
line 96753: } 
line 96754: if ( flags & SQLITE_OPEN_PRIVATECACHE ) { 
line 96755: flags &= ~ SQLITE_OPEN_SHAREDCACHE ; 
line 96756: } else if ( sqlite3GlobalConfig . sharedCacheEnabled ) { 
line 96757: flags |= SQLITE_OPEN_SHAREDCACHE ; 
line 96758: } 
line 96768: flags &= ~ ( SQLITE_OPEN_DELETEONCLOSE | 
line 96769: SQLITE_OPEN_EXCLUSIVE | 
line 96770: SQLITE_OPEN_MAIN_DB | 
line 96771: SQLITE_OPEN_TEMP_DB | 
line 96772: SQLITE_OPEN_TRANSIENT_DB | 
line 96773: SQLITE_OPEN_MAIN_JOURNAL | 
line 96774: SQLITE_OPEN_TEMP_JOURNAL | 
line 96775: SQLITE_OPEN_SUBJOURNAL | 
line 96776: SQLITE_OPEN_MASTER_JOURNAL | 
line 96777: SQLITE_OPEN_NOMUTEX | 
line 96778: SQLITE_OPEN_FULLMUTEX 
line 96779: ) ; 
line 96782: db = sqlite3MallocZero ( sizeof ( sqlite3 ) ) ; 
line 96783: if ( db == 0 ) goto opendb_out ; 
line 96784: if ( isThreadsafe ) { 
line 96785: db -> mutex = sqlite3MutexAlloc ( SQLITE_MUTEX_RECURSIVE ) ; 
line 96786: if ( db -> mutex == 0 ) { 
line 96787: sqlite3_free ( db ) ; 
line 96788: db = 0 ; 
line 96789: goto opendb_out ; 
line 96790: } 
line 96791: } 
line 96792: sqlite3_mutex_enter ( db -> mutex ) ; 
line 96793: db -> errMask = 0xff ; 
line 96794: db -> nDb = 2 ; 
line 96795: db -> magic = SQLITE_MAGIC_BUSY ; 
line 96796: db -> aDb = db -> aDbStatic ; 
line 96798: assert ( sizeof ( db -> aLimit ) == sizeof ( aHardLimit ) ) ; 
line 96799: memcpy ( db -> aLimit , aHardLimit , sizeof ( db -> aLimit ) ) ; 
line 96800: db -> autoCommit = 1 ; 
line 96801: db -> nextAutovac = - 1 ; 
line 96802: db -> nextPagesize = 0 ; 
line 96803: db -> flags |= SQLITE_ShortColNames 
line 96804: # if SQLITE_DEFAULT_FILE_FORMAT < 4 
line 96805: | SQLITE_LegacyFileFmt 
line 96806: # endif 
line 96807: # ifdef SQLITE_ENABLE_LOAD_EXTENSION 
line 96808: | SQLITE_LoadExtension 
line 96809: # endif 
line 96810: # if SQLITE_DEFAULT_RECURSIVE_TRIGGERS 
line 96811: | SQLITE_RecTriggers 
line 96812: # endif 
line 96813: ; 
line 96814: sqlite3HashInit ( & db -> aCollSeq ) ; 
line 96815: # ifndef SQLITE_OMIT_VIRTUALTABLE 
line 96816: sqlite3HashInit ( & db -> aModule ) ; 
line 96817: # endif 
line 96819: db -> pVfs = sqlite3_vfs_find ( zVfs ) ; 
line 96820: if ( ! db -> pVfs ) { 
line 96821: rc = SQLITE_ERROR ; 
line 96822: sqlite3Error ( db , rc , "no such vfs: %s" , zVfs ) ; 
line 96823: goto opendb_out ; 
line 96824: } 
line 96830: createCollation ( db , "BINARY" , SQLITE_UTF8 , SQLITE_COLL_BINARY , 0 , 
line 96831: binCollFunc , 0 ) ; 
line 96832: createCollation ( db , "BINARY" , SQLITE_UTF16BE , SQLITE_COLL_BINARY , 0 , 
line 96833: binCollFunc , 0 ) ; 
line 96834: createCollation ( db , "BINARY" , SQLITE_UTF16LE , SQLITE_COLL_BINARY , 0 , 
line 96835: binCollFunc , 0 ) ; 
line 96836: createCollation ( db , "RTRIM" , SQLITE_UTF8 , SQLITE_COLL_USER , ( void * ) 1 , 
line 96837: binCollFunc , 0 ) ; 
line 96838: if ( db -> mallocFailed ) { 
line 96839: goto opendb_out ; 
line 96840: } 
line 96841: db -> pDfltColl = sqlite3FindCollSeq ( db , SQLITE_UTF8 , "BINARY" , 0 ) ; 
line 96842: assert ( db -> pDfltColl != 0 ) ; 
line 96845: createCollation ( db , "NOCASE" , SQLITE_UTF8 , SQLITE_COLL_NOCASE , 0 , 
line 96846: nocaseCollatingFunc , 0 ) ; 
line 96849: db -> openFlags = flags ; 
line 96850: rc = sqlite3BtreeFactory ( db , zFilename , 0 , SQLITE_DEFAULT_CACHE_SIZE , 
line 96851: flags | SQLITE_OPEN_MAIN_DB , 
line 96852: & db -> aDb [ 0 ] . pBt ) ; 
line 96853: if ( rc != SQLITE_OK ) { 
line 96854: if ( rc == SQLITE_IOERR_NOMEM ) { 
line 96855: rc = SQLITE_NOMEM ; 
line 96856: } 
line 96857: sqlite3Error ( db , rc , 0 ) ; 
line 96858: goto opendb_out ; 
line 96859: } 
line 96860: db -> aDb [ 0 ] . pSchema = sqlite3SchemaGet ( db , db -> aDb [ 0 ] . pBt ) ; 
line 96861: db -> aDb [ 1 ] . pSchema = sqlite3SchemaGet ( db , 0 ) ; 
line 96867: db -> aDb [ 0 ] . zName = "main" ; 
line 96868: db -> aDb [ 0 ] . safety_level = 3 ; 
line 96869: db -> aDb [ 1 ] . zName = "temp" ; 
line 96870: db -> aDb [ 1 ] . safety_level = 1 ; 
line 96872: db -> magic = SQLITE_MAGIC_OPEN ; 
line 96873: if ( db -> mallocFailed ) { 
line 96874: goto opendb_out ; 
line 96875: } 
line 96881: sqlite3Error ( db , SQLITE_OK , 0 ) ; 
line 96882: sqlite3RegisterBuiltinFunctions ( db ) ; 
line 96887: sqlite3AutoLoadExtensions ( db ) ; 
line 96888: rc = sqlite3_errcode ( db ) ; 
line 96889: if ( rc != SQLITE_OK ) { 
line 96890: goto opendb_out ; 
line 96891: } 
line 96893: # ifdef SQLITE_ENABLE_FTS1 
line 96894: if ( ! db -> mallocFailed ) { 
line 96895: extern int sqlite3Fts1Init ( sqlite3 * ) ; 
line 96896: rc = sqlite3Fts1Init ( db ) ; 
line 96897: } 
line 96898: # endif 
line 96900: # ifdef SQLITE_ENABLE_FTS2 
line 96901: if ( ! db -> mallocFailed && rc == SQLITE_OK ) { 
line 96902: extern int sqlite3Fts2Init ( sqlite3 * ) ; 
line 96903: rc = sqlite3Fts2Init ( db ) ; 
line 96904: } 
line 96905: # endif 
line 96907: # ifdef SQLITE_ENABLE_FTS3 
line 96908: if ( ! db -> mallocFailed && rc == SQLITE_OK ) { 
line 96909: rc = sqlite3Fts3Init ( db ) ; 
line 96910: } 
line 96911: # endif 
line 96913: # ifdef SQLITE_ENABLE_ICU 
line 96914: if ( ! db -> mallocFailed && rc == SQLITE_OK ) { 
line 96915: rc = sqlite3IcuInit ( db ) ; 
line 96916: } 
line 96917: # endif 
line 96919: # ifdef SQLITE_ENABLE_RTREE 
line 96920: if ( ! db -> mallocFailed && rc == SQLITE_OK ) { 
line 96921: rc = sqlite3RtreeInit ( db ) ; 
line 96922: } 
line 96923: # endif 
line 96925: sqlite3Error ( db , rc , 0 ) ; 
line 96931: # ifdef SQLITE_DEFAULT_LOCKING_MODE 
line 96932: db -> dfltLockMode = SQLITE_DEFAULT_LOCKING_MODE ; 
line 96933: sqlite3PagerLockingMode ( sqlite3BtreePager ( db -> aDb [ 0 ] . pBt ) , 
line 96934: SQLITE_DEFAULT_LOCKING_MODE ) ; 
line 96935: # endif 
line 96938: setupLookaside ( db , 0 , sqlite3GlobalConfig . szLookaside , 
line 96939: sqlite3GlobalConfig . nLookaside ) ; 
line 96941: opendb_out : 
line 96942: if ( db ) { 
line 96943: assert ( db -> mutex != 0 || isThreadsafe == 0 || sqlite3GlobalConfig . bFullMutex == 0 ) ; 
line 96944: sqlite3_mutex_leave ( db -> mutex ) ; 
line 96945: } 
line 96946: rc = sqlite3_errcode ( db ) ; 
line 96947: if ( rc == SQLITE_NOMEM ) { 
line 96948: sqlite3_close ( db ) ; 
line 96949: db = 0 ; 
line 96950: } else if ( rc != SQLITE_OK ) { 
line 96951: db -> magic = SQLITE_MAGIC_SICK ; 
line 96952: } 
line 96953: * ppDb = db ; 
line 96954: return sqlite3ApiExit ( 0 , rc ) ; 
line 96955: } 
line 96960: SQLITE_API int sqlite3_open ( 
line 96961: const char * zFilename , 
line 96962: sqlite3 * * ppDb 
line 96963: ) { 
line 96964: return openDatabase ( zFilename , ppDb , 
line 96965: SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE , 0 ) ; 
line 96966: } 
line 96967: SQLITE_API int sqlite3_open_v2 ( 
line 96968: const char * filename , 
line 96969: sqlite3 * * ppDb , 
line 96970: int flags , 
line 96971: const char * zVfs 
line 96972: ) { 
line 96973: return openDatabase ( filename , ppDb , flags , zVfs ) ; 
line 96974: } 
line 96976: # ifndef SQLITE_OMIT_UTF16 
line 96980: SQLITE_API int sqlite3_open16 ( 
line 96981: const void * zFilename , 
line 96982: sqlite3 * * ppDb 
line 96983: ) { 
line 96984: char const * zFilename8 ; 
line 96985: sqlite3_value * pVal ; 
line 96986: int rc ; 
line 96988: assert ( zFilename ) ; 
line 96989: assert ( ppDb ) ; 
line 96990: * ppDb = 0 ; 
line 96991: # ifndef SQLITE_OMIT_AUTOINIT 
line 96992: rc = sqlite3_initialize ( ) ; 
line 96993: if ( rc ) return rc ; 
line 96994: # endif 
line 96995: pVal = sqlite3ValueNew ( 0 ) ; 
line 96996: sqlite3ValueSetStr ( pVal , - 1 , zFilename , SQLITE_UTF16NATIVE , SQLITE_STATIC ) ; 
line 96997: zFilename8 = sqlite3ValueText ( pVal , SQLITE_UTF8 ) ; 
line 96998: if ( zFilename8 ) { 
line 96999: rc = openDatabase ( zFilename8 , ppDb , 
line 97000: SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE , 0 ) ; 
line 97001: assert ( * ppDb || rc == SQLITE_NOMEM ) ; 
line 97002: if ( rc == SQLITE_OK && ! DbHasProperty ( * ppDb , 0 , DB_SchemaLoaded ) ) { 
line 97003: ENC ( * ppDb ) = SQLITE_UTF16NATIVE ; 
line 97004: } 
line 97005: } else { 
line 97006: rc = SQLITE_NOMEM ; 
line 97007: } 
line 97008: sqlite3ValueFree ( pVal ) ; 
line 97010: return sqlite3ApiExit ( 0 , rc ) ; 
line 97011: } 
line 97012: # endif 
line 97017: SQLITE_API int sqlite3_create_collation ( 
line 97018: sqlite3 * db , 
line 97019: const char * zName , 
line 97020: int enc , 
line 97021: void * pCtx , 
line 97022: int ( * xCompare ) ( void * , int , const void * , int , const void * ) 
line 97023: ) { 
line 97024: int rc ; 
line 97025: sqlite3_mutex_enter ( db -> mutex ) ; 
line 97026: assert ( ! db -> mallocFailed ) ; 
line 97027: rc = createCollation ( db , zName , ( u8 ) enc , SQLITE_COLL_USER , pCtx , xCompare , 0 ) ; 
line 97028: rc = sqlite3ApiExit ( db , rc ) ; 
line 97029: sqlite3_mutex_leave ( db -> mutex ) ; 
line 97030: return rc ; 
line 97031: } 
line 97036: SQLITE_API int sqlite3_create_collation_v2 ( 
line 97037: sqlite3 * db , 
line 97038: const char * zName , 
line 97039: int enc , 
line 97040: void * pCtx , 
line 97041: int ( * xCompare ) ( void * , int , const void * , int , const void * ) , 
line 97042: void ( * xDel ) ( void * ) 
line 97043: ) { 
line 97044: int rc ; 
line 97045: sqlite3_mutex_enter ( db -> mutex ) ; 
line 97046: assert ( ! db -> mallocFailed ) ; 
line 97047: rc = createCollation ( db , zName , ( u8 ) enc , SQLITE_COLL_USER , pCtx , xCompare , xDel ) ; 
line 97048: rc = sqlite3ApiExit ( db , rc ) ; 
line 97049: sqlite3_mutex_leave ( db -> mutex ) ; 
line 97050: return rc ; 
line 97051: } 
line 97053: # ifndef SQLITE_OMIT_UTF16 
line 97057: SQLITE_API int sqlite3_create_collation16 ( 
line 97058: sqlite3 * db , 
line 97059: const void * zName , 
line 97060: int enc , 
line 97061: void * pCtx , 
line 97062: int ( * xCompare ) ( void * , int , const void * , int , const void * ) 
line 97063: ) { 
line 97064: int rc = SQLITE_OK ; 
line 97065: char * zName8 ; 
line 97066: sqlite3_mutex_enter ( db -> mutex ) ; 
line 97067: assert ( ! db -> mallocFailed ) ; 
line 97068: zName8 = sqlite3Utf16to8 ( db , zName , - 1 ) ; 
line 97069: if ( zName8 ) { 
line 97070: rc = createCollation ( db , zName8 , ( u8 ) enc , SQLITE_COLL_USER , pCtx , xCompare , 0 ) ; 
line 97071: sqlite3DbFree ( db , zName8 ) ; 
line 97072: } 
line 97073: rc = sqlite3ApiExit ( db , rc ) ; 
line 97074: sqlite3_mutex_leave ( db -> mutex ) ; 
line 97075: return rc ; 
line 97076: } 
line 97077: # endif 
line 97083: SQLITE_API int sqlite3_collation_needed ( 
line 97084: sqlite3 * db , 
line 97085: void * pCollNeededArg , 
line 97086: void ( * xCollNeeded ) ( void * , sqlite3 * , int eTextRep , const char * ) 
line 97087: ) { 
line 97088: sqlite3_mutex_enter ( db -> mutex ) ; 
line 97089: db -> xCollNeeded = xCollNeeded ; 
line 97090: db -> xCollNeeded16 = 0 ; 
line 97091: db -> pCollNeededArg = pCollNeededArg ; 
line 97092: sqlite3_mutex_leave ( db -> mutex ) ; 
line 97093: return SQLITE_OK ; 
line 97094: } 
line 97096: # ifndef SQLITE_OMIT_UTF16 
line 97101: SQLITE_API int sqlite3_collation_needed16 ( 
line 97102: sqlite3 * db , 
line 97103: void * pCollNeededArg , 
line 97104: void ( * xCollNeeded16 ) ( void * , sqlite3 * , int eTextRep , const void * ) 
line 97105: ) { 
line 97106: sqlite3_mutex_enter ( db -> mutex ) ; 
line 97107: db -> xCollNeeded = 0 ; 
line 97108: db -> xCollNeeded16 = xCollNeeded16 ; 
line 97109: db -> pCollNeededArg = pCollNeededArg ; 
line 97110: sqlite3_mutex_leave ( db -> mutex ) ; 
line 97111: return SQLITE_OK ; 
line 97112: } 
line 97113: # endif 
line 97115: # ifndef SQLITE_OMIT_GLOBALRECOVER 
line 97116: # ifndef SQLITE_OMIT_DEPRECATED 
line 97121: SQLITE_API int sqlite3_global_recover ( void ) { 
line 97122: return SQLITE_OK ; 
line 97123: } 
line 97124: # endif 
line 97125: # endif 
line 97135: SQLITE_API int sqlite3_get_autocommit ( sqlite3 * db ) { 
line 97136: return db -> autoCommit ; 
line 97137: } 
line 97139: # ifdef SQLITE_DEBUG 
line 97145: SQLITE_PRIVATE int sqlite3Corrupt ( void ) { 
line 97146: return SQLITE_CORRUPT ; 
line 97147: } 
line 97148: # endif 
line 97150: # ifndef SQLITE_OMIT_DEPRECATED 
line 97158: SQLITE_API void sqlite3_thread_cleanup ( void ) { 
line 97159: } 
line 97160: # endif 
line 97166: # ifdef SQLITE_ENABLE_COLUMN_METADATA 
line 97167: SQLITE_API int sqlite3_table_column_metadata ( 
line 97168: sqlite3 * db , 
line 97169: const char * zDbName , 
line 97170: const char * zTableName , 
line 97171: const char * zColumnName , 
line 97172: char const * * pzDataType , 
line 97173: char const * * pzCollSeq , 
line 97174: int * pNotNull , 
line 97175: int * pPrimaryKey , 
line 97176: int * pAutoinc 
line 97177: ) { 
line 97178: int rc ; 
line 97179: char * zErrMsg = 0 ; 
line 97180: Table * pTab = 0 ; 
line 97181: Column * pCol = 0 ; 
line 97182: int iCol ; 
line 97184: char const * zDataType = 0 ; 
line 97185: char const * zCollSeq = 0 ; 
line 97186: int notnull = 0 ; 
line 97187: int primarykey = 0 ; 
line 97188: int autoinc = 0 ; 
line 97191: sqlite3_mutex_enter ( db -> mutex ) ; 
line 97192: ( void ) sqlite3SafetyOn ( db ) ; 
line 97193: sqlite3BtreeEnterAll ( db ) ; 
line 97194: rc = sqlite3Init ( db , & zErrMsg ) ; 
line 97195: if ( SQLITE_OK != rc ) { 
line 97196: goto error_out ; 
line 97197: } 
line 97200: pTab = sqlite3FindTable ( db , zTableName , zDbName ) ; 
line 97201: if ( ! pTab || pTab -> pSelect ) { 
line 97202: pTab = 0 ; 
line 97203: goto error_out ; 
line 97204: } 
line 97207: if ( sqlite3IsRowid ( zColumnName ) ) { 
line 97208: iCol = pTab -> iPKey ; 
line 97209: if ( iCol >= 0 ) { 
line 97210: pCol = & pTab -> aCol [ iCol ] ; 
line 97211: } 
line 97212: } else { 
line 97213: for ( iCol = 0 ; iCol < pTab -> nCol ; iCol ++ ) { 
line 97214: pCol = & pTab -> aCol [ iCol ] ; 
line 97215: if ( 0 == sqlite3StrICmp ( pCol -> zName , zColumnName ) ) { 
line 97216: break ; 
line 97217: } 
line 97218: } 
line 97219: if ( iCol == pTab -> nCol ) { 
line 97220: pTab = 0 ; 
line 97221: goto error_out ; 
line 97222: } 
line 97223: } 
line 97235: if ( pCol ) { 
line 97236: zDataType = pCol -> zType ; 
line 97237: zCollSeq = pCol -> zColl ; 
line 97238: notnull = pCol -> notNull != 0 ; 
line 97239: primarykey = pCol -> isPrimKey != 0 ; 
line 97240: autoinc = pTab -> iPKey == iCol && ( pTab -> tabFlags & TF_Autoincrement ) != 0 ; 
line 97241: } else { 
line 97242: zDataType = "INTEGER" ; 
line 97243: primarykey = 1 ; 
line 97244: } 
line 97245: if ( ! zCollSeq ) { 
line 97246: zCollSeq = "BINARY" ; 
line 97247: } 
line 97249: error_out : 
line 97250: sqlite3BtreeLeaveAll ( db ) ; 
line 97251: ( void ) sqlite3SafetyOff ( db ) ; 
line 97257: if ( pzDataType ) * pzDataType = zDataType ; 
line 97258: if ( pzCollSeq ) * pzCollSeq = zCollSeq ; 
line 97259: if ( pNotNull ) * pNotNull = notnull ; 
line 97260: if ( pPrimaryKey ) * pPrimaryKey = primarykey ; 
line 97261: if ( pAutoinc ) * pAutoinc = autoinc ; 
line 97263: if ( SQLITE_OK == rc && ! pTab ) { 
line 97264: sqlite3DbFree ( db , zErrMsg ) ; 
line 97265: zErrMsg = sqlite3MPrintf ( db , "no such table column: %s.%s" , zTableName , 
line 97266: zColumnName ) ; 
line 97267: rc = SQLITE_ERROR ; 
line 97268: } 
line 97269: sqlite3Error ( db , rc , ( zErrMsg ? "%s" : 0 ) , zErrMsg ) ; 
line 97270: sqlite3DbFree ( db , zErrMsg ) ; 
line 97271: rc = sqlite3ApiExit ( db , rc ) ; 
line 97272: sqlite3_mutex_leave ( db -> mutex ) ; 
line 97273: return rc ; 
line 97274: } 
line 97275: # endif 
line 97280: SQLITE_API int sqlite3_sleep ( int ms ) { 
line 97281: sqlite3_vfs * pVfs ; 
line 97282: int rc ; 
line 97283: pVfs = sqlite3_vfs_find ( 0 ) ; 
line 97284: if ( pVfs == 0 ) return 0 ; 
line 97289: rc = ( sqlite3OsSleep ( pVfs , 1000 * ms ) / 1000 ) ; 
line 97290: return rc ; 
line 97291: } 
line 97296: SQLITE_API int sqlite3_extended_result_codes ( sqlite3 * db , int onoff ) { 
line 97297: sqlite3_mutex_enter ( db -> mutex ) ; 
line 97298: db -> errMask = onoff ? 0xffffffff : 0xff ; 
line 97299: sqlite3_mutex_leave ( db -> mutex ) ; 
line 97300: return SQLITE_OK ; 
line 97301: } 
line 97306: SQLITE_API int sqlite3_file_control ( sqlite3 * db , const char * zDbName , int op , void * pArg ) { 
line 97307: int rc = SQLITE_ERROR ; 
line 97308: int iDb ; 
line 97309: sqlite3_mutex_enter ( db -> mutex ) ; 
line 97310: if ( zDbName == 0 ) { 
line 97311: iDb = 0 ; 
line 97312: } else { 
line 97313: for ( iDb = 0 ; iDb < db -> nDb ; iDb ++ ) { 
line 97314: if ( strcmp ( db -> aDb [ iDb ] . zName , zDbName ) == 0 ) break ; 
line 97315: } 
line 97316: } 
line 97317: if ( iDb < db -> nDb ) { 
line 97318: Btree * pBtree = db -> aDb [ iDb ] . pBt ; 
line 97319: if ( pBtree ) { 
line 97320: Pager * pPager ; 
line 97321: sqlite3_file * fd ; 
line 97322: sqlite3BtreeEnter ( pBtree ) ; 
line 97323: pPager = sqlite3BtreePager ( pBtree ) ; 
line 97324: assert ( pPager != 0 ) ; 
line 97325: fd = sqlite3PagerFile ( pPager ) ; 
line 97326: assert ( fd != 0 ) ; 
line 97327: if ( fd -> pMethods ) { 
line 97328: rc = sqlite3OsFileControl ( fd , op , pArg ) ; 
line 97329: } 
line 97330: sqlite3BtreeLeave ( pBtree ) ; 
line 97331: } 
line 97332: } 
line 97333: sqlite3_mutex_leave ( db -> mutex ) ; 
line 97334: return rc ; 
line 97335: } 
line 97340: SQLITE_API int sqlite3_test_control ( int op , ... ) { 
line 97341: int rc = 0 ; 
line 97342: # ifndef SQLITE_OMIT_BUILTIN_TEST 
line 97343: va_list ap ; 
line 97344: va_start ( ap , op ) ; 
line 97345: switch ( op ) { 
line 97350: case SQLITE_TESTCTRL_PRNG_SAVE : { 
line 97351: sqlite3PrngSaveState ( ) ; 
line 97352: break ; 
line 97353: } 
line 97360: case SQLITE_TESTCTRL_PRNG_RESTORE : { 
line 97361: sqlite3PrngRestoreState ( ) ; 
line 97362: break ; 
line 97363: } 
line 97370: case SQLITE_TESTCTRL_PRNG_RESET : { 
line 97371: sqlite3PrngResetState ( ) ; 
line 97372: break ; 
line 97373: } 
line 97383: case SQLITE_TESTCTRL_BITVEC_TEST : { 
line 97384: int sz = va_arg ( ap , int ) ; 
line 97385: int * aProg = va_arg ( ap , int * ) ; 
line 97386: rc = sqlite3BitvecBuiltinTest ( sz , aProg ) ; 
line 97387: break ; 
line 97388: } 
line 97396: case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS : { 
line 97397: typedef void ( * void_function ) ( void ) ; 
line 97398: void_function xBenignBegin ; 
line 97399: void_function xBenignEnd ; 
line 97400: xBenignBegin = va_arg ( ap , void_function ) ; 
line 97401: xBenignEnd = va_arg ( ap , void_function ) ; 
line 97402: sqlite3BenignMallocHooks ( xBenignBegin , xBenignEnd ) ; 
line 97403: break ; 
line 97404: } 
line 97418: case SQLITE_TESTCTRL_PENDING_BYTE : { 
line 97419: unsigned int newVal = va_arg ( ap , unsigned int ) ; 
line 97420: rc = sqlite3PendingByte ; 
line 97421: if ( newVal ) sqlite3PendingByte = newVal ; 
line 97422: break ; 
line 97423: } 
line 97436: case SQLITE_TESTCTRL_ASSERT : { 
line 97437: volatile int x = 0 ; 
line 97438: assert ( ( x = va_arg ( ap , int ) ) != 0 ) ; 
line 97439: rc = x ; 
line 97440: break ; 
line 97441: } 
line 97471: case SQLITE_TESTCTRL_ALWAYS : { 
line 97472: int x = va_arg ( ap , int ) ; 
line 97473: rc = ALWAYS ( x ) ; 
line 97474: break ; 
line 97475: } 
line 97482: case SQLITE_TESTCTRL_RESERVE : { 
line 97483: sqlite3 * db = va_arg ( ap , sqlite3 * ) ; 
line 97484: int x = va_arg ( ap , int ) ; 
line 97485: sqlite3_mutex_enter ( db -> mutex ) ; 
line 97486: sqlite3BtreeSetPageSize ( db -> aDb [ 0 ] . pBt , 0 , x , 0 ) ; 
line 97487: sqlite3_mutex_leave ( db -> mutex ) ; 
line 97488: break ; 
line 97489: } 
line 97500: case SQLITE_TESTCTRL_OPTIMIZATIONS : { 
line 97501: sqlite3 * db = va_arg ( ap , sqlite3 * ) ; 
line 97502: int x = va_arg ( ap , int ) ; 
line 97503: db -> flags = ( x & SQLITE_OptMask ) | ( db -> flags & ~ SQLITE_OptMask ) ; 
line 97504: break ; 
line 97505: } 
line 97507: # ifdef SQLITE_N_KEYWORD 
line 97517: case SQLITE_TESTCTRL_ISKEYWORD : { 
line 97518: const char * zWord = va_arg ( ap , const char * ) ; 
line 97519: int n = sqlite3Strlen30 ( zWord ) ; 
line 97520: rc = ( sqlite3KeywordCode ( ( u8 * ) zWord , n ) != TK_ID ) ? SQLITE_N_KEYWORD : 0 ; 
line 97521: break ; 
line 97522: } 
line 97523: # endif 
line 97525: } 
line 97526: va_end ( ap ) ; 
line 97527: # endif 
line 97528: return rc ; 
line 97529: } 
line 97550: # ifdef SQLITE_ENABLE_UNLOCK_NOTIFY 
line 97561: # define assertMutexHeld ( ) 
line 97562: assert ( sqlite3_mutex_held ( sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ) ) 
line 97570: static sqlite3 * SQLITE_WSD sqlite3BlockedList = 0 ; 
line 97572: # ifndef NDEBUG 
line 97587: static void checkListProperties ( sqlite3 * db ) { 
line 97588: sqlite3 * p ; 
line 97589: for ( p = sqlite3BlockedList ; p ; p = p -> pNextBlocked ) { 
line 97590: int seen = 0 ; 
line 97591: sqlite3 * p2 ; 
line 97594: assert ( p -> pUnlockConnection || p -> pBlockingConnection ) ; 
line 97597: for ( p2 = sqlite3BlockedList ; p2 != p ; p2 = p2 -> pNextBlocked ) { 
line 97598: if ( p2 -> xUnlockNotify == p -> xUnlockNotify ) seen = 1 ; 
line 97599: assert ( p2 -> xUnlockNotify == p -> xUnlockNotify || ! seen ) ; 
line 97600: assert ( db == 0 || p -> pUnlockConnection != db ) ; 
line 97601: assert ( db == 0 || p -> pBlockingConnection != db ) ; 
line 97602: } 
line 97603: } 
line 97604: } 
line 97605: # else 
line 97606: # define checkListProperties ( x ) 
line 97607: # endif 
line 97613: static void removeFromBlockedList ( sqlite3 * db ) { 
line 97614: sqlite3 * * pp ; 
line 97615: assertMutexHeld ( ) ; 
line 97616: for ( pp = & sqlite3BlockedList ; * pp ; pp = & ( * pp ) -> pNextBlocked ) { 
line 97617: if ( * pp == db ) { 
line 97618: * pp = ( * pp ) -> pNextBlocked ; 
line 97619: break ; 
line 97620: } 
line 97621: } 
line 97622: } 
line 97628: static void addToBlockedList ( sqlite3 * db ) { 
line 97629: sqlite3 * * pp ; 
line 97630: assertMutexHeld ( ) ; 
line 97631: for ( 
line 97632: pp = & sqlite3BlockedList ; 
line 97633: * pp && ( * pp ) -> xUnlockNotify != db -> xUnlockNotify ; 
line 97634: pp = & ( * pp ) -> pNextBlocked 
line 97635: ) ; 
line 97636: db -> pNextBlocked = * pp ; 
line 97637: * pp = db ; 
line 97638: } 
line 97643: static void enterMutex ( void ) { 
line 97644: sqlite3_mutex_enter ( sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ) ; 
line 97645: checkListProperties ( 0 ) ; 
line 97646: } 
line 97651: static void leaveMutex ( void ) { 
line 97652: assertMutexHeld ( ) ; 
line 97653: checkListProperties ( 0 ) ; 
line 97654: sqlite3_mutex_leave ( sqlite3MutexAlloc ( SQLITE_MUTEX_STATIC_MASTER ) ) ; 
line 97655: } 
line 97678: SQLITE_API int sqlite3_unlock_notify ( 
line 97679: sqlite3 * db , 
line 97680: void ( * xNotify ) ( void * * , int ) , 
line 97681: void * pArg 
line 97682: ) { 
line 97683: int rc = SQLITE_OK ; 
line 97685: sqlite3_mutex_enter ( db -> mutex ) ; 
line 97686: enterMutex ( ) ; 
line 97688: if ( xNotify == 0 ) { 
line 97689: removeFromBlockedList ( db ) ; 
line 97690: db -> pUnlockConnection = 0 ; 
line 97691: db -> xUnlockNotify = 0 ; 
line 97692: db -> pUnlockArg = 0 ; 
line 97693: } else if ( 0 == db -> pBlockingConnection ) { 
line 97698: xNotify ( & pArg , 1 ) ; 
line 97699: } else { 
line 97700: sqlite3 * p ; 
line 97702: for ( p = db -> pBlockingConnection ; p && p != db ; p = p -> pUnlockConnection ) { } 
line 97703: if ( p ) { 
line 97704: rc = SQLITE_LOCKED ; 
line 97705: } else { 
line 97706: db -> pUnlockConnection = db -> pBlockingConnection ; 
line 97707: db -> xUnlockNotify = xNotify ; 
line 97708: db -> pUnlockArg = pArg ; 
line 97709: removeFromBlockedList ( db ) ; 
line 97710: addToBlockedList ( db ) ; 
line 97711: } 
line 97712: } 
line 97714: leaveMutex ( ) ; 
line 97715: assert ( ! db -> mallocFailed ) ; 
line 97716: sqlite3Error ( db , rc , ( rc ? "database is deadlocked" : 0 ) ) ; 
line 97717: sqlite3_mutex_leave ( db -> mutex ) ; 
line 97718: return rc ; 
line 97719: } 
line 97727: SQLITE_PRIVATE void sqlite3ConnectionBlocked ( sqlite3 * db , sqlite3 * pBlocker ) { 
line 97728: enterMutex ( ) ; 
line 97729: if ( db -> pBlockingConnection == 0 && db -> pUnlockConnection == 0 ) { 
line 97730: addToBlockedList ( db ) ; 
line 97731: } 
line 97732: db -> pBlockingConnection = pBlocker ; 
line 97733: leaveMutex ( ) ; 
line 97734: } 
line 97755: SQLITE_PRIVATE void sqlite3ConnectionUnlocked ( sqlite3 * db ) { 
line 97756: void ( * xUnlockNotify ) ( void * * , int ) = 0 ; 
line 97757: int nArg = 0 ; 
line 97758: sqlite3 * * pp ; 
line 97759: void * * aArg ; 
line 97760: void * * aDyn = 0 ; 
line 97761: void * aStatic [ 16 ] ; 
line 97763: aArg = aStatic ; 
line 97764: enterMutex ( ) ; 
line 97767: for ( pp = & sqlite3BlockedList ; * pp ; ) { 
line 97768: sqlite3 * p = * pp ; 
line 97771: if ( p -> pBlockingConnection == db ) { 
line 97772: p -> pBlockingConnection = 0 ; 
line 97773: } 
line 97776: if ( p -> pUnlockConnection == db ) { 
line 97777: assert ( p -> xUnlockNotify ) ; 
line 97778: if ( p -> xUnlockNotify != xUnlockNotify && nArg != 0 ) { 
line 97779: xUnlockNotify ( aArg , nArg ) ; 
line 97780: nArg = 0 ; 
line 97781: } 
line 97783: sqlite3BeginBenignMalloc ( ) ; 
line 97784: assert ( aArg == aDyn || ( aDyn == 0 && aArg == aStatic ) ) ; 
line 97785: assert ( nArg <= ( int ) ArraySize ( aStatic ) || aArg == aDyn ) ; 
line 97786: if ( ( ! aDyn && nArg == ( int ) ArraySize ( aStatic ) ) 
line 97787: || ( aDyn && nArg == ( int ) ( sqlite3DbMallocSize ( db , aDyn ) / sizeof ( void * ) ) ) 
line 97788: ) { 
line 97790: void * * pNew = ( void * * ) sqlite3Malloc ( nArg * sizeof ( void * ) * 2 ) ; 
line 97791: if ( pNew ) { 
line 97792: memcpy ( pNew , aArg , nArg * sizeof ( void * ) ) ; 
line 97793: sqlite3_free ( aDyn ) ; 
line 97794: aDyn = aArg = pNew ; 
line 97795: } else { 
line 97820: xUnlockNotify ( aArg , nArg ) ; 
line 97821: nArg = 0 ; 
line 97822: } 
line 97823: } 
line 97824: sqlite3EndBenignMalloc ( ) ; 
line 97826: aArg [ nArg ++ ] = p -> pUnlockArg ; 
line 97827: xUnlockNotify = p -> xUnlockNotify ; 
line 97828: p -> pUnlockConnection = 0 ; 
line 97829: p -> xUnlockNotify = 0 ; 
line 97830: p -> pUnlockArg = 0 ; 
line 97831: } 
line 97834: if ( p -> pBlockingConnection == 0 && p -> pUnlockConnection == 0 ) { 
line 97836: * pp = p -> pNextBlocked ; 
line 97837: p -> pNextBlocked = 0 ; 
line 97838: } else { 
line 97839: pp = & p -> pNextBlocked ; 
line 97840: } 
line 97841: } 
line 97843: if ( nArg != 0 ) { 
line 97844: xUnlockNotify ( aArg , nArg ) ; 
line 97845: } 
line 97846: sqlite3_free ( aDyn ) ; 
line 97847: leaveMutex ( ) ; 
line 97848: } 
line 97854: SQLITE_PRIVATE void sqlite3ConnectionClosed ( sqlite3 * db ) { 
line 97855: sqlite3ConnectionUnlocked ( db ) ; 
line 97856: enterMutex ( ) ; 
line 97857: removeFromBlockedList ( db ) ; 
line 97858: checkListProperties ( db ) ; 
line 97859: leaveMutex ( ) ; 
line 97860: } 
line 97861: # endif 
line 98139: # if ! defined ( SQLITE_CORE ) || defined ( SQLITE_ENABLE_FTS3 ) 
line 98141: # if defined ( SQLITE_ENABLE_FTS3 ) && ! defined ( SQLITE_CORE ) 
line 98142: # define SQLITE_CORE 1 
line 98143: # endif 
line 98161: # ifndef _FTSINT_H 
line 98162: # define _FTSINT_H 
line 98164: # if ! defined ( NDEBUG ) && ! defined ( SQLITE_DEBUG ) 
line 98165: # define NDEBUG 1 
line 98166: # endif 
line 98189: # ifndef _FTS3_TOKENIZER_H_ 
line 98190: # define _FTS3_TOKENIZER_H_ 
line 98216: typedef struct sqlite3_tokenizer_module sqlite3_tokenizer_module ; 
line 98217: typedef struct sqlite3_tokenizer sqlite3_tokenizer ; 
line 98218: typedef struct sqlite3_tokenizer_cursor sqlite3_tokenizer_cursor ; 
line 98220: struct sqlite3_tokenizer_module { 
line 98225: int iVersion ; 
line 98244: int ( * xCreate ) ( 
line 98245: int argc , 
line 98246: const char * const * argv , 
line 98247: sqlite3_tokenizer * * ppTokenizer 
line 98248: ) ; 
line 98254: int ( * xDestroy ) ( sqlite3_tokenizer * pTokenizer ) ; 
line 98261: int ( * xOpen ) ( 
line 98262: sqlite3_tokenizer * pTokenizer , 
line 98263: const char * pInput , int nBytes , 
line 98264: sqlite3_tokenizer_cursor * * ppCursor 
line 98265: ) ; 
line 98271: int ( * xClose ) ( sqlite3_tokenizer_cursor * pCursor ) ; 
line 98297: int ( * xNext ) ( 
line 98298: sqlite3_tokenizer_cursor * pCursor , 
line 98299: const char * * ppToken , int * pnBytes , 
line 98300: int * piStartOffset , 
line 98301: int * piEndOffset , 
line 98302: int * piPosition 
line 98303: ) ; 
line 98304: } ; 
line 98306: struct sqlite3_tokenizer { 
line 98307: const sqlite3_tokenizer_module * pModule ; 
line 98309: } ; 
line 98311: struct sqlite3_tokenizer_cursor { 
line 98312: sqlite3_tokenizer * pTokenizer ; 
line 98314: } ; 
line 98316: int fts3_global_term_cnt ( int iTerm , int iCol ) ; 
line 98317: int fts3_term_cnt ( int iTerm , int iCol ) ; 
line 98320: # endif 
line 98342: # ifndef _FTS3_HASH_H_ 
line 98343: # define _FTS3_HASH_H_ 
line 98346: typedef struct Fts3Hash Fts3Hash ; 
line 98347: typedef struct Fts3HashElem Fts3HashElem ; 
line 98357: struct Fts3Hash { 
line 98358: char keyClass ; 
line 98359: char copyKey ; 
line 98360: int count ; 
line 98361: Fts3HashElem * first ; 
line 98362: int htsize ; 
line 98363: struct _fts3ht { 
line 98364: int count ; 
line 98365: Fts3HashElem * chain ; 
line 98366: } * ht ; 
line 98367: } ; 
line 98375: struct Fts3HashElem { 
line 98376: Fts3HashElem * next , * prev ; 
line 98377: void * data ; 
line 98378: void * pKey ; int nKey ; 
line 98379: } ; 
line 98393: # define FTS3_HASH_STRING 1 
line 98394: # define FTS3_HASH_BINARY 2 
line 98399: SQLITE_PRIVATE void sqlite3Fts3HashInit ( Fts3Hash * pNew , char keyClass , char copyKey ) ; 
line 98400: SQLITE_PRIVATE void * sqlite3Fts3HashInsert ( Fts3Hash * , const void * pKey , int nKey , void * pData ) ; 
line 98401: SQLITE_PRIVATE void * sqlite3Fts3HashFind ( const Fts3Hash * , const void * pKey , int nKey ) ; 
line 98402: SQLITE_PRIVATE void sqlite3Fts3HashClear ( Fts3Hash * ) ; 
line 98403: SQLITE_PRIVATE Fts3HashElem * sqlite3Fts3HashFindElem ( const Fts3Hash * , const void * , int ) ; 
line 98408: # define fts3HashInit sqlite3Fts3HashInit 
line 98409: # define fts3HashInsert sqlite3Fts3HashInsert 
line 98410: # define fts3HashFind sqlite3Fts3HashFind 
line 98411: # define fts3HashClear sqlite3Fts3HashClear 
line 98412: # define fts3HashFindElem sqlite3Fts3HashFindElem 
line 98426: # define fts3HashFirst ( H ) ( ( H ) -> first ) 
line 98427: # define fts3HashNext ( E ) ( ( E ) -> next ) 
line 98428: # define fts3HashData ( E ) ( ( E ) -> data ) 
line 98429: # define fts3HashKey ( E ) ( ( E ) -> pKey ) 
line 98430: # define fts3HashKeysize ( E ) ( ( E ) -> nKey ) 
line 98435: # define fts3HashCount ( H ) ( ( H ) -> count ) 
line 98437: # endif 
line 98447: # define FTS3_MERGE_COUNT 16 
line 98457: # define FTS3_MAX_PENDING_DATA ( 1 * 1024 * 1024 ) 
line 98464: # define SizeofArray ( X ) ( ( int ) ( sizeof ( X ) / sizeof ( X [ 0 ] ) ) ) 
line 98470: # define FTS3_VARINT_MAX 10 
line 98477: # ifndef SQLITE_AMALGAMATION 
line 98482: # define ALWAYS ( x ) ( x ) 
line 98483: # define NEVER ( X ) ( x ) 
line 98487: typedef unsigned char u8 ; 
line 98488: typedef short int i16 ; 
line 98489: typedef unsigned int u32 ; 
line 98490: typedef sqlite3_uint64 u64 ; 
line 98494: # define UNUSED_PARAMETER ( x ) ( void ) ( x ) 
line 98495: # endif 
line 98497: typedef struct Fts3Table Fts3Table ; 
line 98498: typedef struct Fts3Cursor Fts3Cursor ; 
line 98499: typedef struct Fts3Expr Fts3Expr ; 
line 98500: typedef struct Fts3Phrase Fts3Phrase ; 
line 98501: typedef struct Fts3SegReader Fts3SegReader ; 
line 98502: typedef struct Fts3SegFilter Fts3SegFilter ; 
line 98511: struct Fts3Table { 
line 98512: sqlite3_vtab base ; 
line 98513: sqlite3 * db ; 
line 98514: const char * zDb ; 
line 98515: const char * zName ; 
line 98516: int nColumn ; 
line 98517: char * * azColumn ; 
line 98518: sqlite3_tokenizer * pTokenizer ; 
line 98523: sqlite3_stmt * aStmt [ 18 ] ; 
line 98530: char * zSelectLeaves ; 
line 98531: int nLeavesStmt ; 
line 98532: int nLeavesTotal ; 
line 98533: int nLeavesAlloc ; 
line 98534: sqlite3_stmt * * aLeavesStmt ; 
line 98536: int nNodeSize ; 
line 98545: int nMaxPendingData ; 
line 98546: int nPendingData ; 
line 98547: sqlite_int64 iPrevDocid ; 
line 98548: Fts3Hash pendingTerms ; 
line 98549: } ; 
line 98556: struct Fts3Cursor { 
line 98557: sqlite3_vtab_cursor base ; 
line 98558: i16 eSearch ; 
line 98559: u8 isEof ; 
line 98560: u8 isRequireSeek ; 
line 98561: sqlite3_stmt * pStmt ; 
line 98562: Fts3Expr * pExpr ; 
line 98563: sqlite3_int64 iPrevId ; 
line 98564: char * pNextId ; 
line 98565: char * aDoclist ; 
line 98566: int nDoclist ; 
line 98567: int isMatchinfoOk ; 
line 98568: u32 * aMatchinfo ; 
line 98569: } ; 
line 98586: # define FTS3_FULLSCAN_SEARCH 0 
line 98587: # define FTS3_DOCID_SEARCH 1 
line 98588: # define FTS3_FULLTEXT_SEARCH 2 
line 98596: struct Fts3Phrase { 
line 98597: int nToken ; 
line 98598: int iColumn ; 
line 98599: int isNot ; 
line 98600: struct PhraseToken { 
line 98601: char * z ; 
line 98602: int n ; 
line 98603: int isPrefix ; 
line 98604: } aToken [ 1 ] ; 
line 98605: } ; 
line 98620: struct Fts3Expr { 
line 98621: int eType ; 
line 98622: int nNear ; 
line 98623: Fts3Expr * pParent ; 
line 98624: Fts3Expr * pLeft ; 
line 98625: Fts3Expr * pRight ; 
line 98626: Fts3Phrase * pPhrase ; 
line 98628: int isLoaded ; 
line 98629: char * aDoclist ; 
line 98630: int nDoclist ; 
line 98632: sqlite3_int64 iCurrent ; 
line 98633: char * pCurrent ; 
line 98634: } ; 
line 98647: # define FTSQUERY_NEAR 1 
line 98648: # define FTSQUERY_NOT 2 
line 98649: # define FTSQUERY_AND 3 
line 98650: # define FTSQUERY_OR 4 
line 98651: # define FTSQUERY_PHRASE 5 
line 98655: SQLITE_PRIVATE int sqlite3Fts3DeleteVtab ( int , sqlite3_vtab * ) ; 
line 98656: SQLITE_PRIVATE int sqlite3Fts3InitVtab ( int , sqlite3 * , void * , int , const char * const * , 
line 98657: sqlite3_vtab * * , char * * ) ; 
line 98660: SQLITE_PRIVATE int sqlite3Fts3UpdateMethod ( sqlite3_vtab * , int , sqlite3_value * * , sqlite3_int64 * ) ; 
line 98661: SQLITE_PRIVATE int sqlite3Fts3PendingTermsFlush ( Fts3Table * ) ; 
line 98662: SQLITE_PRIVATE void sqlite3Fts3PendingTermsClear ( Fts3Table * ) ; 
line 98663: SQLITE_PRIVATE int sqlite3Fts3Optimize ( Fts3Table * ) ; 
line 98664: SQLITE_PRIVATE int sqlite3Fts3SegReaderNew ( Fts3Table * , int , sqlite3_int64 , 
line 98665: sqlite3_int64 , sqlite3_int64 , const char * , int , Fts3SegReader * * ) ; 
line 98666: SQLITE_PRIVATE int sqlite3Fts3SegReaderPending ( Fts3Table * , const char * , int , int , Fts3SegReader * * ) ; 
line 98667: SQLITE_PRIVATE void sqlite3Fts3SegReaderFree ( Fts3Table * , Fts3SegReader * ) ; 
line 98668: SQLITE_PRIVATE int sqlite3Fts3SegReaderIterate ( 
line 98669: Fts3Table * , Fts3SegReader * * , int , Fts3SegFilter * , 
line 98670: int ( * ) ( Fts3Table * , void * , char * , int , char * , int ) , void * 
line 98671: ) ; 
line 98672: SQLITE_PRIVATE int sqlite3Fts3ReadBlock ( Fts3Table * , sqlite3_int64 , char const * * , int * ) ; 
line 98673: SQLITE_PRIVATE int sqlite3Fts3AllSegdirs ( Fts3Table * , sqlite3_stmt * * ) ; 
line 98676: # define FTS3_SEGMENT_REQUIRE_POS 0x00000001 
line 98677: # define FTS3_SEGMENT_IGNORE_EMPTY 0x00000002 
line 98678: # define FTS3_SEGMENT_COLUMN_FILTER 0x00000004 
line 98679: # define FTS3_SEGMENT_PREFIX 0x00000008 
line 98682: struct Fts3SegFilter { 
line 98683: const char * zTerm ; 
line 98684: int nTerm ; 
line 98685: int iCol ; 
line 98686: int flags ; 
line 98687: } ; 
line 98690: SQLITE_PRIVATE int sqlite3Fts3PutVarint ( char * , sqlite3_int64 ) ; 
line 98691: SQLITE_PRIVATE int sqlite3Fts3GetVarint ( const char * , sqlite_int64 * ) ; 
line 98692: SQLITE_PRIVATE int sqlite3Fts3GetVarint32 ( const char * , int * ) ; 
line 98693: SQLITE_PRIVATE int sqlite3Fts3VarintLen ( sqlite3_uint64 ) ; 
line 98694: SQLITE_PRIVATE void sqlite3Fts3Dequote ( char * ) ; 
line 98696: SQLITE_PRIVATE char * sqlite3Fts3FindPositions ( Fts3Expr * , sqlite3_int64 , int ) ; 
line 98697: SQLITE_PRIVATE int sqlite3Fts3ExprLoadDoclist ( Fts3Table * , Fts3Expr * ) ; 
line 98700: SQLITE_PRIVATE const char * sqlite3Fts3NextToken ( const char * , int * ) ; 
line 98701: SQLITE_PRIVATE int sqlite3Fts3InitHashTable ( sqlite3 * , Fts3Hash * , const char * ) ; 
line 98702: SQLITE_PRIVATE int sqlite3Fts3InitTokenizer ( Fts3Hash * pHash , 
line 98703: const char * , sqlite3_tokenizer * * , const char * * , char * * 
line 98704: ) ; 
line 98707: SQLITE_PRIVATE void sqlite3Fts3Offsets ( sqlite3_context * , Fts3Cursor * ) ; 
line 98708: SQLITE_PRIVATE void sqlite3Fts3Snippet ( sqlite3_context * , Fts3Cursor * , 
line 98709: const char * , const char * , const char * 
line 98710: ) ; 
line 98711: SQLITE_PRIVATE void sqlite3Fts3Snippet2 ( sqlite3_context * , Fts3Cursor * , const char * , 
line 98712: const char * , const char * , int , int 
line 98713: ) ; 
line 98714: SQLITE_PRIVATE void sqlite3Fts3Matchinfo ( sqlite3_context * , Fts3Cursor * ) ; 
line 98717: SQLITE_PRIVATE int sqlite3Fts3ExprParse ( sqlite3_tokenizer * , 
line 98718: char * * , int , int , const char * , int , Fts3Expr * * 
line 98719: ) ; 
line 98720: SQLITE_PRIVATE void sqlite3Fts3ExprFree ( Fts3Expr * ) ; 
line 98721: # ifdef SQLITE_TEST 
line 98722: SQLITE_PRIVATE int sqlite3Fts3ExprInitTestInterface ( sqlite3 * db ) ; 
line 98723: # endif 
line 98725: # endif 
line 98731: # ifndef SQLITE_CORE 
line 98732: SQLITE_EXTENSION_INIT1 
line 98733: # endif 
line 98740: SQLITE_PRIVATE int sqlite3Fts3PutVarint ( char * p , sqlite_int64 v ) { 
line 98741: unsigned char * q = ( unsigned char * ) p ; 
line 98742: sqlite_uint64 vu = v ; 
line 98743: do { 
line 98744: * q ++ = ( unsigned char ) ( ( vu & 0x7f ) | 0x80 ) ; 
line 98745: vu >>= 7 ; 
line 98746: } while ( vu != 0 ) ; 
line 98747: q [ - 1 ] &= 0x7f ; 
line 98748: assert ( q - ( unsigned char * ) p <= FTS3_VARINT_MAX ) ; 
line 98749: return ( int ) ( q - ( unsigned char * ) p ) ; 
line 98750: } 
line 98757: SQLITE_PRIVATE int sqlite3Fts3GetVarint ( const char * p , sqlite_int64 * v ) { 
line 98758: const unsigned char * q = ( const unsigned char * ) p ; 
line 98759: sqlite_uint64 x = 0 , y = 1 ; 
line 98760: while ( ( * q & 0x80 ) == 0x80 && q - ( unsigned char * ) p < FTS3_VARINT_MAX ) { 
line 98761: x += y * ( * q ++ & 0x7f ) ; 
line 98762: y <<= 7 ; 
line 98763: } 
line 98764: x += y * ( * q ++ ) ; 
line 98765: * v = ( sqlite_int64 ) x ; 
line 98766: return ( int ) ( q - ( unsigned char * ) p ) ; 
line 98767: } 
line 98773: SQLITE_PRIVATE int sqlite3Fts3GetVarint32 ( const char * p , int * pi ) { 
line 98774: sqlite_int64 i ; 
line 98775: int ret = sqlite3Fts3GetVarint ( p , & i ) ; 
line 98776: * pi = ( int ) i ; 
line 98777: return ret ; 
line 98778: } 
line 98784: SQLITE_PRIVATE int sqlite3Fts3VarintLen ( sqlite3_uint64 v ) { 
line 98785: int i = 0 ; 
line 98786: do { 
line 98787: i ++ ; 
line 98788: v >>= 7 ; 
line 98789: } while ( v != 0 ) ; 
line 98790: return i ; 
line 98791: } 
line 98807: SQLITE_PRIVATE void sqlite3Fts3Dequote ( char * z ) { 
line 98808: char quote ; 
line 98810: quote = z [ 0 ] ; 
line 98811: if ( quote == '[' || quote == '\'' || quote == '"' || quote == '`' ) { 
line 98812: int iIn = 1 ; 
line 98813: int iOut = 0 ; 
line 98816: if ( quote == '[' ) quote = ']' ; 
line 98818: while ( ALWAYS ( z [ iIn ] ) ) { 
line 98819: if ( z [ iIn ] == quote ) { 
line 98820: if ( z [ iIn + 1 ] != quote ) break ; 
line 98821: z [ iOut ++ ] = quote ; 
line 98822: iIn += 2 ; 
line 98823: } else { 
line 98824: z [ iOut ++ ] = z [ iIn ++ ] ; 
line 98825: } 
line 98826: } 
line 98827: z [ iOut ] = '\0' ; 
line 98828: } 
line 98829: } 
line 98831: static void fts3GetDeltaVarint ( char * * pp , sqlite3_int64 * pVal ) { 
line 98832: sqlite3_int64 iVal ; 
line 98833: * pp += sqlite3Fts3GetVarint ( * pp , & iVal ) ; 
line 98834: * pVal += iVal ; 
line 98835: } 
line 98837: static void fts3GetDeltaVarint2 ( char * * pp , char * pEnd , sqlite3_int64 * pVal ) { 
line 98838: if ( * pp >= pEnd ) { 
line 98839: * pp = 0 ; 
line 98840: } else { 
line 98841: fts3GetDeltaVarint ( pp , pVal ) ; 
line 98842: } 
line 98843: } 
line 98848: static int fts3DisconnectMethod ( sqlite3_vtab * pVtab ) { 
line 98849: Fts3Table * p = ( Fts3Table * ) pVtab ; 
line 98850: int i ; 
line 98852: assert ( p -> nPendingData == 0 ) ; 
line 98855: for ( i = 0 ; i < SizeofArray ( p -> aStmt ) ; i ++ ) { 
line 98856: sqlite3_finalize ( p -> aStmt [ i ] ) ; 
line 98857: } 
line 98858: for ( i = 0 ; i < p -> nLeavesStmt ; i ++ ) { 
line 98859: sqlite3_finalize ( p -> aLeavesStmt [ i ] ) ; 
line 98860: } 
line 98861: sqlite3_free ( p -> zSelectLeaves ) ; 
line 98862: sqlite3_free ( p -> aLeavesStmt ) ; 
line 98865: p -> pTokenizer -> pModule -> xDestroy ( p -> pTokenizer ) ; 
line 98867: sqlite3_free ( p ) ; 
line 98868: return SQLITE_OK ; 
line 98869: } 
line 98874: static int fts3DestroyMethod ( sqlite3_vtab * pVtab ) { 
line 98875: int rc ; 
line 98876: Fts3Table * p = ( Fts3Table * ) pVtab ; 
line 98879: char * zSql = sqlite3_mprintf ( 
line 98880: "DROP TABLE IF EXISTS %Q.'%q_content';" 
line 98881: "DROP TABLE IF EXISTS %Q.'%q_segments';" 
line 98882: "DROP TABLE IF EXISTS %Q.'%q_segdir';" , 
line 98883: p -> zDb , p -> zName , p -> zDb , p -> zName , p -> zDb , p -> zName 
line 98884: ) ; 
line 98889: if ( zSql ) { 
line 98890: rc = sqlite3_exec ( p -> db , zSql , 0 , 0 , 0 ) ; 
line 98891: sqlite3_free ( zSql ) ; 
line 98892: } else { 
line 98893: rc = SQLITE_NOMEM ; 
line 98894: } 
line 98900: return ( rc == SQLITE_OK ? fts3DisconnectMethod ( pVtab ) : rc ) ; 
line 98901: } 
line 98909: static int fts3DeclareVtab ( Fts3Table * p ) { 
line 98910: int i ; 
line 98911: int rc ; 
line 98912: char * zSql ; 
line 98913: char * zCols ; 
line 98916: zCols = sqlite3_mprintf ( "%Q, " , p -> azColumn [ 0 ] ) ; 
line 98917: for ( i = 1 ; zCols && i < p -> nColumn ; i ++ ) { 
line 98918: zCols = sqlite3_mprintf ( "%z%Q, " , zCols , p -> azColumn [ i ] ) ; 
line 98919: } 
line 98922: zSql = sqlite3_mprintf ( 
line 98923: "CREATE TABLE x(%s %Q HIDDEN, docid HIDDEN)" , zCols , p -> zName 
line 98924: ) ; 
line 98926: if ( ! zCols || ! zSql ) { 
line 98927: rc = SQLITE_NOMEM ; 
line 98928: } else { 
line 98929: rc = sqlite3_declare_vtab ( p -> db , zSql ) ; 
line 98930: } 
line 98932: sqlite3_free ( zSql ) ; 
line 98933: sqlite3_free ( zCols ) ; 
line 98934: return rc ; 
line 98935: } 
line 98942: static int fts3CreateTables ( Fts3Table * p ) { 
line 98943: int rc ; 
line 98944: int i ; 
line 98945: char * zContentCols ; 
line 98946: char * zSql ; 
line 98949: zContentCols = sqlite3_mprintf ( "docid INTEGER PRIMARY KEY" ) ; 
line 98950: for ( i = 0 ; zContentCols && i < p -> nColumn ; i ++ ) { 
line 98951: char * z = p -> azColumn [ i ] ; 
line 98952: zContentCols = sqlite3_mprintf ( "%z, 'c%d%q'" , zContentCols , i , z ) ; 
line 98953: } 
line 98956: zSql = sqlite3_mprintf ( 
line 98957: "CREATE TABLE %Q.'%q_content'(%s);" 
line 98958: "CREATE TABLE %Q.'%q_segments'(blockid INTEGER PRIMARY KEY, block BLOB);" 
line 98959: "CREATE TABLE %Q.'%q_segdir'(" 
line 98960: "level INTEGER," 
line 98961: "idx INTEGER," 
line 98962: "start_block INTEGER," 
line 98963: "leaves_end_block INTEGER," 
line 98964: "end_block INTEGER," 
line 98965: "root BLOB," 
line 98966: "PRIMARY KEY(level, idx)" 
line 98967: ");" , 
line 98968: p -> zDb , p -> zName , zContentCols , p -> zDb , p -> zName , p -> zDb , p -> zName 
line 98969: ) ; 
line 98974: if ( zContentCols == 0 || zSql == 0 ) { 
line 98975: rc = SQLITE_NOMEM ; 
line 98976: } else { 
line 98977: rc = sqlite3_exec ( p -> db , zSql , 0 , 0 , 0 ) ; 
line 98978: } 
line 98980: sqlite3_free ( zSql ) ; 
line 98981: sqlite3_free ( zContentCols ) ; 
line 98982: return rc ; 
line 98983: } 
line 98996: static int fts3InitVtab ( 
line 98997: int isCreate , 
line 98998: sqlite3 * db , 
line 98999: void * pAux , 
line 99000: int argc , 
line 99001: const char * const * argv , 
line 99002: sqlite3_vtab * * ppVTab , 
line 99003: char * * pzErr 
line 99004: ) { 
line 99005: Fts3Hash * pHash = ( Fts3Hash * ) pAux ; 
line 99006: Fts3Table * p ; 
line 99007: int rc ; 
line 99008: int i ; 
line 99009: int nByte ; 
line 99010: int iCol ; 
line 99011: int nString = 0 ; 
line 99012: int nCol = 0 ; 
line 99013: char * zCsr ; 
line 99014: int nDb ; 
line 99015: int nName ; 
line 99017: const char * zTokenizer = 0 ; 
line 99018: sqlite3_tokenizer * pTokenizer = 0 ; 
line 99020: nDb = ( int ) strlen ( argv [ 1 ] ) + 1 ; 
line 99021: nName = ( int ) strlen ( argv [ 2 ] ) + 1 ; 
line 99022: for ( i = 3 ; i < argc ; i ++ ) { 
line 99023: char const * z = argv [ i ] ; 
line 99024: rc = sqlite3Fts3InitTokenizer ( pHash , z , & pTokenizer , & zTokenizer , pzErr ) ; 
line 99025: if ( rc != SQLITE_OK ) { 
line 99026: return rc ; 
line 99027: } 
line 99028: if ( z != zTokenizer ) { 
line 99029: nString += ( int ) ( strlen ( z ) + 1 ) ; 
line 99030: } 
line 99031: } 
line 99032: nCol = argc - 3 - ( zTokenizer != 0 ) ; 
line 99033: if ( zTokenizer == 0 ) { 
line 99034: rc = sqlite3Fts3InitTokenizer ( pHash , 0 , & pTokenizer , 0 , pzErr ) ; 
line 99035: if ( rc != SQLITE_OK ) { 
line 99036: return rc ; 
line 99037: } 
line 99038: assert ( pTokenizer ) ; 
line 99039: } 
line 99041: if ( nCol == 0 ) { 
line 99042: nCol = 1 ; 
line 99043: } 
line 99046: nByte = sizeof ( Fts3Table ) + 
line 99047: nCol * sizeof ( char * ) + 
line 99048: nName + 
line 99049: nDb + 
line 99050: nString ; 
line 99051: p = ( Fts3Table * ) sqlite3_malloc ( nByte ) ; 
line 99052: if ( p == 0 ) { 
line 99053: rc = SQLITE_NOMEM ; 
line 99054: goto fts3_init_out ; 
line 99055: } 
line 99056: memset ( p , 0 , nByte ) ; 
line 99058: p -> db = db ; 
line 99059: p -> nColumn = nCol ; 
line 99060: p -> nPendingData = 0 ; 
line 99061: p -> azColumn = ( char * * ) & p [ 1 ] ; 
line 99062: p -> pTokenizer = pTokenizer ; 
line 99063: p -> nNodeSize = 1000 ; 
line 99064: p -> nMaxPendingData = FTS3_MAX_PENDING_DATA ; 
line 99065: zCsr = ( char * ) & p -> azColumn [ nCol ] ; 
line 99067: fts3HashInit ( & p -> pendingTerms , FTS3_HASH_STRING , 1 ) ; 
line 99070: p -> zName = zCsr ; 
line 99071: memcpy ( zCsr , argv [ 2 ] , nName ) ; 
line 99072: zCsr += nName ; 
line 99073: p -> zDb = zCsr ; 
line 99074: memcpy ( zCsr , argv [ 1 ] , nDb ) ; 
line 99075: zCsr += nDb ; 
line 99078: iCol = 0 ; 
line 99079: for ( i = 3 ; i < argc ; i ++ ) { 
line 99080: if ( argv [ i ] != zTokenizer ) { 
line 99081: char * z ; 
line 99082: int n ; 
line 99083: z = ( char * ) sqlite3Fts3NextToken ( argv [ i ] , & n ) ; 
line 99084: memcpy ( zCsr , z , n ) ; 
line 99085: zCsr [ n ] = '\0' ; 
line 99086: sqlite3Fts3Dequote ( zCsr ) ; 
line 99087: p -> azColumn [ iCol ++ ] = zCsr ; 
line 99088: zCsr += n + 1 ; 
line 99089: assert ( zCsr <= & ( ( char * ) p ) [ nByte ] ) ; 
line 99090: } 
line 99091: } 
line 99092: if ( iCol == 0 ) { 
line 99093: assert ( nCol == 1 ) ; 
line 99094: p -> azColumn [ 0 ] = "content" ; 
line 99095: } 
line 99100: if ( isCreate ) { 
line 99101: rc = fts3CreateTables ( p ) ; 
line 99102: if ( rc != SQLITE_OK ) goto fts3_init_out ; 
line 99103: } 
line 99105: rc = fts3DeclareVtab ( p ) ; 
line 99106: if ( rc != SQLITE_OK ) goto fts3_init_out ; 
line 99108: * ppVTab = & p -> base ; 
line 99110: fts3_init_out : 
line 99111: assert ( p || ( pTokenizer && rc != SQLITE_OK ) ) ; 
line 99112: if ( rc != SQLITE_OK ) { 
line 99113: if ( p ) { 
line 99114: fts3DisconnectMethod ( ( sqlite3_vtab * ) p ) ; 
line 99115: } else { 
line 99116: pTokenizer -> pModule -> xDestroy ( pTokenizer ) ; 
line 99117: } 
line 99118: } 
line 99119: return rc ; 
line 99120: } 
line 99126: static int fts3ConnectMethod ( 
line 99127: sqlite3 * db , 
line 99128: void * pAux , 
line 99129: int argc , 
line 99130: const char * const * argv , 
line 99131: sqlite3_vtab * * ppVtab , 
line 99132: char * * pzErr 
line 99133: ) { 
line 99134: return fts3InitVtab ( 0 , db , pAux , argc , argv , ppVtab , pzErr ) ; 
line 99135: } 
line 99136: static int fts3CreateMethod ( 
line 99137: sqlite3 * db , 
line 99138: void * pAux , 
line 99139: int argc , 
line 99140: const char * const * argv , 
line 99141: sqlite3_vtab * * ppVtab , 
line 99142: char * * pzErr 
line 99143: ) { 
line 99144: return fts3InitVtab ( 1 , db , pAux , argc , argv , ppVtab , pzErr ) ; 
line 99145: } 
line 99155: static int fts3BestIndexMethod ( sqlite3_vtab * pVTab , sqlite3_index_info * pInfo ) { 
line 99156: Fts3Table * p = ( Fts3Table * ) pVTab ; 
line 99157: int i ; 
line 99158: int iCons = - 1 ; 
line 99164: pInfo -> idxNum = FTS3_FULLSCAN_SEARCH ; 
line 99165: pInfo -> estimatedCost = 500000 ; 
line 99166: for ( i = 0 ; i < pInfo -> nConstraint ; i ++ ) { 
line 99167: struct sqlite3_index_constraint * pCons = & pInfo -> aConstraint [ i ] ; 
line 99168: if ( pCons -> usable == 0 ) continue ; 
line 99171: if ( pCons -> op == SQLITE_INDEX_CONSTRAINT_EQ 
line 99172: && ( pCons -> iColumn < 0 || pCons -> iColumn == p -> nColumn + 1 ) 
line 99173: ) { 
line 99174: pInfo -> idxNum = FTS3_DOCID_SEARCH ; 
line 99175: pInfo -> estimatedCost = 1.0 ; 
line 99176: iCons = i ; 
line 99177: } 
line 99188: if ( pCons -> op == SQLITE_INDEX_CONSTRAINT_MATCH 
line 99189: && pCons -> iColumn >= 0 && pCons -> iColumn <= p -> nColumn 
line 99190: ) { 
line 99191: pInfo -> idxNum = FTS3_FULLTEXT_SEARCH + pCons -> iColumn ; 
line 99192: pInfo -> estimatedCost = 2.0 ; 
line 99193: iCons = i ; 
line 99194: break ; 
line 99195: } 
line 99196: } 
line 99198: if ( iCons >= 0 ) { 
line 99199: pInfo -> aConstraintUsage [ iCons ] . argvIndex = 1 ; 
line 99200: pInfo -> aConstraintUsage [ iCons ] . omit = 1 ; 
line 99201: } 
line 99202: return SQLITE_OK ; 
line 99203: } 
line 99208: static int fts3OpenMethod ( sqlite3_vtab * pVTab , sqlite3_vtab_cursor * * ppCsr ) { 
line 99209: sqlite3_vtab_cursor * pCsr ; 
line 99211: UNUSED_PARAMETER ( pVTab ) ; 
line 99217: * ppCsr = pCsr = ( sqlite3_vtab_cursor * ) sqlite3_malloc ( sizeof ( Fts3Cursor ) ) ; 
line 99218: if ( ! pCsr ) { 
line 99219: return SQLITE_NOMEM ; 
line 99220: } 
line 99221: memset ( pCsr , 0 , sizeof ( Fts3Cursor ) ) ; 
line 99222: return SQLITE_OK ; 
line 99223: } 
line 99235: static int fulltextClose ( sqlite3_vtab_cursor * pCursor ) { 
line 99236: Fts3Cursor * pCsr = ( Fts3Cursor * ) pCursor ; 
line 99237: sqlite3_finalize ( pCsr -> pStmt ) ; 
line 99238: sqlite3Fts3ExprFree ( pCsr -> pExpr ) ; 
line 99239: sqlite3_free ( pCsr -> aDoclist ) ; 
line 99240: sqlite3_free ( pCsr -> aMatchinfo ) ; 
line 99241: sqlite3_free ( pCsr ) ; 
line 99242: return SQLITE_OK ; 
line 99243: } 
line 99245: static int fts3CursorSeek ( sqlite3_context * pContext , Fts3Cursor * pCsr ) { 
line 99246: if ( pCsr -> isRequireSeek ) { 
line 99247: pCsr -> isRequireSeek = 0 ; 
line 99248: sqlite3_bind_int64 ( pCsr -> pStmt , 1 , pCsr -> iPrevId ) ; 
line 99249: if ( SQLITE_ROW == sqlite3_step ( pCsr -> pStmt ) ) { 
line 99250: return SQLITE_OK ; 
line 99251: } else { 
line 99252: int rc = sqlite3_reset ( pCsr -> pStmt ) ; 
line 99253: if ( rc == SQLITE_OK ) { 
line 99258: rc = SQLITE_CORRUPT ; 
line 99259: } 
line 99260: pCsr -> isEof = 1 ; 
line 99261: if ( pContext ) { 
line 99262: sqlite3_result_error_code ( pContext , rc ) ; 
line 99263: } 
line 99264: return rc ; 
line 99265: } 
line 99266: } else { 
line 99267: return SQLITE_OK ; 
line 99268: } 
line 99269: } 
line 99271: static int fts3NextMethod ( sqlite3_vtab_cursor * pCursor ) { 
line 99272: int rc = SQLITE_OK ; 
line 99273: Fts3Cursor * pCsr = ( Fts3Cursor * ) pCursor ; 
line 99275: if ( pCsr -> aDoclist == 0 ) { 
line 99276: if ( SQLITE_ROW != sqlite3_step ( pCsr -> pStmt ) ) { 
line 99277: pCsr -> isEof = 1 ; 
line 99278: rc = sqlite3_reset ( pCsr -> pStmt ) ; 
line 99279: } 
line 99280: } else if ( pCsr -> pNextId >= & pCsr -> aDoclist [ pCsr -> nDoclist ] ) { 
line 99281: pCsr -> isEof = 1 ; 
line 99282: } else { 
line 99283: sqlite3_reset ( pCsr -> pStmt ) ; 
line 99284: fts3GetDeltaVarint ( & pCsr -> pNextId , & pCsr -> iPrevId ) ; 
line 99285: pCsr -> isRequireSeek = 1 ; 
line 99286: pCsr -> isMatchinfoOk = 1 ; 
line 99287: } 
line 99288: return rc ; 
line 99289: } 
line 99308: static int fts3SelectLeaf ( 
line 99309: Fts3Table * p , 
line 99310: const char * zTerm , 
line 99311: int nTerm , 
line 99312: const char * zNode , 
line 99313: int nNode , 
line 99314: sqlite3_int64 * piLeaf 
line 99315: ) { 
line 99316: int rc = SQLITE_OK ; 
line 99317: const char * zCsr = zNode ; 
line 99318: const char * zEnd = & zCsr [ nNode ] ; 
line 99319: char * zBuffer = 0 ; 
line 99320: int nAlloc = 0 ; 
line 99322: while ( 1 ) { 
line 99323: int isFirstTerm = 1 ; 
line 99324: int iHeight ; 
line 99325: sqlite3_int64 iChild ; 
line 99326: int nBlock ; 
line 99328: zCsr += sqlite3Fts3GetVarint32 ( zCsr , & iHeight ) ; 
line 99329: zCsr += sqlite3Fts3GetVarint ( zCsr , & iChild ) ; 
line 99331: while ( zCsr < zEnd ) { 
line 99332: int cmp ; 
line 99333: int nSuffix ; 
line 99334: int nPrefix = 0 ; 
line 99335: int nBuffer ; 
line 99338: if ( ! isFirstTerm ) { 
line 99339: zCsr += sqlite3Fts3GetVarint32 ( zCsr , & nPrefix ) ; 
line 99340: } 
line 99341: isFirstTerm = 0 ; 
line 99342: zCsr += sqlite3Fts3GetVarint32 ( zCsr , & nSuffix ) ; 
line 99343: if ( nPrefix + nSuffix > nAlloc ) { 
line 99344: char * zNew ; 
line 99345: nAlloc = ( nPrefix + nSuffix ) * 2 ; 
line 99346: zNew = ( char * ) sqlite3_realloc ( zBuffer , nAlloc ) ; 
line 99347: if ( ! zNew ) { 
line 99348: sqlite3_free ( zBuffer ) ; 
line 99349: return SQLITE_NOMEM ; 
line 99350: } 
line 99351: zBuffer = zNew ; 
line 99352: } 
line 99353: memcpy ( & zBuffer [ nPrefix ] , zCsr , nSuffix ) ; 
line 99354: nBuffer = nPrefix + nSuffix ; 
line 99355: zCsr += nSuffix ; 
line 99366: cmp = memcmp ( zTerm , zBuffer , ( nBuffer > nTerm ? nTerm : nBuffer ) ) ; 
line 99367: if ( cmp < 0 || ( cmp == 0 && nBuffer > nTerm ) ) break ; 
line 99368: iChild ++ ; 
line 99369: } ; 
line 99374: if ( iHeight == 1 ) { 
line 99375: * piLeaf = iChild ; 
line 99376: break ; 
line 99377: } 
line 99380: rc = sqlite3Fts3ReadBlock ( p , iChild , & zCsr , & nBlock ) ; 
line 99381: if ( rc != SQLITE_OK ) break ; 
line 99382: zEnd = & zCsr [ nBlock ] ; 
line 99383: } 
line 99384: sqlite3_free ( zBuffer ) ; 
line 99385: return rc ; 
line 99386: } 
line 99392: static void fts3PutDeltaVarint ( 
line 99393: char * * pp , 
line 99394: sqlite3_int64 * piPrev , 
line 99395: sqlite3_int64 iVal 
line 99396: ) { 
line 99397: assert ( iVal - * piPrev > 0 || ( * piPrev == 0 && iVal == 0 ) ) ; 
line 99398: * pp += sqlite3Fts3PutVarint ( * pp , iVal - * piPrev ) ; 
line 99399: * piPrev = iVal ; 
line 99400: } 
line 99406: static void fts3PoslistCopy ( char * * pp , char * * ppPoslist ) { 
line 99407: char * pEnd = * ppPoslist ; 
line 99408: char c = 0 ; 
line 99420: while ( * pEnd | c ) c = * pEnd ++ & 0x80 ; 
line 99421: pEnd ++ ; 
line 99423: if ( pp ) { 
line 99424: int n = ( int ) ( pEnd - * ppPoslist ) ; 
line 99425: char * p = * pp ; 
line 99426: memcpy ( p , * ppPoslist , n ) ; 
line 99427: p += n ; 
line 99428: * pp = p ; 
line 99429: } 
line 99430: * ppPoslist = pEnd ; 
line 99431: } 
line 99433: static void fts3ColumnlistCopy ( char * * pp , char * * ppPoslist ) { 
line 99434: char * pEnd = * ppPoslist ; 
line 99435: char c = 0 ; 
line 99438: while ( 0xFE & ( * pEnd | c ) ) c = * pEnd ++ & 0x80 ; 
line 99439: if ( pp ) { 
line 99440: int n = ( int ) ( pEnd - * ppPoslist ) ; 
line 99441: char * p = * pp ; 
line 99442: memcpy ( p , * ppPoslist , n ) ; 
line 99443: p += n ; 
line 99444: * pp = p ; 
line 99445: } 
line 99446: * ppPoslist = pEnd ; 
line 99447: } 
line 99453: # define OFFSET_LIST_END 0x7fffffff 
line 99466: static void fts3ReadNextPos ( 
line 99467: char * * pp , 
line 99468: sqlite3_int64 * pi 
line 99469: ) { 
line 99470: if ( * * pp & 0xFE ) { 
line 99471: fts3GetDeltaVarint ( pp , pi ) ; 
line 99472: * pi -= 2 ; 
line 99473: } else { 
line 99474: * pi = OFFSET_LIST_END ; 
line 99475: } 
line 99476: } 
line 99486: static int fts3PutColNumber ( char * * pp , int iCol ) { 
line 99487: int n = 0 ; 
line 99488: if ( iCol ) { 
line 99489: char * p = * pp ; 
line 99490: n = 1 + sqlite3Fts3PutVarint ( & p [ 1 ] , iCol ) ; 
line 99491: * p = 0x01 ; 
line 99492: * pp = & p [ n ] ; 
line 99493: } 
line 99494: return n ; 
line 99495: } 
line 99500: static void fts3PoslistMerge ( 
line 99501: char * * pp , 
line 99502: char * * pp1 , 
line 99503: char * * pp2 
line 99504: ) { 
line 99505: char * p = * pp ; 
line 99506: char * p1 = * pp1 ; 
line 99507: char * p2 = * pp2 ; 
line 99509: while ( * p1 || * p2 ) { 
line 99510: int iCol1 ; 
line 99511: int iCol2 ; 
line 99513: if ( * p1 == 0x01 ) sqlite3Fts3GetVarint32 ( & p1 [ 1 ] , & iCol1 ) ; 
line 99514: else if ( * p1 == 0x00 ) iCol1 = OFFSET_LIST_END ; 
line 99515: else iCol1 = 0 ; 
line 99517: if ( * p2 == 0x01 ) sqlite3Fts3GetVarint32 ( & p2 [ 1 ] , & iCol2 ) ; 
line 99518: else if ( * p2 == 0x00 ) iCol2 = OFFSET_LIST_END ; 
line 99519: else iCol2 = 0 ; 
line 99521: if ( iCol1 == iCol2 ) { 
line 99522: sqlite3_int64 i1 = 0 ; 
line 99523: sqlite3_int64 i2 = 0 ; 
line 99524: sqlite3_int64 iPrev = 0 ; 
line 99525: int n = fts3PutColNumber ( & p , iCol1 ) ; 
line 99526: p1 += n ; 
line 99527: p2 += n ; 
line 99537: fts3GetDeltaVarint ( & p1 , & i1 ) ; 
line 99538: fts3GetDeltaVarint ( & p2 , & i2 ) ; 
line 99539: do { 
line 99540: fts3PutDeltaVarint ( & p , & iPrev , ( i1 < i2 ) ? i1 : i2 ) ; 
line 99541: iPrev -= 2 ; 
line 99542: if ( i1 == i2 ) { 
line 99543: fts3ReadNextPos ( & p1 , & i1 ) ; 
line 99544: fts3ReadNextPos ( & p2 , & i2 ) ; 
line 99545: } else if ( i1 < i2 ) { 
line 99546: fts3ReadNextPos ( & p1 , & i1 ) ; 
line 99547: } else { 
line 99548: fts3ReadNextPos ( & p2 , & i2 ) ; 
line 99549: } 
line 99550: } while ( i1 != OFFSET_LIST_END || i2 != OFFSET_LIST_END ) ; 
line 99551: } else if ( iCol1 < iCol2 ) { 
line 99552: p1 += fts3PutColNumber ( & p , iCol1 ) ; 
line 99553: fts3ColumnlistCopy ( & p , & p1 ) ; 
line 99554: } else { 
line 99555: p2 += fts3PutColNumber ( & p , iCol2 ) ; 
line 99556: fts3ColumnlistCopy ( & p , & p2 ) ; 
line 99557: } 
line 99558: } 
line 99560: * p ++ = '\0' ; 
line 99561: * pp = p ; 
line 99562: * pp1 = p1 + 1 ; 
line 99563: * pp2 = p2 + 1 ; 
line 99564: } 
line 99569: static int fts3PoslistPhraseMerge ( 
line 99570: char * * pp , 
line 99571: int nToken , 
line 99572: int isSaveLeft , 
line 99573: char * * pp1 , 
line 99574: char * * pp2 
line 99575: ) { 
line 99576: char * p = ( pp ? * pp : 0 ) ; 
line 99577: char * p1 = * pp1 ; 
line 99578: char * p2 = * pp2 ; 
line 99580: int iCol1 = 0 ; 
line 99581: int iCol2 = 0 ; 
line 99582: assert ( * p1 != 0 && * p2 != 0 ) ; 
line 99583: if ( * p1 == 0x01 ) { 
line 99584: p1 ++ ; 
line 99585: p1 += sqlite3Fts3GetVarint32 ( p1 , & iCol1 ) ; 
line 99586: } 
line 99587: if ( * p2 == 0x01 ) { 
line 99588: p2 ++ ; 
line 99589: p2 += sqlite3Fts3GetVarint32 ( p2 , & iCol2 ) ; 
line 99590: } 
line 99592: while ( 1 ) { 
line 99593: if ( iCol1 == iCol2 ) { 
line 99594: char * pSave = p ; 
line 99595: sqlite3_int64 iPrev = 0 ; 
line 99596: sqlite3_int64 iPos1 = 0 ; 
line 99597: sqlite3_int64 iPos2 = 0 ; 
line 99599: if ( pp && iCol1 ) { 
line 99600: * p ++ = 0x01 ; 
line 99601: p += sqlite3Fts3PutVarint ( p , iCol1 ) ; 
line 99602: } 
line 99604: assert ( * p1 != 0x00 && * p2 != 0x00 && * p1 != 0x01 && * p2 != 0x01 ) ; 
line 99605: fts3GetDeltaVarint ( & p1 , & iPos1 ) ; iPos1 -= 2 ; 
line 99606: fts3GetDeltaVarint ( & p2 , & iPos2 ) ; iPos2 -= 2 ; 
line 99608: while ( 1 ) { 
line 99609: if ( iPos2 > iPos1 && iPos2 <= iPos1 + nToken ) { 
line 99610: sqlite3_int64 iSave ; 
line 99611: if ( ! pp ) { 
line 99612: fts3PoslistCopy ( 0 , & p2 ) ; 
line 99613: fts3PoslistCopy ( 0 , & p1 ) ; 
line 99614: * pp1 = p1 ; 
line 99615: * pp2 = p2 ; 
line 99616: return 1 ; 
line 99617: } 
line 99618: iSave = isSaveLeft ? iPos1 : iPos2 ; 
line 99619: fts3PutDeltaVarint ( & p , & iPrev , iSave + 2 ) ; iPrev -= 2 ; 
line 99620: pSave = 0 ; 
line 99621: } 
line 99622: if ( ( ! isSaveLeft && iPos2 <= ( iPos1 + nToken ) ) || iPos2 <= iPos1 ) { 
line 99623: if ( ( * p2 & 0xFE ) == 0 ) break ; 
line 99624: fts3GetDeltaVarint ( & p2 , & iPos2 ) ; iPos2 -= 2 ; 
line 99625: } else { 
line 99626: if ( ( * p1 & 0xFE ) == 0 ) break ; 
line 99627: fts3GetDeltaVarint ( & p1 , & iPos1 ) ; iPos1 -= 2 ; 
line 99628: } 
line 99629: } 
line 99631: if ( pSave ) { 
line 99632: assert ( pp && p ) ; 
line 99633: p = pSave ; 
line 99634: } 
line 99636: fts3ColumnlistCopy ( 0 , & p1 ) ; 
line 99637: fts3ColumnlistCopy ( 0 , & p2 ) ; 
line 99638: assert ( ( * p1 & 0xFE ) == 0 && ( * p2 & 0xFE ) == 0 ) ; 
line 99639: if ( 0 == * p1 || 0 == * p2 ) break ; 
line 99641: p1 ++ ; 
line 99642: p1 += sqlite3Fts3GetVarint32 ( p1 , & iCol1 ) ; 
line 99643: p2 ++ ; 
line 99644: p2 += sqlite3Fts3GetVarint32 ( p2 , & iCol2 ) ; 
line 99645: } 
line 99652: else if ( iCol1 < iCol2 ) { 
line 99653: fts3ColumnlistCopy ( 0 , & p1 ) ; 
line 99654: if ( 0 == * p1 ) break ; 
line 99655: p1 ++ ; 
line 99656: p1 += sqlite3Fts3GetVarint32 ( p1 , & iCol1 ) ; 
line 99657: } else { 
line 99658: fts3ColumnlistCopy ( 0 , & p2 ) ; 
line 99659: if ( 0 == * p2 ) break ; 
line 99660: p2 ++ ; 
line 99661: p2 += sqlite3Fts3GetVarint32 ( p2 , & iCol2 ) ; 
line 99662: } 
line 99663: } 
line 99665: fts3PoslistCopy ( 0 , & p2 ) ; 
line 99666: fts3PoslistCopy ( 0 , & p1 ) ; 
line 99667: * pp1 = p1 ; 
line 99668: * pp2 = p2 ; 
line 99669: if ( ! pp || * pp == p ) { 
line 99670: return 0 ; 
line 99671: } 
line 99672: * p ++ = 0x00 ; 
line 99673: * pp = p ; 
line 99674: return 1 ; 
line 99675: } 
line 99680: static int fts3PoslistNearMerge ( 
line 99681: char * * pp , 
line 99682: char * aTmp , 
line 99683: int nRight , 
line 99684: int nLeft , 
line 99685: char * * pp1 , 
line 99686: char * * pp2 
line 99687: ) { 
line 99688: char * p1 = * pp1 ; 
line 99689: char * p2 = * pp2 ; 
line 99691: if ( ! pp ) { 
line 99692: if ( fts3PoslistPhraseMerge ( 0 , nRight , 0 , pp1 , pp2 ) ) return 1 ; 
line 99693: * pp1 = p1 ; 
line 99694: * pp2 = p2 ; 
line 99695: return fts3PoslistPhraseMerge ( 0 , nLeft , 0 , pp2 , pp1 ) ; 
line 99696: } else { 
line 99697: char * pTmp1 = aTmp ; 
line 99698: char * pTmp2 ; 
line 99699: char * aTmp2 ; 
line 99700: int res = 1 ; 
line 99702: fts3PoslistPhraseMerge ( & pTmp1 , nRight , 0 , pp1 , pp2 ) ; 
line 99703: aTmp2 = pTmp2 = pTmp1 ; 
line 99704: * pp1 = p1 ; 
line 99705: * pp2 = p2 ; 
line 99706: fts3PoslistPhraseMerge ( & pTmp2 , nLeft , 1 , pp2 , pp1 ) ; 
line 99707: if ( pTmp1 != aTmp && pTmp2 != aTmp2 ) { 
line 99708: fts3PoslistMerge ( pp , & aTmp , & aTmp2 ) ; 
line 99709: } else if ( pTmp1 != aTmp ) { 
line 99710: fts3PoslistCopy ( pp , & aTmp ) ; 
line 99711: } else if ( pTmp2 != aTmp2 ) { 
line 99712: fts3PoslistCopy ( pp , & aTmp2 ) ; 
line 99713: } else { 
line 99714: res = 0 ; 
line 99715: } 
line 99717: return res ; 
line 99718: } 
line 99719: } 
line 99724: # define MERGE_NOT 2 
line 99725: # define MERGE_AND 3 
line 99726: # define MERGE_OR 4 
line 99727: # define MERGE_POS_OR 5 
line 99728: # define MERGE_PHRASE 6 
line 99729: # define MERGE_POS_PHRASE 7 
line 99730: # define MERGE_NEAR 8 
line 99731: # define MERGE_POS_NEAR 9 
line 99743: static int fts3DoclistMerge ( 
line 99744: int mergetype , 
line 99745: int nParam1 , 
line 99746: int nParam2 , 
line 99747: char * aBuffer , 
line 99748: int * pnBuffer , 
line 99749: char * a1 , 
line 99750: int n1 , 
line 99751: char * a2 , 
line 99752: int n2 
line 99753: ) { 
line 99754: sqlite3_int64 i1 = 0 ; 
line 99755: sqlite3_int64 i2 = 0 ; 
line 99756: sqlite3_int64 iPrev = 0 ; 
line 99758: char * p = aBuffer ; 
line 99759: char * p1 = a1 ; 
line 99760: char * p2 = a2 ; 
line 99761: char * pEnd1 = & a1 [ n1 ] ; 
line 99762: char * pEnd2 = & a2 [ n2 ] ; 
line 99764: assert ( mergetype == MERGE_OR || mergetype == MERGE_POS_OR 
line 99765: || mergetype == MERGE_AND || mergetype == MERGE_NOT 
line 99766: || mergetype == MERGE_PHRASE || mergetype == MERGE_POS_PHRASE 
line 99767: || mergetype == MERGE_NEAR || mergetype == MERGE_POS_NEAR 
line 99768: ) ; 
line 99770: if ( ! aBuffer ) { 
line 99771: * pnBuffer = 0 ; 
line 99772: return SQLITE_NOMEM ; 
line 99773: } 
line 99776: fts3GetDeltaVarint2 ( & p1 , pEnd1 , & i1 ) ; 
line 99777: fts3GetDeltaVarint2 ( & p2 , pEnd2 , & i2 ) ; 
line 99779: switch ( mergetype ) { 
line 99780: case MERGE_OR : 
line 99781: case MERGE_POS_OR : 
line 99782: while ( p1 || p2 ) { 
line 99783: if ( p2 && p1 && i1 == i2 ) { 
line 99784: fts3PutDeltaVarint ( & p , & iPrev , i1 ) ; 
line 99785: if ( mergetype == MERGE_POS_OR ) fts3PoslistMerge ( & p , & p1 , & p2 ) ; 
line 99786: fts3GetDeltaVarint2 ( & p1 , pEnd1 , & i1 ) ; 
line 99787: fts3GetDeltaVarint2 ( & p2 , pEnd2 , & i2 ) ; 
line 99788: } else if ( ! p2 || ( p1 && i1 < i2 ) ) { 
line 99789: fts3PutDeltaVarint ( & p , & iPrev , i1 ) ; 
line 99790: if ( mergetype == MERGE_POS_OR ) fts3PoslistCopy ( & p , & p1 ) ; 
line 99791: fts3GetDeltaVarint2 ( & p1 , pEnd1 , & i1 ) ; 
line 99792: } else { 
line 99793: fts3PutDeltaVarint ( & p , & iPrev , i2 ) ; 
line 99794: if ( mergetype == MERGE_POS_OR ) fts3PoslistCopy ( & p , & p2 ) ; 
line 99795: fts3GetDeltaVarint2 ( & p2 , pEnd2 , & i2 ) ; 
line 99796: } 
line 99797: } 
line 99798: break ; 
line 99800: case MERGE_AND : 
line 99801: while ( p1 && p2 ) { 
line 99802: if ( i1 == i2 ) { 
line 99803: fts3PutDeltaVarint ( & p , & iPrev , i1 ) ; 
line 99804: fts3GetDeltaVarint2 ( & p1 , pEnd1 , & i1 ) ; 
line 99805: fts3GetDeltaVarint2 ( & p2 , pEnd2 , & i2 ) ; 
line 99806: } else if ( i1 < i2 ) { 
line 99807: fts3GetDeltaVarint2 ( & p1 , pEnd1 , & i1 ) ; 
line 99808: } else { 
line 99809: fts3GetDeltaVarint2 ( & p2 , pEnd2 , & i2 ) ; 
line 99810: } 
line 99811: } 
line 99812: break ; 
line 99814: case MERGE_NOT : 
line 99815: while ( p1 ) { 
line 99816: if ( p2 && i1 == i2 ) { 
line 99817: fts3GetDeltaVarint2 ( & p1 , pEnd1 , & i1 ) ; 
line 99818: fts3GetDeltaVarint2 ( & p2 , pEnd2 , & i2 ) ; 
line 99819: } else if ( ! p2 || i1 < i2 ) { 
line 99820: fts3PutDeltaVarint ( & p , & iPrev , i1 ) ; 
line 99821: fts3GetDeltaVarint2 ( & p1 , pEnd1 , & i1 ) ; 
line 99822: } else { 
line 99823: fts3GetDeltaVarint2 ( & p2 , pEnd2 , & i2 ) ; 
line 99824: } 
line 99825: } 
line 99826: break ; 
line 99828: case MERGE_POS_PHRASE : 
line 99829: case MERGE_PHRASE : { 
line 99830: char * * ppPos = ( mergetype == MERGE_PHRASE ? 0 : & p ) ; 
line 99831: while ( p1 && p2 ) { 
line 99832: if ( i1 == i2 ) { 
line 99833: char * pSave = p ; 
line 99834: sqlite3_int64 iPrevSave = iPrev ; 
line 99835: fts3PutDeltaVarint ( & p , & iPrev , i1 ) ; 
line 99836: if ( 0 == fts3PoslistPhraseMerge ( ppPos , 1 , 0 , & p1 , & p2 ) ) { 
line 99837: p = pSave ; 
line 99838: iPrev = iPrevSave ; 
line 99839: } 
line 99840: fts3GetDeltaVarint2 ( & p1 , pEnd1 , & i1 ) ; 
line 99841: fts3GetDeltaVarint2 ( & p2 , pEnd2 , & i2 ) ; 
line 99842: } else if ( i1 < i2 ) { 
line 99843: fts3PoslistCopy ( 0 , & p1 ) ; 
line 99844: fts3GetDeltaVarint2 ( & p1 , pEnd1 , & i1 ) ; 
line 99845: } else { 
line 99846: fts3PoslistCopy ( 0 , & p2 ) ; 
line 99847: fts3GetDeltaVarint2 ( & p2 , pEnd2 , & i2 ) ; 
line 99848: } 
line 99849: } 
line 99850: break ; 
line 99851: } 
line 99853: default : assert ( mergetype == MERGE_POS_NEAR || mergetype == MERGE_NEAR ) ; { 
line 99854: char * aTmp = 0 ; 
line 99855: char * * ppPos = 0 ; 
line 99856: if ( mergetype == MERGE_POS_NEAR ) { 
line 99857: ppPos = & p ; 
line 99858: aTmp = sqlite3_malloc ( 2 * ( n1 + n2 + 1 ) ) ; 
line 99859: if ( ! aTmp ) { 
line 99860: return SQLITE_NOMEM ; 
line 99861: } 
line 99862: } 
line 99864: while ( p1 && p2 ) { 
line 99865: if ( i1 == i2 ) { 
line 99866: char * pSave = p ; 
line 99867: sqlite3_int64 iPrevSave = iPrev ; 
line 99868: fts3PutDeltaVarint ( & p , & iPrev , i1 ) ; 
line 99870: if ( ! fts3PoslistNearMerge ( ppPos , aTmp , nParam1 , nParam2 , & p1 , & p2 ) ) { 
line 99871: iPrev = iPrevSave ; 
line 99872: p = pSave ; 
line 99873: } 
line 99875: fts3GetDeltaVarint2 ( & p1 , pEnd1 , & i1 ) ; 
line 99876: fts3GetDeltaVarint2 ( & p2 , pEnd2 , & i2 ) ; 
line 99877: } else if ( i1 < i2 ) { 
line 99878: fts3PoslistCopy ( 0 , & p1 ) ; 
line 99879: fts3GetDeltaVarint2 ( & p1 , pEnd1 , & i1 ) ; 
line 99880: } else { 
line 99881: fts3PoslistCopy ( 0 , & p2 ) ; 
line 99882: fts3GetDeltaVarint2 ( & p2 , pEnd2 , & i2 ) ; 
line 99883: } 
line 99884: } 
line 99885: sqlite3_free ( aTmp ) ; 
line 99886: break ; 
line 99887: } 
line 99888: } 
line 99890: * pnBuffer = ( int ) ( p - aBuffer ) ; 
line 99891: return SQLITE_OK ; 
line 99892: } 
line 99898: typedef struct TermSelect TermSelect ; 
line 99899: struct TermSelect { 
line 99900: int isReqPos ; 
line 99901: char * aOutput ; 
line 99902: int nOutput ; 
line 99903: } ; 
line 99910: static int fts3TermSelectCb ( 
line 99911: Fts3Table * p , 
line 99912: void * pContext , 
line 99913: char * zTerm , 
line 99914: int nTerm , 
line 99915: char * aDoclist , 
line 99916: int nDoclist 
line 99917: ) { 
line 99918: TermSelect * pTS = ( TermSelect * ) pContext ; 
line 99919: int nNew = pTS -> nOutput + nDoclist ; 
line 99920: char * aNew = sqlite3_malloc ( nNew ) ; 
line 99922: UNUSED_PARAMETER ( p ) ; 
line 99923: UNUSED_PARAMETER ( zTerm ) ; 
line 99924: UNUSED_PARAMETER ( nTerm ) ; 
line 99926: if ( ! aNew ) { 
line 99927: return SQLITE_NOMEM ; 
line 99928: } 
line 99930: if ( pTS -> nOutput == 0 ) { 
line 99935: memcpy ( aNew , aDoclist , nDoclist ) ; 
line 99936: } else { 
line 99941: int mergetype = ( pTS -> isReqPos ? MERGE_POS_OR : MERGE_OR ) ; 
line 99942: fts3DoclistMerge ( mergetype , 0 , 0 , 
line 99943: aNew , & nNew , pTS -> aOutput , pTS -> nOutput , aDoclist , nDoclist 
line 99944: ) ; 
line 99945: } 
line 99947: sqlite3_free ( pTS -> aOutput ) ; 
line 99948: pTS -> aOutput = aNew ; 
line 99949: pTS -> nOutput = nNew ; 
line 99951: return SQLITE_OK ; 
line 99952: } 
line 99965: static int fts3TermSelect ( 
line 99966: Fts3Table * p , 
line 99967: int iColumn , 
line 99968: const char * zTerm , 
line 99969: int nTerm , 
line 99970: int isPrefix , 
line 99971: int isReqPos , 
line 99972: int * pnOut , 
line 99973: char * * ppOut 
line 99974: ) { 
line 99975: int i ; 
line 99976: TermSelect tsc ; 
line 99977: Fts3SegFilter filter ; 
line 99978: Fts3SegReader * * apSegment ; 
line 99979: int nSegment = 0 ; 
line 99980: int nAlloc = 16 ; 
line 99981: int rc ; 
line 99982: sqlite3_stmt * pStmt = 0 ; 
line 99983: int iAge = 0 ; 
line 99985: apSegment = ( Fts3SegReader * * ) sqlite3_malloc ( sizeof ( Fts3SegReader * ) * nAlloc ) ; 
line 99986: if ( ! apSegment ) return SQLITE_NOMEM ; 
line 99987: rc = sqlite3Fts3SegReaderPending ( p , zTerm , nTerm , isPrefix , & apSegment [ 0 ] ) ; 
line 99988: if ( rc != SQLITE_OK ) goto finished ; 
line 99989: if ( apSegment [ 0 ] ) { 
line 99990: nSegment = 1 ; 
line 99991: } 
line 100003: rc = sqlite3Fts3AllSegdirs ( p , & pStmt ) ; 
line 100004: while ( rc == SQLITE_OK && SQLITE_ROW == ( rc = sqlite3_step ( pStmt ) ) ) { 
line 100005: Fts3SegReader * pNew = 0 ; 
line 100006: int nRoot = sqlite3_column_bytes ( pStmt , 4 ) ; 
line 100007: char const * zRoot = sqlite3_column_blob ( pStmt , 4 ) ; 
line 100008: if ( sqlite3_column_int64 ( pStmt , 1 ) == 0 ) { 
line 100013: rc = sqlite3Fts3SegReaderNew ( p , iAge , 0 , 0 , 0 , zRoot , nRoot , & pNew ) ; 
line 100014: } else { 
line 100015: int rc2 ; 
line 100016: sqlite3_int64 i1 ; 
line 100017: rc = fts3SelectLeaf ( p , zTerm , nTerm , zRoot , nRoot , & i1 ) ; 
line 100018: if ( rc == SQLITE_OK ) { 
line 100019: sqlite3_int64 i2 = sqlite3_column_int64 ( pStmt , 2 ) ; 
line 100020: rc = sqlite3Fts3SegReaderNew ( p , iAge , i1 , i2 , 0 , 0 , 0 , & pNew ) ; 
line 100021: } 
line 100029: rc2 = sqlite3Fts3ReadBlock ( p , 0 , 0 , 0 ) ; 
line 100030: if ( rc == SQLITE_OK ) { 
line 100031: rc = rc2 ; 
line 100032: } 
line 100033: } 
line 100034: iAge ++ ; 
line 100037: assert ( pNew != 0 || rc != SQLITE_OK ) ; 
line 100038: if ( pNew ) { 
line 100039: if ( nSegment == nAlloc ) { 
line 100040: Fts3SegReader * * pArray ; 
line 100041: nAlloc += 16 ; 
line 100042: pArray = ( Fts3SegReader * * ) sqlite3_realloc ( 
line 100043: apSegment , nAlloc * sizeof ( Fts3SegReader * ) 
line 100044: ) ; 
line 100045: if ( ! pArray ) { 
line 100046: sqlite3Fts3SegReaderFree ( p , pNew ) ; 
line 100047: rc = SQLITE_NOMEM ; 
line 100048: goto finished ; 
line 100049: } 
line 100050: apSegment = pArray ; 
line 100051: } 
line 100052: apSegment [ nSegment ++ ] = pNew ; 
line 100053: } 
line 100054: } 
line 100055: if ( rc != SQLITE_DONE ) { 
line 100056: assert ( rc != SQLITE_OK ) ; 
line 100057: goto finished ; 
line 100058: } 
line 100060: memset ( & tsc , 0 , sizeof ( TermSelect ) ) ; 
line 100061: tsc . isReqPos = isReqPos ; 
line 100063: filter . flags = FTS3_SEGMENT_IGNORE_EMPTY 
line 100064: | ( isPrefix ? FTS3_SEGMENT_PREFIX : 0 ) 
line 100065: | ( isReqPos ? FTS3_SEGMENT_REQUIRE_POS : 0 ) 
line 100066: | ( iColumn < p -> nColumn ? FTS3_SEGMENT_COLUMN_FILTER : 0 ) ; 
line 100067: filter . iCol = iColumn ; 
line 100068: filter . zTerm = zTerm ; 
line 100069: filter . nTerm = nTerm ; 
line 100071: rc = sqlite3Fts3SegReaderIterate ( p , apSegment , nSegment , & filter , 
line 100072: fts3TermSelectCb , ( void * ) & tsc 
line 100073: ) ; 
line 100075: if ( rc == SQLITE_OK ) { 
line 100076: * ppOut = tsc . aOutput ; 
line 100077: * pnOut = tsc . nOutput ; 
line 100078: } else { 
line 100079: sqlite3_free ( tsc . aOutput ) ; 
line 100080: } 
line 100082: finished : 
line 100083: sqlite3_reset ( pStmt ) ; 
line 100084: for ( i = 0 ; i < nSegment ; i ++ ) { 
line 100085: sqlite3Fts3SegReaderFree ( p , apSegment [ i ] ) ; 
line 100086: } 
line 100087: sqlite3_free ( apSegment ) ; 
line 100088: return rc ; 
line 100089: } 
line 100095: static int fts3PhraseSelect ( 
line 100096: Fts3Table * p , 
line 100097: Fts3Phrase * pPhrase , 
line 100098: int isReqPos , 
line 100099: char * * paOut , 
line 100100: int * pnOut 
line 100101: ) { 
line 100102: char * pOut = 0 ; 
line 100103: int nOut = 0 ; 
line 100104: int rc = SQLITE_OK ; 
line 100105: int ii ; 
line 100106: int iCol = pPhrase -> iColumn ; 
line 100107: int isTermPos = ( pPhrase -> nToken > 1 || isReqPos ) ; 
line 100109: for ( ii = 0 ; ii < pPhrase -> nToken ; ii ++ ) { 
line 100110: struct PhraseToken * pTok = & pPhrase -> aToken [ ii ] ; 
line 100111: char * z = pTok -> z ; 
line 100112: int n = pTok -> n ; 
line 100113: int isPrefix = pTok -> isPrefix ; 
line 100114: char * pList ; 
line 100115: int nList ; 
line 100117: rc = fts3TermSelect ( p , iCol , z , n , isPrefix , isTermPos , & nList , & pList ) ; 
line 100118: if ( rc != SQLITE_OK ) break ; 
line 100120: if ( ii == 0 ) { 
line 100121: pOut = pList ; 
line 100122: nOut = nList ; 
line 100123: } else { 
line 100132: int mergetype = MERGE_POS_PHRASE ; 
line 100133: if ( ii == pPhrase -> nToken - 1 && ! isReqPos ) { 
line 100134: mergetype = MERGE_PHRASE ; 
line 100135: } 
line 100136: fts3DoclistMerge ( mergetype , 0 , 0 , pList , & nOut , pOut , nOut , pList , nList ) ; 
line 100137: sqlite3_free ( pOut ) ; 
line 100138: pOut = pList ; 
line 100139: } 
line 100140: assert ( nOut == 0 || pOut != 0 ) ; 
line 100141: } 
line 100143: if ( rc == SQLITE_OK ) { 
line 100144: * paOut = pOut ; 
line 100145: * pnOut = nOut ; 
line 100146: } else { 
line 100147: sqlite3_free ( pOut ) ; 
line 100148: } 
line 100149: return rc ; 
line 100150: } 
line 100156: static int evalFts3Expr ( 
line 100157: Fts3Table * p , 
line 100158: Fts3Expr * pExpr , 
line 100159: char * * paOut , 
line 100160: int * pnOut , 
line 100161: int isReqPos 
line 100162: ) { 
line 100163: int rc = SQLITE_OK ; 
line 100166: * paOut = 0 ; 
line 100167: * pnOut = 0 ; 
line 100169: if ( pExpr ) { 
line 100170: assert ( pExpr -> eType == FTSQUERY_PHRASE 
line 100171: || pExpr -> eType == FTSQUERY_NEAR 
line 100172: || isReqPos == 0 
line 100173: ) ; 
line 100174: if ( pExpr -> eType == FTSQUERY_PHRASE ) { 
line 100175: rc = fts3PhraseSelect ( p , pExpr -> pPhrase , 
line 100176: isReqPos || ( pExpr -> pParent && pExpr -> pParent -> eType == FTSQUERY_NEAR ) , 
line 100177: paOut , pnOut 
line 100178: ) ; 
line 100179: } else { 
line 100180: char * aLeft ; 
line 100181: char * aRight ; 
line 100182: int nLeft ; 
line 100183: int nRight ; 
line 100185: if ( 0 == ( rc = evalFts3Expr ( p , pExpr -> pRight , & aRight , & nRight , isReqPos ) ) 
line 100186: && 0 == ( rc = evalFts3Expr ( p , pExpr -> pLeft , & aLeft , & nLeft , isReqPos ) ) 
line 100187: ) { 
line 100188: assert ( pExpr -> eType == FTSQUERY_NEAR || pExpr -> eType == FTSQUERY_OR 
line 100189: || pExpr -> eType == FTSQUERY_AND || pExpr -> eType == FTSQUERY_NOT 
line 100190: ) ; 
line 100191: switch ( pExpr -> eType ) { 
line 100192: case FTSQUERY_NEAR : { 
line 100193: Fts3Expr * pLeft ; 
line 100194: Fts3Expr * pRight ; 
line 100195: int mergetype = isReqPos ? MERGE_POS_NEAR : MERGE_NEAR ; 
line 100196: int nParam1 ; 
line 100197: int nParam2 ; 
line 100198: char * aBuffer ; 
line 100200: if ( pExpr -> pParent && pExpr -> pParent -> eType == FTSQUERY_NEAR ) { 
line 100201: mergetype = MERGE_POS_NEAR ; 
line 100202: } 
line 100203: pLeft = pExpr -> pLeft ; 
line 100204: while ( pLeft -> eType == FTSQUERY_NEAR ) { 
line 100205: pLeft = pLeft -> pRight ; 
line 100206: } 
line 100207: pRight = pExpr -> pRight ; 
line 100208: assert ( pRight -> eType == FTSQUERY_PHRASE ) ; 
line 100209: assert ( pLeft -> eType == FTSQUERY_PHRASE ) ; 
line 100211: nParam1 = pExpr -> nNear + 1 ; 
line 100212: nParam2 = nParam1 + pLeft -> pPhrase -> nToken + pRight -> pPhrase -> nToken - 2 ; 
line 100213: aBuffer = sqlite3_malloc ( nLeft + nRight + 1 ) ; 
line 100214: rc = fts3DoclistMerge ( mergetype , nParam1 , nParam2 , aBuffer , 
line 100215: pnOut , aLeft , nLeft , aRight , nRight 
line 100216: ) ; 
line 100217: if ( rc != SQLITE_OK ) { 
line 100218: sqlite3_free ( aBuffer ) ; 
line 100219: } else { 
line 100220: * paOut = aBuffer ; 
line 100221: } 
line 100222: sqlite3_free ( aLeft ) ; 
line 100223: break ; 
line 100224: } 
line 100226: case FTSQUERY_OR : { 
line 100232: char * aBuffer = sqlite3_malloc ( nRight + nLeft + 1 ) ; 
line 100233: rc = fts3DoclistMerge ( MERGE_OR , 0 , 0 , aBuffer , pnOut , 
line 100234: aLeft , nLeft , aRight , nRight 
line 100235: ) ; 
line 100236: * paOut = aBuffer ; 
line 100237: sqlite3_free ( aLeft ) ; 
line 100238: break ; 
line 100239: } 
line 100241: default : { 
line 100242: assert ( FTSQUERY_NOT == MERGE_NOT && FTSQUERY_AND == MERGE_AND ) ; 
line 100243: fts3DoclistMerge ( pExpr -> eType , 0 , 0 , aLeft , pnOut , 
line 100244: aLeft , nLeft , aRight , nRight 
line 100245: ) ; 
line 100246: * paOut = aLeft ; 
line 100247: break ; 
line 100248: } 
line 100249: } 
line 100250: } 
line 100251: sqlite3_free ( aRight ) ; 
line 100252: } 
line 100253: } 
line 100255: return rc ; 
line 100256: } 
line 100279: static int fts3FilterMethod ( 
line 100280: sqlite3_vtab_cursor * pCursor , 
line 100281: int idxNum , 
line 100282: const char * idxStr , 
line 100283: int nVal , 
line 100284: sqlite3_value * * apVal 
line 100285: ) { 
line 100286: const char * azSql [ ] = { 
line 100287: "SELECT * FROM %Q.'%q_content' WHERE docid = ?" , 
line 100288: "SELECT * FROM %Q.'%q_content'" , 
line 100289: } ; 
line 100290: int rc ; 
line 100291: char * zSql ; 
line 100292: Fts3Table * p = ( Fts3Table * ) pCursor -> pVtab ; 
line 100293: Fts3Cursor * pCsr = ( Fts3Cursor * ) pCursor ; 
line 100295: UNUSED_PARAMETER ( idxStr ) ; 
line 100296: UNUSED_PARAMETER ( nVal ) ; 
line 100298: assert ( idxNum >= 0 && idxNum <= ( FTS3_FULLTEXT_SEARCH + p -> nColumn ) ) ; 
line 100299: assert ( nVal == 0 || nVal == 1 ) ; 
line 100300: assert ( ( nVal == 0 ) == ( idxNum == FTS3_FULLSCAN_SEARCH ) ) ; 
line 100303: sqlite3_finalize ( pCsr -> pStmt ) ; 
line 100304: sqlite3_free ( pCsr -> aDoclist ) ; 
line 100305: sqlite3Fts3ExprFree ( pCsr -> pExpr ) ; 
line 100306: memset ( & pCursor [ 1 ] , 0 , sizeof ( Fts3Cursor ) - sizeof ( sqlite3_vtab_cursor ) ) ; 
line 100313: zSql = sqlite3_mprintf ( azSql [ idxNum == FTS3_FULLSCAN_SEARCH ] , p -> zDb , p -> zName ) ; 
line 100314: if ( ! zSql ) { 
line 100315: rc = SQLITE_NOMEM ; 
line 100316: } else { 
line 100317: rc = sqlite3_prepare_v2 ( p -> db , zSql , - 1 , & pCsr -> pStmt , 0 ) ; 
line 100318: sqlite3_free ( zSql ) ; 
line 100319: } 
line 100320: if ( rc != SQLITE_OK ) return rc ; 
line 100321: pCsr -> eSearch = ( i16 ) idxNum ; 
line 100323: if ( idxNum == FTS3_DOCID_SEARCH ) { 
line 100324: rc = sqlite3_bind_value ( pCsr -> pStmt , 1 , apVal [ 0 ] ) ; 
line 100325: } else if ( idxNum != FTS3_FULLSCAN_SEARCH ) { 
line 100326: int iCol = idxNum - FTS3_FULLTEXT_SEARCH ; 
line 100327: const char * zQuery = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; 
line 100329: if ( zQuery == 0 && sqlite3_value_type ( apVal [ 0 ] ) != SQLITE_NULL ) { 
line 100330: return SQLITE_NOMEM ; 
line 100331: } 
line 100333: rc = sqlite3Fts3ExprParse ( p -> pTokenizer , p -> azColumn , p -> nColumn , 
line 100334: iCol , zQuery , - 1 , & pCsr -> pExpr 
line 100335: ) ; 
line 100336: if ( rc != SQLITE_OK ) return rc ; 
line 100338: rc = evalFts3Expr ( p , pCsr -> pExpr , & pCsr -> aDoclist , & pCsr -> nDoclist , 0 ) ; 
line 100339: pCsr -> pNextId = pCsr -> aDoclist ; 
line 100340: pCsr -> iPrevId = 0 ; 
line 100341: } 
line 100343: if ( rc != SQLITE_OK ) return rc ; 
line 100344: return fts3NextMethod ( pCursor ) ; 
line 100345: } 
line 100351: static int fts3EofMethod ( sqlite3_vtab_cursor * pCursor ) { 
line 100352: return ( ( Fts3Cursor * ) pCursor ) -> isEof ; 
line 100353: } 
line 100361: static int fts3RowidMethod ( sqlite3_vtab_cursor * pCursor , sqlite_int64 * pRowid ) { 
line 100362: Fts3Cursor * pCsr = ( Fts3Cursor * ) pCursor ; 
line 100363: if ( pCsr -> aDoclist ) { 
line 100364: * pRowid = pCsr -> iPrevId ; 
line 100365: } else { 
line 100366: * pRowid = sqlite3_column_int64 ( pCsr -> pStmt , 0 ) ; 
line 100367: } 
line 100368: return SQLITE_OK ; 
line 100369: } 
line 100375: static int fts3ColumnMethod ( 
line 100376: sqlite3_vtab_cursor * pCursor , 
line 100377: sqlite3_context * pContext , 
line 100378: int iCol 
line 100379: ) { 
line 100380: int rc ; 
line 100381: Fts3Cursor * pCsr = ( Fts3Cursor * ) pCursor ; 
line 100382: Fts3Table * p = ( Fts3Table * ) pCursor -> pVtab ; 
line 100385: assert ( iCol >= 0 && iCol <= p -> nColumn + 1 ) ; 
line 100387: if ( iCol == p -> nColumn + 1 ) { 
line 100391: sqlite3_int64 iRowid ; 
line 100392: rc = fts3RowidMethod ( pCursor , & iRowid ) ; 
line 100393: sqlite3_result_int64 ( pContext , iRowid ) ; 
line 100394: } else if ( iCol == p -> nColumn ) { 
line 100398: sqlite3_result_blob ( pContext , & pCsr , sizeof ( pCsr ) , SQLITE_TRANSIENT ) ; 
line 100399: rc = SQLITE_OK ; 
line 100400: } else { 
line 100401: rc = fts3CursorSeek ( 0 , pCsr ) ; 
line 100402: if ( rc == SQLITE_OK ) { 
line 100403: sqlite3_result_value ( pContext , sqlite3_column_value ( pCsr -> pStmt , iCol + 1 ) ) ; 
line 100404: } 
line 100405: } 
line 100406: return rc ; 
line 100407: } 
line 100414: static int fts3UpdateMethod ( 
line 100415: sqlite3_vtab * pVtab , 
line 100416: int nArg , 
line 100417: sqlite3_value * * apVal , 
line 100418: sqlite_int64 * pRowid 
line 100419: ) { 
line 100420: return sqlite3Fts3UpdateMethod ( pVtab , nArg , apVal , pRowid ) ; 
line 100421: } 
line 100427: static int fts3SyncMethod ( sqlite3_vtab * pVtab ) { 
line 100428: return sqlite3Fts3PendingTermsFlush ( ( Fts3Table * ) pVtab ) ; 
line 100429: } 
line 100434: static int fts3BeginMethod ( sqlite3_vtab * pVtab ) { 
line 100435: UNUSED_PARAMETER ( pVtab ) ; 
line 100436: assert ( ( ( Fts3Table * ) pVtab ) -> nPendingData == 0 ) ; 
line 100437: return SQLITE_OK ; 
line 100438: } 
line 100445: static int fts3CommitMethod ( sqlite3_vtab * pVtab ) { 
line 100446: UNUSED_PARAMETER ( pVtab ) ; 
line 100447: assert ( ( ( Fts3Table * ) pVtab ) -> nPendingData == 0 ) ; 
line 100448: return SQLITE_OK ; 
line 100449: } 
line 100455: static int fts3RollbackMethod ( sqlite3_vtab * pVtab ) { 
line 100456: sqlite3Fts3PendingTermsClear ( ( Fts3Table * ) pVtab ) ; 
line 100457: return SQLITE_OK ; 
line 100458: } 
line 100466: SQLITE_PRIVATE int sqlite3Fts3ExprLoadDoclist ( Fts3Table * pTab , Fts3Expr * pExpr ) { 
line 100467: return evalFts3Expr ( pTab , pExpr , & pExpr -> aDoclist , & pExpr -> nDoclist , 1 ) ; 
line 100468: } 
line 100475: SQLITE_PRIVATE char * sqlite3Fts3FindPositions ( 
line 100476: Fts3Expr * pExpr , 
line 100477: sqlite3_int64 iDocid , 
line 100478: int iCol 
line 100479: ) { 
line 100480: assert ( pExpr -> isLoaded ) ; 
line 100481: if ( pExpr -> aDoclist ) { 
line 100482: char * pEnd = & pExpr -> aDoclist [ pExpr -> nDoclist ] ; 
line 100483: char * pCsr = pExpr -> pCurrent ; 
line 100485: assert ( pCsr ) ; 
line 100486: while ( pCsr < pEnd ) { 
line 100487: if ( pExpr -> iCurrent < iDocid ) { 
line 100488: fts3PoslistCopy ( 0 , & pCsr ) ; 
line 100489: fts3GetDeltaVarint ( & pCsr , & pExpr -> iCurrent ) ; 
line 100490: pExpr -> pCurrent = pCsr ; 
line 100491: } else { 
line 100492: if ( pExpr -> iCurrent == iDocid ) { 
line 100493: int iThis = 0 ; 
line 100494: if ( iCol < 0 ) { 
line 100499: return pCsr ; 
line 100500: } 
line 100501: while ( iThis < iCol ) { 
line 100502: fts3ColumnlistCopy ( 0 , & pCsr ) ; 
line 100503: if ( * pCsr == 0x00 ) return 0 ; 
line 100504: pCsr ++ ; 
line 100505: pCsr += sqlite3Fts3GetVarint32 ( pCsr , & iThis ) ; 
line 100506: } 
line 100507: if ( iCol == iThis ) return pCsr ; 
line 100508: } 
line 100509: return 0 ; 
line 100510: } 
line 100511: } 
line 100512: } 
line 100514: return 0 ; 
line 100515: } 
line 100527: static int fts3FunctionArg ( 
line 100528: sqlite3_context * pContext , 
line 100529: const char * zFunc , 
line 100530: sqlite3_value * pVal , 
line 100531: Fts3Cursor * * ppCsr 
line 100532: ) { 
line 100533: Fts3Cursor * pRet ; 
line 100534: if ( sqlite3_value_type ( pVal ) != SQLITE_BLOB 
line 100535: || sqlite3_value_bytes ( pVal ) != sizeof ( Fts3Cursor * ) 
line 100536: ) { 
line 100537: char * zErr = sqlite3_mprintf ( "illegal first argument to %s" , zFunc ) ; 
line 100538: sqlite3_result_error ( pContext , zErr , - 1 ) ; 
line 100539: sqlite3_free ( zErr ) ; 
line 100540: return SQLITE_ERROR ; 
line 100541: } 
line 100542: memcpy ( & pRet , sqlite3_value_blob ( pVal ) , sizeof ( Fts3Cursor * ) ) ; 
line 100543: * ppCsr = pRet ; 
line 100544: return SQLITE_OK ; 
line 100545: } 
line 100550: static void fts3SnippetFunc ( 
line 100551: sqlite3_context * pContext , 
line 100552: int nVal , 
line 100553: sqlite3_value * * apVal 
line 100554: ) { 
line 100555: Fts3Cursor * pCsr ; 
line 100556: const char * zStart = "<b>" ; 
line 100557: const char * zEnd = "</b>" ; 
line 100558: const char * zEllipsis = "<b>...</b>" ; 
line 100563: assert ( nVal >= 1 ) ; 
line 100565: if ( nVal > 4 ) { 
line 100566: sqlite3_result_error ( pContext , 
line 100567: "wrong number of arguments to function snippet()" , - 1 ) ; 
line 100568: return ; 
line 100569: } 
line 100570: if ( fts3FunctionArg ( pContext , "snippet" , apVal [ 0 ] , & pCsr ) ) return ; 
line 100572: switch ( nVal ) { 
line 100573: case 4 : zEllipsis = ( const char * ) sqlite3_value_text ( apVal [ 3 ] ) ; 
line 100574: case 3 : zEnd = ( const char * ) sqlite3_value_text ( apVal [ 2 ] ) ; 
line 100575: case 2 : zStart = ( const char * ) sqlite3_value_text ( apVal [ 1 ] ) ; 
line 100576: } 
line 100577: if ( ! zEllipsis || ! zEnd || ! zStart ) { 
line 100578: sqlite3_result_error_nomem ( pContext ) ; 
line 100579: } else if ( SQLITE_OK == fts3CursorSeek ( pContext , pCsr ) ) { 
line 100580: sqlite3Fts3Snippet ( pContext , pCsr , zStart , zEnd , zEllipsis ) ; 
line 100581: } 
line 100582: } 
line 100587: static void fts3Snippet2Func ( 
line 100588: sqlite3_context * pContext , 
line 100589: int nVal , 
line 100590: sqlite3_value * * apVal 
line 100591: ) { 
line 100592: Fts3Cursor * pCsr ; 
line 100593: const char * zStart = "<b>" ; 
line 100594: const char * zEnd = "</b>" ; 
line 100595: const char * zEllipsis = "<b>...</b>" ; 
line 100596: int iCol = - 1 ; 
line 100597: int nToken = 10 ; 
line 100602: assert ( nVal >= 1 ) ; 
line 100604: if ( nVal > 6 ) { 
line 100605: sqlite3_result_error ( pContext , 
line 100606: "wrong number of arguments to function snippet()" , - 1 ) ; 
line 100607: return ; 
line 100608: } 
line 100609: if ( fts3FunctionArg ( pContext , "snippet" , apVal [ 0 ] , & pCsr ) ) return ; 
line 100611: switch ( nVal ) { 
line 100612: case 6 : nToken = sqlite3_value_int ( apVal [ 5 ] ) ; 
line 100613: case 5 : iCol = sqlite3_value_int ( apVal [ 4 ] ) ; 
line 100614: case 4 : zEllipsis = ( const char * ) sqlite3_value_text ( apVal [ 3 ] ) ; 
line 100615: case 3 : zEnd = ( const char * ) sqlite3_value_text ( apVal [ 2 ] ) ; 
line 100616: case 2 : zStart = ( const char * ) sqlite3_value_text ( apVal [ 1 ] ) ; 
line 100617: } 
line 100618: if ( ! zEllipsis || ! zEnd || ! zStart ) { 
line 100619: sqlite3_result_error_nomem ( pContext ) ; 
line 100620: } else if ( SQLITE_OK == fts3CursorSeek ( pContext , pCsr ) ) { 
line 100621: sqlite3Fts3Snippet2 ( pContext , pCsr , zStart , zEnd , zEllipsis , iCol , nToken ) ; 
line 100622: } 
line 100623: } 
line 100628: static void fts3OffsetsFunc ( 
line 100629: sqlite3_context * pContext , 
line 100630: int nVal , 
line 100631: sqlite3_value * * apVal 
line 100632: ) { 
line 100633: Fts3Cursor * pCsr ; 
line 100635: UNUSED_PARAMETER ( nVal ) ; 
line 100637: assert ( nVal == 1 ) ; 
line 100638: if ( fts3FunctionArg ( pContext , "offsets" , apVal [ 0 ] , & pCsr ) ) return ; 
line 100639: assert ( pCsr ) ; 
line 100640: if ( SQLITE_OK == fts3CursorSeek ( pContext , pCsr ) ) { 
line 100641: sqlite3Fts3Offsets ( pContext , pCsr ) ; 
line 100642: } 
line 100643: } 
line 100654: static void fts3OptimizeFunc ( 
line 100655: sqlite3_context * pContext , 
line 100656: int nVal , 
line 100657: sqlite3_value * * apVal 
line 100658: ) { 
line 100659: int rc ; 
line 100660: Fts3Table * p ; 
line 100661: Fts3Cursor * pCursor ; 
line 100663: UNUSED_PARAMETER ( nVal ) ; 
line 100665: assert ( nVal == 1 ) ; 
line 100666: if ( fts3FunctionArg ( pContext , "optimize" , apVal [ 0 ] , & pCursor ) ) return ; 
line 100667: p = ( Fts3Table * ) pCursor -> base . pVtab ; 
line 100668: assert ( p ) ; 
line 100670: rc = sqlite3Fts3Optimize ( p ) ; 
line 100672: switch ( rc ) { 
line 100673: case SQLITE_OK : 
line 100674: sqlite3_result_text ( pContext , "Index optimized" , - 1 , SQLITE_STATIC ) ; 
line 100675: break ; 
line 100676: case SQLITE_DONE : 
line 100677: sqlite3_result_text ( pContext , "Index already optimal" , - 1 , SQLITE_STATIC ) ; 
line 100678: break ; 
line 100679: default : 
line 100680: sqlite3_result_error_code ( pContext , rc ) ; 
line 100681: break ; 
line 100682: } 
line 100683: } 
line 100688: static void fts3MatchinfoFunc ( 
line 100689: sqlite3_context * pContext , 
line 100690: int nVal , 
line 100691: sqlite3_value * * apVal 
line 100692: ) { 
line 100693: Fts3Cursor * pCsr ; 
line 100695: if ( nVal != 1 ) { 
line 100696: sqlite3_result_error ( pContext , 
line 100697: "wrong number of arguments to function matchinfo()" , - 1 ) ; 
line 100698: return ; 
line 100699: } 
line 100701: if ( SQLITE_OK == fts3FunctionArg ( pContext , "matchinfo" , apVal [ 0 ] , & pCsr ) ) { 
line 100702: sqlite3Fts3Matchinfo ( pContext , pCsr ) ; 
line 100703: } 
line 100704: } 
line 100710: static int fts3FindFunctionMethod ( 
line 100711: sqlite3_vtab * pVtab , 
line 100712: int nArg , 
line 100713: const char * zName , 
line 100714: void ( * * pxFunc ) ( sqlite3_context * , int , sqlite3_value * * ) , 
line 100715: void * * ppArg 
line 100716: ) { 
line 100717: struct Overloaded { 
line 100718: const char * zName ; 
line 100719: void ( * xFunc ) ( sqlite3_context * , int , sqlite3_value * * ) ; 
line 100720: } aOverload [ ] = { 
line 100721: { "snippet" , fts3SnippetFunc } , 
line 100722: { "snippet2" , fts3Snippet2Func } , 
line 100723: { "offsets" , fts3OffsetsFunc } , 
line 100724: { "optimize" , fts3OptimizeFunc } , 
line 100725: { "matchinfo" , fts3MatchinfoFunc } , 
line 100726: } ; 
line 100727: int i ; 
line 100729: UNUSED_PARAMETER ( pVtab ) ; 
line 100730: UNUSED_PARAMETER ( nArg ) ; 
line 100731: UNUSED_PARAMETER ( ppArg ) ; 
line 100733: for ( i = 0 ; i < SizeofArray ( aOverload ) ; i ++ ) { 
line 100734: if ( strcmp ( zName , aOverload [ i ] . zName ) == 0 ) { 
line 100735: * pxFunc = aOverload [ i ] . xFunc ; 
line 100736: return 1 ; 
line 100737: } 
line 100738: } 
line 100741: return 0 ; 
line 100742: } 
line 100747: static int fts3RenameMethod ( 
line 100748: sqlite3_vtab * pVtab , 
line 100749: const char * zName 
line 100750: ) { 
line 100751: Fts3Table * p = ( Fts3Table * ) pVtab ; 
line 100752: int rc = SQLITE_NOMEM ; 
line 100753: char * zSql ; 
line 100755: zSql = sqlite3_mprintf ( 
line 100756: "ALTER TABLE %Q.'%q_content'  RENAME TO '%q_content';" 
line 100757: "ALTER TABLE %Q.'%q_segments' RENAME TO '%q_segments';" 
line 100758: "ALTER TABLE %Q.'%q_segdir'   RENAME TO '%q_segdir';" 
line 100759: , p -> zDb , p -> zName , zName 
line 100760: , p -> zDb , p -> zName , zName 
line 100761: , p -> zDb , p -> zName , zName 
line 100762: ) ; 
line 100763: if ( zSql ) { 
line 100764: rc = sqlite3_exec ( p -> db , zSql , 0 , 0 , 0 ) ; 
line 100765: sqlite3_free ( zSql ) ; 
line 100766: } 
line 100767: return rc ; 
line 100768: } 
line 100770: static const sqlite3_module fts3Module = { 
line 100771: 0 , 
line 100772: fts3CreateMethod , 
line 100773: fts3ConnectMethod , 
line 100774: fts3BestIndexMethod , 
line 100775: fts3DisconnectMethod , 
line 100776: fts3DestroyMethod , 
line 100777: fts3OpenMethod , 
line 100778: fulltextClose , 
line 100779: fts3FilterMethod , 
line 100780: fts3NextMethod , 
line 100781: fts3EofMethod , 
line 100782: fts3ColumnMethod , 
line 100783: fts3RowidMethod , 
line 100784: fts3UpdateMethod , 
line 100785: fts3BeginMethod , 
line 100786: fts3SyncMethod , 
line 100787: fts3CommitMethod , 
line 100788: fts3RollbackMethod , 
line 100789: fts3FindFunctionMethod , 
line 100790: fts3RenameMethod , 
line 100791: } ; 
line 100798: static void hashDestroy ( void * p ) { 
line 100799: Fts3Hash * pHash = ( Fts3Hash * ) p ; 
line 100800: sqlite3Fts3HashClear ( pHash ) ; 
line 100801: sqlite3_free ( pHash ) ; 
line 100802: } 
line 100815: SQLITE_PRIVATE void sqlite3Fts3SimpleTokenizerModule ( sqlite3_tokenizer_module const * * ppModule ) ; 
line 100816: SQLITE_PRIVATE void sqlite3Fts3PorterTokenizerModule ( sqlite3_tokenizer_module const * * ppModule ) ; 
line 100817: SQLITE_PRIVATE void sqlite3Fts3IcuTokenizerModule ( sqlite3_tokenizer_module const * * ppModule ) ; 
line 100825: SQLITE_PRIVATE int sqlite3Fts3Init ( sqlite3 * db ) { 
line 100826: int rc = SQLITE_OK ; 
line 100827: Fts3Hash * pHash = 0 ; 
line 100828: const sqlite3_tokenizer_module * pSimple = 0 ; 
line 100829: const sqlite3_tokenizer_module * pPorter = 0 ; 
line 100831: # ifdef SQLITE_ENABLE_ICU 
line 100832: const sqlite3_tokenizer_module * pIcu = 0 ; 
line 100833: sqlite3Fts3IcuTokenizerModule ( & pIcu ) ; 
line 100834: # endif 
line 100836: sqlite3Fts3SimpleTokenizerModule ( & pSimple ) ; 
line 100837: sqlite3Fts3PorterTokenizerModule ( & pPorter ) ; 
line 100840: pHash = sqlite3_malloc ( sizeof ( Fts3Hash ) ) ; 
line 100841: if ( ! pHash ) { 
line 100842: rc = SQLITE_NOMEM ; 
line 100843: } else { 
line 100844: sqlite3Fts3HashInit ( pHash , FTS3_HASH_STRING , 1 ) ; 
line 100845: } 
line 100848: if ( rc == SQLITE_OK ) { 
line 100849: if ( sqlite3Fts3HashInsert ( pHash , "simple" , 7 , ( void * ) pSimple ) 
line 100850: || sqlite3Fts3HashInsert ( pHash , "porter" , 7 , ( void * ) pPorter ) 
line 100851: # ifdef SQLITE_ENABLE_ICU 
line 100852: || ( pIcu && sqlite3Fts3HashInsert ( pHash , "icu" , 4 , ( void * ) pIcu ) ) 
line 100853: # endif 
line 100854: ) { 
line 100855: rc = SQLITE_NOMEM ; 
line 100856: } 
line 100857: } 
line 100859: # ifdef SQLITE_TEST 
line 100860: if ( rc == SQLITE_OK ) { 
line 100861: rc = sqlite3Fts3ExprInitTestInterface ( db ) ; 
line 100862: } 
line 100863: # endif 
line 100869: if ( SQLITE_OK == rc 
line 100870: && SQLITE_OK == ( rc = sqlite3Fts3InitHashTable ( db , pHash , "fts3_tokenizer" ) ) 
line 100871: && SQLITE_OK == ( rc = sqlite3_overload_function ( db , "snippet" , - 1 ) ) 
line 100872: && SQLITE_OK == ( rc = sqlite3_overload_function ( db , "snippet2" , - 1 ) ) 
line 100873: && SQLITE_OK == ( rc = sqlite3_overload_function ( db , "offsets" , 1 ) ) 
line 100874: && SQLITE_OK == ( rc = sqlite3_overload_function ( db , "matchinfo" , - 1 ) ) 
line 100875: && SQLITE_OK == ( rc = sqlite3_overload_function ( db , "optimize" , 1 ) ) 
line 100876: ) { 
line 100877: return sqlite3_create_module_v2 ( 
line 100878: db , "fts3" , & fts3Module , ( void * ) pHash , hashDestroy 
line 100879: ) ; 
line 100880: } 
line 100883: assert ( rc != SQLITE_OK ) ; 
line 100884: if ( pHash ) { 
line 100885: sqlite3Fts3HashClear ( pHash ) ; 
line 100886: sqlite3_free ( pHash ) ; 
line 100887: } 
line 100888: return rc ; 
line 100889: } 
line 100891: # if ! SQLITE_CORE 
line 100892: SQLITE_API int sqlite3_extension_init ( 
line 100893: sqlite3 * db , 
line 100894: char * * pzErrMsg , 
line 100895: const sqlite3_api_routines * pApi 
line 100896: ) { 
line 100897: SQLITE_EXTENSION_INIT2 ( pApi ) 
line 100898: return sqlite3Fts3Init ( db ) ; 
line 100899: } 
line 100900: # endif 
line 100902: # endif 
line 100923: # if ! defined ( SQLITE_CORE ) || defined ( SQLITE_ENABLE_FTS3 ) 
line 100970: # ifdef SQLITE_TEST 
line 100971: SQLITE_API int sqlite3_fts3_enable_parentheses = 0 ; 
line 100972: # else 
line 100973: # ifdef SQLITE_ENABLE_FTS3_PARENTHESIS 
line 100974: # define sqlite3_fts3_enable_parentheses 1 
line 100975: # else 
line 100976: # define sqlite3_fts3_enable_parentheses 0 
line 100977: # endif 
line 100978: # endif 
line 100983: # define SQLITE_FTS3_DEFAULT_NEAR_PARAM 10 
line 100986: typedef struct ParseContext ParseContext ; 
line 100987: struct ParseContext { 
line 100988: sqlite3_tokenizer * pTokenizer ; 
line 100989: const char * * azCol ; 
line 100990: int nCol ; 
line 100991: int iDefaultCol ; 
line 100992: sqlite3_context * pCtx ; 
line 100993: int nNest ; 
line 100994: } ; 
line 101007: static int fts3isspace ( char c ) { 
line 101008: return ( c & 0x80 ) == 0 ? isspace ( c ) : 0 ; 
line 101009: } 
line 101023: static int getNextToken ( 
line 101024: ParseContext * pParse , 
line 101025: int iCol , 
line 101026: const char * z , int n , 
line 101027: Fts3Expr * * ppExpr , 
line 101028: int * pnConsumed 
line 101029: ) { 
line 101030: sqlite3_tokenizer * pTokenizer = pParse -> pTokenizer ; 
line 101031: sqlite3_tokenizer_module const * pModule = pTokenizer -> pModule ; 
line 101032: int rc ; 
line 101033: sqlite3_tokenizer_cursor * pCursor ; 
line 101034: Fts3Expr * pRet = 0 ; 
line 101035: int nConsumed = 0 ; 
line 101037: rc = pModule -> xOpen ( pTokenizer , z , n , & pCursor ) ; 
line 101038: if ( rc == SQLITE_OK ) { 
line 101039: const char * zToken ; 
line 101040: int nToken , iStart , iEnd , iPosition ; 
line 101041: int nByte ; 
line 101043: pCursor -> pTokenizer = pTokenizer ; 
line 101044: rc = pModule -> xNext ( pCursor , & zToken , & nToken , & iStart , & iEnd , & iPosition ) ; 
line 101046: if ( rc == SQLITE_OK ) { 
line 101047: nByte = sizeof ( Fts3Expr ) + sizeof ( Fts3Phrase ) + nToken ; 
line 101048: pRet = ( Fts3Expr * ) sqlite3_malloc ( nByte ) ; 
line 101049: if ( ! pRet ) { 
line 101050: rc = SQLITE_NOMEM ; 
line 101051: } else { 
line 101052: memset ( pRet , 0 , nByte ) ; 
line 101053: pRet -> eType = FTSQUERY_PHRASE ; 
line 101054: pRet -> pPhrase = ( Fts3Phrase * ) & pRet [ 1 ] ; 
line 101055: pRet -> pPhrase -> nToken = 1 ; 
line 101056: pRet -> pPhrase -> iColumn = iCol ; 
line 101057: pRet -> pPhrase -> aToken [ 0 ] . n = nToken ; 
line 101058: pRet -> pPhrase -> aToken [ 0 ] . z = ( char * ) & pRet -> pPhrase [ 1 ] ; 
line 101059: memcpy ( pRet -> pPhrase -> aToken [ 0 ] . z , zToken , nToken ) ; 
line 101061: if ( iEnd < n && z [ iEnd ] == '*' ) { 
line 101062: pRet -> pPhrase -> aToken [ 0 ] . isPrefix = 1 ; 
line 101063: iEnd ++ ; 
line 101064: } 
line 101065: if ( ! sqlite3_fts3_enable_parentheses && iStart > 0 && z [ iStart - 1 ] == '-' ) { 
line 101066: pRet -> pPhrase -> isNot = 1 ; 
line 101067: } 
line 101068: } 
line 101069: nConsumed = iEnd ; 
line 101070: } 
line 101072: pModule -> xClose ( pCursor ) ; 
line 101073: } 
line 101075: * pnConsumed = nConsumed ; 
line 101076: * ppExpr = pRet ; 
line 101077: return rc ; 
line 101078: } 
line 101085: static void * fts3ReallocOrFree ( void * pOrig , int nNew ) { 
line 101086: void * pRet = sqlite3_realloc ( pOrig , nNew ) ; 
line 101087: if ( ! pRet ) { 
line 101088: sqlite3_free ( pOrig ) ; 
line 101089: } 
line 101090: return pRet ; 
line 101091: } 
line 101105: static int getNextString ( 
line 101106: ParseContext * pParse , 
line 101107: const char * zInput , int nInput , 
line 101108: Fts3Expr * * ppExpr 
line 101109: ) { 
line 101110: sqlite3_tokenizer * pTokenizer = pParse -> pTokenizer ; 
line 101111: sqlite3_tokenizer_module const * pModule = pTokenizer -> pModule ; 
line 101112: int rc ; 
line 101113: Fts3Expr * p = 0 ; 
line 101114: sqlite3_tokenizer_cursor * pCursor = 0 ; 
line 101115: char * zTemp = 0 ; 
line 101116: int nTemp = 0 ; 
line 101118: rc = pModule -> xOpen ( pTokenizer , zInput , nInput , & pCursor ) ; 
line 101119: if ( rc == SQLITE_OK ) { 
line 101120: int ii ; 
line 101121: pCursor -> pTokenizer = pTokenizer ; 
line 101122: for ( ii = 0 ; rc == SQLITE_OK ; ii ++ ) { 
line 101123: const char * zToken ; 
line 101124: int nToken , iBegin , iEnd , iPos ; 
line 101125: rc = pModule -> xNext ( pCursor , & zToken , & nToken , & iBegin , & iEnd , & iPos ) ; 
line 101126: if ( rc == SQLITE_OK ) { 
line 101127: int nByte = sizeof ( Fts3Expr ) + sizeof ( Fts3Phrase ) ; 
line 101128: p = fts3ReallocOrFree ( p , nByte + ii * sizeof ( struct PhraseToken ) ) ; 
line 101129: zTemp = fts3ReallocOrFree ( zTemp , nTemp + nToken ) ; 
line 101130: if ( ! p || ! zTemp ) { 
line 101131: goto no_mem ; 
line 101132: } 
line 101133: if ( ii == 0 ) { 
line 101134: memset ( p , 0 , nByte ) ; 
line 101135: p -> pPhrase = ( Fts3Phrase * ) & p [ 1 ] ; 
line 101136: } 
line 101137: p -> pPhrase = ( Fts3Phrase * ) & p [ 1 ] ; 
line 101138: p -> pPhrase -> nToken = ii + 1 ; 
line 101139: p -> pPhrase -> aToken [ ii ] . n = nToken ; 
line 101140: memcpy ( & zTemp [ nTemp ] , zToken , nToken ) ; 
line 101141: nTemp += nToken ; 
line 101142: if ( iEnd < nInput && zInput [ iEnd ] == '*' ) { 
line 101143: p -> pPhrase -> aToken [ ii ] . isPrefix = 1 ; 
line 101144: } else { 
line 101145: p -> pPhrase -> aToken [ ii ] . isPrefix = 0 ; 
line 101146: } 
line 101147: } 
line 101148: } 
line 101150: pModule -> xClose ( pCursor ) ; 
line 101151: pCursor = 0 ; 
line 101152: } 
line 101154: if ( rc == SQLITE_DONE ) { 
line 101155: int jj ; 
line 101156: char * zNew = NULL ; 
line 101157: int nNew = 0 ; 
line 101158: int nByte = sizeof ( Fts3Expr ) + sizeof ( Fts3Phrase ) ; 
line 101159: nByte += ( p ? ( p -> pPhrase -> nToken - 1 ) : 0 ) * sizeof ( struct PhraseToken ) ; 
line 101160: p = fts3ReallocOrFree ( p , nByte + nTemp ) ; 
line 101161: if ( ! p ) { 
line 101162: goto no_mem ; 
line 101163: } 
line 101164: if ( zTemp ) { 
line 101165: zNew = & ( ( ( char * ) p ) [ nByte ] ) ; 
line 101166: memcpy ( zNew , zTemp , nTemp ) ; 
line 101167: } else { 
line 101168: memset ( p , 0 , nByte + nTemp ) ; 
line 101169: } 
line 101170: p -> pPhrase = ( Fts3Phrase * ) & p [ 1 ] ; 
line 101171: for ( jj = 0 ; jj < p -> pPhrase -> nToken ; jj ++ ) { 
line 101172: p -> pPhrase -> aToken [ jj ] . z = & zNew [ nNew ] ; 
line 101173: nNew += p -> pPhrase -> aToken [ jj ] . n ; 
line 101174: } 
line 101175: sqlite3_free ( zTemp ) ; 
line 101176: p -> eType = FTSQUERY_PHRASE ; 
line 101177: p -> pPhrase -> iColumn = pParse -> iDefaultCol ; 
line 101178: rc = SQLITE_OK ; 
line 101179: } 
line 101181: * ppExpr = p ; 
line 101182: return rc ; 
line 101183: no_mem : 
line 101185: if ( pCursor ) { 
line 101186: pModule -> xClose ( pCursor ) ; 
line 101187: } 
line 101188: sqlite3_free ( zTemp ) ; 
line 101189: sqlite3_free ( p ) ; 
line 101190: * ppExpr = 0 ; 
line 101191: return SQLITE_NOMEM ; 
line 101192: } 
line 101198: static int fts3ExprParse ( ParseContext * , const char * , int , Fts3Expr * * , int * ) ; 
line 101208: static int getNextNode ( 
line 101209: ParseContext * pParse , 
line 101210: const char * z , int n , 
line 101211: Fts3Expr * * ppExpr , 
line 101212: int * pnConsumed 
line 101213: ) { 
line 101214: static const struct Fts3Keyword { 
line 101215: char * z ; 
line 101216: unsigned char n ; 
line 101217: unsigned char parenOnly ; 
line 101218: unsigned char eType ; 
line 101219: } aKeyword [ ] = { 
line 101220: { "OR" , 2 , 0 , FTSQUERY_OR } , 
line 101221: { "AND" , 3 , 1 , FTSQUERY_AND } , 
line 101222: { "NOT" , 3 , 1 , FTSQUERY_NOT } , 
line 101223: { "NEAR" , 4 , 0 , FTSQUERY_NEAR } 
line 101224: } ; 
line 101225: int ii ; 
line 101226: int iCol ; 
line 101227: int iColLen ; 
line 101228: int rc ; 
line 101229: Fts3Expr * pRet = 0 ; 
line 101231: const char * zInput = z ; 
line 101232: int nInput = n ; 
line 101237: while ( nInput > 0 && fts3isspace ( * zInput ) ) { 
line 101238: nInput -- ; 
line 101239: zInput ++ ; 
line 101240: } 
line 101241: if ( nInput == 0 ) { 
line 101242: return SQLITE_DONE ; 
line 101243: } 
line 101246: for ( ii = 0 ; ii < ( int ) ( sizeof ( aKeyword ) / sizeof ( struct Fts3Keyword ) ) ; ii ++ ) { 
line 101247: const struct Fts3Keyword * pKey = & aKeyword [ ii ] ; 
line 101249: if ( ( pKey -> parenOnly & ~ sqlite3_fts3_enable_parentheses ) != 0 ) { 
line 101250: continue ; 
line 101251: } 
line 101253: if ( nInput >= pKey -> n && 0 == memcmp ( zInput , pKey -> z , pKey -> n ) ) { 
line 101254: int nNear = SQLITE_FTS3_DEFAULT_NEAR_PARAM ; 
line 101255: int nKey = pKey -> n ; 
line 101256: char cNext ; 
line 101259: if ( pKey -> eType == FTSQUERY_NEAR ) { 
line 101260: assert ( nKey == 4 ) ; 
line 101261: if ( zInput [ 4 ] == '/' && zInput [ 5 ] >= '0' && zInput [ 5 ] <= '9' ) { 
line 101262: nNear = 0 ; 
line 101263: for ( nKey = 5 ; zInput [ nKey ] >= '0' && zInput [ nKey ] <= '9' ; nKey ++ ) { 
line 101264: nNear = nNear * 10 + ( zInput [ nKey ] - '0' ) ; 
line 101265: } 
line 101266: } 
line 101267: } 
line 101273: cNext = zInput [ nKey ] ; 
line 101274: if ( fts3isspace ( cNext ) 
line 101275: || cNext == '"' || cNext == '(' || cNext == ')' || cNext == 0 
line 101276: ) { 
line 101277: pRet = ( Fts3Expr * ) sqlite3_malloc ( sizeof ( Fts3Expr ) ) ; 
line 101278: if ( ! pRet ) { 
line 101279: return SQLITE_NOMEM ; 
line 101280: } 
line 101281: memset ( pRet , 0 , sizeof ( Fts3Expr ) ) ; 
line 101282: pRet -> eType = pKey -> eType ; 
line 101283: pRet -> nNear = nNear ; 
line 101284: * ppExpr = pRet ; 
line 101285: * pnConsumed = ( int ) ( ( zInput - z ) + nKey ) ; 
line 101286: return SQLITE_OK ; 
line 101287: } 
line 101292: } 
line 101293: } 
line 101296: if ( sqlite3_fts3_enable_parentheses ) { 
line 101297: if ( * zInput == '(' ) { 
line 101298: int nConsumed ; 
line 101299: int rc ; 
line 101300: pParse -> nNest ++ ; 
line 101301: rc = fts3ExprParse ( pParse , & zInput [ 1 ] , nInput - 1 , ppExpr , & nConsumed ) ; 
line 101302: if ( rc == SQLITE_OK && ! * ppExpr ) { 
line 101303: rc = SQLITE_DONE ; 
line 101304: } 
line 101305: * pnConsumed = ( int ) ( ( zInput - z ) + 1 + nConsumed ) ; 
line 101306: return rc ; 
line 101307: } 
line 101310: if ( * zInput == ')' ) { 
line 101311: pParse -> nNest -- ; 
line 101312: * pnConsumed = ( int ) ( ( zInput - z ) + 1 ) ; 
line 101313: return SQLITE_DONE ; 
line 101314: } 
line 101315: } 
line 101322: if ( * zInput == '"' ) { 
line 101323: for ( ii = 1 ; ii < nInput && zInput [ ii ] != '"' ; ii ++ ) ; 
line 101324: * pnConsumed = ( int ) ( ( zInput - z ) + ii + 1 ) ; 
line 101325: if ( ii == nInput ) { 
line 101326: return SQLITE_ERROR ; 
line 101327: } 
line 101328: return getNextString ( pParse , & zInput [ 1 ] , ii - 1 , ppExpr ) ; 
line 101329: } 
line 101343: iCol = pParse -> iDefaultCol ; 
line 101344: iColLen = 0 ; 
line 101345: for ( ii = 0 ; ii < pParse -> nCol ; ii ++ ) { 
line 101346: const char * zStr = pParse -> azCol [ ii ] ; 
line 101347: int nStr = ( int ) strlen ( zStr ) ; 
line 101348: if ( nInput > nStr && zInput [ nStr ] == ':' 
line 101349: && sqlite3_strnicmp ( zStr , zInput , nStr ) == 0 
line 101350: ) { 
line 101351: iCol = ii ; 
line 101352: iColLen = ( int ) ( ( zInput - z ) + nStr + 1 ) ; 
line 101353: break ; 
line 101354: } 
line 101355: } 
line 101356: rc = getNextToken ( pParse , iCol , & z [ iColLen ] , n - iColLen , ppExpr , pnConsumed ) ; 
line 101357: * pnConsumed += iColLen ; 
line 101358: return rc ; 
line 101359: } 
line 101380: static int opPrecedence ( Fts3Expr * p ) { 
line 101381: assert ( p -> eType != FTSQUERY_PHRASE ) ; 
line 101382: if ( sqlite3_fts3_enable_parentheses ) { 
line 101383: return p -> eType ; 
line 101384: } else if ( p -> eType == FTSQUERY_NEAR ) { 
line 101385: return 1 ; 
line 101386: } else if ( p -> eType == FTSQUERY_OR ) { 
line 101387: return 2 ; 
line 101388: } 
line 101389: assert ( p -> eType == FTSQUERY_AND ) ; 
line 101390: return 3 ; 
line 101391: } 
line 101401: static void insertBinaryOperator ( 
line 101402: Fts3Expr * * ppHead , 
line 101403: Fts3Expr * pPrev , 
line 101404: Fts3Expr * pNew 
line 101405: ) { 
line 101406: Fts3Expr * pSplit = pPrev ; 
line 101407: while ( pSplit -> pParent && opPrecedence ( pSplit -> pParent ) <= opPrecedence ( pNew ) ) { 
line 101408: pSplit = pSplit -> pParent ; 
line 101409: } 
line 101411: if ( pSplit -> pParent ) { 
line 101412: assert ( pSplit -> pParent -> pRight == pSplit ) ; 
line 101413: pSplit -> pParent -> pRight = pNew ; 
line 101414: pNew -> pParent = pSplit -> pParent ; 
line 101415: } else { 
line 101416: * ppHead = pNew ; 
line 101417: } 
line 101418: pNew -> pLeft = pSplit ; 
line 101419: pSplit -> pParent = pNew ; 
line 101420: } 
line 101432: static int fts3ExprParse ( 
line 101433: ParseContext * pParse , 
line 101434: const char * z , int n , 
line 101435: Fts3Expr * * ppExpr , 
line 101436: int * pnConsumed 
line 101437: ) { 
line 101438: Fts3Expr * pRet = 0 ; 
line 101439: Fts3Expr * pPrev = 0 ; 
line 101440: Fts3Expr * pNotBranch = 0 ; 
line 101441: int nIn = n ; 
line 101442: const char * zIn = z ; 
line 101443: int rc = SQLITE_OK ; 
line 101444: int isRequirePhrase = 1 ; 
line 101446: while ( rc == SQLITE_OK ) { 
line 101447: Fts3Expr * p = 0 ; 
line 101448: int nByte = 0 ; 
line 101449: rc = getNextNode ( pParse , zIn , nIn , & p , & nByte ) ; 
line 101450: if ( rc == SQLITE_OK ) { 
line 101451: int isPhrase ; 
line 101453: if ( ! sqlite3_fts3_enable_parentheses 
line 101454: && p -> eType == FTSQUERY_PHRASE && p -> pPhrase -> isNot 
line 101455: ) { 
line 101457: Fts3Expr * pNot = sqlite3_malloc ( sizeof ( Fts3Expr ) ) ; 
line 101458: if ( ! pNot ) { 
line 101459: sqlite3Fts3ExprFree ( p ) ; 
line 101460: rc = SQLITE_NOMEM ; 
line 101461: goto exprparse_out ; 
line 101462: } 
line 101463: memset ( pNot , 0 , sizeof ( Fts3Expr ) ) ; 
line 101464: pNot -> eType = FTSQUERY_NOT ; 
line 101465: pNot -> pRight = p ; 
line 101466: if ( pNotBranch ) { 
line 101467: pNot -> pLeft = pNotBranch ; 
line 101468: } 
line 101469: pNotBranch = pNot ; 
line 101470: p = pPrev ; 
line 101471: } else { 
line 101472: int eType = p -> eType ; 
line 101473: assert ( eType != FTSQUERY_PHRASE || ! p -> pPhrase -> isNot ) ; 
line 101474: isPhrase = ( eType == FTSQUERY_PHRASE || p -> pLeft ) ; 
line 101481: if ( ! isPhrase && isRequirePhrase ) { 
line 101482: sqlite3Fts3ExprFree ( p ) ; 
line 101483: rc = SQLITE_ERROR ; 
line 101484: goto exprparse_out ; 
line 101485: } 
line 101487: if ( isPhrase && ! isRequirePhrase ) { 
line 101489: Fts3Expr * pAnd ; 
line 101490: assert ( pRet && pPrev ) ; 
line 101491: pAnd = sqlite3_malloc ( sizeof ( Fts3Expr ) ) ; 
line 101492: if ( ! pAnd ) { 
line 101493: sqlite3Fts3ExprFree ( p ) ; 
line 101494: rc = SQLITE_NOMEM ; 
line 101495: goto exprparse_out ; 
line 101496: } 
line 101497: memset ( pAnd , 0 , sizeof ( Fts3Expr ) ) ; 
line 101498: pAnd -> eType = FTSQUERY_AND ; 
line 101499: insertBinaryOperator ( & pRet , pPrev , pAnd ) ; 
line 101500: pPrev = pAnd ; 
line 101501: } 
line 101512: if ( pPrev && ( 
line 101513: ( eType == FTSQUERY_NEAR && ! isPhrase && pPrev -> eType != FTSQUERY_PHRASE ) 
line 101514: || ( eType != FTSQUERY_PHRASE && isPhrase && pPrev -> eType == FTSQUERY_NEAR ) 
line 101515: ) ) { 
line 101516: sqlite3Fts3ExprFree ( p ) ; 
line 101517: rc = SQLITE_ERROR ; 
line 101518: goto exprparse_out ; 
line 101519: } 
line 101521: if ( isPhrase ) { 
line 101522: if ( pRet ) { 
line 101523: assert ( pPrev && pPrev -> pLeft && pPrev -> pRight == 0 ) ; 
line 101524: pPrev -> pRight = p ; 
line 101525: p -> pParent = pPrev ; 
line 101526: } else { 
line 101527: pRet = p ; 
line 101528: } 
line 101529: } else { 
line 101530: insertBinaryOperator ( & pRet , pPrev , p ) ; 
line 101531: } 
line 101532: isRequirePhrase = ! isPhrase ; 
line 101533: } 
line 101534: assert ( nByte > 0 ) ; 
line 101535: } 
line 101536: assert ( rc != SQLITE_OK || ( nByte > 0 && nByte <= nIn ) ) ; 
line 101537: nIn -= nByte ; 
line 101538: zIn += nByte ; 
line 101539: pPrev = p ; 
line 101540: } 
line 101542: if ( rc == SQLITE_DONE && pRet && isRequirePhrase ) { 
line 101543: rc = SQLITE_ERROR ; 
line 101544: } 
line 101546: if ( rc == SQLITE_DONE ) { 
line 101547: rc = SQLITE_OK ; 
line 101548: if ( ! sqlite3_fts3_enable_parentheses && pNotBranch ) { 
line 101549: if ( ! pRet ) { 
line 101550: rc = SQLITE_ERROR ; 
line 101551: } else { 
line 101552: Fts3Expr * pIter = pNotBranch ; 
line 101553: while ( pIter -> pLeft ) { 
line 101554: pIter = pIter -> pLeft ; 
line 101555: } 
line 101556: pIter -> pLeft = pRet ; 
line 101557: pRet = pNotBranch ; 
line 101558: } 
line 101559: } 
line 101560: } 
line 101561: * pnConsumed = n - nIn ; 
line 101563: exprparse_out : 
line 101564: if ( rc != SQLITE_OK ) { 
line 101565: sqlite3Fts3ExprFree ( pRet ) ; 
line 101566: sqlite3Fts3ExprFree ( pNotBranch ) ; 
line 101567: pRet = 0 ; 
line 101568: } 
line 101569: * ppExpr = pRet ; 
line 101570: return rc ; 
line 101571: } 
line 101597: SQLITE_PRIVATE int sqlite3Fts3ExprParse ( 
line 101598: sqlite3_tokenizer * pTokenizer , 
line 101599: char * * azCol , 
line 101600: int nCol , 
line 101601: int iDefaultCol , 
line 101602: const char * z , int n , 
line 101603: Fts3Expr * * ppExpr 
line 101604: ) { 
line 101605: int nParsed ; 
line 101606: int rc ; 
line 101607: ParseContext sParse ; 
line 101608: sParse . pTokenizer = pTokenizer ; 
line 101609: sParse . azCol = ( const char * * ) azCol ; 
line 101610: sParse . nCol = nCol ; 
line 101611: sParse . iDefaultCol = iDefaultCol ; 
line 101612: sParse . nNest = 0 ; 
line 101613: if ( z == 0 ) { 
line 101614: * ppExpr = 0 ; 
line 101615: return SQLITE_OK ; 
line 101616: } 
line 101617: if ( n < 0 ) { 
line 101618: n = ( int ) strlen ( z ) ; 
line 101619: } 
line 101620: rc = fts3ExprParse ( & sParse , z , n , ppExpr , & nParsed ) ; 
line 101623: if ( rc == SQLITE_OK && sParse . nNest ) { 
line 101624: rc = SQLITE_ERROR ; 
line 101625: sqlite3Fts3ExprFree ( * ppExpr ) ; 
line 101626: * ppExpr = 0 ; 
line 101627: } 
line 101629: return rc ; 
line 101630: } 
line 101635: SQLITE_PRIVATE void sqlite3Fts3ExprFree ( Fts3Expr * p ) { 
line 101636: if ( p ) { 
line 101637: sqlite3Fts3ExprFree ( p -> pLeft ) ; 
line 101638: sqlite3Fts3ExprFree ( p -> pRight ) ; 
line 101639: sqlite3_free ( p -> aDoclist ) ; 
line 101640: sqlite3_free ( p ) ; 
line 101641: } 
line 101642: } 
line 101649: # ifdef SQLITE_TEST 
line 101655: static int queryTestTokenizer ( 
line 101656: sqlite3 * db , 
line 101657: const char * zName , 
line 101658: const sqlite3_tokenizer_module * * pp 
line 101659: ) { 
line 101660: int rc ; 
line 101661: sqlite3_stmt * pStmt ; 
line 101662: const char zSql [ ] = "SELECT fts3_tokenizer(?)" ; 
line 101664: * pp = 0 ; 
line 101665: rc = sqlite3_prepare_v2 ( db , zSql , - 1 , & pStmt , 0 ) ; 
line 101666: if ( rc != SQLITE_OK ) { 
line 101667: return rc ; 
line 101668: } 
line 101670: sqlite3_bind_text ( pStmt , 1 , zName , - 1 , SQLITE_STATIC ) ; 
line 101671: if ( SQLITE_ROW == sqlite3_step ( pStmt ) ) { 
line 101672: if ( sqlite3_column_type ( pStmt , 0 ) == SQLITE_BLOB ) { 
line 101673: memcpy ( ( void * ) pp , sqlite3_column_blob ( pStmt , 0 ) , sizeof ( * pp ) ) ; 
line 101674: } 
line 101675: } 
line 101677: return sqlite3_finalize ( pStmt ) ; 
line 101678: } 
line 101686: static void exprToString ( Fts3Expr * pExpr , char * zBuf ) { 
line 101687: switch ( pExpr -> eType ) { 
line 101688: case FTSQUERY_PHRASE : { 
line 101689: Fts3Phrase * pPhrase = pExpr -> pPhrase ; 
line 101690: int i ; 
line 101691: zBuf += sprintf ( zBuf , "PHRASE %d %d" , pPhrase -> iColumn , pPhrase -> isNot ) ; 
line 101692: for ( i = 0 ; i < pPhrase -> nToken ; i ++ ) { 
line 101693: zBuf += sprintf ( zBuf , " %.*s" , pPhrase -> aToken [ i ] . n , pPhrase -> aToken [ i ] . z ) ; 
line 101694: zBuf += sprintf ( zBuf , "%s" , ( pPhrase -> aToken [ i ] . isPrefix ? "+" : "" ) ) ; 
line 101695: } 
line 101696: return ; 
line 101697: } 
line 101699: case FTSQUERY_NEAR : 
line 101700: zBuf += sprintf ( zBuf , "NEAR/%d " , pExpr -> nNear ) ; 
line 101701: break ; 
line 101702: case FTSQUERY_NOT : 
line 101703: zBuf += sprintf ( zBuf , "NOT " ) ; 
line 101704: break ; 
line 101705: case FTSQUERY_AND : 
line 101706: zBuf += sprintf ( zBuf , "AND " ) ; 
line 101707: break ; 
line 101708: case FTSQUERY_OR : 
line 101709: zBuf += sprintf ( zBuf , "OR " ) ; 
line 101710: break ; 
line 101711: } 
line 101713: zBuf += sprintf ( zBuf , "{" ) ; 
line 101714: exprToString ( pExpr -> pLeft , zBuf ) ; 
line 101715: zBuf += strlen ( zBuf ) ; 
line 101716: zBuf += sprintf ( zBuf , "} " ) ; 
line 101718: zBuf += sprintf ( zBuf , "{" ) ; 
line 101719: exprToString ( pExpr -> pRight , zBuf ) ; 
line 101720: zBuf += strlen ( zBuf ) ; 
line 101721: zBuf += sprintf ( zBuf , "}" ) ; 
line 101722: } 
line 101738: static void fts3ExprTest ( 
line 101739: sqlite3_context * context , 
line 101740: int argc , 
line 101741: sqlite3_value * * argv 
line 101742: ) { 
line 101743: sqlite3_tokenizer_module const * pModule = 0 ; 
line 101744: sqlite3_tokenizer * pTokenizer = 0 ; 
line 101745: int rc ; 
line 101746: char * * azCol = 0 ; 
line 101747: const char * zExpr ; 
line 101748: int nExpr ; 
line 101749: int nCol ; 
line 101750: int ii ; 
line 101751: Fts3Expr * pExpr ; 
line 101752: sqlite3 * db = sqlite3_context_db_handle ( context ) ; 
line 101754: if ( argc < 3 ) { 
line 101755: sqlite3_result_error ( context , 
line 101756: "Usage: fts3_exprtest(tokenizer, expr, col1, ..." , - 1 
line 101757: ) ; 
line 101758: return ; 
line 101759: } 
line 101761: rc = queryTestTokenizer ( db , 
line 101762: ( const char * ) sqlite3_value_text ( argv [ 0 ] ) , & pModule ) ; 
line 101763: if ( rc == SQLITE_NOMEM ) { 
line 101764: sqlite3_result_error_nomem ( context ) ; 
line 101765: goto exprtest_out ; 
line 101766: } else if ( ! pModule ) { 
line 101767: sqlite3_result_error ( context , "No such tokenizer module" , - 1 ) ; 
line 101768: goto exprtest_out ; 
line 101769: } 
line 101771: rc = pModule -> xCreate ( 0 , 0 , & pTokenizer ) ; 
line 101772: assert ( rc == SQLITE_NOMEM || rc == SQLITE_OK ) ; 
line 101773: if ( rc == SQLITE_NOMEM ) { 
line 101774: sqlite3_result_error_nomem ( context ) ; 
line 101775: goto exprtest_out ; 
line 101776: } 
line 101777: pTokenizer -> pModule = pModule ; 
line 101779: zExpr = ( const char * ) sqlite3_value_text ( argv [ 1 ] ) ; 
line 101780: nExpr = sqlite3_value_bytes ( argv [ 1 ] ) ; 
line 101781: nCol = argc - 2 ; 
line 101782: azCol = ( char * * ) sqlite3_malloc ( nCol * sizeof ( char * ) ) ; 
line 101783: if ( ! azCol ) { 
line 101784: sqlite3_result_error_nomem ( context ) ; 
line 101785: goto exprtest_out ; 
line 101786: } 
line 101787: for ( ii = 0 ; ii < nCol ; ii ++ ) { 
line 101788: azCol [ ii ] = ( char * ) sqlite3_value_text ( argv [ ii + 2 ] ) ; 
line 101789: } 
line 101791: rc = sqlite3Fts3ExprParse ( 
line 101792: pTokenizer , azCol , nCol , nCol , zExpr , nExpr , & pExpr 
line 101793: ) ; 
line 101794: if ( rc == SQLITE_NOMEM ) { 
line 101795: sqlite3_result_error_nomem ( context ) ; 
line 101796: goto exprtest_out ; 
line 101797: } else if ( rc == SQLITE_OK ) { 
line 101798: char zBuf [ 4096 ] ; 
line 101799: exprToString ( pExpr , zBuf ) ; 
line 101800: sqlite3_result_text ( context , zBuf , - 1 , SQLITE_TRANSIENT ) ; 
line 101801: sqlite3Fts3ExprFree ( pExpr ) ; 
line 101802: } else { 
line 101803: sqlite3_result_error ( context , "Error parsing expression" , - 1 ) ; 
line 101804: } 
line 101806: exprtest_out : 
line 101807: if ( pModule && pTokenizer ) { 
line 101808: rc = pModule -> xDestroy ( pTokenizer ) ; 
line 101809: } 
line 101810: sqlite3_free ( azCol ) ; 
line 101811: } 
line 101817: SQLITE_PRIVATE int sqlite3Fts3ExprInitTestInterface ( sqlite3 * db ) { 
line 101818: return sqlite3_create_function ( 
line 101819: db , "fts3_exprtest" , - 1 , SQLITE_UTF8 , 0 , fts3ExprTest , 0 , 0 
line 101820: ) ; 
line 101821: } 
line 101823: # endif 
line 101824: # endif 
line 101853: # if ! defined ( SQLITE_CORE ) || defined ( SQLITE_ENABLE_FTS3 ) 
line 101860: static void * fts3HashMalloc ( int n ) { 
line 101861: void * p = sqlite3_malloc ( n ) ; 
line 101862: if ( p ) { 
line 101863: memset ( p , 0 , n ) ; 
line 101864: } 
line 101865: return p ; 
line 101866: } 
line 101867: static void fts3HashFree ( void * p ) { 
line 101868: sqlite3_free ( p ) ; 
line 101869: } 
line 101881: SQLITE_PRIVATE void sqlite3Fts3HashInit ( Fts3Hash * pNew , char keyClass , char copyKey ) { 
line 101882: assert ( pNew != 0 ) ; 
line 101883: assert ( keyClass >= FTS3_HASH_STRING && keyClass <= FTS3_HASH_BINARY ) ; 
line 101884: pNew -> keyClass = keyClass ; 
line 101885: pNew -> copyKey = copyKey ; 
line 101886: pNew -> first = 0 ; 
line 101887: pNew -> count = 0 ; 
line 101888: pNew -> htsize = 0 ; 
line 101889: pNew -> ht = 0 ; 
line 101890: } 
line 101896: SQLITE_PRIVATE void sqlite3Fts3HashClear ( Fts3Hash * pH ) { 
line 101897: Fts3HashElem * elem ; 
line 101899: assert ( pH != 0 ) ; 
line 101900: elem = pH -> first ; 
line 101901: pH -> first = 0 ; 
line 101902: fts3HashFree ( pH -> ht ) ; 
line 101903: pH -> ht = 0 ; 
line 101904: pH -> htsize = 0 ; 
line 101905: while ( elem ) { 
line 101906: Fts3HashElem * next_elem = elem -> next ; 
line 101907: if ( pH -> copyKey && elem -> pKey ) { 
line 101908: fts3HashFree ( elem -> pKey ) ; 
line 101909: } 
line 101910: fts3HashFree ( elem ) ; 
line 101911: elem = next_elem ; 
line 101912: } 
line 101913: pH -> count = 0 ; 
line 101914: } 
line 101919: static int fts3StrHash ( const void * pKey , int nKey ) { 
line 101920: const char * z = ( const char * ) pKey ; 
line 101921: int h = 0 ; 
line 101922: if ( nKey <= 0 ) nKey = ( int ) strlen ( z ) ; 
line 101923: while ( nKey > 0 ) { 
line 101924: h = ( h << 3 ) ^ h ^ * z ++ ; 
line 101925: nKey -- ; 
line 101926: } 
line 101927: return h & 0x7fffffff ; 
line 101928: } 
line 101929: static int fts3StrCompare ( const void * pKey1 , int n1 , const void * pKey2 , int n2 ) { 
line 101930: if ( n1 != n2 ) return 1 ; 
line 101931: return strncmp ( ( const char * ) pKey1 , ( const char * ) pKey2 , n1 ) ; 
line 101932: } 
line 101937: static int fts3BinHash ( const void * pKey , int nKey ) { 
line 101938: int h = 0 ; 
line 101939: const char * z = ( const char * ) pKey ; 
line 101940: while ( nKey -- > 0 ) { 
line 101941: h = ( h << 3 ) ^ h ^ * ( z ++ ) ; 
line 101942: } 
line 101943: return h & 0x7fffffff ; 
line 101944: } 
line 101945: static int fts3BinCompare ( const void * pKey1 , int n1 , const void * pKey2 , int n2 ) { 
line 101946: if ( n1 != n2 ) return 1 ; 
line 101947: return memcmp ( pKey1 , pKey2 , n1 ) ; 
line 101948: } 
line 101962: static int ( * ftsHashFunction ( int keyClass ) ) ( const void * , int ) { 
line 101963: if ( keyClass == FTS3_HASH_STRING ) { 
line 101964: return & fts3StrHash ; 
line 101965: } else { 
line 101966: assert ( keyClass == FTS3_HASH_BINARY ) ; 
line 101967: return & fts3BinHash ; 
line 101968: } 
line 101969: } 
line 101977: static int ( * ftsCompareFunction ( int keyClass ) ) ( const void * , int , const void * , int ) { 
line 101978: if ( keyClass == FTS3_HASH_STRING ) { 
line 101979: return & fts3StrCompare ; 
line 101980: } else { 
line 101981: assert ( keyClass == FTS3_HASH_BINARY ) ; 
line 101982: return & fts3BinCompare ; 
line 101983: } 
line 101984: } 
line 101988: static void fts3HashInsertElement ( 
line 101989: Fts3Hash * pH , 
line 101990: struct _fts3ht * pEntry , 
line 101991: Fts3HashElem * pNew 
line 101992: ) { 
line 101993: Fts3HashElem * pHead ; 
line 101994: pHead = pEntry -> chain ; 
line 101995: if ( pHead ) { 
line 101996: pNew -> next = pHead ; 
line 101997: pNew -> prev = pHead -> prev ; 
line 101998: if ( pHead -> prev ) { pHead -> prev -> next = pNew ; } 
line 101999: else { pH -> first = pNew ; } 
line 102000: pHead -> prev = pNew ; 
line 102001: } else { 
line 102002: pNew -> next = pH -> first ; 
line 102003: if ( pH -> first ) { pH -> first -> prev = pNew ; } 
line 102004: pNew -> prev = 0 ; 
line 102005: pH -> first = pNew ; 
line 102006: } 
line 102007: pEntry -> count ++ ; 
line 102008: pEntry -> chain = pNew ; 
line 102009: } 
line 102018: static int fts3Rehash ( Fts3Hash * pH , int new_size ) { 
line 102019: struct _fts3ht * new_ht ; 
line 102020: Fts3HashElem * elem , * next_elem ; 
line 102021: int ( * xHash ) ( const void * , int ) ; 
line 102023: assert ( ( new_size & ( new_size - 1 ) ) == 0 ) ; 
line 102024: new_ht = ( struct _fts3ht * ) fts3HashMalloc ( new_size * sizeof ( struct _fts3ht ) ) ; 
line 102025: if ( new_ht == 0 ) return 1 ; 
line 102026: fts3HashFree ( pH -> ht ) ; 
line 102027: pH -> ht = new_ht ; 
line 102028: pH -> htsize = new_size ; 
line 102029: xHash = ftsHashFunction ( pH -> keyClass ) ; 
line 102030: for ( elem = pH -> first , pH -> first = 0 ; elem ; elem = next_elem ) { 
line 102031: int h = ( * xHash ) ( elem -> pKey , elem -> nKey ) & ( new_size - 1 ) ; 
line 102032: next_elem = elem -> next ; 
line 102033: fts3HashInsertElement ( pH , & new_ht [ h ] , elem ) ; 
line 102034: } 
line 102035: return 0 ; 
line 102036: } 
line 102042: static Fts3HashElem * fts3FindElementByHash ( 
line 102043: const Fts3Hash * pH , 
line 102044: const void * pKey , 
line 102045: int nKey , 
line 102046: int h 
line 102047: ) { 
line 102048: Fts3HashElem * elem ; 
line 102049: int count ; 
line 102050: int ( * xCompare ) ( const void * , int , const void * , int ) ; 
line 102052: if ( pH -> ht ) { 
line 102053: struct _fts3ht * pEntry = & pH -> ht [ h ] ; 
line 102054: elem = pEntry -> chain ; 
line 102055: count = pEntry -> count ; 
line 102056: xCompare = ftsCompareFunction ( pH -> keyClass ) ; 
line 102057: while ( count -- && elem ) { 
line 102058: if ( ( * xCompare ) ( elem -> pKey , elem -> nKey , pKey , nKey ) == 0 ) { 
line 102059: return elem ; 
line 102060: } 
line 102061: elem = elem -> next ; 
line 102062: } 
line 102063: } 
line 102064: return 0 ; 
line 102065: } 
line 102070: static void fts3RemoveElementByHash ( 
line 102071: Fts3Hash * pH , 
line 102072: Fts3HashElem * elem , 
line 102073: int h 
line 102074: ) { 
line 102075: struct _fts3ht * pEntry ; 
line 102076: if ( elem -> prev ) { 
line 102077: elem -> prev -> next = elem -> next ; 
line 102078: } else { 
line 102079: pH -> first = elem -> next ; 
line 102080: } 
line 102081: if ( elem -> next ) { 
line 102082: elem -> next -> prev = elem -> prev ; 
line 102083: } 
line 102084: pEntry = & pH -> ht [ h ] ; 
line 102085: if ( pEntry -> chain == elem ) { 
line 102086: pEntry -> chain = elem -> next ; 
line 102087: } 
line 102088: pEntry -> count -- ; 
line 102089: if ( pEntry -> count <= 0 ) { 
line 102090: pEntry -> chain = 0 ; 
line 102091: } 
line 102092: if ( pH -> copyKey && elem -> pKey ) { 
line 102093: fts3HashFree ( elem -> pKey ) ; 
line 102094: } 
line 102095: fts3HashFree ( elem ) ; 
line 102096: pH -> count -- ; 
line 102097: if ( pH -> count <= 0 ) { 
line 102098: assert ( pH -> first == 0 ) ; 
line 102099: assert ( pH -> count == 0 ) ; 
line 102100: fts3HashClear ( pH ) ; 
line 102101: } 
line 102102: } 
line 102104: SQLITE_PRIVATE Fts3HashElem * sqlite3Fts3HashFindElem ( 
line 102105: const Fts3Hash * pH , 
line 102106: const void * pKey , 
line 102107: int nKey 
line 102108: ) { 
line 102109: int h ; 
line 102110: int ( * xHash ) ( const void * , int ) ; 
line 102112: if ( pH == 0 || pH -> ht == 0 ) return 0 ; 
line 102113: xHash = ftsHashFunction ( pH -> keyClass ) ; 
line 102114: assert ( xHash != 0 ) ; 
line 102115: h = ( * xHash ) ( pKey , nKey ) ; 
line 102116: assert ( ( pH -> htsize & ( pH -> htsize - 1 ) ) == 0 ) ; 
line 102117: return fts3FindElementByHash ( pH , pKey , nKey , h & ( pH -> htsize - 1 ) ) ; 
line 102118: } 
line 102125: SQLITE_PRIVATE void * sqlite3Fts3HashFind ( const Fts3Hash * pH , const void * pKey , int nKey ) { 
line 102126: Fts3HashElem * pElem ; 
line 102128: pElem = sqlite3Fts3HashFindElem ( pH , pKey , nKey ) ; 
line 102129: return pElem ? pElem -> data : 0 ; 
line 102130: } 
line 102147: SQLITE_PRIVATE void * sqlite3Fts3HashInsert ( 
line 102148: Fts3Hash * pH , 
line 102149: const void * pKey , 
line 102150: int nKey , 
line 102151: void * data 
line 102152: ) { 
line 102153: int hraw ; 
line 102154: int h ; 
line 102155: Fts3HashElem * elem ; 
line 102156: Fts3HashElem * new_elem ; 
line 102157: int ( * xHash ) ( const void * , int ) ; 
line 102159: assert ( pH != 0 ) ; 
line 102160: xHash = ftsHashFunction ( pH -> keyClass ) ; 
line 102161: assert ( xHash != 0 ) ; 
line 102162: hraw = ( * xHash ) ( pKey , nKey ) ; 
line 102163: assert ( ( pH -> htsize & ( pH -> htsize - 1 ) ) == 0 ) ; 
line 102164: h = hraw & ( pH -> htsize - 1 ) ; 
line 102165: elem = fts3FindElementByHash ( pH , pKey , nKey , h ) ; 
line 102166: if ( elem ) { 
line 102167: void * old_data = elem -> data ; 
line 102168: if ( data == 0 ) { 
line 102169: fts3RemoveElementByHash ( pH , elem , h ) ; 
line 102170: } else { 
line 102171: elem -> data = data ; 
line 102172: } 
line 102173: return old_data ; 
line 102174: } 
line 102175: if ( data == 0 ) return 0 ; 
line 102176: if ( ( pH -> htsize == 0 && fts3Rehash ( pH , 8 ) ) 
line 102177: || ( pH -> count >= pH -> htsize && fts3Rehash ( pH , pH -> htsize * 2 ) ) 
line 102178: ) { 
line 102179: pH -> count = 0 ; 
line 102180: return data ; 
line 102181: } 
line 102182: assert ( pH -> htsize > 0 ) ; 
line 102183: new_elem = ( Fts3HashElem * ) fts3HashMalloc ( sizeof ( Fts3HashElem ) ) ; 
line 102184: if ( new_elem == 0 ) return data ; 
line 102185: if ( pH -> copyKey && pKey != 0 ) { 
line 102186: new_elem -> pKey = fts3HashMalloc ( nKey ) ; 
line 102187: if ( new_elem -> pKey == 0 ) { 
line 102188: fts3HashFree ( new_elem ) ; 
line 102189: return data ; 
line 102190: } 
line 102191: memcpy ( ( void * ) new_elem -> pKey , pKey , nKey ) ; 
line 102192: } else { 
line 102193: new_elem -> pKey = ( void * ) pKey ; 
line 102194: } 
line 102195: new_elem -> nKey = nKey ; 
line 102196: pH -> count ++ ; 
line 102197: assert ( pH -> htsize > 0 ) ; 
line 102198: assert ( ( pH -> htsize & ( pH -> htsize - 1 ) ) == 0 ) ; 
line 102199: h = hraw & ( pH -> htsize - 1 ) ; 
line 102200: fts3HashInsertElement ( pH , & pH -> ht [ h ] , new_elem ) ; 
line 102201: new_elem -> data = data ; 
line 102202: return 0 ; 
line 102203: } 
line 102205: # endif 
line 102233: # if ! defined ( SQLITE_CORE ) || defined ( SQLITE_ENABLE_FTS3 ) 
line 102241: typedef struct porter_tokenizer { 
line 102242: sqlite3_tokenizer base ; 
line 102243: } porter_tokenizer ; 
line 102248: typedef struct porter_tokenizer_cursor { 
line 102249: sqlite3_tokenizer_cursor base ; 
line 102250: const char * zInput ; 
line 102251: int nInput ; 
line 102252: int iOffset ; 
line 102253: int iToken ; 
line 102254: char * zToken ; 
line 102255: int nAllocated ; 
line 102256: } porter_tokenizer_cursor ; 
line 102262: static int porterCreate ( 
line 102263: int argc , const char * const * argv , 
line 102264: sqlite3_tokenizer * * ppTokenizer 
line 102265: ) { 
line 102266: porter_tokenizer * t ; 
line 102268: UNUSED_PARAMETER ( argc ) ; 
line 102269: UNUSED_PARAMETER ( argv ) ; 
line 102271: t = ( porter_tokenizer * ) sqlite3_malloc ( sizeof ( * t ) ) ; 
line 102272: if ( t == NULL ) return SQLITE_NOMEM ; 
line 102273: memset ( t , 0 , sizeof ( * t ) ) ; 
line 102274: * ppTokenizer = & t -> base ; 
line 102275: return SQLITE_OK ; 
line 102276: } 
line 102281: static int porterDestroy ( sqlite3_tokenizer * pTokenizer ) { 
line 102282: sqlite3_free ( pTokenizer ) ; 
line 102283: return SQLITE_OK ; 
line 102284: } 
line 102292: static int porterOpen ( 
line 102293: sqlite3_tokenizer * pTokenizer , 
line 102294: const char * zInput , int nInput , 
line 102295: sqlite3_tokenizer_cursor * * ppCursor 
line 102296: ) { 
line 102297: porter_tokenizer_cursor * c ; 
line 102299: UNUSED_PARAMETER ( pTokenizer ) ; 
line 102301: c = ( porter_tokenizer_cursor * ) sqlite3_malloc ( sizeof ( * c ) ) ; 
line 102302: if ( c == NULL ) return SQLITE_NOMEM ; 
line 102304: c -> zInput = zInput ; 
line 102305: if ( zInput == 0 ) { 
line 102306: c -> nInput = 0 ; 
line 102307: } else if ( nInput < 0 ) { 
line 102308: c -> nInput = ( int ) strlen ( zInput ) ; 
line 102309: } else { 
line 102310: c -> nInput = nInput ; 
line 102311: } 
line 102312: c -> iOffset = 0 ; 
line 102313: c -> iToken = 0 ; 
line 102314: c -> zToken = NULL ; 
line 102315: c -> nAllocated = 0 ; 
line 102317: * ppCursor = & c -> base ; 
line 102318: return SQLITE_OK ; 
line 102319: } 
line 102325: static int porterClose ( sqlite3_tokenizer_cursor * pCursor ) { 
line 102326: porter_tokenizer_cursor * c = ( porter_tokenizer_cursor * ) pCursor ; 
line 102327: sqlite3_free ( c -> zToken ) ; 
line 102328: sqlite3_free ( c ) ; 
line 102329: return SQLITE_OK ; 
line 102330: } 
line 102334: static const char cType [ ] = { 
line 102335: 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 
line 102336: 1 , 1 , 1 , 2 , 1 
line 102337: } ; 
line 102352: static int isVowel ( const char * ) ; 
line 102353: static int isConsonant ( const char * z ) { 
line 102354: int j ; 
line 102355: char x = * z ; 
line 102356: if ( x == 0 ) return 0 ; 
line 102357: assert ( x >= 'a' && x <= 'z' ) ; 
line 102358: j = cType [ x - 'a' ] ; 
line 102359: if ( j < 2 ) return j ; 
line 102360: return z [ 1 ] == 0 || isVowel ( z + 1 ) ; 
line 102361: } 
line 102362: static int isVowel ( const char * z ) { 
line 102363: int j ; 
line 102364: char x = * z ; 
line 102365: if ( x == 0 ) return 0 ; 
line 102366: assert ( x >= 'a' && x <= 'z' ) ; 
line 102367: j = cType [ x - 'a' ] ; 
line 102368: if ( j < 2 ) return 1 - j ; 
line 102369: return isConsonant ( z + 1 ) ; 
line 102370: } 
line 102391: static int m_gt_0 ( const char * z ) { 
line 102392: while ( isVowel ( z ) ) { z ++ ; } 
line 102393: if ( * z == 0 ) return 0 ; 
line 102394: while ( isConsonant ( z ) ) { z ++ ; } 
line 102395: return * z != 0 ; 
line 102396: } 
line 102401: static int m_eq_1 ( const char * z ) { 
line 102402: while ( isVowel ( z ) ) { z ++ ; } 
line 102403: if ( * z == 0 ) return 0 ; 
line 102404: while ( isConsonant ( z ) ) { z ++ ; } 
line 102405: if ( * z == 0 ) return 0 ; 
line 102406: while ( isVowel ( z ) ) { z ++ ; } 
line 102407: if ( * z == 0 ) return 1 ; 
line 102408: while ( isConsonant ( z ) ) { z ++ ; } 
line 102409: return * z == 0 ; 
line 102410: } 
line 102415: static int m_gt_1 ( const char * z ) { 
line 102416: while ( isVowel ( z ) ) { z ++ ; } 
line 102417: if ( * z == 0 ) return 0 ; 
line 102418: while ( isConsonant ( z ) ) { z ++ ; } 
line 102419: if ( * z == 0 ) return 0 ; 
line 102420: while ( isVowel ( z ) ) { z ++ ; } 
line 102421: if ( * z == 0 ) return 0 ; 
line 102422: while ( isConsonant ( z ) ) { z ++ ; } 
line 102423: return * z != 0 ; 
line 102424: } 
line 102429: static int hasVowel ( const char * z ) { 
line 102430: while ( isConsonant ( z ) ) { z ++ ; } 
line 102431: return * z != 0 ; 
line 102432: } 
line 102440: static int doubleConsonant ( const char * z ) { 
line 102441: return isConsonant ( z ) && z [ 0 ] == z [ 1 ] ; 
line 102442: } 
line 102452: static int star_oh ( const char * z ) { 
line 102453: return 
line 102454: isConsonant ( z ) && 
line 102455: z [ 0 ] != 'w' && z [ 0 ] != 'x' && z [ 0 ] != 'y' && 
line 102456: isVowel ( z + 1 ) && 
line 102457: isConsonant ( z + 2 ) ; 
line 102458: } 
line 102472: static int stem ( 
line 102473: char * * pz , 
line 102474: const char * zFrom , 
line 102475: const char * zTo , 
line 102476: int ( * xCond ) ( const char * ) 
line 102477: ) { 
line 102478: char * z = * pz ; 
line 102479: while ( * zFrom && * zFrom == * z ) { z ++ ; zFrom ++ ; } 
line 102480: if ( * zFrom != 0 ) return 0 ; 
line 102481: if ( xCond && ! xCond ( z ) ) return 1 ; 
line 102482: while ( * zTo ) { 
line 102483: * ( -- z ) = * ( zTo ++ ) ; 
line 102484: } 
line 102485: * pz = z ; 
line 102486: return 1 ; 
line 102487: } 
line 102497: static void copy_stemmer ( const char * zIn , int nIn , char * zOut , int * pnOut ) { 
line 102498: int i , mx , j ; 
line 102499: int hasDigit = 0 ; 
line 102500: for ( i = 0 ; i < nIn ; i ++ ) { 
line 102501: char c = zIn [ i ] ; 
line 102502: if ( c >= 'A' && c <= 'Z' ) { 
line 102503: zOut [ i ] = c - 'A' + 'a' ; 
line 102504: } else { 
line 102505: if ( c >= '0' && c <= '9' ) hasDigit = 1 ; 
line 102506: zOut [ i ] = c ; 
line 102507: } 
line 102508: } 
line 102509: mx = hasDigit ? 3 : 10 ; 
line 102510: if ( nIn > mx * 2 ) { 
line 102511: for ( j = mx , i = nIn - mx ; i < nIn ; i ++ , j ++ ) { 
line 102512: zOut [ j ] = zOut [ i ] ; 
line 102513: } 
line 102514: i = j ; 
line 102515: } 
line 102516: zOut [ i ] = 0 ; 
line 102517: * pnOut = i ; 
line 102518: } 
line 102544: static void porter_stemmer ( const char * zIn , int nIn , char * zOut , int * pnOut ) { 
line 102545: int i , j ; 
line 102546: char zReverse [ 28 ] ; 
line 102547: char * z , * z2 ; 
line 102548: if ( nIn < 3 || nIn >= sizeof ( zReverse ) - 7 ) { 
line 102551: copy_stemmer ( zIn , nIn , zOut , pnOut ) ; 
line 102552: return ; 
line 102553: } 
line 102554: for ( i = 0 , j = sizeof ( zReverse ) - 6 ; i < nIn ; i ++ , j -- ) { 
line 102555: char c = zIn [ i ] ; 
line 102556: if ( c >= 'A' && c <= 'Z' ) { 
line 102557: zReverse [ j ] = c + 'a' - 'A' ; 
line 102558: } else if ( c >= 'a' && c <= 'z' ) { 
line 102559: zReverse [ j ] = c ; 
line 102560: } else { 
line 102563: copy_stemmer ( zIn , nIn , zOut , pnOut ) ; 
line 102564: return ; 
line 102565: } 
line 102566: } 
line 102567: memset ( & zReverse [ sizeof ( zReverse ) - 5 ] , 0 , 5 ) ; 
line 102568: z = & zReverse [ j + 1 ] ; 
line 102572: if ( z [ 0 ] == 's' ) { 
line 102573: if ( 
line 102574: ! stem ( & z , "sess" , "ss" , 0 ) && 
line 102575: ! stem ( & z , "sei" , "i" , 0 ) && 
line 102576: ! stem ( & z , "ss" , "ss" , 0 ) 
line 102577: ) { 
line 102578: z ++ ; 
line 102579: } 
line 102580: } 
line 102583: z2 = z ; 
line 102584: if ( stem ( & z , "dee" , "ee" , m_gt_0 ) ) { 
line 102586: } else if ( 
line 102587: ( stem ( & z , "gni" , "" , hasVowel ) || stem ( & z , "de" , "" , hasVowel ) ) 
line 102588: && z != z2 
line 102589: ) { 
line 102590: if ( stem ( & z , "ta" , "ate" , 0 ) || 
line 102591: stem ( & z , "lb" , "ble" , 0 ) || 
line 102592: stem ( & z , "zi" , "ize" , 0 ) ) { 
line 102594: } else if ( doubleConsonant ( z ) && ( * z != 'l' && * z != 's' && * z != 'z' ) ) { 
line 102595: z ++ ; 
line 102596: } else if ( m_eq_1 ( z ) && star_oh ( z ) ) { 
line 102597: * ( -- z ) = 'e' ; 
line 102598: } 
line 102599: } 
line 102602: if ( z [ 0 ] == 'y' && hasVowel ( z + 1 ) ) { 
line 102603: z [ 0 ] = 'i' ; 
line 102604: } 
line 102607: switch ( z [ 1 ] ) { 
line 102608: case 'a' : 
line 102609: stem ( & z , "lanoita" , "ate" , m_gt_0 ) || 
line 102610: stem ( & z , "lanoit" , "tion" , m_gt_0 ) ; 
line 102611: break ; 
line 102612: case 'c' : 
line 102613: stem ( & z , "icne" , "ence" , m_gt_0 ) || 
line 102614: stem ( & z , "icna" , "ance" , m_gt_0 ) ; 
line 102615: break ; 
line 102616: case 'e' : 
line 102617: stem ( & z , "rezi" , "ize" , m_gt_0 ) ; 
line 102618: break ; 
line 102619: case 'g' : 
line 102620: stem ( & z , "igol" , "log" , m_gt_0 ) ; 
line 102621: break ; 
line 102622: case 'l' : 
line 102623: stem ( & z , "ilb" , "ble" , m_gt_0 ) || 
line 102624: stem ( & z , "illa" , "al" , m_gt_0 ) || 
line 102625: stem ( & z , "iltne" , "ent" , m_gt_0 ) || 
line 102626: stem ( & z , "ile" , "e" , m_gt_0 ) || 
line 102627: stem ( & z , "ilsuo" , "ous" , m_gt_0 ) ; 
line 102628: break ; 
line 102629: case 'o' : 
line 102630: stem ( & z , "noitazi" , "ize" , m_gt_0 ) || 
line 102631: stem ( & z , "noita" , "ate" , m_gt_0 ) || 
line 102632: stem ( & z , "rota" , "ate" , m_gt_0 ) ; 
line 102633: break ; 
line 102634: case 's' : 
line 102635: stem ( & z , "msila" , "al" , m_gt_0 ) || 
line 102636: stem ( & z , "ssenevi" , "ive" , m_gt_0 ) || 
line 102637: stem ( & z , "ssenluf" , "ful" , m_gt_0 ) || 
line 102638: stem ( & z , "ssensuo" , "ous" , m_gt_0 ) ; 
line 102639: break ; 
line 102640: case 't' : 
line 102641: stem ( & z , "itila" , "al" , m_gt_0 ) || 
line 102642: stem ( & z , "itivi" , "ive" , m_gt_0 ) || 
line 102643: stem ( & z , "itilib" , "ble" , m_gt_0 ) ; 
line 102644: break ; 
line 102645: } 
line 102648: switch ( z [ 0 ] ) { 
line 102649: case 'e' : 
line 102650: stem ( & z , "etaci" , "ic" , m_gt_0 ) || 
line 102651: stem ( & z , "evita" , "" , m_gt_0 ) || 
line 102652: stem ( & z , "ezila" , "al" , m_gt_0 ) ; 
line 102653: break ; 
line 102654: case 'i' : 
line 102655: stem ( & z , "itici" , "ic" , m_gt_0 ) ; 
line 102656: break ; 
line 102657: case 'l' : 
line 102658: stem ( & z , "laci" , "ic" , m_gt_0 ) || 
line 102659: stem ( & z , "luf" , "" , m_gt_0 ) ; 
line 102660: break ; 
line 102661: case 's' : 
line 102662: stem ( & z , "ssen" , "" , m_gt_0 ) ; 
line 102663: break ; 
line 102664: } 
line 102667: switch ( z [ 1 ] ) { 
line 102668: case 'a' : 
line 102669: if ( z [ 0 ] == 'l' && m_gt_1 ( z + 2 ) ) { 
line 102670: z += 2 ; 
line 102671: } 
line 102672: break ; 
line 102673: case 'c' : 
line 102674: if ( z [ 0 ] == 'e' && z [ 2 ] == 'n' && ( z [ 3 ] == 'a' || z [ 3 ] == 'e' ) && m_gt_1 ( z + 4 ) ) { 
line 102675: z += 4 ; 
line 102676: } 
line 102677: break ; 
line 102678: case 'e' : 
line 102679: if ( z [ 0 ] == 'r' && m_gt_1 ( z + 2 ) ) { 
line 102680: z += 2 ; 
line 102681: } 
line 102682: break ; 
line 102683: case 'i' : 
line 102684: if ( z [ 0 ] == 'c' && m_gt_1 ( z + 2 ) ) { 
line 102685: z += 2 ; 
line 102686: } 
line 102687: break ; 
line 102688: case 'l' : 
line 102689: if ( z [ 0 ] == 'e' && z [ 2 ] == 'b' && ( z [ 3 ] == 'a' || z [ 3 ] == 'i' ) && m_gt_1 ( z + 4 ) ) { 
line 102690: z += 4 ; 
line 102691: } 
line 102692: break ; 
line 102693: case 'n' : 
line 102694: if ( z [ 0 ] == 't' ) { 
line 102695: if ( z [ 2 ] == 'a' ) { 
line 102696: if ( m_gt_1 ( z + 3 ) ) { 
line 102697: z += 3 ; 
line 102698: } 
line 102699: } else if ( z [ 2 ] == 'e' ) { 
line 102700: stem ( & z , "tneme" , "" , m_gt_1 ) || 
line 102701: stem ( & z , "tnem" , "" , m_gt_1 ) || 
line 102702: stem ( & z , "tne" , "" , m_gt_1 ) ; 
line 102703: } 
line 102704: } 
line 102705: break ; 
line 102706: case 'o' : 
line 102707: if ( z [ 0 ] == 'u' ) { 
line 102708: if ( m_gt_1 ( z + 2 ) ) { 
line 102709: z += 2 ; 
line 102710: } 
line 102711: } else if ( z [ 3 ] == 's' || z [ 3 ] == 't' ) { 
line 102712: stem ( & z , "noi" , "" , m_gt_1 ) ; 
line 102713: } 
line 102714: break ; 
line 102715: case 's' : 
line 102716: if ( z [ 0 ] == 'm' && z [ 2 ] == 'i' && m_gt_1 ( z + 3 ) ) { 
line 102717: z += 3 ; 
line 102718: } 
line 102719: break ; 
line 102720: case 't' : 
line 102721: stem ( & z , "eta" , "" , m_gt_1 ) || 
line 102722: stem ( & z , "iti" , "" , m_gt_1 ) ; 
line 102723: break ; 
line 102724: case 'u' : 
line 102725: if ( z [ 0 ] == 's' && z [ 2 ] == 'o' && m_gt_1 ( z + 3 ) ) { 
line 102726: z += 3 ; 
line 102727: } 
line 102728: break ; 
line 102729: case 'v' : 
line 102730: case 'z' : 
line 102731: if ( z [ 0 ] == 'e' && z [ 2 ] == 'i' && m_gt_1 ( z + 3 ) ) { 
line 102732: z += 3 ; 
line 102733: } 
line 102734: break ; 
line 102735: } 
line 102738: if ( z [ 0 ] == 'e' ) { 
line 102739: if ( m_gt_1 ( z + 1 ) ) { 
line 102740: z ++ ; 
line 102741: } else if ( m_eq_1 ( z + 1 ) && ! star_oh ( z + 1 ) ) { 
line 102742: z ++ ; 
line 102743: } 
line 102744: } 
line 102747: if ( m_gt_1 ( z ) && z [ 0 ] == 'l' && z [ 1 ] == 'l' ) { 
line 102748: z ++ ; 
line 102749: } 
line 102754: * pnOut = i = ( int ) strlen ( z ) ; 
line 102755: zOut [ i ] = 0 ; 
line 102756: while ( * z ) { 
line 102757: zOut [ -- i ] = * ( z ++ ) ; 
line 102758: } 
line 102759: } 
line 102767: static const char porterIdChar [ ] = { 
line 102769: 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 102770: 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 
line 102771: 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 
line 102772: 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 
line 102773: 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 
line 102774: } ; 
line 102775: # define isDelim ( C ) ( ( ( ch = C ) & 0x80 ) == 0 && ( ch < 0x30 || ! porterIdChar [ ch - 0x30 ] ) ) 
line 102781: static int porterNext ( 
line 102782: sqlite3_tokenizer_cursor * pCursor , 
line 102783: const char * * pzToken , 
line 102784: int * pnBytes , 
line 102785: int * piStartOffset , 
line 102786: int * piEndOffset , 
line 102787: int * piPosition 
line 102788: ) { 
line 102789: porter_tokenizer_cursor * c = ( porter_tokenizer_cursor * ) pCursor ; 
line 102790: const char * z = c -> zInput ; 
line 102792: while ( c -> iOffset < c -> nInput ) { 
line 102793: int iStartOffset , ch ; 
line 102796: while ( c -> iOffset < c -> nInput && isDelim ( z [ c -> iOffset ] ) ) { 
line 102797: c -> iOffset ++ ; 
line 102798: } 
line 102801: iStartOffset = c -> iOffset ; 
line 102802: while ( c -> iOffset < c -> nInput && ! isDelim ( z [ c -> iOffset ] ) ) { 
line 102803: c -> iOffset ++ ; 
line 102804: } 
line 102806: if ( c -> iOffset > iStartOffset ) { 
line 102807: int n = c -> iOffset - iStartOffset ; 
line 102808: if ( n > c -> nAllocated ) { 
line 102809: c -> nAllocated = n + 20 ; 
line 102810: c -> zToken = sqlite3_realloc ( c -> zToken , c -> nAllocated ) ; 
line 102811: if ( c -> zToken == NULL ) return SQLITE_NOMEM ; 
line 102812: } 
line 102813: porter_stemmer ( & z [ iStartOffset ] , n , c -> zToken , pnBytes ) ; 
line 102814: * pzToken = c -> zToken ; 
line 102815: * piStartOffset = iStartOffset ; 
line 102816: * piEndOffset = c -> iOffset ; 
line 102817: * piPosition = c -> iToken ++ ; 
line 102818: return SQLITE_OK ; 
line 102819: } 
line 102820: } 
line 102821: return SQLITE_DONE ; 
line 102822: } 
line 102827: static const sqlite3_tokenizer_module porterTokenizerModule = { 
line 102828: 0 , 
line 102829: porterCreate , 
line 102830: porterDestroy , 
line 102831: porterOpen , 
line 102832: porterClose , 
line 102833: porterNext , 
line 102834: } ; 
line 102840: SQLITE_PRIVATE void sqlite3Fts3PorterTokenizerModule ( 
line 102841: sqlite3_tokenizer_module const * * ppModule 
line 102842: ) { 
line 102843: * ppModule = & porterTokenizerModule ; 
line 102844: } 
line 102846: # endif 
line 102875: # if ! defined ( SQLITE_CORE ) || defined ( SQLITE_ENABLE_FTS3 ) 
line 102877: # ifndef SQLITE_CORE 
line 102878: SQLITE_EXTENSION_INIT1 
line 102879: # endif 
line 102902: static void scalarFunc ( 
line 102903: sqlite3_context * context , 
line 102904: int argc , 
line 102905: sqlite3_value * * argv 
line 102906: ) { 
line 102907: Fts3Hash * pHash ; 
line 102908: void * pPtr = 0 ; 
line 102909: const unsigned char * zName ; 
line 102910: int nName ; 
line 102912: assert ( argc == 1 || argc == 2 ) ; 
line 102914: pHash = ( Fts3Hash * ) sqlite3_user_data ( context ) ; 
line 102916: zName = sqlite3_value_text ( argv [ 0 ] ) ; 
line 102917: nName = sqlite3_value_bytes ( argv [ 0 ] ) + 1 ; 
line 102919: if ( argc == 2 ) { 
line 102920: void * pOld ; 
line 102921: int n = sqlite3_value_bytes ( argv [ 1 ] ) ; 
line 102922: if ( n != sizeof ( pPtr ) ) { 
line 102923: sqlite3_result_error ( context , "argument type mismatch" , - 1 ) ; 
line 102924: return ; 
line 102925: } 
line 102926: pPtr = * ( void * * ) sqlite3_value_blob ( argv [ 1 ] ) ; 
line 102927: pOld = sqlite3Fts3HashInsert ( pHash , ( void * ) zName , nName , pPtr ) ; 
line 102928: if ( pOld == pPtr ) { 
line 102929: sqlite3_result_error ( context , "out of memory" , - 1 ) ; 
line 102930: return ; 
line 102931: } 
line 102932: } else { 
line 102933: pPtr = sqlite3Fts3HashFind ( pHash , zName , nName ) ; 
line 102934: if ( ! pPtr ) { 
line 102935: char * zErr = sqlite3_mprintf ( "unknown tokenizer: %s" , zName ) ; 
line 102936: sqlite3_result_error ( context , zErr , - 1 ) ; 
line 102937: sqlite3_free ( zErr ) ; 
line 102938: return ; 
line 102939: } 
line 102940: } 
line 102942: sqlite3_result_blob ( context , ( void * ) & pPtr , sizeof ( pPtr ) , SQLITE_TRANSIENT ) ; 
line 102943: } 
line 102945: static int fts3IsIdChar ( char c ) { 
line 102946: static const char isFtsIdChar [ ] = { 
line 102947: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 102948: 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 102949: 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 102950: 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 
line 102951: 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 
line 102952: 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 
line 102953: 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 
line 102954: 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 
line 102955: } ; 
line 102956: return ( c & 0x80 || isFtsIdChar [ ( int ) ( c ) ] ) ; 
line 102957: } 
line 102959: SQLITE_PRIVATE const char * sqlite3Fts3NextToken ( const char * zStr , int * pn ) { 
line 102960: const char * z1 ; 
line 102961: const char * z2 = 0 ; 
line 102964: z1 = zStr ; 
line 102965: while ( z2 == 0 ) { 
line 102966: char c = * z1 ; 
line 102967: switch ( c ) { 
line 102968: case '\0' : return 0 ; 
line 102969: case '\'' : 
line 102970: case '"' : 
line 102971: case '`' : { 
line 102972: z2 = z1 ; 
line 102973: while ( * ++ z2 && ( * z2 != c || * ++ z2 == c ) ) ; 
line 102974: break ; 
line 102975: } 
line 102976: case '[' : 
line 102977: z2 = & z1 [ 1 ] ; 
line 102978: while ( * z2 && z2 [ 0 ] != ']' ) z2 ++ ; 
line 102979: if ( * z2 ) z2 ++ ; 
line 102980: break ; 
line 102982: default : 
line 102983: if ( fts3IsIdChar ( * z1 ) ) { 
line 102984: z2 = & z1 [ 1 ] ; 
line 102985: while ( fts3IsIdChar ( * z2 ) ) z2 ++ ; 
line 102986: } else { 
line 102987: z1 ++ ; 
line 102988: } 
line 102989: } 
line 102990: } 
line 102992: * pn = ( int ) ( z2 - z1 ) ; 
line 102993: return z1 ; 
line 102994: } 
line 102996: SQLITE_PRIVATE int sqlite3Fts3InitTokenizer ( 
line 102997: Fts3Hash * pHash , 
line 102998: const char * zArg , 
line 102999: sqlite3_tokenizer * * ppTok , 
line 103000: const char * * pzTokenizer , 
line 103001: char * * pzErr 
line 103002: ) { 
line 103003: int rc ; 
line 103004: char * z = ( char * ) zArg ; 
line 103005: int n ; 
line 103006: char * zCopy ; 
line 103007: char * zEnd ; 
line 103008: sqlite3_tokenizer_module * m ; 
line 103010: if ( ! z ) { 
line 103011: zCopy = sqlite3_mprintf ( "simple" ) ; 
line 103012: } else { 
line 103013: if ( sqlite3_strnicmp ( z , "tokenize" , 8 ) || fts3IsIdChar ( z [ 8 ] ) ) { 
line 103014: return SQLITE_OK ; 
line 103015: } 
line 103016: zCopy = sqlite3_mprintf ( "%s" , & z [ 8 ] ) ; 
line 103017: * pzTokenizer = zArg ; 
line 103018: } 
line 103019: if ( ! zCopy ) { 
line 103020: return SQLITE_NOMEM ; 
line 103021: } 
line 103023: zEnd = & zCopy [ strlen ( zCopy ) ] ; 
line 103025: z = ( char * ) sqlite3Fts3NextToken ( zCopy , & n ) ; 
line 103026: z [ n ] = '\0' ; 
line 103027: sqlite3Fts3Dequote ( z ) ; 
line 103029: m = ( sqlite3_tokenizer_module * ) sqlite3Fts3HashFind ( pHash , z , ( int ) strlen ( z ) + 1 ) ; 
line 103030: if ( ! m ) { 
line 103031: * pzErr = sqlite3_mprintf ( "unknown tokenizer: %s" , z ) ; 
line 103032: rc = SQLITE_ERROR ; 
line 103033: } else { 
line 103034: char const * * aArg = 0 ; 
line 103035: int iArg = 0 ; 
line 103036: z = & z [ n + 1 ] ; 
line 103037: while ( z < zEnd && ( NULL != ( z = ( char * ) sqlite3Fts3NextToken ( z , & n ) ) ) ) { 
line 103038: int nNew = sizeof ( char * ) * ( iArg + 1 ) ; 
line 103039: char const * * aNew = ( const char * * ) sqlite3_realloc ( ( void * ) aArg , nNew ) ; 
line 103040: if ( ! aNew ) { 
line 103041: sqlite3_free ( zCopy ) ; 
line 103042: sqlite3_free ( ( void * ) aArg ) ; 
line 103043: return SQLITE_NOMEM ; 
line 103044: } 
line 103045: aArg = aNew ; 
line 103046: aArg [ iArg ++ ] = z ; 
line 103047: z [ n ] = '\0' ; 
line 103048: sqlite3Fts3Dequote ( z ) ; 
line 103049: z = & z [ n + 1 ] ; 
line 103050: } 
line 103051: rc = m -> xCreate ( iArg , aArg , ppTok ) ; 
line 103052: assert ( rc != SQLITE_OK || * ppTok ) ; 
line 103053: if ( rc != SQLITE_OK ) { 
line 103054: * pzErr = sqlite3_mprintf ( "unknown tokenizer" ) ; 
line 103055: } else { 
line 103056: ( * ppTok ) -> pModule = m ; 
line 103057: } 
line 103058: sqlite3_free ( ( void * ) aArg ) ; 
line 103059: } 
line 103061: sqlite3_free ( zCopy ) ; 
line 103062: return rc ; 
line 103063: } 
line 103066: # ifdef SQLITE_TEST 
line 103095: static void testFunc ( 
line 103096: sqlite3_context * context , 
line 103097: int argc , 
line 103098: sqlite3_value * * argv 
line 103099: ) { 
line 103100: Fts3Hash * pHash ; 
line 103101: sqlite3_tokenizer_module * p ; 
line 103102: sqlite3_tokenizer * pTokenizer = 0 ; 
line 103103: sqlite3_tokenizer_cursor * pCsr = 0 ; 
line 103105: const char * zErr = 0 ; 
line 103107: const char * zName ; 
line 103108: int nName ; 
line 103109: const char * zInput ; 
line 103110: int nInput ; 
line 103112: const char * zArg = 0 ; 
line 103114: const char * zToken ; 
line 103115: int nToken ; 
line 103116: int iStart ; 
line 103117: int iEnd ; 
line 103118: int iPos ; 
line 103120: Tcl_Obj * pRet ; 
line 103122: assert ( argc == 2 || argc == 3 ) ; 
line 103124: nName = sqlite3_value_bytes ( argv [ 0 ] ) ; 
line 103125: zName = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; 
line 103126: nInput = sqlite3_value_bytes ( argv [ argc - 1 ] ) ; 
line 103127: zInput = ( const char * ) sqlite3_value_text ( argv [ argc - 1 ] ) ; 
line 103129: if ( argc == 3 ) { 
line 103130: zArg = ( const char * ) sqlite3_value_text ( argv [ 1 ] ) ; 
line 103131: } 
line 103133: pHash = ( Fts3Hash * ) sqlite3_user_data ( context ) ; 
line 103134: p = ( sqlite3_tokenizer_module * ) sqlite3Fts3HashFind ( pHash , zName , nName + 1 ) ; 
line 103136: if ( ! p ) { 
line 103137: char * zErr = sqlite3_mprintf ( "unknown tokenizer: %s" , zName ) ; 
line 103138: sqlite3_result_error ( context , zErr , - 1 ) ; 
line 103139: sqlite3_free ( zErr ) ; 
line 103140: return ; 
line 103141: } 
line 103143: pRet = Tcl_NewObj ( ) ; 
line 103144: Tcl_IncrRefCount ( pRet ) ; 
line 103146: if ( SQLITE_OK != p -> xCreate ( zArg ? 1 : 0 , & zArg , & pTokenizer ) ) { 
line 103147: zErr = "error in xCreate()" ; 
line 103148: goto finish ; 
line 103149: } 
line 103150: pTokenizer -> pModule = p ; 
line 103151: if ( SQLITE_OK != p -> xOpen ( pTokenizer , zInput , nInput , & pCsr ) ) { 
line 103152: zErr = "error in xOpen()" ; 
line 103153: goto finish ; 
line 103154: } 
line 103155: pCsr -> pTokenizer = pTokenizer ; 
line 103157: while ( SQLITE_OK == p -> xNext ( pCsr , & zToken , & nToken , & iStart , & iEnd , & iPos ) ) { 
line 103158: Tcl_ListObjAppendElement ( 0 , pRet , Tcl_NewIntObj ( iPos ) ) ; 
line 103159: Tcl_ListObjAppendElement ( 0 , pRet , Tcl_NewStringObj ( zToken , nToken ) ) ; 
line 103160: zToken = & zInput [ iStart ] ; 
line 103161: nToken = iEnd - iStart ; 
line 103162: Tcl_ListObjAppendElement ( 0 , pRet , Tcl_NewStringObj ( zToken , nToken ) ) ; 
line 103163: } 
line 103165: if ( SQLITE_OK != p -> xClose ( pCsr ) ) { 
line 103166: zErr = "error in xClose()" ; 
line 103167: goto finish ; 
line 103168: } 
line 103169: if ( SQLITE_OK != p -> xDestroy ( pTokenizer ) ) { 
line 103170: zErr = "error in xDestroy()" ; 
line 103171: goto finish ; 
line 103172: } 
line 103174: finish : 
line 103175: if ( zErr ) { 
line 103176: sqlite3_result_error ( context , zErr , - 1 ) ; 
line 103177: } else { 
line 103178: sqlite3_result_text ( context , Tcl_GetString ( pRet ) , - 1 , SQLITE_TRANSIENT ) ; 
line 103179: } 
line 103180: Tcl_DecrRefCount ( pRet ) ; 
line 103181: } 
line 103183: static 
line 103184: int registerTokenizer ( 
line 103185: sqlite3 * db , 
line 103186: char * zName , 
line 103187: const sqlite3_tokenizer_module * p 
line 103188: ) { 
line 103189: int rc ; 
line 103190: sqlite3_stmt * pStmt ; 
line 103191: const char zSql [ ] = "SELECT fts3_tokenizer(?, ?)" ; 
line 103193: rc = sqlite3_prepare_v2 ( db , zSql , - 1 , & pStmt , 0 ) ; 
line 103194: if ( rc != SQLITE_OK ) { 
line 103195: return rc ; 
line 103196: } 
line 103198: sqlite3_bind_text ( pStmt , 1 , zName , - 1 , SQLITE_STATIC ) ; 
line 103199: sqlite3_bind_blob ( pStmt , 2 , & p , sizeof ( p ) , SQLITE_STATIC ) ; 
line 103200: sqlite3_step ( pStmt ) ; 
line 103202: return sqlite3_finalize ( pStmt ) ; 
line 103203: } 
line 103205: static 
line 103206: int queryTokenizer ( 
line 103207: sqlite3 * db , 
line 103208: char * zName , 
line 103209: const sqlite3_tokenizer_module * * pp 
line 103210: ) { 
line 103211: int rc ; 
line 103212: sqlite3_stmt * pStmt ; 
line 103213: const char zSql [ ] = "SELECT fts3_tokenizer(?)" ; 
line 103215: * pp = 0 ; 
line 103216: rc = sqlite3_prepare_v2 ( db , zSql , - 1 , & pStmt , 0 ) ; 
line 103217: if ( rc != SQLITE_OK ) { 
line 103218: return rc ; 
line 103219: } 
line 103221: sqlite3_bind_text ( pStmt , 1 , zName , - 1 , SQLITE_STATIC ) ; 
line 103222: if ( SQLITE_ROW == sqlite3_step ( pStmt ) ) { 
line 103223: if ( sqlite3_column_type ( pStmt , 0 ) == SQLITE_BLOB ) { 
line 103224: memcpy ( ( void * ) pp , sqlite3_column_blob ( pStmt , 0 ) , sizeof ( * pp ) ) ; 
line 103225: } 
line 103226: } 
line 103228: return sqlite3_finalize ( pStmt ) ; 
line 103229: } 
line 103231: SQLITE_PRIVATE void sqlite3Fts3SimpleTokenizerModule ( sqlite3_tokenizer_module const * * ppModule ) ; 
line 103251: static void intTestFunc ( 
line 103252: sqlite3_context * context , 
line 103253: int argc , 
line 103254: sqlite3_value * * argv 
line 103255: ) { 
line 103256: int rc ; 
line 103257: const sqlite3_tokenizer_module * p1 ; 
line 103258: const sqlite3_tokenizer_module * p2 ; 
line 103259: sqlite3 * db = ( sqlite3 * ) sqlite3_user_data ( context ) ; 
line 103261: UNUSED_PARAMETER ( argc ) ; 
line 103262: UNUSED_PARAMETER ( argv ) ; 
line 103265: sqlite3Fts3SimpleTokenizerModule ( & p1 ) ; 
line 103266: rc = queryTokenizer ( db , "simple" , & p2 ) ; 
line 103267: assert ( rc == SQLITE_OK ) ; 
line 103268: assert ( p1 == p2 ) ; 
line 103269: rc = queryTokenizer ( db , "nosuchtokenizer" , & p2 ) ; 
line 103270: assert ( rc == SQLITE_ERROR ) ; 
line 103271: assert ( p2 == 0 ) ; 
line 103272: assert ( 0 == strcmp ( sqlite3_errmsg ( db ) , "unknown tokenizer: nosuchtokenizer" ) ) ; 
line 103275: rc = registerTokenizer ( db , "nosuchtokenizer" , p1 ) ; 
line 103276: assert ( rc == SQLITE_OK ) ; 
line 103277: rc = queryTokenizer ( db , "nosuchtokenizer" , & p2 ) ; 
line 103278: assert ( rc == SQLITE_OK ) ; 
line 103279: assert ( p2 == p1 ) ; 
line 103281: sqlite3_result_text ( context , "ok" , - 1 , SQLITE_STATIC ) ; 
line 103282: } 
line 103284: # endif 
line 103303: SQLITE_PRIVATE int sqlite3Fts3InitHashTable ( 
line 103304: sqlite3 * db , 
line 103305: Fts3Hash * pHash , 
line 103306: const char * zName 
line 103307: ) { 
line 103308: int rc = SQLITE_OK ; 
line 103309: void * p = ( void * ) pHash ; 
line 103310: const int any = SQLITE_ANY ; 
line 103312: # ifdef SQLITE_TEST 
line 103313: char * zTest = 0 ; 
line 103314: char * zTest2 = 0 ; 
line 103315: void * pdb = ( void * ) db ; 
line 103316: zTest = sqlite3_mprintf ( "%s_test" , zName ) ; 
line 103317: zTest2 = sqlite3_mprintf ( "%s_internal_test" , zName ) ; 
line 103318: if ( ! zTest || ! zTest2 ) { 
line 103319: rc = SQLITE_NOMEM ; 
line 103320: } 
line 103321: # endif 
line 103323: if ( SQLITE_OK != rc 
line 103324: || SQLITE_OK != ( rc = sqlite3_create_function ( db , zName , 1 , any , p , scalarFunc , 0 , 0 ) ) 
line 103325: || SQLITE_OK != ( rc = sqlite3_create_function ( db , zName , 2 , any , p , scalarFunc , 0 , 0 ) ) 
line 103326: # ifdef SQLITE_TEST 
line 103327: || SQLITE_OK != ( rc = sqlite3_create_function ( db , zTest , 2 , any , p , testFunc , 0 , 0 ) ) 
line 103328: || SQLITE_OK != ( rc = sqlite3_create_function ( db , zTest , 3 , any , p , testFunc , 0 , 0 ) ) 
line 103329: || SQLITE_OK != ( rc = sqlite3_create_function ( db , zTest2 , 0 , any , pdb , intTestFunc , 0 , 0 ) ) 
line 103330: # endif 
line 103331: ) ; 
line 103333: # ifdef SQLITE_TEST 
line 103334: sqlite3_free ( zTest ) ; 
line 103335: sqlite3_free ( zTest2 ) ; 
line 103336: # endif 
line 103338: return rc ; 
line 103339: } 
line 103341: # endif 
line 103369: # if ! defined ( SQLITE_CORE ) || defined ( SQLITE_ENABLE_FTS3 ) 
line 103374: typedef struct simple_tokenizer { 
line 103375: sqlite3_tokenizer base ; 
line 103376: char delim [ 128 ] ; 
line 103377: } simple_tokenizer ; 
line 103379: typedef struct simple_tokenizer_cursor { 
line 103380: sqlite3_tokenizer_cursor base ; 
line 103381: const char * pInput ; 
line 103382: int nBytes ; 
line 103383: int iOffset ; 
line 103384: int iToken ; 
line 103385: char * pToken ; 
line 103386: int nTokenAllocated ; 
line 103387: } simple_tokenizer_cursor ; 
line 103390: static int simpleDelim ( simple_tokenizer * t , unsigned char c ) { 
line 103391: return c < 0x80 && t -> delim [ c ] ; 
line 103392: } 
line 103397: static int simpleCreate ( 
line 103398: int argc , const char * const * argv , 
line 103399: sqlite3_tokenizer * * ppTokenizer 
line 103400: ) { 
line 103401: simple_tokenizer * t ; 
line 103403: t = ( simple_tokenizer * ) sqlite3_malloc ( sizeof ( * t ) ) ; 
line 103404: if ( t == NULL ) return SQLITE_NOMEM ; 
line 103405: memset ( t , 0 , sizeof ( * t ) ) ; 
line 103412: if ( argc > 1 ) { 
line 103413: int i , n = ( int ) strlen ( argv [ 1 ] ) ; 
line 103414: for ( i = 0 ; i < n ; i ++ ) { 
line 103415: unsigned char ch = argv [ 1 ] [ i ] ; 
line 103417: if ( ch >= 0x80 ) { 
line 103418: sqlite3_free ( t ) ; 
line 103419: return SQLITE_ERROR ; 
line 103420: } 
line 103421: t -> delim [ ch ] = 1 ; 
line 103422: } 
line 103423: } else { 
line 103425: int i ; 
line 103426: for ( i = 1 ; i < 0x80 ; i ++ ) { 
line 103427: t -> delim [ i ] = ! isalnum ( i ) ? - 1 : 0 ; 
line 103428: } 
line 103429: } 
line 103431: * ppTokenizer = & t -> base ; 
line 103432: return SQLITE_OK ; 
line 103433: } 
line 103438: static int simpleDestroy ( sqlite3_tokenizer * pTokenizer ) { 
line 103439: sqlite3_free ( pTokenizer ) ; 
line 103440: return SQLITE_OK ; 
line 103441: } 
line 103449: static int simpleOpen ( 
line 103450: sqlite3_tokenizer * pTokenizer , 
line 103451: const char * pInput , int nBytes , 
line 103452: sqlite3_tokenizer_cursor * * ppCursor 
line 103453: ) { 
line 103454: simple_tokenizer_cursor * c ; 
line 103456: UNUSED_PARAMETER ( pTokenizer ) ; 
line 103458: c = ( simple_tokenizer_cursor * ) sqlite3_malloc ( sizeof ( * c ) ) ; 
line 103459: if ( c == NULL ) return SQLITE_NOMEM ; 
line 103461: c -> pInput = pInput ; 
line 103462: if ( pInput == 0 ) { 
line 103463: c -> nBytes = 0 ; 
line 103464: } else if ( nBytes < 0 ) { 
line 103465: c -> nBytes = ( int ) strlen ( pInput ) ; 
line 103466: } else { 
line 103467: c -> nBytes = nBytes ; 
line 103468: } 
line 103469: c -> iOffset = 0 ; 
line 103470: c -> iToken = 0 ; 
line 103471: c -> pToken = NULL ; 
line 103472: c -> nTokenAllocated = 0 ; 
line 103474: * ppCursor = & c -> base ; 
line 103475: return SQLITE_OK ; 
line 103476: } 
line 103482: static int simpleClose ( sqlite3_tokenizer_cursor * pCursor ) { 
line 103483: simple_tokenizer_cursor * c = ( simple_tokenizer_cursor * ) pCursor ; 
line 103484: sqlite3_free ( c -> pToken ) ; 
line 103485: sqlite3_free ( c ) ; 
line 103486: return SQLITE_OK ; 
line 103487: } 
line 103493: static int simpleNext ( 
line 103494: sqlite3_tokenizer_cursor * pCursor , 
line 103495: const char * * ppToken , 
line 103496: int * pnBytes , 
line 103497: int * piStartOffset , 
line 103498: int * piEndOffset , 
line 103499: int * piPosition 
line 103500: ) { 
line 103501: simple_tokenizer_cursor * c = ( simple_tokenizer_cursor * ) pCursor ; 
line 103502: simple_tokenizer * t = ( simple_tokenizer * ) pCursor -> pTokenizer ; 
line 103503: unsigned char * p = ( unsigned char * ) c -> pInput ; 
line 103505: while ( c -> iOffset < c -> nBytes ) { 
line 103506: int iStartOffset ; 
line 103509: while ( c -> iOffset < c -> nBytes && simpleDelim ( t , p [ c -> iOffset ] ) ) { 
line 103510: c -> iOffset ++ ; 
line 103511: } 
line 103514: iStartOffset = c -> iOffset ; 
line 103515: while ( c -> iOffset < c -> nBytes && ! simpleDelim ( t , p [ c -> iOffset ] ) ) { 
line 103516: c -> iOffset ++ ; 
line 103517: } 
line 103519: if ( c -> iOffset > iStartOffset ) { 
line 103520: int i , n = c -> iOffset - iStartOffset ; 
line 103521: if ( n > c -> nTokenAllocated ) { 
line 103522: c -> nTokenAllocated = n + 20 ; 
line 103523: c -> pToken = sqlite3_realloc ( c -> pToken , c -> nTokenAllocated ) ; 
line 103524: if ( c -> pToken == NULL ) return SQLITE_NOMEM ; 
line 103525: } 
line 103526: for ( i = 0 ; i < n ; i ++ ) { 
line 103530: unsigned char ch = p [ iStartOffset + i ] ; 
line 103531: c -> pToken [ i ] = ( char ) ( ch < 0x80 ? tolower ( ch ) : ch ) ; 
line 103532: } 
line 103533: * ppToken = c -> pToken ; 
line 103534: * pnBytes = n ; 
line 103535: * piStartOffset = iStartOffset ; 
line 103536: * piEndOffset = c -> iOffset ; 
line 103537: * piPosition = c -> iToken ++ ; 
line 103539: return SQLITE_OK ; 
line 103540: } 
line 103541: } 
line 103542: return SQLITE_DONE ; 
line 103543: } 
line 103548: static const sqlite3_tokenizer_module simpleTokenizerModule = { 
line 103549: 0 , 
line 103550: simpleCreate , 
line 103551: simpleDestroy , 
line 103552: simpleOpen , 
line 103553: simpleClose , 
line 103554: simpleNext , 
line 103555: } ; 
line 103561: SQLITE_PRIVATE void sqlite3Fts3SimpleTokenizerModule ( 
line 103562: sqlite3_tokenizer_module const * * ppModule 
line 103563: ) { 
line 103564: * ppModule = & simpleTokenizerModule ; 
line 103565: } 
line 103567: # endif 
line 103590: # if ! defined ( SQLITE_CORE ) || defined ( SQLITE_ENABLE_FTS3 ) 
line 103593: typedef struct PendingList PendingList ; 
line 103594: typedef struct SegmentNode SegmentNode ; 
line 103595: typedef struct SegmentWriter SegmentWriter ; 
line 103602: struct PendingList { 
line 103603: int nData ; 
line 103604: char * aData ; 
line 103605: int nSpace ; 
line 103606: sqlite3_int64 iLastDocid ; 
line 103607: sqlite3_int64 iLastCol ; 
line 103608: sqlite3_int64 iLastPos ; 
line 103609: } ; 
line 103628: struct Fts3SegReader { 
line 103629: int iIdx ; 
line 103630: sqlite3_int64 iStartBlock ; 
line 103631: sqlite3_int64 iEndBlock ; 
line 103632: sqlite3_stmt * pStmt ; 
line 103633: char * aNode ; 
line 103634: int nNode ; 
line 103635: int nTermAlloc ; 
line 103636: Fts3HashElem * * ppNextElem ; 
line 103643: int nTerm ; 
line 103644: char * zTerm ; 
line 103645: char * aDoclist ; 
line 103646: int nDoclist ; 
line 103649: char * pOffsetList ; 
line 103650: sqlite3_int64 iDocid ; 
line 103651: } ; 
line 103653: # define fts3SegReaderIsPending ( p ) ( ( p ) -> ppNextElem != 0 ) 
line 103664: struct SegmentWriter { 
line 103665: SegmentNode * pTree ; 
line 103666: sqlite3_int64 iFirst ; 
line 103667: sqlite3_int64 iFree ; 
line 103668: char * zTerm ; 
line 103669: int nTerm ; 
line 103670: int nMalloc ; 
line 103671: char * zMalloc ; 
line 103672: int nSize ; 
line 103673: int nData ; 
line 103674: char * aData ; 
line 103675: } ; 
line 103687: struct SegmentNode { 
line 103688: SegmentNode * pParent ; 
line 103689: SegmentNode * pRight ; 
line 103690: SegmentNode * pLeftmost ; 
line 103691: int nEntry ; 
line 103692: char * zTerm ; 
line 103693: int nTerm ; 
line 103694: int nMalloc ; 
line 103695: char * zMalloc ; 
line 103696: int nData ; 
line 103697: char * aData ; 
line 103698: } ; 
line 103703: # define SQL_DELETE_CONTENT 0 
line 103704: # define SQL_IS_EMPTY 1 
line 103705: # define SQL_DELETE_ALL_CONTENT 2 
line 103706: # define SQL_DELETE_ALL_SEGMENTS 3 
line 103707: # define SQL_DELETE_ALL_SEGDIR 4 
line 103708: # define SQL_SELECT_CONTENT_BY_ROWID 5 
line 103709: # define SQL_NEXT_SEGMENT_INDEX 6 
line 103710: # define SQL_INSERT_SEGMENTS 7 
line 103711: # define SQL_NEXT_SEGMENTS_ID 8 
line 103712: # define SQL_INSERT_SEGDIR 9 
line 103713: # define SQL_SELECT_LEVEL 10 
line 103714: # define SQL_SELECT_ALL_LEVEL 11 
line 103715: # define SQL_SELECT_LEVEL_COUNT 12 
line 103716: # define SQL_SELECT_SEGDIR_COUNT_MAX 13 
line 103717: # define SQL_DELETE_SEGDIR_BY_LEVEL 14 
line 103718: # define SQL_DELETE_SEGMENTS_RANGE 15 
line 103719: # define SQL_CONTENT_INSERT 16 
line 103720: # define SQL_GET_BLOCK 17 
line 103733: static int fts3SqlStmt ( 
line 103734: Fts3Table * p , 
line 103735: int eStmt , 
line 103736: sqlite3_stmt * * pp , 
line 103737: sqlite3_value * * apVal 
line 103738: ) { 
line 103739: const char * azSql [ ] = { 
line 103740: "DELETE FROM %Q.'%q_content' WHERE rowid = ?" , 
line 103741: "SELECT NOT EXISTS(SELECT docid FROM %Q.'%q_content' WHERE rowid!=?)" , 
line 103742: "DELETE FROM %Q.'%q_content'" , 
line 103743: "DELETE FROM %Q.'%q_segments'" , 
line 103744: "DELETE FROM %Q.'%q_segdir'" , 
line 103745: "SELECT * FROM %Q.'%q_content' WHERE rowid=?" , 
line 103746: "SELECT coalesce(max(idx)+1, 0) FROM %Q.'%q_segdir' WHERE level=?" , 
line 103747: "INSERT INTO %Q.'%q_segments'(blockid, block) VALUES(?, ?)" , 
line 103748: "SELECT coalesce(max(blockid)+1, 1) FROM %Q.'%q_segments'" , 
line 103749: "INSERT INTO %Q.'%q_segdir' VALUES(?,?,?,?,?,?)" , 
line 103752: "SELECT idx, start_block, leaves_end_block, end_block, root " 
line 103753: "FROM %Q.'%q_segdir' WHERE level = ? ORDER BY idx ASC" , 
line 103754: "SELECT idx, start_block, leaves_end_block, end_block, root " 
line 103755: "FROM %Q.'%q_segdir' ORDER BY level DESC, idx ASC" , 
line 103757: "SELECT count(*) FROM %Q.'%q_segdir' WHERE level = ?" , 
line 103758: "SELECT count(*), max(level) FROM %Q.'%q_segdir'" , 
line 103760: "DELETE FROM %Q.'%q_segdir' WHERE level = ?" , 
line 103761: "DELETE FROM %Q.'%q_segments' WHERE blockid BETWEEN ? AND ?" , 
line 103762: "INSERT INTO %Q.'%q_content' VALUES(%z)" , 
line 103763: "SELECT block FROM %Q.'%q_segments' WHERE blockid = ?" , 
line 103764: } ; 
line 103765: int rc = SQLITE_OK ; 
line 103766: sqlite3_stmt * pStmt ; 
line 103768: assert ( SizeofArray ( azSql ) == SizeofArray ( p -> aStmt ) ) ; 
line 103769: assert ( eStmt < SizeofArray ( azSql ) && eStmt >= 0 ) ; 
line 103771: pStmt = p -> aStmt [ eStmt ] ; 
line 103772: if ( ! pStmt ) { 
line 103773: char * zSql ; 
line 103774: if ( eStmt == SQL_CONTENT_INSERT ) { 
line 103775: int i ; 
line 103776: char * zVarlist ; 
line 103777: zVarlist = ( char * ) sqlite3_malloc ( 2 * p -> nColumn + 2 ) ; 
line 103778: if ( ! zVarlist ) { 
line 103779: * pp = 0 ; 
line 103780: return SQLITE_NOMEM ; 
line 103781: } 
line 103782: zVarlist [ 0 ] = '?' ; 
line 103783: zVarlist [ p -> nColumn * 2 + 1 ] = '\0' ; 
line 103784: for ( i = 1 ; i <= p -> nColumn ; i ++ ) { 
line 103785: zVarlist [ i * 2 - 1 ] = ',' ; 
line 103786: zVarlist [ i * 2 ] = '?' ; 
line 103787: } 
line 103788: zSql = sqlite3_mprintf ( azSql [ eStmt ] , p -> zDb , p -> zName , zVarlist ) ; 
line 103789: } else { 
line 103790: zSql = sqlite3_mprintf ( azSql [ eStmt ] , p -> zDb , p -> zName ) ; 
line 103791: } 
line 103792: if ( ! zSql ) { 
line 103793: rc = SQLITE_NOMEM ; 
line 103794: } else { 
line 103795: rc = sqlite3_prepare_v2 ( p -> db , zSql , - 1 , & pStmt , NULL ) ; 
line 103796: sqlite3_free ( zSql ) ; 
line 103797: assert ( rc == SQLITE_OK || pStmt == 0 ) ; 
line 103798: p -> aStmt [ eStmt ] = pStmt ; 
line 103799: } 
line 103800: } 
line 103801: if ( apVal ) { 
line 103802: int i ; 
line 103803: int nParam = sqlite3_bind_parameter_count ( pStmt ) ; 
line 103804: for ( i = 0 ; rc == SQLITE_OK && i < nParam ; i ++ ) { 
line 103805: rc = sqlite3_bind_value ( pStmt , i + 1 , apVal [ i ] ) ; 
line 103806: } 
line 103807: } 
line 103808: * pp = pStmt ; 
line 103809: return rc ; 
line 103810: } 
line 103820: static int fts3SqlExec ( Fts3Table * p , int eStmt , sqlite3_value * * apVal ) { 
line 103821: sqlite3_stmt * pStmt ; 
line 103822: int rc = fts3SqlStmt ( p , eStmt , & pStmt , apVal ) ; 
line 103823: if ( rc == SQLITE_OK ) { 
line 103824: sqlite3_step ( pStmt ) ; 
line 103825: rc = sqlite3_reset ( pStmt ) ; 
line 103826: } 
line 103827: return rc ; 
line 103828: } 
line 103843: SQLITE_PRIVATE int sqlite3Fts3ReadBlock ( 
line 103844: Fts3Table * p , 
line 103845: sqlite3_int64 iBlock , 
line 103846: char const * * pzBlock , 
line 103847: int * pnBlock 
line 103848: ) { 
line 103849: sqlite3_stmt * pStmt ; 
line 103850: int rc = fts3SqlStmt ( p , SQL_GET_BLOCK , & pStmt , 0 ) ; 
line 103851: if ( rc != SQLITE_OK ) return rc ; 
line 103852: sqlite3_reset ( pStmt ) ; 
line 103854: if ( pzBlock ) { 
line 103855: sqlite3_bind_int64 ( pStmt , 1 , iBlock ) ; 
line 103856: rc = sqlite3_step ( pStmt ) ; 
line 103857: if ( rc != SQLITE_ROW ) { 
line 103858: return ( rc == SQLITE_DONE ? SQLITE_CORRUPT : rc ) ; 
line 103859: } 
line 103861: * pnBlock = sqlite3_column_bytes ( pStmt , 0 ) ; 
line 103862: * pzBlock = ( char * ) sqlite3_column_blob ( pStmt , 0 ) ; 
line 103863: if ( sqlite3_column_type ( pStmt , 0 ) != SQLITE_BLOB ) { 
line 103864: return SQLITE_CORRUPT ; 
line 103865: } 
line 103866: } 
line 103867: return SQLITE_OK ; 
line 103868: } 
line 103887: SQLITE_PRIVATE int sqlite3Fts3AllSegdirs ( Fts3Table * p , sqlite3_stmt * * ppStmt ) { 
line 103888: return fts3SqlStmt ( p , SQL_SELECT_ALL_LEVEL , ppStmt , 0 ) ; 
line 103889: } 
line 103904: static int fts3PendingListAppendVarint ( 
line 103905: PendingList * * pp , 
line 103906: sqlite3_int64 i 
line 103907: ) { 
line 103908: PendingList * p = * pp ; 
line 103911: if ( ! p ) { 
line 103912: p = sqlite3_malloc ( sizeof ( * p ) + 100 ) ; 
line 103913: if ( ! p ) { 
line 103914: return SQLITE_NOMEM ; 
line 103915: } 
line 103916: p -> nSpace = 100 ; 
line 103917: p -> aData = ( char * ) & p [ 1 ] ; 
line 103918: p -> nData = 0 ; 
line 103919: } 
line 103920: else if ( p -> nData + FTS3_VARINT_MAX + 1 > p -> nSpace ) { 
line 103921: int nNew = p -> nSpace * 2 ; 
line 103922: p = sqlite3_realloc ( p , sizeof ( * p ) + nNew ) ; 
line 103923: if ( ! p ) { 
line 103924: sqlite3_free ( * pp ) ; 
line 103925: * pp = 0 ; 
line 103926: return SQLITE_NOMEM ; 
line 103927: } 
line 103928: p -> nSpace = nNew ; 
line 103929: p -> aData = ( char * ) & p [ 1 ] ; 
line 103930: } 
line 103933: p -> nData += sqlite3Fts3PutVarint ( & p -> aData [ p -> nData ] , i ) ; 
line 103934: p -> aData [ p -> nData ] = '\0' ; 
line 103935: * pp = p ; 
line 103936: return SQLITE_OK ; 
line 103937: } 
line 103948: static int fts3PendingListAppend ( 
line 103949: PendingList * * pp , 
line 103950: sqlite3_int64 iDocid , 
line 103951: sqlite3_int64 iCol , 
line 103952: sqlite3_int64 iPos , 
line 103953: int * pRc 
line 103954: ) { 
line 103955: PendingList * p = * pp ; 
line 103956: int rc = SQLITE_OK ; 
line 103958: assert ( ! p || p -> iLastDocid <= iDocid ) ; 
line 103960: if ( ! p || p -> iLastDocid != iDocid ) { 
line 103961: sqlite3_int64 iDelta = iDocid - ( p ? p -> iLastDocid : 0 ) ; 
line 103962: if ( p ) { 
line 103963: assert ( p -> nData < p -> nSpace ) ; 
line 103964: assert ( p -> aData [ p -> nData ] == 0 ) ; 
line 103965: p -> nData ++ ; 
line 103966: } 
line 103967: if ( SQLITE_OK != ( rc = fts3PendingListAppendVarint ( & p , iDelta ) ) ) { 
line 103968: goto pendinglistappend_out ; 
line 103969: } 
line 103970: p -> iLastCol = - 1 ; 
line 103971: p -> iLastPos = 0 ; 
line 103972: p -> iLastDocid = iDocid ; 
line 103973: } 
line 103974: if ( iCol > 0 && p -> iLastCol != iCol ) { 
line 103975: if ( SQLITE_OK != ( rc = fts3PendingListAppendVarint ( & p , 1 ) ) 
line 103976: || SQLITE_OK != ( rc = fts3PendingListAppendVarint ( & p , iCol ) ) 
line 103977: ) { 
line 103978: goto pendinglistappend_out ; 
line 103979: } 
line 103980: p -> iLastCol = iCol ; 
line 103981: p -> iLastPos = 0 ; 
line 103982: } 
line 103983: if ( iCol >= 0 ) { 
line 103984: assert ( iPos > p -> iLastPos || ( iPos == 0 && p -> iLastPos == 0 ) ) ; 
line 103985: rc = fts3PendingListAppendVarint ( & p , 2 + iPos - p -> iLastPos ) ; 
line 103986: if ( rc == SQLITE_OK ) { 
line 103987: p -> iLastPos = iPos ; 
line 103988: } 
line 103989: } 
line 103991: pendinglistappend_out : 
line 103992: * pRc = rc ; 
line 103993: if ( p != * pp ) { 
line 103994: * pp = p ; 
line 103995: return 1 ; 
line 103996: } 
line 103997: return 0 ; 
line 103998: } 
line 104007: static int fts3PendingTermsAdd ( Fts3Table * p , const char * zText , int iCol ) { 
line 104008: int rc ; 
line 104009: int iStart ; 
line 104010: int iEnd ; 
line 104011: int iPos ; 
line 104013: char const * zToken ; 
line 104014: int nToken ; 
line 104016: sqlite3_tokenizer * pTokenizer = p -> pTokenizer ; 
line 104017: sqlite3_tokenizer_module const * pModule = pTokenizer -> pModule ; 
line 104018: sqlite3_tokenizer_cursor * pCsr ; 
line 104019: int ( * xNext ) ( sqlite3_tokenizer_cursor * pCursor , 
line 104020: const char * * , int * , int * , int * , int * ) ; 
line 104022: assert ( pTokenizer && pModule ) ; 
line 104024: rc = pModule -> xOpen ( pTokenizer , zText , - 1 , & pCsr ) ; 
line 104025: if ( rc != SQLITE_OK ) { 
line 104026: return rc ; 
line 104027: } 
line 104028: pCsr -> pTokenizer = pTokenizer ; 
line 104030: xNext = pModule -> xNext ; 
line 104031: while ( SQLITE_OK == rc 
line 104032: && SQLITE_OK == ( rc = xNext ( pCsr , & zToken , & nToken , & iStart , & iEnd , & iPos ) ) 
line 104033: ) { 
line 104034: PendingList * pList ; 
line 104039: if ( iPos < 0 || ! zToken || nToken <= 0 ) { 
line 104040: rc = SQLITE_ERROR ; 
line 104041: break ; 
line 104042: } 
line 104044: pList = ( PendingList * ) fts3HashFind ( & p -> pendingTerms , zToken , nToken ) ; 
line 104045: if ( pList ) { 
line 104046: p -> nPendingData -= ( pList -> nData + nToken + sizeof ( Fts3HashElem ) ) ; 
line 104047: } 
line 104048: if ( fts3PendingListAppend ( & pList , p -> iPrevDocid , iCol , iPos , & rc ) ) { 
line 104049: if ( pList == fts3HashInsert ( & p -> pendingTerms , zToken , nToken , pList ) ) { 
line 104053: assert ( 0 == fts3HashFind ( & p -> pendingTerms , zToken , nToken ) ) ; 
line 104054: sqlite3_free ( pList ) ; 
line 104055: rc = SQLITE_NOMEM ; 
line 104056: } 
line 104057: } 
line 104058: if ( rc == SQLITE_OK ) { 
line 104059: p -> nPendingData += ( pList -> nData + nToken + sizeof ( Fts3HashElem ) ) ; 
line 104060: } 
line 104061: } 
line 104063: pModule -> xClose ( pCsr ) ; 
line 104064: return ( rc == SQLITE_DONE ? SQLITE_OK : rc ) ; 
line 104065: } 
line 104072: static int fts3PendingTermsDocid ( Fts3Table * p , sqlite_int64 iDocid ) { 
line 104079: if ( iDocid <= p -> iPrevDocid || p -> nPendingData > p -> nMaxPendingData ) { 
line 104080: int rc = sqlite3Fts3PendingTermsFlush ( p ) ; 
line 104081: if ( rc != SQLITE_OK ) return rc ; 
line 104082: } 
line 104083: p -> iPrevDocid = iDocid ; 
line 104084: return SQLITE_OK ; 
line 104085: } 
line 104087: SQLITE_PRIVATE void sqlite3Fts3PendingTermsClear ( Fts3Table * p ) { 
line 104088: Fts3HashElem * pElem ; 
line 104089: for ( pElem = fts3HashFirst ( & p -> pendingTerms ) ; pElem ; pElem = fts3HashNext ( pElem ) ) { 
line 104090: sqlite3_free ( fts3HashData ( pElem ) ) ; 
line 104091: } 
line 104092: fts3HashClear ( & p -> pendingTerms ) ; 
line 104093: p -> nPendingData = 0 ; 
line 104094: } 
line 104104: static int fts3InsertTerms ( Fts3Table * p , sqlite3_value * * apVal ) { 
line 104105: int i ; 
line 104106: for ( i = 2 ; i < p -> nColumn + 2 ; i ++ ) { 
line 104107: const char * zText = ( const char * ) sqlite3_value_text ( apVal [ i ] ) ; 
line 104108: if ( zText ) { 
line 104109: int rc = fts3PendingTermsAdd ( p , zText , i - 2 ) ; 
line 104110: if ( rc != SQLITE_OK ) { 
line 104111: return rc ; 
line 104112: } 
line 104113: } 
line 104114: } 
line 104115: return SQLITE_OK ; 
line 104116: } 
line 104131: static int fts3InsertData ( 
line 104132: Fts3Table * p , 
line 104133: sqlite3_value * * apVal , 
line 104134: sqlite3_int64 * piDocid 
line 104135: ) { 
line 104136: int rc ; 
line 104137: sqlite3_stmt * pContentInsert ; 
line 104147: rc = fts3SqlStmt ( p , SQL_CONTENT_INSERT , & pContentInsert , & apVal [ 1 ] ) ; 
line 104148: if ( rc != SQLITE_OK ) { 
line 104149: return rc ; 
line 104150: } 
line 104162: if ( SQLITE_NULL != sqlite3_value_type ( apVal [ 3 + p -> nColumn ] ) ) { 
line 104163: if ( SQLITE_NULL == sqlite3_value_type ( apVal [ 0 ] ) 
line 104164: && SQLITE_NULL != sqlite3_value_type ( apVal [ 1 ] ) 
line 104165: ) { 
line 104167: return SQLITE_ERROR ; 
line 104168: } 
line 104169: rc = sqlite3_bind_value ( pContentInsert , 1 , apVal [ 3 + p -> nColumn ] ) ; 
line 104170: if ( rc != SQLITE_OK ) return rc ; 
line 104171: } 
line 104176: sqlite3_step ( pContentInsert ) ; 
line 104177: rc = sqlite3_reset ( pContentInsert ) ; 
line 104179: * piDocid = sqlite3_last_insert_rowid ( p -> db ) ; 
line 104180: return rc ; 
line 104181: } 
line 104189: static int fts3DeleteAll ( Fts3Table * p ) { 
line 104190: int rc ; 
line 104193: sqlite3Fts3PendingTermsClear ( p ) ; 
line 104196: rc = fts3SqlExec ( p , SQL_DELETE_ALL_CONTENT , 0 ) ; 
line 104197: if ( rc == SQLITE_OK ) { 
line 104198: rc = fts3SqlExec ( p , SQL_DELETE_ALL_SEGMENTS , 0 ) ; 
line 104199: } 
line 104200: if ( rc == SQLITE_OK ) { 
line 104201: rc = fts3SqlExec ( p , SQL_DELETE_ALL_SEGDIR , 0 ) ; 
line 104202: } 
line 104203: return rc ; 
line 104204: } 
line 104211: static int fts3DeleteTerms ( Fts3Table * p , sqlite3_value * * apVal ) { 
line 104212: int rc ; 
line 104213: sqlite3_stmt * pSelect ; 
line 104215: rc = fts3SqlStmt ( p , SQL_SELECT_CONTENT_BY_ROWID , & pSelect , apVal ) ; 
line 104216: if ( rc == SQLITE_OK ) { 
line 104217: if ( SQLITE_ROW == sqlite3_step ( pSelect ) ) { 
line 104218: int i ; 
line 104219: for ( i = 1 ; i <= p -> nColumn ; i ++ ) { 
line 104220: const char * zText = ( const char * ) sqlite3_column_text ( pSelect , i ) ; 
line 104221: rc = fts3PendingTermsAdd ( p , zText , - 1 ) ; 
line 104222: if ( rc != SQLITE_OK ) { 
line 104223: sqlite3_reset ( pSelect ) ; 
line 104224: return rc ; 
line 104225: } 
line 104226: } 
line 104227: } 
line 104228: rc = sqlite3_reset ( pSelect ) ; 
line 104229: } else { 
line 104230: sqlite3_reset ( pSelect ) ; 
line 104231: } 
line 104232: return rc ; 
line 104233: } 
line 104239: static int fts3SegmentMerge ( Fts3Table * , int ) ; 
line 104256: static int fts3AllocateSegdirIdx ( Fts3Table * p , int iLevel , int * piIdx ) { 
line 104257: int rc ; 
line 104258: sqlite3_stmt * pNextIdx ; 
line 104259: int iNext = 0 ; 
line 104262: rc = fts3SqlStmt ( p , SQL_NEXT_SEGMENT_INDEX , & pNextIdx , 0 ) ; 
line 104263: if ( rc == SQLITE_OK ) { 
line 104264: sqlite3_bind_int ( pNextIdx , 1 , iLevel ) ; 
line 104265: if ( SQLITE_ROW == sqlite3_step ( pNextIdx ) ) { 
line 104266: iNext = sqlite3_column_int ( pNextIdx , 0 ) ; 
line 104267: } 
line 104268: rc = sqlite3_reset ( pNextIdx ) ; 
line 104269: } 
line 104271: if ( rc == SQLITE_OK ) { 
line 104277: if ( iNext >= FTS3_MERGE_COUNT ) { 
line 104278: rc = fts3SegmentMerge ( p , iLevel ) ; 
line 104279: * piIdx = 0 ; 
line 104280: } else { 
line 104281: * piIdx = iNext ; 
line 104282: } 
line 104283: } 
line 104285: return rc ; 
line 104286: } 
line 104293: static int fts3SegReaderNext ( Fts3SegReader * pReader ) { 
line 104294: char * pNext ; 
line 104295: int nPrefix ; 
line 104296: int nSuffix ; 
line 104298: if ( ! pReader -> aDoclist ) { 
line 104299: pNext = pReader -> aNode ; 
line 104300: } else { 
line 104301: pNext = & pReader -> aDoclist [ pReader -> nDoclist ] ; 
line 104302: } 
line 104304: if ( ! pNext || pNext >= & pReader -> aNode [ pReader -> nNode ] ) { 
line 104305: int rc ; 
line 104306: if ( fts3SegReaderIsPending ( pReader ) ) { 
line 104307: Fts3HashElem * pElem = * ( pReader -> ppNextElem ) ; 
line 104308: if ( pElem == 0 ) { 
line 104309: pReader -> aNode = 0 ; 
line 104310: } else { 
line 104311: PendingList * pList = ( PendingList * ) fts3HashData ( pElem ) ; 
line 104312: pReader -> zTerm = ( char * ) fts3HashKey ( pElem ) ; 
line 104313: pReader -> nTerm = fts3HashKeysize ( pElem ) ; 
line 104314: pReader -> nNode = pReader -> nDoclist = pList -> nData + 1 ; 
line 104315: pReader -> aNode = pReader -> aDoclist = pList -> aData ; 
line 104316: pReader -> ppNextElem ++ ; 
line 104317: assert ( pReader -> aNode ) ; 
line 104318: } 
line 104319: return SQLITE_OK ; 
line 104320: } 
line 104321: if ( ! pReader -> pStmt ) { 
line 104322: pReader -> aNode = 0 ; 
line 104323: return SQLITE_OK ; 
line 104324: } 
line 104325: rc = sqlite3_step ( pReader -> pStmt ) ; 
line 104326: if ( rc != SQLITE_ROW ) { 
line 104327: pReader -> aNode = 0 ; 
line 104328: return ( rc == SQLITE_DONE ? SQLITE_OK : rc ) ; 
line 104329: } 
line 104330: pReader -> nNode = sqlite3_column_bytes ( pReader -> pStmt , 0 ) ; 
line 104331: pReader -> aNode = ( char * ) sqlite3_column_blob ( pReader -> pStmt , 0 ) ; 
line 104332: pNext = pReader -> aNode ; 
line 104333: } 
line 104335: pNext += sqlite3Fts3GetVarint32 ( pNext , & nPrefix ) ; 
line 104336: pNext += sqlite3Fts3GetVarint32 ( pNext , & nSuffix ) ; 
line 104338: if ( nPrefix + nSuffix > pReader -> nTermAlloc ) { 
line 104339: int nNew = ( nPrefix + nSuffix ) * 2 ; 
line 104340: char * zNew = sqlite3_realloc ( pReader -> zTerm , nNew ) ; 
line 104341: if ( ! zNew ) { 
line 104342: return SQLITE_NOMEM ; 
line 104343: } 
line 104344: pReader -> zTerm = zNew ; 
line 104345: pReader -> nTermAlloc = nNew ; 
line 104346: } 
line 104347: memcpy ( & pReader -> zTerm [ nPrefix ] , pNext , nSuffix ) ; 
line 104348: pReader -> nTerm = nPrefix + nSuffix ; 
line 104349: pNext += nSuffix ; 
line 104350: pNext += sqlite3Fts3GetVarint32 ( pNext , & pReader -> nDoclist ) ; 
line 104351: assert ( pNext < & pReader -> aNode [ pReader -> nNode ] ) ; 
line 104352: pReader -> aDoclist = pNext ; 
line 104353: pReader -> pOffsetList = 0 ; 
line 104354: return SQLITE_OK ; 
line 104355: } 
line 104361: static void fts3SegReaderFirstDocid ( Fts3SegReader * pReader ) { 
line 104362: int n ; 
line 104363: assert ( pReader -> aDoclist ) ; 
line 104364: assert ( ! pReader -> pOffsetList ) ; 
line 104365: n = sqlite3Fts3GetVarint ( pReader -> aDoclist , & pReader -> iDocid ) ; 
line 104366: pReader -> pOffsetList = & pReader -> aDoclist [ n ] ; 
line 104367: } 
line 104379: static void fts3SegReaderNextDocid ( 
line 104380: Fts3SegReader * pReader , 
line 104381: char * * ppOffsetList , 
line 104382: int * pnOffsetList 
line 104383: ) { 
line 104384: char * p = pReader -> pOffsetList ; 
line 104385: char c = 0 ; 
line 104391: while ( * p | c ) c = * p ++ & 0x80 ; 
line 104392: p ++ ; 
line 104397: if ( ppOffsetList ) { 
line 104398: * ppOffsetList = pReader -> pOffsetList ; 
line 104399: * pnOffsetList = ( int ) ( p - pReader -> pOffsetList - 1 ) ; 
line 104400: } 
line 104407: if ( p >= & pReader -> aDoclist [ pReader -> nDoclist ] ) { 
line 104408: pReader -> pOffsetList = 0 ; 
line 104409: } else { 
line 104410: sqlite3_int64 iDelta ; 
line 104411: pReader -> pOffsetList = p + sqlite3Fts3GetVarint ( p , & iDelta ) ; 
line 104412: pReader -> iDocid += iDelta ; 
line 104413: } 
line 104414: } 
line 104420: SQLITE_PRIVATE void sqlite3Fts3SegReaderFree ( Fts3Table * p , Fts3SegReader * pReader ) { 
line 104421: if ( pReader ) { 
line 104422: if ( pReader -> pStmt ) { 
line 104426: assert ( p -> nLeavesStmt < p -> nLeavesTotal ) ; 
line 104427: sqlite3_reset ( pReader -> pStmt ) ; 
line 104428: p -> aLeavesStmt [ p -> nLeavesStmt ++ ] = pReader -> pStmt ; 
line 104429: } 
line 104430: if ( ! fts3SegReaderIsPending ( pReader ) ) { 
line 104431: sqlite3_free ( pReader -> zTerm ) ; 
line 104432: } 
line 104433: sqlite3_free ( pReader ) ; 
line 104434: } 
line 104435: } 
line 104440: SQLITE_PRIVATE int sqlite3Fts3SegReaderNew ( 
line 104441: Fts3Table * p , 
line 104442: int iAge , 
line 104443: sqlite3_int64 iStartLeaf , 
line 104444: sqlite3_int64 iEndLeaf , 
line 104445: sqlite3_int64 iEndBlock , 
line 104446: const char * zRoot , 
line 104447: int nRoot , 
line 104448: Fts3SegReader * * ppReader 
line 104449: ) { 
line 104450: int rc = SQLITE_OK ; 
line 104451: Fts3SegReader * pReader ; 
line 104452: int nExtra = 0 ; 
line 104454: if ( iStartLeaf == 0 ) { 
line 104455: nExtra = nRoot ; 
line 104456: } 
line 104458: pReader = ( Fts3SegReader * ) sqlite3_malloc ( sizeof ( Fts3SegReader ) + nExtra ) ; 
line 104459: if ( ! pReader ) { 
line 104460: return SQLITE_NOMEM ; 
line 104461: } 
line 104462: memset ( pReader , 0 , sizeof ( Fts3SegReader ) ) ; 
line 104463: pReader -> iStartBlock = iStartLeaf ; 
line 104464: pReader -> iIdx = iAge ; 
line 104465: pReader -> iEndBlock = iEndBlock ; 
line 104467: if ( nExtra ) { 
line 104469: pReader -> aNode = ( char * ) & pReader [ 1 ] ; 
line 104470: pReader -> nNode = nRoot ; 
line 104471: memcpy ( pReader -> aNode , zRoot , nRoot ) ; 
line 104472: } else { 
line 104477: if ( ! p -> zSelectLeaves ) { 
line 104478: p -> zSelectLeaves = sqlite3_mprintf ( 
line 104479: "SELECT block FROM %Q.'%q_segments' WHERE blockid BETWEEN ? AND ? " 
line 104480: "ORDER BY blockid" , p -> zDb , p -> zName 
line 104481: ) ; 
line 104482: if ( ! p -> zSelectLeaves ) { 
line 104483: rc = SQLITE_NOMEM ; 
line 104484: goto finished ; 
line 104485: } 
line 104486: } 
line 104492: if ( p -> nLeavesStmt == 0 ) { 
line 104493: if ( p -> nLeavesTotal == p -> nLeavesAlloc ) { 
line 104494: int nNew = p -> nLeavesAlloc + 16 ; 
line 104495: sqlite3_stmt * * aNew = ( sqlite3_stmt * * ) sqlite3_realloc ( 
line 104496: p -> aLeavesStmt , nNew * sizeof ( sqlite3_stmt * ) 
line 104497: ) ; 
line 104498: if ( ! aNew ) { 
line 104499: rc = SQLITE_NOMEM ; 
line 104500: goto finished ; 
line 104501: } 
line 104502: p -> nLeavesAlloc = nNew ; 
line 104503: p -> aLeavesStmt = aNew ; 
line 104504: } 
line 104505: rc = sqlite3_prepare_v2 ( p -> db , p -> zSelectLeaves , - 1 , & pReader -> pStmt , 0 ) ; 
line 104506: if ( rc != SQLITE_OK ) { 
line 104507: goto finished ; 
line 104508: } 
line 104509: p -> nLeavesTotal ++ ; 
line 104510: } else { 
line 104511: pReader -> pStmt = p -> aLeavesStmt [ -- p -> nLeavesStmt ] ; 
line 104512: } 
line 104515: sqlite3_bind_int64 ( pReader -> pStmt , 1 , iStartLeaf ) ; 
line 104516: sqlite3_bind_int64 ( pReader -> pStmt , 2 , iEndLeaf ) ; 
line 104517: } 
line 104518: rc = fts3SegReaderNext ( pReader ) ; 
line 104520: finished : 
line 104521: if ( rc == SQLITE_OK ) { 
line 104522: * ppReader = pReader ; 
line 104523: } else { 
line 104524: sqlite3Fts3SegReaderFree ( p , pReader ) ; 
line 104525: } 
line 104526: return rc ; 
line 104527: } 
line 104534: static int fts3CompareElemByTerm ( const void * lhs , const void * rhs ) { 
line 104535: char * z1 = fts3HashKey ( * ( Fts3HashElem * * ) lhs ) ; 
line 104536: char * z2 = fts3HashKey ( * ( Fts3HashElem * * ) rhs ) ; 
line 104537: int n1 = fts3HashKeysize ( * ( Fts3HashElem * * ) lhs ) ; 
line 104538: int n2 = fts3HashKeysize ( * ( Fts3HashElem * * ) rhs ) ; 
line 104540: int n = ( n1 < n2 ? n1 : n2 ) ; 
line 104541: int c = memcmp ( z1 , z2 , n ) ; 
line 104542: if ( c == 0 ) { 
line 104543: c = n1 - n2 ; 
line 104544: } 
line 104545: return c ; 
line 104546: } 
line 104552: SQLITE_PRIVATE int sqlite3Fts3SegReaderPending ( 
line 104553: Fts3Table * p , 
line 104554: const char * zTerm , 
line 104555: int nTerm , 
line 104556: int isPrefix , 
line 104557: Fts3SegReader * * ppReader 
line 104558: ) { 
line 104559: Fts3SegReader * pReader = 0 ; 
line 104560: Fts3HashElem * * aElem = 0 ; 
line 104561: int nElem = 0 ; 
line 104562: int rc = SQLITE_OK ; 
line 104564: if ( isPrefix ) { 
line 104565: int nAlloc = 0 ; 
line 104566: Fts3HashElem * pE = 0 ; 
line 104568: for ( pE = fts3HashFirst ( & p -> pendingTerms ) ; pE ; pE = fts3HashNext ( pE ) ) { 
line 104569: char * zKey = ( char * ) fts3HashKey ( pE ) ; 
line 104570: int nKey = fts3HashKeysize ( pE ) ; 
line 104571: if ( nTerm == 0 || ( nKey >= nTerm && 0 == memcmp ( zKey , zTerm , nTerm ) ) ) { 
line 104572: if ( nElem == nAlloc ) { 
line 104573: Fts3HashElem * * aElem2 ; 
line 104574: nAlloc += 16 ; 
line 104575: aElem2 = ( Fts3HashElem * * ) sqlite3_realloc ( 
line 104576: aElem , nAlloc * sizeof ( Fts3HashElem * ) 
line 104577: ) ; 
line 104578: if ( ! aElem2 ) { 
line 104579: rc = SQLITE_NOMEM ; 
line 104580: nElem = 0 ; 
line 104581: break ; 
line 104582: } 
line 104583: aElem = aElem2 ; 
line 104584: } 
line 104585: aElem [ nElem ++ ] = pE ; 
line 104586: } 
line 104587: } 
line 104593: if ( nElem > 1 ) { 
line 104594: qsort ( aElem , nElem , sizeof ( Fts3HashElem * ) , fts3CompareElemByTerm ) ; 
line 104595: } 
line 104597: } else { 
line 104598: Fts3HashElem * pE = fts3HashFindElem ( & p -> pendingTerms , zTerm , nTerm ) ; 
line 104599: if ( pE ) { 
line 104600: aElem = & pE ; 
line 104601: nElem = 1 ; 
line 104602: } 
line 104603: } 
line 104605: if ( nElem > 0 ) { 
line 104606: int nByte = sizeof ( Fts3SegReader ) + ( nElem + 1 ) * sizeof ( Fts3HashElem * ) ; 
line 104607: pReader = ( Fts3SegReader * ) sqlite3_malloc ( nByte ) ; 
line 104608: if ( ! pReader ) { 
line 104609: rc = SQLITE_NOMEM ; 
line 104610: } else { 
line 104611: memset ( pReader , 0 , nByte ) ; 
line 104612: pReader -> iIdx = 0x7FFFFFFF ; 
line 104613: pReader -> ppNextElem = ( Fts3HashElem * * ) & pReader [ 1 ] ; 
line 104614: memcpy ( pReader -> ppNextElem , aElem , nElem * sizeof ( Fts3HashElem * ) ) ; 
line 104615: fts3SegReaderNext ( pReader ) ; 
line 104616: } 
line 104617: } 
line 104619: if ( isPrefix ) { 
line 104620: sqlite3_free ( aElem ) ; 
line 104621: } 
line 104622: * ppReader = pReader ; 
line 104623: return rc ; 
line 104624: } 
line 104647: static int fts3SegReaderNew ( 
line 104648: Fts3Table * p , 
line 104649: sqlite3_stmt * pStmt , 
line 104650: int iAge , 
line 104651: Fts3SegReader * * ppReader 
line 104652: ) { 
line 104653: return sqlite3Fts3SegReaderNew ( p , iAge , 
line 104654: sqlite3_column_int64 ( pStmt , 1 ) , 
line 104655: sqlite3_column_int64 ( pStmt , 2 ) , 
line 104656: sqlite3_column_int64 ( pStmt , 3 ) , 
line 104657: sqlite3_column_blob ( pStmt , 4 ) , 
line 104658: sqlite3_column_bytes ( pStmt , 4 ) , 
line 104659: ppReader 
line 104660: ) ; 
line 104661: } 
line 104675: static int fts3SegReaderCmp ( Fts3SegReader * pLhs , Fts3SegReader * pRhs ) { 
line 104676: int rc ; 
line 104677: if ( pLhs -> aNode && pRhs -> aNode ) { 
line 104678: int rc2 = pLhs -> nTerm - pRhs -> nTerm ; 
line 104679: if ( rc2 < 0 ) { 
line 104680: rc = memcmp ( pLhs -> zTerm , pRhs -> zTerm , pLhs -> nTerm ) ; 
line 104681: } else { 
line 104682: rc = memcmp ( pLhs -> zTerm , pRhs -> zTerm , pRhs -> nTerm ) ; 
line 104683: } 
line 104684: if ( rc == 0 ) { 
line 104685: rc = rc2 ; 
line 104686: } 
line 104687: } else { 
line 104688: rc = ( pLhs -> aNode == 0 ) - ( pRhs -> aNode == 0 ) ; 
line 104689: } 
line 104690: if ( rc == 0 ) { 
line 104691: rc = pRhs -> iIdx - pLhs -> iIdx ; 
line 104692: } 
line 104693: assert ( rc != 0 ) ; 
line 104694: return rc ; 
line 104695: } 
line 104708: static int fts3SegReaderDoclistCmp ( Fts3SegReader * pLhs , Fts3SegReader * pRhs ) { 
line 104709: int rc = ( pLhs -> pOffsetList == 0 ) - ( pRhs -> pOffsetList == 0 ) ; 
line 104710: if ( rc == 0 ) { 
line 104711: if ( pLhs -> iDocid == pRhs -> iDocid ) { 
line 104712: rc = pRhs -> iIdx - pLhs -> iIdx ; 
line 104713: } else { 
line 104714: rc = ( pLhs -> iDocid > pRhs -> iDocid ) ? 1 : - 1 ; 
line 104715: } 
line 104716: } 
line 104717: assert ( pLhs -> aNode && pRhs -> aNode ) ; 
line 104718: return rc ; 
line 104719: } 
line 104729: static int fts3SegReaderTermCmp ( 
line 104730: Fts3SegReader * pSeg , 
line 104731: const char * zTerm , 
line 104732: int nTerm 
line 104733: ) { 
line 104734: int res = 0 ; 
line 104735: if ( pSeg -> aNode ) { 
line 104736: if ( pSeg -> nTerm > nTerm ) { 
line 104737: res = memcmp ( pSeg -> zTerm , zTerm , nTerm ) ; 
line 104738: } else { 
line 104739: res = memcmp ( pSeg -> zTerm , zTerm , pSeg -> nTerm ) ; 
line 104740: } 
line 104741: if ( res == 0 ) { 
line 104742: res = pSeg -> nTerm - nTerm ; 
line 104743: } 
line 104744: } 
line 104745: return res ; 
line 104746: } 
line 104754: static void fts3SegReaderSort ( 
line 104755: Fts3SegReader * * apSegment , 
line 104756: int nSegment , 
line 104757: int nSuspect , 
line 104758: int ( * xCmp ) ( Fts3SegReader * , Fts3SegReader * ) 
line 104759: ) { 
line 104760: int i ; 
line 104762: assert ( nSuspect <= nSegment ) ; 
line 104764: if ( nSuspect == nSegment ) nSuspect -- ; 
line 104765: for ( i = nSuspect - 1 ; i >= 0 ; i -- ) { 
line 104766: int j ; 
line 104767: for ( j = i ; j < ( nSegment - 1 ) ; j ++ ) { 
line 104768: Fts3SegReader * pTmp ; 
line 104769: if ( xCmp ( apSegment [ j ] , apSegment [ j + 1 ] ) < 0 ) break ; 
line 104770: pTmp = apSegment [ j + 1 ] ; 
line 104771: apSegment [ j + 1 ] = apSegment [ j ] ; 
line 104772: apSegment [ j ] = pTmp ; 
line 104773: } 
line 104774: } 
line 104776: # ifndef NDEBUG 
line 104778: for ( i = 0 ; i < ( nSuspect - 1 ) ; i ++ ) { 
line 104779: assert ( xCmp ( apSegment [ i ] , apSegment [ i + 1 ] ) < 0 ) ; 
line 104780: } 
line 104781: # endif 
line 104782: } 
line 104787: static int fts3WriteSegment ( 
line 104788: Fts3Table * p , 
line 104789: sqlite3_int64 iBlock , 
line 104790: char * z , 
line 104791: int n 
line 104792: ) { 
line 104793: sqlite3_stmt * pStmt ; 
line 104794: int rc = fts3SqlStmt ( p , SQL_INSERT_SEGMENTS , & pStmt , 0 ) ; 
line 104795: if ( rc == SQLITE_OK ) { 
line 104796: sqlite3_bind_int64 ( pStmt , 1 , iBlock ) ; 
line 104797: sqlite3_bind_blob ( pStmt , 2 , z , n , SQLITE_STATIC ) ; 
line 104798: sqlite3_step ( pStmt ) ; 
line 104799: rc = sqlite3_reset ( pStmt ) ; 
line 104800: } 
line 104801: return rc ; 
line 104802: } 
line 104807: static int fts3WriteSegdir ( 
line 104808: Fts3Table * p , 
line 104809: int iLevel , 
line 104810: int iIdx , 
line 104811: sqlite3_int64 iStartBlock , 
line 104812: sqlite3_int64 iLeafEndBlock , 
line 104813: sqlite3_int64 iEndBlock , 
line 104814: char * zRoot , 
line 104815: int nRoot 
line 104816: ) { 
line 104817: sqlite3_stmt * pStmt ; 
line 104818: int rc = fts3SqlStmt ( p , SQL_INSERT_SEGDIR , & pStmt , 0 ) ; 
line 104819: if ( rc == SQLITE_OK ) { 
line 104820: sqlite3_bind_int ( pStmt , 1 , iLevel ) ; 
line 104821: sqlite3_bind_int ( pStmt , 2 , iIdx ) ; 
line 104822: sqlite3_bind_int64 ( pStmt , 3 , iStartBlock ) ; 
line 104823: sqlite3_bind_int64 ( pStmt , 4 , iLeafEndBlock ) ; 
line 104824: sqlite3_bind_int64 ( pStmt , 5 , iEndBlock ) ; 
line 104825: sqlite3_bind_blob ( pStmt , 6 , zRoot , nRoot , SQLITE_STATIC ) ; 
line 104826: sqlite3_step ( pStmt ) ; 
line 104827: rc = sqlite3_reset ( pStmt ) ; 
line 104828: } 
line 104829: return rc ; 
line 104830: } 
line 104840: static int fts3PrefixCompress ( 
line 104841: const char * zPrev , 
line 104842: int nPrev , 
line 104843: const char * zNext , 
line 104844: int nNext 
line 104845: ) { 
line 104846: int n ; 
line 104847: UNUSED_PARAMETER ( nNext ) ; 
line 104848: for ( n = 0 ; n < nPrev && zPrev [ n ] == zNext [ n ] ; n ++ ) ; 
line 104849: return n ; 
line 104850: } 
line 104856: static int fts3NodeAddTerm ( 
line 104857: Fts3Table * p , 
line 104858: SegmentNode * * ppTree , 
line 104859: int isCopyTerm , 
line 104860: const char * zTerm , 
line 104861: int nTerm 
line 104862: ) { 
line 104863: SegmentNode * pTree = * ppTree ; 
line 104864: int rc ; 
line 104865: SegmentNode * pNew ; 
line 104870: if ( pTree ) { 
line 104871: int nData = pTree -> nData ; 
line 104872: int nReq = nData ; 
line 104873: int nPrefix ; 
line 104874: int nSuffix ; 
line 104876: nPrefix = fts3PrefixCompress ( pTree -> zTerm , pTree -> nTerm , zTerm , nTerm ) ; 
line 104877: nSuffix = nTerm - nPrefix ; 
line 104879: nReq += sqlite3Fts3VarintLen ( nPrefix ) + sqlite3Fts3VarintLen ( nSuffix ) + nSuffix ; 
line 104880: if ( nReq <= p -> nNodeSize || ! pTree -> zTerm ) { 
line 104882: if ( nReq > p -> nNodeSize ) { 
line 104890: assert ( pTree -> aData == ( char * ) & pTree [ 1 ] ) ; 
line 104891: pTree -> aData = ( char * ) sqlite3_malloc ( nReq ) ; 
line 104892: if ( ! pTree -> aData ) { 
line 104893: return SQLITE_NOMEM ; 
line 104894: } 
line 104895: } 
line 104897: if ( pTree -> zTerm ) { 
line 104899: nData += sqlite3Fts3PutVarint ( & pTree -> aData [ nData ] , nPrefix ) ; 
line 104900: } 
line 104902: nData += sqlite3Fts3PutVarint ( & pTree -> aData [ nData ] , nSuffix ) ; 
line 104903: memcpy ( & pTree -> aData [ nData ] , & zTerm [ nPrefix ] , nSuffix ) ; 
line 104904: pTree -> nData = nData + nSuffix ; 
line 104905: pTree -> nEntry ++ ; 
line 104907: if ( isCopyTerm ) { 
line 104908: if ( pTree -> nMalloc < nTerm ) { 
line 104909: char * zNew = sqlite3_realloc ( pTree -> zMalloc , nTerm * 2 ) ; 
line 104910: if ( ! zNew ) { 
line 104911: return SQLITE_NOMEM ; 
line 104912: } 
line 104913: pTree -> nMalloc = nTerm * 2 ; 
line 104914: pTree -> zMalloc = zNew ; 
line 104915: } 
line 104916: pTree -> zTerm = pTree -> zMalloc ; 
line 104917: memcpy ( pTree -> zTerm , zTerm , nTerm ) ; 
line 104918: pTree -> nTerm = nTerm ; 
line 104919: } else { 
line 104920: pTree -> zTerm = ( char * ) zTerm ; 
line 104921: pTree -> nTerm = nTerm ; 
line 104922: } 
line 104923: return SQLITE_OK ; 
line 104924: } 
line 104925: } 
line 104935: pNew = ( SegmentNode * ) sqlite3_malloc ( sizeof ( SegmentNode ) + p -> nNodeSize ) ; 
line 104936: if ( ! pNew ) { 
line 104937: return SQLITE_NOMEM ; 
line 104938: } 
line 104939: memset ( pNew , 0 , sizeof ( SegmentNode ) ) ; 
line 104940: pNew -> nData = 1 + FTS3_VARINT_MAX ; 
line 104941: pNew -> aData = ( char * ) & pNew [ 1 ] ; 
line 104943: if ( pTree ) { 
line 104944: SegmentNode * pParent = pTree -> pParent ; 
line 104945: rc = fts3NodeAddTerm ( p , & pParent , isCopyTerm , zTerm , nTerm ) ; 
line 104946: if ( pTree -> pParent == 0 ) { 
line 104947: pTree -> pParent = pParent ; 
line 104948: } 
line 104949: pTree -> pRight = pNew ; 
line 104950: pNew -> pLeftmost = pTree -> pLeftmost ; 
line 104951: pNew -> pParent = pParent ; 
line 104952: pNew -> zMalloc = pTree -> zMalloc ; 
line 104953: pNew -> nMalloc = pTree -> nMalloc ; 
line 104954: pTree -> zMalloc = 0 ; 
line 104955: } else { 
line 104956: pNew -> pLeftmost = pNew ; 
line 104957: rc = fts3NodeAddTerm ( p , & pNew , isCopyTerm , zTerm , nTerm ) ; 
line 104958: } 
line 104960: * ppTree = pNew ; 
line 104961: return rc ; 
line 104962: } 
line 104967: static int fts3TreeFinishNode ( 
line 104968: SegmentNode * pTree , 
line 104969: int iHeight , 
line 104970: sqlite3_int64 iLeftChild 
line 104971: ) { 
line 104972: int nStart ; 
line 104973: assert ( iHeight >= 1 && iHeight < 128 ) ; 
line 104974: nStart = FTS3_VARINT_MAX - sqlite3Fts3VarintLen ( iLeftChild ) ; 
line 104975: pTree -> aData [ nStart ] = ( char ) iHeight ; 
line 104976: sqlite3Fts3PutVarint ( & pTree -> aData [ nStart + 1 ] , iLeftChild ) ; 
line 104977: return nStart ; 
line 104978: } 
line 104993: static int fts3NodeWrite ( 
line 104994: Fts3Table * p , 
line 104995: SegmentNode * pTree , 
line 104996: int iHeight , 
line 104997: sqlite3_int64 iLeaf , 
line 104998: sqlite3_int64 iFree , 
line 104999: sqlite3_int64 * piLast , 
line 105000: char * * paRoot , 
line 105001: int * pnRoot 
line 105002: ) { 
line 105003: int rc = SQLITE_OK ; 
line 105005: if ( ! pTree -> pParent ) { 
line 105007: int nStart = fts3TreeFinishNode ( pTree , iHeight , iLeaf ) ; 
line 105008: * piLast = iFree - 1 ; 
line 105009: * pnRoot = pTree -> nData - nStart ; 
line 105010: * paRoot = & pTree -> aData [ nStart ] ; 
line 105011: } else { 
line 105012: SegmentNode * pIter ; 
line 105013: sqlite3_int64 iNextFree = iFree ; 
line 105014: sqlite3_int64 iNextLeaf = iLeaf ; 
line 105015: for ( pIter = pTree -> pLeftmost ; pIter && rc == SQLITE_OK ; pIter = pIter -> pRight ) { 
line 105016: int nStart = fts3TreeFinishNode ( pIter , iHeight , iNextLeaf ) ; 
line 105017: int nWrite = pIter -> nData - nStart ; 
line 105019: rc = fts3WriteSegment ( p , iNextFree , & pIter -> aData [ nStart ] , nWrite ) ; 
line 105020: iNextFree ++ ; 
line 105021: iNextLeaf += ( pIter -> nEntry + 1 ) ; 
line 105022: } 
line 105023: if ( rc == SQLITE_OK ) { 
line 105024: assert ( iNextLeaf == iFree ) ; 
line 105025: rc = fts3NodeWrite ( 
line 105026: p , pTree -> pParent , iHeight + 1 , iFree , iNextFree , piLast , paRoot , pnRoot 
line 105027: ) ; 
line 105028: } 
line 105029: } 
line 105031: return rc ; 
line 105032: } 
line 105037: static void fts3NodeFree ( SegmentNode * pTree ) { 
line 105038: if ( pTree ) { 
line 105039: SegmentNode * p = pTree -> pLeftmost ; 
line 105040: fts3NodeFree ( p -> pParent ) ; 
line 105041: while ( p ) { 
line 105042: SegmentNode * pRight = p -> pRight ; 
line 105043: if ( p -> aData != ( char * ) & p [ 1 ] ) { 
line 105044: sqlite3_free ( p -> aData ) ; 
line 105045: } 
line 105046: assert ( pRight == 0 || p -> zMalloc == 0 ) ; 
line 105047: sqlite3_free ( p -> zMalloc ) ; 
line 105048: sqlite3_free ( p ) ; 
line 105049: p = pRight ; 
line 105050: } 
line 105051: } 
line 105052: } 
line 105062: static int fts3SegWriterAdd ( 
line 105063: Fts3Table * p , 
line 105064: SegmentWriter * * ppWriter , 
line 105065: int isCopyTerm , 
line 105066: const char * zTerm , 
line 105067: int nTerm , 
line 105068: const char * aDoclist , 
line 105069: int nDoclist 
line 105070: ) { 
line 105071: int nPrefix ; 
line 105072: int nSuffix ; 
line 105073: int nReq ; 
line 105074: int nData ; 
line 105075: SegmentWriter * pWriter = * ppWriter ; 
line 105077: if ( ! pWriter ) { 
line 105078: int rc ; 
line 105079: sqlite3_stmt * pStmt ; 
line 105082: pWriter = ( SegmentWriter * ) sqlite3_malloc ( sizeof ( SegmentWriter ) ) ; 
line 105083: if ( ! pWriter ) return SQLITE_NOMEM ; 
line 105084: memset ( pWriter , 0 , sizeof ( SegmentWriter ) ) ; 
line 105085: * ppWriter = pWriter ; 
line 105088: pWriter -> aData = ( char * ) sqlite3_malloc ( p -> nNodeSize ) ; 
line 105089: if ( ! pWriter -> aData ) return SQLITE_NOMEM ; 
line 105090: pWriter -> nSize = p -> nNodeSize ; 
line 105093: rc = fts3SqlStmt ( p , SQL_NEXT_SEGMENTS_ID , & pStmt , 0 ) ; 
line 105094: if ( rc != SQLITE_OK ) return rc ; 
line 105095: if ( SQLITE_ROW == sqlite3_step ( pStmt ) ) { 
line 105096: pWriter -> iFree = sqlite3_column_int64 ( pStmt , 0 ) ; 
line 105097: pWriter -> iFirst = pWriter -> iFree ; 
line 105098: } 
line 105099: rc = sqlite3_reset ( pStmt ) ; 
line 105100: if ( rc != SQLITE_OK ) return rc ; 
line 105101: } 
line 105102: nData = pWriter -> nData ; 
line 105104: nPrefix = fts3PrefixCompress ( pWriter -> zTerm , pWriter -> nTerm , zTerm , nTerm ) ; 
line 105105: nSuffix = nTerm - nPrefix ; 
line 105108: nReq = sqlite3Fts3VarintLen ( nPrefix ) + 
line 105109: sqlite3Fts3VarintLen ( nSuffix ) + 
line 105110: nSuffix + 
line 105111: sqlite3Fts3VarintLen ( nDoclist ) + 
line 105112: nDoclist ; 
line 105114: if ( nData > 0 && nData + nReq > p -> nNodeSize ) { 
line 105115: int rc ; 
line 105118: rc = fts3WriteSegment ( p , pWriter -> iFree ++ , pWriter -> aData , nData ) ; 
line 105119: if ( rc != SQLITE_OK ) return rc ; 
line 105133: assert ( nPrefix < nTerm ) ; 
line 105134: rc = fts3NodeAddTerm ( p , & pWriter -> pTree , isCopyTerm , zTerm , nPrefix + 1 ) ; 
line 105135: if ( rc != SQLITE_OK ) return rc ; 
line 105137: nData = 0 ; 
line 105138: pWriter -> nTerm = 0 ; 
line 105140: nPrefix = 0 ; 
line 105141: nSuffix = nTerm ; 
line 105142: nReq = 1 + 
line 105143: sqlite3Fts3VarintLen ( nTerm ) + 
line 105144: nTerm + 
line 105145: sqlite3Fts3VarintLen ( nDoclist ) + 
line 105146: nDoclist ; 
line 105147: } 
line 105152: if ( nReq > pWriter -> nSize ) { 
line 105153: char * aNew = sqlite3_realloc ( pWriter -> aData , nReq ) ; 
line 105154: if ( ! aNew ) return SQLITE_NOMEM ; 
line 105155: pWriter -> aData = aNew ; 
line 105156: pWriter -> nSize = nReq ; 
line 105157: } 
line 105158: assert ( nData + nReq <= pWriter -> nSize ) ; 
line 105161: nData += sqlite3Fts3PutVarint ( & pWriter -> aData [ nData ] , nPrefix ) ; 
line 105162: nData += sqlite3Fts3PutVarint ( & pWriter -> aData [ nData ] , nSuffix ) ; 
line 105163: memcpy ( & pWriter -> aData [ nData ] , & zTerm [ nPrefix ] , nSuffix ) ; 
line 105164: nData += nSuffix ; 
line 105165: nData += sqlite3Fts3PutVarint ( & pWriter -> aData [ nData ] , nDoclist ) ; 
line 105166: memcpy ( & pWriter -> aData [ nData ] , aDoclist , nDoclist ) ; 
line 105167: pWriter -> nData = nData + nDoclist ; 
line 105174: if ( isCopyTerm ) { 
line 105175: if ( nTerm > pWriter -> nMalloc ) { 
line 105176: char * zNew = sqlite3_realloc ( pWriter -> zMalloc , nTerm * 2 ) ; 
line 105177: if ( ! zNew ) { 
line 105178: return SQLITE_NOMEM ; 
line 105179: } 
line 105180: pWriter -> nMalloc = nTerm * 2 ; 
line 105181: pWriter -> zMalloc = zNew ; 
line 105182: pWriter -> zTerm = zNew ; 
line 105183: } 
line 105184: assert ( pWriter -> zTerm == pWriter -> zMalloc ) ; 
line 105185: memcpy ( pWriter -> zTerm , zTerm , nTerm ) ; 
line 105186: } else { 
line 105187: pWriter -> zTerm = ( char * ) zTerm ; 
line 105188: } 
line 105189: pWriter -> nTerm = nTerm ; 
line 105191: return SQLITE_OK ; 
line 105192: } 
line 105200: static int fts3SegWriterFlush ( 
line 105201: Fts3Table * p , 
line 105202: SegmentWriter * pWriter , 
line 105203: int iLevel , 
line 105204: int iIdx 
line 105205: ) { 
line 105206: int rc ; 
line 105207: if ( pWriter -> pTree ) { 
line 105208: sqlite3_int64 iLast = 0 ; 
line 105209: sqlite3_int64 iLastLeaf ; 
line 105210: char * zRoot = NULL ; 
line 105211: int nRoot = 0 ; 
line 105213: iLastLeaf = pWriter -> iFree ; 
line 105214: rc = fts3WriteSegment ( p , pWriter -> iFree ++ , pWriter -> aData , pWriter -> nData ) ; 
line 105215: if ( rc == SQLITE_OK ) { 
line 105216: rc = fts3NodeWrite ( p , pWriter -> pTree , 1 , 
line 105217: pWriter -> iFirst , pWriter -> iFree , & iLast , & zRoot , & nRoot ) ; 
line 105218: } 
line 105219: if ( rc == SQLITE_OK ) { 
line 105220: rc = fts3WriteSegdir ( 
line 105221: p , iLevel , iIdx , pWriter -> iFirst , iLastLeaf , iLast , zRoot , nRoot ) ; 
line 105222: } 
line 105223: } else { 
line 105225: rc = fts3WriteSegdir ( 
line 105226: p , iLevel , iIdx , 0 , 0 , 0 , pWriter -> aData , pWriter -> nData ) ; 
line 105227: } 
line 105228: return rc ; 
line 105229: } 
line 105235: static void fts3SegWriterFree ( SegmentWriter * pWriter ) { 
line 105236: if ( pWriter ) { 
line 105237: sqlite3_free ( pWriter -> aData ) ; 
line 105238: sqlite3_free ( pWriter -> zMalloc ) ; 
line 105239: fts3NodeFree ( pWriter -> pTree ) ; 
line 105240: sqlite3_free ( pWriter ) ; 
line 105241: } 
line 105242: } 
line 105254: static int fts3IsEmpty ( Fts3Table * p , sqlite3_value * * apVal , int * pisEmpty ) { 
line 105255: sqlite3_stmt * pStmt ; 
line 105256: int rc ; 
line 105257: rc = fts3SqlStmt ( p , SQL_IS_EMPTY , & pStmt , apVal ) ; 
line 105258: if ( rc == SQLITE_OK ) { 
line 105259: if ( SQLITE_ROW == sqlite3_step ( pStmt ) ) { 
line 105260: * pisEmpty = sqlite3_column_int ( pStmt , 0 ) ; 
line 105261: } 
line 105262: rc = sqlite3_reset ( pStmt ) ; 
line 105263: } 
line 105264: return rc ; 
line 105265: } 
line 105272: static int fts3SegmentCount ( Fts3Table * p , int iLevel , int * pnSegment ) { 
line 105273: sqlite3_stmt * pStmt ; 
line 105274: int rc ; 
line 105276: assert ( iLevel >= 0 ) ; 
line 105277: rc = fts3SqlStmt ( p , SQL_SELECT_LEVEL_COUNT , & pStmt , 0 ) ; 
line 105278: if ( rc != SQLITE_OK ) return rc ; 
line 105279: sqlite3_bind_int ( pStmt , 1 , iLevel ) ; 
line 105280: if ( SQLITE_ROW == sqlite3_step ( pStmt ) ) { 
line 105281: * pnSegment = sqlite3_column_int ( pStmt , 0 ) ; 
line 105282: } 
line 105283: return sqlite3_reset ( pStmt ) ; 
line 105284: } 
line 105293: static int fts3SegmentCountMax ( Fts3Table * p , int * pnSegment , int * pnMax ) { 
line 105294: sqlite3_stmt * pStmt ; 
line 105295: int rc ; 
line 105297: rc = fts3SqlStmt ( p , SQL_SELECT_SEGDIR_COUNT_MAX , & pStmt , 0 ) ; 
line 105298: if ( rc != SQLITE_OK ) return rc ; 
line 105299: if ( SQLITE_ROW == sqlite3_step ( pStmt ) ) { 
line 105300: * pnSegment = sqlite3_column_int ( pStmt , 0 ) ; 
line 105301: * pnMax = sqlite3_column_int ( pStmt , 1 ) ; 
line 105302: } 
line 105303: return sqlite3_reset ( pStmt ) ; 
line 105304: } 
line 105320: static int fts3DeleteSegdir ( 
line 105321: Fts3Table * p , 
line 105322: int iLevel , 
line 105323: Fts3SegReader * * apSegment , 
line 105324: int nReader 
line 105325: ) { 
line 105326: int rc ; 
line 105327: int i ; 
line 105328: sqlite3_stmt * pDelete ; 
line 105330: rc = fts3SqlStmt ( p , SQL_DELETE_SEGMENTS_RANGE , & pDelete , 0 ) ; 
line 105331: for ( i = 0 ; rc == SQLITE_OK && i < nReader ; i ++ ) { 
line 105332: Fts3SegReader * pSegment = apSegment [ i ] ; 
line 105333: if ( pSegment -> iStartBlock ) { 
line 105334: sqlite3_bind_int64 ( pDelete , 1 , pSegment -> iStartBlock ) ; 
line 105335: sqlite3_bind_int64 ( pDelete , 2 , pSegment -> iEndBlock ) ; 
line 105336: sqlite3_step ( pDelete ) ; 
line 105337: rc = sqlite3_reset ( pDelete ) ; 
line 105338: } 
line 105339: } 
line 105340: if ( rc != SQLITE_OK ) { 
line 105341: return rc ; 
line 105342: } 
line 105344: if ( iLevel >= 0 ) { 
line 105345: rc = fts3SqlStmt ( p , SQL_DELETE_SEGDIR_BY_LEVEL , & pDelete , 0 ) ; 
line 105346: if ( rc == SQLITE_OK ) { 
line 105347: sqlite3_bind_int ( pDelete , 1 , iLevel ) ; 
line 105348: sqlite3_step ( pDelete ) ; 
line 105349: rc = sqlite3_reset ( pDelete ) ; 
line 105350: } 
line 105351: } else { 
line 105352: rc = fts3SqlExec ( p , SQL_DELETE_ALL_SEGDIR , 0 ) ; 
line 105353: } 
line 105355: return rc ; 
line 105356: } 
line 105367: static void fts3ColumnFilter ( 
line 105368: int iCol , 
line 105369: char * * ppList , 
line 105370: int * pnList 
line 105371: ) { 
line 105372: char * pList = * ppList ; 
line 105373: int nList = * pnList ; 
line 105374: char * pEnd = & pList [ nList ] ; 
line 105375: int iCurrent = 0 ; 
line 105376: char * p = pList ; 
line 105378: assert ( iCol >= 0 ) ; 
line 105379: while ( 1 ) { 
line 105380: char c = 0 ; 
line 105381: while ( p < pEnd && ( c | * p ) & 0xFE ) c = * p ++ & 0x80 ; 
line 105383: if ( iCol == iCurrent ) { 
line 105384: nList = ( int ) ( p - pList ) ; 
line 105385: break ; 
line 105386: } 
line 105388: nList -= ( int ) ( p - pList ) ; 
line 105389: pList = p ; 
line 105390: if ( nList == 0 ) { 
line 105391: break ; 
line 105392: } 
line 105393: p = & pList [ 1 ] ; 
line 105394: p += sqlite3Fts3GetVarint32 ( p , & iCurrent ) ; 
line 105395: } 
line 105397: * ppList = pList ; 
line 105398: * pnList = nList ; 
line 105399: } 
line 105405: static int fts3MergeCallback ( 
line 105406: Fts3Table * p , 
line 105407: void * pContext , 
line 105408: char * zTerm , 
line 105409: int nTerm , 
line 105410: char * aDoclist , 
line 105411: int nDoclist 
line 105412: ) { 
line 105413: SegmentWriter * * ppW = ( SegmentWriter * * ) pContext ; 
line 105414: return fts3SegWriterAdd ( p , ppW , 1 , zTerm , nTerm , aDoclist , nDoclist ) ; 
line 105415: } 
line 105421: static int fts3FlushCallback ( 
line 105422: Fts3Table * p , 
line 105423: void * pContext , 
line 105424: char * zTerm , 
line 105425: int nTerm , 
line 105426: char * aDoclist , 
line 105427: int nDoclist 
line 105428: ) { 
line 105429: SegmentWriter * * ppW = ( SegmentWriter * * ) pContext ; 
line 105430: return fts3SegWriterAdd ( p , ppW , 0 , zTerm , nTerm , aDoclist , nDoclist ) ; 
line 105431: } 
line 105458: SQLITE_PRIVATE int sqlite3Fts3SegReaderIterate ( 
line 105459: Fts3Table * p , 
line 105460: Fts3SegReader * * apSegment , 
line 105461: int nSegment , 
line 105462: Fts3SegFilter * pFilter , 
line 105463: int ( * xFunc ) ( Fts3Table * , void * , char * , int , char * , int ) , 
line 105464: void * pContext 
line 105465: ) { 
line 105466: int i ; 
line 105467: char * aBuffer = 0 ; 
line 105468: int nAlloc = 0 ; 
line 105469: int rc = SQLITE_OK ; 
line 105471: int isIgnoreEmpty = ( pFilter -> flags & FTS3_SEGMENT_IGNORE_EMPTY ) ; 
line 105472: int isRequirePos = ( pFilter -> flags & FTS3_SEGMENT_REQUIRE_POS ) ; 
line 105473: int isColFilter = ( pFilter -> flags & FTS3_SEGMENT_COLUMN_FILTER ) ; 
line 105474: int isPrefix = ( pFilter -> flags & FTS3_SEGMENT_PREFIX ) ; 
line 105479: if ( nSegment == 0 ) goto finished ; 
line 105487: if ( pFilter -> zTerm ) { 
line 105488: int nTerm = pFilter -> nTerm ; 
line 105489: const char * zTerm = pFilter -> zTerm ; 
line 105490: for ( i = 0 ; i < nSegment ; i ++ ) { 
line 105491: Fts3SegReader * pSeg = apSegment [ i ] ; 
line 105492: while ( fts3SegReaderTermCmp ( pSeg , zTerm , nTerm ) < 0 ) { 
line 105493: rc = fts3SegReaderNext ( pSeg ) ; 
line 105494: if ( rc != SQLITE_OK ) goto finished ; } 
line 105495: } 
line 105496: } 
line 105498: fts3SegReaderSort ( apSegment , nSegment , nSegment , fts3SegReaderCmp ) ; 
line 105499: while ( apSegment [ 0 ] -> aNode ) { 
line 105500: int nTerm = apSegment [ 0 ] -> nTerm ; 
line 105501: char * zTerm = apSegment [ 0 ] -> zTerm ; 
line 105502: int nMerge = 1 ; 
line 105511: if ( pFilter -> zTerm ) { 
line 105512: if ( nTerm < pFilter -> nTerm 
line 105513: || ( ! isPrefix && nTerm > pFilter -> nTerm ) 
line 105514: || memcmp ( zTerm , pFilter -> zTerm , pFilter -> nTerm ) 
line 105515: ) { 
line 105516: goto finished ; 
line 105517: } 
line 105518: } 
line 105520: while ( nMerge < nSegment 
line 105521: && apSegment [ nMerge ] -> aNode 
line 105522: && apSegment [ nMerge ] -> nTerm == nTerm 
line 105523: && 0 == memcmp ( zTerm , apSegment [ nMerge ] -> zTerm , nTerm ) 
line 105524: ) { 
line 105525: nMerge ++ ; 
line 105526: } 
line 105528: assert ( isIgnoreEmpty || ( isRequirePos && ! isColFilter ) ) ; 
line 105529: if ( nMerge == 1 && ! isIgnoreEmpty ) { 
line 105530: Fts3SegReader * p0 = apSegment [ 0 ] ; 
line 105531: rc = xFunc ( p , pContext , zTerm , nTerm , p0 -> aDoclist , p0 -> nDoclist ) ; 
line 105532: if ( rc != SQLITE_OK ) goto finished ; 
line 105533: } else { 
line 105534: int nDoclist = 0 ; 
line 105535: sqlite3_int64 iPrev = 0 ; 
line 105541: for ( i = 0 ; i < nMerge ; i ++ ) { 
line 105542: fts3SegReaderFirstDocid ( apSegment [ i ] ) ; 
line 105543: } 
line 105544: fts3SegReaderSort ( apSegment , nMerge , nMerge , fts3SegReaderDoclistCmp ) ; 
line 105545: while ( apSegment [ 0 ] -> pOffsetList ) { 
line 105546: int j ; 
line 105547: char * pList ; 
line 105548: int nList ; 
line 105549: int nByte ; 
line 105550: sqlite3_int64 iDocid = apSegment [ 0 ] -> iDocid ; 
line 105551: fts3SegReaderNextDocid ( apSegment [ 0 ] , & pList , & nList ) ; 
line 105552: j = 1 ; 
line 105553: while ( j < nMerge 
line 105554: && apSegment [ j ] -> pOffsetList 
line 105555: && apSegment [ j ] -> iDocid == iDocid 
line 105556: ) { 
line 105557: fts3SegReaderNextDocid ( apSegment [ j ] , 0 , 0 ) ; 
line 105558: j ++ ; 
line 105559: } 
line 105561: if ( isColFilter ) { 
line 105562: fts3ColumnFilter ( pFilter -> iCol , & pList , & nList ) ; 
line 105563: } 
line 105565: if ( ! isIgnoreEmpty || nList > 0 ) { 
line 105566: nByte = sqlite3Fts3VarintLen ( iDocid - iPrev ) + ( isRequirePos ? nList + 1 : 0 ) ; 
line 105567: if ( nDoclist + nByte > nAlloc ) { 
line 105568: char * aNew ; 
line 105569: nAlloc = nDoclist + nByte * 2 ; 
line 105570: aNew = sqlite3_realloc ( aBuffer , nAlloc ) ; 
line 105571: if ( ! aNew ) { 
line 105572: rc = SQLITE_NOMEM ; 
line 105573: goto finished ; 
line 105574: } 
line 105575: aBuffer = aNew ; 
line 105576: } 
line 105577: nDoclist += sqlite3Fts3PutVarint ( & aBuffer [ nDoclist ] , iDocid - iPrev ) ; 
line 105578: iPrev = iDocid ; 
line 105579: if ( isRequirePos ) { 
line 105580: memcpy ( & aBuffer [ nDoclist ] , pList , nList ) ; 
line 105581: nDoclist += nList ; 
line 105582: aBuffer [ nDoclist ++ ] = '\0' ; 
line 105583: } 
line 105584: } 
line 105586: fts3SegReaderSort ( apSegment , nMerge , j , fts3SegReaderDoclistCmp ) ; 
line 105587: } 
line 105589: if ( nDoclist > 0 ) { 
line 105590: rc = xFunc ( p , pContext , zTerm , nTerm , aBuffer , nDoclist ) ; 
line 105591: if ( rc != SQLITE_OK ) goto finished ; 
line 105592: } 
line 105593: } 
line 105599: if ( pFilter -> zTerm && ! isPrefix ) { 
line 105600: goto finished ; 
line 105601: } 
line 105603: for ( i = 0 ; i < nMerge ; i ++ ) { 
line 105604: rc = fts3SegReaderNext ( apSegment [ i ] ) ; 
line 105605: if ( rc != SQLITE_OK ) goto finished ; 
line 105606: } 
line 105607: fts3SegReaderSort ( apSegment , nSegment , nMerge , fts3SegReaderCmp ) ; 
line 105608: } 
line 105610: finished : 
line 105611: sqlite3_free ( aBuffer ) ; 
line 105612: return rc ; 
line 105613: } 
line 105626: static int fts3SegmentMerge ( Fts3Table * p , int iLevel ) { 
line 105627: int i ; 
line 105628: int rc ; 
line 105629: int iIdx ; 
line 105630: int iNewLevel ; 
line 105631: sqlite3_stmt * pStmt = 0 ; 
line 105632: SegmentWriter * pWriter = 0 ; 
line 105633: int nSegment = 0 ; 
line 105634: Fts3SegReader * * apSegment = 0 ; 
line 105635: Fts3SegReader * pPending = 0 ; 
line 105636: Fts3SegFilter filter ; 
line 105638: if ( iLevel < 0 ) { 
line 105644: iIdx = 0 ; 
line 105645: rc = sqlite3Fts3SegReaderPending ( p , 0 , 0 , 1 , & pPending ) ; 
line 105646: if ( rc != SQLITE_OK ) goto finished ; 
line 105647: rc = fts3SegmentCountMax ( p , & nSegment , & iNewLevel ) ; 
line 105648: if ( rc != SQLITE_OK ) goto finished ; 
line 105649: nSegment += ( pPending != 0 ) ; 
line 105650: if ( nSegment <= 1 ) { 
line 105651: return SQLITE_DONE ; 
line 105652: } 
line 105653: } else { 
line 105659: iNewLevel = iLevel + 1 ; 
line 105660: rc = fts3AllocateSegdirIdx ( p , iNewLevel , & iIdx ) ; 
line 105661: if ( rc != SQLITE_OK ) goto finished ; 
line 105662: rc = fts3SegmentCount ( p , iLevel , & nSegment ) ; 
line 105663: if ( rc != SQLITE_OK ) goto finished ; 
line 105664: } 
line 105665: assert ( nSegment > 0 ) ; 
line 105666: assert ( iNewLevel >= 0 ) ; 
line 105669: apSegment = ( Fts3SegReader * * ) sqlite3_malloc ( sizeof ( Fts3SegReader * ) * nSegment ) ; 
line 105670: if ( ! apSegment ) { 
line 105671: rc = SQLITE_NOMEM ; 
line 105672: goto finished ; 
line 105673: } 
line 105674: memset ( apSegment , 0 , sizeof ( Fts3SegReader * ) * nSegment ) ; 
line 105680: assert ( SQL_SELECT_LEVEL + 1 == SQL_SELECT_ALL_LEVEL ) ; 
line 105681: rc = fts3SqlStmt ( p , SQL_SELECT_LEVEL + ( iLevel < 0 ) , & pStmt , 0 ) ; 
line 105682: if ( rc != SQLITE_OK ) goto finished ; 
line 105683: sqlite3_bind_int ( pStmt , 1 , iLevel ) ; 
line 105684: for ( i = 0 ; SQLITE_ROW == ( sqlite3_step ( pStmt ) ) ; i ++ ) { 
line 105685: rc = fts3SegReaderNew ( p , pStmt , i , & apSegment [ i ] ) ; 
line 105686: if ( rc != SQLITE_OK ) { 
line 105687: goto finished ; 
line 105688: } 
line 105689: } 
line 105690: rc = sqlite3_reset ( pStmt ) ; 
line 105691: if ( pPending ) { 
line 105692: apSegment [ i ] = pPending ; 
line 105693: pPending = 0 ; 
line 105694: } 
line 105695: pStmt = 0 ; 
line 105696: if ( rc != SQLITE_OK ) goto finished ; 
line 105698: memset ( & filter , 0 , sizeof ( Fts3SegFilter ) ) ; 
line 105699: filter . flags = FTS3_SEGMENT_REQUIRE_POS ; 
line 105700: filter . flags |= ( iLevel < 0 ? FTS3_SEGMENT_IGNORE_EMPTY : 0 ) ; 
line 105701: rc = sqlite3Fts3SegReaderIterate ( p , apSegment , nSegment , 
line 105702: & filter , fts3MergeCallback , ( void * ) & pWriter 
line 105703: ) ; 
line 105704: if ( rc != SQLITE_OK ) goto finished ; 
line 105706: rc = fts3DeleteSegdir ( p , iLevel , apSegment , nSegment ) ; 
line 105707: if ( rc == SQLITE_OK ) { 
line 105708: rc = fts3SegWriterFlush ( p , pWriter , iNewLevel , iIdx ) ; 
line 105709: } 
line 105711: finished : 
line 105712: fts3SegWriterFree ( pWriter ) ; 
line 105713: if ( apSegment ) { 
line 105714: for ( i = 0 ; i < nSegment ; i ++ ) { 
line 105715: sqlite3Fts3SegReaderFree ( p , apSegment [ i ] ) ; 
line 105716: } 
line 105717: sqlite3_free ( apSegment ) ; 
line 105718: } 
line 105719: sqlite3Fts3SegReaderFree ( p , pPending ) ; 
line 105720: sqlite3_reset ( pStmt ) ; 
line 105721: return rc ; 
line 105722: } 
line 105728: SQLITE_PRIVATE int sqlite3Fts3PendingTermsFlush ( Fts3Table * p ) { 
line 105729: int rc ; 
line 105730: int idx ; 
line 105731: SegmentWriter * pWriter = 0 ; 
line 105732: Fts3SegReader * pReader = 0 ; 
line 105738: rc = sqlite3Fts3SegReaderPending ( p , 0 , 0 , 1 , & pReader ) ; 
line 105739: if ( rc != SQLITE_OK || pReader == 0 ) { 
line 105740: return rc ; 
line 105741: } 
line 105747: rc = fts3AllocateSegdirIdx ( p , 0 , & idx ) ; 
line 105754: if ( rc == SQLITE_OK ) { 
line 105755: void * c = ( void * ) & pWriter ; 
line 105756: Fts3SegFilter f ; 
line 105758: memset ( & f , 0 , sizeof ( Fts3SegFilter ) ) ; 
line 105759: f . flags = FTS3_SEGMENT_REQUIRE_POS ; 
line 105760: rc = sqlite3Fts3SegReaderIterate ( p , & pReader , 1 , & f , fts3FlushCallback , c ) ; 
line 105761: } 
line 105762: assert ( pWriter || rc != SQLITE_OK ) ; 
line 105768: if ( rc == SQLITE_OK ) { 
line 105769: rc = fts3SegWriterFlush ( p , pWriter , 0 , idx ) ; 
line 105770: } 
line 105771: fts3SegWriterFree ( pWriter ) ; 
line 105772: sqlite3Fts3SegReaderFree ( p , pReader ) ; 
line 105774: if ( rc == SQLITE_OK ) { 
line 105775: sqlite3Fts3PendingTermsClear ( p ) ; 
line 105776: } 
line 105777: return rc ; 
line 105778: } 
line 105788: static int fts3SpecialInsert ( Fts3Table * p , sqlite3_value * pVal ) { 
line 105789: int rc ; 
line 105790: const char * zVal = ( const char * ) sqlite3_value_text ( pVal ) ; 
line 105791: int nVal = sqlite3_value_bytes ( pVal ) ; 
line 105793: if ( ! zVal ) { 
line 105794: return SQLITE_NOMEM ; 
line 105795: } else if ( nVal == 8 && 0 == sqlite3_strnicmp ( zVal , "optimize" , 8 ) ) { 
line 105796: rc = fts3SegmentMerge ( p , - 1 ) ; 
line 105797: if ( rc == SQLITE_DONE ) { 
line 105798: rc = SQLITE_OK ; 
line 105799: } else { 
line 105800: sqlite3Fts3PendingTermsClear ( p ) ; 
line 105801: } 
line 105802: # ifdef SQLITE_TEST 
line 105803: } else if ( nVal > 9 && 0 == sqlite3_strnicmp ( zVal , "nodesize=" , 9 ) ) { 
line 105804: p -> nNodeSize = atoi ( & zVal [ 9 ] ) ; 
line 105805: rc = SQLITE_OK ; 
line 105806: } else if ( nVal > 11 && 0 == sqlite3_strnicmp ( zVal , "maxpending=" , 9 ) ) { 
line 105807: p -> nMaxPendingData = atoi ( & zVal [ 11 ] ) ; 
line 105808: rc = SQLITE_OK ; 
line 105809: # endif 
line 105810: } else { 
line 105811: rc = SQLITE_ERROR ; 
line 105812: } 
line 105814: return rc ; 
line 105815: } 
line 105821: SQLITE_PRIVATE int sqlite3Fts3UpdateMethod ( 
line 105822: sqlite3_vtab * pVtab , 
line 105823: int nArg , 
line 105824: sqlite3_value * * apVal , 
line 105825: sqlite_int64 * pRowid 
line 105826: ) { 
line 105827: Fts3Table * p = ( Fts3Table * ) pVtab ; 
line 105828: int rc = SQLITE_OK ; 
line 105829: int isRemove = 0 ; 
line 105830: sqlite3_int64 iRemove = 0 ; 
line 105834: if ( sqlite3_value_type ( apVal [ 0 ] ) != SQLITE_NULL ) { 
line 105835: int isEmpty ; 
line 105836: rc = fts3IsEmpty ( p , apVal , & isEmpty ) ; 
line 105837: if ( rc == SQLITE_OK ) { 
line 105838: if ( isEmpty ) { 
line 105843: rc = fts3DeleteAll ( p ) ; 
line 105844: } else { 
line 105845: isRemove = 1 ; 
line 105846: iRemove = sqlite3_value_int64 ( apVal [ 0 ] ) ; 
line 105847: rc = fts3PendingTermsDocid ( p , iRemove ) ; 
line 105848: if ( rc == SQLITE_OK ) { 
line 105849: rc = fts3DeleteTerms ( p , apVal ) ; 
line 105850: if ( rc == SQLITE_OK ) { 
line 105851: rc = fts3SqlExec ( p , SQL_DELETE_CONTENT , apVal ) ; 
line 105852: } 
line 105853: } 
line 105854: } 
line 105855: } 
line 105856: } else if ( sqlite3_value_type ( apVal [ p -> nColumn + 2 ] ) != SQLITE_NULL ) { 
line 105857: return fts3SpecialInsert ( p , apVal [ p -> nColumn + 2 ] ) ; 
line 105858: } 
line 105861: if ( nArg > 1 && rc == SQLITE_OK ) { 
line 105862: rc = fts3InsertData ( p , apVal , pRowid ) ; 
line 105863: if ( rc == SQLITE_OK && ( ! isRemove || * pRowid != iRemove ) ) { 
line 105864: rc = fts3PendingTermsDocid ( p , * pRowid ) ; 
line 105865: } 
line 105866: if ( rc == SQLITE_OK ) { 
line 105867: rc = fts3InsertTerms ( p , apVal ) ; 
line 105868: } 
line 105869: } 
line 105871: return rc ; 
line 105872: } 
line 105879: SQLITE_PRIVATE int sqlite3Fts3Optimize ( Fts3Table * p ) { 
line 105880: int rc ; 
line 105881: rc = sqlite3_exec ( p -> db , "SAVEPOINT fts3" , 0 , 0 , 0 ) ; 
line 105882: if ( rc == SQLITE_OK ) { 
line 105883: rc = fts3SegmentMerge ( p , - 1 ) ; 
line 105884: if ( rc == SQLITE_OK ) { 
line 105885: rc = sqlite3_exec ( p -> db , "RELEASE fts3" , 0 , 0 , 0 ) ; 
line 105886: if ( rc == SQLITE_OK ) { 
line 105887: sqlite3Fts3PendingTermsClear ( p ) ; 
line 105888: } 
line 105889: } else { 
line 105890: sqlite3_exec ( p -> db , "ROLLBACK TO fts3" , 0 , 0 , 0 ) ; 
line 105891: sqlite3_exec ( p -> db , "RELEASE fts3" , 0 , 0 , 0 ) ; 
line 105892: } 
line 105893: } 
line 105894: return rc ; 
line 105895: } 
line 105897: # endif 
line 105914: # if ! defined ( SQLITE_CORE ) || defined ( SQLITE_ENABLE_FTS3 ) 
line 105917: typedef struct Snippet Snippet ; 
line 105923: struct Snippet { 
line 105924: int nMatch ; 
line 105925: int nAlloc ; 
line 105926: struct snippetMatch { 
line 105927: char snStatus ; 
line 105928: short int nByte ; 
line 105929: short int iCol ; 
line 105930: short int iTerm ; 
line 105931: int iToken ; 
line 105932: int iStart ; 
line 105933: } * aMatch ; 
line 105934: char * zOffset ; 
line 105935: int nOffset ; 
line 105936: char * zSnippet ; 
line 105937: int nSnippet ; 
line 105938: } ; 
line 105945: static int fts3snippetIsspace ( char c ) { 
line 105946: return ( c & 0x80 ) == 0 ? isspace ( c ) : 0 ; 
line 105947: } 
line 105956: typedef struct StringBuffer { 
line 105957: char * z ; 
line 105958: int nUsed ; 
line 105959: int nAlloc ; 
line 105960: } StringBuffer ; 
line 105966: static void fts3SnippetSbInit ( StringBuffer * p ) { 
line 105967: p -> nAlloc = 100 ; 
line 105968: p -> nUsed = 0 ; 
line 105969: p -> z = sqlite3_malloc ( p -> nAlloc ) ; 
line 105970: } 
line 105975: static void fts3SnippetAppend ( StringBuffer * p , const char * zNew , int nNew ) { 
line 105976: if ( p -> z == 0 ) return ; 
line 105977: if ( nNew < 0 ) nNew = ( int ) strlen ( zNew ) ; 
line 105978: if ( p -> nUsed + nNew >= p -> nAlloc ) { 
line 105979: int nAlloc ; 
line 105980: char * zNew ; 
line 105982: nAlloc = p -> nUsed + nNew + p -> nAlloc ; 
line 105983: zNew = sqlite3_realloc ( p -> z , nAlloc ) ; 
line 105984: if ( zNew == 0 ) { 
line 105985: sqlite3_free ( p -> z ) ; 
line 105986: p -> z = 0 ; 
line 105987: return ; 
line 105988: } 
line 105989: p -> z = zNew ; 
line 105990: p -> nAlloc = nAlloc ; 
line 105991: } 
line 105992: memcpy ( & p -> z [ p -> nUsed ] , zNew , nNew ) ; 
line 105993: p -> nUsed += nNew ; 
line 105994: p -> z [ p -> nUsed ] = 0 ; 
line 105995: } 
line 106000: static void fts3SnippetAppendWhiteSpace ( StringBuffer * p ) { 
line 106001: if ( p -> z && p -> nUsed && ! fts3snippetIsspace ( p -> z [ p -> nUsed - 1 ] ) ) { 
line 106002: fts3SnippetAppend ( p , " " , 1 ) ; 
line 106003: } 
line 106004: } 
line 106007: static void fts3SnippetTrimWhiteSpace ( StringBuffer * p ) { 
line 106008: if ( p -> z ) { 
line 106009: while ( p -> nUsed && fts3snippetIsspace ( p -> z [ p -> nUsed - 1 ] ) ) { 
line 106010: p -> nUsed -- ; 
line 106011: } 
line 106012: p -> z [ p -> nUsed ] = 0 ; 
line 106013: } 
line 106014: } 
line 106020: static void fts3SnippetFree ( Snippet * p ) { 
line 106021: if ( p ) { 
line 106022: sqlite3_free ( p -> aMatch ) ; 
line 106023: sqlite3_free ( p -> zOffset ) ; 
line 106024: sqlite3_free ( p -> zSnippet ) ; 
line 106025: sqlite3_free ( p ) ; 
line 106026: } 
line 106027: } 
line 106032: static int snippetAppendMatch ( 
line 106033: Snippet * p , 
line 106034: int iCol , int iTerm , 
line 106035: int iToken , 
line 106036: int iStart , int nByte 
line 106037: ) { 
line 106038: int i ; 
line 106039: struct snippetMatch * pMatch ; 
line 106040: if ( p -> nMatch + 1 >= p -> nAlloc ) { 
line 106041: struct snippetMatch * pNew ; 
line 106042: p -> nAlloc = p -> nAlloc * 2 + 10 ; 
line 106043: pNew = sqlite3_realloc ( p -> aMatch , p -> nAlloc * sizeof ( p -> aMatch [ 0 ] ) ) ; 
line 106044: if ( pNew == 0 ) { 
line 106045: p -> aMatch = 0 ; 
line 106046: p -> nMatch = 0 ; 
line 106047: p -> nAlloc = 0 ; 
line 106048: return SQLITE_NOMEM ; 
line 106049: } 
line 106050: p -> aMatch = pNew ; 
line 106051: } 
line 106052: i = p -> nMatch ++ ; 
line 106053: pMatch = & p -> aMatch [ i ] ; 
line 106054: pMatch -> iCol = ( short ) iCol ; 
line 106055: pMatch -> iTerm = ( short ) iTerm ; 
line 106056: pMatch -> iToken = iToken ; 
line 106057: pMatch -> iStart = iStart ; 
line 106058: pMatch -> nByte = ( short ) nByte ; 
line 106059: return SQLITE_OK ; 
line 106060: } 
line 106065: # define FTS3_ROTOR_SZ ( 32 ) 
line 106066: # define FTS3_ROTOR_MASK ( FTS3_ROTOR_SZ - 1 ) 
line 106076: static int fts3NextExprToken ( Fts3Expr * * ppExpr , int * piToken ) { 
line 106077: Fts3Expr * p = * ppExpr ; 
line 106078: int iToken = * piToken ; 
line 106079: if ( iToken < 0 ) { 
line 106083: while ( p -> pLeft ) { 
line 106084: p = p -> pLeft ; 
line 106085: } 
line 106086: iToken = 0 ; 
line 106087: } else { 
line 106088: assert ( p && p -> eType == FTSQUERY_PHRASE ) ; 
line 106089: if ( iToken < ( p -> pPhrase -> nToken - 1 ) ) { 
line 106090: iToken ++ ; 
line 106091: } else { 
line 106092: iToken = 0 ; 
line 106093: while ( p -> pParent && p -> pParent -> pLeft != p ) { 
line 106094: assert ( p -> pParent -> pRight == p ) ; 
line 106095: p = p -> pParent ; 
line 106096: } 
line 106097: p = p -> pParent ; 
line 106098: if ( p ) { 
line 106099: assert ( p -> pRight != 0 ) ; 
line 106100: p = p -> pRight ; 
line 106101: while ( p -> pLeft ) { 
line 106102: p = p -> pLeft ; 
line 106103: } 
line 106104: } 
line 106105: } 
line 106106: } 
line 106108: * ppExpr = p ; 
line 106109: * piToken = iToken ; 
line 106110: return p ? 1 : 0 ; 
line 106111: } 
line 106117: static int fts3ExprBeneathNot ( Fts3Expr * p ) { 
line 106118: Fts3Expr * pParent ; 
line 106119: while ( p ) { 
line 106120: pParent = p -> pParent ; 
line 106121: if ( pParent && pParent -> eType == FTSQUERY_NOT && pParent -> pRight == p ) { 
line 106122: return 1 ; 
line 106123: } 
line 106124: p = pParent ; 
line 106125: } 
line 106126: return 0 ; 
line 106127: } 
line 106133: static int snippetOffsetsOfColumn ( 
line 106134: Fts3Cursor * pCur , 
line 106135: Snippet * pSnippet , 
line 106136: int iColumn , 
line 106137: const char * zDoc , 
line 106138: int nDoc 
line 106139: ) { 
line 106140: const sqlite3_tokenizer_module * pTModule ; 
line 106141: sqlite3_tokenizer * pTokenizer ; 
line 106142: sqlite3_tokenizer_cursor * pTCursor ; 
line 106143: Fts3Table * pVtab ; 
line 106144: int nColumn ; 
line 106145: int i , j ; 
line 106146: int rc ; 
line 106147: unsigned int match , prevMatch ; 
line 106148: const char * zToken ; 
line 106149: int nToken ; 
line 106150: int iBegin , iEnd , iPos ; 
line 106154: unsigned int iRotor = 0 ; 
line 106155: int iRotorBegin [ FTS3_ROTOR_SZ ] ; 
line 106156: int iRotorLen [ FTS3_ROTOR_SZ ] ; 
line 106158: pVtab = ( Fts3Table * ) pCur -> base . pVtab ; 
line 106159: nColumn = pVtab -> nColumn ; 
line 106160: pTokenizer = pVtab -> pTokenizer ; 
line 106161: pTModule = pTokenizer -> pModule ; 
line 106162: rc = pTModule -> xOpen ( pTokenizer , zDoc , nDoc , & pTCursor ) ; 
line 106163: if ( rc ) return rc ; 
line 106164: pTCursor -> pTokenizer = pTokenizer ; 
line 106166: prevMatch = 0 ; 
line 106167: while ( ( rc = pTModule -> xNext ( pTCursor , & zToken , & nToken , 
line 106168: & iBegin , & iEnd , & iPos ) ) == SQLITE_OK ) { 
line 106169: Fts3Expr * pIter = pCur -> pExpr ; 
line 106170: int iIter = - 1 ; 
line 106171: iRotorBegin [ iRotor & FTS3_ROTOR_MASK ] = iBegin ; 
line 106172: iRotorLen [ iRotor & FTS3_ROTOR_MASK ] = iEnd - iBegin ; 
line 106173: match = 0 ; 
line 106174: for ( i = 0 ; i < ( FTS3_ROTOR_SZ - 1 ) && fts3NextExprToken ( & pIter , & iIter ) ; i ++ ) { 
line 106175: int nPhrase ; 
line 106176: struct PhraseToken * pToken ; 
line 106177: int iCol ; 
line 106179: if ( fts3ExprBeneathNot ( pIter ) ) continue ; 
line 106180: nPhrase = pIter -> pPhrase -> nToken ; 
line 106181: pToken = & pIter -> pPhrase -> aToken [ iIter ] ; 
line 106182: iCol = pIter -> pPhrase -> iColumn ; 
line 106183: if ( iCol >= 0 && iCol < nColumn && iCol != iColumn ) continue ; 
line 106184: if ( pToken -> n > nToken ) continue ; 
line 106185: if ( ! pToken -> isPrefix && pToken -> n < nToken ) continue ; 
line 106186: assert ( pToken -> n <= nToken ) ; 
line 106187: if ( memcmp ( pToken -> z , zToken , pToken -> n ) ) continue ; 
line 106188: if ( iIter > 0 && ( prevMatch & ( 1 << i ) ) == 0 ) continue ; 
line 106189: match |= 1 << i ; 
line 106190: if ( i == ( FTS3_ROTOR_SZ - 2 ) || nPhrase == iIter + 1 ) { 
line 106191: for ( j = nPhrase - 1 ; j >= 0 ; j -- ) { 
line 106192: int k = ( iRotor - j ) & FTS3_ROTOR_MASK ; 
line 106193: rc = snippetAppendMatch ( pSnippet , iColumn , i - j , iPos - j , 
line 106194: iRotorBegin [ k ] , iRotorLen [ k ] ) ; 
line 106195: if ( rc ) goto end_offsets_of_column ; 
line 106196: } 
line 106197: } 
line 106198: } 
line 106199: prevMatch = match << 1 ; 
line 106200: iRotor ++ ; 
line 106201: } 
line 106202: end_offsets_of_column : 
line 106203: pTModule -> xClose ( pTCursor ) ; 
line 106204: return rc == SQLITE_DONE ? SQLITE_OK : rc ; 
line 106205: } 
line 106232: static int trimSnippetOffsets ( 
line 106233: Fts3Expr * pExpr , 
line 106234: Snippet * pSnippet , 
line 106235: int * piLeft 
line 106236: ) { 
line 106237: if ( pExpr ) { 
line 106238: if ( trimSnippetOffsets ( pExpr -> pLeft , pSnippet , piLeft ) ) { 
line 106239: return 1 ; 
line 106240: } 
line 106242: switch ( pExpr -> eType ) { 
line 106243: case FTSQUERY_PHRASE : 
line 106244: * piLeft += pExpr -> pPhrase -> nToken ; 
line 106245: break ; 
line 106246: case FTSQUERY_NEAR : { 
line 106259: Fts3Expr * pLeft = pExpr -> pLeft ; 
line 106260: Fts3Expr * pRight = pExpr -> pRight ; 
line 106261: int iLeft = * piLeft ; 
line 106262: int nNear = pExpr -> nNear ; 
line 106263: int nToken = pRight -> pPhrase -> nToken ; 
line 106264: int jj , ii ; 
line 106265: if ( pLeft -> eType == FTSQUERY_NEAR ) { 
line 106266: pLeft = pLeft -> pRight ; 
line 106267: } 
line 106268: assert ( pRight -> eType == FTSQUERY_PHRASE ) ; 
line 106269: assert ( pLeft -> eType == FTSQUERY_PHRASE ) ; 
line 106270: nToken += pLeft -> pPhrase -> nToken ; 
line 106272: for ( ii = 0 ; ii < pSnippet -> nMatch ; ii ++ ) { 
line 106273: struct snippetMatch * p = & pSnippet -> aMatch [ ii ] ; 
line 106274: if ( p -> iTerm == iLeft ) { 
line 106275: int isOk = 0 ; 
line 106285: for ( jj = 0 ; isOk == 0 && jj < pSnippet -> nMatch ; jj ++ ) { 
line 106286: struct snippetMatch * p2 = & pSnippet -> aMatch [ jj ] ; 
line 106287: if ( p2 -> iTerm == ( iLeft - 1 ) ) { 
line 106288: if ( p2 -> iToken >= ( p -> iToken - nNear - 1 ) 
line 106289: && p2 -> iToken < ( p -> iToken + nNear + nToken ) 
line 106290: ) { 
line 106291: isOk = 1 ; 
line 106292: } 
line 106293: } 
line 106294: } 
line 106295: if ( ! isOk ) { 
line 106296: int kk ; 
line 106297: for ( kk = 0 ; kk < pRight -> pPhrase -> nToken ; kk ++ ) { 
line 106298: pSnippet -> aMatch [ kk + ii ] . iTerm = - 2 ; 
line 106299: } 
line 106300: return 1 ; 
line 106301: } 
line 106302: } 
line 106303: if ( p -> iTerm == ( iLeft - 1 ) ) { 
line 106304: int isOk = 0 ; 
line 106305: for ( jj = 0 ; isOk == 0 && jj < pSnippet -> nMatch ; jj ++ ) { 
line 106306: struct snippetMatch * p2 = & pSnippet -> aMatch [ jj ] ; 
line 106307: if ( p2 -> iTerm == iLeft ) { 
line 106308: if ( p2 -> iToken <= ( p -> iToken + nNear + 1 ) 
line 106309: && p2 -> iToken > ( p -> iToken - nNear - nToken ) 
line 106310: ) { 
line 106311: isOk = 1 ; 
line 106312: } 
line 106313: } 
line 106314: } 
line 106315: if ( ! isOk ) { 
line 106316: int kk ; 
line 106317: for ( kk = 0 ; kk < pLeft -> pPhrase -> nToken ; kk ++ ) { 
line 106318: pSnippet -> aMatch [ ii - kk ] . iTerm = - 2 ; 
line 106319: } 
line 106320: return 1 ; 
line 106321: } 
line 106322: } 
line 106323: } 
line 106324: break ; 
line 106325: } 
line 106326: } 
line 106328: if ( trimSnippetOffsets ( pExpr -> pRight , pSnippet , piLeft ) ) { 
line 106329: return 1 ; 
line 106330: } 
line 106331: } 
line 106332: return 0 ; 
line 106333: } 
line 106339: static int snippetAllOffsets ( Fts3Cursor * pCsr , Snippet * * ppSnippet ) { 
line 106340: Fts3Table * p = ( Fts3Table * ) pCsr -> base . pVtab ; 
line 106341: int nColumn ; 
line 106342: int iColumn ; 
line 106343: int i ; 
line 106344: int iFirst ; 
line 106345: int iLast ; 
line 106346: int iTerm = 0 ; 
line 106347: Snippet * pSnippet ; 
line 106348: int rc = SQLITE_OK ; 
line 106350: if ( pCsr -> pExpr == 0 ) { 
line 106351: return SQLITE_OK ; 
line 106352: } 
line 106354: pSnippet = ( Snippet * ) sqlite3_malloc ( sizeof ( Snippet ) ) ; 
line 106355: * ppSnippet = pSnippet ; 
line 106356: if ( ! pSnippet ) { 
line 106357: return SQLITE_NOMEM ; 
line 106358: } 
line 106359: memset ( pSnippet , 0 , sizeof ( Snippet ) ) ; 
line 106361: nColumn = p -> nColumn ; 
line 106362: iColumn = ( pCsr -> eSearch - 2 ) ; 
line 106363: if ( iColumn < 0 || iColumn >= nColumn ) { 
line 106365: iFirst = 0 ; 
line 106366: iLast = nColumn - 1 ; 
line 106367: } else { 
line 106369: iFirst = iColumn ; 
line 106370: iLast = iColumn ; 
line 106371: } 
line 106372: for ( i = iFirst ; rc == SQLITE_OK && i <= iLast ; i ++ ) { 
line 106373: const char * zDoc ; 
line 106374: int nDoc ; 
line 106375: zDoc = ( const char * ) sqlite3_column_text ( pCsr -> pStmt , i + 1 ) ; 
line 106376: nDoc = sqlite3_column_bytes ( pCsr -> pStmt , i + 1 ) ; 
line 106377: if ( zDoc == 0 && sqlite3_column_type ( pCsr -> pStmt , i + 1 ) != SQLITE_NULL ) { 
line 106378: rc = SQLITE_NOMEM ; 
line 106379: } else { 
line 106380: rc = snippetOffsetsOfColumn ( pCsr , pSnippet , i , zDoc , nDoc ) ; 
line 106381: } 
line 106382: } 
line 106384: while ( trimSnippetOffsets ( pCsr -> pExpr , pSnippet , & iTerm ) ) { 
line 106385: iTerm = 0 ; 
line 106386: } 
line 106388: return rc ; 
line 106389: } 
line 106396: static void snippetOffsetText ( Snippet * p ) { 
line 106397: int i ; 
line 106398: int cnt = 0 ; 
line 106399: StringBuffer sb ; 
line 106400: char zBuf [ 200 ] ; 
line 106401: if ( p -> zOffset ) return ; 
line 106402: fts3SnippetSbInit ( & sb ) ; 
line 106403: for ( i = 0 ; i < p -> nMatch ; i ++ ) { 
line 106404: struct snippetMatch * pMatch = & p -> aMatch [ i ] ; 
line 106405: if ( pMatch -> iTerm >= 0 ) { 
line 106411: zBuf [ 0 ] = ' ' ; 
line 106412: sqlite3_snprintf ( sizeof ( zBuf ) - 1 , & zBuf [ cnt > 0 ] , "%d %d %d %d" , 
line 106413: pMatch -> iCol , pMatch -> iTerm , pMatch -> iStart , pMatch -> nByte ) ; 
line 106414: fts3SnippetAppend ( & sb , zBuf , - 1 ) ; 
line 106415: cnt ++ ; 
line 106416: } 
line 106417: } 
line 106418: p -> zOffset = sb . z ; 
line 106419: p -> nOffset = sb . z ? sb . nUsed : 0 ; 
line 106420: } 
line 106431: static int wordBoundary ( 
line 106432: int iBreak , 
line 106433: const char * zDoc , 
line 106434: int nDoc , 
line 106435: struct snippetMatch * aMatch , 
line 106436: int nMatch , 
line 106437: int iCol 
line 106438: ) { 
line 106439: int i ; 
line 106440: if ( iBreak <= 10 ) { 
line 106441: return 0 ; 
line 106442: } 
line 106443: if ( iBreak >= nDoc - 10 ) { 
line 106444: return nDoc ; 
line 106445: } 
line 106446: for ( i = 0 ; ALWAYS ( i < nMatch ) && aMatch [ i ] . iCol < iCol ; i ++ ) { } 
line 106447: while ( i < nMatch && aMatch [ i ] . iStart + aMatch [ i ] . nByte < iBreak ) { i ++ ; } 
line 106448: if ( i < nMatch ) { 
line 106449: if ( aMatch [ i ] . iStart < iBreak + 10 ) { 
line 106450: return aMatch [ i ] . iStart ; 
line 106451: } 
line 106452: if ( i > 0 && aMatch [ i - 1 ] . iStart + aMatch [ i - 1 ] . nByte >= iBreak ) { 
line 106453: return aMatch [ i - 1 ] . iStart ; 
line 106454: } 
line 106455: } 
line 106456: for ( i = 1 ; i <= 10 ; i ++ ) { 
line 106457: if ( fts3snippetIsspace ( zDoc [ iBreak - i ] ) ) { 
line 106458: return iBreak - i + 1 ; 
line 106459: } 
line 106460: if ( fts3snippetIsspace ( zDoc [ iBreak + i ] ) ) { 
line 106461: return iBreak + i + 1 ; 
line 106462: } 
line 106463: } 
line 106464: return iBreak ; 
line 106465: } 
line 106472: # define SNIPPET_IGNORE 0 
line 106473: # define SNIPPET_DESIRED 1 
line 106478: static void snippetText ( 
line 106479: Fts3Cursor * pCursor , 
line 106480: Snippet * pSnippet , 
line 106481: const char * zStartMark , 
line 106482: const char * zEndMark , 
line 106483: const char * zEllipsis 
line 106484: ) { 
line 106485: int i , j ; 
line 106486: struct snippetMatch * aMatch ; 
line 106487: int nMatch ; 
line 106488: int nDesired ; 
line 106489: StringBuffer sb ; 
line 106490: int tailCol ; 
line 106491: int tailOffset ; 
line 106492: int iCol ; 
line 106493: int nDoc ; 
line 106494: const char * zDoc ; 
line 106495: int iStart , iEnd ; 
line 106496: int tailEllipsis = 0 ; 
line 106497: int iMatch ; 
line 106500: sqlite3_free ( pSnippet -> zSnippet ) ; 
line 106501: pSnippet -> zSnippet = 0 ; 
line 106502: aMatch = pSnippet -> aMatch ; 
line 106503: nMatch = pSnippet -> nMatch ; 
line 106504: fts3SnippetSbInit ( & sb ) ; 
line 106506: for ( i = 0 ; i < nMatch ; i ++ ) { 
line 106507: aMatch [ i ] . snStatus = SNIPPET_IGNORE ; 
line 106508: } 
line 106509: nDesired = 0 ; 
line 106510: for ( i = 0 ; i < FTS3_ROTOR_SZ ; i ++ ) { 
line 106511: for ( j = 0 ; j < nMatch ; j ++ ) { 
line 106512: if ( aMatch [ j ] . iTerm == i ) { 
line 106513: aMatch [ j ] . snStatus = SNIPPET_DESIRED ; 
line 106514: nDesired ++ ; 
line 106515: break ; 
line 106516: } 
line 106517: } 
line 106518: } 
line 106520: iMatch = 0 ; 
line 106521: tailCol = - 1 ; 
line 106522: tailOffset = 0 ; 
line 106523: for ( i = 0 ; i < nMatch && nDesired > 0 ; i ++ ) { 
line 106524: if ( aMatch [ i ] . snStatus != SNIPPET_DESIRED ) continue ; 
line 106525: nDesired -- ; 
line 106526: iCol = aMatch [ i ] . iCol ; 
line 106527: zDoc = ( const char * ) sqlite3_column_text ( pCursor -> pStmt , iCol + 1 ) ; 
line 106528: nDoc = sqlite3_column_bytes ( pCursor -> pStmt , iCol + 1 ) ; 
line 106529: iStart = aMatch [ i ] . iStart - 40 ; 
line 106530: iStart = wordBoundary ( iStart , zDoc , nDoc , aMatch , nMatch , iCol ) ; 
line 106531: if ( iStart <= 10 ) { 
line 106532: iStart = 0 ; 
line 106533: } 
line 106534: if ( iCol == tailCol && iStart <= tailOffset + 20 ) { 
line 106535: iStart = tailOffset ; 
line 106536: } 
line 106537: if ( ( iCol != tailCol && tailCol >= 0 ) || iStart != tailOffset ) { 
line 106538: fts3SnippetTrimWhiteSpace ( & sb ) ; 
line 106539: fts3SnippetAppendWhiteSpace ( & sb ) ; 
line 106540: fts3SnippetAppend ( & sb , zEllipsis , - 1 ) ; 
line 106541: fts3SnippetAppendWhiteSpace ( & sb ) ; 
line 106542: } 
line 106543: iEnd = aMatch [ i ] . iStart + aMatch [ i ] . nByte + 40 ; 
line 106544: iEnd = wordBoundary ( iEnd , zDoc , nDoc , aMatch , nMatch , iCol ) ; 
line 106545: if ( iEnd >= nDoc - 10 ) { 
line 106546: iEnd = nDoc ; 
line 106547: tailEllipsis = 0 ; 
line 106548: } else { 
line 106549: tailEllipsis = 1 ; 
line 106550: } 
line 106551: while ( iMatch < nMatch && aMatch [ iMatch ] . iCol < iCol ) { iMatch ++ ; } 
line 106552: while ( iStart < iEnd ) { 
line 106553: while ( iMatch < nMatch && aMatch [ iMatch ] . iStart < iStart 
line 106554: && aMatch [ iMatch ] . iCol <= iCol ) { 
line 106555: iMatch ++ ; 
line 106556: } 
line 106557: if ( iMatch < nMatch && aMatch [ iMatch ] . iStart < iEnd 
line 106558: && aMatch [ iMatch ] . iCol == iCol ) { 
line 106559: fts3SnippetAppend ( & sb , & zDoc [ iStart ] , aMatch [ iMatch ] . iStart - iStart ) ; 
line 106560: iStart = aMatch [ iMatch ] . iStart ; 
line 106561: fts3SnippetAppend ( & sb , zStartMark , - 1 ) ; 
line 106562: fts3SnippetAppend ( & sb , & zDoc [ iStart ] , aMatch [ iMatch ] . nByte ) ; 
line 106563: fts3SnippetAppend ( & sb , zEndMark , - 1 ) ; 
line 106564: iStart += aMatch [ iMatch ] . nByte ; 
line 106565: for ( j = iMatch + 1 ; j < nMatch ; j ++ ) { 
line 106566: if ( aMatch [ j ] . iTerm == aMatch [ iMatch ] . iTerm 
line 106567: && aMatch [ j ] . snStatus == SNIPPET_DESIRED ) { 
line 106568: nDesired -- ; 
line 106569: aMatch [ j ] . snStatus = SNIPPET_IGNORE ; 
line 106570: } 
line 106571: } 
line 106572: } else { 
line 106573: fts3SnippetAppend ( & sb , & zDoc [ iStart ] , iEnd - iStart ) ; 
line 106574: iStart = iEnd ; 
line 106575: } 
line 106576: } 
line 106577: tailCol = iCol ; 
line 106578: tailOffset = iEnd ; 
line 106579: } 
line 106580: fts3SnippetTrimWhiteSpace ( & sb ) ; 
line 106581: if ( tailEllipsis ) { 
line 106582: fts3SnippetAppendWhiteSpace ( & sb ) ; 
line 106583: fts3SnippetAppend ( & sb , zEllipsis , - 1 ) ; 
line 106584: } 
line 106585: pSnippet -> zSnippet = sb . z ; 
line 106586: pSnippet -> nSnippet = sb . z ? sb . nUsed : 0 ; 
line 106587: } 
line 106589: SQLITE_PRIVATE void sqlite3Fts3Offsets ( 
line 106590: sqlite3_context * pCtx , 
line 106591: Fts3Cursor * pCsr 
line 106592: ) { 
line 106593: Snippet * p ; 
line 106594: int rc = snippetAllOffsets ( pCsr , & p ) ; 
line 106595: if ( rc == SQLITE_OK ) { 
line 106596: snippetOffsetText ( p ) ; 
line 106597: if ( p -> zOffset ) { 
line 106598: sqlite3_result_text ( pCtx , p -> zOffset , p -> nOffset , SQLITE_TRANSIENT ) ; 
line 106599: } else { 
line 106600: sqlite3_result_error_nomem ( pCtx ) ; 
line 106601: } 
line 106602: } else { 
line 106603: sqlite3_result_error_nomem ( pCtx ) ; 
line 106604: } 
line 106605: fts3SnippetFree ( p ) ; 
line 106606: } 
line 106608: SQLITE_PRIVATE void sqlite3Fts3Snippet ( 
line 106609: sqlite3_context * pCtx , 
line 106610: Fts3Cursor * pCsr , 
line 106611: const char * zStart , 
line 106612: const char * zEnd , 
line 106613: const char * zEllipsis 
line 106614: ) { 
line 106615: Snippet * p ; 
line 106616: int rc = snippetAllOffsets ( pCsr , & p ) ; 
line 106617: if ( rc == SQLITE_OK ) { 
line 106618: snippetText ( pCsr , p , zStart , zEnd , zEllipsis ) ; 
line 106619: if ( p -> zSnippet ) { 
line 106620: sqlite3_result_text ( pCtx , p -> zSnippet , p -> nSnippet , SQLITE_TRANSIENT ) ; 
line 106621: } else { 
line 106622: sqlite3_result_error_nomem ( pCtx ) ; 
line 106623: } 
line 106624: } else { 
line 106625: sqlite3_result_error_nomem ( pCtx ) ; 
line 106626: } 
line 106627: fts3SnippetFree ( p ) ; 
line 106628: } 
line 106634: # define SNIPPET_BUFFER_CHUNK 64 
line 106635: # define SNIPPET_BUFFER_SIZE SNIPPET_BUFFER_CHUNK * 4 
line 106636: # define SNIPPET_BUFFER_MASK ( SNIPPET_BUFFER_SIZE - 1 ) 
line 106638: static void fts3GetDeltaPosition ( char * * pp , int * piPos ) { 
line 106639: int iVal ; 
line 106640: * pp += sqlite3Fts3GetVarint32 ( * pp , & iVal ) ; 
line 106641: * piPos += ( iVal - 2 ) ; 
line 106642: } 
line 106654: static int fts3ExprIterate ( 
line 106655: Fts3Expr * pExpr , 
line 106656: int ( * x ) ( Fts3Expr * , void * ) , 
line 106657: void * pCtx 
line 106658: ) { 
line 106659: int rc ; 
line 106660: int eType = pExpr -> eType ; 
line 106661: if ( eType == FTSQUERY_NOT ) { 
line 106662: rc = SQLITE_OK ; 
line 106663: } else if ( eType != FTSQUERY_PHRASE ) { 
line 106664: assert ( pExpr -> pLeft && pExpr -> pRight ) ; 
line 106665: rc = fts3ExprIterate ( pExpr -> pLeft , x , pCtx ) ; 
line 106666: if ( rc == SQLITE_OK ) { 
line 106667: rc = fts3ExprIterate ( pExpr -> pRight , x , pCtx ) ; 
line 106668: } 
line 106669: } else { 
line 106670: rc = x ( pExpr , pCtx ) ; 
line 106671: } 
line 106672: return rc ; 
line 106673: } 
line 106675: typedef struct LoadDoclistCtx LoadDoclistCtx ; 
line 106676: struct LoadDoclistCtx { 
line 106677: Fts3Table * pTab ; 
line 106678: int nPhrase ; 
line 106679: } ; 
line 106681: static int fts3ExprLoadDoclistsCb ( Fts3Expr * pExpr , void * ctx ) { 
line 106682: int rc = SQLITE_OK ; 
line 106683: LoadDoclistCtx * p = ( LoadDoclistCtx * ) ctx ; 
line 106684: p -> nPhrase ++ ; 
line 106685: if ( pExpr -> isLoaded == 0 ) { 
line 106686: rc = sqlite3Fts3ExprLoadDoclist ( p -> pTab , pExpr ) ; 
line 106687: pExpr -> isLoaded = 1 ; 
line 106688: if ( rc == SQLITE_OK && pExpr -> aDoclist ) { 
line 106689: pExpr -> pCurrent = pExpr -> aDoclist ; 
line 106690: pExpr -> pCurrent += sqlite3Fts3GetVarint ( pExpr -> pCurrent , & pExpr -> iCurrent ) ; 
line 106691: } 
line 106692: } 
line 106693: return rc ; 
line 106694: } 
line 106696: static int fts3ExprLoadDoclists ( Fts3Cursor * pCsr , int * pnPhrase ) { 
line 106697: int rc ; 
line 106698: LoadDoclistCtx sCtx = { 0 , 0 } ; 
line 106699: sCtx . pTab = ( Fts3Table * ) pCsr -> base . pVtab ; 
line 106700: rc = fts3ExprIterate ( pCsr -> pExpr , fts3ExprLoadDoclistsCb , ( void * ) & sCtx ) ; 
line 106701: * pnPhrase = sCtx . nPhrase ; 
line 106702: return rc ; 
line 106703: } 
line 106713: static int fts3LoadSnippetBuffer ( 
line 106714: int iPos , 
line 106715: u8 * aBuffer , 
line 106716: int nList , 
line 106717: char * * apList , 
line 106718: int * aiPrev 
line 106719: ) { 
line 106720: int i ; 
line 106721: int nFin = 0 ; 
line 106723: assert ( ( iPos & ( SNIPPET_BUFFER_CHUNK - 1 ) ) == 0 ) ; 
line 106725: memset ( & aBuffer [ iPos & SNIPPET_BUFFER_MASK ] , 0 , SNIPPET_BUFFER_CHUNK ) ; 
line 106727: for ( i = 0 ; i < nList ; i ++ ) { 
line 106728: int iPrev = aiPrev [ i ] ; 
line 106729: char * pList = apList [ i ] ; 
line 106731: if ( ! pList ) { 
line 106732: nFin ++ ; 
line 106733: continue ; 
line 106734: } 
line 106736: while ( iPrev < ( iPos + SNIPPET_BUFFER_CHUNK ) ) { 
line 106737: if ( iPrev >= iPos ) { 
line 106738: aBuffer [ iPrev & SNIPPET_BUFFER_MASK ] = ( u8 ) ( i + 1 ) ; 
line 106739: } 
line 106740: if ( 0 == ( ( * pList ) & 0xFE ) ) { 
line 106741: nFin ++ ; 
line 106742: break ; 
line 106743: } 
line 106744: fts3GetDeltaPosition ( & pList , & iPrev ) ; 
line 106745: } 
line 106747: aiPrev [ i ] = iPrev ; 
line 106748: apList [ i ] = pList ; 
line 106749: } 
line 106751: return ( nFin == nList ) ; 
line 106752: } 
line 106754: typedef struct SnippetCtx SnippetCtx ; 
line 106755: struct SnippetCtx { 
line 106756: Fts3Cursor * pCsr ; 
line 106757: int iCol ; 
line 106758: int iPhrase ; 
line 106759: int * aiPrev ; 
line 106760: int * anToken ; 
line 106761: char * * apList ; 
line 106762: } ; 
line 106764: static int fts3SnippetFindPositions ( Fts3Expr * pExpr , void * ctx ) { 
line 106765: SnippetCtx * p = ( SnippetCtx * ) ctx ; 
line 106766: int iPhrase = p -> iPhrase ++ ; 
line 106767: char * pCsr ; 
line 106769: p -> anToken [ iPhrase ] = pExpr -> pPhrase -> nToken ; 
line 106770: pCsr = sqlite3Fts3FindPositions ( pExpr , p -> pCsr -> iPrevId , p -> iCol ) ; 
line 106772: if ( pCsr ) { 
line 106773: int iVal ; 
line 106774: pCsr += sqlite3Fts3GetVarint32 ( pCsr , & iVal ) ; 
line 106775: p -> apList [ iPhrase ] = pCsr ; 
line 106776: p -> aiPrev [ iPhrase ] = iVal - 2 ; 
line 106777: } 
line 106778: return SQLITE_OK ; 
line 106779: } 
line 106781: static void fts3SnippetCnt ( 
line 106782: int iIdx , 
line 106783: int nSnippet , 
line 106784: int * anCnt , 
line 106785: u8 * aBuffer , 
line 106786: int * anToken , 
line 106787: u64 * pHlmask 
line 106788: ) { 
line 106789: int iSub = ( iIdx - 1 ) & SNIPPET_BUFFER_MASK ; 
line 106790: int iAdd = ( iIdx + nSnippet - 1 ) & SNIPPET_BUFFER_MASK ; 
line 106791: int iSub2 = ( iIdx + ( nSnippet / 3 ) - 1 ) & SNIPPET_BUFFER_MASK ; 
line 106792: int iAdd2 = ( iIdx + ( nSnippet * 2 / 3 ) - 1 ) & SNIPPET_BUFFER_MASK ; 
line 106794: u64 h = * pHlmask ; 
line 106796: anCnt [ aBuffer [ iSub ] ] -- ; 
line 106797: anCnt [ aBuffer [ iSub2 ] ] -- ; 
line 106798: anCnt [ aBuffer [ iAdd ] ] ++ ; 
line 106799: anCnt [ aBuffer [ iAdd2 ] ] ++ ; 
line 106801: h = h >> 1 ; 
line 106802: if ( aBuffer [ iAdd ] ) { 
line 106803: int j ; 
line 106804: for ( j = anToken [ aBuffer [ iAdd ] - 1 ] ; j >= 1 ; j -- ) { 
line 106805: h |= ( u64 ) 1 << ( nSnippet - j ) ; 
line 106806: } 
line 106807: } 
line 106808: * pHlmask = h ; 
line 106809: } 
line 106811: static int fts3SnippetScore ( int n , int * anCnt ) { 
line 106812: int j ; 
line 106813: int iScore = 0 ; 
line 106814: for ( j = 1 ; j <= n ; j ++ ) { 
line 106815: int nCnt = anCnt [ j ] ; 
line 106816: iScore += nCnt + ( nCnt ? 1000 : 0 ) ; 
line 106817: } 
line 106818: return iScore ; 
line 106819: } 
line 106821: static int fts3BestSnippet ( 
line 106822: int nSnippet , 
line 106823: Fts3Cursor * pCsr , 
line 106824: int iCol , 
line 106825: int * piPos , 
line 106826: u64 * pHlmask 
line 106827: ) { 
line 106828: int rc ; 
line 106829: u8 aBuffer [ SNIPPET_BUFFER_SIZE ] ; 
line 106830: int * aiPrev ; 
line 106831: int * anToken ; 
line 106832: char * * apList ; 
line 106833: int * anCnt ; 
line 106834: int nList ; 
line 106836: int i ; 
line 106838: u64 hlmask = 0 ; 
line 106839: u64 besthlmask = 0 ; 
line 106840: int iBestPos = 0 ; 
line 106841: int iBestScore = 0 ; 
line 106842: SnippetCtx sCtx ; 
line 106847: rc = fts3ExprLoadDoclists ( pCsr , & nList ) ; 
line 106848: if ( rc != SQLITE_OK ) { 
line 106849: return rc ; 
line 106850: } 
line 106855: apList = sqlite3_malloc ( 
line 106856: sizeof ( u8 * ) * nList + 
line 106857: sizeof ( int ) * ( nList ) + 
line 106858: sizeof ( int ) * nList + 
line 106859: sizeof ( int ) * ( nList + 1 ) 
line 106860: ) ; 
line 106861: if ( ! apList ) { 
line 106862: return SQLITE_NOMEM ; 
line 106863: } 
line 106864: memset ( apList , 0 , sizeof ( u8 * ) * nList + sizeof ( int ) * nList + sizeof ( int ) * nList ) ; 
line 106865: anToken = ( int * ) & apList [ nList ] ; 
line 106866: aiPrev = & anToken [ nList ] ; 
line 106867: anCnt = & aiPrev [ nList ] ; 
line 106870: sCtx . pCsr = pCsr ; 
line 106871: sCtx . iCol = iCol ; 
line 106872: sCtx . apList = apList ; 
line 106873: sCtx . aiPrev = aiPrev ; 
line 106874: sCtx . anToken = anToken ; 
line 106875: sCtx . iPhrase = 0 ; 
line 106876: ( void ) fts3ExprIterate ( pCsr -> pExpr , fts3SnippetFindPositions , ( void * ) & sCtx ) ; 
line 106879: memset ( aBuffer , 0 , SNIPPET_BUFFER_SIZE ) ; 
line 106880: fts3LoadSnippetBuffer ( 0 , aBuffer , nList , apList , aiPrev ) ; 
line 106881: fts3LoadSnippetBuffer ( SNIPPET_BUFFER_CHUNK , aBuffer , nList , apList , aiPrev ) ; 
line 106884: for ( i = 1 - nSnippet ; i <= 0 ; i ++ ) { 
line 106885: fts3SnippetCnt ( i , nSnippet , anCnt , aBuffer , anToken , & hlmask ) ; 
line 106886: } 
line 106887: iBestScore = fts3SnippetScore ( nList , anCnt ) ; 
line 106888: besthlmask = hlmask ; 
line 106889: iBestPos = 0 ; 
line 106891: for ( i = 1 ; 1 ; i ++ ) { 
line 106892: int iScore ; 
line 106894: if ( 0 == ( i & ( SNIPPET_BUFFER_CHUNK - 1 ) ) ) { 
line 106895: int iLoad = i + SNIPPET_BUFFER_CHUNK ; 
line 106896: if ( fts3LoadSnippetBuffer ( iLoad , aBuffer , nList , apList , aiPrev ) ) break ; 
line 106897: } 
line 106904: fts3SnippetCnt ( i , nSnippet , anCnt , aBuffer , anToken , & hlmask ) ; 
line 106905: iScore = fts3SnippetScore ( nList , anCnt ) ; 
line 106906: if ( iScore > iBestScore ) { 
line 106907: iBestPos = i ; 
line 106908: iBestScore = iScore ; 
line 106909: besthlmask = hlmask ; 
line 106910: } 
line 106911: } 
line 106913: sqlite3_free ( apList ) ; 
line 106914: * piPos = iBestPos ; 
line 106915: * pHlmask = besthlmask ; 
line 106916: return SQLITE_OK ; 
line 106917: } 
line 106919: typedef struct StrBuffer StrBuffer ; 
line 106920: struct StrBuffer { 
line 106921: char * z ; 
line 106922: int n ; 
line 106923: int nAlloc ; 
line 106924: } ; 
line 106926: static int fts3StringAppend ( 
line 106927: StrBuffer * pStr , 
line 106928: const char * zAppend , 
line 106929: int nAppend 
line 106930: ) { 
line 106931: if ( nAppend < 0 ) { 
line 106932: nAppend = ( int ) strlen ( zAppend ) ; 
line 106933: } 
line 106935: if ( pStr -> n + nAppend + 1 >= pStr -> nAlloc ) { 
line 106936: int nAlloc = pStr -> nAlloc + nAppend + 100 ; 
line 106937: char * zNew = sqlite3_realloc ( pStr -> z , nAlloc ) ; 
line 106938: if ( ! zNew ) { 
line 106939: return SQLITE_NOMEM ; 
line 106940: } 
line 106941: pStr -> z = zNew ; 
line 106942: pStr -> nAlloc = nAlloc ; 
line 106943: } 
line 106945: memcpy ( & pStr -> z [ pStr -> n ] , zAppend , nAppend ) ; 
line 106946: pStr -> n += nAppend ; 
line 106947: pStr -> z [ pStr -> n ] = '\0' ; 
line 106949: return SQLITE_OK ; 
line 106950: } 
line 106952: static int fts3SnippetText ( 
line 106953: Fts3Cursor * pCsr , 
line 106954: const char * zDoc , 
line 106955: int nDoc , 
line 106956: int nSnippet , 
line 106957: int iPos , 
line 106958: u64 hlmask , 
line 106959: const char * zOpen , 
line 106960: const char * zClose , 
line 106961: const char * zEllipsis , 
line 106962: char * * pzSnippet 
line 106963: ) { 
line 106964: Fts3Table * pTab = ( Fts3Table * ) pCsr -> base . pVtab ; 
line 106965: int rc ; 
line 106966: int iCurrent = 0 ; 
line 106967: int iStart = 0 ; 
line 106968: int iEnd ; 
line 106970: sqlite3_tokenizer_module * pMod ; 
line 106971: sqlite3_tokenizer_cursor * pC ; 
line 106972: const char * ZDUMMY ; 
line 106973: int DUMMY1 , DUMMY2 , DUMMY3 ; 
line 106975: StrBuffer res = { 0 , 0 , 0 } ; 
line 106981: pMod = ( sqlite3_tokenizer_module * ) pTab -> pTokenizer -> pModule ; 
line 106982: rc = pMod -> xOpen ( pTab -> pTokenizer , zDoc , nDoc , & pC ) ; 
line 106983: while ( rc == SQLITE_OK && iCurrent < iPos ) { 
line 106984: rc = pMod -> xNext ( pC , & ZDUMMY , & DUMMY1 , & iStart , & DUMMY2 , & iCurrent ) ; 
line 106985: } 
line 106986: iEnd = iStart ; 
line 106988: if ( rc == SQLITE_OK && iStart > 0 ) { 
line 106989: rc = fts3StringAppend ( & res , zEllipsis , - 1 ) ; 
line 106990: } 
line 106992: while ( rc == SQLITE_OK ) { 
line 106993: int iBegin ; 
line 106994: int iFin ; 
line 106995: rc = pMod -> xNext ( pC , & ZDUMMY , & DUMMY1 , & iBegin , & iFin , & iCurrent ) ; 
line 106997: if ( rc == SQLITE_OK ) { 
line 106998: if ( iCurrent >= ( iPos + nSnippet ) ) { 
line 106999: rc = SQLITE_DONE ; 
line 107000: } else { 
line 107001: iEnd = iFin ; 
line 107002: if ( hlmask & ( ( u64 ) 1 << ( iCurrent - iPos ) ) ) { 
line 107003: if ( fts3StringAppend ( & res , & zDoc [ iStart ] , iBegin - iStart ) 
line 107004: || fts3StringAppend ( & res , zOpen , - 1 ) 
line 107005: || fts3StringAppend ( & res , & zDoc [ iBegin ] , iEnd - iBegin ) 
line 107006: || fts3StringAppend ( & res , zClose , - 1 ) 
line 107007: ) { 
line 107008: rc = SQLITE_NOMEM ; 
line 107009: } 
line 107010: iStart = iEnd ; 
line 107011: } 
line 107012: } 
line 107013: } 
line 107014: } 
line 107015: assert ( rc != SQLITE_OK ) ; 
line 107016: if ( rc == SQLITE_DONE ) { 
line 107017: rc = fts3StringAppend ( & res , & zDoc [ iStart ] , iEnd - iStart ) ; 
line 107018: if ( rc == SQLITE_OK ) { 
line 107019: rc = pMod -> xNext ( pC , & ZDUMMY , & DUMMY1 , & DUMMY2 , & DUMMY3 , & iCurrent ) ; 
line 107020: if ( rc == SQLITE_OK ) { 
line 107021: rc = fts3StringAppend ( & res , zEllipsis , - 1 ) ; 
line 107022: } else if ( rc == SQLITE_DONE ) { 
line 107023: rc = fts3StringAppend ( & res , & zDoc [ iEnd ] , - 1 ) ; 
line 107024: } 
line 107025: } 
line 107026: } 
line 107028: pMod -> xClose ( pC ) ; 
line 107029: if ( rc != SQLITE_OK ) { 
line 107030: sqlite3_free ( res . z ) ; 
line 107031: } else { 
line 107032: * pzSnippet = res . z ; 
line 107033: } 
line 107034: return rc ; 
line 107035: } 
line 107060: typedef struct MatchInfo MatchInfo ; 
line 107061: struct MatchInfo { 
line 107062: Fts3Table * pTab ; 
line 107063: Fts3Cursor * pCursor ; 
line 107064: int iPhrase ; 
line 107065: int nCol ; 
line 107066: u32 * aGlobal ; 
line 107067: } ; 
line 107073: static int fts3ColumnlistCount ( char * * ppCollist ) { 
line 107074: char * pEnd = * ppCollist ; 
line 107075: char c = 0 ; 
line 107076: int nEntry = 0 ; 
line 107079: while ( 0xFE & ( * pEnd | c ) ) { 
line 107080: c = * pEnd ++ & 0x80 ; 
line 107081: if ( ! c ) nEntry ++ ; 
line 107082: } 
line 107084: * ppCollist = pEnd ; 
line 107085: return nEntry ; 
line 107086: } 
line 107088: static void fts3LoadColumnlistCounts ( char * * pp , u32 * aOut ) { 
line 107089: char * pCsr = * pp ; 
line 107090: while ( * pCsr ) { 
line 107091: sqlite3_int64 iCol = 0 ; 
line 107092: if ( * pCsr == 0x01 ) { 
line 107093: pCsr ++ ; 
line 107094: pCsr += sqlite3Fts3GetVarint ( pCsr , & iCol ) ; 
line 107095: } 
line 107096: aOut [ iCol ] += fts3ColumnlistCount ( & pCsr ) ; 
line 107097: } 
line 107098: pCsr ++ ; 
line 107099: * pp = pCsr ; 
line 107100: } 
line 107106: static int fts3ExprGlobalMatchinfoCb ( 
line 107107: Fts3Expr * pExpr , 
line 107108: void * pCtx 
line 107109: ) { 
line 107110: MatchInfo * p = ( MatchInfo * ) pCtx ; 
line 107111: char * pCsr ; 
line 107112: char * pEnd ; 
line 107113: const int iStart = 2 + p -> nCol * p -> iPhrase ; 
line 107115: assert ( pExpr -> isLoaded ) ; 
line 107118: pCsr = pExpr -> aDoclist ; 
line 107119: pEnd = & pExpr -> aDoclist [ pExpr -> nDoclist ] ; 
line 107120: while ( pCsr < pEnd ) { 
line 107121: while ( * pCsr ++ & 0x80 ) ; 
line 107122: fts3LoadColumnlistCounts ( & pCsr , & p -> aGlobal [ iStart ] ) ; 
line 107123: } 
line 107125: p -> iPhrase ++ ; 
line 107126: return SQLITE_OK ; 
line 107127: } 
line 107129: static int fts3ExprLocalMatchinfoCb ( 
line 107130: Fts3Expr * pExpr , 
line 107131: void * pCtx 
line 107132: ) { 
line 107133: MatchInfo * p = ( MatchInfo * ) pCtx ; 
line 107134: int iPhrase = p -> iPhrase ++ ; 
line 107136: if ( pExpr -> aDoclist ) { 
line 107137: char * pCsr ; 
line 107138: int iOffset = 2 + p -> nCol * ( p -> aGlobal [ 0 ] + iPhrase ) ; 
line 107140: memset ( & p -> aGlobal [ iOffset ] , 0 , p -> nCol * sizeof ( u32 ) ) ; 
line 107141: pCsr = sqlite3Fts3FindPositions ( pExpr , p -> pCursor -> iPrevId , - 1 ) ; 
line 107142: if ( pCsr ) fts3LoadColumnlistCounts ( & pCsr , & p -> aGlobal [ iOffset ] ) ; 
line 107143: } 
line 107145: return SQLITE_OK ; 
line 107146: } 
line 107152: static int fts3GetMatchinfo ( Fts3Cursor * pCsr ) { 
line 107153: MatchInfo g ; 
line 107154: Fts3Table * pTab = ( Fts3Table * ) pCsr -> base . pVtab ; 
line 107155: if ( pCsr -> aMatchinfo == 0 ) { 
line 107156: int rc ; 
line 107157: int nPhrase ; 
line 107158: int nMatchinfo ; 
line 107160: g . pTab = pTab ; 
line 107161: g . nCol = pTab -> nColumn ; 
line 107162: g . iPhrase = 0 ; 
line 107163: rc = fts3ExprLoadDoclists ( pCsr , & nPhrase ) ; 
line 107164: if ( rc != SQLITE_OK ) { 
line 107165: return rc ; 
line 107166: } 
line 107168: nMatchinfo = 2 + 2 * g . nCol * nPhrase ; 
line 107170: g . iPhrase = 0 ; 
line 107171: g . aGlobal = ( u32 * ) sqlite3_malloc ( sizeof ( u32 ) * nMatchinfo ) ; 
line 107172: if ( ! g . aGlobal ) { 
line 107173: return SQLITE_NOMEM ; 
line 107174: } 
line 107175: memset ( g . aGlobal , 0 , sizeof ( u32 ) * nMatchinfo ) ; 
line 107177: g . aGlobal [ 0 ] = nPhrase ; 
line 107178: g . aGlobal [ 1 ] = g . nCol ; 
line 107179: ( void ) fts3ExprIterate ( pCsr -> pExpr , fts3ExprGlobalMatchinfoCb , ( void * ) & g ) ; 
line 107181: pCsr -> aMatchinfo = g . aGlobal ; 
line 107182: } 
line 107184: g . pTab = pTab ; 
line 107185: g . pCursor = pCsr ; 
line 107186: g . nCol = pTab -> nColumn ; 
line 107187: g . iPhrase = 0 ; 
line 107188: g . aGlobal = pCsr -> aMatchinfo ; 
line 107190: if ( pCsr -> isMatchinfoOk ) { 
line 107191: ( void ) fts3ExprIterate ( pCsr -> pExpr , fts3ExprLocalMatchinfoCb , ( void * ) & g ) ; 
line 107192: pCsr -> isMatchinfoOk = 0 ; 
line 107193: } 
line 107195: return SQLITE_OK ; 
line 107196: } 
line 107198: SQLITE_PRIVATE void sqlite3Fts3Snippet2 ( 
line 107199: sqlite3_context * pCtx , 
line 107200: Fts3Cursor * pCsr , 
line 107201: const char * zStart , 
line 107202: const char * zEnd , 
line 107203: const char * zEllipsis , 
line 107204: int iCol , 
line 107205: int nToken 
line 107206: ) { 
line 107207: int rc ; 
line 107208: int iPos = 0 ; 
line 107209: u64 hlmask = 0 ; 
line 107210: char * z = 0 ; 
line 107211: int nDoc ; 
line 107212: const char * zDoc ; 
line 107214: rc = fts3BestSnippet ( nToken , pCsr , iCol , & iPos , & hlmask ) ; 
line 107216: nDoc = sqlite3_column_bytes ( pCsr -> pStmt , iCol + 1 ) ; 
line 107217: zDoc = ( const char * ) sqlite3_column_text ( pCsr -> pStmt , iCol + 1 ) ; 
line 107219: if ( rc == SQLITE_OK ) { 
line 107220: rc = fts3SnippetText ( 
line 107221: pCsr , zDoc , nDoc , nToken , iPos , hlmask , zStart , zEnd , zEllipsis , & z ) ; 
line 107222: } 
line 107223: if ( rc != SQLITE_OK ) { 
line 107224: sqlite3_result_error_code ( pCtx , rc ) ; 
line 107225: } else { 
line 107226: sqlite3_result_text ( pCtx , z , - 1 , sqlite3_free ) ; 
line 107227: } 
line 107228: } 
line 107230: SQLITE_PRIVATE void sqlite3Fts3Matchinfo ( sqlite3_context * pContext , Fts3Cursor * pCsr ) { 
line 107231: int rc = fts3GetMatchinfo ( pCsr ) ; 
line 107232: if ( rc != SQLITE_OK ) { 
line 107233: sqlite3_result_error_code ( pContext , rc ) ; 
line 107234: } else { 
line 107235: int n = sizeof ( u32 ) * ( 2 + pCsr -> aMatchinfo [ 0 ] * pCsr -> aMatchinfo [ 1 ] * 2 ) ; 
line 107236: sqlite3_result_blob ( pContext , pCsr -> aMatchinfo , n , SQLITE_TRANSIENT ) ; 
line 107237: } 
line 107238: } 
line 107240: # endif 
line 107259: # if ! defined ( SQLITE_CORE ) || defined ( SQLITE_ENABLE_RTREE ) 
line 107272: # define VARIANT_RSTARTREE_CHOOSESUBTREE 0 
line 107273: # define VARIANT_RSTARTREE_REINSERT 1 
line 107278: # define VARIANT_GUTTMAN_QUADRATIC_SPLIT 0 
line 107279: # define VARIANT_GUTTMAN_LINEAR_SPLIT 0 
line 107280: # define VARIANT_RSTARTREE_SPLIT 1 
line 107282: # define VARIANT_GUTTMAN_SPLIT 
line 107283: ( VARIANT_GUTTMAN_LINEAR_SPLIT || VARIANT_GUTTMAN_QUADRATIC_SPLIT ) 
line 107285: # if VARIANT_GUTTMAN_QUADRATIC_SPLIT 
line 107286: # define PickNext QuadraticPickNext 
line 107287: # define PickSeeds QuadraticPickSeeds 
line 107288: # define AssignCells splitNodeGuttman 
line 107289: # endif 
line 107290: # if VARIANT_GUTTMAN_LINEAR_SPLIT 
line 107291: # define PickNext LinearPickNext 
line 107292: # define PickSeeds LinearPickSeeds 
line 107293: # define AssignCells splitNodeGuttman 
line 107294: # endif 
line 107295: # if VARIANT_RSTARTREE_SPLIT 
line 107296: # define AssignCells splitNodeStartree 
line 107297: # endif 
line 107300: # ifndef SQLITE_CORE 
line 107301: SQLITE_EXTENSION_INIT1 
line 107302: # else 
line 107303: # endif 
line 107306: # ifndef SQLITE_AMALGAMATION 
line 107307: typedef sqlite3_int64 i64 ; 
line 107308: typedef unsigned char u8 ; 
line 107309: typedef unsigned int u32 ; 
line 107310: # endif 
line 107312: typedef struct Rtree Rtree ; 
line 107313: typedef struct RtreeCursor RtreeCursor ; 
line 107314: typedef struct RtreeNode RtreeNode ; 
line 107315: typedef struct RtreeCell RtreeCell ; 
line 107316: typedef struct RtreeConstraint RtreeConstraint ; 
line 107317: typedef union RtreeCoord RtreeCoord ; 
line 107320: # define RTREE_MAX_DIMENSIONS 5 
line 107326: # define HASHSIZE 128 
line 107331: struct Rtree { 
line 107332: sqlite3_vtab base ; 
line 107333: sqlite3 * db ; 
line 107334: int iNodeSize ; 
line 107335: int nDim ; 
line 107336: int nBytesPerCell ; 
line 107337: int iDepth ; 
line 107338: char * zDb ; 
line 107339: char * zName ; 
line 107340: RtreeNode * aHash [ HASHSIZE ] ; 
line 107341: int nBusy ; 
line 107348: RtreeNode * pDeleted ; 
line 107349: int iReinsertHeight ; 
line 107352: sqlite3_stmt * pReadNode ; 
line 107353: sqlite3_stmt * pWriteNode ; 
line 107354: sqlite3_stmt * pDeleteNode ; 
line 107357: sqlite3_stmt * pReadRowid ; 
line 107358: sqlite3_stmt * pWriteRowid ; 
line 107359: sqlite3_stmt * pDeleteRowid ; 
line 107362: sqlite3_stmt * pReadParent ; 
line 107363: sqlite3_stmt * pWriteParent ; 
line 107364: sqlite3_stmt * pDeleteParent ; 
line 107366: int eCoordType ; 
line 107367: } ; 
line 107370: # define RTREE_COORD_REAL32 0 
line 107371: # define RTREE_COORD_INT32 1 
line 107382: # define RTREE_MINCELLS ( p ) ( ( ( ( p ) -> iNodeSize - 4 ) / ( p ) -> nBytesPerCell ) / 3 ) 
line 107383: # define RTREE_REINSERT ( p ) RTREE_MINCELLS ( p ) 
line 107384: # define RTREE_MAXCELLS 51 
line 107389: struct RtreeCursor { 
line 107390: sqlite3_vtab_cursor base ; 
line 107391: RtreeNode * pNode ; 
line 107392: int iCell ; 
line 107393: int iStrategy ; 
line 107394: int nConstraint ; 
line 107395: RtreeConstraint * aConstraint ; 
line 107396: } ; 
line 107398: union RtreeCoord { 
line 107399: float f ; 
line 107400: int i ; 
line 107401: } ; 
line 107408: # define DCOORD ( coord ) ( 
line 107409: ( pRtree -> eCoordType == RTREE_COORD_REAL32 ) ? 
line 107410: ( ( double ) coord . f ) : 
line 107411: ( ( double ) coord . i ) 
line 107412: ) 
line 107417: struct RtreeConstraint { 
line 107418: int iCoord ; 
line 107419: int op ; 
line 107420: double rValue ; 
line 107421: } ; 
line 107424: # define RTREE_EQ 0x41 
line 107425: # define RTREE_LE 0x42 
line 107426: # define RTREE_LT 0x43 
line 107427: # define RTREE_GE 0x44 
line 107428: # define RTREE_GT 0x45 
line 107448: struct RtreeNode { 
line 107449: RtreeNode * pParent ; 
line 107450: i64 iNode ; 
line 107451: int nRef ; 
line 107452: int isDirty ; 
line 107453: u8 * zData ; 
line 107454: RtreeNode * pNext ; 
line 107455: } ; 
line 107456: # define NCELL ( pNode ) readInt16 ( & ( pNode ) -> zData [ 2 ] ) 
line 107461: struct RtreeCell { 
line 107462: i64 iRowid ; 
line 107463: RtreeCoord aCoord [ RTREE_MAX_DIMENSIONS * 2 ] ; 
line 107464: } ; 
line 107466: # ifndef MAX 
line 107467: # define MAX ( x , y ) ( ( x ) < ( y ) ? ( y ) : ( x ) ) 
line 107468: # endif 
line 107469: # ifndef MIN 
line 107470: # define MIN ( x , y ) ( ( x ) > ( y ) ? ( y ) : ( x ) ) 
line 107471: # endif 
line 107477: static int readInt16 ( u8 * p ) { 
line 107478: return ( p [ 0 ] << 8 ) + p [ 1 ] ; 
line 107479: } 
line 107480: static void readCoord ( u8 * p , RtreeCoord * pCoord ) { 
line 107481: u32 i = ( 
line 107482: ( ( ( u32 ) p [ 0 ] ) << 24 ) + 
line 107483: ( ( ( u32 ) p [ 1 ] ) << 16 ) + 
line 107484: ( ( ( u32 ) p [ 2 ] ) << 8 ) + 
line 107485: ( ( ( u32 ) p [ 3 ] ) << 0 ) 
line 107486: ) ; 
line 107487: * ( u32 * ) pCoord = i ; 
line 107488: } 
line 107489: static i64 readInt64 ( u8 * p ) { 
line 107490: return ( 
line 107491: ( ( ( i64 ) p [ 0 ] ) << 56 ) + 
line 107492: ( ( ( i64 ) p [ 1 ] ) << 48 ) + 
line 107493: ( ( ( i64 ) p [ 2 ] ) << 40 ) + 
line 107494: ( ( ( i64 ) p [ 3 ] ) << 32 ) + 
line 107495: ( ( ( i64 ) p [ 4 ] ) << 24 ) + 
line 107496: ( ( ( i64 ) p [ 5 ] ) << 16 ) + 
line 107497: ( ( ( i64 ) p [ 6 ] ) << 8 ) + 
line 107498: ( ( ( i64 ) p [ 7 ] ) << 0 ) 
line 107499: ) ; 
line 107500: } 
line 107507: static int writeInt16 ( u8 * p , int i ) { 
line 107508: p [ 0 ] = ( i >> 8 ) & 0xFF ; 
line 107509: p [ 1 ] = ( i >> 0 ) & 0xFF ; 
line 107510: return 2 ; 
line 107511: } 
line 107512: static int writeCoord ( u8 * p , RtreeCoord * pCoord ) { 
line 107513: u32 i ; 
line 107514: assert ( sizeof ( RtreeCoord ) == 4 ) ; 
line 107515: assert ( sizeof ( u32 ) == 4 ) ; 
line 107516: i = * ( u32 * ) pCoord ; 
line 107517: p [ 0 ] = ( i >> 24 ) & 0xFF ; 
line 107518: p [ 1 ] = ( i >> 16 ) & 0xFF ; 
line 107519: p [ 2 ] = ( i >> 8 ) & 0xFF ; 
line 107520: p [ 3 ] = ( i >> 0 ) & 0xFF ; 
line 107521: return 4 ; 
line 107522: } 
line 107523: static int writeInt64 ( u8 * p , i64 i ) { 
line 107524: p [ 0 ] = ( i >> 56 ) & 0xFF ; 
line 107525: p [ 1 ] = ( i >> 48 ) & 0xFF ; 
line 107526: p [ 2 ] = ( i >> 40 ) & 0xFF ; 
line 107527: p [ 3 ] = ( i >> 32 ) & 0xFF ; 
line 107528: p [ 4 ] = ( i >> 24 ) & 0xFF ; 
line 107529: p [ 5 ] = ( i >> 16 ) & 0xFF ; 
line 107530: p [ 6 ] = ( i >> 8 ) & 0xFF ; 
line 107531: p [ 7 ] = ( i >> 0 ) & 0xFF ; 
line 107532: return 8 ; 
line 107533: } 
line 107538: static void nodeReference ( RtreeNode * p ) { 
line 107539: if ( p ) { 
line 107540: p -> nRef ++ ; 
line 107541: } 
line 107542: } 
line 107547: static void nodeZero ( Rtree * pRtree , RtreeNode * p ) { 
line 107548: if ( p ) { 
line 107549: memset ( & p -> zData [ 2 ] , 0 , pRtree -> iNodeSize - 2 ) ; 
line 107550: p -> isDirty = 1 ; 
line 107551: } 
line 107552: } 
line 107558: static int nodeHash ( i64 iNode ) { 
line 107559: return ( 
line 107560: ( iNode >> 56 ) ^ ( iNode >> 48 ) ^ ( iNode >> 40 ) ^ ( iNode >> 32 ) ^ 
line 107561: ( iNode >> 24 ) ^ ( iNode >> 16 ) ^ ( iNode >> 8 ) ^ ( iNode >> 0 ) 
line 107562: ) % HASHSIZE ; 
line 107563: } 
line 107569: static RtreeNode * nodeHashLookup ( Rtree * pRtree , i64 iNode ) { 
line 107570: RtreeNode * p ; 
line 107571: assert ( iNode != 0 ) ; 
line 107572: for ( p = pRtree -> aHash [ nodeHash ( iNode ) ] ; p && p -> iNode != iNode ; p = p -> pNext ) ; 
line 107573: return p ; 
line 107574: } 
line 107579: static void nodeHashInsert ( Rtree * pRtree , RtreeNode * pNode ) { 
line 107580: if ( pNode ) { 
line 107581: int iHash ; 
line 107582: assert ( pNode -> pNext == 0 ) ; 
line 107583: iHash = nodeHash ( pNode -> iNode ) ; 
line 107584: pNode -> pNext = pRtree -> aHash [ iHash ] ; 
line 107585: pRtree -> aHash [ iHash ] = pNode ; 
line 107586: } 
line 107587: } 
line 107592: static void nodeHashDelete ( Rtree * pRtree , RtreeNode * pNode ) { 
line 107593: RtreeNode * * pp ; 
line 107594: if ( pNode -> iNode != 0 ) { 
line 107595: pp = & pRtree -> aHash [ nodeHash ( pNode -> iNode ) ] ; 
line 107596: for ( ; ( * pp ) != pNode ; pp = & ( * pp ) -> pNext ) { assert ( * pp ) ; } 
line 107597: * pp = pNode -> pNext ; 
line 107598: pNode -> pNext = 0 ; 
line 107599: } 
line 107600: } 
line 107608: static RtreeNode * nodeNew ( Rtree * pRtree , RtreeNode * pParent , int zero ) { 
line 107609: RtreeNode * pNode ; 
line 107610: pNode = ( RtreeNode * ) sqlite3_malloc ( sizeof ( RtreeNode ) + pRtree -> iNodeSize ) ; 
line 107611: if ( pNode ) { 
line 107612: memset ( pNode , 0 , sizeof ( RtreeNode ) + ( zero ? pRtree -> iNodeSize : 0 ) ) ; 
line 107613: pNode -> zData = ( u8 * ) & pNode [ 1 ] ; 
line 107614: pNode -> nRef = 1 ; 
line 107615: pNode -> pParent = pParent ; 
line 107616: pNode -> isDirty = 1 ; 
line 107617: nodeReference ( pParent ) ; 
line 107618: } 
line 107619: return pNode ; 
line 107620: } 
line 107625: static int 
line 107626: nodeAcquire ( 
line 107627: Rtree * pRtree , 
line 107628: i64 iNode , 
line 107629: RtreeNode * pParent , 
line 107630: RtreeNode * * ppNode 
line 107631: ) { 
line 107632: int rc ; 
line 107633: RtreeNode * pNode ; 
line 107638: if ( ( pNode = nodeHashLookup ( pRtree , iNode ) ) ) { 
line 107639: assert ( ! pParent || ! pNode -> pParent || pNode -> pParent == pParent ) ; 
line 107640: if ( pParent && ! pNode -> pParent ) { 
line 107641: nodeReference ( pParent ) ; 
line 107642: pNode -> pParent = pParent ; 
line 107643: } 
line 107644: pNode -> nRef ++ ; 
line 107645: * ppNode = pNode ; 
line 107646: return SQLITE_OK ; 
line 107647: } 
line 107649: pNode = ( RtreeNode * ) sqlite3_malloc ( sizeof ( RtreeNode ) + pRtree -> iNodeSize ) ; 
line 107650: if ( ! pNode ) { 
line 107651: * ppNode = 0 ; 
line 107652: return SQLITE_NOMEM ; 
line 107653: } 
line 107654: pNode -> pParent = pParent ; 
line 107655: pNode -> zData = ( u8 * ) & pNode [ 1 ] ; 
line 107656: pNode -> nRef = 1 ; 
line 107657: pNode -> iNode = iNode ; 
line 107658: pNode -> isDirty = 0 ; 
line 107659: pNode -> pNext = 0 ; 
line 107661: sqlite3_bind_int64 ( pRtree -> pReadNode , 1 , iNode ) ; 
line 107662: rc = sqlite3_step ( pRtree -> pReadNode ) ; 
line 107663: if ( rc == SQLITE_ROW ) { 
line 107664: const u8 * zBlob = sqlite3_column_blob ( pRtree -> pReadNode , 0 ) ; 
line 107665: memcpy ( pNode -> zData , zBlob , pRtree -> iNodeSize ) ; 
line 107666: nodeReference ( pParent ) ; 
line 107667: } else { 
line 107668: sqlite3_free ( pNode ) ; 
line 107669: pNode = 0 ; 
line 107670: } 
line 107672: * ppNode = pNode ; 
line 107673: rc = sqlite3_reset ( pRtree -> pReadNode ) ; 
line 107675: if ( rc == SQLITE_OK && iNode == 1 ) { 
line 107676: pRtree -> iDepth = readInt16 ( pNode -> zData ) ; 
line 107677: } 
line 107679: assert ( ( rc == SQLITE_OK && pNode ) || ( pNode == 0 && rc != SQLITE_OK ) ) ; 
line 107680: nodeHashInsert ( pRtree , pNode ) ; 
line 107682: return rc ; 
line 107683: } 
line 107688: static void nodeOverwriteCell ( 
line 107689: Rtree * pRtree , 
line 107690: RtreeNode * pNode , 
line 107691: RtreeCell * pCell , 
line 107692: int iCell 
line 107693: ) { 
line 107694: int ii ; 
line 107695: u8 * p = & pNode -> zData [ 4 + pRtree -> nBytesPerCell * iCell ] ; 
line 107696: p += writeInt64 ( p , pCell -> iRowid ) ; 
line 107697: for ( ii = 0 ; ii < ( pRtree -> nDim * 2 ) ; ii ++ ) { 
line 107698: p += writeCoord ( p , & pCell -> aCoord [ ii ] ) ; 
line 107699: } 
line 107700: pNode -> isDirty = 1 ; 
line 107701: } 
line 107706: static void nodeDeleteCell ( Rtree * pRtree , RtreeNode * pNode , int iCell ) { 
line 107707: u8 * pDst = & pNode -> zData [ 4 + pRtree -> nBytesPerCell * iCell ] ; 
line 107708: u8 * pSrc = & pDst [ pRtree -> nBytesPerCell ] ; 
line 107709: int nByte = ( NCELL ( pNode ) - iCell - 1 ) * pRtree -> nBytesPerCell ; 
line 107710: memmove ( pDst , pSrc , nByte ) ; 
line 107711: writeInt16 ( & pNode -> zData [ 2 ] , NCELL ( pNode ) - 1 ) ; 
line 107712: pNode -> isDirty = 1 ; 
line 107713: } 
line 107721: static int 
line 107722: nodeInsertCell ( 
line 107723: Rtree * pRtree , 
line 107724: RtreeNode * pNode , 
line 107725: RtreeCell * pCell 
line 107726: ) { 
line 107727: int nCell ; 
line 107728: int nMaxCell ; 
line 107730: nMaxCell = ( pRtree -> iNodeSize - 4 ) / pRtree -> nBytesPerCell ; 
line 107731: nCell = NCELL ( pNode ) ; 
line 107733: assert ( nCell <= nMaxCell ) ; 
line 107735: if ( nCell < nMaxCell ) { 
line 107736: nodeOverwriteCell ( pRtree , pNode , pCell , nCell ) ; 
line 107737: writeInt16 ( & pNode -> zData [ 2 ] , nCell + 1 ) ; 
line 107738: pNode -> isDirty = 1 ; 
line 107739: } 
line 107741: return ( nCell == nMaxCell ) ; 
line 107742: } 
line 107747: static int 
line 107748: nodeWrite ( Rtree * pRtree , RtreeNode * pNode ) { 
line 107749: int rc = SQLITE_OK ; 
line 107750: if ( pNode -> isDirty ) { 
line 107751: sqlite3_stmt * p = pRtree -> pWriteNode ; 
line 107752: if ( pNode -> iNode ) { 
line 107753: sqlite3_bind_int64 ( p , 1 , pNode -> iNode ) ; 
line 107754: } else { 
line 107755: sqlite3_bind_null ( p , 1 ) ; 
line 107756: } 
line 107757: sqlite3_bind_blob ( p , 2 , pNode -> zData , pRtree -> iNodeSize , SQLITE_STATIC ) ; 
line 107758: sqlite3_step ( p ) ; 
line 107759: pNode -> isDirty = 0 ; 
line 107760: rc = sqlite3_reset ( p ) ; 
line 107761: if ( pNode -> iNode == 0 && rc == SQLITE_OK ) { 
line 107762: pNode -> iNode = sqlite3_last_insert_rowid ( pRtree -> db ) ; 
line 107763: nodeHashInsert ( pRtree , pNode ) ; 
line 107764: } 
line 107765: } 
line 107766: return rc ; 
line 107767: } 
line 107773: static int 
line 107774: nodeRelease ( Rtree * pRtree , RtreeNode * pNode ) { 
line 107775: int rc = SQLITE_OK ; 
line 107776: if ( pNode ) { 
line 107777: assert ( pNode -> nRef > 0 ) ; 
line 107778: pNode -> nRef -- ; 
line 107779: if ( pNode -> nRef == 0 ) { 
line 107780: if ( pNode -> iNode == 1 ) { 
line 107781: pRtree -> iDepth = - 1 ; 
line 107782: } 
line 107783: if ( pNode -> pParent ) { 
line 107784: rc = nodeRelease ( pRtree , pNode -> pParent ) ; 
line 107785: } 
line 107786: if ( rc == SQLITE_OK ) { 
line 107787: rc = nodeWrite ( pRtree , pNode ) ; 
line 107788: } 
line 107789: nodeHashDelete ( pRtree , pNode ) ; 
line 107790: sqlite3_free ( pNode ) ; 
line 107791: } 
line 107792: } 
line 107793: return rc ; 
line 107794: } 
line 107801: static i64 nodeGetRowid ( 
line 107802: Rtree * pRtree , 
line 107803: RtreeNode * pNode , 
line 107804: int iCell 
line 107805: ) { 
line 107806: assert ( iCell < NCELL ( pNode ) ) ; 
line 107807: return readInt64 ( & pNode -> zData [ 4 + pRtree -> nBytesPerCell * iCell ] ) ; 
line 107808: } 
line 107813: static void nodeGetCoord ( 
line 107814: Rtree * pRtree , 
line 107815: RtreeNode * pNode , 
line 107816: int iCell , 
line 107817: int iCoord , 
line 107818: RtreeCoord * pCoord 
line 107819: ) { 
line 107820: readCoord ( & pNode -> zData [ 12 + pRtree -> nBytesPerCell * iCell + 4 * iCoord ] , pCoord ) ; 
line 107821: } 
line 107827: static void nodeGetCell ( 
line 107828: Rtree * pRtree , 
line 107829: RtreeNode * pNode , 
line 107830: int iCell , 
line 107831: RtreeCell * pCell 
line 107832: ) { 
line 107833: int ii ; 
line 107834: pCell -> iRowid = nodeGetRowid ( pRtree , pNode , iCell ) ; 
line 107835: for ( ii = 0 ; ii < pRtree -> nDim * 2 ; ii ++ ) { 
line 107836: nodeGetCoord ( pRtree , pNode , iCell , ii , & pCell -> aCoord [ ii ] ) ; 
line 107837: } 
line 107838: } 
line 107844: static int rtreeInit ( 
line 107845: sqlite3 * , void * , int , const char * const * , sqlite3_vtab * * , char * * , int 
line 107846: ) ; 
line 107851: static int rtreeCreate ( 
line 107852: sqlite3 * db , 
line 107853: void * pAux , 
line 107854: int argc , const char * const * argv , 
line 107855: sqlite3_vtab * * ppVtab , 
line 107856: char * * pzErr 
line 107857: ) { 
line 107858: return rtreeInit ( db , pAux , argc , argv , ppVtab , pzErr , 1 ) ; 
line 107859: } 
line 107864: static int rtreeConnect ( 
line 107865: sqlite3 * db , 
line 107866: void * pAux , 
line 107867: int argc , const char * const * argv , 
line 107868: sqlite3_vtab * * ppVtab , 
line 107869: char * * pzErr 
line 107870: ) { 
line 107871: return rtreeInit ( db , pAux , argc , argv , ppVtab , pzErr , 0 ) ; 
line 107872: } 
line 107877: static void rtreeReference ( Rtree * pRtree ) { 
line 107878: pRtree -> nBusy ++ ; 
line 107879: } 
line 107885: static void rtreeRelease ( Rtree * pRtree ) { 
line 107886: pRtree -> nBusy -- ; 
line 107887: if ( pRtree -> nBusy == 0 ) { 
line 107888: sqlite3_finalize ( pRtree -> pReadNode ) ; 
line 107889: sqlite3_finalize ( pRtree -> pWriteNode ) ; 
line 107890: sqlite3_finalize ( pRtree -> pDeleteNode ) ; 
line 107891: sqlite3_finalize ( pRtree -> pReadRowid ) ; 
line 107892: sqlite3_finalize ( pRtree -> pWriteRowid ) ; 
line 107893: sqlite3_finalize ( pRtree -> pDeleteRowid ) ; 
line 107894: sqlite3_finalize ( pRtree -> pReadParent ) ; 
line 107895: sqlite3_finalize ( pRtree -> pWriteParent ) ; 
line 107896: sqlite3_finalize ( pRtree -> pDeleteParent ) ; 
line 107897: sqlite3_free ( pRtree ) ; 
line 107898: } 
line 107899: } 
line 107904: static int rtreeDisconnect ( sqlite3_vtab * pVtab ) { 
line 107905: rtreeRelease ( ( Rtree * ) pVtab ) ; 
line 107906: return SQLITE_OK ; 
line 107907: } 
line 107912: static int rtreeDestroy ( sqlite3_vtab * pVtab ) { 
line 107913: Rtree * pRtree = ( Rtree * ) pVtab ; 
line 107914: int rc ; 
line 107915: char * zCreate = sqlite3_mprintf ( 
line 107916: "DROP TABLE '%q'.'%q_node';" 
line 107917: "DROP TABLE '%q'.'%q_rowid';" 
line 107918: "DROP TABLE '%q'.'%q_parent';" , 
line 107919: pRtree -> zDb , pRtree -> zName , 
line 107920: pRtree -> zDb , pRtree -> zName , 
line 107921: pRtree -> zDb , pRtree -> zName 
line 107922: ) ; 
line 107923: if ( ! zCreate ) { 
line 107924: rc = SQLITE_NOMEM ; 
line 107925: } else { 
line 107926: rc = sqlite3_exec ( pRtree -> db , zCreate , 0 , 0 , 0 ) ; 
line 107927: sqlite3_free ( zCreate ) ; 
line 107928: } 
line 107929: if ( rc == SQLITE_OK ) { 
line 107930: rtreeRelease ( pRtree ) ; 
line 107931: } 
line 107933: return rc ; 
line 107934: } 
line 107939: static int rtreeOpen ( sqlite3_vtab * pVTab , sqlite3_vtab_cursor * * ppCursor ) { 
line 107940: int rc = SQLITE_NOMEM ; 
line 107941: RtreeCursor * pCsr ; 
line 107943: pCsr = ( RtreeCursor * ) sqlite3_malloc ( sizeof ( RtreeCursor ) ) ; 
line 107944: if ( pCsr ) { 
line 107945: memset ( pCsr , 0 , sizeof ( RtreeCursor ) ) ; 
line 107946: pCsr -> base . pVtab = pVTab ; 
line 107947: rc = SQLITE_OK ; 
line 107948: } 
line 107949: * ppCursor = ( sqlite3_vtab_cursor * ) pCsr ; 
line 107951: return rc ; 
line 107952: } 
line 107957: static int rtreeClose ( sqlite3_vtab_cursor * cur ) { 
line 107958: Rtree * pRtree = ( Rtree * ) ( cur -> pVtab ) ; 
line 107959: int rc ; 
line 107960: RtreeCursor * pCsr = ( RtreeCursor * ) cur ; 
line 107961: sqlite3_free ( pCsr -> aConstraint ) ; 
line 107962: rc = nodeRelease ( pRtree , pCsr -> pNode ) ; 
line 107963: sqlite3_free ( pCsr ) ; 
line 107964: return rc ; 
line 107965: } 
line 107973: static int rtreeEof ( sqlite3_vtab_cursor * cur ) { 
line 107974: RtreeCursor * pCsr = ( RtreeCursor * ) cur ; 
line 107975: return ( pCsr -> pNode == 0 ) ; 
line 107976: } 
line 107984: static int testRtreeCell ( Rtree * pRtree , RtreeCursor * pCursor ) { 
line 107985: RtreeCell cell ; 
line 107986: int ii ; 
line 107987: int bRes = 0 ; 
line 107989: nodeGetCell ( pRtree , pCursor -> pNode , pCursor -> iCell , & cell ) ; 
line 107990: for ( ii = 0 ; bRes == 0 && ii < pCursor -> nConstraint ; ii ++ ) { 
line 107991: RtreeConstraint * p = & pCursor -> aConstraint [ ii ] ; 
line 107992: double cell_min = DCOORD ( cell . aCoord [ ( p -> iCoord >> 1 ) * 2 ] ) ; 
line 107993: double cell_max = DCOORD ( cell . aCoord [ ( p -> iCoord >> 1 ) * 2 + 1 ] ) ; 
line 107995: assert ( p -> op == RTREE_LE || p -> op == RTREE_LT || p -> op == RTREE_GE 
line 107996: || p -> op == RTREE_GT || p -> op == RTREE_EQ 
line 107997: ) ; 
line 107999: switch ( p -> op ) { 
line 108000: case RTREE_LE : case RTREE_LT : bRes = p -> rValue < cell_min ; break ; 
line 108001: case RTREE_GE : case RTREE_GT : bRes = p -> rValue > cell_max ; break ; 
line 108002: case RTREE_EQ : 
line 108003: bRes = ( p -> rValue > cell_max || p -> rValue < cell_min ) ; 
line 108004: break ; 
line 108005: } 
line 108006: } 
line 108008: return bRes ; 
line 108009: } 
line 108018: static int testRtreeEntry ( Rtree * pRtree , RtreeCursor * pCursor ) { 
line 108019: RtreeCell cell ; 
line 108020: int ii ; 
line 108022: nodeGetCell ( pRtree , pCursor -> pNode , pCursor -> iCell , & cell ) ; 
line 108023: for ( ii = 0 ; ii < pCursor -> nConstraint ; ii ++ ) { 
line 108024: RtreeConstraint * p = & pCursor -> aConstraint [ ii ] ; 
line 108025: double coord = DCOORD ( cell . aCoord [ p -> iCoord ] ) ; 
line 108026: int res ; 
line 108027: assert ( p -> op == RTREE_LE || p -> op == RTREE_LT || p -> op == RTREE_GE 
line 108028: || p -> op == RTREE_GT || p -> op == RTREE_EQ 
line 108029: ) ; 
line 108030: switch ( p -> op ) { 
line 108031: case RTREE_LE : res = ( coord <= p -> rValue ) ; break ; 
line 108032: case RTREE_LT : res = ( coord < p -> rValue ) ; break ; 
line 108033: case RTREE_GE : res = ( coord >= p -> rValue ) ; break ; 
line 108034: case RTREE_GT : res = ( coord > p -> rValue ) ; break ; 
line 108035: case RTREE_EQ : res = ( coord == p -> rValue ) ; break ; 
line 108036: } 
line 108038: if ( ! res ) return 1 ; 
line 108039: } 
line 108041: return 0 ; 
line 108042: } 
line 108050: static int descendToCell ( 
line 108051: Rtree * pRtree , 
line 108052: RtreeCursor * pCursor , 
line 108053: int iHeight , 
line 108054: int * pEof 
line 108055: ) { 
line 108056: int isEof ; 
line 108057: int rc ; 
line 108058: int ii ; 
line 108059: RtreeNode * pChild ; 
line 108060: sqlite3_int64 iRowid ; 
line 108062: RtreeNode * pSavedNode = pCursor -> pNode ; 
line 108063: int iSavedCell = pCursor -> iCell ; 
line 108065: assert ( iHeight >= 0 ) ; 
line 108067: if ( iHeight == 0 ) { 
line 108068: isEof = testRtreeEntry ( pRtree , pCursor ) ; 
line 108069: } else { 
line 108070: isEof = testRtreeCell ( pRtree , pCursor ) ; 
line 108071: } 
line 108072: if ( isEof || iHeight == 0 ) { 
line 108073: * pEof = isEof ; 
line 108074: return SQLITE_OK ; 
line 108075: } 
line 108077: iRowid = nodeGetRowid ( pRtree , pCursor -> pNode , pCursor -> iCell ) ; 
line 108078: rc = nodeAcquire ( pRtree , iRowid , pCursor -> pNode , & pChild ) ; 
line 108079: if ( rc != SQLITE_OK ) { 
line 108080: return rc ; 
line 108081: } 
line 108083: nodeRelease ( pRtree , pCursor -> pNode ) ; 
line 108084: pCursor -> pNode = pChild ; 
line 108085: isEof = 1 ; 
line 108086: for ( ii = 0 ; isEof && ii < NCELL ( pChild ) ; ii ++ ) { 
line 108087: pCursor -> iCell = ii ; 
line 108088: rc = descendToCell ( pRtree , pCursor , iHeight - 1 , & isEof ) ; 
line 108089: if ( rc != SQLITE_OK ) { 
line 108090: return rc ; 
line 108091: } 
line 108092: } 
line 108094: if ( isEof ) { 
line 108095: assert ( pCursor -> pNode == pChild ) ; 
line 108096: nodeReference ( pSavedNode ) ; 
line 108097: nodeRelease ( pRtree , pChild ) ; 
line 108098: pCursor -> pNode = pSavedNode ; 
line 108099: pCursor -> iCell = iSavedCell ; 
line 108100: } 
line 108102: * pEof = isEof ; 
line 108103: return SQLITE_OK ; 
line 108104: } 
line 108110: static int nodeRowidIndex ( Rtree * pRtree , RtreeNode * pNode , i64 iRowid ) { 
line 108111: int ii ; 
line 108112: for ( ii = 0 ; nodeGetRowid ( pRtree , pNode , ii ) != iRowid ; ii ++ ) { 
line 108113: assert ( ii < ( NCELL ( pNode ) - 1 ) ) ; 
line 108114: } 
line 108115: return ii ; 
line 108116: } 
line 108122: static int nodeParentIndex ( Rtree * pRtree , RtreeNode * pNode ) { 
line 108123: RtreeNode * pParent = pNode -> pParent ; 
line 108124: if ( pParent ) { 
line 108125: return nodeRowidIndex ( pRtree , pParent , pNode -> iNode ) ; 
line 108126: } 
line 108127: return - 1 ; 
line 108128: } 
line 108133: static int rtreeNext ( sqlite3_vtab_cursor * pVtabCursor ) { 
line 108134: Rtree * pRtree = ( Rtree * ) ( pVtabCursor -> pVtab ) ; 
line 108135: RtreeCursor * pCsr = ( RtreeCursor * ) pVtabCursor ; 
line 108136: int rc = SQLITE_OK ; 
line 108138: if ( pCsr -> iStrategy == 1 ) { 
line 108140: nodeRelease ( pRtree , pCsr -> pNode ) ; 
line 108141: pCsr -> pNode = 0 ; 
line 108142: } 
line 108144: else if ( pCsr -> pNode ) { 
line 108146: int iHeight = 0 ; 
line 108147: while ( pCsr -> pNode ) { 
line 108148: RtreeNode * pNode = pCsr -> pNode ; 
line 108149: int nCell = NCELL ( pNode ) ; 
line 108150: for ( pCsr -> iCell ++ ; pCsr -> iCell < nCell ; pCsr -> iCell ++ ) { 
line 108151: int isEof ; 
line 108152: rc = descendToCell ( pRtree , pCsr , iHeight , & isEof ) ; 
line 108153: if ( rc != SQLITE_OK || ! isEof ) { 
line 108154: return rc ; 
line 108155: } 
line 108156: } 
line 108157: pCsr -> pNode = pNode -> pParent ; 
line 108158: pCsr -> iCell = nodeParentIndex ( pRtree , pNode ) ; 
line 108159: nodeReference ( pCsr -> pNode ) ; 
line 108160: nodeRelease ( pRtree , pNode ) ; 
line 108161: iHeight ++ ; 
line 108162: } 
line 108163: } 
line 108165: return rc ; 
line 108166: } 
line 108171: static int rtreeRowid ( sqlite3_vtab_cursor * pVtabCursor , sqlite_int64 * pRowid ) { 
line 108172: Rtree * pRtree = ( Rtree * ) pVtabCursor -> pVtab ; 
line 108173: RtreeCursor * pCsr = ( RtreeCursor * ) pVtabCursor ; 
line 108175: assert ( pCsr -> pNode ) ; 
line 108176: * pRowid = nodeGetRowid ( pRtree , pCsr -> pNode , pCsr -> iCell ) ; 
line 108178: return SQLITE_OK ; 
line 108179: } 
line 108184: static int rtreeColumn ( sqlite3_vtab_cursor * cur , sqlite3_context * ctx , int i ) { 
line 108185: Rtree * pRtree = ( Rtree * ) cur -> pVtab ; 
line 108186: RtreeCursor * pCsr = ( RtreeCursor * ) cur ; 
line 108188: if ( i == 0 ) { 
line 108189: i64 iRowid = nodeGetRowid ( pRtree , pCsr -> pNode , pCsr -> iCell ) ; 
line 108190: sqlite3_result_int64 ( ctx , iRowid ) ; 
line 108191: } else { 
line 108192: RtreeCoord c ; 
line 108193: nodeGetCoord ( pRtree , pCsr -> pNode , pCsr -> iCell , i - 1 , & c ) ; 
line 108194: if ( pRtree -> eCoordType == RTREE_COORD_REAL32 ) { 
line 108195: sqlite3_result_double ( ctx , c . f ) ; 
line 108196: } else { 
line 108197: assert ( pRtree -> eCoordType == RTREE_COORD_INT32 ) ; 
line 108198: sqlite3_result_int ( ctx , c . i ) ; 
line 108199: } 
line 108200: } 
line 108202: return SQLITE_OK ; 
line 108203: } 
line 108212: static int findLeafNode ( Rtree * pRtree , i64 iRowid , RtreeNode * * ppLeaf ) { 
line 108213: int rc ; 
line 108214: * ppLeaf = 0 ; 
line 108215: sqlite3_bind_int64 ( pRtree -> pReadRowid , 1 , iRowid ) ; 
line 108216: if ( sqlite3_step ( pRtree -> pReadRowid ) == SQLITE_ROW ) { 
line 108217: i64 iNode = sqlite3_column_int64 ( pRtree -> pReadRowid , 0 ) ; 
line 108218: rc = nodeAcquire ( pRtree , iNode , 0 , ppLeaf ) ; 
line 108219: sqlite3_reset ( pRtree -> pReadRowid ) ; 
line 108220: } else { 
line 108221: rc = sqlite3_reset ( pRtree -> pReadRowid ) ; 
line 108222: } 
line 108223: return rc ; 
line 108224: } 
line 108230: static int rtreeFilter ( 
line 108231: sqlite3_vtab_cursor * pVtabCursor , 
line 108232: int idxNum , const char * idxStr , 
line 108233: int argc , sqlite3_value * * argv 
line 108234: ) { 
line 108235: Rtree * pRtree = ( Rtree * ) pVtabCursor -> pVtab ; 
line 108236: RtreeCursor * pCsr = ( RtreeCursor * ) pVtabCursor ; 
line 108238: RtreeNode * pRoot = 0 ; 
line 108239: int ii ; 
line 108240: int rc = SQLITE_OK ; 
line 108242: rtreeReference ( pRtree ) ; 
line 108244: sqlite3_free ( pCsr -> aConstraint ) ; 
line 108245: pCsr -> aConstraint = 0 ; 
line 108246: pCsr -> iStrategy = idxNum ; 
line 108248: if ( idxNum == 1 ) { 
line 108250: RtreeNode * pLeaf ; 
line 108251: i64 iRowid = sqlite3_value_int64 ( argv [ 0 ] ) ; 
line 108252: rc = findLeafNode ( pRtree , iRowid , & pLeaf ) ; 
line 108253: pCsr -> pNode = pLeaf ; 
line 108254: if ( pLeaf && rc == SQLITE_OK ) { 
line 108255: pCsr -> iCell = nodeRowidIndex ( pRtree , pLeaf , iRowid ) ; 
line 108256: } 
line 108257: } else { 
line 108261: if ( argc > 0 ) { 
line 108262: pCsr -> aConstraint = sqlite3_malloc ( sizeof ( RtreeConstraint ) * argc ) ; 
line 108263: pCsr -> nConstraint = argc ; 
line 108264: if ( ! pCsr -> aConstraint ) { 
line 108265: rc = SQLITE_NOMEM ; 
line 108266: } else { 
line 108267: assert ( ( idxStr == 0 && argc == 0 ) || strlen ( idxStr ) == argc * 2 ) ; 
line 108268: for ( ii = 0 ; ii < argc ; ii ++ ) { 
line 108269: RtreeConstraint * p = & pCsr -> aConstraint [ ii ] ; 
line 108270: p -> op = idxStr [ ii * 2 ] ; 
line 108271: p -> iCoord = idxStr [ ii * 2 + 1 ] - 'a' ; 
line 108272: p -> rValue = sqlite3_value_double ( argv [ ii ] ) ; 
line 108273: } 
line 108274: } 
line 108275: } 
line 108277: if ( rc == SQLITE_OK ) { 
line 108278: pCsr -> pNode = 0 ; 
line 108279: rc = nodeAcquire ( pRtree , 1 , 0 , & pRoot ) ; 
line 108280: } 
line 108281: if ( rc == SQLITE_OK ) { 
line 108282: int isEof = 1 ; 
line 108283: int nCell = NCELL ( pRoot ) ; 
line 108284: pCsr -> pNode = pRoot ; 
line 108285: for ( pCsr -> iCell = 0 ; rc == SQLITE_OK && pCsr -> iCell < nCell ; pCsr -> iCell ++ ) { 
line 108286: assert ( pCsr -> pNode == pRoot ) ; 
line 108287: rc = descendToCell ( pRtree , pCsr , pRtree -> iDepth , & isEof ) ; 
line 108288: if ( ! isEof ) { 
line 108289: break ; 
line 108290: } 
line 108291: } 
line 108292: if ( rc == SQLITE_OK && isEof ) { 
line 108293: assert ( pCsr -> pNode == pRoot ) ; 
line 108294: nodeRelease ( pRtree , pRoot ) ; 
line 108295: pCsr -> pNode = 0 ; 
line 108296: } 
line 108297: assert ( rc != SQLITE_OK || ! pCsr -> pNode || pCsr -> iCell < NCELL ( pCsr -> pNode ) ) ; 
line 108298: } 
line 108299: } 
line 108301: rtreeRelease ( pRtree ) ; 
line 108302: return rc ; 
line 108303: } 
line 108339: static int rtreeBestIndex ( sqlite3_vtab * tab , sqlite3_index_info * pIdxInfo ) { 
line 108340: int rc = SQLITE_OK ; 
line 108341: int ii , cCol ; 
line 108343: int iIdx = 0 ; 
line 108344: char zIdxStr [ RTREE_MAX_DIMENSIONS * 8 + 1 ] ; 
line 108345: memset ( zIdxStr , 0 , sizeof ( zIdxStr ) ) ; 
line 108347: assert ( pIdxInfo -> idxStr == 0 ) ; 
line 108348: for ( ii = 0 ; ii < pIdxInfo -> nConstraint ; ii ++ ) { 
line 108349: struct sqlite3_index_constraint * p = & pIdxInfo -> aConstraint [ ii ] ; 
line 108351: if ( p -> usable && p -> iColumn == 0 && p -> op == SQLITE_INDEX_CONSTRAINT_EQ ) { 
line 108353: int jj ; 
line 108354: for ( jj = 0 ; jj < ii ; jj ++ ) { 
line 108355: pIdxInfo -> aConstraintUsage [ jj ] . argvIndex = 0 ; 
line 108356: pIdxInfo -> aConstraintUsage [ jj ] . omit = 0 ; 
line 108357: } 
line 108358: pIdxInfo -> idxNum = 1 ; 
line 108359: pIdxInfo -> aConstraintUsage [ ii ] . argvIndex = 1 ; 
line 108360: pIdxInfo -> aConstraintUsage [ jj ] . omit = 1 ; 
line 108367: pIdxInfo -> estimatedCost = 10.0 ; 
line 108368: return SQLITE_OK ; 
line 108369: } 
line 108371: if ( p -> usable && p -> iColumn > 0 ) { 
line 108372: u8 op = 0 ; 
line 108373: switch ( p -> op ) { 
line 108374: case SQLITE_INDEX_CONSTRAINT_EQ : op = RTREE_EQ ; break ; 
line 108375: case SQLITE_INDEX_CONSTRAINT_GT : op = RTREE_GT ; break ; 
line 108376: case SQLITE_INDEX_CONSTRAINT_LE : op = RTREE_LE ; break ; 
line 108377: case SQLITE_INDEX_CONSTRAINT_LT : op = RTREE_LT ; break ; 
line 108378: case SQLITE_INDEX_CONSTRAINT_GE : op = RTREE_GE ; break ; 
line 108379: } 
line 108380: if ( op ) { 
line 108390: int j , opmsk ; 
line 108391: static const unsigned char compatible [ ] = { 0 , 0 , 1 , 1 , 2 , 2 } ; 
line 108392: assert ( compatible [ RTREE_EQ & 7 ] == 0 ) ; 
line 108393: assert ( compatible [ RTREE_LT & 7 ] == 1 ) ; 
line 108394: assert ( compatible [ RTREE_LE & 7 ] == 1 ) ; 
line 108395: assert ( compatible [ RTREE_GT & 7 ] == 2 ) ; 
line 108396: assert ( compatible [ RTREE_GE & 7 ] == 2 ) ; 
line 108397: cCol = p -> iColumn - 1 + 'a' ; 
line 108398: opmsk = compatible [ op & 7 ] ; 
line 108399: for ( j = 0 ; j < iIdx ; j += 2 ) { 
line 108400: if ( zIdxStr [ j + 1 ] == cCol && ( compatible [ zIdxStr [ j ] & 7 ] & opmsk ) != 0 ) { 
line 108401: op = 0 ; 
line 108402: break ; 
line 108403: } 
line 108404: } 
line 108405: } 
line 108406: if ( op ) { 
line 108407: assert ( iIdx < sizeof ( zIdxStr ) - 1 ) ; 
line 108408: zIdxStr [ iIdx ++ ] = op ; 
line 108409: zIdxStr [ iIdx ++ ] = cCol ; 
line 108410: pIdxInfo -> aConstraintUsage [ ii ] . argvIndex = ( iIdx / 2 ) ; 
line 108411: pIdxInfo -> aConstraintUsage [ ii ] . omit = 1 ; 
line 108412: } 
line 108413: } 
line 108414: } 
line 108416: pIdxInfo -> idxNum = 2 ; 
line 108417: pIdxInfo -> needToFreeIdxStr = 1 ; 
line 108418: if ( iIdx > 0 && 0 == ( pIdxInfo -> idxStr = sqlite3_mprintf ( "%s" , zIdxStr ) ) ) { 
line 108419: return SQLITE_NOMEM ; 
line 108420: } 
line 108421: assert ( iIdx >= 0 ) ; 
line 108422: pIdxInfo -> estimatedCost = ( 2000000.0 / ( double ) ( iIdx + 1 ) ) ; 
line 108423: return rc ; 
line 108424: } 
line 108429: static float cellArea ( Rtree * pRtree , RtreeCell * p ) { 
line 108430: float area = 1.0 ; 
line 108431: int ii ; 
line 108432: for ( ii = 0 ; ii < ( pRtree -> nDim * 2 ) ; ii += 2 ) { 
line 108433: area = area * ( DCOORD ( p -> aCoord [ ii + 1 ] ) - DCOORD ( p -> aCoord [ ii ] ) ) ; 
line 108434: } 
line 108435: return area ; 
line 108436: } 
line 108442: static float cellMargin ( Rtree * pRtree , RtreeCell * p ) { 
line 108443: float margin = 0.0 ; 
line 108444: int ii ; 
line 108445: for ( ii = 0 ; ii < ( pRtree -> nDim * 2 ) ; ii += 2 ) { 
line 108446: margin += ( DCOORD ( p -> aCoord [ ii + 1 ] ) - DCOORD ( p -> aCoord [ ii ] ) ) ; 
line 108447: } 
line 108448: return margin ; 
line 108449: } 
line 108454: static void cellUnion ( Rtree * pRtree , RtreeCell * p1 , RtreeCell * p2 ) { 
line 108455: int ii ; 
line 108456: if ( pRtree -> eCoordType == RTREE_COORD_REAL32 ) { 
line 108457: for ( ii = 0 ; ii < ( pRtree -> nDim * 2 ) ; ii += 2 ) { 
line 108458: p1 -> aCoord [ ii ] . f = MIN ( p1 -> aCoord [ ii ] . f , p2 -> aCoord [ ii ] . f ) ; 
line 108459: p1 -> aCoord [ ii + 1 ] . f = MAX ( p1 -> aCoord [ ii + 1 ] . f , p2 -> aCoord [ ii + 1 ] . f ) ; 
line 108460: } 
line 108461: } else { 
line 108462: for ( ii = 0 ; ii < ( pRtree -> nDim * 2 ) ; ii += 2 ) { 
line 108463: p1 -> aCoord [ ii ] . i = MIN ( p1 -> aCoord [ ii ] . i , p2 -> aCoord [ ii ] . i ) ; 
line 108464: p1 -> aCoord [ ii + 1 ] . i = MAX ( p1 -> aCoord [ ii + 1 ] . i , p2 -> aCoord [ ii + 1 ] . i ) ; 
line 108465: } 
line 108466: } 
line 108467: } 
line 108473: static int cellContains ( Rtree * pRtree , RtreeCell * p1 , RtreeCell * p2 ) { 
line 108474: int ii ; 
line 108475: int isInt = ( pRtree -> eCoordType == RTREE_COORD_INT32 ) ; 
line 108476: for ( ii = 0 ; ii < ( pRtree -> nDim * 2 ) ; ii += 2 ) { 
line 108477: RtreeCoord * a1 = & p1 -> aCoord [ ii ] ; 
line 108478: RtreeCoord * a2 = & p2 -> aCoord [ ii ] ; 
line 108479: if ( ( ! isInt && ( a2 [ 0 ] . f < a1 [ 0 ] . f || a2 [ 1 ] . f > a1 [ 1 ] . f ) ) 
line 108480: || ( isInt && ( a2 [ 0 ] . i < a1 [ 0 ] . i || a2 [ 1 ] . i > a1 [ 1 ] . i ) ) 
line 108481: ) { 
line 108482: return 0 ; 
line 108483: } 
line 108484: } 
line 108485: return 1 ; 
line 108486: } 
line 108491: static float cellGrowth ( Rtree * pRtree , RtreeCell * p , RtreeCell * pCell ) { 
line 108492: float area ; 
line 108493: RtreeCell cell ; 
line 108494: memcpy ( & cell , p , sizeof ( RtreeCell ) ) ; 
line 108495: area = cellArea ( pRtree , & cell ) ; 
line 108496: cellUnion ( pRtree , & cell , pCell ) ; 
line 108497: return ( cellArea ( pRtree , & cell ) - area ) ; 
line 108498: } 
line 108500: # if VARIANT_RSTARTREE_CHOOSESUBTREE || VARIANT_RSTARTREE_SPLIT 
line 108501: static float cellOverlap ( 
line 108502: Rtree * pRtree , 
line 108503: RtreeCell * p , 
line 108504: RtreeCell * aCell , 
line 108505: int nCell , 
line 108506: int iExclude 
line 108507: ) { 
line 108508: int ii ; 
line 108509: float overlap = 0.0 ; 
line 108510: for ( ii = 0 ; ii < nCell ; ii ++ ) { 
line 108511: if ( ii != iExclude ) { 
line 108512: int jj ; 
line 108513: float o = 1.0 ; 
line 108514: for ( jj = 0 ; jj < ( pRtree -> nDim * 2 ) ; jj += 2 ) { 
line 108515: double x1 ; 
line 108516: double x2 ; 
line 108518: x1 = MAX ( DCOORD ( p -> aCoord [ jj ] ) , DCOORD ( aCell [ ii ] . aCoord [ jj ] ) ) ; 
line 108519: x2 = MIN ( DCOORD ( p -> aCoord [ jj + 1 ] ) , DCOORD ( aCell [ ii ] . aCoord [ jj + 1 ] ) ) ; 
line 108521: if ( x2 < x1 ) { 
line 108522: o = 0.0 ; 
line 108523: break ; 
line 108524: } else { 
line 108525: o = o * ( x2 - x1 ) ; 
line 108526: } 
line 108527: } 
line 108528: overlap += o ; 
line 108529: } 
line 108530: } 
line 108531: return overlap ; 
line 108532: } 
line 108533: # endif 
line 108535: # if VARIANT_RSTARTREE_CHOOSESUBTREE 
line 108536: static float cellOverlapEnlargement ( 
line 108537: Rtree * pRtree , 
line 108538: RtreeCell * p , 
line 108539: RtreeCell * pInsert , 
line 108540: RtreeCell * aCell , 
line 108541: int nCell , 
line 108542: int iExclude 
line 108543: ) { 
line 108544: float before ; 
line 108545: float after ; 
line 108546: before = cellOverlap ( pRtree , p , aCell , nCell , iExclude ) ; 
line 108547: cellUnion ( pRtree , p , pInsert ) ; 
line 108548: after = cellOverlap ( pRtree , p , aCell , nCell , iExclude ) ; 
line 108549: return after - before ; 
line 108550: } 
line 108551: # endif 
line 108558: static int ChooseLeaf ( 
line 108559: Rtree * pRtree , 
line 108560: RtreeCell * pCell , 
line 108561: int iHeight , 
line 108562: RtreeNode * * ppLeaf 
line 108563: ) { 
line 108564: int rc ; 
line 108565: int ii ; 
line 108566: RtreeNode * pNode ; 
line 108567: rc = nodeAcquire ( pRtree , 1 , 0 , & pNode ) ; 
line 108569: for ( ii = 0 ; rc == SQLITE_OK && ii < ( pRtree -> iDepth - iHeight ) ; ii ++ ) { 
line 108570: int iCell ; 
line 108571: sqlite3_int64 iBest ; 
line 108573: float fMinGrowth ; 
line 108574: float fMinArea ; 
line 108575: float fMinOverlap ; 
line 108577: int nCell = NCELL ( pNode ) ; 
line 108578: RtreeCell cell ; 
line 108579: RtreeNode * pChild ; 
line 108581: RtreeCell * aCell = 0 ; 
line 108583: # if VARIANT_RSTARTREE_CHOOSESUBTREE 
line 108584: if ( ii == ( pRtree -> iDepth - 1 ) ) { 
line 108585: int jj ; 
line 108586: aCell = sqlite3_malloc ( sizeof ( RtreeCell ) * nCell ) ; 
line 108587: if ( ! aCell ) { 
line 108588: rc = SQLITE_NOMEM ; 
line 108589: nodeRelease ( pRtree , pNode ) ; 
line 108590: pNode = 0 ; 
line 108591: continue ; 
line 108592: } 
line 108593: for ( jj = 0 ; jj < nCell ; jj ++ ) { 
line 108594: nodeGetCell ( pRtree , pNode , jj , & aCell [ jj ] ) ; 
line 108595: } 
line 108596: } 
line 108597: # endif 
line 108603: for ( iCell = 0 ; iCell < nCell ; iCell ++ ) { 
line 108604: float growth ; 
line 108605: float area ; 
line 108606: float overlap = 0.0 ; 
line 108607: nodeGetCell ( pRtree , pNode , iCell , & cell ) ; 
line 108608: growth = cellGrowth ( pRtree , & cell , pCell ) ; 
line 108609: area = cellArea ( pRtree , & cell ) ; 
line 108610: # if VARIANT_RSTARTREE_CHOOSESUBTREE 
line 108611: if ( ii == ( pRtree -> iDepth - 1 ) ) { 
line 108612: overlap = cellOverlapEnlargement ( pRtree , & cell , pCell , aCell , nCell , iCell ) ; 
line 108613: } 
line 108614: # endif 
line 108615: if ( ( iCell == 0 ) 
line 108616: || ( overlap < fMinOverlap ) 
line 108617: || ( overlap == fMinOverlap && growth < fMinGrowth ) 
line 108618: || ( overlap == fMinOverlap && growth == fMinGrowth && area < fMinArea ) 
line 108619: ) { 
line 108620: fMinOverlap = overlap ; 
line 108621: fMinGrowth = growth ; 
line 108622: fMinArea = area ; 
line 108623: iBest = cell . iRowid ; 
line 108624: } 
line 108625: } 
line 108627: sqlite3_free ( aCell ) ; 
line 108628: rc = nodeAcquire ( pRtree , iBest , pNode , & pChild ) ; 
line 108629: nodeRelease ( pRtree , pNode ) ; 
line 108630: pNode = pChild ; 
line 108631: } 
line 108633: * ppLeaf = pNode ; 
line 108634: return rc ; 
line 108635: } 
line 108642: static void AdjustTree ( 
line 108643: Rtree * pRtree , 
line 108644: RtreeNode * pNode , 
line 108645: RtreeCell * pCell 
line 108646: ) { 
line 108647: RtreeNode * p = pNode ; 
line 108648: while ( p -> pParent ) { 
line 108649: RtreeCell cell ; 
line 108650: RtreeNode * pParent = p -> pParent ; 
line 108651: int iCell = nodeParentIndex ( pRtree , p ) ; 
line 108653: nodeGetCell ( pRtree , pParent , iCell , & cell ) ; 
line 108654: if ( ! cellContains ( pRtree , & cell , pCell ) ) { 
line 108655: cellUnion ( pRtree , & cell , pCell ) ; 
line 108656: nodeOverwriteCell ( pRtree , pParent , & cell , iCell ) ; 
line 108657: } 
line 108659: p = pParent ; 
line 108660: } 
line 108661: } 
line 108666: static int rowidWrite ( Rtree * pRtree , sqlite3_int64 iRowid , sqlite3_int64 iNode ) { 
line 108667: sqlite3_bind_int64 ( pRtree -> pWriteRowid , 1 , iRowid ) ; 
line 108668: sqlite3_bind_int64 ( pRtree -> pWriteRowid , 2 , iNode ) ; 
line 108669: sqlite3_step ( pRtree -> pWriteRowid ) ; 
line 108670: return sqlite3_reset ( pRtree -> pWriteRowid ) ; 
line 108671: } 
line 108676: static int parentWrite ( Rtree * pRtree , sqlite3_int64 iNode , sqlite3_int64 iPar ) { 
line 108677: sqlite3_bind_int64 ( pRtree -> pWriteParent , 1 , iNode ) ; 
line 108678: sqlite3_bind_int64 ( pRtree -> pWriteParent , 2 , iPar ) ; 
line 108679: sqlite3_step ( pRtree -> pWriteParent ) ; 
line 108680: return sqlite3_reset ( pRtree -> pWriteParent ) ; 
line 108681: } 
line 108683: static int rtreeInsertCell ( Rtree * , RtreeNode * , RtreeCell * , int ) ; 
line 108685: # if VARIANT_GUTTMAN_LINEAR_SPLIT 
line 108690: static RtreeCell * LinearPickNext ( 
line 108691: Rtree * pRtree , 
line 108692: RtreeCell * aCell , 
line 108693: int nCell , 
line 108694: RtreeCell * pLeftBox , 
line 108695: RtreeCell * pRightBox , 
line 108696: int * aiUsed 
line 108697: ) { 
line 108698: int ii ; 
line 108699: for ( ii = 0 ; aiUsed [ ii ] ; ii ++ ) ; 
line 108700: aiUsed [ ii ] = 1 ; 
line 108701: return & aCell [ ii ] ; 
line 108702: } 
line 108708: static void LinearPickSeeds ( 
line 108709: Rtree * pRtree , 
line 108710: RtreeCell * aCell , 
line 108711: int nCell , 
line 108712: int * piLeftSeed , 
line 108713: int * piRightSeed 
line 108714: ) { 
line 108715: int i ; 
line 108716: int iLeftSeed = 0 ; 
line 108717: int iRightSeed = 1 ; 
line 108718: float maxNormalInnerWidth = 0.0 ; 
line 108725: for ( i = 0 ; i < pRtree -> nDim ; i ++ ) { 
line 108726: float x1 = DCOORD ( aCell [ 0 ] . aCoord [ i * 2 ] ) ; 
line 108727: float x2 = DCOORD ( aCell [ 0 ] . aCoord [ i * 2 + 1 ] ) ; 
line 108728: float x3 = x1 ; 
line 108729: float x4 = x2 ; 
line 108730: int jj ; 
line 108732: int iCellLeft = 0 ; 
line 108733: int iCellRight = 0 ; 
line 108735: for ( jj = 1 ; jj < nCell ; jj ++ ) { 
line 108736: float left = DCOORD ( aCell [ jj ] . aCoord [ i * 2 ] ) ; 
line 108737: float right = DCOORD ( aCell [ jj ] . aCoord [ i * 2 + 1 ] ) ; 
line 108739: if ( left < x1 ) x1 = left ; 
line 108740: if ( right > x4 ) x4 = right ; 
line 108741: if ( left > x3 ) { 
line 108742: x3 = left ; 
line 108743: iCellRight = jj ; 
line 108744: } 
line 108745: if ( right < x2 ) { 
line 108746: x2 = right ; 
line 108747: iCellLeft = jj ; 
line 108748: } 
line 108749: } 
line 108751: if ( x4 != x1 ) { 
line 108752: float normalwidth = ( x3 - x2 ) / ( x4 - x1 ) ; 
line 108753: if ( normalwidth > maxNormalInnerWidth ) { 
line 108754: iLeftSeed = iCellLeft ; 
line 108755: iRightSeed = iCellRight ; 
line 108756: } 
line 108757: } 
line 108758: } 
line 108760: * piLeftSeed = iLeftSeed ; 
line 108761: * piRightSeed = iRightSeed ; 
line 108762: } 
line 108763: # endif 
line 108765: # if VARIANT_GUTTMAN_QUADRATIC_SPLIT 
line 108770: static RtreeCell * QuadraticPickNext ( 
line 108771: Rtree * pRtree , 
line 108772: RtreeCell * aCell , 
line 108773: int nCell , 
line 108774: RtreeCell * pLeftBox , 
line 108775: RtreeCell * pRightBox , 
line 108776: int * aiUsed 
line 108777: ) { 
line 108778: # define FABS ( a ) ( ( a ) < 0.0 ? - 1.0 * ( a ) : ( a ) ) 
line 108780: int iSelect = - 1 ; 
line 108781: float fDiff ; 
line 108782: int ii ; 
line 108783: for ( ii = 0 ; ii < nCell ; ii ++ ) { 
line 108784: if ( aiUsed [ ii ] == 0 ) { 
line 108785: float left = cellGrowth ( pRtree , pLeftBox , & aCell [ ii ] ) ; 
line 108786: float right = cellGrowth ( pRtree , pLeftBox , & aCell [ ii ] ) ; 
line 108787: float diff = FABS ( right - left ) ; 
line 108788: if ( iSelect < 0 || diff > fDiff ) { 
line 108789: fDiff = diff ; 
line 108790: iSelect = ii ; 
line 108791: } 
line 108792: } 
line 108793: } 
line 108794: aiUsed [ iSelect ] = 1 ; 
line 108795: return & aCell [ iSelect ] ; 
line 108796: } 
line 108802: static void QuadraticPickSeeds ( 
line 108803: Rtree * pRtree , 
line 108804: RtreeCell * aCell , 
line 108805: int nCell , 
line 108806: int * piLeftSeed , 
line 108807: int * piRightSeed 
line 108808: ) { 
line 108809: int ii ; 
line 108810: int jj ; 
line 108812: int iLeftSeed = 0 ; 
line 108813: int iRightSeed = 1 ; 
line 108814: float fWaste = 0.0 ; 
line 108816: for ( ii = 0 ; ii < nCell ; ii ++ ) { 
line 108817: for ( jj = ii + 1 ; jj < nCell ; jj ++ ) { 
line 108818: float right = cellArea ( pRtree , & aCell [ jj ] ) ; 
line 108819: float growth = cellGrowth ( pRtree , & aCell [ ii ] , & aCell [ jj ] ) ; 
line 108820: float waste = growth - right ; 
line 108822: if ( waste > fWaste ) { 
line 108823: iLeftSeed = ii ; 
line 108824: iRightSeed = jj ; 
line 108825: fWaste = waste ; 
line 108826: } 
line 108827: } 
line 108828: } 
line 108830: * piLeftSeed = iLeftSeed ; 
line 108831: * piRightSeed = iRightSeed ; 
line 108832: } 
line 108833: # endif 
line 108852: static void SortByDistance ( 
line 108853: int * aIdx , 
line 108854: int nIdx , 
line 108855: float * aDistance , 
line 108856: int * aSpare 
line 108857: ) { 
line 108858: if ( nIdx > 1 ) { 
line 108859: int iLeft = 0 ; 
line 108860: int iRight = 0 ; 
line 108862: int nLeft = nIdx / 2 ; 
line 108863: int nRight = nIdx - nLeft ; 
line 108864: int * aLeft = aIdx ; 
line 108865: int * aRight = & aIdx [ nLeft ] ; 
line 108867: SortByDistance ( aLeft , nLeft , aDistance , aSpare ) ; 
line 108868: SortByDistance ( aRight , nRight , aDistance , aSpare ) ; 
line 108870: memcpy ( aSpare , aLeft , sizeof ( int ) * nLeft ) ; 
line 108871: aLeft = aSpare ; 
line 108873: while ( iLeft < nLeft || iRight < nRight ) { 
line 108874: if ( iLeft == nLeft ) { 
line 108875: aIdx [ iLeft + iRight ] = aRight [ iRight ] ; 
line 108876: iRight ++ ; 
line 108877: } else if ( iRight == nRight ) { 
line 108878: aIdx [ iLeft + iRight ] = aLeft [ iLeft ] ; 
line 108879: iLeft ++ ; 
line 108880: } else { 
line 108881: float fLeft = aDistance [ aLeft [ iLeft ] ] ; 
line 108882: float fRight = aDistance [ aRight [ iRight ] ] ; 
line 108883: if ( fLeft < fRight ) { 
line 108884: aIdx [ iLeft + iRight ] = aLeft [ iLeft ] ; 
line 108885: iLeft ++ ; 
line 108886: } else { 
line 108887: aIdx [ iLeft + iRight ] = aRight [ iRight ] ; 
line 108888: iRight ++ ; 
line 108889: } 
line 108890: } 
line 108891: } 
line 108893: # if 0 
line 108895: { 
line 108896: int jj ; 
line 108897: for ( jj = 1 ; jj < nIdx ; jj ++ ) { 
line 108898: float left = aDistance [ aIdx [ jj - 1 ] ] ; 
line 108899: float right = aDistance [ aIdx [ jj ] ] ; 
line 108900: assert ( left <= right ) ; 
line 108901: } 
line 108902: } 
line 108903: # endif 
line 108904: } 
line 108905: } 
line 108918: static void SortByDimension ( 
line 108919: Rtree * pRtree , 
line 108920: int * aIdx , 
line 108921: int nIdx , 
line 108922: int iDim , 
line 108923: RtreeCell * aCell , 
line 108924: int * aSpare 
line 108925: ) { 
line 108926: if ( nIdx > 1 ) { 
line 108928: int iLeft = 0 ; 
line 108929: int iRight = 0 ; 
line 108931: int nLeft = nIdx / 2 ; 
line 108932: int nRight = nIdx - nLeft ; 
line 108933: int * aLeft = aIdx ; 
line 108934: int * aRight = & aIdx [ nLeft ] ; 
line 108936: SortByDimension ( pRtree , aLeft , nLeft , iDim , aCell , aSpare ) ; 
line 108937: SortByDimension ( pRtree , aRight , nRight , iDim , aCell , aSpare ) ; 
line 108939: memcpy ( aSpare , aLeft , sizeof ( int ) * nLeft ) ; 
line 108940: aLeft = aSpare ; 
line 108941: while ( iLeft < nLeft || iRight < nRight ) { 
line 108942: double xleft1 = DCOORD ( aCell [ aLeft [ iLeft ] ] . aCoord [ iDim * 2 ] ) ; 
line 108943: double xleft2 = DCOORD ( aCell [ aLeft [ iLeft ] ] . aCoord [ iDim * 2 + 1 ] ) ; 
line 108944: double xright1 = DCOORD ( aCell [ aRight [ iRight ] ] . aCoord [ iDim * 2 ] ) ; 
line 108945: double xright2 = DCOORD ( aCell [ aRight [ iRight ] ] . aCoord [ iDim * 2 + 1 ] ) ; 
line 108946: if ( ( iLeft != nLeft ) && ( ( iRight == nRight ) 
line 108947: || ( xleft1 < xright1 ) 
line 108948: || ( xleft1 == xright1 && xleft2 < xright2 ) 
line 108949: ) ) { 
line 108950: aIdx [ iLeft + iRight ] = aLeft [ iLeft ] ; 
line 108951: iLeft ++ ; 
line 108952: } else { 
line 108953: aIdx [ iLeft + iRight ] = aRight [ iRight ] ; 
line 108954: iRight ++ ; 
line 108955: } 
line 108956: } 
line 108958: # if 0 
line 108960: { 
line 108961: int jj ; 
line 108962: for ( jj = 1 ; jj < nIdx ; jj ++ ) { 
line 108963: float xleft1 = aCell [ aIdx [ jj - 1 ] ] . aCoord [ iDim * 2 ] ; 
line 108964: float xleft2 = aCell [ aIdx [ jj - 1 ] ] . aCoord [ iDim * 2 + 1 ] ; 
line 108965: float xright1 = aCell [ aIdx [ jj ] ] . aCoord [ iDim * 2 ] ; 
line 108966: float xright2 = aCell [ aIdx [ jj ] ] . aCoord [ iDim * 2 + 1 ] ; 
line 108967: assert ( xleft1 <= xright1 && ( xleft1 < xright1 || xleft2 <= xright2 ) ) ; 
line 108968: } 
line 108969: } 
line 108970: # endif 
line 108971: } 
line 108972: } 
line 108974: # if VARIANT_RSTARTREE_SPLIT 
line 108978: static int splitNodeStartree ( 
line 108979: Rtree * pRtree , 
line 108980: RtreeCell * aCell , 
line 108981: int nCell , 
line 108982: RtreeNode * pLeft , 
line 108983: RtreeNode * pRight , 
line 108984: RtreeCell * pBboxLeft , 
line 108985: RtreeCell * pBboxRight 
line 108986: ) { 
line 108987: int * * aaSorted ; 
line 108988: int * aSpare ; 
line 108989: int ii ; 
line 108991: int iBestDim ; 
line 108992: int iBestSplit ; 
line 108993: float fBestMargin ; 
line 108995: int nByte = ( pRtree -> nDim + 1 ) * ( sizeof ( int * ) + nCell * sizeof ( int ) ) ; 
line 108997: aaSorted = ( int * * ) sqlite3_malloc ( nByte ) ; 
line 108998: if ( ! aaSorted ) { 
line 108999: return SQLITE_NOMEM ; 
line 109000: } 
line 109002: aSpare = & ( ( int * ) & aaSorted [ pRtree -> nDim ] ) [ pRtree -> nDim * nCell ] ; 
line 109003: memset ( aaSorted , 0 , nByte ) ; 
line 109004: for ( ii = 0 ; ii < pRtree -> nDim ; ii ++ ) { 
line 109005: int jj ; 
line 109006: aaSorted [ ii ] = & ( ( int * ) & aaSorted [ pRtree -> nDim ] ) [ ii * nCell ] ; 
line 109007: for ( jj = 0 ; jj < nCell ; jj ++ ) { 
line 109008: aaSorted [ ii ] [ jj ] = jj ; 
line 109009: } 
line 109010: SortByDimension ( pRtree , aaSorted [ ii ] , nCell , ii , aCell , aSpare ) ; 
line 109011: } 
line 109013: for ( ii = 0 ; ii < pRtree -> nDim ; ii ++ ) { 
line 109014: float margin = 0.0 ; 
line 109015: float fBestOverlap ; 
line 109016: float fBestArea ; 
line 109017: int iBestLeft ; 
line 109018: int nLeft ; 
line 109020: for ( 
line 109021: nLeft = RTREE_MINCELLS ( pRtree ) ; 
line 109022: nLeft <= ( nCell - RTREE_MINCELLS ( pRtree ) ) ; 
line 109023: nLeft ++ 
line 109024: ) { 
line 109025: RtreeCell left ; 
line 109026: RtreeCell right ; 
line 109027: int kk ; 
line 109028: float overlap ; 
line 109029: float area ; 
line 109031: memcpy ( & left , & aCell [ aaSorted [ ii ] [ 0 ] ] , sizeof ( RtreeCell ) ) ; 
line 109032: memcpy ( & right , & aCell [ aaSorted [ ii ] [ nCell - 1 ] ] , sizeof ( RtreeCell ) ) ; 
line 109033: for ( kk = 1 ; kk < ( nCell - 1 ) ; kk ++ ) { 
line 109034: if ( kk < nLeft ) { 
line 109035: cellUnion ( pRtree , & left , & aCell [ aaSorted [ ii ] [ kk ] ] ) ; 
line 109036: } else { 
line 109037: cellUnion ( pRtree , & right , & aCell [ aaSorted [ ii ] [ kk ] ] ) ; 
line 109038: } 
line 109039: } 
line 109040: margin += cellMargin ( pRtree , & left ) ; 
line 109041: margin += cellMargin ( pRtree , & right ) ; 
line 109042: overlap = cellOverlap ( pRtree , & left , & right , 1 , - 1 ) ; 
line 109043: area = cellArea ( pRtree , & left ) + cellArea ( pRtree , & right ) ; 
line 109044: if ( ( nLeft == RTREE_MINCELLS ( pRtree ) ) 
line 109045: || ( overlap < fBestOverlap ) 
line 109046: || ( overlap == fBestOverlap && area < fBestArea ) 
line 109047: ) { 
line 109048: iBestLeft = nLeft ; 
line 109049: fBestOverlap = overlap ; 
line 109050: fBestArea = area ; 
line 109051: } 
line 109052: } 
line 109054: if ( ii == 0 || margin < fBestMargin ) { 
line 109055: iBestDim = ii ; 
line 109056: fBestMargin = margin ; 
line 109057: iBestSplit = iBestLeft ; 
line 109058: } 
line 109059: } 
line 109061: memcpy ( pBboxLeft , & aCell [ aaSorted [ iBestDim ] [ 0 ] ] , sizeof ( RtreeCell ) ) ; 
line 109062: memcpy ( pBboxRight , & aCell [ aaSorted [ iBestDim ] [ iBestSplit ] ] , sizeof ( RtreeCell ) ) ; 
line 109063: for ( ii = 0 ; ii < nCell ; ii ++ ) { 
line 109064: RtreeNode * pTarget = ( ii < iBestSplit ) ? pLeft : pRight ; 
line 109065: RtreeCell * pBbox = ( ii < iBestSplit ) ? pBboxLeft : pBboxRight ; 
line 109066: RtreeCell * pCell = & aCell [ aaSorted [ iBestDim ] [ ii ] ] ; 
line 109067: nodeInsertCell ( pRtree , pTarget , pCell ) ; 
line 109068: cellUnion ( pRtree , pBbox , pCell ) ; 
line 109069: } 
line 109071: sqlite3_free ( aaSorted ) ; 
line 109072: return SQLITE_OK ; 
line 109073: } 
line 109074: # endif 
line 109076: # if VARIANT_GUTTMAN_SPLIT 
line 109080: static int splitNodeGuttman ( 
line 109081: Rtree * pRtree , 
line 109082: RtreeCell * aCell , 
line 109083: int nCell , 
line 109084: RtreeNode * pLeft , 
line 109085: RtreeNode * pRight , 
line 109086: RtreeCell * pBboxLeft , 
line 109087: RtreeCell * pBboxRight 
line 109088: ) { 
line 109089: int iLeftSeed = 0 ; 
line 109090: int iRightSeed = 1 ; 
line 109091: int * aiUsed ; 
line 109092: int i ; 
line 109094: aiUsed = sqlite3_malloc ( sizeof ( int ) * nCell ) ; 
line 109095: if ( ! aiUsed ) { 
line 109096: return SQLITE_NOMEM ; 
line 109097: } 
line 109098: memset ( aiUsed , 0 , sizeof ( int ) * nCell ) ; 
line 109100: PickSeeds ( pRtree , aCell , nCell , & iLeftSeed , & iRightSeed ) ; 
line 109102: memcpy ( pBboxLeft , & aCell [ iLeftSeed ] , sizeof ( RtreeCell ) ) ; 
line 109103: memcpy ( pBboxRight , & aCell [ iRightSeed ] , sizeof ( RtreeCell ) ) ; 
line 109104: nodeInsertCell ( pRtree , pLeft , & aCell [ iLeftSeed ] ) ; 
line 109105: nodeInsertCell ( pRtree , pRight , & aCell [ iRightSeed ] ) ; 
line 109106: aiUsed [ iLeftSeed ] = 1 ; 
line 109107: aiUsed [ iRightSeed ] = 1 ; 
line 109109: for ( i = nCell - 2 ; i > 0 ; i -- ) { 
line 109110: RtreeCell * pNext ; 
line 109111: pNext = PickNext ( pRtree , aCell , nCell , pBboxLeft , pBboxRight , aiUsed ) ; 
line 109112: float diff = 
line 109113: cellGrowth ( pRtree , pBboxLeft , pNext ) - 
line 109114: cellGrowth ( pRtree , pBboxRight , pNext ) 
line 109115: ; 
line 109116: if ( ( RTREE_MINCELLS ( pRtree ) - NCELL ( pRight ) == i ) 
line 109117: || ( diff > 0.0 && ( RTREE_MINCELLS ( pRtree ) - NCELL ( pLeft ) != i ) ) 
line 109118: ) { 
line 109119: nodeInsertCell ( pRtree , pRight , pNext ) ; 
line 109120: cellUnion ( pRtree , pBboxRight , pNext ) ; 
line 109121: } else { 
line 109122: nodeInsertCell ( pRtree , pLeft , pNext ) ; 
line 109123: cellUnion ( pRtree , pBboxLeft , pNext ) ; 
line 109124: } 
line 109125: } 
line 109127: sqlite3_free ( aiUsed ) ; 
line 109128: return SQLITE_OK ; 
line 109129: } 
line 109130: # endif 
line 109132: static int updateMapping ( 
line 109133: Rtree * pRtree , 
line 109134: i64 iRowid , 
line 109135: RtreeNode * pNode , 
line 109136: int iHeight 
line 109137: ) { 
line 109138: int ( * xSetMapping ) ( Rtree * , sqlite3_int64 , sqlite3_int64 ) ; 
line 109139: xSetMapping = ( ( iHeight == 0 ) ? rowidWrite : parentWrite ) ; 
line 109140: if ( iHeight > 0 ) { 
line 109141: RtreeNode * pChild = nodeHashLookup ( pRtree , iRowid ) ; 
line 109142: if ( pChild ) { 
line 109143: nodeRelease ( pRtree , pChild -> pParent ) ; 
line 109144: nodeReference ( pNode ) ; 
line 109145: pChild -> pParent = pNode ; 
line 109146: } 
line 109147: } 
line 109148: return xSetMapping ( pRtree , iRowid , pNode -> iNode ) ; 
line 109149: } 
line 109151: static int SplitNode ( 
line 109152: Rtree * pRtree , 
line 109153: RtreeNode * pNode , 
line 109154: RtreeCell * pCell , 
line 109155: int iHeight 
line 109156: ) { 
line 109157: int i ; 
line 109158: int newCellIsRight = 0 ; 
line 109160: int rc = SQLITE_OK ; 
line 109161: int nCell = NCELL ( pNode ) ; 
line 109162: RtreeCell * aCell ; 
line 109163: int * aiUsed ; 
line 109165: RtreeNode * pLeft = 0 ; 
line 109166: RtreeNode * pRight = 0 ; 
line 109168: RtreeCell leftbbox ; 
line 109169: RtreeCell rightbbox ; 
line 109174: aCell = sqlite3_malloc ( ( sizeof ( RtreeCell ) + sizeof ( int ) ) * ( nCell + 1 ) ) ; 
line 109175: if ( ! aCell ) { 
line 109176: rc = SQLITE_NOMEM ; 
line 109177: goto splitnode_out ; 
line 109178: } 
line 109179: aiUsed = ( int * ) & aCell [ nCell + 1 ] ; 
line 109180: memset ( aiUsed , 0 , sizeof ( int ) * ( nCell + 1 ) ) ; 
line 109181: for ( i = 0 ; i < nCell ; i ++ ) { 
line 109182: nodeGetCell ( pRtree , pNode , i , & aCell [ i ] ) ; 
line 109183: } 
line 109184: nodeZero ( pRtree , pNode ) ; 
line 109185: memcpy ( & aCell [ nCell ] , pCell , sizeof ( RtreeCell ) ) ; 
line 109186: nCell ++ ; 
line 109188: if ( pNode -> iNode == 1 ) { 
line 109189: pRight = nodeNew ( pRtree , pNode , 1 ) ; 
line 109190: pLeft = nodeNew ( pRtree , pNode , 1 ) ; 
line 109191: pRtree -> iDepth ++ ; 
line 109192: pNode -> isDirty = 1 ; 
line 109193: writeInt16 ( pNode -> zData , pRtree -> iDepth ) ; 
line 109194: } else { 
line 109195: pLeft = pNode ; 
line 109196: pRight = nodeNew ( pRtree , pLeft -> pParent , 1 ) ; 
line 109197: nodeReference ( pLeft ) ; 
line 109198: } 
line 109200: if ( ! pLeft || ! pRight ) { 
line 109201: rc = SQLITE_NOMEM ; 
line 109202: goto splitnode_out ; 
line 109203: } 
line 109205: memset ( pLeft -> zData , 0 , pRtree -> iNodeSize ) ; 
line 109206: memset ( pRight -> zData , 0 , pRtree -> iNodeSize ) ; 
line 109208: rc = AssignCells ( pRtree , aCell , nCell , pLeft , pRight , & leftbbox , & rightbbox ) ; 
line 109209: if ( rc != SQLITE_OK ) { 
line 109210: goto splitnode_out ; 
line 109211: } 
line 109214: if ( ( 0 == pRight -> iNode && SQLITE_OK != ( rc = nodeWrite ( pRtree , pRight ) ) ) 
line 109215: || ( 0 == pLeft -> iNode && SQLITE_OK != ( rc = nodeWrite ( pRtree , pLeft ) ) ) 
line 109216: ) { 
line 109217: goto splitnode_out ; 
line 109218: } 
line 109220: rightbbox . iRowid = pRight -> iNode ; 
line 109221: leftbbox . iRowid = pLeft -> iNode ; 
line 109223: if ( pNode -> iNode == 1 ) { 
line 109224: rc = rtreeInsertCell ( pRtree , pLeft -> pParent , & leftbbox , iHeight + 1 ) ; 
line 109225: if ( rc != SQLITE_OK ) { 
line 109226: goto splitnode_out ; 
line 109227: } 
line 109228: } else { 
line 109229: RtreeNode * pParent = pLeft -> pParent ; 
line 109230: int iCell = nodeParentIndex ( pRtree , pLeft ) ; 
line 109231: nodeOverwriteCell ( pRtree , pParent , & leftbbox , iCell ) ; 
line 109232: AdjustTree ( pRtree , pParent , & leftbbox ) ; 
line 109233: } 
line 109234: if ( ( rc = rtreeInsertCell ( pRtree , pRight -> pParent , & rightbbox , iHeight + 1 ) ) ) { 
line 109235: goto splitnode_out ; 
line 109236: } 
line 109238: for ( i = 0 ; i < NCELL ( pRight ) ; i ++ ) { 
line 109239: i64 iRowid = nodeGetRowid ( pRtree , pRight , i ) ; 
line 109240: rc = updateMapping ( pRtree , iRowid , pRight , iHeight ) ; 
line 109241: if ( iRowid == pCell -> iRowid ) { 
line 109242: newCellIsRight = 1 ; 
line 109243: } 
line 109244: if ( rc != SQLITE_OK ) { 
line 109245: goto splitnode_out ; 
line 109246: } 
line 109247: } 
line 109248: if ( pNode -> iNode == 1 ) { 
line 109249: for ( i = 0 ; i < NCELL ( pLeft ) ; i ++ ) { 
line 109250: i64 iRowid = nodeGetRowid ( pRtree , pLeft , i ) ; 
line 109251: rc = updateMapping ( pRtree , iRowid , pLeft , iHeight ) ; 
line 109252: if ( rc != SQLITE_OK ) { 
line 109253: goto splitnode_out ; 
line 109254: } 
line 109255: } 
line 109256: } else if ( newCellIsRight == 0 ) { 
line 109257: rc = updateMapping ( pRtree , pCell -> iRowid , pLeft , iHeight ) ; 
line 109258: } 
line 109260: if ( rc == SQLITE_OK ) { 
line 109261: rc = nodeRelease ( pRtree , pRight ) ; 
line 109262: pRight = 0 ; 
line 109263: } 
line 109264: if ( rc == SQLITE_OK ) { 
line 109265: rc = nodeRelease ( pRtree , pLeft ) ; 
line 109266: pLeft = 0 ; 
line 109267: } 
line 109269: splitnode_out : 
line 109270: nodeRelease ( pRtree , pRight ) ; 
line 109271: nodeRelease ( pRtree , pLeft ) ; 
line 109272: sqlite3_free ( aCell ) ; 
line 109273: return rc ; 
line 109274: } 
line 109276: static int fixLeafParent ( Rtree * pRtree , RtreeNode * pLeaf ) { 
line 109277: int rc = SQLITE_OK ; 
line 109278: if ( pLeaf -> iNode != 1 && pLeaf -> pParent == 0 ) { 
line 109279: sqlite3_bind_int64 ( pRtree -> pReadParent , 1 , pLeaf -> iNode ) ; 
line 109280: if ( sqlite3_step ( pRtree -> pReadParent ) == SQLITE_ROW ) { 
line 109281: i64 iNode = sqlite3_column_int64 ( pRtree -> pReadParent , 0 ) ; 
line 109282: rc = nodeAcquire ( pRtree , iNode , 0 , & pLeaf -> pParent ) ; 
line 109283: } else { 
line 109284: rc = SQLITE_ERROR ; 
line 109285: } 
line 109286: sqlite3_reset ( pRtree -> pReadParent ) ; 
line 109287: if ( rc == SQLITE_OK ) { 
line 109288: rc = fixLeafParent ( pRtree , pLeaf -> pParent ) ; 
line 109289: } 
line 109290: } 
line 109291: return rc ; 
line 109292: } 
line 109294: static int deleteCell ( Rtree * , RtreeNode * , int , int ) ; 
line 109296: static int removeNode ( Rtree * pRtree , RtreeNode * pNode , int iHeight ) { 
line 109297: int rc ; 
line 109298: RtreeNode * pParent ; 
line 109299: int iCell ; 
line 109301: assert ( pNode -> nRef == 1 ) ; 
line 109304: iCell = nodeParentIndex ( pRtree , pNode ) ; 
line 109305: pParent = pNode -> pParent ; 
line 109306: pNode -> pParent = 0 ; 
line 109307: if ( SQLITE_OK != ( rc = deleteCell ( pRtree , pParent , iCell , iHeight + 1 ) ) 
line 109308: || SQLITE_OK != ( rc = nodeRelease ( pRtree , pParent ) ) 
line 109309: ) { 
line 109310: return rc ; 
line 109311: } 
line 109314: sqlite3_bind_int64 ( pRtree -> pDeleteNode , 1 , pNode -> iNode ) ; 
line 109315: sqlite3_step ( pRtree -> pDeleteNode ) ; 
line 109316: if ( SQLITE_OK != ( rc = sqlite3_reset ( pRtree -> pDeleteNode ) ) ) { 
line 109317: return rc ; 
line 109318: } 
line 109321: sqlite3_bind_int64 ( pRtree -> pDeleteParent , 1 , pNode -> iNode ) ; 
line 109322: sqlite3_step ( pRtree -> pDeleteParent ) ; 
line 109323: if ( SQLITE_OK != ( rc = sqlite3_reset ( pRtree -> pDeleteParent ) ) ) { 
line 109324: return rc ; 
line 109325: } 
line 109330: nodeHashDelete ( pRtree , pNode ) ; 
line 109331: pNode -> iNode = iHeight ; 
line 109332: pNode -> pNext = pRtree -> pDeleted ; 
line 109333: pNode -> nRef ++ ; 
line 109334: pRtree -> pDeleted = pNode ; 
line 109336: return SQLITE_OK ; 
line 109337: } 
line 109339: static void fixBoundingBox ( Rtree * pRtree , RtreeNode * pNode ) { 
line 109340: RtreeNode * pParent = pNode -> pParent ; 
line 109341: if ( pParent ) { 
line 109342: int ii ; 
line 109343: int nCell = NCELL ( pNode ) ; 
line 109344: RtreeCell box ; 
line 109345: nodeGetCell ( pRtree , pNode , 0 , & box ) ; 
line 109346: for ( ii = 1 ; ii < nCell ; ii ++ ) { 
line 109347: RtreeCell cell ; 
line 109348: nodeGetCell ( pRtree , pNode , ii , & cell ) ; 
line 109349: cellUnion ( pRtree , & box , & cell ) ; 
line 109350: } 
line 109351: box . iRowid = pNode -> iNode ; 
line 109352: ii = nodeParentIndex ( pRtree , pNode ) ; 
line 109353: nodeOverwriteCell ( pRtree , pParent , & box , ii ) ; 
line 109354: fixBoundingBox ( pRtree , pParent ) ; 
line 109355: } 
line 109356: } 
line 109362: static int deleteCell ( Rtree * pRtree , RtreeNode * pNode , int iCell , int iHeight ) { 
line 109363: int rc ; 
line 109365: if ( SQLITE_OK != ( rc = fixLeafParent ( pRtree , pNode ) ) ) { 
line 109366: return rc ; 
line 109367: } 
line 109372: nodeDeleteCell ( pRtree , pNode , iCell ) ; 
line 109379: if ( pNode -> iNode != 1 ) { 
line 109380: RtreeNode * pParent = pNode -> pParent ; 
line 109381: if ( ( pParent -> iNode != 1 || NCELL ( pParent ) != 1 ) 
line 109382: && ( NCELL ( pNode ) < RTREE_MINCELLS ( pRtree ) ) 
line 109383: ) { 
line 109384: rc = removeNode ( pRtree , pNode , iHeight ) ; 
line 109385: } else { 
line 109386: fixBoundingBox ( pRtree , pNode ) ; 
line 109387: } 
line 109388: } 
line 109390: return rc ; 
line 109391: } 
line 109393: static int Reinsert ( 
line 109394: Rtree * pRtree , 
line 109395: RtreeNode * pNode , 
line 109396: RtreeCell * pCell , 
line 109397: int iHeight 
line 109398: ) { 
line 109399: int * aOrder ; 
line 109400: int * aSpare ; 
line 109401: RtreeCell * aCell ; 
line 109402: float * aDistance ; 
line 109403: int nCell ; 
line 109404: float aCenterCoord [ RTREE_MAX_DIMENSIONS ] ; 
line 109405: int iDim ; 
line 109406: int ii ; 
line 109407: int rc = SQLITE_OK ; 
line 109409: memset ( aCenterCoord , 0 , sizeof ( float ) * RTREE_MAX_DIMENSIONS ) ; 
line 109411: nCell = NCELL ( pNode ) + 1 ; 
line 109416: aCell = ( RtreeCell * ) sqlite3_malloc ( nCell * ( 
line 109417: sizeof ( RtreeCell ) + 
line 109418: sizeof ( int ) + 
line 109419: sizeof ( int ) + 
line 109420: sizeof ( float ) 
line 109421: ) ) ; 
line 109422: if ( ! aCell ) { 
line 109423: return SQLITE_NOMEM ; 
line 109424: } 
line 109425: aOrder = ( int * ) & aCell [ nCell ] ; 
line 109426: aSpare = ( int * ) & aOrder [ nCell ] ; 
line 109427: aDistance = ( float * ) & aSpare [ nCell ] ; 
line 109429: for ( ii = 0 ; ii < nCell ; ii ++ ) { 
line 109430: if ( ii == ( nCell - 1 ) ) { 
line 109431: memcpy ( & aCell [ ii ] , pCell , sizeof ( RtreeCell ) ) ; 
line 109432: } else { 
line 109433: nodeGetCell ( pRtree , pNode , ii , & aCell [ ii ] ) ; 
line 109434: } 
line 109435: aOrder [ ii ] = ii ; 
line 109436: for ( iDim = 0 ; iDim < pRtree -> nDim ; iDim ++ ) { 
line 109437: aCenterCoord [ iDim ] += DCOORD ( aCell [ ii ] . aCoord [ iDim * 2 ] ) ; 
line 109438: aCenterCoord [ iDim ] += DCOORD ( aCell [ ii ] . aCoord [ iDim * 2 + 1 ] ) ; 
line 109439: } 
line 109440: } 
line 109441: for ( iDim = 0 ; iDim < pRtree -> nDim ; iDim ++ ) { 
line 109442: aCenterCoord [ iDim ] = aCenterCoord [ iDim ] / ( ( float ) nCell * 2.0 ) ; 
line 109443: } 
line 109445: for ( ii = 0 ; ii < nCell ; ii ++ ) { 
line 109446: aDistance [ ii ] = 0.0 ; 
line 109447: for ( iDim = 0 ; iDim < pRtree -> nDim ; iDim ++ ) { 
line 109448: float coord = DCOORD ( aCell [ ii ] . aCoord [ iDim * 2 + 1 ] ) - 
line 109449: DCOORD ( aCell [ ii ] . aCoord [ iDim * 2 ] ) ; 
line 109450: aDistance [ ii ] += ( coord - aCenterCoord [ iDim ] ) * ( coord - aCenterCoord [ iDim ] ) ; 
line 109451: } 
line 109452: } 
line 109454: SortByDistance ( aOrder , nCell , aDistance , aSpare ) ; 
line 109455: nodeZero ( pRtree , pNode ) ; 
line 109457: for ( ii = 0 ; rc == SQLITE_OK && ii < ( nCell - ( RTREE_MINCELLS ( pRtree ) + 1 ) ) ; ii ++ ) { 
line 109458: RtreeCell * p = & aCell [ aOrder [ ii ] ] ; 
line 109459: nodeInsertCell ( pRtree , pNode , p ) ; 
line 109460: if ( p -> iRowid == pCell -> iRowid ) { 
line 109461: if ( iHeight == 0 ) { 
line 109462: rc = rowidWrite ( pRtree , p -> iRowid , pNode -> iNode ) ; 
line 109463: } else { 
line 109464: rc = parentWrite ( pRtree , p -> iRowid , pNode -> iNode ) ; 
line 109465: } 
line 109466: } 
line 109467: } 
line 109468: if ( rc == SQLITE_OK ) { 
line 109469: fixBoundingBox ( pRtree , pNode ) ; 
line 109470: } 
line 109471: for ( ; rc == SQLITE_OK && ii < nCell ; ii ++ ) { 
line 109475: RtreeNode * pInsert ; 
line 109476: RtreeCell * p = & aCell [ aOrder [ ii ] ] ; 
line 109477: rc = ChooseLeaf ( pRtree , p , iHeight , & pInsert ) ; 
line 109478: if ( rc == SQLITE_OK ) { 
line 109479: int rc2 ; 
line 109480: rc = rtreeInsertCell ( pRtree , pInsert , p , iHeight ) ; 
line 109481: rc2 = nodeRelease ( pRtree , pInsert ) ; 
line 109482: if ( rc == SQLITE_OK ) { 
line 109483: rc = rc2 ; 
line 109484: } 
line 109485: } 
line 109486: } 
line 109488: sqlite3_free ( aCell ) ; 
line 109489: return rc ; 
line 109490: } 
line 109496: static int rtreeInsertCell ( 
line 109497: Rtree * pRtree , 
line 109498: RtreeNode * pNode , 
line 109499: RtreeCell * pCell , 
line 109500: int iHeight 
line 109501: ) { 
line 109502: int rc = SQLITE_OK ; 
line 109503: if ( iHeight > 0 ) { 
line 109504: RtreeNode * pChild = nodeHashLookup ( pRtree , pCell -> iRowid ) ; 
line 109505: if ( pChild ) { 
line 109506: nodeRelease ( pRtree , pChild -> pParent ) ; 
line 109507: nodeReference ( pNode ) ; 
line 109508: pChild -> pParent = pNode ; 
line 109509: } 
line 109510: } 
line 109511: if ( nodeInsertCell ( pRtree , pNode , pCell ) ) { 
line 109512: # if VARIANT_RSTARTREE_REINSERT 
line 109513: if ( iHeight <= pRtree -> iReinsertHeight || pNode -> iNode == 1 ) { 
line 109514: rc = SplitNode ( pRtree , pNode , pCell , iHeight ) ; 
line 109515: } else { 
line 109516: pRtree -> iReinsertHeight = iHeight ; 
line 109517: rc = Reinsert ( pRtree , pNode , pCell , iHeight ) ; 
line 109518: } 
line 109519: # else 
line 109520: rc = SplitNode ( pRtree , pNode , pCell , iHeight ) ; 
line 109521: # endif 
line 109522: } else { 
line 109523: AdjustTree ( pRtree , pNode , pCell ) ; 
line 109524: if ( iHeight == 0 ) { 
line 109525: rc = rowidWrite ( pRtree , pCell -> iRowid , pNode -> iNode ) ; 
line 109526: } else { 
line 109527: rc = parentWrite ( pRtree , pCell -> iRowid , pNode -> iNode ) ; 
line 109528: } 
line 109529: } 
line 109530: return rc ; 
line 109531: } 
line 109533: static int reinsertNodeContent ( Rtree * pRtree , RtreeNode * pNode ) { 
line 109534: int ii ; 
line 109535: int rc = SQLITE_OK ; 
line 109536: int nCell = NCELL ( pNode ) ; 
line 109538: for ( ii = 0 ; rc == SQLITE_OK && ii < nCell ; ii ++ ) { 
line 109539: RtreeNode * pInsert ; 
line 109540: RtreeCell cell ; 
line 109541: nodeGetCell ( pRtree , pNode , ii , & cell ) ; 
line 109546: rc = ChooseLeaf ( pRtree , & cell , pNode -> iNode , & pInsert ) ; 
line 109547: if ( rc == SQLITE_OK ) { 
line 109548: int rc2 ; 
line 109549: rc = rtreeInsertCell ( pRtree , pInsert , & cell , pNode -> iNode ) ; 
line 109550: rc2 = nodeRelease ( pRtree , pInsert ) ; 
line 109551: if ( rc == SQLITE_OK ) { 
line 109552: rc = rc2 ; 
line 109553: } 
line 109554: } 
line 109555: } 
line 109556: return rc ; 
line 109557: } 
line 109562: static int newRowid ( Rtree * pRtree , i64 * piRowid ) { 
line 109563: int rc ; 
line 109564: sqlite3_bind_null ( pRtree -> pWriteRowid , 1 ) ; 
line 109565: sqlite3_bind_null ( pRtree -> pWriteRowid , 2 ) ; 
line 109566: sqlite3_step ( pRtree -> pWriteRowid ) ; 
line 109567: rc = sqlite3_reset ( pRtree -> pWriteRowid ) ; 
line 109568: * piRowid = sqlite3_last_insert_rowid ( pRtree -> db ) ; 
line 109569: return rc ; 
line 109570: } 
line 109572: # ifndef NDEBUG 
line 109573: static int hashIsEmpty ( Rtree * pRtree ) { 
line 109574: int ii ; 
line 109575: for ( ii = 0 ; ii < HASHSIZE ; ii ++ ) { 
line 109576: assert ( ! pRtree -> aHash [ ii ] ) ; 
line 109577: } 
line 109578: return 1 ; 
line 109579: } 
line 109580: # endif 
line 109585: static int rtreeUpdate ( 
line 109586: sqlite3_vtab * pVtab , 
line 109587: int nData , 
line 109588: sqlite3_value * * azData , 
line 109589: sqlite_int64 * pRowid 
line 109590: ) { 
line 109591: Rtree * pRtree = ( Rtree * ) pVtab ; 
line 109592: int rc = SQLITE_OK ; 
line 109594: rtreeReference ( pRtree ) ; 
line 109596: assert ( nData >= 1 ) ; 
line 109597: assert ( hashIsEmpty ( pRtree ) ) ; 
line 109603: if ( sqlite3_value_type ( azData [ 0 ] ) != SQLITE_NULL ) { 
line 109604: i64 iDelete ; 
line 109605: RtreeNode * pLeaf ; 
line 109606: int iCell ; 
line 109607: RtreeNode * pRoot ; 
line 109610: rc = nodeAcquire ( pRtree , 1 , 0 , & pRoot ) ; 
line 109615: if ( rc == SQLITE_OK ) { 
line 109616: iDelete = sqlite3_value_int64 ( azData [ 0 ] ) ; 
line 109617: rc = findLeafNode ( pRtree , iDelete , & pLeaf ) ; 
line 109618: } 
line 109621: if ( rc == SQLITE_OK ) { 
line 109622: int rc2 ; 
line 109623: iCell = nodeRowidIndex ( pRtree , pLeaf , iDelete ) ; 
line 109624: rc = deleteCell ( pRtree , pLeaf , iCell , 0 ) ; 
line 109625: rc2 = nodeRelease ( pRtree , pLeaf ) ; 
line 109626: if ( rc == SQLITE_OK ) { 
line 109627: rc = rc2 ; 
line 109628: } 
line 109629: } 
line 109632: if ( rc == SQLITE_OK ) { 
line 109633: sqlite3_bind_int64 ( pRtree -> pDeleteRowid , 1 , iDelete ) ; 
line 109634: sqlite3_step ( pRtree -> pDeleteRowid ) ; 
line 109635: rc = sqlite3_reset ( pRtree -> pDeleteRowid ) ; 
line 109636: } 
line 109646: if ( rc == SQLITE_OK && pRtree -> iDepth > 0 ) { 
line 109647: if ( rc == SQLITE_OK && NCELL ( pRoot ) == 1 ) { 
line 109648: RtreeNode * pChild ; 
line 109649: i64 iChild = nodeGetRowid ( pRtree , pRoot , 0 ) ; 
line 109650: rc = nodeAcquire ( pRtree , iChild , pRoot , & pChild ) ; 
line 109651: if ( rc == SQLITE_OK ) { 
line 109652: rc = removeNode ( pRtree , pChild , pRtree -> iDepth - 1 ) ; 
line 109653: } 
line 109654: if ( rc == SQLITE_OK ) { 
line 109655: pRtree -> iDepth -- ; 
line 109656: writeInt16 ( pRoot -> zData , pRtree -> iDepth ) ; 
line 109657: pRoot -> isDirty = 1 ; 
line 109658: } 
line 109659: } 
line 109660: } 
line 109663: for ( pLeaf = pRtree -> pDeleted ; pLeaf ; pLeaf = pRtree -> pDeleted ) { 
line 109664: if ( rc == SQLITE_OK ) { 
line 109665: rc = reinsertNodeContent ( pRtree , pLeaf ) ; 
line 109666: } 
line 109667: pRtree -> pDeleted = pLeaf -> pNext ; 
line 109668: sqlite3_free ( pLeaf ) ; 
line 109669: } 
line 109672: if ( rc == SQLITE_OK ) { 
line 109673: rc = nodeRelease ( pRtree , pRoot ) ; 
line 109674: } else { 
line 109675: nodeRelease ( pRtree , pRoot ) ; 
line 109676: } 
line 109677: } 
line 109683: if ( rc == SQLITE_OK && nData > 1 ) { 
line 109685: RtreeCell cell ; 
line 109686: int ii ; 
line 109687: RtreeNode * pLeaf ; 
line 109690: assert ( nData == ( pRtree -> nDim * 2 + 3 ) ) ; 
line 109691: if ( pRtree -> eCoordType == RTREE_COORD_REAL32 ) { 
line 109692: for ( ii = 0 ; ii < ( pRtree -> nDim * 2 ) ; ii += 2 ) { 
line 109693: cell . aCoord [ ii ] . f = ( float ) sqlite3_value_double ( azData [ ii + 3 ] ) ; 
line 109694: cell . aCoord [ ii + 1 ] . f = ( float ) sqlite3_value_double ( azData [ ii + 4 ] ) ; 
line 109695: if ( cell . aCoord [ ii ] . f > cell . aCoord [ ii + 1 ] . f ) { 
line 109696: rc = SQLITE_CONSTRAINT ; 
line 109697: goto constraint ; 
line 109698: } 
line 109699: } 
line 109700: } else { 
line 109701: for ( ii = 0 ; ii < ( pRtree -> nDim * 2 ) ; ii += 2 ) { 
line 109702: cell . aCoord [ ii ] . i = sqlite3_value_int ( azData [ ii + 3 ] ) ; 
line 109703: cell . aCoord [ ii + 1 ] . i = sqlite3_value_int ( azData [ ii + 4 ] ) ; 
line 109704: if ( cell . aCoord [ ii ] . i > cell . aCoord [ ii + 1 ] . i ) { 
line 109705: rc = SQLITE_CONSTRAINT ; 
line 109706: goto constraint ; 
line 109707: } 
line 109708: } 
line 109709: } 
line 109712: if ( sqlite3_value_type ( azData [ 2 ] ) == SQLITE_NULL ) { 
line 109713: rc = newRowid ( pRtree , & cell . iRowid ) ; 
line 109714: } else { 
line 109715: cell . iRowid = sqlite3_value_int64 ( azData [ 2 ] ) ; 
line 109716: sqlite3_bind_int64 ( pRtree -> pReadRowid , 1 , cell . iRowid ) ; 
line 109717: if ( SQLITE_ROW == sqlite3_step ( pRtree -> pReadRowid ) ) { 
line 109718: sqlite3_reset ( pRtree -> pReadRowid ) ; 
line 109719: rc = SQLITE_CONSTRAINT ; 
line 109720: goto constraint ; 
line 109721: } 
line 109722: rc = sqlite3_reset ( pRtree -> pReadRowid ) ; 
line 109723: } 
line 109725: if ( rc == SQLITE_OK ) { 
line 109726: rc = ChooseLeaf ( pRtree , & cell , 0 , & pLeaf ) ; 
line 109727: } 
line 109728: if ( rc == SQLITE_OK ) { 
line 109729: int rc2 ; 
line 109730: pRtree -> iReinsertHeight = - 1 ; 
line 109731: rc = rtreeInsertCell ( pRtree , pLeaf , & cell , 0 ) ; 
line 109732: rc2 = nodeRelease ( pRtree , pLeaf ) ; 
line 109733: if ( rc == SQLITE_OK ) { 
line 109734: rc = rc2 ; 
line 109735: } 
line 109736: } 
line 109737: } 
line 109739: constraint : 
line 109740: rtreeRelease ( pRtree ) ; 
line 109741: return rc ; 
line 109742: } 
line 109747: static int rtreeRename ( sqlite3_vtab * pVtab , const char * zNewName ) { 
line 109748: Rtree * pRtree = ( Rtree * ) pVtab ; 
line 109749: int rc = SQLITE_NOMEM ; 
line 109750: char * zSql = sqlite3_mprintf ( 
line 109751: "ALTER TABLE %Q.'%q_node'   RENAME TO \"%w_node\";" 
line 109752: "ALTER TABLE %Q.'%q_parent' RENAME TO \"%w_parent\";" 
line 109753: "ALTER TABLE %Q.'%q_rowid'  RENAME TO \"%w_rowid\";" 
line 109754: , pRtree -> zDb , pRtree -> zName , zNewName 
line 109755: , pRtree -> zDb , pRtree -> zName , zNewName 
line 109756: , pRtree -> zDb , pRtree -> zName , zNewName 
line 109757: ) ; 
line 109758: if ( zSql ) { 
line 109759: rc = sqlite3_exec ( pRtree -> db , zSql , 0 , 0 , 0 ) ; 
line 109760: sqlite3_free ( zSql ) ; 
line 109761: } 
line 109762: return rc ; 
line 109763: } 
line 109765: static sqlite3_module rtreeModule = { 
line 109766: 0 , 
line 109767: rtreeCreate , 
line 109768: rtreeConnect , 
line 109769: rtreeBestIndex , 
line 109770: rtreeDisconnect , 
line 109771: rtreeDestroy , 
line 109772: rtreeOpen , 
line 109773: rtreeClose , 
line 109774: rtreeFilter , 
line 109775: rtreeNext , 
line 109776: rtreeEof , 
line 109777: rtreeColumn , 
line 109778: rtreeRowid , 
line 109779: rtreeUpdate , 
line 109780: 0 , 
line 109781: 0 , 
line 109782: 0 , 
line 109783: 0 , 
line 109784: 0 , 
line 109785: rtreeRename 
line 109786: } ; 
line 109788: static int rtreeSqlInit ( 
line 109789: Rtree * pRtree , 
line 109790: sqlite3 * db , 
line 109791: const char * zDb , 
line 109792: const char * zPrefix , 
line 109793: int isCreate 
line 109794: ) { 
line 109795: int rc = SQLITE_OK ; 
line 109797: # define N_STATEMENT 9 
line 109798: static const char * azSql [ N_STATEMENT ] = { 
line 109800: "SELECT data FROM '%q'.'%q_node' WHERE nodeno = :1" , 
line 109801: "INSERT OR REPLACE INTO '%q'.'%q_node' VALUES(:1, :2)" , 
line 109802: "DELETE FROM '%q'.'%q_node' WHERE nodeno = :1" , 
line 109805: "SELECT nodeno FROM '%q'.'%q_rowid' WHERE rowid = :1" , 
line 109806: "INSERT OR REPLACE INTO '%q'.'%q_rowid' VALUES(:1, :2)" , 
line 109807: "DELETE FROM '%q'.'%q_rowid' WHERE rowid = :1" , 
line 109810: "SELECT parentnode FROM '%q'.'%q_parent' WHERE nodeno = :1" , 
line 109811: "INSERT OR REPLACE INTO '%q'.'%q_parent' VALUES(:1, :2)" , 
line 109812: "DELETE FROM '%q'.'%q_parent' WHERE nodeno = :1" 
line 109813: } ; 
line 109814: sqlite3_stmt * * appStmt [ N_STATEMENT ] ; 
line 109815: int i ; 
line 109817: pRtree -> db = db ; 
line 109819: if ( isCreate ) { 
line 109820: char * zCreate = sqlite3_mprintf ( 
line 109821: "CREATE TABLE \"%w\".\"%w_node\"(nodeno INTEGER PRIMARY KEY, data BLOB);" 
line 109822: "CREATE TABLE \"%w\".\"%w_rowid\"(rowid INTEGER PRIMARY KEY, nodeno INTEGER);" 
line 109823: "CREATE TABLE \"%w\".\"%w_parent\"(nodeno INTEGER PRIMARY KEY, parentnode INTEGER);" 
line 109824: "INSERT INTO '%q'.'%q_node' VALUES(1, zeroblob(%d))" , 
line 109825: zDb , zPrefix , zDb , zPrefix , zDb , zPrefix , zDb , zPrefix , pRtree -> iNodeSize 
line 109826: ) ; 
line 109827: if ( ! zCreate ) { 
line 109828: return SQLITE_NOMEM ; 
line 109829: } 
line 109830: rc = sqlite3_exec ( db , zCreate , 0 , 0 , 0 ) ; 
line 109831: sqlite3_free ( zCreate ) ; 
line 109832: if ( rc != SQLITE_OK ) { 
line 109833: return rc ; 
line 109834: } 
line 109835: } 
line 109837: appStmt [ 0 ] = & pRtree -> pReadNode ; 
line 109838: appStmt [ 1 ] = & pRtree -> pWriteNode ; 
line 109839: appStmt [ 2 ] = & pRtree -> pDeleteNode ; 
line 109840: appStmt [ 3 ] = & pRtree -> pReadRowid ; 
line 109841: appStmt [ 4 ] = & pRtree -> pWriteRowid ; 
line 109842: appStmt [ 5 ] = & pRtree -> pDeleteRowid ; 
line 109843: appStmt [ 6 ] = & pRtree -> pReadParent ; 
line 109844: appStmt [ 7 ] = & pRtree -> pWriteParent ; 
line 109845: appStmt [ 8 ] = & pRtree -> pDeleteParent ; 
line 109847: for ( i = 0 ; i < N_STATEMENT && rc == SQLITE_OK ; i ++ ) { 
line 109848: char * zSql = sqlite3_mprintf ( azSql [ i ] , zDb , zPrefix ) ; 
line 109849: if ( zSql ) { 
line 109850: rc = sqlite3_prepare_v2 ( db , zSql , - 1 , appStmt [ i ] , 0 ) ; 
line 109851: } else { 
line 109852: rc = SQLITE_NOMEM ; 
line 109853: } 
line 109854: sqlite3_free ( zSql ) ; 
line 109855: } 
line 109857: return rc ; 
line 109858: } 
line 109866: static int getPageSize ( sqlite3 * db , const char * zDb , int * piPageSize ) { 
line 109867: int rc = SQLITE_NOMEM ; 
line 109868: char * zSql ; 
line 109869: sqlite3_stmt * pStmt = 0 ; 
line 109871: zSql = sqlite3_mprintf ( "PRAGMA %Q.page_size" , zDb ) ; 
line 109872: if ( ! zSql ) { 
line 109873: return SQLITE_NOMEM ; 
line 109874: } 
line 109876: rc = sqlite3_prepare_v2 ( db , zSql , - 1 , & pStmt , 0 ) ; 
line 109877: sqlite3_free ( zSql ) ; 
line 109878: if ( rc != SQLITE_OK ) { 
line 109879: return rc ; 
line 109880: } 
line 109882: if ( SQLITE_ROW == sqlite3_step ( pStmt ) ) { 
line 109883: * piPageSize = sqlite3_column_int ( pStmt , 0 ) ; 
line 109884: } 
line 109885: return sqlite3_finalize ( pStmt ) ; 
line 109886: } 
line 109897: static int rtreeInit ( 
line 109898: sqlite3 * db , 
line 109899: void * pAux , 
line 109900: int argc , const char * const * argv , 
line 109901: sqlite3_vtab * * ppVtab , 
line 109902: char * * pzErr , 
line 109903: int isCreate 
line 109904: ) { 
line 109905: int rc = SQLITE_OK ; 
line 109906: int iPageSize = 0 ; 
line 109907: Rtree * pRtree ; 
line 109908: int nDb ; 
line 109909: int nName ; 
line 109910: int eCoordType = ( int ) pAux ; 
line 109912: const char * aErrMsg [ ] = { 
line 109913: 0 , 
line 109914: "Wrong number of columns for an rtree table" , 
line 109915: "Too few columns for an rtree table" , 
line 109916: "Too many columns for an rtree table" 
line 109917: } ; 
line 109919: int iErr = ( argc < 6 ) ? 2 : argc > ( RTREE_MAX_DIMENSIONS * 2 + 4 ) ? 3 : argc % 2 ; 
line 109920: if ( aErrMsg [ iErr ] ) { 
line 109921: * pzErr = sqlite3_mprintf ( "%s" , aErrMsg [ iErr ] ) ; 
line 109922: return SQLITE_ERROR ; 
line 109923: } 
line 109925: rc = getPageSize ( db , argv [ 1 ] , & iPageSize ) ; 
line 109926: if ( rc != SQLITE_OK ) { 
line 109927: return rc ; 
line 109928: } 
line 109931: nDb = strlen ( argv [ 1 ] ) ; 
line 109932: nName = strlen ( argv [ 2 ] ) ; 
line 109933: pRtree = ( Rtree * ) sqlite3_malloc ( sizeof ( Rtree ) + nDb + nName + 2 ) ; 
line 109934: if ( ! pRtree ) { 
line 109935: return SQLITE_NOMEM ; 
line 109936: } 
line 109937: memset ( pRtree , 0 , sizeof ( Rtree ) + nDb + nName + 2 ) ; 
line 109938: pRtree -> nBusy = 1 ; 
line 109939: pRtree -> base . pModule = & rtreeModule ; 
line 109940: pRtree -> zDb = ( char * ) & pRtree [ 1 ] ; 
line 109941: pRtree -> zName = & pRtree -> zDb [ nDb + 1 ] ; 
line 109942: pRtree -> nDim = ( argc - 4 ) / 2 ; 
line 109943: pRtree -> nBytesPerCell = 8 + pRtree -> nDim * 4 * 2 ; 
line 109944: pRtree -> eCoordType = eCoordType ; 
line 109945: memcpy ( pRtree -> zDb , argv [ 1 ] , nDb ) ; 
line 109946: memcpy ( pRtree -> zName , argv [ 2 ] , nName ) ; 
line 109955: pRtree -> iNodeSize = iPageSize - 64 ; 
line 109956: if ( ( 4 + pRtree -> nBytesPerCell * RTREE_MAXCELLS ) < pRtree -> iNodeSize ) { 
line 109957: pRtree -> iNodeSize = 4 + pRtree -> nBytesPerCell * RTREE_MAXCELLS ; 
line 109958: } 
line 109964: if ( ( rc = rtreeSqlInit ( pRtree , db , argv [ 1 ] , argv [ 2 ] , isCreate ) ) ) { 
line 109965: * pzErr = sqlite3_mprintf ( "%s" , sqlite3_errmsg ( db ) ) ; 
line 109966: } else { 
line 109967: char * zSql = sqlite3_mprintf ( "CREATE TABLE x(%s" , argv [ 3 ] ) ; 
line 109968: char * zTmp ; 
line 109969: int ii ; 
line 109970: for ( ii = 4 ; zSql && ii < argc ; ii ++ ) { 
line 109971: zTmp = zSql ; 
line 109972: zSql = sqlite3_mprintf ( "%s, %s" , zTmp , argv [ ii ] ) ; 
line 109973: sqlite3_free ( zTmp ) ; 
line 109974: } 
line 109975: if ( zSql ) { 
line 109976: zTmp = zSql ; 
line 109977: zSql = sqlite3_mprintf ( "%s);" , zTmp ) ; 
line 109978: sqlite3_free ( zTmp ) ; 
line 109979: } 
line 109980: if ( ! zSql ) { 
line 109981: rc = SQLITE_NOMEM ; 
line 109982: } else if ( SQLITE_OK != ( rc = sqlite3_declare_vtab ( db , zSql ) ) ) { 
line 109983: * pzErr = sqlite3_mprintf ( "%s" , sqlite3_errmsg ( db ) ) ; 
line 109984: } 
line 109985: sqlite3_free ( zSql ) ; 
line 109986: } 
line 109988: if ( rc == SQLITE_OK ) { 
line 109989: * ppVtab = ( sqlite3_vtab * ) pRtree ; 
line 109990: } else { 
line 109991: rtreeRelease ( pRtree ) ; 
line 109992: } 
line 109993: return rc ; 
line 109994: } 
line 110013: static void rtreenode ( sqlite3_context * ctx , int nArg , sqlite3_value * * apArg ) { 
line 110014: char * zText = 0 ; 
line 110015: RtreeNode node ; 
line 110016: Rtree tree ; 
line 110017: int ii ; 
line 110019: memset ( & node , 0 , sizeof ( RtreeNode ) ) ; 
line 110020: memset ( & tree , 0 , sizeof ( Rtree ) ) ; 
line 110021: tree . nDim = sqlite3_value_int ( apArg [ 0 ] ) ; 
line 110022: tree . nBytesPerCell = 8 + 8 * tree . nDim ; 
line 110023: node . zData = ( u8 * ) sqlite3_value_blob ( apArg [ 1 ] ) ; 
line 110025: for ( ii = 0 ; ii < NCELL ( & node ) ; ii ++ ) { 
line 110026: char zCell [ 512 ] ; 
line 110027: int nCell = 0 ; 
line 110028: RtreeCell cell ; 
line 110029: int jj ; 
line 110031: nodeGetCell ( & tree , & node , ii , & cell ) ; 
line 110032: sqlite3_snprintf ( 512 - nCell , & zCell [ nCell ] , "%d" , cell . iRowid ) ; 
line 110033: nCell = strlen ( zCell ) ; 
line 110034: for ( jj = 0 ; jj < tree . nDim * 2 ; jj ++ ) { 
line 110035: sqlite3_snprintf ( 512 - nCell , & zCell [ nCell ] , " %f" , ( double ) cell . aCoord [ jj ] . f ) ; 
line 110036: nCell = strlen ( zCell ) ; 
line 110037: } 
line 110039: if ( zText ) { 
line 110040: char * zTextNew = sqlite3_mprintf ( "%s {%s}" , zText , zCell ) ; 
line 110041: sqlite3_free ( zText ) ; 
line 110042: zText = zTextNew ; 
line 110043: } else { 
line 110044: zText = sqlite3_mprintf ( "{%s}" , zCell ) ; 
line 110045: } 
line 110046: } 
line 110048: sqlite3_result_text ( ctx , zText , - 1 , sqlite3_free ) ; 
line 110049: } 
line 110051: static void rtreedepth ( sqlite3_context * ctx , int nArg , sqlite3_value * * apArg ) { 
line 110052: if ( sqlite3_value_type ( apArg [ 0 ] ) != SQLITE_BLOB 
line 110053: || sqlite3_value_bytes ( apArg [ 0 ] ) < 2 
line 110054: ) { 
line 110055: sqlite3_result_error ( ctx , "Invalid argument to rtreedepth()" , - 1 ) ; 
line 110056: } else { 
line 110057: u8 * zBlob = ( u8 * ) sqlite3_value_blob ( apArg [ 0 ] ) ; 
line 110058: sqlite3_result_int ( ctx , readInt16 ( zBlob ) ) ; 
line 110059: } 
line 110060: } 
line 110067: SQLITE_PRIVATE int sqlite3RtreeInit ( sqlite3 * db ) { 
line 110068: int rc = SQLITE_OK ; 
line 110070: if ( rc == SQLITE_OK ) { 
line 110071: int utf8 = SQLITE_UTF8 ; 
line 110072: rc = sqlite3_create_function ( db , "rtreenode" , 2 , utf8 , 0 , rtreenode , 0 , 0 ) ; 
line 110073: } 
line 110074: if ( rc == SQLITE_OK ) { 
line 110075: int utf8 = SQLITE_UTF8 ; 
line 110076: rc = sqlite3_create_function ( db , "rtreedepth" , 1 , utf8 , 0 , rtreedepth , 0 , 0 ) ; 
line 110077: } 
line 110078: if ( rc == SQLITE_OK ) { 
line 110079: void * c = ( void * ) RTREE_COORD_REAL32 ; 
line 110080: rc = sqlite3_create_module_v2 ( db , "rtree" , & rtreeModule , c , 0 ) ; 
line 110081: } 
line 110082: if ( rc == SQLITE_OK ) { 
line 110083: void * c = ( void * ) RTREE_COORD_INT32 ; 
line 110084: rc = sqlite3_create_module_v2 ( db , "rtree_i32" , & rtreeModule , c , 0 ) ; 
line 110085: } 
line 110087: return rc ; 
line 110088: } 
line 110090: # if ! SQLITE_CORE 
line 110091: SQLITE_API int sqlite3_extension_init ( 
line 110092: sqlite3 * db , 
line 110093: char * * pzErrMsg , 
line 110094: const sqlite3_api_routines * pApi 
line 110095: ) { 
line 110096: SQLITE_EXTENSION_INIT2 ( pApi ) 
line 110097: return sqlite3RtreeInit ( db ) ; 
line 110098: } 
line 110099: # endif 
line 110101: # endif 
line 110135: # if ! defined ( SQLITE_CORE ) || defined ( SQLITE_ENABLE_ICU ) 
line 110138: # include < unicode / utypes . h > 
line 110139: # include < unicode / uregex . h > 
line 110140: # include < unicode / ustring . h > 
line 110141: # include < unicode / ucol . h > 
line 110144: # ifndef SQLITE_CORE 
line 110145: SQLITE_EXTENSION_INIT1 
line 110146: # else 
line 110147: # endif 
line 110153: # ifndef SQLITE_MAX_LIKE_PATTERN_LENGTH 
line 110154: # define SQLITE_MAX_LIKE_PATTERN_LENGTH 50000 
line 110155: # endif 
line 110160: static void xFree ( void * p ) { 
line 110161: sqlite3_free ( p ) ; 
line 110162: } 
line 110169: static int icuLikeCompare ( 
line 110170: const uint8_t * zPattern , 
line 110171: const uint8_t * zString , 
line 110172: const UChar32 uEsc 
line 110173: ) { 
line 110174: static const int MATCH_ONE = ( UChar32 ) '_' ; 
line 110175: static const int MATCH_ALL = ( UChar32 ) '%' ; 
line 110177: int iPattern = 0 ; 
line 110178: int iString = 0 ; 
line 110180: int prevEscape = 0 ; 
line 110182: while ( zPattern [ iPattern ] != 0 ) { 
line 110185: UChar32 uPattern ; 
line 110186: U8_NEXT_UNSAFE ( zPattern , iPattern , uPattern ) ; 
line 110187: assert ( uPattern != 0 ) ; 
line 110196: if ( ! prevEscape && uPattern == MATCH_ALL ) { 
line 110198: uint8_t c ; 
line 110204: while ( ( c = zPattern [ iPattern ] ) == MATCH_ALL || c == MATCH_ONE ) { 
line 110205: if ( c == MATCH_ONE ) { 
line 110206: if ( zString [ iString ] == 0 ) return 0 ; 
line 110207: U8_FWD_1_UNSAFE ( zString , iString ) ; 
line 110208: } 
line 110209: iPattern ++ ; 
line 110210: } 
line 110212: if ( zPattern [ iPattern ] == 0 ) return 1 ; 
line 110214: while ( zString [ iString ] ) { 
line 110215: if ( icuLikeCompare ( & zPattern [ iPattern ] , & zString [ iString ] , uEsc ) ) { 
line 110216: return 1 ; 
line 110217: } 
line 110218: U8_FWD_1_UNSAFE ( zString , iString ) ; 
line 110219: } 
line 110220: return 0 ; 
line 110222: } else if ( ! prevEscape && uPattern == MATCH_ONE ) { 
line 110224: if ( zString [ iString ] == 0 ) return 0 ; 
line 110225: U8_FWD_1_UNSAFE ( zString , iString ) ; 
line 110227: } else if ( ! prevEscape && uPattern == uEsc ) { 
line 110229: prevEscape = 1 ; 
line 110231: } else { 
line 110233: UChar32 uString ; 
line 110234: U8_NEXT_UNSAFE ( zString , iString , uString ) ; 
line 110235: uString = u_foldCase ( uString , U_FOLD_CASE_DEFAULT ) ; 
line 110236: uPattern = u_foldCase ( uPattern , U_FOLD_CASE_DEFAULT ) ; 
line 110237: if ( uString != uPattern ) { 
line 110238: return 0 ; 
line 110239: } 
line 110240: prevEscape = 0 ; 
line 110241: } 
line 110242: } 
line 110244: return zString [ iString ] == 0 ; 
line 110245: } 
line 110260: static void icuLikeFunc ( 
line 110261: sqlite3_context * context , 
line 110262: int argc , 
line 110263: sqlite3_value * * argv 
line 110264: ) { 
line 110265: const unsigned char * zA = sqlite3_value_text ( argv [ 0 ] ) ; 
line 110266: const unsigned char * zB = sqlite3_value_text ( argv [ 1 ] ) ; 
line 110267: UChar32 uEsc = 0 ; 
line 110272: if ( sqlite3_value_bytes ( argv [ 0 ] ) > SQLITE_MAX_LIKE_PATTERN_LENGTH ) { 
line 110273: sqlite3_result_error ( context , "LIKE or GLOB pattern too complex" , - 1 ) ; 
line 110274: return ; 
line 110275: } 
line 110278: if ( argc == 3 ) { 
line 110282: int nE = sqlite3_value_bytes ( argv [ 2 ] ) ; 
line 110283: const unsigned char * zE = sqlite3_value_text ( argv [ 2 ] ) ; 
line 110284: int i = 0 ; 
line 110285: if ( zE == 0 ) return ; 
line 110286: U8_NEXT ( zE , i , nE , uEsc ) ; 
line 110287: if ( i != nE ) { 
line 110288: sqlite3_result_error ( context , 
line 110289: "ESCAPE expression must be a single character" , - 1 ) ; 
line 110290: return ; 
line 110291: } 
line 110292: } 
line 110294: if ( zA && zB ) { 
line 110295: sqlite3_result_int ( context , icuLikeCompare ( zA , zB , uEsc ) ) ; 
line 110296: } 
line 110297: } 
line 110306: static void icuFunctionError ( 
line 110307: sqlite3_context * pCtx , 
line 110308: const char * zName , 
line 110309: UErrorCode e 
line 110310: ) { 
line 110311: char zBuf [ 128 ] ; 
line 110312: sqlite3_snprintf ( 128 , zBuf , "ICU error: %s(): %s" , zName , u_errorName ( e ) ) ; 
line 110313: zBuf [ 127 ] = '\0' ; 
line 110314: sqlite3_result_error ( pCtx , zBuf , - 1 ) ; 
line 110315: } 
line 110321: static void icuRegexpDelete ( void * p ) { 
line 110322: URegularExpression * pExpr = ( URegularExpression * ) p ; 
line 110323: uregex_close ( pExpr ) ; 
line 110324: } 
line 110345: static void icuRegexpFunc ( sqlite3_context * p , int nArg , sqlite3_value * * apArg ) { 
line 110346: UErrorCode status = U_ZERO_ERROR ; 
line 110347: URegularExpression * pExpr ; 
line 110348: UBool res ; 
line 110349: const UChar * zString = sqlite3_value_text16 ( apArg [ 1 ] ) ; 
line 110354: if ( ! zString ) { 
line 110355: return ; 
line 110356: } 
line 110358: pExpr = sqlite3_get_auxdata ( p , 0 ) ; 
line 110359: if ( ! pExpr ) { 
line 110360: const UChar * zPattern = sqlite3_value_text16 ( apArg [ 0 ] ) ; 
line 110361: if ( ! zPattern ) { 
line 110362: return ; 
line 110363: } 
line 110364: pExpr = uregex_open ( zPattern , - 1 , 0 , 0 , & status ) ; 
line 110366: if ( U_SUCCESS ( status ) ) { 
line 110367: sqlite3_set_auxdata ( p , 0 , pExpr , icuRegexpDelete ) ; 
line 110368: } else { 
line 110369: assert ( ! pExpr ) ; 
line 110370: icuFunctionError ( p , "uregex_open" , status ) ; 
line 110371: return ; 
line 110372: } 
line 110373: } 
line 110376: uregex_setText ( pExpr , zString , - 1 , & status ) ; 
line 110377: if ( ! U_SUCCESS ( status ) ) { 
line 110378: icuFunctionError ( p , "uregex_setText" , status ) ; 
line 110379: return ; 
line 110380: } 
line 110383: res = uregex_matches ( pExpr , 0 , & status ) ; 
line 110384: if ( ! U_SUCCESS ( status ) ) { 
line 110385: icuFunctionError ( p , "uregex_matches" , status ) ; 
line 110386: return ; 
line 110387: } 
line 110394: uregex_setText ( pExpr , 0 , 0 , & status ) ; 
line 110397: sqlite3_result_int ( p , res ? 1 : 0 ) ; 
line 110398: } 
line 110426: static void icuCaseFunc16 ( sqlite3_context * p , int nArg , sqlite3_value * * apArg ) { 
line 110427: const UChar * zInput ; 
line 110428: UChar * zOutput ; 
line 110429: int nInput ; 
line 110430: int nOutput ; 
line 110432: UErrorCode status = U_ZERO_ERROR ; 
line 110433: const char * zLocale = 0 ; 
line 110435: assert ( nArg == 1 || nArg == 2 ) ; 
line 110436: if ( nArg == 2 ) { 
line 110437: zLocale = ( const char * ) sqlite3_value_text ( apArg [ 1 ] ) ; 
line 110438: } 
line 110440: zInput = sqlite3_value_text16 ( apArg [ 0 ] ) ; 
line 110441: if ( ! zInput ) { 
line 110442: return ; 
line 110443: } 
line 110444: nInput = sqlite3_value_bytes16 ( apArg [ 0 ] ) ; 
line 110446: nOutput = nInput * 2 + 2 ; 
line 110447: zOutput = sqlite3_malloc ( nOutput ) ; 
line 110448: if ( ! zOutput ) { 
line 110449: return ; 
line 110450: } 
line 110452: if ( sqlite3_user_data ( p ) ) { 
line 110453: u_strToUpper ( zOutput , nOutput / 2 , zInput , nInput / 2 , zLocale , & status ) ; 
line 110454: } else { 
line 110455: u_strToLower ( zOutput , nOutput / 2 , zInput , nInput / 2 , zLocale , & status ) ; 
line 110456: } 
line 110458: if ( ! U_SUCCESS ( status ) ) { 
line 110459: icuFunctionError ( p , "u_strToLower()/u_strToUpper" , status ) ; 
line 110460: return ; 
line 110461: } 
line 110463: sqlite3_result_text16 ( p , zOutput , - 1 , xFree ) ; 
line 110464: } 
line 110470: static void icuCollationDel ( void * pCtx ) { 
line 110471: UCollator * p = ( UCollator * ) pCtx ; 
line 110472: ucol_close ( p ) ; 
line 110473: } 
line 110479: static int icuCollationColl ( 
line 110480: void * pCtx , 
line 110481: int nLeft , 
line 110482: const void * zLeft , 
line 110483: int nRight , 
line 110484: const void * zRight 
line 110485: ) { 
line 110486: UCollationResult res ; 
line 110487: UCollator * p = ( UCollator * ) pCtx ; 
line 110488: res = ucol_strcoll ( p , ( UChar * ) zLeft , nLeft / 2 , ( UChar * ) zRight , nRight / 2 ) ; 
line 110489: switch ( res ) { 
line 110490: case UCOL_LESS : return - 1 ; 
line 110491: case UCOL_GREATER : return + 1 ; 
line 110492: case UCOL_EQUAL : return 0 ; 
line 110493: } 
line 110494: assert ( ! "Unexpected return value from ucol_strcoll()" ) ; 
line 110495: return 0 ; 
line 110496: } 
line 110511: static void icuLoadCollation ( 
line 110512: sqlite3_context * p , 
line 110513: int nArg , 
line 110514: sqlite3_value * * apArg 
line 110515: ) { 
line 110516: sqlite3 * db = ( sqlite3 * ) sqlite3_user_data ( p ) ; 
line 110517: UErrorCode status = U_ZERO_ERROR ; 
line 110518: const char * zLocale ; 
line 110519: const char * zName ; 
line 110520: UCollator * pUCollator ; 
line 110521: int rc ; 
line 110523: assert ( nArg == 2 ) ; 
line 110524: zLocale = ( const char * ) sqlite3_value_text ( apArg [ 0 ] ) ; 
line 110525: zName = ( const char * ) sqlite3_value_text ( apArg [ 1 ] ) ; 
line 110527: if ( ! zLocale || ! zName ) { 
line 110528: return ; 
line 110529: } 
line 110531: pUCollator = ucol_open ( zLocale , & status ) ; 
line 110532: if ( ! U_SUCCESS ( status ) ) { 
line 110533: icuFunctionError ( p , "ucol_open" , status ) ; 
line 110534: return ; 
line 110535: } 
line 110536: assert ( p ) ; 
line 110538: rc = sqlite3_create_collation_v2 ( db , zName , SQLITE_UTF16 , ( void * ) pUCollator , 
line 110539: icuCollationColl , icuCollationDel 
line 110540: ) ; 
line 110541: if ( rc != SQLITE_OK ) { 
line 110542: ucol_close ( pUCollator ) ; 
line 110543: sqlite3_result_error ( p , "Error registering collation function" , - 1 ) ; 
line 110544: } 
line 110545: } 
line 110550: SQLITE_PRIVATE int sqlite3IcuInit ( sqlite3 * db ) { 
line 110551: struct IcuScalar { 
line 110552: const char * zName ; 
line 110553: int nArg ; 
line 110554: int enc ; 
line 110555: void * pContext ; 
line 110556: void ( * xFunc ) ( sqlite3_context * , int , sqlite3_value * * ) ; 
line 110557: } scalars [ ] = { 
line 110558: { "regexp" , 2 , SQLITE_ANY , 0 , icuRegexpFunc } , 
line 110560: { "lower" , 1 , SQLITE_UTF16 , 0 , icuCaseFunc16 } , 
line 110561: { "lower" , 2 , SQLITE_UTF16 , 0 , icuCaseFunc16 } , 
line 110562: { "upper" , 1 , SQLITE_UTF16 , ( void * ) 1 , icuCaseFunc16 } , 
line 110563: { "upper" , 2 , SQLITE_UTF16 , ( void * ) 1 , icuCaseFunc16 } , 
line 110565: { "lower" , 1 , SQLITE_UTF8 , 0 , icuCaseFunc16 } , 
line 110566: { "lower" , 2 , SQLITE_UTF8 , 0 , icuCaseFunc16 } , 
line 110567: { "upper" , 1 , SQLITE_UTF8 , ( void * ) 1 , icuCaseFunc16 } , 
line 110568: { "upper" , 2 , SQLITE_UTF8 , ( void * ) 1 , icuCaseFunc16 } , 
line 110570: { "like" , 2 , SQLITE_UTF8 , 0 , icuLikeFunc } , 
line 110571: { "like" , 3 , SQLITE_UTF8 , 0 , icuLikeFunc } , 
line 110573: { "icu_load_collation" , 2 , SQLITE_UTF8 , ( void * ) db , icuLoadCollation } , 
line 110574: } ; 
line 110576: int rc = SQLITE_OK ; 
line 110577: int i ; 
line 110579: for ( i = 0 ; rc == SQLITE_OK && i < ( sizeof ( scalars ) / sizeof ( struct IcuScalar ) ) ; i ++ ) { 
line 110580: struct IcuScalar * p = & scalars [ i ] ; 
line 110581: rc = sqlite3_create_function ( 
line 110582: db , p -> zName , p -> nArg , p -> enc , p -> pContext , p -> xFunc , 0 , 0 
line 110583: ) ; 
line 110584: } 
line 110586: return rc ; 
line 110587: } 
line 110589: # if ! SQLITE_CORE 
line 110590: SQLITE_API int sqlite3_extension_init ( 
line 110591: sqlite3 * db , 
line 110592: char * * pzErrMsg , 
line 110593: const sqlite3_api_routines * pApi 
line 110594: ) { 
line 110595: SQLITE_EXTENSION_INIT2 ( pApi ) 
line 110596: return sqlite3IcuInit ( db ) ; 
line 110597: } 
line 110598: # endif 
line 110600: # endif 
line 110620: # if ! defined ( SQLITE_CORE ) || defined ( SQLITE_ENABLE_FTS3 ) 
line 110621: # ifdef SQLITE_ENABLE_ICU 
line 110624: # include < unicode / ubrk . h > 
line 110625: # include < unicode / utf16 . h > 
line 110627: typedef struct IcuTokenizer IcuTokenizer ; 
line 110628: typedef struct IcuCursor IcuCursor ; 
line 110630: struct IcuTokenizer { 
line 110631: sqlite3_tokenizer base ; 
line 110632: char * zLocale ; 
line 110633: } ; 
line 110635: struct IcuCursor { 
line 110636: sqlite3_tokenizer_cursor base ; 
line 110638: UBreakIterator * pIter ; 
line 110639: int nChar ; 
line 110640: UChar * aChar ; 
line 110641: int * aOffset ; 
line 110643: int nBuffer ; 
line 110644: char * zBuffer ; 
line 110646: int iToken ; 
line 110647: } ; 
line 110652: static int icuCreate ( 
line 110653: int argc , 
line 110654: const char * const * argv , 
line 110655: sqlite3_tokenizer * * ppTokenizer 
line 110656: ) { 
line 110657: IcuTokenizer * p ; 
line 110658: int n = 0 ; 
line 110660: if ( argc > 0 ) { 
line 110661: n = strlen ( argv [ 0 ] ) + 1 ; 
line 110662: } 
line 110663: p = ( IcuTokenizer * ) sqlite3_malloc ( sizeof ( IcuTokenizer ) + n ) ; 
line 110664: if ( ! p ) { 
line 110665: return SQLITE_NOMEM ; 
line 110666: } 
line 110667: memset ( p , 0 , sizeof ( IcuTokenizer ) ) ; 
line 110669: if ( n ) { 
line 110670: p -> zLocale = ( char * ) & p [ 1 ] ; 
line 110671: memcpy ( p -> zLocale , argv [ 0 ] , n ) ; 
line 110672: } 
line 110674: * ppTokenizer = ( sqlite3_tokenizer * ) p ; 
line 110676: return SQLITE_OK ; 
line 110677: } 
line 110682: static int icuDestroy ( sqlite3_tokenizer * pTokenizer ) { 
line 110683: IcuTokenizer * p = ( IcuTokenizer * ) pTokenizer ; 
line 110684: sqlite3_free ( p ) ; 
line 110685: return SQLITE_OK ; 
line 110686: } 
line 110694: static int icuOpen ( 
line 110695: sqlite3_tokenizer * pTokenizer , 
line 110696: const char * zInput , 
line 110697: int nInput , 
line 110698: sqlite3_tokenizer_cursor * * ppCursor 
line 110699: ) { 
line 110700: IcuTokenizer * p = ( IcuTokenizer * ) pTokenizer ; 
line 110701: IcuCursor * pCsr ; 
line 110703: const int32_t opt = U_FOLD_CASE_DEFAULT ; 
line 110704: UErrorCode status = U_ZERO_ERROR ; 
line 110705: int nChar ; 
line 110707: UChar32 c ; 
line 110708: int iInput = 0 ; 
line 110709: int iOut = 0 ; 
line 110711: * ppCursor = 0 ; 
line 110713: if ( nInput < 0 ) { 
line 110714: nInput = strlen ( zInput ) ; 
line 110715: } 
line 110716: nChar = nInput + 1 ; 
line 110717: pCsr = ( IcuCursor * ) sqlite3_malloc ( 
line 110718: sizeof ( IcuCursor ) + 
line 110719: nChar * sizeof ( UChar ) + 
line 110720: ( nChar + 1 ) * sizeof ( int ) 
line 110721: ) ; 
line 110722: if ( ! pCsr ) { 
line 110723: return SQLITE_NOMEM ; 
line 110724: } 
line 110725: memset ( pCsr , 0 , sizeof ( IcuCursor ) ) ; 
line 110726: pCsr -> aChar = ( UChar * ) & pCsr [ 1 ] ; 
line 110727: pCsr -> aOffset = ( int * ) & pCsr -> aChar [ nChar ] ; 
line 110729: pCsr -> aOffset [ iOut ] = iInput ; 
line 110730: U8_NEXT ( zInput , iInput , nInput , c ) ; 
line 110731: while ( c > 0 ) { 
line 110732: int isError = 0 ; 
line 110733: c = u_foldCase ( c , opt ) ; 
line 110734: U16_APPEND ( pCsr -> aChar , iOut , nChar , c , isError ) ; 
line 110735: if ( isError ) { 
line 110736: sqlite3_free ( pCsr ) ; 
line 110737: return SQLITE_ERROR ; 
line 110738: } 
line 110739: pCsr -> aOffset [ iOut ] = iInput ; 
line 110741: if ( iInput < nInput ) { 
line 110742: U8_NEXT ( zInput , iInput , nInput , c ) ; 
line 110743: } else { 
line 110744: c = 0 ; 
line 110745: } 
line 110746: } 
line 110748: pCsr -> pIter = ubrk_open ( UBRK_WORD , p -> zLocale , pCsr -> aChar , iOut , & status ) ; 
line 110749: if ( ! U_SUCCESS ( status ) ) { 
line 110750: sqlite3_free ( pCsr ) ; 
line 110751: return SQLITE_ERROR ; 
line 110752: } 
line 110753: pCsr -> nChar = iOut ; 
line 110755: ubrk_first ( pCsr -> pIter ) ; 
line 110756: * ppCursor = ( sqlite3_tokenizer_cursor * ) pCsr ; 
line 110757: return SQLITE_OK ; 
line 110758: } 
line 110763: static int icuClose ( sqlite3_tokenizer_cursor * pCursor ) { 
line 110764: IcuCursor * pCsr = ( IcuCursor * ) pCursor ; 
line 110765: ubrk_close ( pCsr -> pIter ) ; 
line 110766: sqlite3_free ( pCsr -> zBuffer ) ; 
line 110767: sqlite3_free ( pCsr ) ; 
line 110768: return SQLITE_OK ; 
line 110769: } 
line 110774: static int icuNext ( 
line 110775: sqlite3_tokenizer_cursor * pCursor , 
line 110776: const char * * ppToken , 
line 110777: int * pnBytes , 
line 110778: int * piStartOffset , 
line 110779: int * piEndOffset , 
line 110780: int * piPosition 
line 110781: ) { 
line 110782: IcuCursor * pCsr = ( IcuCursor * ) pCursor ; 
line 110784: int iStart = 0 ; 
line 110785: int iEnd = 0 ; 
line 110786: int nByte = 0 ; 
line 110788: while ( iStart == iEnd ) { 
line 110789: UChar32 c ; 
line 110791: iStart = ubrk_current ( pCsr -> pIter ) ; 
line 110792: iEnd = ubrk_next ( pCsr -> pIter ) ; 
line 110793: if ( iEnd == UBRK_DONE ) { 
line 110794: return SQLITE_DONE ; 
line 110795: } 
line 110797: while ( iStart < iEnd ) { 
line 110798: int iWhite = iStart ; 
line 110799: U8_NEXT ( pCsr -> aChar , iWhite , pCsr -> nChar , c ) ; 
line 110800: if ( u_isspace ( c ) ) { 
line 110801: iStart = iWhite ; 
line 110802: } else { 
line 110803: break ; 
line 110804: } 
line 110805: } 
line 110806: assert ( iStart <= iEnd ) ; 
line 110807: } 
line 110809: do { 
line 110810: UErrorCode status = U_ZERO_ERROR ; 
line 110811: if ( nByte ) { 
line 110812: char * zNew = sqlite3_realloc ( pCsr -> zBuffer , nByte ) ; 
line 110813: if ( ! zNew ) { 
line 110814: return SQLITE_NOMEM ; 
line 110815: } 
line 110816: pCsr -> zBuffer = zNew ; 
line 110817: pCsr -> nBuffer = nByte ; 
line 110818: } 
line 110820: u_strToUTF8 ( 
line 110821: pCsr -> zBuffer , pCsr -> nBuffer , & nByte , 
line 110822: & pCsr -> aChar [ iStart ] , iEnd - iStart , 
line 110823: & status 
line 110824: ) ; 
line 110825: } while ( nByte > pCsr -> nBuffer ) ; 
line 110827: * ppToken = pCsr -> zBuffer ; 
line 110828: * pnBytes = nByte ; 
line 110829: * piStartOffset = pCsr -> aOffset [ iStart ] ; 
line 110830: * piEndOffset = pCsr -> aOffset [ iEnd ] ; 
line 110831: * piPosition = pCsr -> iToken ++ ; 
line 110833: return SQLITE_OK ; 
line 110834: } 
line 110839: static const sqlite3_tokenizer_module icuTokenizerModule = { 
line 110840: 0 , 
line 110841: icuCreate , 
line 110842: icuDestroy , 
line 110843: icuOpen , 
line 110844: icuClose , 
line 110845: icuNext , 
line 110846: } ; 
line 110851: SQLITE_PRIVATE void sqlite3Fts3IcuTokenizerModule ( 
line 110852: sqlite3_tokenizer_module const * * ppModule 
line 110853: ) { 
line 110854: * ppModule = & icuTokenizerModule ; 
line 110855: } 
line 110857: # endif 
line 110858: # endif 