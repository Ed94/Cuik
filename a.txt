
 61:	typedef unsigned long long uintptr_t ; 
 72:	typedef char * va_list ; 
149:	void __cdecl __va_start ( va_list * , ... ) ; 
 86:	_Pragma ( pack ( push , 8 ) ) 
183:	typedef unsigned long long size_t ; 
184:	typedef long long ptrdiff_t ; 
185:	typedef long long intptr_t ; 
199:	typedef _Bool __vcrt_bool ; 
218:	typedef unsigned short wchar_t ; 
327:	void __cdecl __security_init_cookie ( void ) ; 
336:	void __cdecl __security_check_cookie ( uintptr_t _StackCookie ) ; 
337:	__declspec ( noreturn ) void __cdecl __report_gsfailure ( uintptr_t _StackCookie ) ; 
341:	extern uintptr_t __security_cookie ; 
349:	_Pragma ( pack ( pop ) ) 
 72:	_Pragma ( pack ( push , 8 ) ) 
214:	typedef _Bool __crt_bool ; 
352:	void __cdecl _invalid_parameter_noinfo ( void ) ; 
353:	__declspec ( noreturn ) void __cdecl _invalid_parameter_noinfo_noreturn ( void ) ; 
355:	__declspec ( noreturn ) 
356:	void __cdecl _invoke_watson ( 
357:	wchar_t const * _Expression , 
358:	wchar_t const * _FunctionName , 
359:	wchar_t const * _FileName , 
360:	unsigned int _LineNo , 
361:	uintptr_t _Reserved ) ; 
576:	typedef int errno_t ; 
577:	typedef unsigned short wint_t ; 
578:	typedef unsigned short wctype_t ; 
579:	typedef long __time32_t ; 
580:	typedef long long __time64_t ; 
582:	typedef struct __crt_locale_data_public 
583:	{ 
584:	unsigned short const * _locale_pctype ; 
585:	int _locale_mb_cur_max ; 
586:	unsigned int _locale_lc_codepage ; 
587:	} __crt_locale_data_public ; 
589:	typedef struct __crt_locale_pointers 
590:	{ 
591:	struct __crt_locale_data * locinfo ; 
592:	struct __crt_multibyte_data * mbcinfo ; 
593:	} __crt_locale_pointers ; 
595:	typedef __crt_locale_pointers * _locale_t ; 
597:	typedef struct _Mbstatet 
598:	{ 
599:	unsigned long _Wchar ; 
600:	unsigned short _Byte , _State ; 
601:	} _Mbstatet ; 
603:	typedef _Mbstatet mbstate_t ; 
617:	typedef __time64_t time_t ; 
627:	typedef size_t rsize_t ; 
1052:	_Pragma ( pack ( pop ) ) 
 16:	_Pragma ( pack ( push , 8 ) ) 
 89:	__declspec ( noinline ) inline unsigned long long * __cdecl __local_stdio_printf_options ( void ) 
 90:	{ 
 91:	static unsigned long long _OptionsStorage ; 
 92:	return & _OptionsStorage ; 
 93:	} 
 99:	__declspec ( noinline ) inline unsigned long long * __cdecl __local_stdio_scanf_options ( void ) 
100:	{ 
101:	static unsigned long long _OptionsStorage ; 
102:	return & _OptionsStorage ; 
103:	} 
129:	_Pragma ( pack ( pop ) ) 
 19:	_Pragma ( pack ( push , 8 ) ) 
 28:	typedef struct _iobuf 
 29:	{ 
 30:	void * _Placeholder ; 
 31:	} FILE ; 
 34:	FILE * __cdecl __acrt_iob_func ( unsigned _Ix ) ; 
 51:	wint_t __cdecl fgetwc ( 
 52:	FILE * _Stream 
 53:	) ; 
 56:	wint_t __cdecl _fgetwchar ( void ) ; 
 59:	wint_t __cdecl fputwc ( 
 60:	wchar_t _Character , 
 61:	FILE * _Stream ) ; 
 64:	wint_t __cdecl _fputwchar ( 
 65:	wchar_t _Character 
 66:	) ; 
 69:	wint_t __cdecl getwc ( 
 70:	FILE * _Stream 
 71:	) ; 
 74:	wint_t __cdecl getwchar ( void ) ; 
 79:	wchar_t * __cdecl fgetws ( 
 80:	wchar_t * _Buffer , 
 81:	int _BufferCount , 
 82:	FILE * _Stream 
 83:	) ; 
 86:	int __cdecl fputws ( 
 87:	wchar_t const * _Buffer , 
 88:	FILE * _Stream 
 89:	) ; 
 93:	wchar_t * __cdecl _getws_s ( 
 94:	wchar_t * _Buffer , 
 95:	size_t _BufferCount 
 96:	) ; 
105:	wint_t __cdecl putwc ( 
106:	wchar_t _Character , 
107:	FILE * _Stream 
108:	) ; 
111:	wint_t __cdecl putwchar ( 
112:	wchar_t _Character 
113:	) ; 
116:	int __cdecl _putws ( 
117:	wchar_t const * _Buffer 
118:	) ; 
121:	wint_t __cdecl ungetwc ( 
122:	wint_t _Character , 
123:	FILE * _Stream 
124:	) ; 
127:	FILE * __cdecl _wfdopen ( 
128:	int _FileHandle , 
129:	wchar_t const * _Mode 
130:	) ; 
133:	FILE * __cdecl _wfopen ( 
134:	wchar_t const * _FileName , 
135:	wchar_t const * _Mode 
136:	) ; 
139:	errno_t __cdecl _wfopen_s ( 
140:	FILE * * _Stream , 
141:	wchar_t const * _FileName , 
142:	wchar_t const * _Mode 
143:	) ; 
147:	FILE * __cdecl _wfreopen ( 
148:	wchar_t const * _FileName , 
149:	wchar_t const * _Mode , 
150:	FILE * _OldStream 
151:	) ; 
154:	errno_t __cdecl _wfreopen_s ( 
155:	FILE * * _Stream , 
156:	wchar_t const * _FileName , 
157:	wchar_t const * _Mode , 
158:	FILE * _OldStream 
159:	) ; 
162:	FILE * __cdecl _wfsopen ( 
163:	wchar_t const * _FileName , 
164:	wchar_t const * _Mode , 
165:	int _ShFlag 
166:	) ; 
168:	void __cdecl _wperror ( 
169:	wchar_t const * _ErrorMessage 
170:	) ; 
175:	FILE * __cdecl _wpopen ( 
176:	wchar_t const * _Command , 
177:	wchar_t const * _Mode 
178:	) ; 
182:	int __cdecl _wremove ( 
183:	wchar_t const * _FileName 
184:	) ; 
190:	wchar_t * __cdecl _wtempnam ( 
191:	wchar_t const * _Directory , 
192:	wchar_t const * _FilePrefix 
193:	) ; 
199:	errno_t __cdecl _wtmpnam_s ( 
200:	wchar_t * _Buffer , 
201:	size_t _BufferCount 
202:	) ; 
224:	wint_t __cdecl _fgetwc_nolock ( 
225:	FILE * _Stream 
226:	) ; 
229:	wint_t __cdecl _fputwc_nolock ( 
230:	wchar_t _Character , 
231:	FILE * _Stream 
232:	) ; 
235:	wint_t __cdecl _getwc_nolock ( 
236:	FILE * _Stream 
237:	) ; 
240:	wint_t __cdecl _putwc_nolock ( 
241:	wchar_t _Character , 
242:	FILE * _Stream 
243:	) ; 
246:	wint_t __cdecl _ungetwc_nolock ( 
247:	wint_t _Character , 
248:	FILE * _Stream 
249:	) ; 
272:	int __cdecl __stdio_common_vfwprintf ( 
273:	unsigned long long _Options , 
274:	FILE * _Stream , 
275:	wchar_t const * _Format , 
276:	_locale_t _Locale , 
277:	va_list _ArgList 
278:	) ; 
281:	int __cdecl __stdio_common_vfwprintf_s ( 
282:	unsigned long long _Options , 
283:	FILE * _Stream , 
284:	wchar_t const * _Format , 
285:	_locale_t _Locale , 
286:	va_list _ArgList 
287:	) ; 
290:	int __cdecl __stdio_common_vfwprintf_p ( 
291:	unsigned long long _Options , 
292:	FILE * _Stream , 
293:	wchar_t const * _Format , 
294:	_locale_t _Locale , 
295:	va_list _ArgList 
296:	) ; 
299:	inline int __cdecl _vfwprintf_l ( 
300:	FILE * const _Stream , 
301:	wchar_t const * const _Format , 
302:	_locale_t const _Locale , 
303:	va_list _ArgList 
304:	) 
308:	{ 
309:	return __stdio_common_vfwprintf ( ( * __local_stdio_printf_options ( ) ) , _Stream , _Format , _Locale , _ArgList ) ; 
310:	} 
314:	inline int __cdecl vfwprintf ( 
315:	FILE * const _Stream , 
316:	wchar_t const * const _Format , 
317:	va_list _ArgList 
318:	) 
322:	{ 
323:	return _vfwprintf_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
324:	} 
328:	inline int __cdecl _vfwprintf_s_l ( 
329:	FILE * const _Stream , 
330:	wchar_t const * const _Format , 
331:	_locale_t const _Locale , 
332:	va_list _ArgList 
333:	) 
337:	{ 
338:	return __stdio_common_vfwprintf_s ( ( * __local_stdio_printf_options ( ) ) , _Stream , _Format , _Locale , _ArgList ) ; 
339:	} 
345:	inline int __cdecl vfwprintf_s ( 
346:	FILE * const _Stream , 
347:	wchar_t const * const _Format , 
348:	va_list _ArgList 
349:	) 
353:	{ 
354:	return _vfwprintf_s_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
355:	} 
361:	inline int __cdecl _vfwprintf_p_l ( 
362:	FILE * const _Stream , 
363:	wchar_t const * const _Format , 
364:	_locale_t const _Locale , 
365:	va_list _ArgList 
366:	) 
370:	{ 
371:	return __stdio_common_vfwprintf_p ( ( * __local_stdio_printf_options ( ) ) , _Stream , _Format , _Locale , _ArgList ) ; 
372:	} 
376:	inline int __cdecl _vfwprintf_p ( 
377:	FILE * const _Stream , 
378:	wchar_t const * const _Format , 
379:	va_list _ArgList 
380:	) 
384:	{ 
385:	return _vfwprintf_p_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
386:	} 
390:	inline int __cdecl _vwprintf_l ( 
391:	wchar_t const * const _Format , 
392:	_locale_t const _Locale , 
393:	va_list _ArgList 
394:	) 
398:	{ 
399:	return _vfwprintf_l ( ( __acrt_iob_func ( 1 ) ) , _Format , _Locale , _ArgList ) ; 
400:	} 
404:	inline int __cdecl vwprintf ( 
405:	wchar_t const * const _Format , 
406:	va_list _ArgList 
407:	) 
411:	{ 
412:	return _vfwprintf_l ( ( __acrt_iob_func ( 1 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
413:	} 
417:	inline int __cdecl _vwprintf_s_l ( 
418:	wchar_t const * const _Format , 
419:	_locale_t const _Locale , 
420:	va_list _ArgList 
421:	) 
425:	{ 
426:	return _vfwprintf_s_l ( ( __acrt_iob_func ( 1 ) ) , _Format , _Locale , _ArgList ) ; 
427:	} 
433:	inline int __cdecl vwprintf_s ( 
434:	wchar_t const * const _Format , 
435:	va_list _ArgList 
436:	) 
440:	{ 
441:	return _vfwprintf_s_l ( ( __acrt_iob_func ( 1 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
442:	} 
448:	inline int __cdecl _vwprintf_p_l ( 
449:	wchar_t const * const _Format , 
450:	_locale_t const _Locale , 
451:	va_list _ArgList 
452:	) 
456:	{ 
457:	return _vfwprintf_p_l ( ( __acrt_iob_func ( 1 ) ) , _Format , _Locale , _ArgList ) ; 
458:	} 
462:	inline int __cdecl _vwprintf_p ( 
463:	wchar_t const * const _Format , 
464:	va_list _ArgList 
465:	) 
469:	{ 
470:	return _vfwprintf_p_l ( ( __acrt_iob_func ( 1 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
471:	} 
475:	inline int __cdecl _fwprintf_l ( 
476:	FILE * const _Stream , 
477:	wchar_t const * const _Format , 
478:	_locale_t const _Locale , 
479:	... ) 
483:	{ 
484:	int _Result ; 
485:	va_list _ArgList ; 
486:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
487:	_Result = _vfwprintf_l ( _Stream , _Format , _Locale , _ArgList ) ; 
488:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
489:	return _Result ; 
490:	} 
494:	inline int __cdecl fwprintf ( 
495:	FILE * const _Stream , 
496:	wchar_t const * const _Format , 
497:	... ) 
501:	{ 
502:	int _Result ; 
503:	va_list _ArgList ; 
504:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
505:	_Result = _vfwprintf_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
506:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
507:	return _Result ; 
508:	} 
512:	inline int __cdecl _fwprintf_s_l ( 
513:	FILE * const _Stream , 
514:	wchar_t const * const _Format , 
515:	_locale_t const _Locale , 
516:	... ) 
520:	{ 
521:	int _Result ; 
522:	va_list _ArgList ; 
523:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
524:	_Result = _vfwprintf_s_l ( _Stream , _Format , _Locale , _ArgList ) ; 
525:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
526:	return _Result ; 
527:	} 
533:	inline int __cdecl fwprintf_s ( 
534:	FILE * const _Stream , 
535:	wchar_t const * const _Format , 
536:	... ) 
540:	{ 
541:	int _Result ; 
542:	va_list _ArgList ; 
543:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
544:	_Result = _vfwprintf_s_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
545:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
546:	return _Result ; 
547:	} 
553:	inline int __cdecl _fwprintf_p_l ( 
554:	FILE * const _Stream , 
555:	wchar_t const * const _Format , 
556:	_locale_t const _Locale , 
557:	... ) 
561:	{ 
562:	int _Result ; 
563:	va_list _ArgList ; 
564:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
565:	_Result = _vfwprintf_p_l ( _Stream , _Format , _Locale , _ArgList ) ; 
566:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
567:	return _Result ; 
568:	} 
572:	inline int __cdecl _fwprintf_p ( 
573:	FILE * const _Stream , 
574:	wchar_t const * const _Format , 
575:	... ) 
579:	{ 
580:	int _Result ; 
581:	va_list _ArgList ; 
582:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
583:	_Result = _vfwprintf_p_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
584:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
585:	return _Result ; 
586:	} 
590:	inline int __cdecl _wprintf_l ( 
591:	wchar_t const * const _Format , 
592:	_locale_t const _Locale , 
593:	... ) 
597:	{ 
598:	int _Result ; 
599:	va_list _ArgList ; 
600:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
601:	_Result = _vfwprintf_l ( ( __acrt_iob_func ( 1 ) ) , _Format , _Locale , _ArgList ) ; 
602:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
603:	return _Result ; 
604:	} 
608:	inline int __cdecl wprintf ( 
609:	wchar_t const * const _Format , 
610:	... ) 
614:	{ 
615:	int _Result ; 
616:	va_list _ArgList ; 
617:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
618:	_Result = _vfwprintf_l ( ( __acrt_iob_func ( 1 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
619:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
620:	return _Result ; 
621:	} 
625:	inline int __cdecl _wprintf_s_l ( 
626:	wchar_t const * const _Format , 
627:	_locale_t const _Locale , 
628:	... ) 
632:	{ 
633:	int _Result ; 
634:	va_list _ArgList ; 
635:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
636:	_Result = _vfwprintf_s_l ( ( __acrt_iob_func ( 1 ) ) , _Format , _Locale , _ArgList ) ; 
637:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
638:	return _Result ; 
639:	} 
645:	inline int __cdecl wprintf_s ( 
646:	wchar_t const * const _Format , 
647:	... ) 
651:	{ 
652:	int _Result ; 
653:	va_list _ArgList ; 
654:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
655:	_Result = _vfwprintf_s_l ( ( __acrt_iob_func ( 1 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
656:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
657:	return _Result ; 
658:	} 
664:	inline int __cdecl _wprintf_p_l ( 
665:	wchar_t const * const _Format , 
666:	_locale_t const _Locale , 
667:	... ) 
671:	{ 
672:	int _Result ; 
673:	va_list _ArgList ; 
674:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
675:	_Result = _vfwprintf_p_l ( ( __acrt_iob_func ( 1 ) ) , _Format , _Locale , _ArgList ) ; 
676:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
677:	return _Result ; 
678:	} 
682:	inline int __cdecl _wprintf_p ( 
683:	wchar_t const * const _Format , 
684:	... ) 
688:	{ 
689:	int _Result ; 
690:	va_list _ArgList ; 
691:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
692:	_Result = _vfwprintf_p_l ( ( __acrt_iob_func ( 1 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
693:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
694:	return _Result ; 
695:	} 
705:	int __cdecl __stdio_common_vfwscanf ( 
706:	unsigned long long _Options , 
707:	FILE * _Stream , 
708:	wchar_t const * _Format , 
709:	_locale_t _Locale , 
710:	va_list _ArgList 
711:	) ; 
714:	inline int __cdecl _vfwscanf_l ( 
715:	FILE * const _Stream , 
716:	wchar_t const * const _Format , 
717:	_locale_t const _Locale , 
718:	va_list _ArgList 
719:	) 
723:	{ 
724:	return __stdio_common_vfwscanf ( 
725:	( * __local_stdio_scanf_options ( ) ) , 
726:	_Stream , _Format , _Locale , _ArgList ) ; 
727:	} 
731:	inline int __cdecl vfwscanf ( 
732:	FILE * const _Stream , 
733:	wchar_t const * const _Format , 
734:	va_list _ArgList 
735:	) 
739:	{ 
740:	return _vfwscanf_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
741:	} 
745:	inline int __cdecl _vfwscanf_s_l ( 
746:	FILE * const _Stream , 
747:	wchar_t const * const _Format , 
748:	_locale_t const _Locale , 
749:	va_list _ArgList 
750:	) 
754:	{ 
755:	return __stdio_common_vfwscanf ( 
756:	( * __local_stdio_scanf_options ( ) ) | ( 1 ULL << 0 ) , 
757:	_Stream , _Format , _Locale , _ArgList ) ; 
758:	} 
764:	inline int __cdecl vfwscanf_s ( 
765:	FILE * const _Stream , 
766:	wchar_t const * const _Format , 
767:	va_list _ArgList 
768:	) 
772:	{ 
773:	return _vfwscanf_s_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
774:	} 
779:	inline int __cdecl _vwscanf_l ( 
780:	wchar_t const * const _Format , 
781:	_locale_t const _Locale , 
782:	va_list _ArgList 
783:	) 
787:	{ 
788:	return _vfwscanf_l ( ( __acrt_iob_func ( 0 ) ) , _Format , _Locale , _ArgList ) ; 
789:	} 
793:	inline int __cdecl vwscanf ( 
794:	wchar_t const * const _Format , 
795:	va_list _ArgList 
796:	) 
800:	{ 
801:	return _vfwscanf_l ( ( __acrt_iob_func ( 0 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
802:	} 
806:	inline int __cdecl _vwscanf_s_l ( 
807:	wchar_t const * const _Format , 
808:	_locale_t const _Locale , 
809:	va_list _ArgList 
810:	) 
814:	{ 
815:	return _vfwscanf_s_l ( ( __acrt_iob_func ( 0 ) ) , _Format , _Locale , _ArgList ) ; 
816:	} 
822:	inline int __cdecl vwscanf_s ( 
823:	wchar_t const * const _Format , 
824:	va_list _ArgList 
825:	) 
829:	{ 
830:	return _vfwscanf_s_l ( ( __acrt_iob_func ( 0 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
831:	} 
837:	inline int __cdecl _fwscanf_l ( 
838:	FILE * const _Stream , 
839:	wchar_t const * const _Format , 
840:	_locale_t const _Locale , 
841:	... ) 
845:	{ 
846:	int _Result ; 
847:	va_list _ArgList ; 
848:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
849:	_Result = _vfwscanf_l ( _Stream , _Format , _Locale , _ArgList ) ; 
850:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
851:	return _Result ; 
852:	} 
856:	inline int __cdecl fwscanf ( 
857:	FILE * const _Stream , 
858:	wchar_t const * const _Format , 
859:	... ) 
863:	{ 
864:	int _Result ; 
865:	va_list _ArgList ; 
866:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
867:	_Result = _vfwscanf_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
868:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
869:	return _Result ; 
870:	} 
874:	inline int __cdecl _fwscanf_s_l ( 
875:	FILE * const _Stream , 
876:	wchar_t const * const _Format , 
877:	_locale_t const _Locale , 
878:	... ) 
882:	{ 
883:	int _Result ; 
884:	va_list _ArgList ; 
885:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
886:	_Result = _vfwscanf_s_l ( _Stream , _Format , _Locale , _ArgList ) ; 
887:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
888:	return _Result ; 
889:	} 
895:	inline int __cdecl fwscanf_s ( 
896:	FILE * const _Stream , 
897:	wchar_t const * const _Format , 
898:	... ) 
902:	{ 
903:	int _Result ; 
904:	va_list _ArgList ; 
905:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
906:	_Result = _vfwscanf_s_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
907:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
908:	return _Result ; 
909:	} 
915:	inline int __cdecl _wscanf_l ( 
916:	wchar_t const * const _Format , 
917:	_locale_t const _Locale , 
918:	... ) 
922:	{ 
923:	int _Result ; 
924:	va_list _ArgList ; 
925:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
926:	_Result = _vfwscanf_l ( ( __acrt_iob_func ( 0 ) ) , _Format , _Locale , _ArgList ) ; 
927:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
928:	return _Result ; 
929:	} 
933:	inline int __cdecl wscanf ( 
934:	wchar_t const * const _Format , 
935:	... ) 
939:	{ 
940:	int _Result ; 
941:	va_list _ArgList ; 
942:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
943:	_Result = _vfwscanf_l ( ( __acrt_iob_func ( 0 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
944:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
945:	return _Result ; 
946:	} 
950:	inline int __cdecl _wscanf_s_l ( 
951:	wchar_t const * const _Format , 
952:	_locale_t const _Locale , 
953:	... ) 
957:	{ 
958:	int _Result ; 
959:	va_list _ArgList ; 
960:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
961:	_Result = _vfwscanf_s_l ( ( __acrt_iob_func ( 0 ) ) , _Format , _Locale , _ArgList ) ; 
962:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
963:	return _Result ; 
964:	} 
970:	inline int __cdecl wscanf_s ( 
971:	wchar_t const * const _Format , 
972:	... ) 
976:	{ 
977:	int _Result ; 
978:	va_list _ArgList ; 
979:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
980:	_Result = _vfwscanf_s_l ( ( __acrt_iob_func ( 0 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
981:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
982:	return _Result ; 
983:	} 
1003:	int __cdecl __stdio_common_vswprintf ( 
1004:	unsigned long long _Options , 
1005:	wchar_t * _Buffer , 
1006:	size_t _BufferCount , 
1007:	wchar_t const * _Format , 
1008:	_locale_t _Locale , 
1009:	va_list _ArgList 
1010:	) ; 
1014:	int __cdecl __stdio_common_vswprintf_s ( 
1015:	unsigned long long _Options , 
1016:	wchar_t * _Buffer , 
1017:	size_t _BufferCount , 
1018:	wchar_t const * _Format , 
1019:	_locale_t _Locale , 
1020:	va_list _ArgList 
1021:	) ; 
1025:	int __cdecl __stdio_common_vsnwprintf_s ( 
1026:	unsigned long long _Options , 
1027:	wchar_t * _Buffer , 
1028:	size_t _BufferCount , 
1029:	size_t _MaxCount , 
1030:	wchar_t const * _Format , 
1031:	_locale_t _Locale , 
1032:	va_list _ArgList 
1033:	) ; 
1037:	int __cdecl __stdio_common_vswprintf_p ( 
1038:	unsigned long long _Options , 
1039:	wchar_t * _Buffer , 
1040:	size_t _BufferCount , 
1041:	wchar_t const * _Format , 
1042:	_locale_t _Locale , 
1043:	va_list _ArgList 
1044:	) ; 
1048:	inline int __cdecl _vsnwprintf_l ( 
1049:	wchar_t * const _Buffer , 
1050:	size_t const _BufferCount , 
1051:	wchar_t const * const _Format , 
1052:	_locale_t const _Locale , 
1053:	va_list _ArgList 
1054:	) 
1058:	{ 
1059:	int const _Result = __stdio_common_vswprintf ( 
1060:	( * __local_stdio_printf_options ( ) ) | ( 1 ULL << 0 ) , 
1061:	_Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1063:	return _Result < 0 ? - 1 : _Result ; 
1064:	} 
1069:	inline int __cdecl _vsnwprintf_s_l ( 
1070:	wchar_t * const _Buffer , 
1071:	size_t const _BufferCount , 
1072:	size_t const _MaxCount , 
1073:	wchar_t const * const _Format , 
1074:	_locale_t const _Locale , 
1075:	va_list _ArgList 
1076:	) 
1080:	{ 
1081:	int const _Result = __stdio_common_vsnwprintf_s ( 
1082:	( * __local_stdio_printf_options ( ) ) , 
1083:	_Buffer , _BufferCount , _MaxCount , _Format , _Locale , _ArgList ) ; 
1085:	return _Result < 0 ? - 1 : _Result ; 
1086:	} 
1091:	inline int __cdecl _vsnwprintf_s ( 
1092:	wchar_t * const _Buffer , 
1093:	size_t const _BufferCount , 
1094:	size_t const _MaxCount , 
1095:	wchar_t const * const _Format , 
1096:	va_list _ArgList 
1097:	) 
1101:	{ 
1102:	return _vsnwprintf_s_l ( _Buffer , _BufferCount , _MaxCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1103:	} 
1106:	inline 
1117:	inline int __cdecl _vsnwprintf ( 
1118:	wchar_t * _Buffer , 
1119:	size_t _BufferCount , 
1120:	wchar_t const * _Format , 
1121:	va_list _ArgList 
1122:	) 
1126:	{ 
1127:	return _vsnwprintf_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1128:	} 
1142:	inline int __cdecl _vswprintf_c_l ( 
1143:	wchar_t * const _Buffer , 
1144:	size_t const _BufferCount , 
1145:	wchar_t const * const _Format , 
1146:	_locale_t const _Locale , 
1147:	va_list _ArgList 
1148:	) 
1152:	{ 
1153:	int const _Result = __stdio_common_vswprintf ( 
1154:	( * __local_stdio_printf_options ( ) ) , 
1155:	_Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1157:	return _Result < 0 ? - 1 : _Result ; 
1158:	} 
1163:	inline int __cdecl _vswprintf_c ( 
1164:	wchar_t * const _Buffer , 
1165:	size_t const _BufferCount , 
1166:	wchar_t const * const _Format , 
1167:	va_list _ArgList 
1168:	) 
1172:	{ 
1173:	return _vswprintf_c_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1174:	} 
1179:	inline int __cdecl _vswprintf_l ( 
1180:	wchar_t * const _Buffer , 
1181:	size_t const _BufferCount , 
1182:	wchar_t const * const _Format , 
1183:	_locale_t const _Locale , 
1184:	va_list _ArgList 
1185:	) 
1189:	{ 
1190:	return _vswprintf_c_l ( _Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1191:	} 
1196:	inline int __cdecl __vswprintf_l ( 
1197:	wchar_t * const _Buffer , 
1198:	wchar_t const * const _Format , 
1199:	_locale_t const _Locale , 
1200:	va_list _ArgList 
1201:	) 
1205:	{ 
1206:	return _vswprintf_l ( _Buffer , ( size_t ) - 1 , _Format , _Locale , _ArgList ) ; 
1207:	} 
1212:	inline int __cdecl _vswprintf ( 
1213:	wchar_t * const _Buffer , 
1214:	wchar_t const * const _Format , 
1215:	va_list _ArgList 
1216:	) 
1220:	{ 
1221:	return _vswprintf_l ( _Buffer , ( size_t ) - 1 , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1222:	} 
1227:	inline int __cdecl vswprintf ( 
1228:	wchar_t * const _Buffer , 
1229:	size_t const _BufferCount , 
1230:	wchar_t const * const _Format , 
1231:	va_list _ArgList 
1232:	) 
1236:	{ 
1237:	return _vswprintf_c_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1238:	} 
1243:	inline int __cdecl _vswprintf_s_l ( 
1244:	wchar_t * const _Buffer , 
1245:	size_t const _BufferCount , 
1246:	wchar_t const * const _Format , 
1247:	_locale_t const _Locale , 
1248:	va_list _ArgList 
1249:	) 
1253:	{ 
1254:	int const _Result = __stdio_common_vswprintf_s ( 
1255:	( * __local_stdio_printf_options ( ) ) , 
1256:	_Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1258:	return _Result < 0 ? - 1 : _Result ; 
1259:	} 
1265:	inline int __cdecl vswprintf_s ( 
1266:	wchar_t * const _Buffer , 
1267:	size_t const _BufferCount , 
1268:	wchar_t const * const _Format , 
1269:	va_list _ArgList 
1270:	) 
1274:	{ 
1275:	return _vswprintf_s_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1276:	} 
1291:	inline int __cdecl _vswprintf_p_l ( 
1292:	wchar_t * const _Buffer , 
1293:	size_t const _BufferCount , 
1294:	wchar_t const * const _Format , 
1295:	_locale_t const _Locale , 
1296:	va_list _ArgList 
1297:	) 
1301:	{ 
1302:	int const _Result = __stdio_common_vswprintf_p ( 
1303:	( * __local_stdio_printf_options ( ) ) , 
1304:	_Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1306:	return _Result < 0 ? - 1 : _Result ; 
1307:	} 
1312:	inline int __cdecl _vswprintf_p ( 
1313:	wchar_t * const _Buffer , 
1314:	size_t const _BufferCount , 
1315:	wchar_t const * const _Format , 
1316:	va_list _ArgList 
1317:	) 
1321:	{ 
1322:	return _vswprintf_p_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1323:	} 
1328:	inline int __cdecl _vscwprintf_l ( 
1329:	wchar_t const * const _Format , 
1330:	_locale_t const _Locale , 
1331:	va_list _ArgList 
1332:	) 
1336:	{ 
1337:	int const _Result = __stdio_common_vswprintf ( 
1338:	( * __local_stdio_printf_options ( ) ) | ( 1 ULL << 1 ) , 
1339:	( ( void * ) 0 ) , 0 , _Format , _Locale , _ArgList ) ; 
1341:	return _Result < 0 ? - 1 : _Result ; 
1342:	} 
1347:	inline int __cdecl _vscwprintf ( 
1348:	wchar_t const * const _Format , 
1349:	va_list _ArgList 
1350:	) 
1354:	{ 
1355:	return _vscwprintf_l ( _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1356:	} 
1361:	inline int __cdecl _vscwprintf_p_l ( 
1362:	wchar_t const * const _Format , 
1363:	_locale_t const _Locale , 
1364:	va_list _ArgList 
1365:	) 
1369:	{ 
1370:	int const _Result = __stdio_common_vswprintf_p ( 
1371:	( * __local_stdio_printf_options ( ) ) | ( 1 ULL << 1 ) , 
1372:	( ( void * ) 0 ) , 0 , _Format , _Locale , _ArgList ) ; 
1374:	return _Result < 0 ? - 1 : _Result ; 
1375:	} 
1380:	inline int __cdecl _vscwprintf_p ( 
1381:	wchar_t const * const _Format , 
1382:	va_list _ArgList 
1383:	) 
1387:	{ 
1388:	return _vscwprintf_p_l ( _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1389:	} 
1394:	inline int __cdecl __swprintf_l ( 
1395:	wchar_t * const _Buffer , 
1396:	wchar_t const * const _Format , 
1397:	_locale_t const _Locale , 
1398:	... ) 
1402:	{ 
1403:	int _Result ; 
1404:	va_list _ArgList ; 
1405:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1406:	_Result = __vswprintf_l ( _Buffer , _Format , _Locale , _ArgList ) ; 
1407:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1408:	return _Result ; 
1409:	} 
1414:	inline int __cdecl _swprintf_l ( 
1415:	wchar_t * const _Buffer , 
1416:	size_t const _BufferCount , 
1417:	wchar_t const * const _Format , 
1418:	_locale_t const _Locale , 
1419:	... ) 
1423:	{ 
1424:	int _Result ; 
1425:	va_list _ArgList ; 
1426:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1427:	_Result = _vswprintf_c_l ( _Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1428:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1429:	return _Result ; 
1430:	} 
1435:	inline int __cdecl _swprintf ( 
1436:	wchar_t * const _Buffer , 
1437:	wchar_t const * const _Format , 
1438:	... ) 
1442:	{ 
1443:	int _Result ; 
1444:	va_list _ArgList ; 
1445:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1446:	_Result = __vswprintf_l ( _Buffer , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1447:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1448:	return _Result ; 
1449:	} 
1454:	inline int __cdecl swprintf ( 
1455:	wchar_t * const _Buffer , 
1456:	size_t const _BufferCount , 
1457:	wchar_t const * const _Format , 
1458:	... ) 
1462:	{ 
1463:	int _Result ; 
1464:	va_list _ArgList ; 
1465:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1466:	_Result = _vswprintf_c_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1467:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1468:	return _Result ; 
1469:	} 
1472:	inline 
1481:	inline 
1490:	inline int __cdecl _swprintf_s_l ( 
1491:	wchar_t * const _Buffer , 
1492:	size_t const _BufferCount , 
1493:	wchar_t const * const _Format , 
1494:	_locale_t const _Locale , 
1495:	... ) 
1499:	{ 
1500:	int _Result ; 
1501:	va_list _ArgList ; 
1502:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1503:	_Result = _vswprintf_s_l ( _Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1504:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1505:	return _Result ; 
1506:	} 
1512:	inline int __cdecl swprintf_s ( 
1513:	wchar_t * const _Buffer , 
1514:	size_t const _BufferCount , 
1515:	wchar_t const * const _Format , 
1516:	... ) 
1520:	{ 
1521:	int _Result ; 
1522:	va_list _ArgList ; 
1523:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1524:	_Result = _vswprintf_s_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1525:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1526:	return _Result ; 
1527:	} 
1541:	inline int __cdecl _swprintf_p_l ( 
1542:	wchar_t * const _Buffer , 
1543:	size_t const _BufferCount , 
1544:	wchar_t const * const _Format , 
1545:	_locale_t const _Locale , 
1546:	... ) 
1550:	{ 
1551:	int _Result ; 
1552:	va_list _ArgList ; 
1553:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1554:	_Result = _vswprintf_p_l ( _Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1555:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1556:	return _Result ; 
1557:	} 
1562:	inline int __cdecl _swprintf_p ( 
1563:	wchar_t * const _Buffer , 
1564:	size_t const _BufferCount , 
1565:	wchar_t const * const _Format , 
1566:	... ) 
1570:	{ 
1571:	int _Result ; 
1572:	va_list _ArgList ; 
1573:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1574:	_Result = _vswprintf_p_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1575:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1576:	return _Result ; 
1577:	} 
1582:	inline int __cdecl _swprintf_c_l ( 
1583:	wchar_t * const _Buffer , 
1584:	size_t const _BufferCount , 
1585:	wchar_t const * const _Format , 
1586:	_locale_t const _Locale , 
1587:	... ) 
1591:	{ 
1592:	int _Result ; 
1593:	va_list _ArgList ; 
1594:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1595:	_Result = _vswprintf_c_l ( _Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1596:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1597:	return _Result ; 
1598:	} 
1603:	inline int __cdecl _swprintf_c ( 
1604:	wchar_t * const _Buffer , 
1605:	size_t const _BufferCount , 
1606:	wchar_t const * const _Format , 
1607:	... ) 
1611:	{ 
1612:	int _Result ; 
1613:	va_list _ArgList ; 
1614:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1615:	_Result = _vswprintf_c_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1616:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1617:	return _Result ; 
1618:	} 
1623:	inline int __cdecl _snwprintf_l ( 
1624:	wchar_t * const _Buffer , 
1625:	size_t const _BufferCount , 
1626:	wchar_t const * const _Format , 
1627:	_locale_t const _Locale , 
1628:	... ) 
1632:	{ 
1633:	int _Result ; 
1634:	va_list _ArgList ; 
1635:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1637:	_Result = _vsnwprintf_l ( _Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1639:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1640:	return _Result ; 
1641:	} 
1646:	inline int __cdecl _snwprintf ( 
1647:	wchar_t * _Buffer , 
1648:	size_t _BufferCount , 
1649:	wchar_t const * _Format , 
1650:	... ) 
1654:	{ 
1655:	int _Result ; 
1656:	va_list _ArgList ; 
1657:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1659:	_Result = _vsnwprintf_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1661:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1662:	return _Result ; 
1663:	} 
1668:	inline int __cdecl _snwprintf_s_l ( 
1669:	wchar_t * const _Buffer , 
1670:	size_t const _BufferCount , 
1671:	size_t const _MaxCount , 
1672:	wchar_t const * const _Format , 
1673:	_locale_t const _Locale , 
1674:	... ) 
1678:	{ 
1679:	int _Result ; 
1680:	va_list _ArgList ; 
1681:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1682:	_Result = _vsnwprintf_s_l ( _Buffer , _BufferCount , _MaxCount , _Format , _Locale , _ArgList ) ; 
1683:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1684:	return _Result ; 
1685:	} 
1690:	inline int __cdecl _snwprintf_s ( 
1691:	wchar_t * const _Buffer , 
1692:	size_t const _BufferCount , 
1693:	size_t const _MaxCount , 
1694:	wchar_t const * const _Format , 
1695:	... ) 
1699:	{ 
1700:	int _Result ; 
1701:	va_list _ArgList ; 
1702:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1703:	_Result = _vsnwprintf_s_l ( _Buffer , _BufferCount , _MaxCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1704:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1705:	return _Result ; 
1706:	} 
1718:	inline int __cdecl _scwprintf_l ( 
1719:	wchar_t const * const _Format , 
1720:	_locale_t const _Locale , 
1721:	... ) 
1725:	{ 
1726:	int _Result ; 
1727:	va_list _ArgList ; 
1728:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1729:	_Result = _vscwprintf_l ( _Format , _Locale , _ArgList ) ; 
1730:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1731:	return _Result ; 
1732:	} 
1737:	inline int __cdecl _scwprintf ( 
1738:	wchar_t const * const _Format , 
1739:	... ) 
1743:	{ 
1744:	int _Result ; 
1745:	va_list _ArgList ; 
1746:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1747:	_Result = _vscwprintf_l ( _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1748:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1749:	return _Result ; 
1750:	} 
1755:	inline int __cdecl _scwprintf_p_l ( 
1756:	wchar_t const * const _Format , 
1757:	_locale_t const _Locale , 
1758:	... ) 
1762:	{ 
1763:	int _Result ; 
1764:	va_list _ArgList ; 
1765:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1766:	_Result = _vscwprintf_p_l ( _Format , _Locale , _ArgList ) ; 
1767:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1768:	return _Result ; 
1769:	} 
1774:	inline int __cdecl _scwprintf_p ( 
1775:	wchar_t const * const _Format , 
1776:	... ) 
1780:	{ 
1781:	int _Result ; 
1782:	va_list _ArgList ; 
1783:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1784:	_Result = _vscwprintf_p_l ( _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1785:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1786:	return _Result ; 
1787:	} 
1868:	int __cdecl __stdio_common_vswscanf ( 
1869:	unsigned long long _Options , 
1870:	wchar_t const * _Buffer , 
1871:	size_t _BufferCount , 
1872:	wchar_t const * _Format , 
1873:	_locale_t _Locale , 
1874:	va_list _ArgList 
1875:	) ; 
1879:	inline int __cdecl _vswscanf_l ( 
1880:	wchar_t const * const _Buffer , 
1881:	wchar_t const * const _Format , 
1882:	_locale_t const _Locale , 
1883:	va_list _ArgList 
1884:	) 
1888:	{ 
1889:	return __stdio_common_vswscanf ( 
1890:	( * __local_stdio_scanf_options ( ) ) , 
1891:	_Buffer , ( size_t ) - 1 , _Format , _Locale , _ArgList ) ; 
1892:	} 
1897:	inline int __cdecl vswscanf ( 
1898:	wchar_t const * _Buffer , 
1899:	wchar_t const * _Format , 
1900:	va_list _ArgList 
1901:	) 
1905:	{ 
1906:	return _vswscanf_l ( _Buffer , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1907:	} 
1912:	inline int __cdecl _vswscanf_s_l ( 
1913:	wchar_t const * const _Buffer , 
1914:	wchar_t const * const _Format , 
1915:	_locale_t const _Locale , 
1916:	va_list _ArgList 
1917:	) 
1921:	{ 
1922:	return __stdio_common_vswscanf ( 
1923:	( * __local_stdio_scanf_options ( ) ) | ( 1 ULL << 0 ) , 
1924:	_Buffer , ( size_t ) - 1 , _Format , _Locale , _ArgList ) ; 
1925:	} 
1932:	inline int __cdecl vswscanf_s ( 
1933:	wchar_t const * const _Buffer , 
1934:	wchar_t const * const _Format , 
1935:	va_list _ArgList 
1936:	) 
1940:	{ 
1941:	return _vswscanf_s_l ( _Buffer , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1942:	} 
1957:	inline int __cdecl _vsnwscanf_l ( 
1958:	wchar_t const * const _Buffer , 
1959:	size_t const _BufferCount , 
1960:	wchar_t const * const _Format , 
1961:	_locale_t const _Locale , 
1962:	va_list _ArgList 
1963:	) 
1967:	{ 
1968:	return __stdio_common_vswscanf ( 
1969:	( * __local_stdio_scanf_options ( ) ) , 
1970:	_Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1971:	} 
1976:	inline int __cdecl _vsnwscanf_s_l ( 
1977:	wchar_t const * const _Buffer , 
1978:	size_t const _BufferCount , 
1979:	wchar_t const * const _Format , 
1980:	_locale_t const _Locale , 
1981:	va_list _ArgList 
1982:	) 
1986:	{ 
1987:	return __stdio_common_vswscanf ( 
1988:	( * __local_stdio_scanf_options ( ) ) | ( 1 ULL << 0 ) , 
1989:	_Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1990:	} 
1995:	inline int __cdecl _swscanf_l ( 
1996:	wchar_t const * const _Buffer , 
1997:	wchar_t const * const _Format , 
1998:	_locale_t _Locale , 
1999:	... ) 
2003:	{ 
2004:	int _Result ; 
2005:	va_list _ArgList ; 
2006:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
2007:	_Result = _vswscanf_l ( _Buffer , _Format , _Locale , _ArgList ) ; 
2008:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2009:	return _Result ; 
2010:	} 
2015:	inline int __cdecl swscanf ( 
2016:	wchar_t const * const _Buffer , 
2017:	wchar_t const * const _Format , 
2018:	... ) 
2022:	{ 
2023:	int _Result ; 
2024:	va_list _ArgList ; 
2025:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
2026:	_Result = _vswscanf_l ( _Buffer , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
2027:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2028:	return _Result ; 
2029:	} 
2034:	inline int __cdecl _swscanf_s_l ( 
2035:	wchar_t const * const _Buffer , 
2036:	wchar_t const * const _Format , 
2037:	_locale_t const _Locale , 
2038:	... ) 
2042:	{ 
2043:	int _Result ; 
2044:	va_list _ArgList ; 
2045:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
2046:	_Result = _vswscanf_s_l ( _Buffer , _Format , _Locale , _ArgList ) ; 
2047:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2048:	return _Result ; 
2049:	} 
2056:	inline int __cdecl swscanf_s ( 
2057:	wchar_t const * const _Buffer , 
2058:	wchar_t const * const _Format , 
2059:	... ) 
2063:	{ 
2064:	int _Result ; 
2065:	va_list _ArgList ; 
2066:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
2067:	_Result = _vswscanf_s_l ( _Buffer , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
2068:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2069:	return _Result ; 
2070:	} 
2077:	inline int __cdecl _snwscanf_l ( 
2078:	wchar_t const * const _Buffer , 
2079:	size_t const _BufferCount , 
2080:	wchar_t const * const _Format , 
2081:	_locale_t const _Locale , 
2082:	... ) 
2086:	{ 
2087:	int _Result ; 
2088:	va_list _ArgList ; 
2089:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
2091:	_Result = _vsnwscanf_l ( _Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
2093:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2094:	return _Result ; 
2095:	} 
2100:	inline int __cdecl _snwscanf ( 
2101:	wchar_t const * const _Buffer , 
2102:	size_t const _BufferCount , 
2103:	wchar_t const * const _Format , 
2104:	... ) 
2108:	{ 
2109:	int _Result ; 
2110:	va_list _ArgList ; 
2111:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
2113:	_Result = _vsnwscanf_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
2115:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2116:	return _Result ; 
2117:	} 
2122:	inline int __cdecl _snwscanf_s_l ( 
2123:	wchar_t const * const _Buffer , 
2124:	size_t const _BufferCount , 
2125:	wchar_t const * const _Format , 
2126:	_locale_t const _Locale , 
2127:	... ) 
2131:	{ 
2132:	int _Result ; 
2133:	va_list _ArgList ; 
2134:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
2135:	_Result = _vsnwscanf_s_l ( _Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
2136:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2137:	return _Result ; 
2138:	} 
2143:	inline int __cdecl _snwscanf_s ( 
2144:	wchar_t const * const _Buffer , 
2145:	size_t const _BufferCount , 
2146:	wchar_t const * const _Format , 
2147:	... ) 
2151:	{ 
2152:	int _Result ; 
2153:	va_list _ArgList ; 
2154:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
2155:	_Result = _vsnwscanf_s_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
2156:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2157:	return _Result ; 
2158:	} 
2166:	_Pragma ( pack ( pop ) ) 
 19:	_Pragma ( pack ( push , 8 ) ) 
 67:	typedef long long fpos_t ; 
 74:	errno_t __cdecl _get_stream_buffer_pointers ( 
 75:	FILE * _Stream , 
 76:	char * * * _Base , 
 77:	char * * * _Pointer , 
 78:	int * * _Count 
 79:	) ; 
 90:	errno_t __cdecl clearerr_s ( 
 91:	FILE * _Stream 
 92:	) ; 
 96:	errno_t __cdecl fopen_s ( 
 97:	FILE * * _Stream , 
 98:	char const * _FileName , 
 99:	char const * _Mode 
100:	) ; 
104:	size_t __cdecl fread_s ( 
105:	void * _Buffer , 
106:	size_t _BufferSize , 
107:	size_t _ElementSize , 
108:	size_t _ElementCount , 
109:	FILE * _Stream 
110:	) ; 
113:	errno_t __cdecl freopen_s ( 
114:	FILE * * _Stream , 
115:	char const * _FileName , 
116:	char const * _Mode , 
117:	FILE * _OldStream 
118:	) ; 
121:	char * __cdecl gets_s ( 
122:	char * _Buffer , 
123:	rsize_t _Size 
124:	) ; 
127:	errno_t __cdecl tmpfile_s ( 
128:	FILE * * _Stream 
129:	) ; 
133:	errno_t __cdecl tmpnam_s ( 
134:	char * _Buffer , 
135:	rsize_t _Size 
136:	) ; 
140:	void __cdecl clearerr ( 
141:	FILE * _Stream 
142:	) ; 
146:	int __cdecl fclose ( 
147:	FILE * _Stream 
148:	) ; 
151:	int __cdecl _fcloseall ( void ) ; 
154:	FILE * __cdecl _fdopen ( 
155:	int _FileHandle , 
156:	char const * _Mode 
157:	) ; 
160:	int __cdecl feof ( 
161:	FILE * _Stream 
162:	) ; 
165:	int __cdecl ferror ( 
166:	FILE * _Stream 
167:	) ; 
170:	int __cdecl fflush ( 
171:	FILE * _Stream 
172:	) ; 
176:	int __cdecl fgetc ( 
177:	FILE * _Stream 
178:	) ; 
181:	int __cdecl _fgetchar ( void ) ; 
185:	int __cdecl fgetpos ( 
186:	FILE * _Stream , 
187:	fpos_t * _Position 
188:	) ; 
192:	char * __cdecl fgets ( 
193:	char * _Buffer , 
194:	int _MaxCount , 
195:	FILE * _Stream 
196:	) ; 
199:	int __cdecl _fileno ( 
200:	FILE * _Stream 
201:	) ; 
204:	int __cdecl _flushall ( void ) ; 
207:	FILE * __cdecl fopen ( 
208:	char const * _FileName , 
209:	char const * _Mode 
210:	) ; 
215:	int __cdecl fputc ( 
216:	int _Character , 
217:	FILE * _Stream 
218:	) ; 
221:	int __cdecl _fputchar ( 
222:	int _Character 
223:	) ; 
227:	int __cdecl fputs ( 
228:	char const * _Buffer , 
229:	FILE * _Stream 
230:	) ; 
233:	size_t __cdecl fread ( 
234:	void * _Buffer , 
235:	size_t _ElementSize , 
236:	size_t _ElementCount , 
237:	FILE * _Stream 
238:	) ; 
242:	FILE * __cdecl freopen ( 
243:	char const * _FileName , 
244:	char const * _Mode , 
245:	FILE * _Stream 
246:	) ; 
249:	FILE * __cdecl _fsopen ( 
250:	char const * _FileName , 
251:	char const * _Mode , 
252:	int _ShFlag 
253:	) ; 
257:	int __cdecl fsetpos ( 
258:	FILE * _Stream , 
259:	fpos_t const * _Position 
260:	) ; 
264:	int __cdecl fseek ( 
265:	FILE * _Stream , 
266:	long _Offset , 
267:	int _Origin 
268:	) ; 
272:	int __cdecl _fseeki64 ( 
273:	FILE * _Stream , 
274:	long long _Offset , 
275:	int _Origin 
276:	) ; 
280:	long __cdecl ftell ( 
281:	FILE * _Stream 
282:	) ; 
286:	long long __cdecl _ftelli64 ( 
287:	FILE * _Stream 
288:	) ; 
291:	size_t __cdecl fwrite ( 
292:	void const * _Buffer , 
293:	size_t _ElementSize , 
294:	size_t _ElementCount , 
295:	FILE * _Stream 
296:	) ; 
300:	int __cdecl getc ( 
301:	FILE * _Stream 
302:	) ; 
305:	int __cdecl getchar ( void ) ; 
308:	int __cdecl _getmaxstdio ( void ) ; 
315:	int __cdecl _getw ( 
316:	FILE * _Stream 
317:	) ; 
319:	void __cdecl perror ( 
320:	char const * _ErrorMessage 
321:	) ; 
327:	int __cdecl _pclose ( 
328:	FILE * _Stream 
329:	) ; 
332:	FILE * __cdecl _popen ( 
333:	char const * _Command , 
334:	char const * _Mode 
335:	) ; 
341:	int __cdecl putc ( 
342:	int _Character , 
343:	FILE * _Stream 
344:	) ; 
347:	int __cdecl putchar ( 
348:	int _Character 
349:	) ; 
352:	int __cdecl puts ( 
353:	char const * _Buffer 
354:	) ; 
358:	int __cdecl _putw ( 
359:	int _Word , 
360:	FILE * _Stream 
361:	) ; 
363:	int __cdecl remove ( 
364:	char const * _FileName 
365:	) ; 
368:	int __cdecl rename ( 
369:	char const * _OldFileName , 
370:	char const * _NewFileName 
371:	) ; 
373:	int __cdecl _unlink ( 
374:	char const * _FileName 
375:	) ; 
379:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details." ) ) 
380:	int __cdecl unlink ( 
381:	char const * _FileName 
382:	) ; 
386:	void __cdecl rewind ( 
387:	FILE * _Stream 
388:	) ; 
391:	int __cdecl _rmtmp ( void ) ; 
394:	void __cdecl setbuf ( 
395:	FILE * _Stream , 
396:	char * _Buffer 
397:	) ; 
400:	int __cdecl _setmaxstdio ( 
401:	int _Maximum 
402:	) ; 
406:	int __cdecl setvbuf ( 
407:	FILE * _Stream , 
408:	char * _Buffer , 
409:	int _Mode , 
410:	size_t _Size 
411:	) ; 
419:	char * __cdecl _tempnam ( 
420:	char const * _DirectoryName , 
421:	char const * _FilePrefix 
422:	) ; 
429:	FILE * __cdecl tmpfile ( void ) ; 
445:	int __cdecl ungetc ( 
446:	int _Character , 
447:	FILE * _Stream 
448:	) ; 
457:	void __cdecl _lock_file ( 
458:	FILE * _Stream 
459:	) ; 
461:	void __cdecl _unlock_file ( 
462:	FILE * _Stream 
463:	) ; 
467:	int __cdecl _fclose_nolock ( 
468:	FILE * _Stream 
469:	) ; 
473:	int __cdecl _fflush_nolock ( 
474:	FILE * _Stream 
475:	) ; 
479:	int __cdecl _fgetc_nolock ( 
480:	FILE * _Stream 
481:	) ; 
485:	int __cdecl _fputc_nolock ( 
486:	int _Character , 
487:	FILE * _Stream 
488:	) ; 
491:	size_t __cdecl _fread_nolock ( 
492:	void * _Buffer , 
493:	size_t _ElementSize , 
494:	size_t _ElementCount , 
495:	FILE * _Stream 
496:	) ; 
500:	size_t __cdecl _fread_nolock_s ( 
501:	void * _Buffer , 
502:	size_t _BufferSize , 
503:	size_t _ElementSize , 
504:	size_t _ElementCount , 
505:	FILE * _Stream 
506:	) ; 
509:	int __cdecl _fseek_nolock ( 
510:	FILE * _Stream , 
511:	long _Offset , 
512:	int _Origin 
513:	) ; 
516:	int __cdecl _fseeki64_nolock ( 
517:	FILE * _Stream , 
518:	long long _Offset , 
519:	int _Origin 
520:	) ; 
523:	long __cdecl _ftell_nolock ( 
524:	FILE * _Stream 
525:	) ; 
528:	long long __cdecl _ftelli64_nolock ( 
529:	FILE * _Stream 
530:	) ; 
533:	size_t __cdecl _fwrite_nolock ( 
534:	void const * _Buffer , 
535:	size_t _ElementSize , 
536:	size_t _ElementCount , 
537:	FILE * _Stream 
538:	) ; 
541:	int __cdecl _getc_nolock ( 
542:	FILE * _Stream 
543:	) ; 
546:	int __cdecl _putc_nolock ( 
547:	int _Character , 
548:	FILE * _Stream 
549:	) ; 
552:	int __cdecl _ungetc_nolock ( 
553:	int _Character , 
554:	FILE * _Stream 
555:	) ; 
583:	int * __cdecl __p__commode ( void ) ; 
603:	int __cdecl __stdio_common_vfprintf ( 
604:	unsigned long long _Options , 
605:	FILE * _Stream , 
606:	char const * _Format , 
607:	_locale_t _Locale , 
608:	va_list _ArgList 
609:	) ; 
611:	int __cdecl __stdio_common_vfprintf_s ( 
612:	unsigned long long _Options , 
613:	FILE * _Stream , 
614:	char const * _Format , 
615:	_locale_t _Locale , 
616:	va_list _ArgList 
617:	) ; 
620:	int __cdecl __stdio_common_vfprintf_p ( 
621:	unsigned long long _Options , 
622:	FILE * _Stream , 
623:	char const * _Format , 
624:	_locale_t _Locale , 
625:	va_list _ArgList 
626:	) ; 
629:	inline int __cdecl _vfprintf_l ( 
630:	FILE * const _Stream , 
631:	char const * const _Format , 
632:	_locale_t const _Locale , 
633:	va_list _ArgList 
634:	) 
638:	{ 
639:	return __stdio_common_vfprintf ( ( * __local_stdio_printf_options ( ) ) , _Stream , _Format , _Locale , _ArgList ) ; 
640:	} 
644:	inline int __cdecl vfprintf ( 
645:	FILE * const _Stream , 
646:	char const * const _Format , 
647:	va_list _ArgList 
648:	) 
652:	{ 
653:	return _vfprintf_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
654:	} 
658:	inline int __cdecl _vfprintf_s_l ( 
659:	FILE * const _Stream , 
660:	char const * const _Format , 
661:	_locale_t const _Locale , 
662:	va_list _ArgList 
663:	) 
667:	{ 
668:	return __stdio_common_vfprintf_s ( ( * __local_stdio_printf_options ( ) ) , _Stream , _Format , _Locale , _ArgList ) ; 
669:	} 
675:	inline int __cdecl vfprintf_s ( 
676:	FILE * const _Stream , 
677:	char const * const _Format , 
678:	va_list _ArgList 
679:	) 
683:	{ 
684:	return _vfprintf_s_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
685:	} 
691:	inline int __cdecl _vfprintf_p_l ( 
692:	FILE * const _Stream , 
693:	char const * const _Format , 
694:	_locale_t const _Locale , 
695:	va_list _ArgList 
696:	) 
700:	{ 
701:	return __stdio_common_vfprintf_p ( ( * __local_stdio_printf_options ( ) ) , _Stream , _Format , _Locale , _ArgList ) ; 
702:	} 
706:	inline int __cdecl _vfprintf_p ( 
707:	FILE * const _Stream , 
708:	char const * const _Format , 
709:	va_list _ArgList 
710:	) 
714:	{ 
715:	return _vfprintf_p_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
716:	} 
720:	inline int __cdecl _vprintf_l ( 
721:	char const * const _Format , 
722:	_locale_t const _Locale , 
723:	va_list _ArgList 
724:	) 
728:	{ 
729:	return _vfprintf_l ( ( __acrt_iob_func ( 1 ) ) , _Format , _Locale , _ArgList ) ; 
730:	} 
734:	inline int __cdecl vprintf ( 
735:	char const * const _Format , 
736:	va_list _ArgList 
737:	) 
741:	{ 
742:	return _vfprintf_l ( ( __acrt_iob_func ( 1 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
743:	} 
747:	inline int __cdecl _vprintf_s_l ( 
748:	char const * const _Format , 
749:	_locale_t const _Locale , 
750:	va_list _ArgList 
751:	) 
755:	{ 
756:	return _vfprintf_s_l ( ( __acrt_iob_func ( 1 ) ) , _Format , _Locale , _ArgList ) ; 
757:	} 
763:	inline int __cdecl vprintf_s ( 
764:	char const * const _Format , 
765:	va_list _ArgList 
766:	) 
770:	{ 
771:	return _vfprintf_s_l ( ( __acrt_iob_func ( 1 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
772:	} 
778:	inline int __cdecl _vprintf_p_l ( 
779:	char const * const _Format , 
780:	_locale_t const _Locale , 
781:	va_list _ArgList 
782:	) 
786:	{ 
787:	return _vfprintf_p_l ( ( __acrt_iob_func ( 1 ) ) , _Format , _Locale , _ArgList ) ; 
788:	} 
792:	inline int __cdecl _vprintf_p ( 
793:	char const * const _Format , 
794:	va_list _ArgList 
795:	) 
799:	{ 
800:	return _vfprintf_p_l ( ( __acrt_iob_func ( 1 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
801:	} 
805:	inline int __cdecl _fprintf_l ( 
806:	FILE * const _Stream , 
807:	char const * const _Format , 
808:	_locale_t const _Locale , 
809:	... ) 
813:	{ 
814:	int _Result ; 
815:	va_list _ArgList ; 
816:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
817:	_Result = _vfprintf_l ( _Stream , _Format , _Locale , _ArgList ) ; 
818:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
819:	return _Result ; 
820:	} 
824:	inline int __cdecl fprintf ( 
825:	FILE * const _Stream , 
826:	char const * const _Format , 
827:	... ) 
831:	{ 
832:	int _Result ; 
833:	va_list _ArgList ; 
834:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
835:	_Result = _vfprintf_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
836:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
837:	return _Result ; 
838:	} 
841:	int __cdecl _set_printf_count_output ( 
842:	int _Value 
843:	) ; 
845:	int __cdecl _get_printf_count_output ( void ) ; 
848:	inline int __cdecl _fprintf_s_l ( 
849:	FILE * const _Stream , 
850:	char const * const _Format , 
851:	_locale_t const _Locale , 
852:	... ) 
856:	{ 
857:	int _Result ; 
858:	va_list _ArgList ; 
859:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
860:	_Result = _vfprintf_s_l ( _Stream , _Format , _Locale , _ArgList ) ; 
861:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
862:	return _Result ; 
863:	} 
869:	inline int __cdecl fprintf_s ( 
870:	FILE * const _Stream , 
871:	char const * const _Format , 
872:	... ) 
876:	{ 
877:	int _Result ; 
878:	va_list _ArgList ; 
879:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
880:	_Result = _vfprintf_s_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
881:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
882:	return _Result ; 
883:	} 
889:	inline int __cdecl _fprintf_p_l ( 
890:	FILE * const _Stream , 
891:	char const * const _Format , 
892:	_locale_t const _Locale , 
893:	... ) 
897:	{ 
898:	int _Result ; 
899:	va_list _ArgList ; 
900:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
901:	_Result = _vfprintf_p_l ( _Stream , _Format , _Locale , _ArgList ) ; 
902:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
903:	return _Result ; 
904:	} 
908:	inline int __cdecl _fprintf_p ( 
909:	FILE * const _Stream , 
910:	char const * const _Format , 
911:	... ) 
915:	{ 
916:	int _Result ; 
917:	va_list _ArgList ; 
918:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
919:	_Result = _vfprintf_p_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
920:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
921:	return _Result ; 
922:	} 
926:	inline int __cdecl _printf_l ( 
927:	char const * const _Format , 
928:	_locale_t const _Locale , 
929:	... ) 
933:	{ 
934:	int _Result ; 
935:	va_list _ArgList ; 
936:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
937:	_Result = _vfprintf_l ( ( __acrt_iob_func ( 1 ) ) , _Format , _Locale , _ArgList ) ; 
938:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
939:	return _Result ; 
940:	} 
944:	inline int __cdecl printf ( 
945:	char const * const _Format , 
946:	... ) 
950:	{ 
951:	int _Result ; 
952:	va_list _ArgList ; 
953:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
954:	_Result = _vfprintf_l ( ( __acrt_iob_func ( 1 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
955:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
956:	return _Result ; 
957:	} 
961:	inline int __cdecl _printf_s_l ( 
962:	char const * const _Format , 
963:	_locale_t const _Locale , 
964:	... ) 
968:	{ 
969:	int _Result ; 
970:	va_list _ArgList ; 
971:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
972:	_Result = _vfprintf_s_l ( ( __acrt_iob_func ( 1 ) ) , _Format , _Locale , _ArgList ) ; 
973:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
974:	return _Result ; 
975:	} 
981:	inline int __cdecl printf_s ( 
982:	char const * const _Format , 
983:	... ) 
987:	{ 
988:	int _Result ; 
989:	va_list _ArgList ; 
990:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
991:	_Result = _vfprintf_s_l ( ( __acrt_iob_func ( 1 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
992:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
993:	return _Result ; 
994:	} 
1000:	inline int __cdecl _printf_p_l ( 
1001:	char const * const _Format , 
1002:	_locale_t const _Locale , 
1003:	... ) 
1007:	{ 
1008:	int _Result ; 
1009:	va_list _ArgList ; 
1010:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1011:	_Result = _vfprintf_p_l ( ( __acrt_iob_func ( 1 ) ) , _Format , _Locale , _ArgList ) ; 
1012:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1013:	return _Result ; 
1014:	} 
1018:	inline int __cdecl _printf_p ( 
1019:	char const * const _Format , 
1020:	... ) 
1024:	{ 
1025:	int _Result ; 
1026:	va_list _ArgList ; 
1027:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1028:	_Result = _vfprintf_p_l ( ( __acrt_iob_func ( 1 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1029:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1030:	return _Result ; 
1031:	} 
1040:	int __cdecl __stdio_common_vfscanf ( 
1041:	unsigned long long _Options , 
1042:	FILE * _Stream , 
1043:	char const * _Format , 
1044:	_locale_t _Locale , 
1045:	va_list _Arglist 
1046:	) ; 
1049:	inline int __cdecl _vfscanf_l ( 
1050:	FILE * const _Stream , 
1051:	char const * const _Format , 
1052:	_locale_t const _Locale , 
1053:	va_list _ArgList 
1054:	) 
1058:	{ 
1059:	return __stdio_common_vfscanf ( 
1060:	( * __local_stdio_scanf_options ( ) ) , 
1061:	_Stream , _Format , _Locale , _ArgList ) ; 
1062:	} 
1066:	inline int __cdecl vfscanf ( 
1067:	FILE * const _Stream , 
1068:	char const * const _Format , 
1069:	va_list _ArgList 
1070:	) 
1074:	{ 
1075:	return _vfscanf_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1076:	} 
1080:	inline int __cdecl _vfscanf_s_l ( 
1081:	FILE * const _Stream , 
1082:	char const * const _Format , 
1083:	_locale_t const _Locale , 
1084:	va_list _ArgList 
1085:	) 
1089:	{ 
1090:	return __stdio_common_vfscanf ( 
1091:	( * __local_stdio_scanf_options ( ) ) | ( 1 ULL << 0 ) , 
1092:	_Stream , _Format , _Locale , _ArgList ) ; 
1093:	} 
1100:	inline int __cdecl vfscanf_s ( 
1101:	FILE * const _Stream , 
1102:	char const * const _Format , 
1103:	va_list _ArgList 
1104:	) 
1108:	{ 
1109:	return _vfscanf_s_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1110:	} 
1116:	inline int __cdecl _vscanf_l ( 
1117:	char const * const _Format , 
1118:	_locale_t const _Locale , 
1119:	va_list _ArgList 
1120:	) 
1124:	{ 
1125:	return _vfscanf_l ( ( __acrt_iob_func ( 0 ) ) , _Format , _Locale , _ArgList ) ; 
1126:	} 
1130:	inline int __cdecl vscanf ( 
1131:	char const * const _Format , 
1132:	va_list _ArgList 
1133:	) 
1137:	{ 
1138:	return _vfscanf_l ( ( __acrt_iob_func ( 0 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1139:	} 
1143:	inline int __cdecl _vscanf_s_l ( 
1144:	char const * const _Format , 
1145:	_locale_t const _Locale , 
1146:	va_list _ArgList 
1147:	) 
1151:	{ 
1152:	return _vfscanf_s_l ( ( __acrt_iob_func ( 0 ) ) , _Format , _Locale , _ArgList ) ; 
1153:	} 
1159:	inline int __cdecl vscanf_s ( 
1160:	char const * const _Format , 
1161:	va_list _ArgList 
1162:	) 
1166:	{ 
1167:	return _vfscanf_s_l ( ( __acrt_iob_func ( 0 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1168:	} 
1174:	inline int __cdecl _fscanf_l ( 
1175:	FILE * const _Stream , 
1176:	char const * const _Format , 
1177:	_locale_t const _Locale , 
1178:	... ) 
1182:	{ 
1183:	int _Result ; 
1184:	va_list _ArgList ; 
1185:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1186:	_Result = _vfscanf_l ( _Stream , _Format , _Locale , _ArgList ) ; 
1187:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1188:	return _Result ; 
1189:	} 
1193:	inline int __cdecl fscanf ( 
1194:	FILE * const _Stream , 
1195:	char const * const _Format , 
1196:	... ) 
1200:	{ 
1201:	int _Result ; 
1202:	va_list _ArgList ; 
1203:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1204:	_Result = _vfscanf_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1205:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1206:	return _Result ; 
1207:	} 
1211:	inline int __cdecl _fscanf_s_l ( 
1212:	FILE * const _Stream , 
1213:	char const * const _Format , 
1214:	_locale_t const _Locale , 
1215:	... ) 
1219:	{ 
1220:	int _Result ; 
1221:	va_list _ArgList ; 
1222:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1223:	_Result = _vfscanf_s_l ( _Stream , _Format , _Locale , _ArgList ) ; 
1224:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1225:	return _Result ; 
1226:	} 
1232:	inline int __cdecl fscanf_s ( 
1233:	FILE * const _Stream , 
1234:	char const * const _Format , 
1235:	... ) 
1239:	{ 
1240:	int _Result ; 
1241:	va_list _ArgList ; 
1242:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1243:	_Result = _vfscanf_s_l ( _Stream , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1244:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1245:	return _Result ; 
1246:	} 
1252:	inline int __cdecl _scanf_l ( 
1253:	char const * const _Format , 
1254:	_locale_t const _Locale , 
1255:	... ) 
1259:	{ 
1260:	int _Result ; 
1261:	va_list _ArgList ; 
1262:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1263:	_Result = _vfscanf_l ( ( __acrt_iob_func ( 0 ) ) , _Format , _Locale , _ArgList ) ; 
1264:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1265:	return _Result ; 
1266:	} 
1270:	inline int __cdecl scanf ( 
1271:	char const * const _Format , 
1272:	... ) 
1276:	{ 
1277:	int _Result ; 
1278:	va_list _ArgList ; 
1279:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1280:	_Result = _vfscanf_l ( ( __acrt_iob_func ( 0 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1281:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1282:	return _Result ; 
1283:	} 
1287:	inline int __cdecl _scanf_s_l ( 
1288:	char const * const _Format , 
1289:	_locale_t const _Locale , 
1290:	... ) 
1294:	{ 
1295:	int _Result ; 
1296:	va_list _ArgList ; 
1297:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1298:	_Result = _vfscanf_s_l ( ( __acrt_iob_func ( 0 ) ) , _Format , _Locale , _ArgList ) ; 
1299:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1300:	return _Result ; 
1301:	} 
1307:	inline int __cdecl scanf_s ( 
1308:	char const * const _Format , 
1309:	... ) 
1313:	{ 
1314:	int _Result ; 
1315:	va_list _ArgList ; 
1316:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1317:	_Result = _vfscanf_s_l ( ( __acrt_iob_func ( 0 ) ) , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1318:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1319:	return _Result ; 
1320:	} 
1333:	int __cdecl __stdio_common_vsprintf ( 
1334:	unsigned long long _Options , 
1335:	char * _Buffer , 
1336:	size_t _BufferCount , 
1337:	char const * _Format , 
1338:	_locale_t _Locale , 
1339:	va_list _ArgList 
1340:	) ; 
1343:	int __cdecl __stdio_common_vsprintf_s ( 
1344:	unsigned long long _Options , 
1345:	char * _Buffer , 
1346:	size_t _BufferCount , 
1347:	char const * _Format , 
1348:	_locale_t _Locale , 
1349:	va_list _ArgList 
1350:	) ; 
1353:	int __cdecl __stdio_common_vsnprintf_s ( 
1354:	unsigned long long _Options , 
1355:	char * _Buffer , 
1356:	size_t _BufferCount , 
1357:	size_t _MaxCount , 
1358:	char const * _Format , 
1359:	_locale_t _Locale , 
1360:	va_list _ArgList 
1361:	) ; 
1364:	int __cdecl __stdio_common_vsprintf_p ( 
1365:	unsigned long long _Options , 
1366:	char * _Buffer , 
1367:	size_t _BufferCount , 
1368:	char const * _Format , 
1369:	_locale_t _Locale , 
1370:	va_list _ArgList 
1371:	) ; 
1375:	inline int __cdecl _vsnprintf_l ( 
1376:	char * const _Buffer , 
1377:	size_t const _BufferCount , 
1378:	char const * const _Format , 
1379:	_locale_t const _Locale , 
1380:	va_list _ArgList 
1381:	) 
1385:	{ 
1386:	int const _Result = __stdio_common_vsprintf ( 
1387:	( * __local_stdio_printf_options ( ) ) | ( 1 ULL << 0 ) , 
1388:	_Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1390:	return _Result < 0 ? - 1 : _Result ; 
1391:	} 
1396:	inline int __cdecl _vsnprintf ( 
1397:	char * const _Buffer , 
1398:	size_t const _BufferCount , 
1399:	char const * const _Format , 
1400:	va_list _ArgList 
1401:	) 
1405:	{ 
1406:	return _vsnprintf_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1407:	} 
1423:	inline int __cdecl vsnprintf ( 
1424:	char * const _Buffer , 
1425:	size_t const _BufferCount , 
1426:	char const * const _Format , 
1427:	va_list _ArgList 
1428:	) 
1432:	{ 
1433:	int const _Result = __stdio_common_vsprintf ( 
1434:	( * __local_stdio_printf_options ( ) ) | ( 1 ULL << 1 ) , 
1435:	_Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1437:	return _Result < 0 ? - 1 : _Result ; 
1438:	} 
1443:	inline int __cdecl _vsprintf_l ( 
1444:	char * const _Buffer , 
1445:	char const * const _Format , 
1446:	_locale_t const _Locale , 
1447:	va_list _ArgList 
1448:	) 
1452:	{ 
1453:	return _vsnprintf_l ( _Buffer , ( size_t ) - 1 , _Format , _Locale , _ArgList ) ; 
1454:	} 
1459:	inline int __cdecl vsprintf ( 
1460:	char * const _Buffer , 
1461:	char const * const _Format , 
1462:	va_list _ArgList 
1463:	) 
1467:	{ 
1468:	return _vsnprintf_l ( _Buffer , ( size_t ) - 1 , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1469:	} 
1474:	inline int __cdecl _vsprintf_s_l ( 
1475:	char * const _Buffer , 
1476:	size_t const _BufferCount , 
1477:	char const * const _Format , 
1478:	_locale_t const _Locale , 
1479:	va_list _ArgList 
1480:	) 
1484:	{ 
1485:	int const _Result = __stdio_common_vsprintf_s ( 
1486:	( * __local_stdio_printf_options ( ) ) , 
1487:	_Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1489:	return _Result < 0 ? - 1 : _Result ; 
1490:	} 
1497:	inline int __cdecl vsprintf_s ( 
1498:	char * const _Buffer , 
1499:	size_t const _BufferCount , 
1500:	char const * const _Format , 
1501:	va_list _ArgList 
1502:	) 
1506:	{ 
1507:	return _vsprintf_s_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1508:	} 
1523:	inline int __cdecl _vsprintf_p_l ( 
1524:	char * const _Buffer , 
1525:	size_t const _BufferCount , 
1526:	char const * const _Format , 
1527:	_locale_t const _Locale , 
1528:	va_list _ArgList 
1529:	) 
1533:	{ 
1534:	int const _Result = __stdio_common_vsprintf_p ( 
1535:	( * __local_stdio_printf_options ( ) ) , 
1536:	_Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1538:	return _Result < 0 ? - 1 : _Result ; 
1539:	} 
1544:	inline int __cdecl _vsprintf_p ( 
1545:	char * const _Buffer , 
1546:	size_t const _BufferCount , 
1547:	char const * const _Format , 
1548:	va_list _ArgList 
1549:	) 
1553:	{ 
1554:	return _vsprintf_p_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1555:	} 
1560:	inline int __cdecl _vsnprintf_s_l ( 
1561:	char * const _Buffer , 
1562:	size_t const _BufferCount , 
1563:	size_t const _MaxCount , 
1564:	char const * const _Format , 
1565:	_locale_t const _Locale , 
1566:	va_list _ArgList 
1567:	) 
1571:	{ 
1572:	int const _Result = __stdio_common_vsnprintf_s ( 
1573:	( * __local_stdio_printf_options ( ) ) , 
1574:	_Buffer , _BufferCount , _MaxCount , _Format , _Locale , _ArgList ) ; 
1576:	return _Result < 0 ? - 1 : _Result ; 
1577:	} 
1582:	inline int __cdecl _vsnprintf_s ( 
1583:	char * const _Buffer , 
1584:	size_t const _BufferCount , 
1585:	size_t const _MaxCount , 
1586:	char const * const _Format , 
1587:	va_list _ArgList 
1588:	) 
1592:	{ 
1593:	return _vsnprintf_s_l ( _Buffer , _BufferCount , _MaxCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1594:	} 
1610:	inline int __cdecl vsnprintf_s ( 
1611:	char * const _Buffer , 
1612:	size_t const _BufferCount , 
1613:	size_t const _MaxCount , 
1614:	char const * const _Format , 
1615:	va_list _ArgList 
1616:	) 
1620:	{ 
1621:	return _vsnprintf_s_l ( _Buffer , _BufferCount , _MaxCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1622:	} 
1637:	inline int __cdecl _vscprintf_l ( 
1638:	char const * const _Format , 
1639:	_locale_t const _Locale , 
1640:	va_list _ArgList 
1641:	) 
1645:	{ 
1646:	int const _Result = __stdio_common_vsprintf ( 
1647:	( * __local_stdio_printf_options ( ) ) | ( 1 ULL << 1 ) , 
1648:	( ( void * ) 0 ) , 0 , _Format , _Locale , _ArgList ) ; 
1650:	return _Result < 0 ? - 1 : _Result ; 
1651:	} 
1655:	inline int __cdecl _vscprintf ( 
1656:	char const * const _Format , 
1657:	va_list _ArgList 
1658:	) 
1662:	{ 
1663:	return _vscprintf_l ( _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1664:	} 
1668:	inline int __cdecl _vscprintf_p_l ( 
1669:	char const * const _Format , 
1670:	_locale_t const _Locale , 
1671:	va_list _ArgList 
1672:	) 
1676:	{ 
1677:	int const _Result = __stdio_common_vsprintf_p ( 
1678:	( * __local_stdio_printf_options ( ) ) | ( 1 ULL << 1 ) , 
1679:	( ( void * ) 0 ) , 0 , _Format , _Locale , _ArgList ) ; 
1681:	return _Result < 0 ? - 1 : _Result ; 
1682:	} 
1686:	inline int __cdecl _vscprintf_p ( 
1687:	char const * const _Format , 
1688:	va_list _ArgList 
1689:	) 
1693:	{ 
1694:	return _vscprintf_p_l ( _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1695:	} 
1699:	inline int __cdecl _vsnprintf_c_l ( 
1700:	char * const _Buffer , 
1701:	size_t const _BufferCount , 
1702:	char const * const _Format , 
1703:	_locale_t const _Locale , 
1704:	va_list _ArgList 
1705:	) 
1709:	{ 
1710:	int const _Result = __stdio_common_vsprintf ( 
1711:	( * __local_stdio_printf_options ( ) ) , 
1712:	_Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1714:	return _Result < 0 ? - 1 : _Result ; 
1715:	} 
1720:	inline int __cdecl _vsnprintf_c ( 
1721:	char * const _Buffer , 
1722:	size_t const _BufferCount , 
1723:	char const * const _Format , 
1724:	va_list _ArgList 
1725:	) 
1729:	{ 
1730:	return _vsnprintf_c_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1731:	} 
1736:	inline int __cdecl _sprintf_l ( 
1737:	char * const _Buffer , 
1738:	char const * const _Format , 
1739:	_locale_t const _Locale , 
1740:	... ) 
1744:	{ 
1745:	int _Result ; 
1746:	va_list _ArgList ; 
1747:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1749:	_Result = _vsprintf_l ( _Buffer , _Format , _Locale , _ArgList ) ; 
1751:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1752:	return _Result ; 
1753:	} 
1758:	inline int __cdecl sprintf ( 
1759:	char * const _Buffer , 
1760:	char const * const _Format , 
1761:	... ) 
1765:	{ 
1766:	int _Result ; 
1767:	va_list _ArgList ; 
1768:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1770:	_Result = _vsprintf_l ( _Buffer , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1772:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1773:	return _Result ; 
1774:	} 
1786:	inline int __cdecl _sprintf_s_l ( 
1787:	char * const _Buffer , 
1788:	size_t const _BufferCount , 
1789:	char const * const _Format , 
1790:	_locale_t const _Locale , 
1791:	... ) 
1795:	{ 
1796:	int _Result ; 
1797:	va_list _ArgList ; 
1798:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1799:	_Result = _vsprintf_s_l ( _Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1800:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1801:	return _Result ; 
1802:	} 
1809:	inline int __cdecl sprintf_s ( 
1810:	char * const _Buffer , 
1811:	size_t const _BufferCount , 
1812:	char const * const _Format , 
1813:	... ) 
1817:	{ 
1818:	int _Result ; 
1819:	va_list _ArgList ; 
1820:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1821:	_Result = _vsprintf_s_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1822:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1823:	return _Result ; 
1824:	} 
1838:	inline int __cdecl _sprintf_p_l ( 
1839:	char * const _Buffer , 
1840:	size_t const _BufferCount , 
1841:	char const * const _Format , 
1842:	_locale_t const _Locale , 
1843:	... ) 
1847:	{ 
1848:	int _Result ; 
1849:	va_list _ArgList ; 
1850:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1851:	_Result = _vsprintf_p_l ( _Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1852:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1853:	return _Result ; 
1854:	} 
1859:	inline int __cdecl _sprintf_p ( 
1860:	char * const _Buffer , 
1861:	size_t const _BufferCount , 
1862:	char const * const _Format , 
1863:	... ) 
1867:	{ 
1868:	int _Result ; 
1869:	va_list _ArgList ; 
1870:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1871:	_Result = _vsprintf_p_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1872:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1873:	return _Result ; 
1874:	} 
1879:	inline int __cdecl _snprintf_l ( 
1880:	char * const _Buffer , 
1881:	size_t const _BufferCount , 
1882:	char const * const _Format , 
1883:	_locale_t const _Locale , 
1884:	... ) 
1888:	{ 
1889:	int _Result ; 
1890:	va_list _ArgList ; 
1891:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1893:	_Result = _vsnprintf_l ( _Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1895:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1896:	return _Result ; 
1897:	} 
1913:	inline int __cdecl snprintf ( 
1914:	char * const _Buffer , 
1915:	size_t const _BufferCount , 
1916:	char const * const _Format , 
1917:	... ) 
1921:	{ 
1922:	int _Result ; 
1923:	va_list _ArgList ; 
1924:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1925:	_Result = vsnprintf ( _Buffer , _BufferCount , _Format , _ArgList ) ; 
1926:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1927:	return _Result ; 
1928:	} 
1933:	inline int __cdecl _snprintf ( 
1934:	char * const _Buffer , 
1935:	size_t const _BufferCount , 
1936:	char const * const _Format , 
1937:	... ) 
1941:	{ 
1942:	int _Result ; 
1943:	va_list _ArgList ; 
1944:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1945:	_Result = _vsnprintf ( _Buffer , _BufferCount , _Format , _ArgList ) ; 
1946:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1947:	return _Result ; 
1948:	} 
1962:	inline int __cdecl _snprintf_c_l ( 
1963:	char * const _Buffer , 
1964:	size_t const _BufferCount , 
1965:	char const * const _Format , 
1966:	_locale_t const _Locale , 
1967:	... ) 
1971:	{ 
1972:	int _Result ; 
1973:	va_list _ArgList ; 
1974:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
1975:	_Result = _vsnprintf_c_l ( _Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
1976:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1977:	return _Result ; 
1978:	} 
1983:	inline int __cdecl _snprintf_c ( 
1984:	char * const _Buffer , 
1985:	size_t const _BufferCount , 
1986:	char const * const _Format , 
1987:	... ) 
1991:	{ 
1992:	int _Result ; 
1993:	va_list _ArgList ; 
1994:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
1995:	_Result = _vsnprintf_c_l ( _Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
1996:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
1997:	return _Result ; 
1998:	} 
2003:	inline int __cdecl _snprintf_s_l ( 
2004:	char * const _Buffer , 
2005:	size_t const _BufferCount , 
2006:	size_t const _MaxCount , 
2007:	char const * const _Format , 
2008:	_locale_t const _Locale , 
2009:	... ) 
2013:	{ 
2014:	int _Result ; 
2015:	va_list _ArgList ; 
2016:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
2017:	_Result = _vsnprintf_s_l ( _Buffer , _BufferCount , _MaxCount , _Format , _Locale , _ArgList ) ; 
2018:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2019:	return _Result ; 
2020:	} 
2025:	inline int __cdecl _snprintf_s ( 
2026:	char * const _Buffer , 
2027:	size_t const _BufferCount , 
2028:	size_t const _MaxCount , 
2029:	char const * const _Format , 
2030:	... ) 
2034:	{ 
2035:	int _Result ; 
2036:	va_list _ArgList ; 
2037:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
2038:	_Result = _vsnprintf_s_l ( _Buffer , _BufferCount , _MaxCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
2039:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2040:	return _Result ; 
2041:	} 
2053:	inline int __cdecl _scprintf_l ( 
2054:	char const * const _Format , 
2055:	_locale_t const _Locale , 
2056:	... ) 
2060:	{ 
2061:	int _Result ; 
2062:	va_list _ArgList ; 
2063:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
2064:	_Result = _vscprintf_l ( _Format , _Locale , _ArgList ) ; 
2065:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2066:	return _Result ; 
2067:	} 
2071:	inline int __cdecl _scprintf ( 
2072:	char const * const _Format , 
2073:	... ) 
2077:	{ 
2078:	int _Result ; 
2079:	va_list _ArgList ; 
2080:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
2081:	_Result = _vscprintf_l ( _Format , ( ( void * ) 0 ) , _ArgList ) ; 
2082:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2083:	return _Result ; 
2084:	} 
2088:	inline int __cdecl _scprintf_p_l ( 
2089:	char const * const _Format , 
2090:	_locale_t const _Locale , 
2091:	... ) 
2095:	{ 
2096:	int _Result ; 
2097:	va_list _ArgList ; 
2098:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
2099:	_Result = _vscprintf_p_l ( _Format , _Locale , _ArgList ) ; 
2100:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2101:	return _Result ; 
2102:	} 
2106:	inline int __cdecl _scprintf_p ( 
2107:	char const * const _Format , 
2108:	... ) 
2112:	{ 
2113:	int _Result ; 
2114:	va_list _ArgList ; 
2115:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
2116:	_Result = _vscprintf_p ( _Format , _ArgList ) ; 
2117:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2118:	return _Result ; 
2119:	} 
2127:	int __cdecl __stdio_common_vsscanf ( 
2128:	unsigned long long _Options , 
2129:	char const * _Buffer , 
2130:	size_t _BufferCount , 
2131:	char const * _Format , 
2132:	_locale_t _Locale , 
2133:	va_list _ArgList 
2134:	) ; 
2137:	inline int __cdecl _vsscanf_l ( 
2138:	char const * const _Buffer , 
2139:	char const * const _Format , 
2140:	_locale_t const _Locale , 
2141:	va_list _ArgList 
2142:	) 
2146:	{ 
2147:	return __stdio_common_vsscanf ( 
2148:	( * __local_stdio_scanf_options ( ) ) , 
2149:	_Buffer , ( size_t ) - 1 , _Format , _Locale , _ArgList ) ; 
2150:	} 
2154:	inline int __cdecl vsscanf ( 
2155:	char const * const _Buffer , 
2156:	char const * const _Format , 
2157:	va_list _ArgList 
2158:	) 
2162:	{ 
2163:	return _vsscanf_l ( _Buffer , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
2164:	} 
2168:	inline int __cdecl _vsscanf_s_l ( 
2169:	char const * const _Buffer , 
2170:	char const * const _Format , 
2171:	_locale_t const _Locale , 
2172:	va_list _ArgList 
2173:	) 
2177:	{ 
2178:	return __stdio_common_vsscanf ( 
2179:	( * __local_stdio_scanf_options ( ) ) | ( 1 ULL << 0 ) , 
2180:	_Buffer , ( size_t ) - 1 , _Format , _Locale , _ArgList ) ; 
2181:	} 
2190:	inline int __cdecl vsscanf_s ( 
2191:	char const * const _Buffer , 
2192:	char const * const _Format , 
2193:	va_list _ArgList 
2194:	) 
2198:	{ 
2199:	return _vsscanf_s_l ( _Buffer , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
2200:	} 
2215:	inline int __cdecl _sscanf_l ( 
2216:	char const * const _Buffer , 
2217:	char const * const _Format , 
2218:	_locale_t const _Locale , 
2219:	... ) 
2223:	{ 
2224:	int _Result ; 
2225:	va_list _ArgList ; 
2226:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
2227:	_Result = _vsscanf_l ( _Buffer , _Format , _Locale , _ArgList ) ; 
2228:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2229:	return _Result ; 
2230:	} 
2234:	inline int __cdecl sscanf ( 
2235:	char const * const _Buffer , 
2236:	char const * const _Format , 
2237:	... ) 
2241:	{ 
2242:	int _Result ; 
2243:	va_list _ArgList ; 
2244:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
2245:	_Result = _vsscanf_l ( _Buffer , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
2246:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2247:	return _Result ; 
2248:	} 
2252:	inline int __cdecl _sscanf_s_l ( 
2253:	char const * const _Buffer , 
2254:	char const * const _Format , 
2255:	_locale_t const _Locale , 
2256:	... ) 
2260:	{ 
2261:	int _Result ; 
2262:	va_list _ArgList ; 
2263:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
2264:	_Result = _vsscanf_s_l ( _Buffer , _Format , _Locale , _ArgList ) ; 
2265:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2266:	return _Result ; 
2267:	} 
2273:	inline int __cdecl sscanf_s ( 
2274:	char const * const _Buffer , 
2275:	char const * const _Format , 
2276:	... ) 
2280:	{ 
2281:	int _Result ; 
2282:	va_list _ArgList ; 
2283:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
2285:	_Result = vsscanf_s ( _Buffer , _Format , _ArgList ) ; 
2287:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2288:	return _Result ; 
2289:	} 
2298:	inline int __cdecl _snscanf_l ( 
2299:	char const * const _Buffer , 
2300:	size_t const _BufferCount , 
2301:	char const * const _Format , 
2302:	_locale_t const _Locale , 
2303:	... ) 
2307:	{ 
2308:	int _Result ; 
2309:	va_list _ArgList ; 
2310:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
2312:	_Result = __stdio_common_vsscanf ( 
2313:	( * __local_stdio_scanf_options ( ) ) , 
2314:	_Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
2316:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2317:	return _Result ; 
2318:	} 
2322:	inline int __cdecl _snscanf ( 
2323:	char const * const _Buffer , 
2324:	size_t const _BufferCount , 
2325:	char const * const _Format , 
2326:	... ) 
2330:	{ 
2331:	int _Result ; 
2332:	va_list _ArgList ; 
2333:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
2335:	_Result = __stdio_common_vsscanf ( 
2336:	( * __local_stdio_scanf_options ( ) ) , 
2337:	_Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
2339:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2340:	return _Result ; 
2341:	} 
2346:	inline int __cdecl _snscanf_s_l ( 
2347:	char const * const _Buffer , 
2348:	size_t const _BufferCount , 
2349:	char const * const _Format , 
2350:	_locale_t const _Locale , 
2351:	... ) 
2355:	{ 
2356:	int _Result ; 
2357:	va_list _ArgList ; 
2358:	( ( void ) ( __va_start ( & _ArgList , _Locale ) ) ) ; 
2360:	_Result = __stdio_common_vsscanf ( 
2361:	( * __local_stdio_scanf_options ( ) ) | ( 1 ULL << 0 ) , 
2362:	_Buffer , _BufferCount , _Format , _Locale , _ArgList ) ; 
2364:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2365:	return _Result ; 
2366:	} 
2370:	inline int __cdecl _snscanf_s ( 
2371:	char const * const _Buffer , 
2372:	size_t const _BufferCount , 
2373:	char const * const _Format , 
2374:	... ) 
2378:	{ 
2379:	int _Result ; 
2380:	va_list _ArgList ; 
2381:	( ( void ) ( __va_start ( & _ArgList , _Format ) ) ) ; 
2383:	_Result = __stdio_common_vsscanf ( 
2384:	( * __local_stdio_scanf_options ( ) ) | ( 1 ULL << 0 ) , 
2385:	_Buffer , _BufferCount , _Format , ( ( void * ) 0 ) , _ArgList ) ; 
2387:	( ( void ) ( _ArgList = ( va_list ) 0 ) ) ; 
2388:	return _Result ; 
2389:	} 
2414:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details." ) ) 
2415:	char * __cdecl tempnam ( 
2416:	char const * _Directory , 
2417:	char const * _FilePrefix 
2418:	) ; 
2424:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details." ) ) int __cdecl fcloseall ( void ) ; 
2425:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details." ) ) FILE * __cdecl fdopen ( int _FileHandle , char const * _Format ) ; 
2426:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details." ) ) int __cdecl fgetchar ( void ) ; 
2427:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details." ) ) int __cdecl fileno ( FILE * _Stream ) ; 
2428:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details." ) ) int __cdecl flushall ( void ) ; 
2429:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details." ) ) int __cdecl fputchar ( int _Ch ) ; 
2430:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details." ) ) int __cdecl getw ( FILE * _Stream ) ; 
2431:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details." ) ) int __cdecl putw ( int _Ch , FILE * _Stream ) ; 
2432:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details." ) ) int __cdecl rmtmp ( void ) ; 
2439:	_Pragma ( pack ( pop ) ) 
227:	enum 
228:	{ 
229:	STBI_default = 0 , 
231:	STBI_grey = 1 , 
232:	STBI_grey_alpha = 2 , 
233:	STBI_rgb = 3 , 
234:	STBI_rgb_alpha = 4 
235:	} ; 
 17:	_Pragma ( pack ( push , 8 ) ) 
 58:	__declspec ( restrict ) 
 59:	void * __cdecl _calloc_base ( 
 60:	size_t _Count , 
 61:	size_t _Size 
 62:	) ; 
 65:	__declspec ( restrict ) 
 66:	void * __cdecl calloc ( 
 67:	size_t _Count , 
 68:	size_t _Size 
 69:	) ; 
 72:	int __cdecl _callnewh ( 
 73:	size_t _Size 
 74:	) ; 
 78:	void * __cdecl _expand ( 
 79:	void * _Block , 
 80:	size_t _Size 
 81:	) ; 
 84:	void __cdecl _free_base ( 
 85:	void * _Block 
 86:	) ; 
 89:	void __cdecl free ( 
 90:	void * _Block 
 91:	) ; 
 94:	__declspec ( restrict ) 
 95:	void * __cdecl _malloc_base ( 
 96:	size_t _Size 
 97:	) ; 
100:	__declspec ( restrict ) 
101:	void * __cdecl malloc ( 
102:	size_t _Size 
103:	) ; 
107:	size_t __cdecl _msize_base ( 
108:	void * _Block 
109:	) ; 
113:	size_t __cdecl _msize ( 
114:	void * _Block 
115:	) ; 
118:	__declspec ( restrict ) 
119:	void * __cdecl _realloc_base ( 
120:	void * _Block , 
121:	size_t _Size 
122:	) ; 
125:	__declspec ( restrict ) 
126:	void * __cdecl realloc ( 
127:	void * _Block , 
128:	size_t _Size 
129:	) ; 
132:	__declspec ( restrict ) 
133:	void * __cdecl _recalloc_base ( 
134:	void * _Block , 
135:	size_t _Count , 
136:	size_t _Size 
137:	) ; 
140:	__declspec ( restrict ) 
141:	void * __cdecl _recalloc ( 
142:	void * _Block , 
143:	size_t _Count , 
144:	size_t _Size 
145:	) ; 
148:	void __cdecl _aligned_free ( 
149:	void * _Block 
150:	) ; 
153:	__declspec ( restrict ) 
154:	void * __cdecl _aligned_malloc ( 
155:	size_t _Size , 
156:	size_t _Alignment 
157:	) ; 
160:	__declspec ( restrict ) 
161:	void * __cdecl _aligned_offset_malloc ( 
162:	size_t _Size , 
163:	size_t _Alignment , 
164:	size_t _Offset 
165:	) ; 
169:	size_t __cdecl _aligned_msize ( 
170:	void * _Block , 
171:	size_t _Alignment , 
172:	size_t _Offset 
173:	) ; 
176:	__declspec ( restrict ) 
177:	void * __cdecl _aligned_offset_realloc ( 
178:	void * _Block , 
179:	size_t _Size , 
180:	size_t _Alignment , 
181:	size_t _Offset 
182:	) ; 
185:	__declspec ( restrict ) 
186:	void * __cdecl _aligned_offset_recalloc ( 
187:	void * _Block , 
188:	size_t _Count , 
189:	size_t _Size , 
190:	size_t _Alignment , 
191:	size_t _Offset 
192:	) ; 
195:	__declspec ( restrict ) 
196:	void * __cdecl _aligned_realloc ( 
197:	void * _Block , 
198:	size_t _Size , 
199:	size_t _Alignment 
200:	) ; 
203:	__declspec ( restrict ) 
204:	void * __cdecl _aligned_recalloc ( 
205:	void * _Block , 
206:	size_t _Count , 
207:	size_t _Size , 
208:	size_t _Alignment 
209:	) ; 
232:	_Pragma ( pack ( pop ) ) 
 18:	_Pragma ( pack ( push , 8 ) ) 
 35:	int * __cdecl _errno ( void ) ; 
 38:	errno_t __cdecl _set_errno ( int _Value ) ; 
 39:	errno_t __cdecl _get_errno ( int * _Value ) ; 
 55:	extern unsigned long __cdecl __threadid ( void ) ; 
 57:	extern uintptr_t __cdecl __threadhandle ( void ) ; 
 61:	_Pragma ( pack ( pop ) ) 
 20:	_Pragma ( pack ( push , 8 ) ) 
 23:	typedef int ( __cdecl * _CoreCrtSecureSearchSortCompareFunction ) ( void * , void const * , void const * ) ; 
 24:	typedef int ( __cdecl * _CoreCrtNonSecureSearchSortCompareFunction ) ( void const * , void const * ) ; 
 30:	void * __cdecl bsearch_s ( 
 31:	void const * _Key , 
 32:	void const * _Base , 
 33:	rsize_t _NumOfElements , 
 34:	rsize_t _SizeOfElements , 
 35:	_CoreCrtSecureSearchSortCompareFunction _CompareFunction , 
 36:	void * _Context 
 37:	) ; 
 39:	void __cdecl qsort_s ( 
 40:	void * _Base , 
 41:	rsize_t _NumOfElements , 
 42:	rsize_t _SizeOfElements , 
 43:	_CoreCrtSecureSearchSortCompareFunction _CompareFunction , 
 44:	void * _Context 
 45:	) ; 
 52:	void * __cdecl bsearch ( 
 53:	void const * _Key , 
 54:	void const * _Base , 
 55:	size_t _NumOfElements , 
 56:	size_t _SizeOfElements , 
 57:	_CoreCrtNonSecureSearchSortCompareFunction _CompareFunction 
 58:	) ; 
 60:	void __cdecl qsort ( 
 61:	void * _Base , 
 62:	size_t _NumOfElements , 
 63:	size_t _SizeOfElements , 
 64:	_CoreCrtNonSecureSearchSortCompareFunction _CompareFunction 
 65:	) ; 
 68:	void * __cdecl _lfind_s ( 
 69:	void const * _Key , 
 70:	void const * _Base , 
 71:	unsigned int * _NumOfElements , 
 72:	size_t _SizeOfElements , 
 73:	_CoreCrtSecureSearchSortCompareFunction _CompareFunction , 
 74:	void * _Context 
 75:	) ; 
 78:	void * __cdecl _lfind ( 
 79:	void const * _Key , 
 80:	void const * _Base , 
 81:	unsigned int * _NumOfElements , 
 82:	unsigned int _SizeOfElements , 
 83:	_CoreCrtNonSecureSearchSortCompareFunction _CompareFunction 
 84:	) ; 
 87:	void * __cdecl _lsearch_s ( 
 88:	void const * _Key , 
 89:	void * _Base , 
 90:	unsigned int * _NumOfElements , 
 91:	size_t _SizeOfElements , 
 92:	_CoreCrtSecureSearchSortCompareFunction _CompareFunction , 
 93:	void * _Context 
 94:	) ; 
 97:	void * __cdecl _lsearch ( 
 98:	void const * _Key , 
 99:	void * _Base , 
100:	unsigned int * _NumOfElements , 
101:	unsigned int _SizeOfElements , 
102:	_CoreCrtNonSecureSearchSortCompareFunction _CompareFunction 
103:	) ; 
194:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details." ) ) 
195:	void * __cdecl lfind ( 
196:	void const * _Key , 
197:	void const * _Base , 
198:	unsigned int * _NumOfElements , 
199:	unsigned int _SizeOfElements , 
200:	_CoreCrtNonSecureSearchSortCompareFunction _CompareFunction 
201:	) ; 
203:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details." ) ) 
204:	void * __cdecl lsearch ( 
205:	void const * _Key , 
206:	void * _Base , 
207:	unsigned int * _NumOfElements , 
208:	unsigned int _SizeOfElements , 
209:	_CoreCrtNonSecureSearchSortCompareFunction _CompareFunction 
210:	) ; 
216:	_Pragma ( pack ( pop ) ) 
 17:	_Pragma ( pack ( push , 8 ) ) 
 54:	errno_t __cdecl _itow_s ( 
 55:	int _Value , 
 56:	wchar_t * _Buffer , 
 57:	size_t _BufferCount , 
 58:	int _Radix 
 59:	) ; 
 68:	wchar_t * __cdecl _itow ( int _Value , wchar_t * _Buffer , int _Radix 
 77:	errno_t __cdecl _ltow_s ( 
 78:	long _Value , 
 79:	wchar_t * _Buffer , 
 80:	size_t _BufferCount , 
 81:	int _Radix 
 82:	) ; 
 91:	wchar_t * __cdecl _ltow ( long _Value , wchar_t * _Buffer , int _Radix 
 99:	errno_t __cdecl _ultow_s ( 
100:	unsigned long _Value , 
101:	wchar_t * _Buffer , 
102:	size_t _BufferCount , 
103:	int _Radix 
104:	) ; 
113:	wchar_t * __cdecl _ultow ( unsigned long _Value , wchar_t * _Buffer , int _Radix 
121:	double __cdecl wcstod ( 
122:	wchar_t const * _String , 
123:	wchar_t * * _EndPtr 
124:	) ; 
127:	double __cdecl _wcstod_l ( 
128:	wchar_t const * _String , 
129:	wchar_t * * _EndPtr , 
130:	_locale_t _Locale 
131:	) ; 
134:	long __cdecl wcstol ( 
135:	wchar_t const * _String , 
136:	wchar_t * * _EndPtr , 
137:	int _Radix 
138:	) ; 
141:	long __cdecl _wcstol_l ( 
142:	wchar_t const * _String , 
143:	wchar_t * * _EndPtr , 
144:	int _Radix , 
145:	_locale_t _Locale 
146:	) ; 
149:	long long __cdecl wcstoll ( 
150:	wchar_t const * _String , 
151:	wchar_t * * _EndPtr , 
152:	int _Radix 
153:	) ; 
156:	long long __cdecl _wcstoll_l ( 
157:	wchar_t const * _String , 
158:	wchar_t * * _EndPtr , 
159:	int _Radix , 
160:	_locale_t _Locale 
161:	) ; 
164:	unsigned long __cdecl wcstoul ( 
165:	wchar_t const * _String , 
166:	wchar_t * * _EndPtr , 
167:	int _Radix 
168:	) ; 
171:	unsigned long __cdecl _wcstoul_l ( 
172:	wchar_t const * _String , 
173:	wchar_t * * _EndPtr , 
174:	int _Radix , 
175:	_locale_t _Locale 
176:	) ; 
179:	unsigned long long __cdecl wcstoull ( 
180:	wchar_t const * _String , 
181:	wchar_t * * _EndPtr , 
182:	int _Radix 
183:	) ; 
186:	unsigned long long __cdecl _wcstoull_l ( 
187:	wchar_t const * _String , 
188:	wchar_t * * _EndPtr , 
189:	int _Radix , 
190:	_locale_t _Locale 
191:	) ; 
194:	long double __cdecl wcstold ( 
195:	wchar_t const * _String , 
196:	wchar_t * * _EndPtr 
197:	) ; 
200:	long double __cdecl _wcstold_l ( 
201:	wchar_t const * _String , 
202:	wchar_t * * _EndPtr , 
203:	_locale_t _Locale 
204:	) ; 
207:	float __cdecl wcstof ( 
208:	wchar_t const * _String , 
209:	wchar_t * * _EndPtr 
210:	) ; 
213:	float __cdecl _wcstof_l ( 
214:	wchar_t const * _String , 
215:	wchar_t * * _EndPtr , 
216:	_locale_t _Locale 
217:	) ; 
220:	double __cdecl _wtof ( 
221:	wchar_t const * _String 
222:	) ; 
225:	double __cdecl _wtof_l ( 
226:	wchar_t const * _String , 
227:	_locale_t _Locale 
228:	) ; 
231:	int __cdecl _wtoi ( 
232:	wchar_t const * _String 
233:	) ; 
236:	int __cdecl _wtoi_l ( 
237:	wchar_t const * _String , 
238:	_locale_t _Locale 
239:	) ; 
242:	long __cdecl _wtol ( 
243:	wchar_t const * _String 
244:	) ; 
247:	long __cdecl _wtol_l ( 
248:	wchar_t const * _String , 
249:	_locale_t _Locale 
250:	) ; 
253:	long long __cdecl _wtoll ( 
254:	wchar_t const * _String 
255:	) ; 
258:	long long __cdecl _wtoll_l ( 
259:	wchar_t const * _String , 
260:	_locale_t _Locale 
261:	) ; 
264:	errno_t __cdecl _i64tow_s ( 
265:	long long _Value , 
266:	wchar_t * _Buffer , 
267:	size_t _BufferCount , 
268:	int _Radix 
269:	) ; 
272:	wchar_t * __cdecl _i64tow ( 
273:	long long _Value , 
274:	wchar_t * _Buffer , 
275:	int _Radix 
276:	) ; 
279:	errno_t __cdecl _ui64tow_s ( 
280:	unsigned long long _Value , 
281:	wchar_t * _Buffer , 
282:	size_t _BufferCount , 
283:	int _Radix 
284:	) ; 
287:	wchar_t * __cdecl _ui64tow ( 
288:	unsigned long long _Value , 
289:	wchar_t * _Buffer , 
290:	int _Radix 
291:	) ; 
294:	long long __cdecl _wtoi64 ( 
295:	wchar_t const * _String 
296:	) ; 
299:	long long __cdecl _wtoi64_l ( 
300:	wchar_t const * _String , 
301:	_locale_t _Locale 
302:	) ; 
305:	long long __cdecl _wcstoi64 ( 
306:	wchar_t const * _String , 
307:	wchar_t * * _EndPtr , 
308:	int _Radix 
309:	) ; 
312:	long long __cdecl _wcstoi64_l ( 
313:	wchar_t const * _String , 
314:	wchar_t * * _EndPtr , 
315:	int _Radix , 
316:	_locale_t _Locale 
317:	) ; 
320:	unsigned long long __cdecl _wcstoui64 ( 
321:	wchar_t const * _String , 
322:	wchar_t * * _EndPtr , 
323:	int _Radix 
324:	) ; 
327:	unsigned long long __cdecl _wcstoui64_l ( 
328:	wchar_t const * _String , 
329:	wchar_t * * _EndPtr , 
330:	int _Radix , 
331:	_locale_t _Locale 
332:	) ; 
339:	wchar_t * __cdecl _wfullpath ( 
340:	wchar_t * _Buffer , 
341:	wchar_t const * _Path , 
342:	size_t _BufferCount 
343:	) ; 
348:	errno_t __cdecl _wmakepath_s ( 
349:	wchar_t * _Buffer , 
350:	size_t _BufferCount , 
351:	wchar_t const * _Drive , 
352:	wchar_t const * _Dir , 
353:	wchar_t const * _Filename , 
354:	wchar_t const * _Ext 
355:	) ; 
366:	void __cdecl _wmakepath ( wchar_t * _Buffer , wchar_t const * _Drive , wchar_t const * _Dir , wchar_t const * _Filename , wchar_t const * _Ext 
375:	void __cdecl _wperror ( 
376:	wchar_t const * _ErrorMessage 
377:	) ; 
380:	void __cdecl _wsplitpath ( 
381:	wchar_t const * _FullPath , 
382:	wchar_t * _Drive , 
383:	wchar_t * _Dir , 
384:	wchar_t * _Filename , 
385:	wchar_t * _Ext 
386:	) ; 
388:	errno_t __cdecl _wsplitpath_s ( 
389:	wchar_t const * _FullPath , 
390:	wchar_t * _Drive , 
391:	size_t _DriveCount , 
392:	wchar_t * _Dir , 
393:	size_t _DirCount , 
394:	wchar_t * _Filename , 
395:	size_t _FilenameCount , 
396:	wchar_t * _Ext , 
397:	size_t _ExtCount 
398:	) ; 
409:	errno_t __cdecl _wdupenv_s ( 
410:	wchar_t * * _Buffer , 
411:	size_t * _BufferCount , 
412:	wchar_t const * _VarName 
413:	) ; 
418:	wchar_t * __cdecl _wgetenv ( 
419:	wchar_t const * _VarName 
420:	) ; 
424:	errno_t __cdecl _wgetenv_s ( 
425:	size_t * _RequiredCount , 
426:	wchar_t * _Buffer , 
427:	size_t _BufferCount , 
428:	wchar_t const * _VarName 
429:	) ; 
440:	int __cdecl _wputenv ( 
441:	wchar_t const * _EnvString 
442:	) ; 
445:	errno_t __cdecl _wputenv_s ( 
446:	wchar_t const * _Name , 
447:	wchar_t const * _Value 
448:	) ; 
450:	errno_t __cdecl _wsearchenv_s ( 
451:	wchar_t const * _Filename , 
452:	wchar_t const * _VarName , 
453:	wchar_t * _Buffer , 
454:	size_t _BufferCount 
455:	) ; 
464:	void __cdecl _wsearchenv ( wchar_t const * _Filename , wchar_t const * _VarName , wchar_t * _ResultPath 
471:	int __cdecl _wsystem ( 
472:	wchar_t const * _Command 
473:	) ; 
479:	_Pragma ( pack ( pop ) ) 
 16:	_Pragma ( pack ( push , 8 ) ) 
 76:	_Pragma ( pack ( pop ) ) 
 22:	_Pragma ( pack ( push , 8 ) ) 
 38:	void __cdecl _swab ( 
 39:	char * _Buf1 , 
 40:	char * _Buf2 , 
 41:	int _SizeInBytes 
 42:	) ; 
 56:	__declspec ( noreturn ) void __cdecl exit ( int _Code ) ; 
 57:	__declspec ( noreturn ) void __cdecl _exit ( int _Code ) ; 
 58:	__declspec ( noreturn ) void __cdecl _Exit ( int _Code ) ; 
 59:	__declspec ( noreturn ) void __cdecl quick_exit ( int _Code ) ; 
 60:	__declspec ( noreturn ) void __cdecl abort ( void ) ; 
 67:	unsigned int __cdecl _set_abort_behavior ( 
 68:	unsigned int _Flags , 
 69:	unsigned int _Mask 
 70:	) ; 
 77:	typedef int ( __cdecl * _onexit_t ) ( void ) ; 
144:	int __cdecl atexit ( void ( __cdecl * ) ( void ) ) ; 
145:	_onexit_t __cdecl _onexit ( _onexit_t _Func ) ; 
148:	int __cdecl at_quick_exit ( void ( __cdecl * ) ( void ) ) ; 
159:	typedef void ( __cdecl * _purecall_handler ) ( void ) ; 
162:	typedef void ( __cdecl * _invalid_parameter_handler ) ( 
163:	wchar_t const * , 
164:	wchar_t const * , 
165:	wchar_t const * , 
166:	unsigned int , 
167:	uintptr_t 
168:	) ; 
171:	_purecall_handler __cdecl _set_purecall_handler ( 
172:	_purecall_handler _Handler 
173:	) ; 
175:	_purecall_handler __cdecl _get_purecall_handler ( void ) ; 
178:	_invalid_parameter_handler __cdecl _set_invalid_parameter_handler ( 
179:	_invalid_parameter_handler _Handler 
180:	) ; 
182:	_invalid_parameter_handler __cdecl _get_invalid_parameter_handler ( void ) ; 
184:	_invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler ( 
185:	_invalid_parameter_handler _Handler 
186:	) ; 
188:	_invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler ( void ) ; 
212:	int __cdecl _set_error_mode ( int _Mode ) ; 
217:	int * __cdecl _errno ( void ) ; 
220:	errno_t __cdecl _set_errno ( int _Value ) ; 
221:	errno_t __cdecl _get_errno ( int * _Value ) ; 
223:	unsigned long * __cdecl __doserrno ( void ) ; 
226:	errno_t __cdecl _set_doserrno ( unsigned long _Value ) ; 
227:	errno_t __cdecl _get_doserrno ( unsigned long * _Value ) ; 
230:	char * * __cdecl __sys_errlist ( void ) ; 
233:	int * __cdecl __sys_nerr ( void ) ; 
236:	void __cdecl perror ( char const * _ErrMsg ) ; 
242:	char * * __cdecl __p__pgmptr ( void ) ; 
243:	wchar_t * * __cdecl __p__wpgmptr ( void ) ; 
244:	int * __cdecl __p__fmode ( void ) ; 
259:	errno_t __cdecl _get_pgmptr ( char * * _Value ) ; 
262:	errno_t __cdecl _get_wpgmptr ( wchar_t * * _Value ) ; 
264:	errno_t __cdecl _set_fmode ( int _Mode ) ; 
266:	errno_t __cdecl _get_fmode ( int * _PMode ) ; 
275:	typedef struct _div_t 
276:	{ 
277:	int quot ; 
278:	int rem ; 
279:	} div_t ; 
281:	typedef struct _ldiv_t 
282:	{ 
283:	long quot ; 
284:	long rem ; 
285:	} ldiv_t ; 
287:	typedef struct _lldiv_t 
288:	{ 
289:	long long quot ; 
290:	long long rem ; 
291:	} lldiv_t ; 
293:	int __cdecl abs ( int _Number ) ; 
294:	long __cdecl labs ( long _Number ) ; 
295:	long long __cdecl llabs ( long long _Number ) ; 
296:	long long __cdecl _abs64 ( long long _Number ) ; 
298:	unsigned short __cdecl _byteswap_ushort ( unsigned short _Number ) ; 
299:	unsigned long __cdecl _byteswap_ulong ( unsigned long _Number ) ; 
300:	unsigned long long __cdecl _byteswap_uint64 ( unsigned long long _Number ) ; 
302:	div_t __cdecl div ( int _Numerator , int _Denominator ) ; 
303:	ldiv_t __cdecl ldiv ( long _Numerator , long _Denominator ) ; 
304:	lldiv_t __cdecl lldiv ( long long _Numerator , long long _Denominator ) ; 
311:	unsigned int __cdecl _rotl ( 
312:	unsigned int _Value , 
313:	int _Shift 
314:	) ; 
317:	unsigned long __cdecl _lrotl ( 
318:	unsigned long _Value , 
319:	int _Shift 
320:	) ; 
322:	unsigned long long __cdecl _rotl64 ( 
323:	unsigned long long _Value , 
324:	int _Shift 
325:	) ; 
327:	unsigned int __cdecl _rotr ( 
328:	unsigned int _Value , 
329:	int _Shift 
330:	) ; 
333:	unsigned long __cdecl _lrotr ( 
334:	unsigned long _Value , 
335:	int _Shift 
336:	) ; 
338:	unsigned long long __cdecl _rotr64 ( 
339:	unsigned long long _Value , 
340:	int _Shift 
341:	) ; 
350:	void __cdecl srand ( unsigned int _Seed ) ; 
352:	int __cdecl rand ( void ) ; 
395:	typedef struct 
396:	{ 
397:	unsigned char ld [ 10 ] ; 
398:	} _LDOUBLE ; 
415:	typedef struct 
416:	{ 
417:	double x ; 
418:	} _CRT_DOUBLE ; 
420:	typedef struct 
421:	{ 
422:	float f ; 
423:	} _CRT_FLOAT ; 
429:	typedef struct 
430:	{ 
431:	long double x ; 
432:	} _LONGDOUBLE ; 
437:	typedef struct 
438:	{ 
439:	unsigned char ld12 [ 12 ] ; 
440:	} _LDBL12 ; 
450:	double __cdecl atof ( char const * _String ) ; 
451:	int __cdecl atoi ( char const * _String ) ; 
452:	long __cdecl atol ( char const * _String ) ; 
453:	long long __cdecl atoll ( char const * _String ) ; 
454:	long long __cdecl _atoi64 ( char const * _String ) ; 
456:	double __cdecl _atof_l ( char const * _String , _locale_t _Locale ) ; 
457:	int __cdecl _atoi_l ( char const * _String , _locale_t _Locale ) ; 
458:	long __cdecl _atol_l ( char const * _String , _locale_t _Locale ) ; 
459:	long long __cdecl _atoll_l ( char const * _String , _locale_t _Locale ) ; 
460:	long long __cdecl _atoi64_l ( char const * _String , _locale_t _Locale ) ; 
462:	int __cdecl _atoflt ( _CRT_FLOAT * _Result , char const * _String ) ; 
463:	int __cdecl _atodbl ( _CRT_DOUBLE * _Result , char * _String ) ; 
464:	int __cdecl _atoldbl ( _LDOUBLE * _Result , char * _String ) ; 
467:	int __cdecl _atoflt_l ( 
468:	_CRT_FLOAT * _Result , 
469:	char const * _String , 
470:	_locale_t _Locale 
471:	) ; 
474:	int __cdecl _atodbl_l ( 
475:	_CRT_DOUBLE * _Result , 
476:	char * _String , 
477:	_locale_t _Locale 
478:	) ; 
482:	int __cdecl _atoldbl_l ( 
483:	_LDOUBLE * _Result , 
484:	char * _String , 
485:	_locale_t _Locale 
486:	) ; 
489:	float __cdecl strtof ( 
490:	char const * _String , 
491:	char * * _EndPtr 
492:	) ; 
495:	float __cdecl _strtof_l ( 
496:	char const * _String , 
497:	char * * _EndPtr , 
498:	_locale_t _Locale 
499:	) ; 
502:	double __cdecl strtod ( 
503:	char const * _String , 
504:	char * * _EndPtr 
505:	) ; 
508:	double __cdecl _strtod_l ( 
509:	char const * _String , 
510:	char * * _EndPtr , 
511:	_locale_t _Locale 
512:	) ; 
515:	long double __cdecl strtold ( 
516:	char const * _String , 
517:	char * * _EndPtr 
518:	) ; 
521:	long double __cdecl _strtold_l ( 
522:	char const * _String , 
523:	char * * _EndPtr , 
524:	_locale_t _Locale 
525:	) ; 
528:	long __cdecl strtol ( 
529:	char const * _String , 
530:	char * * _EndPtr , 
531:	int _Radix 
532:	) ; 
535:	long __cdecl _strtol_l ( 
536:	char const * _String , 
537:	char * * _EndPtr , 
538:	int _Radix , 
539:	_locale_t _Locale 
540:	) ; 
543:	long long __cdecl strtoll ( 
544:	char const * _String , 
545:	char * * _EndPtr , 
546:	int _Radix 
547:	) ; 
550:	long long __cdecl _strtoll_l ( 
551:	char const * _String , 
552:	char * * _EndPtr , 
553:	int _Radix , 
554:	_locale_t _Locale 
555:	) ; 
558:	unsigned long __cdecl strtoul ( 
559:	char const * _String , 
560:	char * * _EndPtr , 
561:	int _Radix 
562:	) ; 
565:	unsigned long __cdecl _strtoul_l ( 
566:	char const * _String , 
567:	char * * _EndPtr , 
568:	int _Radix , 
569:	_locale_t _Locale 
570:	) ; 
573:	unsigned long long __cdecl strtoull ( 
574:	char const * _String , 
575:	char * * _EndPtr , 
576:	int _Radix 
577:	) ; 
580:	unsigned long long __cdecl _strtoull_l ( 
581:	char const * _String , 
582:	char * * _EndPtr , 
583:	int _Radix , 
584:	_locale_t _Locale 
585:	) ; 
588:	long long __cdecl _strtoi64 ( 
589:	char const * _String , 
590:	char * * _EndPtr , 
591:	int _Radix 
592:	) ; 
595:	long long __cdecl _strtoi64_l ( 
596:	char const * _String , 
597:	char * * _EndPtr , 
598:	int _Radix , 
599:	_locale_t _Locale 
600:	) ; 
603:	unsigned long long __cdecl _strtoui64 ( 
604:	char const * _String , 
605:	char * * _EndPtr , 
606:	int _Radix 
607:	) ; 
610:	unsigned long long __cdecl _strtoui64_l ( 
611:	char const * _String , 
612:	char * * _EndPtr , 
613:	int _Radix , 
614:	_locale_t _Locale 
615:	) ; 
626:	errno_t __cdecl _itoa_s ( 
627:	int _Value , 
628:	char * _Buffer , 
629:	size_t _BufferCount , 
630:	int _Radix 
631:	) ; 
641:	char * __cdecl _itoa ( int _Value , char * _Buffer , int _Radix 
650:	errno_t __cdecl _ltoa_s ( 
651:	long _Value , 
652:	char * _Buffer , 
653:	size_t _BufferCount , 
654:	int _Radix 
655:	) ; 
664:	char * __cdecl _ltoa ( long _Value , char * _Buffer , int _Radix 
673:	errno_t __cdecl _ultoa_s ( 
674:	unsigned long _Value , 
675:	char * _Buffer , 
676:	size_t _BufferCount , 
677:	int _Radix 
678:	) ; 
687:	char * __cdecl _ultoa ( unsigned long _Value , char * _Buffer , int _Radix 
696:	errno_t __cdecl _i64toa_s ( 
697:	long long _Value , 
698:	char * _Buffer , 
699:	size_t _BufferCount , 
700:	int _Radix 
701:	) ; 
705:	char * __cdecl _i64toa ( 
706:	long long _Value , 
707:	char * _Buffer , 
708:	int _Radix 
709:	) ; 
713:	errno_t __cdecl _ui64toa_s ( 
714:	unsigned long long _Value , 
715:	char * _Buffer , 
716:	size_t _BufferCount , 
717:	int _Radix 
718:	) ; 
721:	char * __cdecl _ui64toa ( 
722:	unsigned long long _Value , 
723:	char * _Buffer , 
724:	int _Radix 
725:	) ; 
741:	errno_t __cdecl _ecvt_s ( 
742:	char * _Buffer , 
743:	size_t _BufferCount , 
744:	double _Value , 
745:	int _DigitCount , 
746:	int * _PtDec , 
747:	int * _PtSign 
748:	) ; 
760:	char * __cdecl _ecvt ( 
761:	double _Value , 
762:	int _DigitCount , 
763:	int * _PtDec , 
764:	int * _PtSign 
765:	) ; 
769:	errno_t __cdecl _fcvt_s ( 
770:	char * _Buffer , 
771:	size_t _BufferCount , 
772:	double _Value , 
773:	int _FractionalDigitCount , 
774:	int * _PtDec , 
775:	int * _PtSign 
776:	) ; 
790:	char * __cdecl _fcvt ( 
791:	double _Value , 
792:	int _FractionalDigitCount , 
793:	int * _PtDec , 
794:	int * _PtSign 
795:	) ; 
798:	errno_t __cdecl _gcvt_s ( 
799:	char * _Buffer , 
800:	size_t _BufferCount , 
801:	double _Value , 
802:	int _DigitCount 
803:	) ; 
814:	char * __cdecl _gcvt ( 
815:	double _Value , 
816:	int _DigitCount , 
817:	char * _Buffer 
818:	) ; 
843:	int __cdecl ___mb_cur_max_func ( void ) ; 
846:	int __cdecl ___mb_cur_max_l_func ( _locale_t _Locale ) ; 
852:	int __cdecl mblen ( 
853:	char const * _Ch , 
854:	size_t _MaxCount 
855:	) ; 
858:	int __cdecl _mblen_l ( 
859:	char const * _Ch , 
860:	size_t _MaxCount , 
861:	_locale_t _Locale 
862:	) ; 
866:	size_t __cdecl _mbstrlen ( 
867:	char const * _String 
868:	) ; 
872:	size_t __cdecl _mbstrlen_l ( 
873:	char const * _String , 
874:	_locale_t _Locale 
875:	) ; 
879:	size_t __cdecl _mbstrnlen ( 
880:	char const * _String , 
881:	size_t _MaxCount 
882:	) ; 
886:	size_t __cdecl _mbstrnlen_l ( 
887:	char const * _String , 
888:	size_t _MaxCount , 
889:	_locale_t _Locale 
890:	) ; 
893:	int __cdecl mbtowc ( 
894:	wchar_t * _DstCh , 
895:	char const * _SrcCh , 
896:	size_t _SrcSizeInBytes 
897:	) ; 
900:	int __cdecl _mbtowc_l ( 
901:	wchar_t * _DstCh , 
902:	char const * _SrcCh , 
903:	size_t _SrcSizeInBytes , 
904:	_locale_t _Locale 
905:	) ; 
908:	errno_t __cdecl mbstowcs_s ( 
909:	size_t * _PtNumOfCharConverted , 
910:	wchar_t * _DstBuf , 
911:	size_t _SizeInWords , 
912:	char const * _SrcBuf , 
913:	size_t _MaxCount 
914:	) ; 
924:	size_t __cdecl mbstowcs ( wchar_t * _Dest , char const * _Source , size_t _MaxCount 
932:	errno_t __cdecl _mbstowcs_s_l ( 
933:	size_t * _PtNumOfCharConverted , 
934:	wchar_t * _DstBuf , 
935:	size_t _SizeInWords , 
936:	char const * _SrcBuf , 
937:	size_t _MaxCount , 
938:	_locale_t _Locale 
939:	) ; 
950:	size_t __cdecl _mbstowcs_l ( wchar_t * _Dest , char const * _Source , size_t _MaxCount , _locale_t _Locale 
963:	int __cdecl wctomb ( 
964:	char * _MbCh , 
965:	wchar_t _WCh 
966:	) ; 
969:	int __cdecl _wctomb_l ( 
970:	char * _MbCh , 
971:	wchar_t _WCh , 
972:	_locale_t _Locale 
973:	) ; 
978:	errno_t __cdecl wctomb_s ( 
979:	int * _SizeConverted , 
980:	char * _MbCh , 
981:	rsize_t _SizeInBytes , 
982:	wchar_t _WCh 
983:	) ; 
988:	errno_t __cdecl _wctomb_s_l ( 
989:	int * _SizeConverted , 
990:	char * _MbCh , 
991:	size_t _SizeInBytes , 
992:	wchar_t _WCh , 
993:	_locale_t _Locale ) ; 
996:	errno_t __cdecl wcstombs_s ( 
997:	size_t * _PtNumOfCharConverted , 
998:	char * _Dst , 
999:	size_t _DstSizeInBytes , 
1000:	wchar_t const * _Src , 
1001:	size_t _MaxCountInBytes 
1002:	) ; 
1012:	size_t __cdecl wcstombs ( char * _Dest , wchar_t const * _Source , size_t _MaxCount 
1020:	errno_t __cdecl _wcstombs_s_l ( 
1021:	size_t * _PtNumOfCharConverted , 
1022:	char * _Dst , 
1023:	size_t _DstSizeInBytes , 
1024:	wchar_t const * _Src , 
1025:	size_t _MaxCountInBytes , 
1026:	_locale_t _Locale 
1027:	) ; 
1038:	size_t __cdecl _wcstombs_l ( char * _Dest , wchar_t const * _Source , size_t _MaxCount , _locale_t _Locale 
1068:	char * __cdecl _fullpath ( 
1069:	char * _Buffer , 
1070:	char const * _Path , 
1071:	size_t _BufferCount 
1072:	) ; 
1077:	errno_t __cdecl _makepath_s ( 
1078:	char * _Buffer , 
1079:	size_t _BufferCount , 
1080:	char const * _Drive , 
1081:	char const * _Dir , 
1082:	char const * _Filename , 
1083:	char const * _Ext 
1084:	) ; 
1095:	void __cdecl _makepath ( char * _Buffer , char const * _Drive , char const * _Dir , char const * _Filename , char const * _Ext 
1105:	void __cdecl _splitpath ( 
1106:	char const * _FullPath , 
1107:	char * _Drive , 
1108:	char * _Dir , 
1109:	char * _Filename , 
1110:	char * _Ext 
1111:	) ; 
1114:	errno_t __cdecl _splitpath_s ( 
1115:	char const * _FullPath , 
1116:	char * _Drive , 
1117:	size_t _DriveCount , 
1118:	char * _Dir , 
1119:	size_t _DirCount , 
1120:	char * _Filename , 
1121:	size_t _FilenameCount , 
1122:	char * _Ext , 
1123:	size_t _ExtCount 
1124:	) ; 
1132:	errno_t __cdecl getenv_s ( 
1133:	size_t * _RequiredCount , 
1134:	char * _Buffer , 
1135:	rsize_t _BufferCount , 
1136:	char const * _VarName 
1137:	) ; 
1144:	int * __cdecl __p___argc ( void ) ; 
1145:	char * * * __cdecl __p___argv ( void ) ; 
1146:	wchar_t * * * __cdecl __p___wargv ( void ) ; 
1158:	char * * * __cdecl __p__environ ( void ) ; 
1159:	wchar_t * * * __cdecl __p__wenviron ( void ) ; 
1184:	char * __cdecl getenv ( 
1185:	char const * _VarName 
1186:	) ; 
1201:	errno_t __cdecl _dupenv_s ( 
1202:	char * * _Buffer , 
1203:	size_t * _BufferCount , 
1204:	char const * _VarName 
1205:	) ; 
1211:	int __cdecl system ( 
1212:	char const * _Command 
1213:	) ; 
1221:	int __cdecl _putenv ( 
1222:	char const * _EnvString 
1223:	) ; 
1226:	errno_t __cdecl _putenv_s ( 
1227:	char const * _Name , 
1228:	char const * _Value 
1229:	) ; 
1233:	errno_t __cdecl _searchenv_s ( 
1234:	char const * _Filename , 
1235:	char const * _VarName , 
1236:	char * _Buffer , 
1237:	size_t _BufferCount 
1238:	) ; 
1247:	void __cdecl _searchenv ( char const * _Filename , char const * _VarName , char * _Buffer 
1255:	__declspec ( deprecated ( "This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details." ) ) 
1256:	void __cdecl _seterrormode ( 
1257:	int _Mode 
1258:	) ; 
1260:	__declspec ( deprecated ( "This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details." ) ) 
1261:	void __cdecl _beep ( 
1262:	unsigned _Frequency , 
1263:	unsigned _Duration 
1264:	) ; 
1266:	__declspec ( deprecated ( "This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details." ) ) 
1267:	void __cdecl _sleep ( 
1268:	unsigned long _Duration 
1269:	) ; 
1292:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details." ) ) 
1293:	char * __cdecl ecvt ( 
1294:	double _Value , 
1295:	int _DigitCount , 
1296:	int * _PtDec , 
1297:	int * _PtSign 
1298:	) ; 
1300:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details." ) ) 
1301:	char * __cdecl fcvt ( 
1302:	double _Value , 
1303:	int _FractionalDigitCount , 
1304:	int * _PtDec , 
1305:	int * _PtSign 
1306:	) ; 
1308:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details." ) ) 
1309:	char * __cdecl gcvt ( 
1310:	double _Value , 
1311:	int _DigitCount , 
1312:	char * _DstBuf 
1313:	) ; 
1315:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details." ) ) 
1316:	char * __cdecl itoa ( 
1317:	int _Value , 
1318:	char * _Buffer , 
1319:	int _Radix 
1320:	) ; 
1322:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details." ) ) 
1323:	char * __cdecl ltoa ( 
1324:	long _Value , 
1325:	char * _Buffer , 
1326:	int _Radix 
1327:	) ; 
1330:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details." ) ) 
1331:	void __cdecl swab ( 
1332:	char * _Buf1 , 
1333:	char * _Buf2 , 
1334:	int _SizeInBytes 
1335:	) ; 
1337:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details." ) ) 
1338:	char * __cdecl ultoa ( 
1339:	unsigned long _Value , 
1340:	char * _Buffer , 
1341:	int _Radix 
1342:	) ; 
1346:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details." ) ) 
1347:	int __cdecl putenv ( 
1348:	char const * _EnvString 
1349:	) ; 
1353:	_onexit_t __cdecl onexit ( _onexit_t _Func ) ; 
1359:	_Pragma ( pack ( pop ) ) 
238:	typedef unsigned char stbi_uc ; 
239:	typedef unsigned short stbi_us ; 
262:	typedef struct 
263:	{ 
264:	int ( * read ) ( void * user , char * data , int size ) ; 
265:	void ( * skip ) ( void * user , int n ) ; 
266:	int ( * eof ) ( void * user ) ; 
267:	} stbi_io_callbacks ; 
274:	extern stbi_uc * stbi_load_from_memory ( stbi_uc const * buffer , int len , int * x , int * y , int * channels_in_file , int desired_channels ) ; 
275:	extern stbi_uc * stbi_load_from_callbacks ( stbi_io_callbacks const * clbk , void * user , int * x , int * y , int * channels_in_file , int desired_channels ) ; 
278:	extern stbi_uc * stbi_load ( char const * filename , int * x , int * y , int * channels_in_file , int desired_channels ) ; 
279:	extern stbi_uc * stbi_load_from_file ( FILE * f , int * x , int * y , int * channels_in_file , int desired_channels ) ; 
284:	extern stbi_uc * stbi_load_gif_from_memory ( stbi_uc const * buffer , int len , int * * delays , int * x , int * y , int * z , int * comp , int req_comp ) ; 
296:	extern stbi_us * stbi_load_16_from_memory ( stbi_uc const * buffer , int len , int * x , int * y , int * channels_in_file , int desired_channels ) ; 
297:	extern stbi_us * stbi_load_16_from_callbacks ( stbi_io_callbacks const * clbk , void * user , int * x , int * y , int * channels_in_file , int desired_channels ) ; 
300:	extern stbi_us * stbi_load_16 ( char const * filename , int * x , int * y , int * channels_in_file , int desired_channels ) ; 
301:	extern stbi_us * stbi_load_from_file_16 ( FILE * f , int * x , int * y , int * channels_in_file , int desired_channels ) ; 
309:	extern float * stbi_loadf_from_memory ( stbi_uc const * buffer , int len , int * x , int * y , int * channels_in_file , int desired_channels ) ; 
310:	extern float * stbi_loadf_from_callbacks ( stbi_io_callbacks const * clbk , void * user , int * x , int * y , int * channels_in_file , int desired_channels ) ; 
313:	extern float * stbi_loadf ( char const * filename , int * x , int * y , int * channels_in_file , int desired_channels ) ; 
314:	extern float * stbi_loadf_from_file ( FILE * f , int * x , int * y , int * channels_in_file , int desired_channels ) ; 
319:	extern void stbi_hdr_to_ldr_gamma ( float gamma ) ; 
320:	extern void stbi_hdr_to_ldr_scale ( float scale ) ; 
324:	extern void stbi_ldr_to_hdr_gamma ( float gamma ) ; 
325:	extern void stbi_ldr_to_hdr_scale ( float scale ) ; 
329:	extern int stbi_is_hdr_from_callbacks ( stbi_io_callbacks const * clbk , void * user ) ; 
330:	extern int stbi_is_hdr_from_memory ( stbi_uc const * buffer , int len ) ; 
332:	extern int stbi_is_hdr ( char const * filename ) ; 
333:	extern int stbi_is_hdr_from_file ( FILE * f ) ; 
339:	extern const char * stbi_failure_reason ( void ) ; 
342:	extern void stbi_image_free ( void * retval_from_stbi_load ) ; 
345:	extern int stbi_info_from_memory ( stbi_uc const * buffer , int len , int * x , int * y , int * comp ) ; 
346:	extern int stbi_info_from_callbacks ( stbi_io_callbacks const * clbk , void * user , int * x , int * y , int * comp ) ; 
347:	extern int stbi_is_16_bit_from_memory ( stbi_uc const * buffer , int len ) ; 
348:	extern int stbi_is_16_bit_from_callbacks ( stbi_io_callbacks const * clbk , void * user ) ; 
351:	extern int stbi_info ( char const * filename , int * x , int * y , int * comp ) ; 
352:	extern int stbi_info_from_file ( FILE * f , int * x , int * y , int * comp ) ; 
353:	extern int stbi_is_16_bit ( char const * filename ) ; 
354:	extern int stbi_is_16_bit_from_file ( FILE * f ) ; 
362:	extern void stbi_set_unpremultiply_on_load ( int flag_true_if_should_unpremultiply ) ; 
366:	extern void stbi_convert_iphone_png_to_rgb ( int flag_true_if_should_convert ) ; 
369:	extern void stbi_set_flip_vertically_on_load ( int flag_true_if_should_flip ) ; 
374:	extern void stbi_set_flip_vertically_on_load_thread ( int flag_true_if_should_flip ) ; 
378:	extern char * stbi_zlib_decode_malloc_guesssize ( const char * buffer , int len , int initial_size , int * outlen ) ; 
379:	extern char * stbi_zlib_decode_malloc_guesssize_headerflag ( const char * buffer , int len , int initial_size , int * outlen , int parse_header ) ; 
380:	extern char * stbi_zlib_decode_malloc ( const char * buffer , int len , int * outlen ) ; 
381:	extern int stbi_zlib_decode_buffer ( char * obuffer , int olen , const char * ibuffer , int ilen ) ; 
383:	extern char * stbi_zlib_decode_noheader_malloc ( const char * buffer , int len , int * outlen ) ; 
384:	extern int stbi_zlib_decode_noheader_buffer ( char * obuffer , int olen , const char * ibuffer , int ilen ) ; 
 16:	_Pragma ( pack ( push , 8 ) ) 
 27:	_Pragma ( pack ( pop ) ) 
 18:	_Pragma ( pack ( push , 8 ) ) 
 23:	int * __cdecl _errno ( void ) ; 
 26:	errno_t __cdecl _set_errno ( int _Value ) ; 
 27:	errno_t __cdecl _get_errno ( int * _Value ) ; 
 29:	unsigned long * __cdecl __doserrno ( void ) ; 
 32:	errno_t __cdecl _set_doserrno ( unsigned long _Value ) ; 
 33:	errno_t __cdecl _get_doserrno ( unsigned long * _Value ) ; 
134:	_Pragma ( pack ( pop ) ) 
 17:	_Pragma ( pack ( push , 8 ) ) 
 22:	void * __cdecl memchr ( 
 23:	void const * _Buf , 
 24:	int _Val , 
 25:	size_t _MaxCount 
 26:	) ; 
 29:	int __cdecl memcmp ( 
 30:	void const * _Buf1 , 
 31:	void const * _Buf2 , 
 32:	size_t _Size 
 33:	) ; 
 43:	void * __cdecl memcpy ( 
 44:	void * _Dst , 
 45:	void const * _Src , 
 46:	size_t _Size 
 47:	) ; 
 50:	void * __cdecl memmove ( 
 51:	void * _Dst , 
 52:	void const * _Src , 
 53:	size_t _Size 
 54:	) ; 
 63:	void * __cdecl memset ( 
 64:	void * _Dst , 
 65:	int _Val , 
 66:	size_t _Size 
 67:	) ; 
 70:	char * __cdecl strchr ( 
 71:	char const * _Str , 
 72:	int _Val 
 73:	) ; 
 76:	char * __cdecl strrchr ( 
 77:	char const * _Str , 
 78:	int _Ch 
 79:	) ; 
 82:	char * __cdecl strstr ( 
 83:	char const * _Str , 
 84:	char const * _SubStr 
 85:	) ; 
 89:	wchar_t * __cdecl wcschr ( 
 90:	wchar_t const * _Str , 
 91:	wchar_t _Ch 
 92:	) ; 
 95:	wchar_t * __cdecl wcsrchr ( 
 96:	wchar_t const * _Str , 
 97:	wchar_t _Ch 
 98:	) ; 
102:	wchar_t * __cdecl wcsstr ( 
103:	wchar_t const * _Str , 
104:	wchar_t const * _SubStr 
105:	) ; 
109:	_Pragma ( pack ( pop ) ) 
 18:	_Pragma ( pack ( push , 8 ) ) 
 30:	static inline errno_t __cdecl memcpy_s ( 
 31:	void * const _Destination , 
 32:	rsize_t const _DestinationSize , 
 33:	void const * const _Source , 
 34:	rsize_t const _SourceSize 
 35:	) 
 36:	{ 
 37:	if ( _SourceSize == 0 ) 
 38:	{ 
 39:	return 0 ; 
 40:	} 
 42:	{ int _Expr_val = !! ( _Destination != ( ( void * ) 0 ) ) ; if ( ! ( _Expr_val ) ) { ( * _errno ( ) ) = 22 ; _invalid_parameter_noinfo ( ) ; return 22 ; } } ; 
 43:	if ( _Source == ( ( void * ) 0 ) || _DestinationSize < _SourceSize ) 
 44:	{ 
 45:	memset ( _Destination , 0 , _DestinationSize ) ; 
 47:	{ int _Expr_val = !! ( _Source != ( ( void * ) 0 ) ) ; if ( ! ( _Expr_val ) ) { ( * _errno ( ) ) = 22 ; _invalid_parameter_noinfo ( ) ; return 22 ; } } ; 
 48:	{ int _Expr_val = !! ( _DestinationSize >= _SourceSize ) ; if ( ! ( _Expr_val ) ) { ( * _errno ( ) ) = 34 ; _invalid_parameter_noinfo ( ) ; return 34 ; } } ; 
 51:	return 22 ; 
 52:	} 
 53:	memcpy ( _Destination , _Source , _SourceSize ) ; 
 54:	return 0 ; 
 55:	} 
 58:	static inline errno_t __cdecl memmove_s ( 
 59:	void * const _Destination , 
 60:	rsize_t const _DestinationSize , 
 61:	void const * const _Source , 
 62:	rsize_t const _SourceSize 
 63:	) 
 64:	{ 
 65:	if ( _SourceSize == 0 ) 
 66:	{ 
 67:	return 0 ; 
 68:	} 
 70:	{ int _Expr_val = !! ( _Destination != ( ( void * ) 0 ) ) ; if ( ! ( _Expr_val ) ) { ( * _errno ( ) ) = 22 ; _invalid_parameter_noinfo ( ) ; return 22 ; } } ; 
 71:	{ int _Expr_val = !! ( _Source != ( ( void * ) 0 ) ) ; if ( ! ( _Expr_val ) ) { ( * _errno ( ) ) = 22 ; _invalid_parameter_noinfo ( ) ; return 22 ; } } ; 
 72:	{ int _Expr_val = !! ( _DestinationSize >= _SourceSize ) ; if ( ! ( _Expr_val ) ) { ( * _errno ( ) ) = 34 ; _invalid_parameter_noinfo ( ) ; return 34 ; } } ; 
 74:	memmove ( _Destination , _Source , _SourceSize ) ; 
 75:	return 0 ; 
 76:	} 
 84:	_Pragma ( pack ( pop ) ) 
 23:	_Pragma ( pack ( push , 8 ) ) 
 28:	int __cdecl _memicmp ( 
 29:	void const * _Buf1 , 
 30:	void const * _Buf2 , 
 31:	size_t _Size 
 32:	) ; 
 35:	int __cdecl _memicmp_l ( 
 36:	void const * _Buf1 , 
 37:	void const * _Buf2 , 
 38:	size_t _Size , 
 39:	_locale_t _Locale 
 40:	) ; 
 82:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details." ) ) 
 83:	void * __cdecl memccpy ( 
 84:	void * _Dst , 
 85:	void const * _Src , 
 86:	int _Val , 
 87:	size_t _Size 
 88:	) ; 
 90:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details." ) ) 
 91:	int __cdecl memicmp ( 
 92:	void const * _Buf1 , 
 93:	void const * _Buf2 , 
 94:	size_t _Size 
 95:	) ; 
118:	_Pragma ( pack ( pop ) ) 
 20:	_Pragma ( pack ( push , 8 ) ) 
 32:	errno_t __cdecl wcscat_s ( 
 33:	wchar_t * _Destination , 
 34:	rsize_t _SizeInWords , 
 35:	wchar_t const * _Source 
 36:	) ; 
 39:	errno_t __cdecl wcscpy_s ( 
 40:	wchar_t * _Destination , 
 41:	rsize_t _SizeInWords , 
 42:	wchar_t const * _Source 
 43:	) ; 
 46:	errno_t __cdecl wcsncat_s ( 
 47:	wchar_t * _Destination , 
 48:	rsize_t _SizeInWords , 
 49:	wchar_t const * _Source , 
 50:	rsize_t _MaxCount 
 51:	) ; 
 54:	errno_t __cdecl wcsncpy_s ( 
 55:	wchar_t * _Destination , 
 56:	rsize_t _SizeInWords , 
 57:	wchar_t const * _Source , 
 58:	rsize_t _MaxCount 
 59:	) ; 
 62:	wchar_t * __cdecl wcstok_s ( 
 63:	wchar_t * _String , 
 64:	wchar_t const * _Delimiter , 
 65:	wchar_t * * _Context 
 66:	) ; 
 83:	wchar_t * __cdecl _wcsdup ( 
 84:	wchar_t const * _String 
 85:	) ; 
100:	wchar_t * __cdecl wcscat ( wchar_t * _Destination , wchar_t const * _Source 
108:	int __cdecl wcscmp ( 
109:	wchar_t const * _String1 , 
110:	wchar_t const * _String2 
111:	) ; 
119:	wchar_t * __cdecl wcscpy ( wchar_t * _Destination , wchar_t const * _Source 
126:	size_t __cdecl wcscspn ( 
127:	wchar_t const * _String , 
128:	wchar_t const * _Control 
129:	) ; 
132:	size_t __cdecl wcslen ( 
133:	wchar_t const * _String 
134:	) ; 
145:	size_t __cdecl wcsnlen ( 
146:	wchar_t const * _Source , 
147:	size_t _MaxCount 
148:	) ; 
161:	static inline size_t __cdecl wcsnlen_s ( 
162:	wchar_t const * _Source , 
163:	size_t _MaxCount 
164:	) 
165:	{ 
166:	return ( _Source == 0 ) ? 0 : wcsnlen ( _Source , _MaxCount ) ; 
167:	} 
178:	wchar_t * __cdecl wcsncat ( wchar_t * _Destination , wchar_t const * _Source , size_t _Count 
187:	int __cdecl wcsncmp ( 
188:	wchar_t const * _String1 , 
189:	wchar_t const * _String2 , 
190:	size_t _MaxCount 
191:	) ; 
200:	wchar_t * __cdecl wcsncpy ( wchar_t * _Destination , wchar_t const * _Source , size_t _Count 
209:	wchar_t * __cdecl wcspbrk ( 
210:	wchar_t const * _String , 
211:	wchar_t const * _Control 
212:	) ; 
215:	size_t __cdecl wcsspn ( 
216:	wchar_t const * _String , 
217:	wchar_t const * _Control 
218:	) ; 
221:	wchar_t * __cdecl wcstok ( 
222:	wchar_t * _String , 
223:	wchar_t const * _Delimiter , 
224:	wchar_t * * _Context 
225:	) ; 
236:	static inline wchar_t * __cdecl _wcstok ( 
237:	wchar_t * const _String , 
238:	wchar_t const * const _Delimiter 
239:	) 
240:	{ 
241:	return wcstok ( _String , _Delimiter , 0 ) ; 
242:	} 
265:	wchar_t * __cdecl _wcserror ( 
266:	int _ErrorNumber 
267:	) ; 
270:	errno_t __cdecl _wcserror_s ( 
271:	wchar_t * _Buffer , 
272:	size_t _SizeInWords , 
273:	int _ErrorNumber 
274:	) ; 
285:	wchar_t * __cdecl __wcserror ( 
286:	wchar_t const * _String 
287:	) ; 
289:	errno_t __cdecl __wcserror_s ( 
290:	wchar_t * _Buffer , 
291:	size_t _SizeInWords , 
292:	wchar_t const * _ErrorMessage 
293:	) ; 
301:	int __cdecl _wcsicmp ( 
302:	wchar_t const * _String1 , 
303:	wchar_t const * _String2 
304:	) ; 
306:	int __cdecl _wcsicmp_l ( 
307:	wchar_t const * _String1 , 
308:	wchar_t const * _String2 , 
309:	_locale_t _Locale 
310:	) ; 
312:	int __cdecl _wcsnicmp ( 
313:	wchar_t const * _String1 , 
314:	wchar_t const * _String2 , 
315:	size_t _MaxCount 
316:	) ; 
318:	int __cdecl _wcsnicmp_l ( 
319:	wchar_t const * _String1 , 
320:	wchar_t const * _String2 , 
321:	size_t _MaxCount , 
322:	_locale_t _Locale 
323:	) ; 
325:	errno_t __cdecl _wcsnset_s ( 
326:	wchar_t * _Destination , 
327:	size_t _SizeInWords , 
328:	wchar_t _Value , 
329:	size_t _MaxCount 
330:	) ; 
339:	wchar_t * __cdecl _wcsnset ( wchar_t * _String , wchar_t _Value , size_t _MaxCount 
347:	wchar_t * __cdecl _wcsrev ( 
348:	wchar_t * _String 
349:	) ; 
351:	errno_t __cdecl _wcsset_s ( 
352:	wchar_t * _Destination , 
353:	size_t _SizeInWords , 
354:	wchar_t _Value 
355:	) ; 
363:	wchar_t * __cdecl _wcsset ( wchar_t * _String , wchar_t _Value 
370:	errno_t __cdecl _wcslwr_s ( 
371:	wchar_t * _String , 
372:	size_t _SizeInWords 
373:	) ; 
380:	wchar_t * __cdecl _wcslwr ( wchar_t * _String 
386:	errno_t __cdecl _wcslwr_s_l ( 
387:	wchar_t * _String , 
388:	size_t _SizeInWords , 
389:	_locale_t _Locale 
390:	) ; 
398:	wchar_t * __cdecl _wcslwr_l ( wchar_t * _String , _locale_t _Locale 
406:	errno_t __cdecl _wcsupr_s ( 
407:	wchar_t * _String , 
408:	size_t _Size 
409:	) ; 
416:	wchar_t * __cdecl _wcsupr ( wchar_t * _String 
422:	errno_t __cdecl _wcsupr_s_l ( 
423:	wchar_t * _String , 
424:	size_t _Size , 
425:	_locale_t _Locale 
426:	) ; 
434:	wchar_t * __cdecl _wcsupr_l ( wchar_t * _String , _locale_t _Locale 
443:	size_t __cdecl wcsxfrm ( 
444:	wchar_t * _Destination , 
445:	wchar_t const * _Source , 
446:	size_t _MaxCount 
447:	) ; 
451:	size_t __cdecl _wcsxfrm_l ( 
452:	wchar_t * _Destination , 
453:	wchar_t const * _Source , 
454:	size_t _MaxCount , 
455:	_locale_t _Locale 
456:	) ; 
459:	int __cdecl wcscoll ( 
460:	wchar_t const * _String1 , 
461:	wchar_t const * _String2 
462:	) ; 
465:	int __cdecl _wcscoll_l ( 
466:	wchar_t const * _String1 , 
467:	wchar_t const * _String2 , 
468:	_locale_t _Locale 
469:	) ; 
472:	int __cdecl _wcsicoll ( 
473:	wchar_t const * _String1 , 
474:	wchar_t const * _String2 
475:	) ; 
478:	int __cdecl _wcsicoll_l ( 
479:	wchar_t const * _String1 , 
480:	wchar_t const * _String2 , 
481:	_locale_t _Locale 
482:	) ; 
485:	int __cdecl _wcsncoll ( 
486:	wchar_t const * _String1 , 
487:	wchar_t const * _String2 , 
488:	size_t _MaxCount 
489:	) ; 
492:	int __cdecl _wcsncoll_l ( 
493:	wchar_t const * _String1 , 
494:	wchar_t const * _String2 , 
495:	size_t _MaxCount , 
496:	_locale_t _Locale 
497:	) ; 
500:	int __cdecl _wcsnicoll ( 
501:	wchar_t const * _String1 , 
502:	wchar_t const * _String2 , 
503:	size_t _MaxCount 
504:	) ; 
507:	int __cdecl _wcsnicoll_l ( 
508:	wchar_t const * _String1 , 
509:	wchar_t const * _String2 , 
510:	size_t _MaxCount , 
511:	_locale_t _Locale 
512:	) ; 
566:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details." ) ) 
567:	wchar_t * __cdecl wcsdup ( 
568:	wchar_t const * _String 
569:	) ; 
578:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details." ) ) 
579:	int __cdecl wcsicmp ( 
580:	wchar_t const * _String1 , 
581:	wchar_t const * _String2 
582:	) ; 
584:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details." ) ) 
585:	int __cdecl wcsnicmp ( 
586:	wchar_t const * _String1 , 
587:	wchar_t const * _String2 , 
588:	size_t _MaxCount 
589:	) ; 
591:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details." ) ) 
593:	wchar_t * __cdecl wcsnset ( 
594:	wchar_t * _String , 
595:	wchar_t _Value , 
596:	size_t _MaxCount 
597:	) ; 
599:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details." ) ) 
601:	wchar_t * __cdecl wcsrev ( 
602:	wchar_t * _String 
603:	) ; 
605:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details." ) ) 
607:	wchar_t * __cdecl wcsset ( 
608:	wchar_t * _String , 
609:	wchar_t _Value 
610:	) ; 
612:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details." ) ) 
614:	wchar_t * __cdecl wcslwr ( 
615:	wchar_t * _String 
616:	) ; 
618:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details." ) ) 
620:	wchar_t * __cdecl wcsupr ( 
621:	wchar_t * _String 
622:	) ; 
624:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details." ) ) 
625:	int __cdecl wcsicoll ( 
626:	wchar_t const * _String1 , 
627:	wchar_t const * _String2 
628:	) ; 
634:	_Pragma ( pack ( pop ) ) 
 23:	_Pragma ( pack ( push , 8 ) ) 
 32:	errno_t __cdecl strcpy_s ( 
 33:	char * _Destination , 
 34:	rsize_t _SizeInBytes , 
 35:	char const * _Source 
 36:	) ; 
 39:	errno_t __cdecl strcat_s ( 
 40:	char * _Destination , 
 41:	rsize_t _SizeInBytes , 
 42:	char const * _Source 
 43:	) ; 
 46:	errno_t __cdecl strerror_s ( 
 47:	char * _Buffer , 
 48:	size_t _SizeInBytes , 
 49:	int _ErrorNumber ) ; 
 52:	errno_t __cdecl strncat_s ( 
 53:	char * _Destination , 
 54:	rsize_t _SizeInBytes , 
 55:	char const * _Source , 
 56:	rsize_t _MaxCount 
 57:	) ; 
 60:	errno_t __cdecl strncpy_s ( 
 61:	char * _Destination , 
 62:	rsize_t _SizeInBytes , 
 63:	char const * _Source , 
 64:	rsize_t _MaxCount 
 65:	) ; 
 68:	char * __cdecl strtok_s ( 
 69:	char * _String , 
 70:	char const * _Delimiter , 
 71:	char * * _Context 
 72:	) ; 
 76:	void * __cdecl _memccpy ( 
 77:	void * _Dst , 
 78:	void const * _Src , 
 79:	int _Val , 
 80:	size_t _MaxCount 
 81:	) ; 
 91:	char * __cdecl strcat ( char * _Destination , char const * _Source 
100:	int __cdecl strcmp ( 
101:	char const * _Str1 , 
102:	char const * _Str2 
103:	) ; 
106:	int __cdecl _strcmpi ( 
107:	char const * _String1 , 
108:	char const * _String2 
109:	) ; 
112:	int __cdecl strcoll ( 
113:	char const * _String1 , 
114:	char const * _String2 
115:	) ; 
118:	int __cdecl _strcoll_l ( 
119:	char const * _String1 , 
120:	char const * _String2 , 
121:	_locale_t _Locale 
122:	) ; 
130:	char * __cdecl strcpy ( char * _Destination , char const * _Source 
137:	size_t __cdecl strcspn ( 
138:	char const * _Str , 
139:	char const * _Control 
140:	) ; 
148:	char * __cdecl _strdup ( 
149:	char const * _Source 
150:	) ; 
159:	char * __cdecl _strerror ( 
160:	char const * _ErrorMessage 
161:	) ; 
164:	errno_t __cdecl _strerror_s ( 
165:	char * _Buffer , 
166:	size_t _SizeInBytes , 
167:	char const * _ErrorMessage 
168:	) ; 
178:	char * __cdecl strerror ( 
179:	int _ErrorMessage 
180:	) ; 
189:	int __cdecl _stricmp ( 
190:	char const * _String1 , 
191:	char const * _String2 
192:	) ; 
195:	int __cdecl _stricoll ( 
196:	char const * _String1 , 
197:	char const * _String2 
198:	) ; 
201:	int __cdecl _stricoll_l ( 
202:	char const * _String1 , 
203:	char const * _String2 , 
204:	_locale_t _Locale 
205:	) ; 
208:	int __cdecl _stricmp_l ( 
209:	char const * _String1 , 
210:	char const * _String2 , 
211:	_locale_t _Locale 
212:	) ; 
215:	size_t __cdecl strlen ( 
216:	char const * _Str 
217:	) ; 
220:	errno_t __cdecl _strlwr_s ( 
221:	char * _String , 
222:	size_t _Size 
223:	) ; 
230:	char * __cdecl _strlwr ( char * _String 
236:	errno_t __cdecl _strlwr_s_l ( 
237:	char * _String , 
238:	size_t _Size , 
239:	_locale_t _Locale 
240:	) ; 
248:	char * __cdecl _strlwr_l ( char * _String , _locale_t _Locale 
262:	char * __cdecl strncat ( char * _Destination , char const * _Source , size_t _Count 
271:	int __cdecl strncmp ( 
272:	char const * _Str1 , 
273:	char const * _Str2 , 
274:	size_t _MaxCount 
275:	) ; 
278:	int __cdecl _strnicmp ( 
279:	char const * _String1 , 
280:	char const * _String2 , 
281:	size_t _MaxCount 
282:	) ; 
285:	int __cdecl _strnicmp_l ( 
286:	char const * _String1 , 
287:	char const * _String2 , 
288:	size_t _MaxCount , 
289:	_locale_t _Locale 
290:	) ; 
293:	int __cdecl _strnicoll ( 
294:	char const * _String1 , 
295:	char const * _String2 , 
296:	size_t _MaxCount 
297:	) ; 
300:	int __cdecl _strnicoll_l ( 
301:	char const * _String1 , 
302:	char const * _String2 , 
303:	size_t _MaxCount , 
304:	_locale_t _Locale 
305:	) ; 
308:	int __cdecl _strncoll ( 
309:	char const * _String1 , 
310:	char const * _String2 , 
311:	size_t _MaxCount 
312:	) ; 
315:	int __cdecl _strncoll_l ( 
316:	char const * _String1 , 
317:	char const * _String2 , 
318:	size_t _MaxCount , 
319:	_locale_t _Locale 
320:	) ; 
322:	size_t __cdecl __strncnt ( 
323:	char const * _String , 
324:	size_t _Count 
325:	) ; 
334:	char * __cdecl strncpy ( char * _Destination , char const * _Source , size_t _Count 
351:	size_t __cdecl strnlen ( 
352:	char const * _String , 
353:	size_t _MaxCount 
354:	) ; 
367:	static inline size_t __cdecl strnlen_s ( 
368:	char const * _String , 
369:	size_t _MaxCount 
370:	) 
371:	{ 
372:	return _String == 0 ? 0 : strnlen ( _String , _MaxCount ) ; 
373:	} 
378:	errno_t __cdecl _strnset_s ( 
379:	char * _String , 
380:	size_t _SizeInBytes , 
381:	int _Value , 
382:	size_t _MaxCount 
383:	) ; 
392:	char * __cdecl _strnset ( char * _Destination , int _Value , size_t _Count 
401:	char * __cdecl strpbrk ( 
402:	char const * _Str , 
403:	char const * _Control 
404:	) ; 
406:	char * __cdecl _strrev ( 
407:	char * _Str 
408:	) ; 
411:	errno_t __cdecl _strset_s ( 
412:	char * _Destination , 
413:	size_t _DestinationSize , 
414:	int _Value 
415:	) ; 
423:	char * __cdecl _strset ( char * _Destination , int _Value 
430:	size_t __cdecl strspn ( 
431:	char const * _Str , 
432:	char const * _Control 
433:	) ; 
436:	char * __cdecl strtok ( 
437:	char * _String , 
438:	char const * _Delimiter 
439:	) ; 
442:	errno_t __cdecl _strupr_s ( 
443:	char * _String , 
444:	size_t _Size 
445:	) ; 
452:	char * __cdecl _strupr ( char * _String 
458:	errno_t __cdecl _strupr_s_l ( 
459:	char * _String , 
460:	size_t _Size , 
461:	_locale_t _Locale 
462:	) ; 
470:	char * __cdecl _strupr_l ( char * _String , _locale_t _Locale 
479:	size_t __cdecl strxfrm ( 
480:	char * _Destination , 
481:	char const * _Source , 
482:	size_t _MaxCount 
483:	) ; 
487:	size_t __cdecl _strxfrm_l ( 
488:	char * _Destination , 
489:	char const * _Source , 
490:	size_t _MaxCount , 
491:	_locale_t _Locale 
492:	) ; 
531:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details." ) ) 
532:	char * __cdecl strdup ( 
533:	char const * _String 
534:	) ; 
538:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details." ) ) 
539:	int __cdecl strcmpi ( 
540:	char const * _String1 , 
541:	char const * _String2 
542:	) ; 
544:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details." ) ) 
545:	int __cdecl stricmp ( 
546:	char const * _String1 , 
547:	char const * _String2 
548:	) ; 
550:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details." ) ) 
551:	char * __cdecl strlwr ( 
552:	char * _String 
553:	) ; 
555:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details." ) ) 
556:	int __cdecl strnicmp ( 
557:	char const * _String1 , 
558:	char const * _String2 , 
559:	size_t _MaxCount 
560:	) ; 
562:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details." ) ) 
563:	char * __cdecl strnset ( 
564:	char * _String , 
565:	int _Value , 
566:	size_t _MaxCount 
567:	) ; 
569:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details." ) ) 
570:	char * __cdecl strrev ( 
571:	char * _String 
572:	) ; 
574:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details." ) ) 
575:	char * __cdecl strset ( 
576:	char * _String , 
577:	int _Value ) ; 
579:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details." ) ) 
580:	char * __cdecl strupr ( 
581:	char * _String 
582:	) ; 
588:	_Pragma ( pack ( pop ) ) 
 18:	_Pragma ( pack ( push , 8 ) ) 
 23:	struct _exception 
 24:	{ 
 25:	int type ; 
 26:	char * name ; 
 27:	double arg1 ; 
 28:	double arg2 ; 
 29:	double retval ; 
 30:	} ; 
 37:	struct _complex 
 38:	{ 
 39:	double x , y ; 
 40:	} ; 
 59:	typedef float float_t ; 
 60:	typedef double double_t ; 
 78:	extern double const _HUGE ; 
169:	void __cdecl _fperrraise ( int _Except ) ; 
171:	short __cdecl _dclass ( double _X ) ; 
172:	short __cdecl _ldclass ( long double _X ) ; 
173:	short __cdecl _fdclass ( float _X ) ; 
175:	int __cdecl _dsign ( double _X ) ; 
176:	int __cdecl _ldsign ( long double _X ) ; 
177:	int __cdecl _fdsign ( float _X ) ; 
179:	int __cdecl _dpcomp ( double _X , double _Y ) ; 
180:	int __cdecl _ldpcomp ( long double _X , long double _Y ) ; 
181:	int __cdecl _fdpcomp ( float _X , float _Y ) ; 
183:	short __cdecl _dtest ( double * _Px ) ; 
184:	short __cdecl _ldtest ( long double * _Px ) ; 
185:	short __cdecl _fdtest ( float * _Px ) ; 
187:	short __cdecl _d_int ( double * _Px , short _Xexp ) ; 
188:	short __cdecl _ld_int ( long double * _Px , short _Xexp ) ; 
189:	short __cdecl _fd_int ( float * _Px , short _Xexp ) ; 
191:	short __cdecl _dscale ( double * _Px , long _Lexp ) ; 
192:	short __cdecl _ldscale ( long double * _Px , long _Lexp ) ; 
193:	short __cdecl _fdscale ( float * _Px , long _Lexp ) ; 
195:	short __cdecl _dunscale ( short * _Pex , double * _Px ) ; 
196:	short __cdecl _ldunscale ( short * _Pex , long double * _Px ) ; 
197:	short __cdecl _fdunscale ( short * _Pex , float * _Px ) ; 
199:	short __cdecl _dexp ( double * _Px , double _Y , long _Eoff ) ; 
200:	short __cdecl _ldexp ( long double * _Px , long double _Y , long _Eoff ) ; 
201:	short __cdecl _fdexp ( float * _Px , float _Y , long _Eoff ) ; 
203:	short __cdecl _dnorm ( unsigned short * _Ps ) ; 
204:	short __cdecl _fdnorm ( unsigned short * _Ps ) ; 
206:	double __cdecl _dpoly ( double _X , double const * _Tab , int _N ) ; 
207:	long double __cdecl _ldpoly ( long double _X , long double const * _Tab , int _N ) ; 
208:	float __cdecl _fdpoly ( float _X , float const * _Tab , int _N ) ; 
210:	double __cdecl _dlog ( double _X , int _Baseflag ) ; 
211:	long double __cdecl _ldlog ( long double _X , int _Baseflag ) ; 
212:	float __cdecl _fdlog ( float _X , int _Baseflag ) ; 
214:	double __cdecl _dsin ( double _X , unsigned int _Qoff ) ; 
215:	long double __cdecl _ldsin ( long double _X , unsigned int _Qoff ) ; 
216:	float __cdecl _fdsin ( float _X , unsigned int _Qoff ) ; 
219:	typedef union 
220:	{ 
221:	unsigned short _Sh [ 4 ] ; 
222:	double _Val ; 
223:	} _double_val ; 
226:	typedef union 
227:	{ 
228:	unsigned short _Sh [ 2 ] ; 
229:	float _Val ; 
230:	} _float_val ; 
233:	typedef union 
234:	{ 
235:	unsigned short _Sh [ 4 ] ; 
236:	long double _Val ; 
237:	} _ldouble_val ; 
239:	typedef union 
240:	{ 
241:	unsigned short _Word [ 4 ] ; 
242:	float _Float ; 
243:	double _Double ; 
244:	long double _Long_double ; 
245:	} _float_const ; 
247:	extern const _float_const _Denorm_C , _Inf_C , _Nan_C , _Snan_C , _Hugeval_C ; 
248:	extern const _float_const _FDenorm_C , _FInf_C , _FNan_C , _FSnan_C ; 
249:	extern const _float_const _LDenorm_C , _LInf_C , _LNan_C , _LSnan_C ; 
251:	extern const _float_const _Eps_C , _Rteps_C ; 
252:	extern const _float_const _FEps_C , _FRteps_C ; 
253:	extern const _float_const _LEps_C , _LRteps_C ; 
255:	extern const double _Zero_C , _Xbig_C ; 
256:	extern const float _FZero_C , _FXbig_C ; 
257:	extern const long double _LZero_C , _LXbig_C ; 
464:	int __cdecl abs ( int _X ) ; 
465:	long __cdecl labs ( long _X ) ; 
466:	long long __cdecl llabs ( long long _X ) ; 
468:	double __cdecl acos ( double _X ) ; 
469:	double __cdecl asin ( double _X ) ; 
470:	double __cdecl atan ( double _X ) ; 
471:	double __cdecl atan2 ( double _Y , double _X ) ; 
473:	double __cdecl cos ( double _X ) ; 
474:	double __cdecl cosh ( double _X ) ; 
475:	double __cdecl exp ( double _X ) ; 
476:	double __cdecl fabs ( double _X ) ; 
477:	double __cdecl fmod ( double _X , double _Y ) ; 
478:	double __cdecl log ( double _X ) ; 
479:	double __cdecl log10 ( double _X ) ; 
480:	double __cdecl pow ( double _X , double _Y ) ; 
481:	double __cdecl sin ( double _X ) ; 
482:	double __cdecl sinh ( double _X ) ; 
483:	double __cdecl sqrt ( double _X ) ; 
484:	double __cdecl tan ( double _X ) ; 
485:	double __cdecl tanh ( double _X ) ; 
487:	double __cdecl acosh ( double _X ) ; 
488:	double __cdecl asinh ( double _X ) ; 
489:	double __cdecl atanh ( double _X ) ; 
490:	double __cdecl atof ( char const * _String ) ; 
491:	double __cdecl _atof_l ( char const * _String , _locale_t _Locale ) ; 
492:	double __cdecl _cabs ( struct _complex _Complex_value ) ; 
493:	double __cdecl cbrt ( double _X ) ; 
494:	double __cdecl ceil ( double _X ) ; 
495:	double __cdecl _chgsign ( double _X ) ; 
496:	double __cdecl copysign ( double _Number , double _Sign ) ; 
497:	double __cdecl _copysign ( double _Number , double _Sign ) ; 
498:	double __cdecl erf ( double _X ) ; 
499:	double __cdecl erfc ( double _X ) ; 
500:	double __cdecl exp2 ( double _X ) ; 
501:	double __cdecl expm1 ( double _X ) ; 
502:	double __cdecl fdim ( double _X , double _Y ) ; 
503:	double __cdecl floor ( double _X ) ; 
504:	double __cdecl fma ( double _X , double _Y , double _Z ) ; 
505:	double __cdecl fmax ( double _X , double _Y ) ; 
506:	double __cdecl fmin ( double _X , double _Y ) ; 
507:	double __cdecl frexp ( double _X , int * _Y ) ; 
508:	double __cdecl hypot ( double _X , double _Y ) ; 
509:	double __cdecl _hypot ( double _X , double _Y ) ; 
510:	int __cdecl ilogb ( double _X ) ; 
511:	double __cdecl ldexp ( double _X , int _Y ) ; 
512:	double __cdecl lgamma ( double _X ) ; 
513:	long long __cdecl llrint ( double _X ) ; 
514:	long long __cdecl llround ( double _X ) ; 
515:	double __cdecl log1p ( double _X ) ; 
516:	double __cdecl log2 ( double _X ) ; 
517:	double __cdecl logb ( double _X ) ; 
518:	long __cdecl lrint ( double _X ) ; 
519:	long __cdecl lround ( double _X ) ; 
521:	int __cdecl _matherr ( struct _exception * _Except ) ; 
523:	double __cdecl modf ( double _X , double * _Y ) ; 
524:	double __cdecl nan ( char const * _X ) ; 
525:	double __cdecl nearbyint ( double _X ) ; 
526:	double __cdecl nextafter ( double _X , double _Y ) ; 
527:	double __cdecl nexttoward ( double _X , long double _Y ) ; 
528:	double __cdecl remainder ( double _X , double _Y ) ; 
529:	double __cdecl remquo ( double _X , double _Y , int * _Z ) ; 
530:	double __cdecl rint ( double _X ) ; 
531:	double __cdecl round ( double _X ) ; 
532:	double __cdecl scalbln ( double _X , long _Y ) ; 
533:	double __cdecl scalbn ( double _X , int _Y ) ; 
534:	double __cdecl tgamma ( double _X ) ; 
535:	double __cdecl trunc ( double _X ) ; 
536:	double __cdecl _j0 ( double _X ) ; 
537:	double __cdecl _j1 ( double _X ) ; 
538:	double __cdecl _jn ( int _X , double _Y ) ; 
539:	double __cdecl _y0 ( double _X ) ; 
540:	double __cdecl _y1 ( double _X ) ; 
541:	double __cdecl _yn ( int _X , double _Y ) ; 
543:	float __cdecl acoshf ( float _X ) ; 
544:	float __cdecl asinhf ( float _X ) ; 
545:	float __cdecl atanhf ( float _X ) ; 
546:	float __cdecl cbrtf ( float _X ) ; 
547:	float __cdecl _chgsignf ( float _X ) ; 
548:	float __cdecl copysignf ( float _Number , float _Sign ) ; 
549:	float __cdecl _copysignf ( float _Number , float _Sign ) ; 
550:	float __cdecl erff ( float _X ) ; 
551:	float __cdecl erfcf ( float _X ) ; 
552:	float __cdecl expm1f ( float _X ) ; 
553:	float __cdecl exp2f ( float _X ) ; 
554:	float __cdecl fdimf ( float _X , float _Y ) ; 
555:	float __cdecl fmaf ( float _X , float _Y , float _Z ) ; 
556:	float __cdecl fmaxf ( float _X , float _Y ) ; 
557:	float __cdecl fminf ( float _X , float _Y ) ; 
558:	float __cdecl _hypotf ( float _X , float _Y ) ; 
559:	int __cdecl ilogbf ( float _X ) ; 
560:	float __cdecl lgammaf ( float _X ) ; 
561:	long long __cdecl llrintf ( float _X ) ; 
562:	long long __cdecl llroundf ( float _X ) ; 
563:	float __cdecl log1pf ( float _X ) ; 
564:	float __cdecl log2f ( float _X ) ; 
565:	float __cdecl logbf ( float _X ) ; 
566:	long __cdecl lrintf ( float _X ) ; 
567:	long __cdecl lroundf ( float _X ) ; 
568:	float __cdecl nanf ( char const * _X ) ; 
569:	float __cdecl nearbyintf ( float _X ) ; 
570:	float __cdecl nextafterf ( float _X , float _Y ) ; 
571:	float __cdecl nexttowardf ( float _X , long double _Y ) ; 
572:	float __cdecl remainderf ( float _X , float _Y ) ; 
573:	float __cdecl remquof ( float _X , float _Y , int * _Z ) ; 
574:	float __cdecl rintf ( float _X ) ; 
575:	float __cdecl roundf ( float _X ) ; 
576:	float __cdecl scalblnf ( float _X , long _Y ) ; 
577:	float __cdecl scalbnf ( float _X , int _Y ) ; 
578:	float __cdecl tgammaf ( float _X ) ; 
579:	float __cdecl truncf ( float _X ) ; 
589:	float __cdecl _logbf ( float _X ) ; 
590:	float __cdecl _nextafterf ( float _X , float _Y ) ; 
591:	int __cdecl _finitef ( float _X ) ; 
592:	int __cdecl _isnanf ( float _X ) ; 
593:	int __cdecl _fpclassf ( float _X ) ; 
595:	int __cdecl _set_FMA3_enable ( int _Flag ) ; 
596:	int __cdecl _get_FMA3_enable ( void ) ; 
609:	float __cdecl acosf ( float _X ) ; 
610:	float __cdecl asinf ( float _X ) ; 
611:	float __cdecl atan2f ( float _Y , float _X ) ; 
612:	float __cdecl atanf ( float _X ) ; 
613:	float __cdecl ceilf ( float _X ) ; 
614:	float __cdecl cosf ( float _X ) ; 
615:	float __cdecl coshf ( float _X ) ; 
616:	float __cdecl expf ( float _X ) ; 
668:	inline float __cdecl fabsf ( float _X ) 
669:	{ 
670:	return ( float ) fabs ( _X ) ; 
671:	} 
677:	float __cdecl floorf ( float _X ) ; 
678:	float __cdecl fmodf ( float _X , float _Y ) ; 
694:	inline float __cdecl frexpf ( float _X , int * _Y ) 
695:	{ 
696:	return ( float ) frexp ( _X , _Y ) ; 
697:	} 
699:	inline float __cdecl hypotf ( float _X , float _Y ) 
700:	{ 
701:	return _hypotf ( _X , _Y ) ; 
702:	} 
704:	inline float __cdecl ldexpf ( float _X , int _Y ) 
705:	{ 
706:	return ( float ) ldexp ( _X , _Y ) ; 
707:	} 
711:	float __cdecl log10f ( float _X ) ; 
712:	float __cdecl logf ( float _X ) ; 
713:	float __cdecl modff ( float _X , float * _Y ) ; 
714:	float __cdecl powf ( float _X , float _Y ) ; 
715:	float __cdecl sinf ( float _X ) ; 
716:	float __cdecl sinhf ( float _X ) ; 
717:	float __cdecl sqrtf ( float _X ) ; 
718:	float __cdecl tanf ( float _X ) ; 
719:	float __cdecl tanhf ( float _X ) ; 
773:	long double __cdecl acoshl ( long double _X ) ; 
775:	inline long double __cdecl acosl ( long double _X ) 
776:	{ 
777:	return acos ( ( double ) _X ) ; 
778:	} 
780:	long double __cdecl asinhl ( long double _X ) ; 
782:	inline long double __cdecl asinl ( long double _X ) 
783:	{ 
784:	return asin ( ( double ) _X ) ; 
785:	} 
787:	inline long double __cdecl atan2l ( long double _Y , long double _X ) 
788:	{ 
789:	return atan2 ( ( double ) _Y , ( double ) _X ) ; 
790:	} 
792:	long double __cdecl atanhl ( long double _X ) ; 
794:	inline long double __cdecl atanl ( long double _X ) 
795:	{ 
796:	return atan ( ( double ) _X ) ; 
797:	} 
799:	long double __cdecl cbrtl ( long double _X ) ; 
801:	inline long double __cdecl ceill ( long double _X ) 
802:	{ 
803:	return ceil ( ( double ) _X ) ; 
804:	} 
806:	inline long double __cdecl _chgsignl ( long double _X ) 
807:	{ 
808:	return _chgsign ( ( double ) _X ) ; 
809:	} 
811:	long double __cdecl copysignl ( long double _Number , long double _Sign ) ; 
813:	inline long double __cdecl _copysignl ( long double _Number , long double _Sign ) 
814:	{ 
815:	return _copysign ( ( double ) _Number , ( double ) _Sign ) ; 
816:	} 
818:	inline long double __cdecl coshl ( long double _X ) 
819:	{ 
820:	return cosh ( ( double ) _X ) ; 
821:	} 
823:	inline long double __cdecl cosl ( long double _X ) 
824:	{ 
825:	return cos ( ( double ) _X ) ; 
826:	} 
828:	long double __cdecl erfl ( long double _X ) ; 
829:	long double __cdecl erfcl ( long double _X ) ; 
831:	inline long double __cdecl expl ( long double _X ) 
832:	{ 
833:	return exp ( ( double ) _X ) ; 
834:	} 
836:	long double __cdecl exp2l ( long double _X ) ; 
837:	long double __cdecl expm1l ( long double _X ) ; 
839:	inline long double __cdecl fabsl ( long double _X ) 
840:	{ 
841:	return fabs ( ( double ) _X ) ; 
842:	} 
844:	long double __cdecl fdiml ( long double _X , long double _Y ) ; 
846:	inline long double __cdecl floorl ( long double _X ) 
847:	{ 
848:	return floor ( ( double ) _X ) ; 
849:	} 
851:	long double __cdecl fmal ( long double _X , long double _Y , long double _Z ) ; 
852:	long double __cdecl fmaxl ( long double _X , long double _Y ) ; 
853:	long double __cdecl fminl ( long double _X , long double _Y ) ; 
855:	inline long double __cdecl fmodl ( long double _X , long double _Y ) 
856:	{ 
857:	return fmod ( ( double ) _X , ( double ) _Y ) ; 
858:	} 
860:	inline long double __cdecl frexpl ( long double _X , int * _Y ) 
861:	{ 
862:	return frexp ( ( double ) _X , _Y ) ; 
863:	} 
865:	int __cdecl ilogbl ( long double _X ) ; 
867:	inline long double __cdecl _hypotl ( long double _X , long double _Y ) 
868:	{ 
869:	return _hypot ( ( double ) _X , ( double ) _Y ) ; 
870:	} 
872:	inline long double __cdecl hypotl ( long double _X , long double _Y ) 
873:	{ 
874:	return _hypot ( ( double ) _X , ( double ) _Y ) ; 
875:	} 
877:	inline long double __cdecl ldexpl ( long double _X , int _Y ) 
878:	{ 
879:	return ldexp ( ( double ) _X , _Y ) ; 
880:	} 
882:	long double __cdecl lgammal ( long double _X ) ; 
883:	long long __cdecl llrintl ( long double _X ) ; 
884:	long long __cdecl llroundl ( long double _X ) ; 
886:	inline long double __cdecl logl ( long double _X ) 
887:	{ 
888:	return log ( ( double ) _X ) ; 
889:	} 
891:	inline long double __cdecl log10l ( long double _X ) 
892:	{ 
893:	return log10 ( ( double ) _X ) ; 
894:	} 
896:	long double __cdecl log1pl ( long double _X ) ; 
897:	long double __cdecl log2l ( long double _X ) ; 
898:	long double __cdecl logbl ( long double _X ) ; 
899:	long __cdecl lrintl ( long double _X ) ; 
900:	long __cdecl lroundl ( long double _X ) ; 
902:	inline long double __cdecl modfl ( long double _X , long double * _Y ) 
903:	{ 
904:	double _F , _I ; 
905:	_F = modf ( ( double ) _X , & _I ) ; 
906:	* _Y = _I ; 
907:	return _F ; 
908:	} 
910:	long double __cdecl nanl ( char const * _X ) ; 
911:	long double __cdecl nearbyintl ( long double _X ) ; 
912:	long double __cdecl nextafterl ( long double _X , long double _Y ) ; 
913:	long double __cdecl nexttowardl ( long double _X , long double _Y ) ; 
915:	inline long double __cdecl powl ( long double _X , long double _Y ) 
916:	{ 
917:	return pow ( ( double ) _X , ( double ) _Y ) ; 
918:	} 
920:	long double __cdecl remainderl ( long double _X , long double _Y ) ; 
921:	long double __cdecl remquol ( long double _X , long double _Y , int * _Z ) ; 
922:	long double __cdecl rintl ( long double _X ) ; 
923:	long double __cdecl roundl ( long double _X ) ; 
924:	long double __cdecl scalblnl ( long double _X , long _Y ) ; 
925:	long double __cdecl scalbnl ( long double _X , int _Y ) ; 
927:	inline long double __cdecl sinhl ( long double _X ) 
928:	{ 
929:	return sinh ( ( double ) _X ) ; 
930:	} 
932:	inline long double __cdecl sinl ( long double _X ) 
933:	{ 
934:	return sin ( ( double ) _X ) ; 
935:	} 
937:	inline long double __cdecl sqrtl ( long double _X ) 
938:	{ 
939:	return sqrt ( ( double ) _X ) ; 
940:	} 
942:	inline long double __cdecl tanhl ( long double _X ) 
943:	{ 
944:	return tanh ( ( double ) _X ) ; 
945:	} 
947:	inline long double __cdecl tanl ( long double _X ) 
948:	{ 
949:	return tan ( ( double ) _X ) ; 
950:	} 
952:	long double __cdecl tgammal ( long double _X ) ; 
953:	long double __cdecl truncl ( long double _X ) ; 
974:	extern double HUGE ; 
979:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details." ) ) double __cdecl j0 ( double _X ) ; 
980:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details." ) ) double __cdecl j1 ( double _X ) ; 
981:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details." ) ) double __cdecl jn ( int _X , double _Y ) ; 
982:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details." ) ) double __cdecl y0 ( double _X ) ; 
983:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details." ) ) double __cdecl y1 ( double _X ) ; 
984:	__declspec ( deprecated ( "The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details." ) ) double __cdecl yn ( int _X , double _Y ) ; 
989:	_Pragma ( pack ( pop ) ) 
 18:	_Pragma ( pack ( push , 8 ) ) 
 30:	void __cdecl _wassert ( 
 31:	wchar_t const * _Message , 
 32:	wchar_t const * _File , 
 33:	unsigned _Line 
 34:	) ; 
 42:	_Pragma ( pack ( pop ) ) 
 18:	typedef signed char int8_t ; 
 19:	typedef short int16_t ; 
 20:	typedef int int32_t ; 
 21:	typedef long long int64_t ; 
 22:	typedef unsigned char uint8_t ; 
 23:	typedef unsigned short uint16_t ; 
 24:	typedef unsigned int uint32_t ; 
 25:	typedef unsigned long long uint64_t ; 
 27:	typedef signed char int_least8_t ; 
 28:	typedef short int_least16_t ; 
 29:	typedef int int_least32_t ; 
 30:	typedef long long int_least64_t ; 
 31:	typedef unsigned char uint_least8_t ; 
 32:	typedef unsigned short uint_least16_t ; 
 33:	typedef unsigned int uint_least32_t ; 
 34:	typedef unsigned long long uint_least64_t ; 
 36:	typedef signed char int_fast8_t ; 
 37:	typedef int int_fast16_t ; 
 38:	typedef int int_fast32_t ; 
 39:	typedef long long int_fast64_t ; 
 40:	typedef unsigned char uint_fast8_t ; 
 41:	typedef unsigned int uint_fast16_t ; 
 42:	typedef unsigned int uint_fast32_t ; 
 43:	typedef unsigned long long uint_fast64_t ; 
 45:	typedef long long intmax_t ; 
 46:	typedef unsigned long long uintmax_t ; 
494:	typedef uint16_t stbi__uint16 ; 
495:	typedef int16_t stbi__int16 ; 
496:	typedef uint32_t stbi__uint32 ; 
497:	typedef int32_t stbi__int32 ; 
501:	typedef unsigned char validate_uint32 [ sizeof ( stbi__uint32 ) == 4 ? 1 : - 1 ] ; 
 23:	typedef union __declspec ( intrin_type ) __declspec ( align ( 8 ) ) __m64 
 24:	{ 
 25:	unsigned long long m64_u64 ; 
 26:	float m64_f32 [ 2 ] ; 
 27:	__int8 m64_i8 [ 8 ] ; 
 28:	__int16 m64_i16 [ 4 ] ; 
 29:	__int32 m64_i32 [ 2 ] ; 
 30:	long long m64_i64 ; 
 31:	unsigned __int8 m64_u8 [ 8 ] ; 
 32:	unsigned __int16 m64_u16 [ 4 ] ; 
 33:	unsigned __int32 m64_u32 [ 2 ] ; 
 34:	} __m64 ; 
 40:	typedef union __declspec ( intrin_type ) __declspec ( align ( 16 ) ) __m128 { 
 41:	float m128_f32 [ 4 ] ; 
 42:	unsigned long long m128_u64 [ 2 ] ; 
 43:	__int8 m128_i8 [ 16 ] ; 
 44:	__int16 m128_i16 [ 8 ] ; 
 45:	__int32 m128_i32 [ 4 ] ; 
 46:	long long m128_i64 [ 2 ] ; 
 47:	unsigned __int8 m128_u8 [ 16 ] ; 
 48:	unsigned __int16 m128_u16 [ 8 ] ; 
 49:	unsigned __int32 m128_u32 [ 4 ] ; 
 50:	} __m128 ; 
 19:	_Pragma ( pack ( push , 8 ) ) 
 42:	typedef struct _heapinfo 
 43:	{ 
 44:	int * _pentry ; 
 45:	size_t _size ; 
 46:	int _useflag ; 
 47:	} _HEAPINFO ; 
 55:	void * __cdecl _alloca ( size_t _Size ) ; 
 61:	intptr_t __cdecl _get_heap_handle ( void ) ; 
 64:	int __cdecl _heapmin ( void ) ; 
 67:	int __cdecl _heapwalk ( _HEAPINFO * _EntryInfo ) ; 
 71:	int __cdecl _heapchk ( void ) ; 
 74:	int __cdecl _resetstkoflw ( void ) ; 
 86:	typedef char __static_assert_t [ ( sizeof ( unsigned int ) <= 16 ) != 0 ] ; 
 93:	inline void * _MarkAllocaS ( void * _Ptr , unsigned int _Marker ) 
 94:	{ 
 95:	if ( _Ptr ) 
 96:	{ 
 97:	* ( ( unsigned int * ) _Ptr ) = _Marker ; 
 98:	_Ptr = ( char * ) _Ptr + 16 ; 
 99:	} 
100:	return _Ptr ; 
101:	} 
103:	inline size_t _MallocaComputeSize ( size_t _Size ) 
104:	{ 
105:	size_t _MarkedSize = _Size + 16 ; 
106:	return _MarkedSize > _Size ? _MarkedSize : 0 ; 
107:	} 
140:	inline void __cdecl _freea ( void * _Memory ) 
141:	{ 
142:	unsigned int _Marker ; 
143:	if ( _Memory ) 
144:	{ 
145:	_Memory = ( char * ) _Memory - 16 ; 
146:	_Marker = * ( unsigned int * ) _Memory ; 
147:	if ( _Marker == 0xDDDD ) 
148:	{ 
149:	free ( _Memory ) ; 
150:	} 
157:	} 
158:	} 
171:	_Pragma ( pack ( pop ) ) 
148:	extern __m128 _mm_add_ss ( __m128 _A , __m128 _B ) ; 
149:	extern __m128 _mm_add_ps ( __m128 _A , __m128 _B ) ; 
150:	extern __m128 _mm_sub_ss ( __m128 _A , __m128 _B ) ; 
151:	extern __m128 _mm_sub_ps ( __m128 _A , __m128 _B ) ; 
152:	extern __m128 _mm_mul_ss ( __m128 _A , __m128 _B ) ; 
153:	extern __m128 _mm_mul_ps ( __m128 _A , __m128 _B ) ; 
154:	extern __m128 _mm_div_ss ( __m128 _A , __m128 _B ) ; 
155:	extern __m128 _mm_div_ps ( __m128 _A , __m128 _B ) ; 
156:	extern __m128 _mm_sqrt_ss ( __m128 _A ) ; 
157:	extern __m128 _mm_sqrt_ps ( __m128 _A ) ; 
158:	extern __m128 _mm_rcp_ss ( __m128 _A ) ; 
159:	extern __m128 _mm_rcp_ps ( __m128 _A ) ; 
160:	extern __m128 _mm_rsqrt_ss ( __m128 _A ) ; 
161:	extern __m128 _mm_rsqrt_ps ( __m128 _A ) ; 
162:	extern __m128 _mm_min_ss ( __m128 _A , __m128 _B ) ; 
163:	extern __m128 _mm_min_ps ( __m128 _A , __m128 _B ) ; 
164:	extern __m128 _mm_max_ss ( __m128 _A , __m128 _B ) ; 
165:	extern __m128 _mm_max_ps ( __m128 _A , __m128 _B ) ; 
169:	extern __m128 _mm_and_ps ( __m128 _A , __m128 _B ) ; 
170:	extern __m128 _mm_andnot_ps ( __m128 _A , __m128 _B ) ; 
171:	extern __m128 _mm_or_ps ( __m128 _A , __m128 _B ) ; 
172:	extern __m128 _mm_xor_ps ( __m128 _A , __m128 _B ) ; 
176:	extern __m128 _mm_cmpeq_ss ( __m128 _A , __m128 _B ) ; 
177:	extern __m128 _mm_cmpeq_ps ( __m128 _A , __m128 _B ) ; 
178:	extern __m128 _mm_cmplt_ss ( __m128 _A , __m128 _B ) ; 
179:	extern __m128 _mm_cmplt_ps ( __m128 _A , __m128 _B ) ; 
180:	extern __m128 _mm_cmple_ss ( __m128 _A , __m128 _B ) ; 
181:	extern __m128 _mm_cmple_ps ( __m128 _A , __m128 _B ) ; 
182:	extern __m128 _mm_cmpgt_ss ( __m128 _A , __m128 _B ) ; 
183:	extern __m128 _mm_cmpgt_ps ( __m128 _A , __m128 _B ) ; 
184:	extern __m128 _mm_cmpge_ss ( __m128 _A , __m128 _B ) ; 
185:	extern __m128 _mm_cmpge_ps ( __m128 _A , __m128 _B ) ; 
186:	extern __m128 _mm_cmpneq_ss ( __m128 _A , __m128 _B ) ; 
187:	extern __m128 _mm_cmpneq_ps ( __m128 _A , __m128 _B ) ; 
188:	extern __m128 _mm_cmpnlt_ss ( __m128 _A , __m128 _B ) ; 
189:	extern __m128 _mm_cmpnlt_ps ( __m128 _A , __m128 _B ) ; 
190:	extern __m128 _mm_cmpnle_ss ( __m128 _A , __m128 _B ) ; 
191:	extern __m128 _mm_cmpnle_ps ( __m128 _A , __m128 _B ) ; 
192:	extern __m128 _mm_cmpngt_ss ( __m128 _A , __m128 _B ) ; 
193:	extern __m128 _mm_cmpngt_ps ( __m128 _A , __m128 _B ) ; 
194:	extern __m128 _mm_cmpnge_ss ( __m128 _A , __m128 _B ) ; 
195:	extern __m128 _mm_cmpnge_ps ( __m128 _A , __m128 _B ) ; 
196:	extern __m128 _mm_cmpord_ss ( __m128 _A , __m128 _B ) ; 
197:	extern __m128 _mm_cmpord_ps ( __m128 _A , __m128 _B ) ; 
198:	extern __m128 _mm_cmpunord_ss ( __m128 _A , __m128 _B ) ; 
199:	extern __m128 _mm_cmpunord_ps ( __m128 _A , __m128 _B ) ; 
200:	extern int _mm_comieq_ss ( __m128 _A , __m128 _B ) ; 
201:	extern int _mm_comilt_ss ( __m128 _A , __m128 _B ) ; 
202:	extern int _mm_comile_ss ( __m128 _A , __m128 _B ) ; 
203:	extern int _mm_comigt_ss ( __m128 _A , __m128 _B ) ; 
204:	extern int _mm_comige_ss ( __m128 _A , __m128 _B ) ; 
205:	extern int _mm_comineq_ss ( __m128 _A , __m128 _B ) ; 
206:	extern int _mm_ucomieq_ss ( __m128 _A , __m128 _B ) ; 
207:	extern int _mm_ucomilt_ss ( __m128 _A , __m128 _B ) ; 
208:	extern int _mm_ucomile_ss ( __m128 _A , __m128 _B ) ; 
209:	extern int _mm_ucomigt_ss ( __m128 _A , __m128 _B ) ; 
210:	extern int _mm_ucomige_ss ( __m128 _A , __m128 _B ) ; 
211:	extern int _mm_ucomineq_ss ( __m128 _A , __m128 _B ) ; 
215:	extern int _mm_cvt_ss2si ( __m128 _A ) ; 
216:	extern int _mm_cvtt_ss2si ( __m128 _A ) ; 
217:	extern __m128 _mm_cvt_si2ss ( __m128 , int ) ; 
218:	extern float _mm_cvtss_f32 ( __m128 _A ) ; 
229:	extern long long _mm_cvtss_si64 ( __m128 _A ) ; 
230:	extern long long _mm_cvttss_si64 ( __m128 _A ) ; 
231:	extern __m128 _mm_cvtsi64_ss ( __m128 _A , long long _B ) ; 
236:	extern __m128 _mm_shuffle_ps ( __m128 _A , __m128 _B , unsigned int _Imm8 ) ; 
237:	extern __m128 _mm_unpackhi_ps ( __m128 _A , __m128 _B ) ; 
238:	extern __m128 _mm_unpacklo_ps ( __m128 _A , __m128 _B ) ; 
239:	extern __m128 _mm_loadh_pi ( __m128 , __m64 const * ) ; 
240:	extern __m128 _mm_movehl_ps ( __m128 , __m128 ) ; 
241:	extern __m128 _mm_movelh_ps ( __m128 , __m128 ) ; 
242:	extern void _mm_storeh_pi ( __m64 * , __m128 ) ; 
243:	extern __m128 _mm_loadl_pi ( __m128 , __m64 const * ) ; 
244:	extern void _mm_storel_pi ( __m64 * , __m128 ) ; 
245:	extern int _mm_movemask_ps ( __m128 _A ) ; 
267:	extern __m128 _mm_set_ss ( float _A ) ; 
268:	extern __m128 _mm_set_ps1 ( float _A ) ; 
269:	extern __m128 _mm_set_ps ( float _A , float _B , float _C , float _D ) ; 
270:	extern __m128 _mm_setr_ps ( float _A , float _B , float _C , float _D ) ; 
271:	extern __m128 _mm_setzero_ps ( void ) ; 
272:	extern __m128 _mm_load_ss ( float const * _A ) ; 
273:	extern __m128 _mm_load_ps1 ( float const * _A ) ; 
274:	extern __m128 _mm_load_ps ( float const * _A ) ; 
275:	extern __m128 _mm_loadr_ps ( float const * _A ) ; 
276:	extern __m128 _mm_loadu_ps ( float const * _A ) ; 
277:	extern void _mm_store_ss ( float * _V , __m128 _A ) ; 
278:	extern void _mm_store_ps1 ( float * _V , __m128 _A ) ; 
279:	extern void _mm_store_ps ( float * _V , __m128 _A ) ; 
280:	extern void _mm_storer_ps ( float * _V , __m128 _A ) ; 
281:	extern void _mm_storeu_ps ( float * _V , __m128 _A ) ; 
282:	extern void _mm_prefetch ( char const * _A , int _Sel ) ; 
286:	extern void _mm_stream_ps ( float * , __m128 ) ; 
287:	extern __m128 _mm_move_ss ( __m128 _A , __m128 _B ) ; 
289:	extern void _mm_sfence ( void ) ; 
290:	extern unsigned int _mm_getcsr ( void ) ; 
291:	extern void _mm_setcsr ( unsigned int ) ; 
 26:	typedef union __declspec ( intrin_type ) __declspec ( align ( 16 ) ) __m128i { 
 27:	__int8 m128i_i8 [ 16 ] ; 
 28:	__int16 m128i_i16 [ 8 ] ; 
 29:	__int32 m128i_i32 [ 4 ] ; 
 30:	long long m128i_i64 [ 2 ] ; 
 31:	unsigned __int8 m128i_u8 [ 16 ] ; 
 32:	unsigned __int16 m128i_u16 [ 8 ] ; 
 33:	unsigned __int32 m128i_u32 [ 4 ] ; 
 34:	unsigned long long m128i_u64 [ 2 ] ; 
 35:	} __m128i ; 
 37:	typedef struct __declspec ( intrin_type ) __declspec ( align ( 16 ) ) __m128d { 
 38:	double m128d_f64 [ 2 ] ; 
 39:	} __m128d ; 
 55:	extern __m128d _mm_add_sd ( __m128d _A , __m128d _B ) ; 
 56:	extern __m128d _mm_add_pd ( __m128d _A , __m128d _B ) ; 
 57:	extern __m128d _mm_sub_sd ( __m128d _A , __m128d _B ) ; 
 58:	extern __m128d _mm_sub_pd ( __m128d _A , __m128d _B ) ; 
 59:	extern __m128d _mm_mul_sd ( __m128d _A , __m128d _B ) ; 
 60:	extern __m128d _mm_mul_pd ( __m128d _A , __m128d _B ) ; 
 61:	extern __m128d _mm_sqrt_sd ( __m128d _A , __m128d _B ) ; 
 62:	extern __m128d _mm_sqrt_pd ( __m128d _A ) ; 
 63:	extern __m128d _mm_div_sd ( __m128d _A , __m128d _B ) ; 
 64:	extern __m128d _mm_div_pd ( __m128d _A , __m128d _B ) ; 
 65:	extern __m128d _mm_min_sd ( __m128d _A , __m128d _B ) ; 
 66:	extern __m128d _mm_min_pd ( __m128d _A , __m128d _B ) ; 
 67:	extern __m128d _mm_max_sd ( __m128d _A , __m128d _B ) ; 
 68:	extern __m128d _mm_max_pd ( __m128d _A , __m128d _B ) ; 
 72:	extern __m128d _mm_and_pd ( __m128d _A , __m128d _B ) ; 
 73:	extern __m128d _mm_andnot_pd ( __m128d _A , __m128d _B ) ; 
 74:	extern __m128d _mm_or_pd ( __m128d _A , __m128d _B ) ; 
 75:	extern __m128d _mm_xor_pd ( __m128d _A , __m128d _B ) ; 
 79:	extern __m128d _mm_cmpeq_sd ( __m128d _A , __m128d _B ) ; 
 80:	extern __m128d _mm_cmpeq_pd ( __m128d _A , __m128d _B ) ; 
 81:	extern __m128d _mm_cmplt_sd ( __m128d _A , __m128d _B ) ; 
 82:	extern __m128d _mm_cmplt_pd ( __m128d _A , __m128d _B ) ; 
 83:	extern __m128d _mm_cmple_sd ( __m128d _A , __m128d _B ) ; 
 84:	extern __m128d _mm_cmple_pd ( __m128d _A , __m128d _B ) ; 
 85:	extern __m128d _mm_cmpgt_sd ( __m128d _A , __m128d _B ) ; 
 86:	extern __m128d _mm_cmpgt_pd ( __m128d _A , __m128d _B ) ; 
 87:	extern __m128d _mm_cmpge_sd ( __m128d _A , __m128d _B ) ; 
 88:	extern __m128d _mm_cmpge_pd ( __m128d _A , __m128d _B ) ; 
 89:	extern __m128d _mm_cmpneq_sd ( __m128d _A , __m128d _B ) ; 
 90:	extern __m128d _mm_cmpneq_pd ( __m128d _A , __m128d _B ) ; 
 91:	extern __m128d _mm_cmpnlt_sd ( __m128d _A , __m128d _B ) ; 
 92:	extern __m128d _mm_cmpnlt_pd ( __m128d _A , __m128d _B ) ; 
 93:	extern __m128d _mm_cmpnle_sd ( __m128d _A , __m128d _B ) ; 
 94:	extern __m128d _mm_cmpnle_pd ( __m128d _A , __m128d _B ) ; 
 95:	extern __m128d _mm_cmpngt_sd ( __m128d _A , __m128d _B ) ; 
 96:	extern __m128d _mm_cmpngt_pd ( __m128d _A , __m128d _B ) ; 
 97:	extern __m128d _mm_cmpnge_sd ( __m128d _A , __m128d _B ) ; 
 98:	extern __m128d _mm_cmpnge_pd ( __m128d _A , __m128d _B ) ; 
 99:	extern __m128d _mm_cmpord_pd ( __m128d _A , __m128d _B ) ; 
100:	extern __m128d _mm_cmpord_sd ( __m128d _A , __m128d _B ) ; 
101:	extern __m128d _mm_cmpunord_pd ( __m128d _A , __m128d _B ) ; 
102:	extern __m128d _mm_cmpunord_sd ( __m128d _A , __m128d _B ) ; 
103:	extern int _mm_comieq_sd ( __m128d _A , __m128d _B ) ; 
104:	extern int _mm_comilt_sd ( __m128d _A , __m128d _B ) ; 
105:	extern int _mm_comile_sd ( __m128d _A , __m128d _B ) ; 
106:	extern int _mm_comigt_sd ( __m128d _A , __m128d _B ) ; 
107:	extern int _mm_comige_sd ( __m128d _A , __m128d _B ) ; 
108:	extern int _mm_comineq_sd ( __m128d _A , __m128d _B ) ; 
109:	extern int _mm_ucomieq_sd ( __m128d _A , __m128d _B ) ; 
110:	extern int _mm_ucomilt_sd ( __m128d _A , __m128d _B ) ; 
111:	extern int _mm_ucomile_sd ( __m128d _A , __m128d _B ) ; 
112:	extern int _mm_ucomigt_sd ( __m128d _A , __m128d _B ) ; 
113:	extern int _mm_ucomige_sd ( __m128d _A , __m128d _B ) ; 
114:	extern int _mm_ucomineq_sd ( __m128d _A , __m128d _B ) ; 
118:	extern __m128d _mm_cvtepi32_pd ( __m128i _A ) ; 
119:	extern __m128i _mm_cvtpd_epi32 ( __m128d _A ) ; 
120:	extern __m128i _mm_cvttpd_epi32 ( __m128d _A ) ; 
121:	extern __m128 _mm_cvtepi32_ps ( __m128i _A ) ; 
122:	extern __m128i _mm_cvtps_epi32 ( __m128 _A ) ; 
123:	extern __m128i _mm_cvttps_epi32 ( __m128 _A ) ; 
124:	extern __m128 _mm_cvtpd_ps ( __m128d _A ) ; 
125:	extern __m128d _mm_cvtps_pd ( __m128 _A ) ; 
126:	extern __m128 _mm_cvtsd_ss ( __m128 _A , __m128d _B ) ; 
127:	extern __m128d _mm_cvtss_sd ( __m128d _A , __m128 _B ) ; 
129:	extern int _mm_cvtsd_si32 ( __m128d _A ) ; 
130:	extern int _mm_cvttsd_si32 ( __m128d _A ) ; 
131:	extern __m128d _mm_cvtsi32_sd ( __m128d _A , int _B ) ; 
141:	extern __m128d _mm_unpackhi_pd ( __m128d _A , __m128d _B ) ; 
142:	extern __m128d _mm_unpacklo_pd ( __m128d _A , __m128d _B ) ; 
143:	extern int _mm_movemask_pd ( __m128d _A ) ; 
144:	extern __m128d _mm_shuffle_pd ( __m128d _A , __m128d _B , int _I ) ; 
148:	extern __m128d _mm_load_pd ( double const * _Dp ) ; 
149:	extern __m128d _mm_load1_pd ( double const * _Dp ) ; 
150:	extern __m128d _mm_loadr_pd ( double const * _Dp ) ; 
151:	extern __m128d _mm_loadu_pd ( double const * _Dp ) ; 
152:	extern __m128d _mm_load_sd ( double const * _Dp ) ; 
153:	extern __m128d _mm_loadh_pd ( __m128d _A , double const * _Dp ) ; 
154:	extern __m128d _mm_loadl_pd ( __m128d _A , double const * _Dp ) ; 
158:	extern __m128d _mm_set_sd ( double _W ) ; 
159:	extern __m128d _mm_set1_pd ( double _A ) ; 
160:	extern __m128d _mm_set_pd ( double _Z , double _Y ) ; 
161:	extern __m128d _mm_setr_pd ( double _Y , double _Z ) ; 
162:	extern __m128d _mm_setzero_pd ( void ) ; 
163:	extern __m128d _mm_move_sd ( __m128d _A , __m128d _B ) ; 
167:	extern void _mm_store_sd ( double * _Dp , __m128d _A ) ; 
168:	extern void _mm_store1_pd ( double * _Dp , __m128d _A ) ; 
169:	extern void _mm_store_pd ( double * _Dp , __m128d _A ) ; 
170:	extern void _mm_storeu_pd ( double * _Dp , __m128d _A ) ; 
171:	extern void _mm_storer_pd ( double * _Dp , __m128d _A ) ; 
172:	extern void _mm_storeh_pd ( double * _Dp , __m128d _A ) ; 
173:	extern void _mm_storel_pd ( double * _Dp , __m128d _A ) ; 
182:	extern __m128i _mm_add_epi8 ( __m128i _A , __m128i _B ) ; 
183:	extern __m128i _mm_add_epi16 ( __m128i _A , __m128i _B ) ; 
184:	extern __m128i _mm_add_epi32 ( __m128i _A , __m128i _B ) ; 
188:	extern __m128i _mm_add_epi64 ( __m128i _A , __m128i _B ) ; 
189:	extern __m128i _mm_adds_epi8 ( __m128i _A , __m128i _B ) ; 
190:	extern __m128i _mm_adds_epi16 ( __m128i _A , __m128i _B ) ; 
191:	extern __m128i _mm_adds_epu8 ( __m128i _A , __m128i _B ) ; 
192:	extern __m128i _mm_adds_epu16 ( __m128i _A , __m128i _B ) ; 
193:	extern __m128i _mm_avg_epu8 ( __m128i _A , __m128i _B ) ; 
194:	extern __m128i _mm_avg_epu16 ( __m128i _A , __m128i _B ) ; 
195:	extern __m128i _mm_madd_epi16 ( __m128i _A , __m128i _B ) ; 
196:	extern __m128i _mm_max_epi16 ( __m128i _A , __m128i _B ) ; 
197:	extern __m128i _mm_max_epu8 ( __m128i _A , __m128i _B ) ; 
198:	extern __m128i _mm_min_epi16 ( __m128i _A , __m128i _B ) ; 
199:	extern __m128i _mm_min_epu8 ( __m128i _A , __m128i _B ) ; 
200:	extern __m128i _mm_mulhi_epi16 ( __m128i _A , __m128i _B ) ; 
201:	extern __m128i _mm_mulhi_epu16 ( __m128i _A , __m128i _B ) ; 
202:	extern __m128i _mm_mullo_epi16 ( __m128i _A , __m128i _B ) ; 
206:	extern __m128i _mm_mul_epu32 ( __m128i _A , __m128i _B ) ; 
207:	extern __m128i _mm_sad_epu8 ( __m128i _A , __m128i _B ) ; 
208:	extern __m128i _mm_sub_epi8 ( __m128i _A , __m128i _B ) ; 
209:	extern __m128i _mm_sub_epi16 ( __m128i _A , __m128i _B ) ; 
210:	extern __m128i _mm_sub_epi32 ( __m128i _A , __m128i _B ) ; 
214:	extern __m128i _mm_sub_epi64 ( __m128i _A , __m128i _B ) ; 
215:	extern __m128i _mm_subs_epi8 ( __m128i _A , __m128i _B ) ; 
216:	extern __m128i _mm_subs_epi16 ( __m128i _A , __m128i _B ) ; 
217:	extern __m128i _mm_subs_epu8 ( __m128i _A , __m128i _B ) ; 
218:	extern __m128i _mm_subs_epu16 ( __m128i _A , __m128i _B ) ; 
222:	extern __m128i _mm_and_si128 ( __m128i _A , __m128i _B ) ; 
223:	extern __m128i _mm_andnot_si128 ( __m128i _A , __m128i _B ) ; 
224:	extern __m128i _mm_or_si128 ( __m128i _A , __m128i _B ) ; 
225:	extern __m128i _mm_xor_si128 ( __m128i _A , __m128i _B ) ; 
229:	extern __m128i _mm_slli_si128 ( __m128i _A , int _Imm ) ; 
231:	extern __m128i _mm_slli_epi16 ( __m128i _A , int _Count ) ; 
232:	extern __m128i _mm_sll_epi16 ( __m128i _A , __m128i _Count ) ; 
233:	extern __m128i _mm_slli_epi32 ( __m128i _A , int _Count ) ; 
234:	extern __m128i _mm_sll_epi32 ( __m128i _A , __m128i _Count ) ; 
235:	extern __m128i _mm_slli_epi64 ( __m128i _A , int _Count ) ; 
236:	extern __m128i _mm_sll_epi64 ( __m128i _A , __m128i _Count ) ; 
237:	extern __m128i _mm_srai_epi16 ( __m128i _A , int _Count ) ; 
238:	extern __m128i _mm_sra_epi16 ( __m128i _A , __m128i _Count ) ; 
239:	extern __m128i _mm_srai_epi32 ( __m128i _A , int _Count ) ; 
240:	extern __m128i _mm_sra_epi32 ( __m128i _A , __m128i _Count ) ; 
241:	extern __m128i _mm_srli_si128 ( __m128i _A , int _Imm ) ; 
243:	extern __m128i _mm_srli_epi16 ( __m128i _A , int _Count ) ; 
244:	extern __m128i _mm_srl_epi16 ( __m128i _A , __m128i _Count ) ; 
245:	extern __m128i _mm_srli_epi32 ( __m128i _A , int _Count ) ; 
246:	extern __m128i _mm_srl_epi32 ( __m128i _A , __m128i _Count ) ; 
247:	extern __m128i _mm_srli_epi64 ( __m128i _A , int _Count ) ; 
248:	extern __m128i _mm_srl_epi64 ( __m128i _A , __m128i _Count ) ; 
252:	extern __m128i _mm_cmpeq_epi8 ( __m128i _A , __m128i _B ) ; 
253:	extern __m128i _mm_cmpeq_epi16 ( __m128i _A , __m128i _B ) ; 
254:	extern __m128i _mm_cmpeq_epi32 ( __m128i _A , __m128i _B ) ; 
255:	extern __m128i _mm_cmpgt_epi8 ( __m128i _A , __m128i _B ) ; 
256:	extern __m128i _mm_cmpgt_epi16 ( __m128i _A , __m128i _B ) ; 
257:	extern __m128i _mm_cmpgt_epi32 ( __m128i _A , __m128i _B ) ; 
258:	extern __m128i _mm_cmplt_epi8 ( __m128i _A , __m128i _B ) ; 
259:	extern __m128i _mm_cmplt_epi16 ( __m128i _A , __m128i _B ) ; 
260:	extern __m128i _mm_cmplt_epi32 ( __m128i _A , __m128i _B ) ; 
264:	extern __m128i _mm_cvtsi32_si128 ( int _A ) ; 
265:	extern int _mm_cvtsi128_si32 ( __m128i _A ) ; 
269:	extern __m128i _mm_packs_epi16 ( __m128i _A , __m128i _B ) ; 
270:	extern __m128i _mm_packs_epi32 ( __m128i _A , __m128i _B ) ; 
271:	extern __m128i _mm_packus_epi16 ( __m128i _A , __m128i _B ) ; 
272:	extern int _mm_extract_epi16 ( __m128i _A , int _Imm ) ; 
273:	extern __m128i _mm_insert_epi16 ( __m128i _A , int _B , int _Imm ) ; 
274:	extern int _mm_movemask_epi8 ( __m128i _A ) ; 
275:	extern __m128i _mm_shuffle_epi32 ( __m128i _A , int _Imm ) ; 
276:	extern __m128i _mm_shufflehi_epi16 ( __m128i _A , int _Imm ) ; 
277:	extern __m128i _mm_shufflelo_epi16 ( __m128i _A , int _Imm ) ; 
278:	extern __m128i _mm_unpackhi_epi8 ( __m128i _A , __m128i _B ) ; 
279:	extern __m128i _mm_unpackhi_epi16 ( __m128i _A , __m128i _B ) ; 
280:	extern __m128i _mm_unpackhi_epi32 ( __m128i _A , __m128i _B ) ; 
281:	extern __m128i _mm_unpackhi_epi64 ( __m128i _A , __m128i _B ) ; 
282:	extern __m128i _mm_unpacklo_epi8 ( __m128i _A , __m128i _B ) ; 
283:	extern __m128i _mm_unpacklo_epi16 ( __m128i _A , __m128i _B ) ; 
284:	extern __m128i _mm_unpacklo_epi32 ( __m128i _A , __m128i _B ) ; 
285:	extern __m128i _mm_unpacklo_epi64 ( __m128i _A , __m128i _B ) ; 
289:	extern __m128i _mm_load_si128 ( __m128i const * _P ) ; 
290:	extern __m128i _mm_loadu_si128 ( __m128i const * _P ) ; 
291:	extern __m128i _mm_loadl_epi64 ( __m128i const * _P ) ; 
298:	extern __m128i _mm_set_epi64x ( long long _I1 , long long _I0 ) ; 
299:	extern __m128i _mm_set_epi32 ( int _I3 , int _I2 , int _I1 , int _I0 ) ; 
300:	extern __m128i _mm_set_epi16 ( short _W7 , short _W6 , short _W5 , short _W4 , 
301:	short _W3 , short _W2 , short _W1 , short _W0 ) ; 
302:	extern __m128i _mm_set_epi8 ( char _B15 , char _B14 , char _B13 , char _B12 , 
303:	char _B11 , char _B10 , char _B9 , char _B8 , 
304:	char _B7 , char _B6 , char _B5 , char _B4 , 
305:	char _B3 , char _B2 , char _B1 , char _B0 ) ; 
309:	extern __m128i _mm_set1_epi64x ( long long i ) ; 
310:	extern __m128i _mm_set1_epi32 ( int _I ) ; 
311:	extern __m128i _mm_set1_epi16 ( short _W ) ; 
312:	extern __m128i _mm_set1_epi8 ( char _B ) ; 
313:	extern __m128i _mm_setl_epi64 ( __m128i _Q ) ; 
317:	extern __m128i _mm_setr_epi32 ( int _I0 , int _I1 , int _I2 , int _I3 ) ; 
318:	extern __m128i _mm_setr_epi16 ( short _W0 , short _W1 , short _W2 , short _W3 , 
319:	short _W4 , short _W5 , short _W6 , short _W7 ) ; 
320:	extern __m128i _mm_setr_epi8 ( char _B15 , char _B14 , char _B13 , char _B12 , 
321:	char _B11 , char _B10 , char _B9 , char _B8 , 
322:	char _B7 , char _B6 , char _B5 , char _B4 , 
323:	char _B3 , char _B2 , char _B1 , char _B0 ) ; 
324:	extern __m128i _mm_setzero_si128 ( void ) ; 
328:	extern void _mm_store_si128 ( __m128i * _P , __m128i _B ) ; 
329:	extern void _mm_storeu_si128 ( __m128i * _P , __m128i _B ) ; 
330:	extern void _mm_storel_epi64 ( __m128i * _P , __m128i _Q ) ; 
331:	extern void _mm_maskmoveu_si128 ( __m128i _D , __m128i _N , char * _P ) ; 
335:	extern __m128i _mm_move_epi64 ( __m128i _Q ) ; 
343:	extern void _mm_stream_pd ( double * _Dp , __m128d _A ) ; 
344:	extern void _mm_stream_si128 ( __m128i * _P , __m128i _A ) ; 
345:	extern void _mm_clflush ( void const * _P ) ; 
346:	extern void _mm_lfence ( void ) ; 
347:	extern void _mm_mfence ( void ) ; 
348:	extern void _mm_stream_si32 ( int * _P , int _I ) ; 
349:	extern void _mm_pause ( void ) ; 
353:	extern double _mm_cvtsd_f64 ( __m128d _A ) ; 
357:	extern __m128 _mm_castpd_ps ( __m128d ) ; 
358:	extern __m128i _mm_castpd_si128 ( __m128d ) ; 
359:	extern __m128d _mm_castps_pd ( __m128 ) ; 
360:	extern __m128i _mm_castps_si128 ( __m128 ) ; 
361:	extern __m128 _mm_castsi128_ps ( __m128i ) ; 
362:	extern __m128d _mm_castsi128_pd ( __m128i ) ; 
367:	extern long long _mm_cvtsd_si64 ( __m128d ) ; 
368:	extern long long _mm_cvttsd_si64 ( __m128d ) ; 
369:	extern __m128d _mm_cvtsi64_sd ( __m128d , long long ) ; 
370:	extern __m128i _mm_cvtsi64_si128 ( long long ) ; 
371:	extern long long _mm_cvtsi128_si64 ( __m128i ) ; 
611:	static int stbi__sse2_available ( void ) 
612:	{ 
616:	return 1 ; 
617:	} 
648:	typedef struct 
649:	{ 
650:	stbi__uint32 img_x , img_y ; 
651:	int img_n , img_out_n ; 
653:	stbi_io_callbacks io ; 
654:	void * io_user_data ; 
656:	int read_from_callbacks ; 
657:	int buflen ; 
658:	stbi_uc buffer_start [ 128 ] ; 
659:	int callback_already_read ; 
661:	stbi_uc * img_buffer , * img_buffer_end ; 
662:	stbi_uc * img_buffer_original , * img_buffer_original_end ; 
663:	} stbi__context ; 
666:	static void stbi__refill_buffer ( stbi__context * s ) ; 
669:	static void stbi__start_mem ( stbi__context * s , stbi_uc const * buffer , int len ) 
670:	{ 
671:	s -> io . read = ( ( void * ) 0 ) ; 
672:	s -> read_from_callbacks = 0 ; 
673:	s -> callback_already_read = 0 ; 
674:	s -> img_buffer = s -> img_buffer_original = ( stbi_uc * ) buffer ; 
675:	s -> img_buffer_end = s -> img_buffer_original_end = ( stbi_uc * ) buffer + len ; 
676:	} 
679:	static void stbi__start_callbacks ( stbi__context * s , stbi_io_callbacks * c , void * user ) 
680:	{ 
681:	s -> io = * c ; 
682:	s -> io_user_data = user ; 
683:	s -> buflen = sizeof ( s -> buffer_start ) ; 
684:	s -> read_from_callbacks = 1 ; 
685:	s -> callback_already_read = 0 ; 
686:	s -> img_buffer = s -> img_buffer_original = s -> buffer_start ; 
687:	stbi__refill_buffer ( s ) ; 
688:	s -> img_buffer_original_end = s -> img_buffer_end ; 
689:	} 
693:	static int stbi__stdio_read ( void * user , char * data , int size ) 
694:	{ 
695:	return ( int ) fread ( data , 1 , size , ( FILE * ) user ) ; 
696:	} 
698:	static void stbi__stdio_skip ( void * user , int n ) 
699:	{ 
700:	int ch ; 
701:	fseek ( ( FILE * ) user , n , 1 ) ; 
702:	ch = fgetc ( ( FILE * ) user ) ; 
703:	if ( ch != ( - 1 ) ) { 
704:	ungetc ( ch , ( FILE * ) user ) ; 
705:	} 
706:	} 
708:	static int stbi__stdio_eof ( void * user ) 
709:	{ 
710:	return feof ( ( FILE * ) user ) || ferror ( ( FILE * ) user ) ; 
711:	} 
713:	static stbi_io_callbacks stbi__stdio_callbacks = 
714:	{ 
715:	stbi__stdio_read , 
716:	stbi__stdio_skip , 
717:	stbi__stdio_eof , 
718:	} ; 
720:	static void stbi__start_file ( stbi__context * s , FILE * f ) 
721:	{ 
722:	stbi__start_callbacks ( s , & stbi__stdio_callbacks , ( void * ) f ) ; 
723:	} 
729:	static void stbi__rewind ( stbi__context * s ) 
730:	{ 
734:	s -> img_buffer = s -> img_buffer_original ; 
735:	s -> img_buffer_end = s -> img_buffer_original_end ; 
736:	} 
738:	enum 
739:	{ 
740:	STBI_ORDER_RGB , 
741:	STBI_ORDER_BGR 
742:	} ; 
744:	typedef struct 
745:	{ 
746:	int bits_per_channel ; 
747:	int num_channels ; 
748:	int channel_order ; 
749:	} stbi__result_info ; 
752:	static int stbi__jpeg_test ( stbi__context * s ) ; 
753:	static void * stbi__jpeg_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri ) ; 
754:	static int stbi__jpeg_info ( stbi__context * s , int * x , int * y , int * comp ) ; 
758:	static int stbi__png_test ( stbi__context * s ) ; 
759:	static void * stbi__png_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri ) ; 
760:	static int stbi__png_info ( stbi__context * s , int * x , int * y , int * comp ) ; 
761:	static int stbi__png_is16 ( stbi__context * s ) ; 
765:	static int stbi__bmp_test ( stbi__context * s ) ; 
766:	static void * stbi__bmp_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri ) ; 
767:	static int stbi__bmp_info ( stbi__context * s , int * x , int * y , int * comp ) ; 
771:	static int stbi__tga_test ( stbi__context * s ) ; 
772:	static void * stbi__tga_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri ) ; 
773:	static int stbi__tga_info ( stbi__context * s , int * x , int * y , int * comp ) ; 
777:	static int stbi__psd_test ( stbi__context * s ) ; 
778:	static void * stbi__psd_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri , int bpc ) ; 
779:	static int stbi__psd_info ( stbi__context * s , int * x , int * y , int * comp ) ; 
780:	static int stbi__psd_is16 ( stbi__context * s ) ; 
784:	static int stbi__hdr_test ( stbi__context * s ) ; 
785:	static float * stbi__hdr_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri ) ; 
786:	static int stbi__hdr_info ( stbi__context * s , int * x , int * y , int * comp ) ; 
790:	static int stbi__pic_test ( stbi__context * s ) ; 
791:	static void * stbi__pic_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri ) ; 
792:	static int stbi__pic_info ( stbi__context * s , int * x , int * y , int * comp ) ; 
796:	static int stbi__gif_test ( stbi__context * s ) ; 
797:	static void * stbi__gif_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri ) ; 
798:	static void * stbi__load_gif_main ( stbi__context * s , int * * delays , int * x , int * y , int * z , int * comp , int req_comp ) ; 
799:	static int stbi__gif_info ( stbi__context * s , int * x , int * y , int * comp ) ; 
803:	static int stbi__pnm_test ( stbi__context * s ) ; 
804:	static void * stbi__pnm_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri ) ; 
805:	static int stbi__pnm_info ( stbi__context * s , int * x , int * y , int * comp ) ; 
808:	static 
812:	const char * stbi__g_failure_reason ; 
814:	extern const char * stbi_failure_reason ( void ) 
815:	{ 
816:	return stbi__g_failure_reason ; 
817:	} 
820:	static int stbi__err ( const char * str ) 
821:	{ 
822:	stbi__g_failure_reason = str ; 
823:	return 0 ; 
824:	} 
827:	static void * stbi__malloc ( size_t size ) 
828:	{ 
829:	return malloc ( size ) ; 
830:	} 
844:	static int stbi__addsizes_valid ( int a , int b ) 
845:	{ 
846:	if ( b < 0 ) return 0 ; 
851:	return a <= 2147483647 - b ; 
852:	} 
856:	static int stbi__mul2sizes_valid ( int a , int b ) 
857:	{ 
858:	if ( a < 0 || b < 0 ) return 0 ; 
859:	if ( b == 0 ) return 1 ; 
861:	return a <= 2147483647 / b ; 
862:	} 
866:	static int stbi__mad2sizes_valid ( int a , int b , int add ) 
867:	{ 
868:	return stbi__mul2sizes_valid ( a , b ) && stbi__addsizes_valid ( a * b , add ) ; 
869:	} 
873:	static int stbi__mad3sizes_valid ( int a , int b , int c , int add ) 
874:	{ 
875:	return stbi__mul2sizes_valid ( a , b ) && stbi__mul2sizes_valid ( a * b , c ) && 
876:	stbi__addsizes_valid ( a * b * c , add ) ; 
877:	} 
881:	static int stbi__mad4sizes_valid ( int a , int b , int c , int d , int add ) 
882:	{ 
883:	return stbi__mul2sizes_valid ( a , b ) && stbi__mul2sizes_valid ( a * b , c ) && 
884:	stbi__mul2sizes_valid ( a * b * c , d ) && stbi__addsizes_valid ( a * b * c * d , add ) ; 
885:	} 
890:	static void * stbi__malloc_mad2 ( int a , int b , int add ) 
891:	{ 
892:	if ( ! stbi__mad2sizes_valid ( a , b , add ) ) return ( ( void * ) 0 ) ; 
893:	return stbi__malloc ( a * b + add ) ; 
894:	} 
897:	static void * stbi__malloc_mad3 ( int a , int b , int c , int add ) 
898:	{ 
899:	if ( ! stbi__mad3sizes_valid ( a , b , c , add ) ) return ( ( void * ) 0 ) ; 
900:	return stbi__malloc ( a * b * c + add ) ; 
901:	} 
904:	static void * stbi__malloc_mad4 ( int a , int b , int c , int d , int add ) 
905:	{ 
906:	if ( ! stbi__mad4sizes_valid ( a , b , c , d , add ) ) return ( ( void * ) 0 ) ; 
907:	return stbi__malloc ( a * b * c * d + add ) ; 
908:	} 
926:	extern void stbi_image_free ( void * retval_from_stbi_load ) 
927:	{ 
928:	free ( retval_from_stbi_load ) ; 
929:	} 
932:	static float * stbi__ldr_to_hdr ( stbi_uc * data , int x , int y , int comp ) ; 
936:	static stbi_uc * stbi__hdr_to_ldr ( float * data , int x , int y , int comp ) ; 
939:	static int stbi__vertically_flip_on_load_global = 0 ; 
941:	extern void stbi_set_flip_vertically_on_load ( int flag_true_if_should_flip ) 
942:	{ 
943:	stbi__vertically_flip_on_load_global = flag_true_if_should_flip ; 
944:	} 
960:	static void * stbi__load_main ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri , int bpc ) 
961:	{ 
962:	memset ( ri , 0 , sizeof ( * ri ) ) ; 
963:	ri -> bits_per_channel = 8 ; 
964:	ri -> channel_order = STBI_ORDER_RGB ; 
965:	ri -> num_channels = 0 ; 
968:	if ( stbi__jpeg_test ( s ) ) return stbi__jpeg_load ( s , x , y , comp , req_comp , ri ) ; 
971:	if ( stbi__png_test ( s ) ) return stbi__png_load ( s , x , y , comp , req_comp , ri ) ; 
974:	if ( stbi__bmp_test ( s ) ) return stbi__bmp_load ( s , x , y , comp , req_comp , ri ) ; 
977:	if ( stbi__gif_test ( s ) ) return stbi__gif_load ( s , x , y , comp , req_comp , ri ) ; 
980:	if ( stbi__psd_test ( s ) ) return stbi__psd_load ( s , x , y , comp , req_comp , ri , bpc ) ; 
985:	if ( stbi__pic_test ( s ) ) return stbi__pic_load ( s , x , y , comp , req_comp , ri ) ; 
988:	if ( stbi__pnm_test ( s ) ) return stbi__pnm_load ( s , x , y , comp , req_comp , ri ) ; 
992:	if ( stbi__hdr_test ( s ) ) { 
993:	float * hdr = stbi__hdr_load ( s , x , y , comp , req_comp , ri ) ; 
994:	return stbi__hdr_to_ldr ( hdr , * x , * y , req_comp ? req_comp : * comp ) ; 
995:	} 
1000:	if ( stbi__tga_test ( s ) ) 
1001:	return stbi__tga_load ( s , x , y , comp , req_comp , ri ) ; 
1004:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "unknown image type" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
1005:	} 
1007:	static stbi_uc * stbi__convert_16_to_8 ( stbi__uint16 * orig , int w , int h , int channels ) 
1008:	{ 
1009:	int i ; 
1010:	int img_len = w * h * channels ; 
1011:	stbi_uc * reduced ; 
1013:	reduced = ( stbi_uc * ) stbi__malloc ( img_len ) ; 
1014:	if ( reduced == ( ( void * ) 0 ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
1016:	for ( i = 0 ; i < img_len ; ++ i ) 
1017:	reduced [ i ] = ( stbi_uc ) ( ( orig [ i ] >> 8 ) & 0xFF ) ; 
1019:	free ( orig ) ; 
1020:	return reduced ; 
1021:	} 
1023:	static stbi__uint16 * stbi__convert_8_to_16 ( stbi_uc * orig , int w , int h , int channels ) 
1024:	{ 
1025:	int i ; 
1026:	int img_len = w * h * channels ; 
1027:	stbi__uint16 * enlarged ; 
1029:	enlarged = ( stbi__uint16 * ) stbi__malloc ( img_len * 2 ) ; 
1030:	if ( enlarged == ( ( void * ) 0 ) ) return ( stbi__uint16 * ) ( ( unsigned char * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
1032:	for ( i = 0 ; i < img_len ; ++ i ) 
1033:	enlarged [ i ] = ( stbi__uint16 ) ( ( orig [ i ] << 8 ) + orig [ i ] ) ; 
1035:	free ( orig ) ; 
1036:	return enlarged ; 
1037:	} 
1039:	static void stbi__vertical_flip ( void * image , int w , int h , int bytes_per_pixel ) 
1040:	{ 
1041:	int row ; 
1042:	size_t bytes_per_row = ( size_t ) w * bytes_per_pixel ; 
1043:	stbi_uc temp [ 2048 ] ; 
1044:	stbi_uc * bytes = ( stbi_uc * ) image ; 
1046:	for ( row = 0 ; row < ( h >> 1 ) ; row ++ ) { 
1047:	stbi_uc * row0 = bytes + row * bytes_per_row ; 
1048:	stbi_uc * row1 = bytes + ( h - row - 1 ) * bytes_per_row ; 
1050:	size_t bytes_left = bytes_per_row ; 
1051:	while ( bytes_left ) { 
1052:	size_t bytes_copy = ( bytes_left < sizeof ( temp ) ) ? bytes_left : sizeof ( temp ) ; 
1053:	memcpy ( temp , row0 , bytes_copy ) ; 
1054:	memcpy ( row0 , row1 , bytes_copy ) ; 
1055:	memcpy ( row1 , temp , bytes_copy ) ; 
1056:	row0 += bytes_copy ; 
1057:	row1 += bytes_copy ; 
1058:	bytes_left -= bytes_copy ; 
1059:	} 
1060:	} 
1061:	} 
1064:	static void stbi__vertical_flip_slices ( void * image , int w , int h , int z , int bytes_per_pixel ) 
1065:	{ 
1066:	int slice ; 
1067:	int slice_size = w * h * bytes_per_pixel ; 
1069:	stbi_uc * bytes = ( stbi_uc * ) image ; 
1070:	for ( slice = 0 ; slice < z ; ++ slice ) { 
1071:	stbi__vertical_flip ( bytes , w , h , bytes_per_pixel ) ; 
1072:	bytes += slice_size ; 
1073:	} 
1074:	} 
1077:	static unsigned char * stbi__load_and_postprocess_8bit ( stbi__context * s , int * x , int * y , int * comp , int req_comp ) 
1078:	{ 
1079:	stbi__result_info ri ; 
1080:	void * result = stbi__load_main ( s , x , y , comp , req_comp , & ri , 8 ) ; 
1082:	if ( result == ( ( void * ) 0 ) ) 
1083:	return ( ( void * ) 0 ) ; 
1086:	( void ) ( ( !! ( ri . bits_per_channel == 8 || ri . bits_per_channel == 16 ) ) || ( _wassert ( L "ri.bits_per_channel == 8 || ri.bits_per_channel == 16 " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
1088:	if ( ri . bits_per_channel != 8 ) { 
1089:	result = stbi__convert_16_to_8 ( ( stbi__uint16 * ) result , * x , * y , req_comp == 0 ? * comp : req_comp ) ; 
1090:	ri . bits_per_channel = 8 ; 
1091:	} 
1095:	if ( stbi__vertically_flip_on_load_global ) { 
1096:	int channels = req_comp ? req_comp : * comp ; 
1097:	stbi__vertical_flip ( result , * x , * y , channels * sizeof ( stbi_uc ) ) ; 
1098:	} 
1100:	return ( unsigned char * ) result ; 
1101:	} 
1103:	static stbi__uint16 * stbi__load_and_postprocess_16bit ( stbi__context * s , int * x , int * y , int * comp , int req_comp ) 
1104:	{ 
1105:	stbi__result_info ri ; 
1106:	void * result = stbi__load_main ( s , x , y , comp , req_comp , & ri , 16 ) ; 
1108:	if ( result == ( ( void * ) 0 ) ) 
1109:	return ( ( void * ) 0 ) ; 
1112:	( void ) ( ( !! ( ri . bits_per_channel == 8 || ri . bits_per_channel == 16 ) ) || ( _wassert ( L "ri.bits_per_channel == 8 || ri.bits_per_channel == 16 " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
1114:	if ( ri . bits_per_channel != 16 ) { 
1115:	result = stbi__convert_8_to_16 ( ( stbi_uc * ) result , * x , * y , req_comp == 0 ? * comp : req_comp ) ; 
1116:	ri . bits_per_channel = 16 ; 
1117:	} 
1122:	if ( stbi__vertically_flip_on_load_global ) { 
1123:	int channels = req_comp ? req_comp : * comp ; 
1124:	stbi__vertical_flip ( result , * x , * y , channels * sizeof ( stbi__uint16 ) ) ; 
1125:	} 
1127:	return ( stbi__uint16 * ) result ; 
1128:	} 
1131:	static void stbi__float_postprocess ( float * result , int * x , int * y , int * comp , int req_comp ) 
1132:	{ 
1133:	if ( stbi__vertically_flip_on_load_global && result != ( ( void * ) 0 ) ) { 
1134:	int channels = req_comp ? req_comp : * comp ; 
1135:	stbi__vertical_flip ( result , * x , * y , channels * sizeof ( float ) ) ; 
1136:	} 
1137:	} 
1154:	static FILE * stbi__fopen ( char const * filename , char const * mode ) 
1155:	{ 
1156:	FILE * f ; 
1177:	f = fopen ( filename , mode ) ; 
1179:	return f ; 
1180:	} 
1183:	extern stbi_uc * stbi_load ( char const * filename , int * x , int * y , int * comp , int req_comp ) 
1184:	{ 
1185:	FILE * f = stbi__fopen ( filename , "rb" ) ; 
1186:	unsigned char * result ; 
1187:	if ( ! f ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "can't fopen" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
1188:	result = stbi_load_from_file ( f , x , y , comp , req_comp ) ; 
1189:	fclose ( f ) ; 
1190:	return result ; 
1191:	} 
1193:	extern stbi_uc * stbi_load_from_file ( FILE * f , int * x , int * y , int * comp , int req_comp ) 
1194:	{ 
1195:	unsigned char * result ; 
1196:	stbi__context s ; 
1197:	stbi__start_file ( & s , f ) ; 
1198:	result = stbi__load_and_postprocess_8bit ( & s , x , y , comp , req_comp ) ; 
1199:	if ( result ) { 
1201:	fseek ( f , - ( int ) ( s . img_buffer_end - s . img_buffer ) , 1 ) ; 
1202:	} 
1203:	return result ; 
1204:	} 
1206:	extern stbi__uint16 * stbi_load_from_file_16 ( FILE * f , int * x , int * y , int * comp , int req_comp ) 
1207:	{ 
1208:	stbi__uint16 * result ; 
1209:	stbi__context s ; 
1210:	stbi__start_file ( & s , f ) ; 
1211:	result = stbi__load_and_postprocess_16bit ( & s , x , y , comp , req_comp ) ; 
1212:	if ( result ) { 
1214:	fseek ( f , - ( int ) ( s . img_buffer_end - s . img_buffer ) , 1 ) ; 
1215:	} 
1216:	return result ; 
1217:	} 
1219:	extern stbi_us * stbi_load_16 ( char const * filename , int * x , int * y , int * comp , int req_comp ) 
1220:	{ 
1221:	FILE * f = stbi__fopen ( filename , "rb" ) ; 
1222:	stbi__uint16 * result ; 
1223:	if ( ! f ) return ( stbi_us * ) ( ( unsigned char * ) ( size_t ) ( stbi__err ( "can't fopen" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
1224:	result = stbi_load_from_file_16 ( f , x , y , comp , req_comp ) ; 
1225:	fclose ( f ) ; 
1226:	return result ; 
1227:	} 
1232:	extern stbi_us * stbi_load_16_from_memory ( stbi_uc const * buffer , int len , int * x , int * y , int * channels_in_file , int desired_channels ) 
1233:	{ 
1234:	stbi__context s ; 
1235:	stbi__start_mem ( & s , buffer , len ) ; 
1236:	return stbi__load_and_postprocess_16bit ( & s , x , y , channels_in_file , desired_channels ) ; 
1237:	} 
1239:	extern stbi_us * stbi_load_16_from_callbacks ( stbi_io_callbacks const * clbk , void * user , int * x , int * y , int * channels_in_file , int desired_channels ) 
1240:	{ 
1241:	stbi__context s ; 
1242:	stbi__start_callbacks ( & s , ( stbi_io_callbacks * ) clbk , user ) ; 
1243:	return stbi__load_and_postprocess_16bit ( & s , x , y , channels_in_file , desired_channels ) ; 
1244:	} 
1246:	extern stbi_uc * stbi_load_from_memory ( stbi_uc const * buffer , int len , int * x , int * y , int * comp , int req_comp ) 
1247:	{ 
1248:	stbi__context s ; 
1249:	stbi__start_mem ( & s , buffer , len ) ; 
1250:	return stbi__load_and_postprocess_8bit ( & s , x , y , comp , req_comp ) ; 
1251:	} 
1253:	extern stbi_uc * stbi_load_from_callbacks ( stbi_io_callbacks const * clbk , void * user , int * x , int * y , int * comp , int req_comp ) 
1254:	{ 
1255:	stbi__context s ; 
1256:	stbi__start_callbacks ( & s , ( stbi_io_callbacks * ) clbk , user ) ; 
1257:	return stbi__load_and_postprocess_8bit ( & s , x , y , comp , req_comp ) ; 
1258:	} 
1261:	extern stbi_uc * stbi_load_gif_from_memory ( stbi_uc const * buffer , int len , int * * delays , int * x , int * y , int * z , int * comp , int req_comp ) 
1262:	{ 
1263:	unsigned char * result ; 
1264:	stbi__context s ; 
1265:	stbi__start_mem ( & s , buffer , len ) ; 
1267:	result = ( unsigned char * ) stbi__load_gif_main ( & s , delays , x , y , z , comp , req_comp ) ; 
1268:	if ( stbi__vertically_flip_on_load_global ) { 
1269:	stbi__vertical_flip_slices ( result , * x , * y , * z , * comp ) ; 
1270:	} 
1272:	return result ; 
1273:	} 
1277:	static float * stbi__loadf_main ( stbi__context * s , int * x , int * y , int * comp , int req_comp ) 
1278:	{ 
1279:	unsigned char * data ; 
1281:	if ( stbi__hdr_test ( s ) ) { 
1282:	stbi__result_info ri ; 
1283:	float * hdr_data = stbi__hdr_load ( s , x , y , comp , req_comp , & ri ) ; 
1284:	if ( hdr_data ) 
1285:	stbi__float_postprocess ( hdr_data , x , y , comp , req_comp ) ; 
1286:	return hdr_data ; 
1287:	} 
1289:	data = stbi__load_and_postprocess_8bit ( s , x , y , comp , req_comp ) ; 
1290:	if ( data ) 
1291:	return stbi__ldr_to_hdr ( data , * x , * y , req_comp ? req_comp : * comp ) ; 
1292:	return ( ( float * ) ( size_t ) ( stbi__err ( "unknown image type" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
1293:	} 
1295:	extern float * stbi_loadf_from_memory ( stbi_uc const * buffer , int len , int * x , int * y , int * comp , int req_comp ) 
1296:	{ 
1297:	stbi__context s ; 
1298:	stbi__start_mem ( & s , buffer , len ) ; 
1299:	return stbi__loadf_main ( & s , x , y , comp , req_comp ) ; 
1300:	} 
1302:	extern float * stbi_loadf_from_callbacks ( stbi_io_callbacks const * clbk , void * user , int * x , int * y , int * comp , int req_comp ) 
1303:	{ 
1304:	stbi__context s ; 
1305:	stbi__start_callbacks ( & s , ( stbi_io_callbacks * ) clbk , user ) ; 
1306:	return stbi__loadf_main ( & s , x , y , comp , req_comp ) ; 
1307:	} 
1310:	extern float * stbi_loadf ( char const * filename , int * x , int * y , int * comp , int req_comp ) 
1311:	{ 
1312:	float * result ; 
1313:	FILE * f = stbi__fopen ( filename , "rb" ) ; 
1314:	if ( ! f ) return ( ( float * ) ( size_t ) ( stbi__err ( "can't fopen" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
1315:	result = stbi_loadf_from_file ( f , x , y , comp , req_comp ) ; 
1316:	fclose ( f ) ; 
1317:	return result ; 
1318:	} 
1320:	extern float * stbi_loadf_from_file ( FILE * f , int * x , int * y , int * comp , int req_comp ) 
1321:	{ 
1322:	stbi__context s ; 
1323:	stbi__start_file ( & s , f ) ; 
1324:	return stbi__loadf_main ( & s , x , y , comp , req_comp ) ; 
1325:	} 
1334:	extern int stbi_is_hdr_from_memory ( stbi_uc const * buffer , int len ) 
1335:	{ 
1337:	stbi__context s ; 
1338:	stbi__start_mem ( & s , buffer , len ) ; 
1339:	return stbi__hdr_test ( & s ) ; 
1345:	} 
1348:	extern int stbi_is_hdr ( char const * filename ) 
1349:	{ 
1350:	FILE * f = stbi__fopen ( filename , "rb" ) ; 
1351:	int result = 0 ; 
1352:	if ( f ) { 
1353:	result = stbi_is_hdr_from_file ( f ) ; 
1354:	fclose ( f ) ; 
1355:	} 
1356:	return result ; 
1357:	} 
1359:	extern int stbi_is_hdr_from_file ( FILE * f ) 
1360:	{ 
1362:	long pos = ftell ( f ) ; 
1363:	int res ; 
1364:	stbi__context s ; 
1365:	stbi__start_file ( & s , f ) ; 
1366:	res = stbi__hdr_test ( & s ) ; 
1367:	fseek ( f , pos , 0 ) ; 
1368:	return res ; 
1373:	} 
1376:	extern int stbi_is_hdr_from_callbacks ( stbi_io_callbacks const * clbk , void * user ) 
1377:	{ 
1379:	stbi__context s ; 
1380:	stbi__start_callbacks ( & s , ( stbi_io_callbacks * ) clbk , user ) ; 
1381:	return stbi__hdr_test ( & s ) ; 
1387:	} 
1390:	static float stbi__l2h_gamma = 2 . 2 f , stbi__l2h_scale = 1 . 0 f ; 
1392:	extern void stbi_ldr_to_hdr_gamma ( float gamma ) { stbi__l2h_gamma = gamma ; } 
1393:	extern void stbi_ldr_to_hdr_scale ( float scale ) { stbi__l2h_scale = scale ; } 
1396:	static float stbi__h2l_gamma_i = 1 . 0 f / 2 . 2 f , stbi__h2l_scale_i = 1 . 0 f ; 
1398:	extern void stbi_hdr_to_ldr_gamma ( float gamma ) { stbi__h2l_gamma_i = 1 / gamma ; } 
1399:	extern void stbi_hdr_to_ldr_scale ( float scale ) { stbi__h2l_scale_i = 1 / scale ; } 
1407:	enum 
1408:	{ 
1409:	STBI__SCAN_load = 0 , 
1410:	STBI__SCAN_type , 
1411:	STBI__SCAN_header 
1412:	} ; 
1414:	static void stbi__refill_buffer ( stbi__context * s ) 
1415:	{ 
1416:	int n = ( s -> io . read ) ( s -> io_user_data , ( char * ) s -> buffer_start , s -> buflen ) ; 
1417:	s -> callback_already_read += ( int ) ( s -> img_buffer - s -> img_buffer_original ) ; 
1418:	if ( n == 0 ) { 
1421:	s -> read_from_callbacks = 0 ; 
1422:	s -> img_buffer = s -> buffer_start ; 
1423:	s -> img_buffer_end = s -> buffer_start + 1 ; 
1424:	* s -> img_buffer = 0 ; 
1425:	} else { 
1426:	s -> img_buffer = s -> buffer_start ; 
1427:	s -> img_buffer_end = s -> buffer_start + n ; 
1428:	} 
1429:	} 
1431:	static stbi_uc stbi__get8 ( stbi__context * s ) 
1432:	{ 
1433:	if ( s -> img_buffer < s -> img_buffer_end ) 
1434:	return * s -> img_buffer ++ ; 
1435:	if ( s -> read_from_callbacks ) { 
1436:	stbi__refill_buffer ( s ) ; 
1437:	return * s -> img_buffer ++ ; 
1438:	} 
1439:	return 0 ; 
1440:	} 
1445:	static int stbi__at_eof ( stbi__context * s ) 
1446:	{ 
1447:	if ( s -> io . read ) { 
1448:	if ( ! ( s -> io . eof ) ( s -> io_user_data ) ) return 0 ; 
1451:	if ( s -> read_from_callbacks == 0 ) return 1 ; 
1452:	} 
1454:	return s -> img_buffer >= s -> img_buffer_end ; 
1455:	} 
1461:	static void stbi__skip ( stbi__context * s , int n ) 
1462:	{ 
1463:	if ( n == 0 ) return ; 
1464:	if ( n < 0 ) { 
1465:	s -> img_buffer = s -> img_buffer_end ; 
1466:	return ; 
1467:	} 
1468:	if ( s -> io . read ) { 
1469:	int blen = ( int ) ( s -> img_buffer_end - s -> img_buffer ) ; 
1470:	if ( blen < n ) { 
1471:	s -> img_buffer = s -> img_buffer_end ; 
1472:	( s -> io . skip ) ( s -> io_user_data , n - blen ) ; 
1473:	return ; 
1474:	} 
1475:	} 
1476:	s -> img_buffer += n ; 
1477:	} 
1483:	static int stbi__getn ( stbi__context * s , stbi_uc * buffer , int n ) 
1484:	{ 
1485:	if ( s -> io . read ) { 
1486:	int blen = ( int ) ( s -> img_buffer_end - s -> img_buffer ) ; 
1487:	if ( blen < n ) { 
1488:	int res , count ; 
1490:	memcpy ( buffer , s -> img_buffer , blen ) ; 
1492:	count = ( s -> io . read ) ( s -> io_user_data , ( char * ) buffer + blen , n - blen ) ; 
1493:	res = ( count == ( n - blen ) ) ; 
1494:	s -> img_buffer = s -> img_buffer_end ; 
1495:	return res ; 
1496:	} 
1497:	} 
1499:	if ( s -> img_buffer + n <= s -> img_buffer_end ) { 
1500:	memcpy ( buffer , s -> img_buffer , n ) ; 
1501:	s -> img_buffer += n ; 
1502:	return 1 ; 
1503:	} else 
1504:	return 0 ; 
1505:	} 
1511:	static int stbi__get16be ( stbi__context * s ) 
1512:	{ 
1513:	int z = stbi__get8 ( s ) ; 
1514:	return ( z << 8 ) + stbi__get8 ( s ) ; 
1515:	} 
1521:	static stbi__uint32 stbi__get32be ( stbi__context * s ) 
1522:	{ 
1523:	stbi__uint32 z = stbi__get16be ( s ) ; 
1524:	return ( z << 16 ) + stbi__get16be ( s ) ; 
1525:	} 
1531:	static int stbi__get16le ( stbi__context * s ) 
1532:	{ 
1533:	int z = stbi__get8 ( s ) ; 
1534:	return z + ( stbi__get8 ( s ) << 8 ) ; 
1535:	} 
1539:	static stbi__uint32 stbi__get32le ( stbi__context * s ) 
1540:	{ 
1541:	stbi__uint32 z = stbi__get16le ( s ) ; 
1542:	return z + ( stbi__get16le ( s ) << 16 ) ; 
1543:	} 
1562:	static stbi_uc stbi__compute_y ( int r , int g , int b ) 
1563:	{ 
1564:	return ( stbi_uc ) ( ( ( r * 77 ) + ( g * 150 ) + ( 29 * b ) ) >> 8 ) ; 
1565:	} 
1571:	static unsigned char * stbi__convert_format ( unsigned char * data , int img_n , int req_comp , unsigned int x , unsigned int y ) 
1572:	{ 
1573:	int i , j ; 
1574:	unsigned char * good ; 
1576:	if ( req_comp == img_n ) return data ; 
1577:	( void ) ( ( !! ( req_comp >= 1 && req_comp <= 4 ) ) || ( _wassert ( L "req_comp >= 1 && req_comp <= 4 " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
1579:	good = ( unsigned char * ) stbi__malloc_mad3 ( req_comp , x , y , 0 ) ; 
1580:	if ( good == ( ( void * ) 0 ) ) { 
1581:	free ( data ) ; 
1582:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
1583:	} 
1585:	for ( j = 0 ; j < ( int ) y ; ++ j ) { 
1586:	unsigned char * src = data + j * x * img_n ; 
1587:	unsigned char * dest = good + j * x * req_comp ; 
1593:	switch ( ( ( img_n ) * 8 + ( req_comp ) ) ) { 
1594:	case ( ( 1 ) * 8 + ( 2 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 1 , dest += 2 ) { dest [ 0 ] = src [ 0 ] ; dest [ 1 ] = 255 ; } break ; 
1595:	case ( ( 1 ) * 8 + ( 3 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 1 , dest += 3 ) { dest [ 0 ] = dest [ 1 ] = dest [ 2 ] = src [ 0 ] ; } break ; 
1596:	case ( ( 1 ) * 8 + ( 4 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 1 , dest += 4 ) { dest [ 0 ] = dest [ 1 ] = dest [ 2 ] = src [ 0 ] ; dest [ 3 ] = 255 ; } break ; 
1597:	case ( ( 2 ) * 8 + ( 1 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 2 , dest += 1 ) { dest [ 0 ] = src [ 0 ] ; } break ; 
1598:	case ( ( 2 ) * 8 + ( 3 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 2 , dest += 3 ) { dest [ 0 ] = dest [ 1 ] = dest [ 2 ] = src [ 0 ] ; } break ; 
1599:	case ( ( 2 ) * 8 + ( 4 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 2 , dest += 4 ) { dest [ 0 ] = dest [ 1 ] = dest [ 2 ] = src [ 0 ] ; dest [ 3 ] = src [ 1 ] ; } break ; 
1600:	case ( ( 3 ) * 8 + ( 4 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 3 , dest += 4 ) { dest [ 0 ] = src [ 0 ] ; dest [ 1 ] = src [ 1 ] ; dest [ 2 ] = src [ 2 ] ; dest [ 3 ] = 255 ; } break ; 
1601:	case ( ( 3 ) * 8 + ( 1 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 3 , dest += 1 ) { dest [ 0 ] = stbi__compute_y ( src [ 0 ] , src [ 1 ] , src [ 2 ] ) ; } break ; 
1602:	case ( ( 3 ) * 8 + ( 2 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 3 , dest += 2 ) { dest [ 0 ] = stbi__compute_y ( src [ 0 ] , src [ 1 ] , src [ 2 ] ) ; dest [ 1 ] = 255 ; } break ; 
1603:	case ( ( 4 ) * 8 + ( 1 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 4 , dest += 1 ) { dest [ 0 ] = stbi__compute_y ( src [ 0 ] , src [ 1 ] , src [ 2 ] ) ; } break ; 
1604:	case ( ( 4 ) * 8 + ( 2 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 4 , dest += 2 ) { dest [ 0 ] = stbi__compute_y ( src [ 0 ] , src [ 1 ] , src [ 2 ] ) ; dest [ 1 ] = src [ 3 ] ; } break ; 
1605:	case ( ( 4 ) * 8 + ( 3 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 4 , dest += 3 ) { dest [ 0 ] = src [ 0 ] ; dest [ 1 ] = src [ 1 ] ; dest [ 2 ] = src [ 2 ] ; } break ; 
1606:	default : ( void ) ( ( !! ( 0 ) ) || ( _wassert ( L "0 " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; free ( data ) ; free ( good ) ; return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "unsupported" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
1607:	} 
1609:	} 
1611:	free ( data ) ; 
1612:	return good ; 
1613:	} 
1619:	static stbi__uint16 stbi__compute_y_16 ( int r , int g , int b ) 
1620:	{ 
1621:	return ( stbi__uint16 ) ( ( ( r * 77 ) + ( g * 150 ) + ( 29 * b ) ) >> 8 ) ; 
1622:	} 
1628:	static stbi__uint16 * stbi__convert_format16 ( stbi__uint16 * data , int img_n , int req_comp , unsigned int x , unsigned int y ) 
1629:	{ 
1630:	int i , j ; 
1631:	stbi__uint16 * good ; 
1633:	if ( req_comp == img_n ) return data ; 
1634:	( void ) ( ( !! ( req_comp >= 1 && req_comp <= 4 ) ) || ( _wassert ( L "req_comp >= 1 && req_comp <= 4 " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
1636:	good = ( stbi__uint16 * ) stbi__malloc ( req_comp * x * y * 2 ) ; 
1637:	if ( good == ( ( void * ) 0 ) ) { 
1638:	free ( data ) ; 
1639:	return ( stbi__uint16 * ) ( ( unsigned char * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
1640:	} 
1642:	for ( j = 0 ; j < ( int ) y ; ++ j ) { 
1643:	stbi__uint16 * src = data + j * x * img_n ; 
1644:	stbi__uint16 * dest = good + j * x * req_comp ; 
1650:	switch ( ( ( img_n ) * 8 + ( req_comp ) ) ) { 
1651:	case ( ( 1 ) * 8 + ( 2 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 1 , dest += 2 ) { dest [ 0 ] = src [ 0 ] ; dest [ 1 ] = 0xffff ; } break ; 
1652:	case ( ( 1 ) * 8 + ( 3 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 1 , dest += 3 ) { dest [ 0 ] = dest [ 1 ] = dest [ 2 ] = src [ 0 ] ; } break ; 
1653:	case ( ( 1 ) * 8 + ( 4 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 1 , dest += 4 ) { dest [ 0 ] = dest [ 1 ] = dest [ 2 ] = src [ 0 ] ; dest [ 3 ] = 0xffff ; } break ; 
1654:	case ( ( 2 ) * 8 + ( 1 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 2 , dest += 1 ) { dest [ 0 ] = src [ 0 ] ; } break ; 
1655:	case ( ( 2 ) * 8 + ( 3 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 2 , dest += 3 ) { dest [ 0 ] = dest [ 1 ] = dest [ 2 ] = src [ 0 ] ; } break ; 
1656:	case ( ( 2 ) * 8 + ( 4 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 2 , dest += 4 ) { dest [ 0 ] = dest [ 1 ] = dest [ 2 ] = src [ 0 ] ; dest [ 3 ] = src [ 1 ] ; } break ; 
1657:	case ( ( 3 ) * 8 + ( 4 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 3 , dest += 4 ) { dest [ 0 ] = src [ 0 ] ; dest [ 1 ] = src [ 1 ] ; dest [ 2 ] = src [ 2 ] ; dest [ 3 ] = 0xffff ; } break ; 
1658:	case ( ( 3 ) * 8 + ( 1 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 3 , dest += 1 ) { dest [ 0 ] = stbi__compute_y_16 ( src [ 0 ] , src [ 1 ] , src [ 2 ] ) ; } break ; 
1659:	case ( ( 3 ) * 8 + ( 2 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 3 , dest += 2 ) { dest [ 0 ] = stbi__compute_y_16 ( src [ 0 ] , src [ 1 ] , src [ 2 ] ) ; dest [ 1 ] = 0xffff ; } break ; 
1660:	case ( ( 4 ) * 8 + ( 1 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 4 , dest += 1 ) { dest [ 0 ] = stbi__compute_y_16 ( src [ 0 ] , src [ 1 ] , src [ 2 ] ) ; } break ; 
1661:	case ( ( 4 ) * 8 + ( 2 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 4 , dest += 2 ) { dest [ 0 ] = stbi__compute_y_16 ( src [ 0 ] , src [ 1 ] , src [ 2 ] ) ; dest [ 1 ] = src [ 3 ] ; } break ; 
1662:	case ( ( 4 ) * 8 + ( 3 ) ) : for ( i = x - 1 ; i >= 0 ; -- i , src += 4 , dest += 3 ) { dest [ 0 ] = src [ 0 ] ; dest [ 1 ] = src [ 1 ] ; dest [ 2 ] = src [ 2 ] ; } break ; 
1663:	default : ( void ) ( ( !! ( 0 ) ) || ( _wassert ( L "0 " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; free ( data ) ; free ( good ) ; return ( stbi__uint16 * ) ( ( unsigned char * ) ( size_t ) ( stbi__err ( "unsupported" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
1664:	} 
1666:	} 
1668:	free ( data ) ; 
1669:	return good ; 
1670:	} 
1674:	static float * stbi__ldr_to_hdr ( stbi_uc * data , int x , int y , int comp ) 
1675:	{ 
1676:	int i , k , n ; 
1677:	float * output ; 
1678:	if ( ! data ) return ( ( void * ) 0 ) ; 
1679:	output = ( float * ) stbi__malloc_mad4 ( x , y , comp , sizeof ( float ) , 0 ) ; 
1680:	if ( output == ( ( void * ) 0 ) ) { free ( data ) ; return ( ( float * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; } 
1682:	if ( comp & 1 ) n = comp ; else n = comp - 1 ; 
1683:	for ( i = 0 ; i < x * y ; ++ i ) { 
1684:	for ( k = 0 ; k < n ; ++ k ) { 
1685:	output [ i * comp + k ] = ( float ) ( pow ( data [ i * comp + k ] / 255 . 0 f , stbi__l2h_gamma ) * stbi__l2h_scale ) ; 
1686:	} 
1687:	} 
1688:	if ( n < comp ) { 
1689:	for ( i = 0 ; i < x * y ; ++ i ) { 
1690:	output [ i * comp + n ] = data [ i * comp + n ] / 255 . 0 f ; 
1691:	} 
1692:	} 
1693:	free ( data ) ; 
1694:	return output ; 
1695:	} 
1700:	static stbi_uc * stbi__hdr_to_ldr ( float * data , int x , int y , int comp ) 
1701:	{ 
1702:	int i , k , n ; 
1703:	stbi_uc * output ; 
1704:	if ( ! data ) return ( ( void * ) 0 ) ; 
1705:	output = ( stbi_uc * ) stbi__malloc_mad3 ( x , y , comp , 0 ) ; 
1706:	if ( output == ( ( void * ) 0 ) ) { free ( data ) ; return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; } 
1708:	if ( comp & 1 ) n = comp ; else n = comp - 1 ; 
1709:	for ( i = 0 ; i < x * y ; ++ i ) { 
1710:	for ( k = 0 ; k < n ; ++ k ) { 
1711:	float z = ( float ) pow ( data [ i * comp + k ] * stbi__h2l_scale_i , stbi__h2l_gamma_i ) * 255 + 0 . 5 f ; 
1712:	if ( z < 0 ) z = 0 ; 
1713:	if ( z > 255 ) z = 255 ; 
1714:	output [ i * comp + k ] = ( stbi_uc ) ( ( int ) ( z ) ) ; 
1715:	} 
1716:	if ( k < comp ) { 
1717:	float z = data [ i * comp + k ] * 255 + 0 . 5 f ; 
1718:	if ( z < 0 ) z = 0 ; 
1719:	if ( z > 255 ) z = 255 ; 
1720:	output [ i * comp + k ] = ( stbi_uc ) ( ( int ) ( z ) ) ; 
1721:	} 
1722:	} 
1723:	free ( data ) ; 
1724:	return output ; 
1725:	} 
1754:	typedef struct 
1755:	{ 
1756:	stbi_uc fast [ 1 << 9 ] ; 
1758:	stbi__uint16 code [ 256 ] ; 
1759:	stbi_uc values [ 256 ] ; 
1760:	stbi_uc size [ 257 ] ; 
1761:	unsigned int maxcode [ 18 ] ; 
1762:	int delta [ 17 ] ; 
1763:	} stbi__huffman ; 
1765:	typedef struct 
1766:	{ 
1767:	stbi__context * s ; 
1768:	stbi__huffman huff_dc [ 4 ] ; 
1769:	stbi__huffman huff_ac [ 4 ] ; 
1770:	stbi__uint16 dequant [ 4 ] [ 64 ] ; 
1771:	stbi__int16 fast_ac [ 4 ] [ 1 << 9 ] ; 
1774:	int img_h_max , img_v_max ; 
1775:	int img_mcu_x , img_mcu_y ; 
1776:	int img_mcu_w , img_mcu_h ; 
1779:	struct 
1780:	{ 
1781:	int id ; 
1782:	int h , v ; 
1783:	int tq ; 
1784:	int hd , ha ; 
1785:	int dc_pred ; 
1787:	int x , y , w2 , h2 ; 
1788:	stbi_uc * data ; 
1789:	void * raw_data , * raw_coeff ; 
1790:	stbi_uc * linebuf ; 
1791:	short * coeff ; 
1792:	int coeff_w , coeff_h ; 
1793:	} img_comp [ 4 ] ; 
1795:	stbi__uint32 code_buffer ; 
1796:	int code_bits ; 
1797:	unsigned char marker ; 
1798:	int nomore ; 
1800:	int progressive ; 
1801:	int spec_start ; 
1802:	int spec_end ; 
1803:	int succ_high ; 
1804:	int succ_low ; 
1805:	int eob_run ; 
1806:	int jfif ; 
1807:	int app14_color_transform ; 
1808:	int rgb ; 
1810:	int scan_n , order [ 4 ] ; 
1811:	int restart_interval , todo ; 
1814:	void ( * idct_block_kernel ) ( stbi_uc * out , int out_stride , short data [ 64 ] ) ; 
1815:	void ( * YCbCr_to_RGB_kernel ) ( stbi_uc * out , const stbi_uc * y , const stbi_uc * pcb , const stbi_uc * pcr , int count , int step ) ; 
1816:	stbi_uc * ( * resample_row_hv_2_kernel ) ( stbi_uc * out , stbi_uc * in_near , stbi_uc * in_far , int w , int hs ) ; 
1817:	} stbi__jpeg ; 
1819:	static int stbi__build_huffman ( stbi__huffman * h , int * count ) 
1820:	{ 
1821:	int i , j , k = 0 ; 
1822:	unsigned int code ; 
1824:	for ( i = 0 ; i < 16 ; ++ i ) 
1825:	for ( j = 0 ; j < count [ i ] ; ++ j ) 
1826:	h -> size [ k ++ ] = ( stbi_uc ) ( i + 1 ) ; 
1827:	h -> size [ k ] = 0 ; 
1830:	code = 0 ; 
1831:	k = 0 ; 
1832:	for ( j = 1 ; j <= 16 ; ++ j ) { 
1834:	h -> delta [ j ] = k - code ; 
1835:	if ( h -> size [ k ] == j ) { 
1836:	while ( h -> size [ k ] == j ) 
1837:	h -> code [ k ++ ] = ( stbi__uint16 ) ( code ++ ) ; 
1838:	if ( code - 1 >= ( 1 u << j ) ) return stbi__err ( "bad code lengths" ) ; 
1839:	} 
1841:	h -> maxcode [ j ] = code << ( 16 - j ) ; 
1842:	code <<= 1 ; 
1843:	} 
1844:	h -> maxcode [ j ] = 0xffffffff ; 
1847:	memset ( h -> fast , 255 , 1 << 9 ) ; 
1848:	for ( i = 0 ; i < k ; ++ i ) { 
1849:	int s = h -> size [ i ] ; 
1850:	if ( s <= 9 ) { 
1851:	int c = h -> code [ i ] << ( 9 - s ) ; 
1852:	int m = 1 << ( 9 - s ) ; 
1853:	for ( j = 0 ; j < m ; ++ j ) { 
1854:	h -> fast [ c + j ] = ( stbi_uc ) i ; 
1855:	} 
1856:	} 
1857:	} 
1858:	return 1 ; 
1859:	} 
1863:	static void stbi__build_fast_ac ( stbi__int16 * fast_ac , stbi__huffman * h ) 
1864:	{ 
1865:	int i ; 
1866:	for ( i = 0 ; i < ( 1 << 9 ) ; ++ i ) { 
1867:	stbi_uc fast = h -> fast [ i ] ; 
1868:	fast_ac [ i ] = 0 ; 
1869:	if ( fast < 255 ) { 
1870:	int rs = h -> values [ fast ] ; 
1871:	int run = ( rs >> 4 ) & 15 ; 
1872:	int magbits = rs & 15 ; 
1873:	int len = h -> size [ fast ] ; 
1875:	if ( magbits && len + magbits <= 9 ) { 
1877:	int k = ( ( i << len ) & ( ( 1 << 9 ) - 1 ) ) >> ( 9 - magbits ) ; 
1878:	int m = 1 << ( magbits - 1 ) ; 
1879:	if ( k < m ) k += ( ~ 0 U << magbits ) + 1 ; 
1881:	if ( k >= - 128 && k <= 127 ) 
1882:	fast_ac [ i ] = ( stbi__int16 ) ( ( k * 256 ) + ( run * 16 ) + ( len + magbits ) ) ; 
1883:	} 
1884:	} 
1885:	} 
1886:	} 
1888:	static void stbi__grow_buffer_unsafe ( stbi__jpeg * j ) 
1889:	{ 
1890:	do { 
1891:	unsigned int b = j -> nomore ? 0 : stbi__get8 ( j -> s ) ; 
1892:	if ( b == 0xff ) { 
1893:	int c = stbi__get8 ( j -> s ) ; 
1894:	while ( c == 0xff ) c = stbi__get8 ( j -> s ) ; 
1895:	if ( c != 0 ) { 
1896:	j -> marker = ( unsigned char ) c ; 
1897:	j -> nomore = 1 ; 
1898:	return ; 
1899:	} 
1900:	} 
1901:	j -> code_buffer |= b << ( 24 - j -> code_bits ) ; 
1902:	j -> code_bits += 8 ; 
1903:	} while ( j -> code_bits <= 24 ) ; 
1904:	} 
1907:	static const stbi__uint32 stbi__bmask [ 17 ] = { 0 , 1 , 3 , 7 , 15 , 31 , 63 , 127 , 255 , 511 , 1023 , 2047 , 4095 , 8191 , 16383 , 32767 , 65535 } ; 
1910:	static int stbi__jpeg_huff_decode ( stbi__jpeg * j , stbi__huffman * h ) 
1911:	{ 
1912:	unsigned int temp ; 
1913:	int c , k ; 
1915:	if ( j -> code_bits < 16 ) stbi__grow_buffer_unsafe ( j ) ; 
1919:	c = ( j -> code_buffer >> ( 32 - 9 ) ) & ( ( 1 << 9 ) - 1 ) ; 
1920:	k = h -> fast [ c ] ; 
1921:	if ( k < 255 ) { 
1922:	int s = h -> size [ k ] ; 
1923:	if ( s > j -> code_bits ) 
1924:	return - 1 ; 
1925:	j -> code_buffer <<= s ; 
1926:	j -> code_bits -= s ; 
1927:	return h -> values [ k ] ; 
1928:	} 
1936:	temp = j -> code_buffer >> 16 ; 
1937:	for ( k = 9 + 1 ; ; ++ k ) 
1938:	if ( temp < h -> maxcode [ k ] ) 
1939:	break ; 
1940:	if ( k == 17 ) { 
1942:	j -> code_bits -= 16 ; 
1943:	return - 1 ; 
1944:	} 
1946:	if ( k > j -> code_bits ) 
1947:	return - 1 ; 
1950:	c = ( ( j -> code_buffer >> ( 32 - k ) ) & stbi__bmask [ k ] ) + h -> delta [ k ] ; 
1951:	( void ) ( ( !! ( ( ( ( j -> code_buffer ) >> ( 32 - h -> size [ c ] ) ) & stbi__bmask [ h -> size [ c ] ] ) == h -> code [ c ] ) ) || ( _wassert ( L "(((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c] " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
1954:	j -> code_bits -= k ; 
1955:	j -> code_buffer <<= k ; 
1956:	return h -> values [ c ] ; 
1957:	} 
1960:	static const int stbi__jbias [ 16 ] = { 0 , - 1 , - 3 , - 7 , - 15 , - 31 , - 63 , - 127 , - 255 , - 511 , - 1023 , - 2047 , - 4095 , - 8191 , - 16383 , - 32767 } ; 
1964:	static int stbi__extend_receive ( stbi__jpeg * j , int n ) 
1965:	{ 
1966:	unsigned int k ; 
1967:	int sgn ; 
1968:	if ( j -> code_bits < n ) stbi__grow_buffer_unsafe ( j ) ; 
1970:	sgn = ( stbi__int32 ) j -> code_buffer >> 31 ; 
1971:	k = ( ( ( j -> code_buffer ) << ( n ) ) | ( ( j -> code_buffer ) >> ( 32 - ( n ) ) ) ) ; 
1972:	if ( n < 0 || n >= ( int ) ( sizeof ( stbi__bmask ) / sizeof ( * stbi__bmask ) ) ) return 0 ; 
1973:	j -> code_buffer = k & ~ stbi__bmask [ n ] ; 
1974:	k &= stbi__bmask [ n ] ; 
1975:	j -> code_bits -= n ; 
1976:	return k + ( stbi__jbias [ n ] & ~ sgn ) ; 
1977:	} 
1980:	static int stbi__jpeg_get_bits ( stbi__jpeg * j , int n ) 
1981:	{ 
1982:	unsigned int k ; 
1983:	if ( j -> code_bits < n ) stbi__grow_buffer_unsafe ( j ) ; 
1984:	k = ( ( ( j -> code_buffer ) << ( n ) ) | ( ( j -> code_buffer ) >> ( 32 - ( n ) ) ) ) ; 
1985:	j -> code_buffer = k & ~ stbi__bmask [ n ] ; 
1986:	k &= stbi__bmask [ n ] ; 
1987:	j -> code_bits -= n ; 
1988:	return k ; 
1989:	} 
1991:	static int stbi__jpeg_get_bit ( stbi__jpeg * j ) 
1992:	{ 
1993:	unsigned int k ; 
1994:	if ( j -> code_bits < 1 ) stbi__grow_buffer_unsafe ( j ) ; 
1995:	k = j -> code_buffer ; 
1996:	j -> code_buffer <<= 1 ; 
1997:	-- j -> code_bits ; 
1998:	return k & 0x80000000 ; 
1999:	} 
2003:	static const stbi_uc stbi__jpeg_dezigzag [ 64 + 15 ] = 
2004:	{ 
2005:	0 , 1 , 8 , 16 , 9 , 2 , 3 , 10 , 
2006:	17 , 24 , 32 , 25 , 18 , 11 , 4 , 5 , 
2007:	12 , 19 , 26 , 33 , 40 , 48 , 41 , 34 , 
2008:	27 , 20 , 13 , 6 , 7 , 14 , 21 , 28 , 
2009:	35 , 42 , 49 , 56 , 57 , 50 , 43 , 36 , 
2010:	29 , 22 , 15 , 23 , 30 , 37 , 44 , 51 , 
2011:	58 , 59 , 52 , 45 , 38 , 31 , 39 , 46 , 
2012:	53 , 60 , 61 , 54 , 47 , 55 , 62 , 63 , 
2014:	63 , 63 , 63 , 63 , 63 , 63 , 63 , 63 , 
2015:	63 , 63 , 63 , 63 , 63 , 63 , 63 
2016:	} ; 
2019:	static int stbi__jpeg_decode_block ( stbi__jpeg * j , short data [ 64 ] , stbi__huffman * hdc , stbi__huffman * hac , stbi__int16 * fac , int b , stbi__uint16 * dequant ) 
2020:	{ 
2021:	int diff , dc , k ; 
2022:	int t ; 
2024:	if ( j -> code_bits < 16 ) stbi__grow_buffer_unsafe ( j ) ; 
2025:	t = stbi__jpeg_huff_decode ( j , hdc ) ; 
2026:	if ( t < 0 ) return stbi__err ( "bad huffman code" ) ; 
2029:	memset ( data , 0 , 64 * sizeof ( data [ 0 ] ) ) ; 
2031:	diff = t ? stbi__extend_receive ( j , t ) : 0 ; 
2032:	dc = j -> img_comp [ b ] . dc_pred + diff ; 
2033:	j -> img_comp [ b ] . dc_pred = dc ; 
2034:	data [ 0 ] = ( short ) ( dc * dequant [ 0 ] ) ; 
2037:	k = 1 ; 
2038:	do { 
2039:	unsigned int zig ; 
2040:	int c , r , s ; 
2041:	if ( j -> code_bits < 16 ) stbi__grow_buffer_unsafe ( j ) ; 
2042:	c = ( j -> code_buffer >> ( 32 - 9 ) ) & ( ( 1 << 9 ) - 1 ) ; 
2043:	r = fac [ c ] ; 
2044:	if ( r ) { 
2045:	k += ( r >> 4 ) & 15 ; 
2046:	s = r & 15 ; 
2047:	j -> code_buffer <<= s ; 
2048:	j -> code_bits -= s ; 
2050:	zig = stbi__jpeg_dezigzag [ k ++ ] ; 
2051:	data [ zig ] = ( short ) ( ( r >> 8 ) * dequant [ zig ] ) ; 
2052:	} else { 
2053:	int rs = stbi__jpeg_huff_decode ( j , hac ) ; 
2054:	if ( rs < 0 ) return stbi__err ( "bad huffman code" ) ; 
2055:	s = rs & 15 ; 
2056:	r = rs >> 4 ; 
2057:	if ( s == 0 ) { 
2058:	if ( rs != 0xf0 ) break ; 
2059:	k += 16 ; 
2060:	} else { 
2061:	k += r ; 
2063:	zig = stbi__jpeg_dezigzag [ k ++ ] ; 
2064:	data [ zig ] = ( short ) ( stbi__extend_receive ( j , s ) * dequant [ zig ] ) ; 
2065:	} 
2066:	} 
2067:	} while ( k < 64 ) ; 
2068:	return 1 ; 
2069:	} 
2071:	static int stbi__jpeg_decode_block_prog_dc ( stbi__jpeg * j , short data [ 64 ] , stbi__huffman * hdc , int b ) 
2072:	{ 
2073:	int diff , dc ; 
2074:	int t ; 
2075:	if ( j -> spec_end != 0 ) return stbi__err ( "can't merge dc and ac" ) ; 
2077:	if ( j -> code_bits < 16 ) stbi__grow_buffer_unsafe ( j ) ; 
2079:	if ( j -> succ_high == 0 ) { 
2081:	memset ( data , 0 , 64 * sizeof ( data [ 0 ] ) ) ; 
2082:	t = stbi__jpeg_huff_decode ( j , hdc ) ; 
2083:	if ( t == - 1 ) return stbi__err ( "can't merge dc and ac" ) ; 
2084:	diff = t ? stbi__extend_receive ( j , t ) : 0 ; 
2086:	dc = j -> img_comp [ b ] . dc_pred + diff ; 
2087:	j -> img_comp [ b ] . dc_pred = dc ; 
2088:	data [ 0 ] = ( short ) ( dc << j -> succ_low ) ; 
2089:	} else { 
2091:	if ( stbi__jpeg_get_bit ( j ) ) 
2092:	data [ 0 ] += ( short ) ( 1 << j -> succ_low ) ; 
2093:	} 
2094:	return 1 ; 
2095:	} 
2099:	static int stbi__jpeg_decode_block_prog_ac ( stbi__jpeg * j , short data [ 64 ] , stbi__huffman * hac , stbi__int16 * fac ) 
2100:	{ 
2101:	int k ; 
2102:	if ( j -> spec_start == 0 ) return stbi__err ( "can't merge dc and ac" ) ; 
2104:	if ( j -> succ_high == 0 ) { 
2105:	int shift = j -> succ_low ; 
2107:	if ( j -> eob_run ) { 
2108:	-- j -> eob_run ; 
2109:	return 1 ; 
2110:	} 
2112:	k = j -> spec_start ; 
2113:	do { 
2114:	unsigned int zig ; 
2115:	int c , r , s ; 
2116:	if ( j -> code_bits < 16 ) stbi__grow_buffer_unsafe ( j ) ; 
2117:	c = ( j -> code_buffer >> ( 32 - 9 ) ) & ( ( 1 << 9 ) - 1 ) ; 
2118:	r = fac [ c ] ; 
2119:	if ( r ) { 
2120:	k += ( r >> 4 ) & 15 ; 
2121:	s = r & 15 ; 
2122:	j -> code_buffer <<= s ; 
2123:	j -> code_bits -= s ; 
2124:	zig = stbi__jpeg_dezigzag [ k ++ ] ; 
2125:	data [ zig ] = ( short ) ( ( r >> 8 ) << shift ) ; 
2126:	} else { 
2127:	int rs = stbi__jpeg_huff_decode ( j , hac ) ; 
2128:	if ( rs < 0 ) return stbi__err ( "bad huffman code" ) ; 
2129:	s = rs & 15 ; 
2130:	r = rs >> 4 ; 
2131:	if ( s == 0 ) { 
2132:	if ( r < 15 ) { 
2133:	j -> eob_run = ( 1 << r ) ; 
2134:	if ( r ) 
2135:	j -> eob_run += stbi__jpeg_get_bits ( j , r ) ; 
2136:	-- j -> eob_run ; 
2137:	break ; 
2138:	} 
2139:	k += 16 ; 
2140:	} else { 
2141:	k += r ; 
2142:	zig = stbi__jpeg_dezigzag [ k ++ ] ; 
2143:	data [ zig ] = ( short ) ( stbi__extend_receive ( j , s ) << shift ) ; 
2144:	} 
2145:	} 
2146:	} while ( k <= j -> spec_end ) ; 
2147:	} else { 
2150:	short bit = ( short ) ( 1 << j -> succ_low ) ; 
2152:	if ( j -> eob_run ) { 
2153:	-- j -> eob_run ; 
2154:	for ( k = j -> spec_start ; k <= j -> spec_end ; ++ k ) { 
2155:	short * p = & data [ stbi__jpeg_dezigzag [ k ] ] ; 
2156:	if ( * p != 0 ) 
2157:	if ( stbi__jpeg_get_bit ( j ) ) 
2158:	if ( ( * p & bit ) == 0 ) { 
2159:	if ( * p > 0 ) 
2160:	* p += bit ; 
2161:	else 
2162:	* p -= bit ; 
2163:	} 
2164:	} 
2165:	} else { 
2166:	k = j -> spec_start ; 
2167:	do { 
2168:	int r , s ; 
2169:	int rs = stbi__jpeg_huff_decode ( j , hac ) ; 
2170:	if ( rs < 0 ) return stbi__err ( "bad huffman code" ) ; 
2171:	s = rs & 15 ; 
2172:	r = rs >> 4 ; 
2173:	if ( s == 0 ) { 
2174:	if ( r < 15 ) { 
2175:	j -> eob_run = ( 1 << r ) - 1 ; 
2176:	if ( r ) 
2177:	j -> eob_run += stbi__jpeg_get_bits ( j , r ) ; 
2178:	r = 64 ; 
2179:	} else { 
2183:	} 
2184:	} else { 
2185:	if ( s != 1 ) return stbi__err ( "bad huffman code" ) ; 
2187:	if ( stbi__jpeg_get_bit ( j ) ) 
2188:	s = bit ; 
2189:	else 
2190:	s = - bit ; 
2191:	} 
2194:	while ( k <= j -> spec_end ) { 
2195:	short * p = & data [ stbi__jpeg_dezigzag [ k ++ ] ] ; 
2196:	if ( * p != 0 ) { 
2197:	if ( stbi__jpeg_get_bit ( j ) ) 
2198:	if ( ( * p & bit ) == 0 ) { 
2199:	if ( * p > 0 ) 
2200:	* p += bit ; 
2201:	else 
2202:	* p -= bit ; 
2203:	} 
2204:	} else { 
2205:	if ( r == 0 ) { 
2206:	* p = ( short ) s ; 
2207:	break ; 
2208:	} 
2209:	-- r ; 
2210:	} 
2211:	} 
2212:	} while ( k <= j -> spec_end ) ; 
2213:	} 
2214:	} 
2215:	return 1 ; 
2216:	} 
2219:	static stbi_uc stbi__clamp ( int x ) 
2220:	{ 
2222:	if ( ( unsigned int ) x > 255 ) { 
2223:	if ( x < 0 ) return 0 ; 
2224:	if ( x > 255 ) return 255 ; 
2225:	} 
2226:	return ( stbi_uc ) x ; 
2227:	} 
2235:	static void stbi__idct_block ( stbi_uc * out , int out_stride , short data [ 64 ] ) 
2236:	{ 
2237:	int i , val [ 64 ] , * v = val ; 
2238:	stbi_uc * o ; 
2239:	short * d = data ; 
2242:	for ( i = 0 ; i < 8 ; ++ i , ++ d , ++ v ) { 
2244:	if ( d [ 8 ] == 0 && d [ 16 ] == 0 && d [ 24 ] == 0 && d [ 32 ] == 0 
2245:	&& d [ 40 ] == 0 && d [ 48 ] == 0 && d [ 56 ] == 0 ) { 
2250:	int dcterm = d [ 0 ] * 4 ; 
2251:	v [ 0 ] = v [ 8 ] = v [ 16 ] = v [ 24 ] = v [ 32 ] = v [ 40 ] = v [ 48 ] = v [ 56 ] = dcterm ; 
2252:	} else { 
2253:	int t0 , t1 , t2 , t3 , p1 , p2 , p3 , p4 , p5 , x0 , x1 , x2 , x3 ; p2 = d [ 16 ] ; p3 = d [ 48 ] ; p1 = ( p2 + p3 ) * ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) ; t2 = p1 + p3 * ( ( int ) ( ( ( - 1 . 847759065 f ) * 4096 + 0 . 5 ) ) ) ; t3 = p1 + p2 * ( ( int ) ( ( ( 0 . 765366865 f ) * 4096 + 0 . 5 ) ) ) ; p2 = d [ 0 ] ; p3 = d [ 32 ] ; t0 = ( ( p2 + p3 ) * 4096 ) ; t1 = ( ( p2 - p3 ) * 4096 ) ; x0 = t0 + t3 ; x3 = t0 - t3 ; x1 = t1 + t2 ; x2 = t1 - t2 ; t0 = d [ 56 ] ; t1 = d [ 40 ] ; t2 = d [ 24 ] ; t3 = d [ 8 ] ; p3 = t0 + t2 ; p4 = t1 + t3 ; p1 = t0 + t3 ; p2 = t1 + t2 ; p5 = ( p3 + p4 ) * ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) ; t0 = t0 * ( ( int ) ( ( ( 0 . 298631336 f ) * 4096 + 0 . 5 ) ) ) ; t1 = t1 * ( ( int ) ( ( ( 2 . 053119869 f ) * 4096 + 0 . 5 ) ) ) ; t2 = t2 * ( ( int ) ( ( ( 3 . 072711026 f ) * 4096 + 0 . 5 ) ) ) ; t3 = t3 * ( ( int ) ( ( ( 1 . 501321110 f ) * 4096 + 0 . 5 ) ) ) ; p1 = p5 + p1 * ( ( int ) ( ( ( - 0 . 899976223 f ) * 4096 + 0 . 5 ) ) ) ; p2 = p5 + p2 * ( ( int ) ( ( ( - 2 . 562915447 f ) * 4096 + 0 . 5 ) ) ) ; p3 = p3 * ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) ; p4 = p4 * ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) ; t3 += p1 + p4 ; t2 += p2 + p3 ; t1 += p2 + p4 ; t0 += p1 + p3 ; 
2256:	x0 += 512 ; x1 += 512 ; x2 += 512 ; x3 += 512 ; 
2257:	v [ 0 ] = ( x0 + t3 ) >> 10 ; 
2258:	v [ 56 ] = ( x0 - t3 ) >> 10 ; 
2259:	v [ 8 ] = ( x1 + t2 ) >> 10 ; 
2260:	v [ 48 ] = ( x1 - t2 ) >> 10 ; 
2261:	v [ 16 ] = ( x2 + t1 ) >> 10 ; 
2262:	v [ 40 ] = ( x2 - t1 ) >> 10 ; 
2263:	v [ 24 ] = ( x3 + t0 ) >> 10 ; 
2264:	v [ 32 ] = ( x3 - t0 ) >> 10 ; 
2265:	} 
2266:	} 
2268:	for ( i = 0 , v = val , o = out ; i < 8 ; ++ i , v += 8 , o += out_stride ) { 
2270:	int t0 , t1 , t2 , t3 , p1 , p2 , p3 , p4 , p5 , x0 , x1 , x2 , x3 ; p2 = v [ 2 ] ; p3 = v [ 6 ] ; p1 = ( p2 + p3 ) * ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) ; t2 = p1 + p3 * ( ( int ) ( ( ( - 1 . 847759065 f ) * 4096 + 0 . 5 ) ) ) ; t3 = p1 + p2 * ( ( int ) ( ( ( 0 . 765366865 f ) * 4096 + 0 . 5 ) ) ) ; p2 = v [ 0 ] ; p3 = v [ 4 ] ; t0 = ( ( p2 + p3 ) * 4096 ) ; t1 = ( ( p2 - p3 ) * 4096 ) ; x0 = t0 + t3 ; x3 = t0 - t3 ; x1 = t1 + t2 ; x2 = t1 - t2 ; t0 = v [ 7 ] ; t1 = v [ 5 ] ; t2 = v [ 3 ] ; t3 = v [ 1 ] ; p3 = t0 + t2 ; p4 = t1 + t3 ; p1 = t0 + t3 ; p2 = t1 + t2 ; p5 = ( p3 + p4 ) * ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) ; t0 = t0 * ( ( int ) ( ( ( 0 . 298631336 f ) * 4096 + 0 . 5 ) ) ) ; t1 = t1 * ( ( int ) ( ( ( 2 . 053119869 f ) * 4096 + 0 . 5 ) ) ) ; t2 = t2 * ( ( int ) ( ( ( 3 . 072711026 f ) * 4096 + 0 . 5 ) ) ) ; t3 = t3 * ( ( int ) ( ( ( 1 . 501321110 f ) * 4096 + 0 . 5 ) ) ) ; p1 = p5 + p1 * ( ( int ) ( ( ( - 0 . 899976223 f ) * 4096 + 0 . 5 ) ) ) ; p2 = p5 + p2 * ( ( int ) ( ( ( - 2 . 562915447 f ) * 4096 + 0 . 5 ) ) ) ; p3 = p3 * ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) ; p4 = p4 * ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) ; t3 += p1 + p4 ; t2 += p2 + p3 ; t1 += p2 + p4 ; t0 += p1 + p3 ; 
2277:	x0 += 65536 + ( 128 << 17 ) ; 
2278:	x1 += 65536 + ( 128 << 17 ) ; 
2279:	x2 += 65536 + ( 128 << 17 ) ; 
2280:	x3 += 65536 + ( 128 << 17 ) ; 
2283:	o [ 0 ] = stbi__clamp ( ( x0 + t3 ) >> 17 ) ; 
2284:	o [ 7 ] = stbi__clamp ( ( x0 - t3 ) >> 17 ) ; 
2285:	o [ 1 ] = stbi__clamp ( ( x1 + t2 ) >> 17 ) ; 
2286:	o [ 6 ] = stbi__clamp ( ( x1 - t2 ) >> 17 ) ; 
2287:	o [ 2 ] = stbi__clamp ( ( x2 + t1 ) >> 17 ) ; 
2288:	o [ 5 ] = stbi__clamp ( ( x2 - t1 ) >> 17 ) ; 
2289:	o [ 3 ] = stbi__clamp ( ( x3 + t0 ) >> 17 ) ; 
2290:	o [ 4 ] = stbi__clamp ( ( x3 - t0 ) >> 17 ) ; 
2291:	} 
2292:	} 
2298:	static void stbi__idct_simd ( stbi_uc * out , int out_stride , short data [ 64 ] ) 
2299:	{ 
2301:	__m128i row0 , row1 , row2 , row3 , row4 , row5 , row6 , row7 ; 
2302:	__m128i tmp ; 
2329:	__m128i rot0_0lo = _mm_unpacklo_epi16 ( ( row2 ) , ( row6 ) ) ; __m128i rot0_0hi = _mm_unpackhi_epi16 ( ( row2 ) , ( row6 ) ) ; __m128i t2e_l = _mm_madd_epi16 ( rot0_0lo , rot0_0 ) ; __m128i t2e_h = _mm_madd_epi16 ( rot0_0hi , rot0_0 ) ; __m128i t3e_l = _mm_madd_epi16 ( rot0_0lo , rot0_1 ) ; __m128i t3e_h = _mm_madd_epi16 ( rot0_0hi , rot0_1 ) ; __m128i sum04 = _mm_add_epi16 ( row0 , row4 ) ; __m128i dif04 = _mm_sub_epi16 ( row0 , row4 ) ; __m128i t0e_l = _mm_srai_epi32 ( _mm_unpacklo_epi16 ( _mm_setzero_si128 ( ) , ( sum04 ) ) , 4 ) ; __m128i t0e_h = _mm_srai_epi32 ( _mm_unpackhi_epi16 ( _mm_setzero_si128 ( ) , ( sum04 ) ) , 4 ) ; __m128i t1e_l = _mm_srai_epi32 ( _mm_unpacklo_epi16 ( _mm_setzero_si128 ( ) , ( dif04 ) ) , 4 ) ; __m128i t1e_h = _mm_srai_epi32 ( _mm_unpackhi_epi16 ( _mm_setzero_si128 ( ) , ( dif04 ) ) , 4 ) ; __m128i x0_l = _mm_add_epi32 ( t0e_l , t3e_l ) ; __m128i x0_h = _mm_add_epi32 ( t0e_h , t3e_h ) ; __m128i x3_l = _mm_sub_epi32 ( t0e_l , t3e_l ) ; __m128i x3_h = _mm_sub_epi32 ( t0e_h , t3e_h ) ; __m128i x1_l = _mm_add_epi32 ( t1e_l , t2e_l ) ; __m128i x1_h = _mm_add_epi32 ( t1e_h , t2e_h ) ; __m128i x2_l = _mm_sub_epi32 ( t1e_l , t2e_l ) ; __m128i x2_h = _mm_sub_epi32 ( t1e_h , t2e_h ) ; __m128i rot2_0lo = _mm_unpacklo_epi16 ( ( row7 ) , ( row3 ) ) ; __m128i rot2_0hi = _mm_unpackhi_epi16 ( ( row7 ) , ( row3 ) ) ; __m128i y0o_l = _mm_madd_epi16 ( rot2_0lo , rot2_0 ) ; __m128i y0o_h = _mm_madd_epi16 ( rot2_0hi , rot2_0 ) ; __m128i y2o_l = _mm_madd_epi16 ( rot2_0lo , rot2_1 ) ; __m128i y2o_h = _mm_madd_epi16 ( rot2_0hi , rot2_1 ) ; __m128i rot3_0lo = _mm_unpacklo_epi16 ( ( row5 ) , ( row1 ) ) ; __m128i rot3_0hi = _mm_unpackhi_epi16 ( ( row5 ) , ( row1 ) ) ; __m128i y1o_l = _mm_madd_epi16 ( rot3_0lo , rot3_0 ) ; __m128i y1o_h = _mm_madd_epi16 ( rot3_0hi , rot3_0 ) ; __m128i y3o_l = _mm_madd_epi16 ( rot3_0lo , rot3_1 ) ; __m128i y3o_h = _mm_madd_epi16 ( rot3_0hi , rot3_1 ) ; __m128i sum17 = _mm_add_epi16 ( row1 , row7 ) ; __m128i sum35 = _mm_add_epi16 ( row3 , row5 ) ; __m128i rot1_0lo = _mm_unpacklo_epi16 ( ( sum17 ) , ( sum35 ) ) ; __m128i rot1_0hi = _mm_unpackhi_epi16 ( ( sum17 ) , ( sum35 ) ) ; __m128i y4o_l = _mm_madd_epi16 ( rot1_0lo , rot1_0 ) ; __m128i y4o_h = _mm_madd_epi16 ( rot1_0hi , rot1_0 ) ; __m128i y5o_l = _mm_madd_epi16 ( rot1_0lo , rot1_1 ) ; __m128i y5o_h = _mm_madd_epi16 ( rot1_0hi , rot1_1 ) ; __m128i x4_l = _mm_add_epi32 ( y0o_l , y4o_l ) ; __m128i x4_h = _mm_add_epi32 ( y0o_h , y4o_h ) ; __m128i x5_l = _mm_add_epi32 ( y1o_l , y5o_l ) ; __m128i x5_h = _mm_add_epi32 ( y1o_h , y5o_h ) ; __m128i x6_l = _mm_add_epi32 ( y2o_l , y5o_l ) ; __m128i x6_h = _mm_add_epi32 ( y2o_h , y5o_h ) ; __m128i x7_l = _mm_add_epi32 ( y3o_l , y4o_l ) ; __m128i x7_h = _mm_add_epi32 ( y3o_h , y4o_h ) ; { __m128i abiased_l = _mm_add_epi32 ( x0_l , bias ) ; __m128i abiased_h = _mm_add_epi32 ( x0_h , bias ) ; __m128i sum_l = _mm_add_epi32 ( abiased_l , x7_l ) ; __m128i sum_h = _mm_add_epi32 ( abiased_h , x7_h ) ; __m128i dif_l = _mm_sub_epi32 ( abiased_l , x7_l ) ; __m128i dif_h = _mm_sub_epi32 ( abiased_h , x7_h ) ; row0 = _mm_packs_epi32 ( _mm_srai_epi32 ( sum_l , shift ) , _mm_srai_epi32 ( sum_h , shift ) ) ; row7 = _mm_packs_epi32 ( _mm_srai_epi32 ( dif_l , shift ) , _mm_srai_epi32 ( dif_h , shift ) ) ; } ; { __m128i abiased_l = _mm_add_epi32 ( x1_l , bias ) ; __m128i abiased_h = _mm_add_epi32 ( x1_h , bias ) ; __m128i sum_l = _mm_add_epi32 ( abiased_l , x6_l ) ; __m128i sum_h = _mm_add_epi32 ( abiased_h , x6_h ) ; __m128i dif_l = _mm_sub_epi32 ( abiased_l , x6_l ) ; __m128i dif_h = _mm_sub_epi32 ( abiased_h , x6_h ) ; row1 = _mm_packs_epi32 ( _mm_srai_epi32 ( sum_l , shift ) , _mm_srai_epi32 ( sum_h , shift ) ) ; row6 = _mm_packs_epi32 ( _mm_srai_epi32 ( dif_l , shift ) , _mm_srai_epi32 ( dif_h , shift ) ) ; } ; { __m128i abiased_l = _mm_add_epi32 ( x2_l , bias ) ; __m128i abiased_h = _mm_add_epi32 ( x2_h , bias ) ; __m128i sum_l = _mm_add_epi32 ( abiased_l , x5_l ) ; __m128i sum_h = _mm_add_epi32 ( abiased_h , x5_h ) ; __m128i dif_l = _mm_sub_epi32 ( abiased_l , x5_l ) ; __m128i dif_h = _mm_sub_epi32 ( abiased_h , x5_h ) ; row2 = _mm_packs_epi32 ( _mm_srai_epi32 ( sum_l , shift ) , _mm_srai_epi32 ( sum_h , shift ) ) ; row5 = _mm_packs_epi32 ( _mm_srai_epi32 ( dif_l , shift ) , _mm_srai_epi32 ( dif_h , shift ) ) ; } ; { __m128i abiased_l = _mm_add_epi32 ( x3_l , bias ) ; __m128i abiased_h = _mm_add_epi32 ( x3_h , bias ) ; __m128i sum_l = _mm_add_epi32 ( abiased_l , x4_l ) ; __m128i sum_h = _mm_add_epi32 ( abiased_h , x4_h ) ; __m128i dif_l = _mm_sub_epi32 ( abiased_l , x4_l ) ; __m128i dif_h = _mm_sub_epi32 ( abiased_h , x4_h ) ; row3 = _mm_packs_epi32 ( _mm_srai_epi32 ( sum_l , shift ) , _mm_srai_epi32 ( sum_h , shift ) ) ; row4 = _mm_packs_epi32 ( _mm_srai_epi32 ( dif_l , shift ) , _mm_srai_epi32 ( dif_h , shift ) ) ; } ; } 
2331:	__m128i rot0_0 = _mm_setr_epi16 ( ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( - 1 . 847759065 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( - 1 . 847759065 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( - 1 . 847759065 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( - 1 . 847759065 f ) * 4096 + 0 . 5 ) ) ) ) ) ; 
2332:	__m128i rot0_1 = _mm_setr_epi16 ( ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 0 . 765366865 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 0 . 765366865 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 0 . 765366865 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 0 . 765366865 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 0 . 5411961 f ) * 4096 + 0 . 5 ) ) ) ) ) ; 
2333:	__m128i rot1_0 = _mm_setr_epi16 ( ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( - 0 . 899976223 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( - 0 . 899976223 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( - 0 . 899976223 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( - 0 . 899976223 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) ) ) ; 
2334:	__m128i rot1_1 = _mm_setr_epi16 ( ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( - 2 . 562915447 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( - 2 . 562915447 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( - 2 . 562915447 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( 1 . 175875602 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( - 2 . 562915447 f ) * 4096 + 0 . 5 ) ) ) ) ) ; 
2335:	__m128i rot2_0 = _mm_setr_epi16 ( ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 0 . 298631336 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 0 . 298631336 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 0 . 298631336 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 0 . 298631336 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) ) ) ; 
2336:	__m128i rot2_1 = _mm_setr_epi16 ( ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 3 . 072711026 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 3 . 072711026 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 3 . 072711026 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 1 . 961570560 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 3 . 072711026 f ) * 4096 + 0 . 5 ) ) ) ) ) ; 
2337:	__m128i rot3_0 = _mm_setr_epi16 ( ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 2 . 053119869 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 2 . 053119869 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 2 . 053119869 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 2 . 053119869 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) ) ) ; 
2338:	__m128i rot3_1 = _mm_setr_epi16 ( ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 1 . 501321110 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 1 . 501321110 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 1 . 501321110 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) ) , ( ( ( int ) ( ( ( - 0 . 390180644 f ) * 4096 + 0 . 5 ) ) ) + ( ( int ) ( ( ( 1 . 501321110 f ) * 4096 + 0 . 5 ) ) ) ) ) ; 
2341:	__m128i bias_0 = _mm_set1_epi32 ( 512 ) ; 
2342:	__m128i bias_1 = _mm_set1_epi32 ( 65536 + ( 128 << 17 ) ) ; 
2345:	row0 = _mm_load_si128 ( ( const __m128i * ) ( data + 0 * 8 ) ) ; 
2346:	row1 = _mm_load_si128 ( ( const __m128i * ) ( data + 1 * 8 ) ) ; 
2347:	row2 = _mm_load_si128 ( ( const __m128i * ) ( data + 2 * 8 ) ) ; 
2348:	row3 = _mm_load_si128 ( ( const __m128i * ) ( data + 3 * 8 ) ) ; 
2349:	row4 = _mm_load_si128 ( ( const __m128i * ) ( data + 4 * 8 ) ) ; 
2350:	row5 = _mm_load_si128 ( ( const __m128i * ) ( data + 5 * 8 ) ) ; 
2351:	row6 = _mm_load_si128 ( ( const __m128i * ) ( data + 6 * 8 ) ) ; 
2352:	row7 = _mm_load_si128 ( ( const __m128i * ) ( data + 7 * 8 ) ) ; 
2355:	{ ; 
2357:	{ 
2359:	tmp = row0 ; row0 = _mm_unpacklo_epi16 ( row0 , row4 ) ; row4 = _mm_unpackhi_epi16 ( tmp , row4 ) ; 
2360:	tmp = row1 ; row1 = _mm_unpacklo_epi16 ( row1 , row5 ) ; row5 = _mm_unpackhi_epi16 ( tmp , row5 ) ; 
2361:	tmp = row2 ; row2 = _mm_unpacklo_epi16 ( row2 , row6 ) ; row6 = _mm_unpackhi_epi16 ( tmp , row6 ) ; 
2362:	tmp = row3 ; row3 = _mm_unpacklo_epi16 ( row3 , row7 ) ; row7 = _mm_unpackhi_epi16 ( tmp , row7 ) ; 
2365:	tmp = row0 ; row0 = _mm_unpacklo_epi16 ( row0 , row2 ) ; row2 = _mm_unpackhi_epi16 ( tmp , row2 ) ; 
2366:	tmp = row1 ; row1 = _mm_unpacklo_epi16 ( row1 , row3 ) ; row3 = _mm_unpackhi_epi16 ( tmp , row3 ) ; 
2367:	tmp = row4 ; row4 = _mm_unpacklo_epi16 ( row4 , row6 ) ; row6 = _mm_unpackhi_epi16 ( tmp , row6 ) ; 
2368:	tmp = row5 ; row5 = _mm_unpacklo_epi16 ( row5 , row7 ) ; row7 = _mm_unpackhi_epi16 ( tmp , row7 ) ; 
2371:	tmp = row0 ; row0 = _mm_unpacklo_epi16 ( row0 , row1 ) ; row1 = _mm_unpackhi_epi16 ( tmp , row1 ) ; 
2372:	tmp = row2 ; row2 = _mm_unpacklo_epi16 ( row2 , row3 ) ; row3 = _mm_unpackhi_epi16 ( tmp , row3 ) ; 
2373:	tmp = row4 ; row4 = _mm_unpacklo_epi16 ( row4 , row5 ) ; row5 = _mm_unpackhi_epi16 ( tmp , row5 ) ; 
2374:	tmp = row6 ; row6 = _mm_unpacklo_epi16 ( row6 , row7 ) ; row7 = _mm_unpackhi_epi16 ( tmp , row7 ) ; 
2375:	} 
2378:	{ ; 
2380:	{ 
2382:	__m128i p0 = _mm_packus_epi16 ( row0 , row1 ) ; 
2383:	__m128i p1 = _mm_packus_epi16 ( row2 , row3 ) ; 
2384:	__m128i p2 = _mm_packus_epi16 ( row4 , row5 ) ; 
2385:	__m128i p3 = _mm_packus_epi16 ( row6 , row7 ) ; 
2388:	tmp = p0 ; p0 = _mm_unpacklo_epi8 ( p0 , p2 ) ; p2 = _mm_unpackhi_epi8 ( tmp , p2 ) ; 
2389:	tmp = p1 ; p1 = _mm_unpacklo_epi8 ( p1 , p3 ) ; p3 = _mm_unpackhi_epi8 ( tmp , p3 ) ; 
2392:	tmp = p0 ; p0 = _mm_unpacklo_epi8 ( p0 , p1 ) ; p1 = _mm_unpackhi_epi8 ( tmp , p1 ) ; 
2393:	tmp = p2 ; p2 = _mm_unpacklo_epi8 ( p2 , p3 ) ; p3 = _mm_unpackhi_epi8 ( tmp , p3 ) ; 
2396:	tmp = p0 ; p0 = _mm_unpacklo_epi8 ( p0 , p2 ) ; p2 = _mm_unpackhi_epi8 ( tmp , p2 ) ; 
2397:	tmp = p1 ; p1 = _mm_unpacklo_epi8 ( p1 , p3 ) ; p3 = _mm_unpackhi_epi8 ( tmp , p3 ) ; 
2400:	_mm_storel_epi64 ( ( __m128i * ) out , p0 ) ; out += out_stride ; 
2401:	_mm_storel_epi64 ( ( __m128i * ) out , _mm_shuffle_epi32 ( p0 , 0x4e ) ) ; out += out_stride ; 
2402:	_mm_storel_epi64 ( ( __m128i * ) out , p2 ) ; out += out_stride ; 
2403:	_mm_storel_epi64 ( ( __m128i * ) out , _mm_shuffle_epi32 ( p2 , 0x4e ) ) ; out += out_stride ; 
2404:	_mm_storel_epi64 ( ( __m128i * ) out , p1 ) ; out += out_stride ; 
2405:	_mm_storel_epi64 ( ( __m128i * ) out , _mm_shuffle_epi32 ( p1 , 0x4e ) ) ; out += out_stride ; 
2406:	_mm_storel_epi64 ( ( __m128i * ) out , p3 ) ; out += out_stride ; 
2407:	_mm_storel_epi64 ( ( __m128i * ) out , _mm_shuffle_epi32 ( p3 , 0x4e ) ) ; 
2408:	} 
2419:	} 
2581:	static stbi_uc stbi__get_marker ( stbi__jpeg * j ) 
2582:	{ 
2583:	stbi_uc x ; 
2584:	if ( j -> marker != 0xff ) { x = j -> marker ; j -> marker = 0xff ; return x ; } 
2585:	x = stbi__get8 ( j -> s ) ; 
2586:	if ( x != 0xff ) return 0xff ; 
2587:	while ( x == 0xff ) 
2588:	x = stbi__get8 ( j -> s ) ; 
2589:	return x ; 
2590:	} 
2598:	static void stbi__jpeg_reset ( stbi__jpeg * j ) 
2599:	{ 
2600:	j -> code_bits = 0 ; 
2601:	j -> code_buffer = 0 ; 
2602:	j -> nomore = 0 ; 
2603:	j -> img_comp [ 0 ] . dc_pred = j -> img_comp [ 1 ] . dc_pred = j -> img_comp [ 2 ] . dc_pred = j -> img_comp [ 3 ] . dc_pred = 0 ; 
2604:	j -> marker = 0xff ; 
2605:	j -> todo = j -> restart_interval ? j -> restart_interval : 0x7fffffff ; 
2606:	j -> eob_run = 0 ; 
2609:	} 
2611:	static int stbi__parse_entropy_coded_data ( stbi__jpeg * z ) 
2612:	{ 
2613:	stbi__jpeg_reset ( z ) ; 
2614:	if ( ! z -> progressive ) { 
2615:	if ( z -> scan_n == 1 ) { 
2616:	int i , j ; 
2617:	short data [ 64 ] __attribute__ ( ( aligned ( 16 ) ) ) ; 
2618:	int n = z -> order [ 0 ] ; 
2623:	int w = ( z -> img_comp [ n ] . x + 7 ) >> 3 ; 
2624:	int h = ( z -> img_comp [ n ] . y + 7 ) >> 3 ; 
2625:	for ( j = 0 ; j < h ; ++ j ) { 
2626:	for ( i = 0 ; i < w ; ++ i ) { 
2627:	int ha = z -> img_comp [ n ] . ha ; 
2628:	if ( ! stbi__jpeg_decode_block ( z , data , z -> huff_dc + z -> img_comp [ n ] . hd , z -> huff_ac + ha , z -> fast_ac [ ha ] , n , z -> dequant [ z -> img_comp [ n ] . tq ] ) ) return 0 ; 
2629:	z -> idct_block_kernel ( z -> img_comp [ n ] . data + z -> img_comp [ n ] . w2 * j * 8 + i * 8 , z -> img_comp [ n ] . w2 , data ) ; 
2631:	if ( -- z -> todo <= 0 ) { 
2632:	if ( z -> code_bits < 24 ) stbi__grow_buffer_unsafe ( z ) ; 
2635:	if ( ! ( ( z -> marker ) >= 0xd0 && ( z -> marker ) <= 0xd7 ) ) return 1 ; 
2636:	stbi__jpeg_reset ( z ) ; 
2637:	} 
2638:	} 
2639:	} 
2640:	return 1 ; 
2641:	} else { 
2642:	int i , j , k , x , y ; 
2643:	short data [ 64 ] __attribute__ ( ( aligned ( 16 ) ) ) ; 
2644:	for ( j = 0 ; j < z -> img_mcu_y ; ++ j ) { 
2645:	for ( i = 0 ; i < z -> img_mcu_x ; ++ i ) { 
2647:	for ( k = 0 ; k < z -> scan_n ; ++ k ) { 
2648:	int n = z -> order [ k ] ; 
2651:	for ( y = 0 ; y < z -> img_comp [ n ] . v ; ++ y ) { 
2652:	for ( x = 0 ; x < z -> img_comp [ n ] . h ; ++ x ) { 
2653:	int x2 = ( i * z -> img_comp [ n ] . h + x ) * 8 ; 
2654:	int y2 = ( j * z -> img_comp [ n ] . v + y ) * 8 ; 
2655:	int ha = z -> img_comp [ n ] . ha ; 
2656:	if ( ! stbi__jpeg_decode_block ( z , data , z -> huff_dc + z -> img_comp [ n ] . hd , z -> huff_ac + ha , z -> fast_ac [ ha ] , n , z -> dequant [ z -> img_comp [ n ] . tq ] ) ) return 0 ; 
2657:	z -> idct_block_kernel ( z -> img_comp [ n ] . data + z -> img_comp [ n ] . w2 * y2 + x2 , z -> img_comp [ n ] . w2 , data ) ; 
2658:	} 
2659:	} 
2660:	} 
2663:	if ( -- z -> todo <= 0 ) { 
2664:	if ( z -> code_bits < 24 ) stbi__grow_buffer_unsafe ( z ) ; 
2665:	if ( ! ( ( z -> marker ) >= 0xd0 && ( z -> marker ) <= 0xd7 ) ) return 1 ; 
2666:	stbi__jpeg_reset ( z ) ; 
2667:	} 
2668:	} 
2669:	} 
2670:	return 1 ; 
2671:	} 
2672:	} else { 
2673:	if ( z -> scan_n == 1 ) { 
2674:	int i , j ; 
2675:	int n = z -> order [ 0 ] ; 
2680:	int w = ( z -> img_comp [ n ] . x + 7 ) >> 3 ; 
2681:	int h = ( z -> img_comp [ n ] . y + 7 ) >> 3 ; 
2682:	for ( j = 0 ; j < h ; ++ j ) { 
2683:	for ( i = 0 ; i < w ; ++ i ) { 
2684:	short * data = z -> img_comp [ n ] . coeff + 64 * ( i + j * z -> img_comp [ n ] . coeff_w ) ; 
2685:	if ( z -> spec_start == 0 ) { 
2686:	if ( ! stbi__jpeg_decode_block_prog_dc ( z , data , & z -> huff_dc [ z -> img_comp [ n ] . hd ] , n ) ) 
2687:	return 0 ; 
2688:	} else { 
2689:	int ha = z -> img_comp [ n ] . ha ; 
2690:	if ( ! stbi__jpeg_decode_block_prog_ac ( z , data , & z -> huff_ac [ ha ] , z -> fast_ac [ ha ] ) ) 
2691:	return 0 ; 
2692:	} 
2694:	if ( -- z -> todo <= 0 ) { 
2695:	if ( z -> code_bits < 24 ) stbi__grow_buffer_unsafe ( z ) ; 
2696:	if ( ! ( ( z -> marker ) >= 0xd0 && ( z -> marker ) <= 0xd7 ) ) return 1 ; 
2697:	stbi__jpeg_reset ( z ) ; 
2698:	} 
2699:	} 
2700:	} 
2701:	return 1 ; 
2702:	} else { 
2703:	int i , j , k , x , y ; 
2704:	for ( j = 0 ; j < z -> img_mcu_y ; ++ j ) { 
2705:	for ( i = 0 ; i < z -> img_mcu_x ; ++ i ) { 
2707:	for ( k = 0 ; k < z -> scan_n ; ++ k ) { 
2708:	int n = z -> order [ k ] ; 
2711:	for ( y = 0 ; y < z -> img_comp [ n ] . v ; ++ y ) { 
2712:	for ( x = 0 ; x < z -> img_comp [ n ] . h ; ++ x ) { 
2713:	int x2 = ( i * z -> img_comp [ n ] . h + x ) ; 
2714:	int y2 = ( j * z -> img_comp [ n ] . v + y ) ; 
2715:	short * data = z -> img_comp [ n ] . coeff + 64 * ( x2 + y2 * z -> img_comp [ n ] . coeff_w ) ; 
2716:	if ( ! stbi__jpeg_decode_block_prog_dc ( z , data , & z -> huff_dc [ z -> img_comp [ n ] . hd ] , n ) ) 
2717:	return 0 ; 
2718:	} 
2719:	} 
2720:	} 
2723:	if ( -- z -> todo <= 0 ) { 
2724:	if ( z -> code_bits < 24 ) stbi__grow_buffer_unsafe ( z ) ; 
2725:	if ( ! ( ( z -> marker ) >= 0xd0 && ( z -> marker ) <= 0xd7 ) ) return 1 ; 
2726:	stbi__jpeg_reset ( z ) ; 
2727:	} 
2728:	} 
2729:	} 
2730:	return 1 ; 
2731:	} 
2732:	} 
2733:	} 
2735:	static void stbi__jpeg_dequantize ( short * data , stbi__uint16 * dequant ) 
2736:	{ 
2737:	int i ; 
2738:	for ( i = 0 ; i < 64 ; ++ i ) 
2739:	data [ i ] *= dequant [ i ] ; 
2740:	} 
2742:	static void stbi__jpeg_finish ( stbi__jpeg * z ) 
2743:	{ 
2744:	if ( z -> progressive ) { 
2746:	int i , j , n ; 
2747:	for ( n = 0 ; n < z -> s -> img_n ; ++ n ) { 
2748:	int w = ( z -> img_comp [ n ] . x + 7 ) >> 3 ; 
2749:	int h = ( z -> img_comp [ n ] . y + 7 ) >> 3 ; 
2750:	for ( j = 0 ; j < h ; ++ j ) { 
2751:	for ( i = 0 ; i < w ; ++ i ) { 
2752:	short * data = z -> img_comp [ n ] . coeff + 64 * ( i + j * z -> img_comp [ n ] . coeff_w ) ; 
2753:	stbi__jpeg_dequantize ( data , z -> dequant [ z -> img_comp [ n ] . tq ] ) ; 
2754:	z -> idct_block_kernel ( z -> img_comp [ n ] . data + z -> img_comp [ n ] . w2 * j * 8 + i * 8 , z -> img_comp [ n ] . w2 , data ) ; 
2755:	} 
2756:	} 
2757:	} 
2758:	} 
2759:	} 
2761:	static int stbi__process_marker ( stbi__jpeg * z , int m ) 
2762:	{ 
2763:	int L ; 
2764:	switch ( m ) { 
2765:	case 0xff : 
2766:	return stbi__err ( "expected marker" ) ; 
2768:	case 0xDD : 
2769:	if ( stbi__get16be ( z -> s ) != 4 ) return stbi__err ( "bad DRI len" ) ; 
2770:	z -> restart_interval = stbi__get16be ( z -> s ) ; 
2771:	return 1 ; 
2773:	case 0xDB : 
2774:	L = stbi__get16be ( z -> s ) - 2 ; 
2775:	while ( L > 0 ) { 
2776:	int q = stbi__get8 ( z -> s ) ; 
2777:	int p = q >> 4 , sixteen = ( p != 0 ) ; 
2778:	int t = q & 15 , i ; 
2779:	if ( p != 0 && p != 1 ) return stbi__err ( "bad DQT type" ) ; 
2780:	if ( t > 3 ) return stbi__err ( "bad DQT table" ) ; 
2782:	for ( i = 0 ; i < 64 ; ++ i ) 
2783:	z -> dequant [ t ] [ stbi__jpeg_dezigzag [ i ] ] = ( stbi__uint16 ) ( sixteen ? stbi__get16be ( z -> s ) : stbi__get8 ( z -> s ) ) ; 
2784:	L -= ( sixteen ? 129 : 65 ) ; 
2785:	} 
2786:	return L == 0 ; 
2788:	case 0xC4 : 
2789:	L = stbi__get16be ( z -> s ) - 2 ; 
2790:	while ( L > 0 ) { 
2791:	stbi_uc * v ; 
2792:	int sizes [ 16 ] , i , n = 0 ; 
2793:	int q = stbi__get8 ( z -> s ) ; 
2794:	int tc = q >> 4 ; 
2795:	int th = q & 15 ; 
2796:	if ( tc > 1 || th > 3 ) return stbi__err ( "bad DHT header" ) ; 
2797:	for ( i = 0 ; i < 16 ; ++ i ) { 
2798:	sizes [ i ] = stbi__get8 ( z -> s ) ; 
2799:	n += sizes [ i ] ; 
2800:	} 
2801:	L -= 17 ; 
2802:	if ( tc == 0 ) { 
2803:	if ( ! stbi__build_huffman ( z -> huff_dc + th , sizes ) ) return 0 ; 
2804:	v = z -> huff_dc [ th ] . values ; 
2805:	} else { 
2806:	if ( ! stbi__build_huffman ( z -> huff_ac + th , sizes ) ) return 0 ; 
2807:	v = z -> huff_ac [ th ] . values ; 
2808:	} 
2809:	for ( i = 0 ; i < n ; ++ i ) 
2810:	v [ i ] = stbi__get8 ( z -> s ) ; 
2811:	if ( tc != 0 ) 
2812:	stbi__build_fast_ac ( z -> fast_ac [ th ] , z -> huff_ac + th ) ; 
2813:	L -= n ; 
2814:	} 
2815:	return L == 0 ; 
2816:	} 
2819:	if ( ( m >= 0xE0 && m <= 0xEF ) || m == 0xFE ) { 
2820:	L = stbi__get16be ( z -> s ) ; 
2821:	if ( L < 2 ) { 
2822:	if ( m == 0xFE ) 
2823:	return stbi__err ( "bad COM len" ) ; 
2824:	else 
2825:	return stbi__err ( "bad APP len" ) ; 
2826:	} 
2827:	L -= 2 ; 
2829:	if ( m == 0xE0 && L >= 5 ) { 
2830:	static const unsigned char tag [ 5 ] = { 'J' , 'F' , 'I' , 'F' , '\0' } ; 
2831:	int ok = 1 ; 
2832:	int i ; 
2833:	for ( i = 0 ; i < 5 ; ++ i ) 
2834:	if ( stbi__get8 ( z -> s ) != tag [ i ] ) 
2835:	ok = 0 ; 
2836:	L -= 5 ; 
2837:	if ( ok ) 
2838:	z -> jfif = 1 ; 
2839:	} else if ( m == 0xEE && L >= 12 ) { 
2840:	static const unsigned char tag [ 6 ] = { 'A' , 'd' , 'o' , 'b' , 'e' , '\0' } ; 
2841:	int ok = 1 ; 
2842:	int i ; 
2843:	for ( i = 0 ; i < 6 ; ++ i ) 
2844:	if ( stbi__get8 ( z -> s ) != tag [ i ] ) 
2845:	ok = 0 ; 
2846:	L -= 6 ; 
2847:	if ( ok ) { 
2848:	stbi__get8 ( z -> s ) ; 
2849:	stbi__get16be ( z -> s ) ; 
2850:	stbi__get16be ( z -> s ) ; 
2851:	z -> app14_color_transform = stbi__get8 ( z -> s ) ; 
2852:	L -= 6 ; 
2853:	} 
2854:	} 
2856:	stbi__skip ( z -> s , L ) ; 
2857:	return 1 ; 
2858:	} 
2860:	return stbi__err ( "unknown marker" ) ; 
2861:	} 
2864:	static int stbi__process_scan_header ( stbi__jpeg * z ) 
2865:	{ 
2866:	int i ; 
2867:	int Ls = stbi__get16be ( z -> s ) ; 
2868:	z -> scan_n = stbi__get8 ( z -> s ) ; 
2869:	if ( z -> scan_n < 1 || z -> scan_n > 4 || z -> scan_n > ( int ) z -> s -> img_n ) return stbi__err ( "bad SOS component count" ) ; 
2870:	if ( Ls != 6 + 2 * z -> scan_n ) return stbi__err ( "bad SOS len" ) ; 
2871:	for ( i = 0 ; i < z -> scan_n ; ++ i ) { 
2872:	int id = stbi__get8 ( z -> s ) , which ; 
2873:	int q = stbi__get8 ( z -> s ) ; 
2874:	for ( which = 0 ; which < z -> s -> img_n ; ++ which ) 
2875:	if ( z -> img_comp [ which ] . id == id ) 
2876:	break ; 
2877:	if ( which == z -> s -> img_n ) return 0 ; 
2878:	z -> img_comp [ which ] . hd = q >> 4 ; if ( z -> img_comp [ which ] . hd > 3 ) return stbi__err ( "bad DC huff" ) ; 
2879:	z -> img_comp [ which ] . ha = q & 15 ; if ( z -> img_comp [ which ] . ha > 3 ) return stbi__err ( "bad AC huff" ) ; 
2880:	z -> order [ i ] = which ; 
2881:	} 
2883:	{ 
2884:	int aa ; 
2885:	z -> spec_start = stbi__get8 ( z -> s ) ; 
2886:	z -> spec_end = stbi__get8 ( z -> s ) ; 
2887:	aa = stbi__get8 ( z -> s ) ; 
2888:	z -> succ_high = ( aa >> 4 ) ; 
2889:	z -> succ_low = ( aa & 15 ) ; 
2890:	if ( z -> progressive ) { 
2891:	if ( z -> spec_start > 63 || z -> spec_end > 63 || z -> spec_start > z -> spec_end || z -> succ_high > 13 || z -> succ_low > 13 ) 
2892:	return stbi__err ( "bad SOS" ) ; 
2893:	} else { 
2894:	if ( z -> spec_start != 0 ) return stbi__err ( "bad SOS" ) ; 
2895:	if ( z -> succ_high != 0 || z -> succ_low != 0 ) return stbi__err ( "bad SOS" ) ; 
2896:	z -> spec_end = 63 ; 
2897:	} 
2898:	} 
2900:	return 1 ; 
2901:	} 
2903:	static int stbi__free_jpeg_components ( stbi__jpeg * z , int ncomp , int why ) 
2904:	{ 
2905:	int i ; 
2906:	for ( i = 0 ; i < ncomp ; ++ i ) { 
2907:	if ( z -> img_comp [ i ] . raw_data ) { 
2908:	free ( z -> img_comp [ i ] . raw_data ) ; 
2909:	z -> img_comp [ i ] . raw_data = ( ( void * ) 0 ) ; 
2910:	z -> img_comp [ i ] . data = ( ( void * ) 0 ) ; 
2911:	} 
2912:	if ( z -> img_comp [ i ] . raw_coeff ) { 
2913:	free ( z -> img_comp [ i ] . raw_coeff ) ; 
2914:	z -> img_comp [ i ] . raw_coeff = 0 ; 
2915:	z -> img_comp [ i ] . coeff = 0 ; 
2916:	} 
2917:	if ( z -> img_comp [ i ] . linebuf ) { 
2918:	free ( z -> img_comp [ i ] . linebuf ) ; 
2919:	z -> img_comp [ i ] . linebuf = ( ( void * ) 0 ) ; 
2920:	} 
2921:	} 
2922:	return why ; 
2923:	} 
2925:	static int stbi__process_frame_header ( stbi__jpeg * z , int scan ) 
2926:	{ 
2927:	stbi__context * s = z -> s ; 
2928:	int Lf , p , i , q , h_max = 1 , v_max = 1 , c ; 
2929:	Lf = stbi__get16be ( s ) ; if ( Lf < 11 ) return stbi__err ( "bad SOF len" ) ; 
2930:	p = stbi__get8 ( s ) ; if ( p != 8 ) return stbi__err ( "only 8-bit" ) ; 
2931:	s -> img_y = stbi__get16be ( s ) ; if ( s -> img_y == 0 ) return stbi__err ( "no header height" ) ; 
2932:	s -> img_x = stbi__get16be ( s ) ; if ( s -> img_x == 0 ) return stbi__err ( "0 width" ) ; 
2933:	if ( s -> img_y > ( 1 << 24 ) ) return stbi__err ( "too large" ) ; 
2934:	if ( s -> img_x > ( 1 << 24 ) ) return stbi__err ( "too large" ) ; 
2935:	c = stbi__get8 ( s ) ; 
2936:	if ( c != 3 && c != 1 && c != 4 ) return stbi__err ( "bad component count" ) ; 
2937:	s -> img_n = c ; 
2938:	for ( i = 0 ; i < c ; ++ i ) { 
2939:	z -> img_comp [ i ] . data = ( ( void * ) 0 ) ; 
2940:	z -> img_comp [ i ] . linebuf = ( ( void * ) 0 ) ; 
2941:	} 
2943:	if ( Lf != 8 + 3 * s -> img_n ) return stbi__err ( "bad SOF len" ) ; 
2945:	z -> rgb = 0 ; 
2946:	for ( i = 0 ; i < s -> img_n ; ++ i ) { 
2947:	static const unsigned char rgb [ 3 ] = { 'R' , 'G' , 'B' } ; 
2948:	z -> img_comp [ i ] . id = stbi__get8 ( s ) ; 
2949:	if ( s -> img_n == 3 && z -> img_comp [ i ] . id == rgb [ i ] ) 
2950:	++ z -> rgb ; 
2951:	q = stbi__get8 ( s ) ; 
2952:	z -> img_comp [ i ] . h = ( q >> 4 ) ; if ( ! z -> img_comp [ i ] . h || z -> img_comp [ i ] . h > 4 ) return stbi__err ( "bad H" ) ; 
2953:	z -> img_comp [ i ] . v = q & 15 ; if ( ! z -> img_comp [ i ] . v || z -> img_comp [ i ] . v > 4 ) return stbi__err ( "bad V" ) ; 
2954:	z -> img_comp [ i ] . tq = stbi__get8 ( s ) ; if ( z -> img_comp [ i ] . tq > 3 ) return stbi__err ( "bad TQ" ) ; 
2955:	} 
2957:	if ( scan != STBI__SCAN_load ) return 1 ; 
2959:	if ( ! stbi__mad3sizes_valid ( s -> img_x , s -> img_y , s -> img_n , 0 ) ) return stbi__err ( "too large" ) ; 
2961:	for ( i = 0 ; i < s -> img_n ; ++ i ) { 
2962:	if ( z -> img_comp [ i ] . h > h_max ) h_max = z -> img_comp [ i ] . h ; 
2963:	if ( z -> img_comp [ i ] . v > v_max ) v_max = z -> img_comp [ i ] . v ; 
2964:	} 
2967:	z -> img_h_max = h_max ; 
2968:	z -> img_v_max = v_max ; 
2969:	z -> img_mcu_w = h_max * 8 ; 
2970:	z -> img_mcu_h = v_max * 8 ; 
2972:	z -> img_mcu_x = ( s -> img_x + z -> img_mcu_w - 1 ) / z -> img_mcu_w ; 
2973:	z -> img_mcu_y = ( s -> img_y + z -> img_mcu_h - 1 ) / z -> img_mcu_h ; 
2975:	for ( i = 0 ; i < s -> img_n ; ++ i ) { 
2977:	z -> img_comp [ i ] . x = ( s -> img_x * z -> img_comp [ i ] . h + h_max - 1 ) / h_max ; 
2978:	z -> img_comp [ i ] . y = ( s -> img_y * z -> img_comp [ i ] . v + v_max - 1 ) / v_max ; 
2986:	z -> img_comp [ i ] . w2 = z -> img_mcu_x * z -> img_comp [ i ] . h * 8 ; 
2987:	z -> img_comp [ i ] . h2 = z -> img_mcu_y * z -> img_comp [ i ] . v * 8 ; 
2988:	z -> img_comp [ i ] . coeff = 0 ; 
2989:	z -> img_comp [ i ] . raw_coeff = 0 ; 
2990:	z -> img_comp [ i ] . linebuf = ( ( void * ) 0 ) ; 
2991:	z -> img_comp [ i ] . raw_data = stbi__malloc_mad2 ( z -> img_comp [ i ] . w2 , z -> img_comp [ i ] . h2 , 15 ) ; 
2992:	if ( z -> img_comp [ i ] . raw_data == ( ( void * ) 0 ) ) 
2993:	return stbi__free_jpeg_components ( z , i + 1 , stbi__err ( "outofmem" ) ) ; 
2995:	z -> img_comp [ i ] . data = ( stbi_uc * ) ( ( ( size_t ) z -> img_comp [ i ] . raw_data + 15 ) & ~ 15 ) ; 
2996:	if ( z -> progressive ) { 
2998:	z -> img_comp [ i ] . coeff_w = z -> img_comp [ i ] . w2 / 8 ; 
2999:	z -> img_comp [ i ] . coeff_h = z -> img_comp [ i ] . h2 / 8 ; 
3000:	z -> img_comp [ i ] . raw_coeff = stbi__malloc_mad3 ( z -> img_comp [ i ] . w2 , z -> img_comp [ i ] . h2 , sizeof ( short ) , 15 ) ; 
3001:	if ( z -> img_comp [ i ] . raw_coeff == ( ( void * ) 0 ) ) 
3002:	return stbi__free_jpeg_components ( z , i + 1 , stbi__err ( "outofmem" ) ) ; 
3003:	z -> img_comp [ i ] . coeff = ( short * ) ( ( ( size_t ) z -> img_comp [ i ] . raw_coeff + 15 ) & ~ 15 ) ; 
3004:	} 
3005:	} 
3007:	return 1 ; 
3008:	} 
3019:	static int stbi__decode_jpeg_header ( stbi__jpeg * z , int scan ) 
3020:	{ 
3021:	int m ; 
3022:	z -> jfif = 0 ; 
3023:	z -> app14_color_transform = - 1 ; 
3024:	z -> marker = 0xff ; 
3025:	m = stbi__get_marker ( z ) ; 
3026:	if ( ! ( ( m ) == 0xd8 ) ) return stbi__err ( "no SOI" ) ; 
3027:	if ( scan == STBI__SCAN_type ) return 1 ; 
3028:	m = stbi__get_marker ( z ) ; 
3029:	while ( ! ( ( m ) == 0xc0 || ( m ) == 0xc1 || ( m ) == 0xc2 ) ) { 
3030:	if ( ! stbi__process_marker ( z , m ) ) return 0 ; 
3031:	m = stbi__get_marker ( z ) ; 
3032:	while ( m == 0xff ) { 
3034:	if ( stbi__at_eof ( z -> s ) ) return stbi__err ( "no SOF" ) ; 
3035:	m = stbi__get_marker ( z ) ; 
3036:	} 
3037:	} 
3038:	z -> progressive = ( ( m ) == 0xc2 ) ; 
3039:	if ( ! stbi__process_frame_header ( z , scan ) ) return 0 ; 
3040:	return 1 ; 
3041:	} 
3044:	static int stbi__decode_jpeg_image ( stbi__jpeg * j ) 
3045:	{ 
3046:	int m ; 
3047:	for ( m = 0 ; m < 4 ; m ++ ) { 
3048:	j -> img_comp [ m ] . raw_data = ( ( void * ) 0 ) ; 
3049:	j -> img_comp [ m ] . raw_coeff = ( ( void * ) 0 ) ; 
3050:	} 
3051:	j -> restart_interval = 0 ; 
3052:	if ( ! stbi__decode_jpeg_header ( j , STBI__SCAN_load ) ) return 0 ; 
3053:	m = stbi__get_marker ( j ) ; 
3054:	while ( ! ( ( m ) == 0xd9 ) ) { 
3055:	if ( ( ( m ) == 0xda ) ) { 
3056:	if ( ! stbi__process_scan_header ( j ) ) return 0 ; 
3057:	if ( ! stbi__parse_entropy_coded_data ( j ) ) return 0 ; 
3058:	if ( j -> marker == 0xff ) { 
3060:	while ( ! stbi__at_eof ( j -> s ) ) { 
3061:	int x = stbi__get8 ( j -> s ) ; 
3062:	if ( x == 255 ) { 
3063:	j -> marker = stbi__get8 ( j -> s ) ; 
3064:	break ; 
3065:	} 
3066:	} 
3068:	} 
3069:	} else if ( ( ( m ) == 0xdc ) ) { 
3070:	int Ld = stbi__get16be ( j -> s ) ; 
3071:	stbi__uint32 NL = stbi__get16be ( j -> s ) ; 
3072:	if ( Ld != 4 ) return stbi__err ( "bad DNL len" ) ; 
3073:	if ( NL != j -> s -> img_y ) return stbi__err ( "bad DNL height" ) ; 
3074:	} else { 
3075:	if ( ! stbi__process_marker ( j , m ) ) return 0 ; 
3076:	} 
3077:	m = stbi__get_marker ( j ) ; 
3078:	} 
3079:	if ( j -> progressive ) 
3080:	stbi__jpeg_finish ( j ) ; 
3081:	return 1 ; 
3082:	} 
3086:	typedef stbi_uc * ( * resample_row_func ) ( stbi_uc * out , stbi_uc * in0 , stbi_uc * in1 , 
3087:	int w , int hs ) ; 
3091:	static stbi_uc * resample_row_1 ( stbi_uc * out , stbi_uc * in_near , stbi_uc * in_far , int w , int hs ) 
3092:	{ 
3093:	( void ) sizeof ( out ) ; 
3094:	( void ) sizeof ( in_far ) ; 
3095:	( void ) sizeof ( w ) ; 
3096:	( void ) sizeof ( hs ) ; 
3097:	return in_near ; 
3098:	} 
3100:	static stbi_uc * stbi__resample_row_v_2 ( stbi_uc * out , stbi_uc * in_near , stbi_uc * in_far , int w , int hs ) 
3101:	{ 
3103:	int i ; 
3104:	( void ) sizeof ( hs ) ; 
3105:	for ( i = 0 ; i < w ; ++ i ) 
3106:	out [ i ] = ( ( stbi_uc ) ( ( 3 * in_near [ i ] + in_far [ i ] + 2 ) >> 2 ) ) ; 
3107:	return out ; 
3108:	} 
3110:	static stbi_uc * stbi__resample_row_h_2 ( stbi_uc * out , stbi_uc * in_near , stbi_uc * in_far , int w , int hs ) 
3111:	{ 
3113:	int i ; 
3114:	stbi_uc * input = in_near ; 
3116:	if ( w == 1 ) { 
3118:	out [ 0 ] = out [ 1 ] = input [ 0 ] ; 
3119:	return out ; 
3120:	} 
3122:	out [ 0 ] = input [ 0 ] ; 
3123:	out [ 1 ] = ( ( stbi_uc ) ( ( input [ 0 ] * 3 + input [ 1 ] + 2 ) >> 2 ) ) ; 
3124:	for ( i = 1 ; i < w - 1 ; ++ i ) { 
3125:	int n = 3 * input [ i ] + 2 ; 
3126:	out [ i * 2 + 0 ] = ( ( stbi_uc ) ( ( n + input [ i - 1 ] ) >> 2 ) ) ; 
3127:	out [ i * 2 + 1 ] = ( ( stbi_uc ) ( ( n + input [ i + 1 ] ) >> 2 ) ) ; 
3128:	} 
3129:	out [ i * 2 + 0 ] = ( ( stbi_uc ) ( ( input [ w - 2 ] * 3 + input [ w - 1 ] + 2 ) >> 2 ) ) ; 
3130:	out [ i * 2 + 1 ] = input [ w - 1 ] ; 
3132:	( void ) sizeof ( in_far ) ; 
3133:	( void ) sizeof ( hs ) ; 
3135:	return out ; 
3136:	} 
3140:	static stbi_uc * stbi__resample_row_hv_2 ( stbi_uc * out , stbi_uc * in_near , stbi_uc * in_far , int w , int hs ) 
3141:	{ 
3143:	int i , t0 , t1 ; 
3144:	if ( w == 1 ) { 
3145:	out [ 0 ] = out [ 1 ] = ( ( stbi_uc ) ( ( 3 * in_near [ 0 ] + in_far [ 0 ] + 2 ) >> 2 ) ) ; 
3146:	return out ; 
3147:	} 
3149:	t1 = 3 * in_near [ 0 ] + in_far [ 0 ] ; 
3150:	out [ 0 ] = ( ( stbi_uc ) ( ( t1 + 2 ) >> 2 ) ) ; 
3151:	for ( i = 1 ; i < w ; ++ i ) { 
3152:	t0 = t1 ; 
3153:	t1 = 3 * in_near [ i ] + in_far [ i ] ; 
3154:	out [ i * 2 - 1 ] = ( ( stbi_uc ) ( ( 3 * t0 + t1 + 8 ) >> 4 ) ) ; 
3155:	out [ i * 2 ] = ( ( stbi_uc ) ( ( 3 * t1 + t0 + 8 ) >> 4 ) ) ; 
3156:	} 
3157:	out [ w * 2 - 1 ] = ( ( stbi_uc ) ( ( t1 + 2 ) >> 2 ) ) ; 
3159:	( void ) sizeof ( hs ) ; 
3161:	return out ; 
3162:	} 
3165:	static stbi_uc * stbi__resample_row_hv_2_simd ( stbi_uc * out , stbi_uc * in_near , stbi_uc * in_far , int w , int hs ) 
3166:	{ 
3168:	int i = 0 , t0 , t1 ; 
3170:	if ( w == 1 ) { 
3171:	out [ 0 ] = out [ 1 ] = ( ( stbi_uc ) ( ( 3 * in_near [ 0 ] + in_far [ 0 ] + 2 ) >> 2 ) ) ; 
3172:	return out ; 
3173:	} 
3175:	t1 = 3 * in_near [ 0 ] + in_far [ 0 ] ; 
3179:	for ( ; i < ( ( w - 1 ) & ~ 7 ) ; i += 8 ) { 
3183:	__m128i zero = _mm_setzero_si128 ( ) ; 
3184:	__m128i farb = _mm_loadl_epi64 ( ( __m128i * ) ( in_far + i ) ) ; 
3185:	__m128i nearb = _mm_loadl_epi64 ( ( __m128i * ) ( in_near + i ) ) ; 
3186:	__m128i farw = _mm_unpacklo_epi8 ( farb , zero ) ; 
3187:	__m128i nearw = _mm_unpacklo_epi8 ( nearb , zero ) ; 
3188:	__m128i diff = _mm_sub_epi16 ( farw , nearw ) ; 
3189:	__m128i nears = _mm_slli_epi16 ( nearw , 2 ) ; 
3190:	__m128i curr = _mm_add_epi16 ( nears , diff ) ; 
3197:	__m128i prv0 = _mm_slli_si128 ( curr , 2 ) ; 
3198:	__m128i nxt0 = _mm_srli_si128 ( curr , 2 ) ; 
3199:	__m128i prev = _mm_insert_epi16 ( prv0 , t1 , 0 ) ; 
3200:	__m128i next = _mm_insert_epi16 ( nxt0 , 3 * in_near [ i + 8 ] + in_far [ i + 8 ] , 7 ) ; 
3206:	__m128i bias = _mm_set1_epi16 ( 8 ) ; 
3207:	__m128i curs = _mm_slli_epi16 ( curr , 2 ) ; 
3208:	__m128i prvd = _mm_sub_epi16 ( prev , curr ) ; 
3209:	__m128i nxtd = _mm_sub_epi16 ( next , curr ) ; 
3210:	__m128i curb = _mm_add_epi16 ( curs , bias ) ; 
3211:	__m128i even = _mm_add_epi16 ( prvd , curb ) ; 
3212:	__m128i odd = _mm_add_epi16 ( nxtd , curb ) ; 
3215:	__m128i int0 = _mm_unpacklo_epi16 ( even , odd ) ; 
3216:	__m128i int1 = _mm_unpackhi_epi16 ( even , odd ) ; 
3217:	__m128i de0 = _mm_srli_epi16 ( int0 , 4 ) ; 
3218:	__m128i de1 = _mm_srli_epi16 ( int1 , 4 ) ; 
3221:	__m128i outv = _mm_packus_epi16 ( de0 , de1 ) ; 
3222:	_mm_storeu_si128 ( ( __m128i * ) ( out + i * 2 ) , outv ) ; 
3260:	t1 = 3 * in_near [ i + 7 ] + in_far [ i + 7 ] ; 
3261:	} 
3263:	t0 = t1 ; 
3264:	t1 = 3 * in_near [ i ] + in_far [ i ] ; 
3265:	out [ i * 2 ] = ( ( stbi_uc ) ( ( 3 * t1 + t0 + 8 ) >> 4 ) ) ; 
3267:	for ( ++ i ; i < w ; ++ i ) { 
3268:	t0 = t1 ; 
3269:	t1 = 3 * in_near [ i ] + in_far [ i ] ; 
3270:	out [ i * 2 - 1 ] = ( ( stbi_uc ) ( ( 3 * t0 + t1 + 8 ) >> 4 ) ) ; 
3271:	out [ i * 2 ] = ( ( stbi_uc ) ( ( 3 * t1 + t0 + 8 ) >> 4 ) ) ; 
3272:	} 
3273:	out [ w * 2 - 1 ] = ( ( stbi_uc ) ( ( t1 + 2 ) >> 2 ) ) ; 
3275:	( void ) sizeof ( hs ) ; 
3277:	return out ; 
3278:	} 
3281:	static stbi_uc * stbi__resample_row_generic ( stbi_uc * out , stbi_uc * in_near , stbi_uc * in_far , int w , int hs ) 
3282:	{ 
3284:	int i , j ; 
3285:	( void ) sizeof ( in_far ) ; 
3286:	for ( i = 0 ; i < w ; ++ i ) 
3287:	for ( j = 0 ; j < hs ; ++ j ) 
3288:	out [ i * hs + j ] = in_near [ i ] ; 
3289:	return out ; 
3290:	} 
3295:	static void stbi__YCbCr_to_RGB_row ( stbi_uc * out , const stbi_uc * y , const stbi_uc * pcb , const stbi_uc * pcr , int count , int step ) 
3296:	{ 
3297:	int i ; 
3298:	for ( i = 0 ; i < count ; ++ i ) { 
3299:	int y_fixed = ( y [ i ] << 20 ) + ( 1 << 19 ) ; 
3300:	int r , g , b ; 
3301:	int cr = pcr [ i ] - 128 ; 
3302:	int cb = pcb [ i ] - 128 ; 
3303:	r = y_fixed + cr * ( ( ( int ) ( ( 1 . 40200 f ) * 4096 . 0 f + 0 . 5 f ) ) << 8 ) ; 
3304:	g = y_fixed + ( cr * - ( ( ( int ) ( ( 0 . 71414 f ) * 4096 . 0 f + 0 . 5 f ) ) << 8 ) ) + ( ( cb * - ( ( ( int ) ( ( 0 . 34414 f ) * 4096 . 0 f + 0 . 5 f ) ) << 8 ) ) & 0xffff0000 ) ; 
3305:	b = y_fixed + cb * ( ( ( int ) ( ( 1 . 77200 f ) * 4096 . 0 f + 0 . 5 f ) ) << 8 ) ; 
3306:	r >>= 20 ; 
3307:	g >>= 20 ; 
3308:	b >>= 20 ; 
3309:	if ( ( unsigned ) r > 255 ) { if ( r < 0 ) r = 0 ; else r = 255 ; } 
3310:	if ( ( unsigned ) g > 255 ) { if ( g < 0 ) g = 0 ; else g = 255 ; } 
3311:	if ( ( unsigned ) b > 255 ) { if ( b < 0 ) b = 0 ; else b = 255 ; } 
3312:	out [ 0 ] = ( stbi_uc ) r ; 
3313:	out [ 1 ] = ( stbi_uc ) g ; 
3314:	out [ 2 ] = ( stbi_uc ) b ; 
3315:	out [ 3 ] = 255 ; 
3316:	out += step ; 
3317:	} 
3318:	} 
3321:	static void stbi__YCbCr_to_RGB_simd ( stbi_uc * out , stbi_uc const * y , stbi_uc const * pcb , stbi_uc const * pcr , int count , int step ) 
3322:	{ 
3323:	int i = 0 ; 
3329:	if ( step == 4 ) { 
3331:	__m128i signflip = _mm_set1_epi8 ( - 0x80 ) ; 
3332:	__m128i cr_const0 = _mm_set1_epi16 ( ( short ) ( 1 . 40200 f * 4096 . 0 f + 0 . 5 f ) ) ; 
3333:	__m128i cr_const1 = _mm_set1_epi16 ( - ( short ) ( 0 . 71414 f * 4096 . 0 f + 0 . 5 f ) ) ; 
3334:	__m128i cb_const0 = _mm_set1_epi16 ( - ( short ) ( 0 . 34414 f * 4096 . 0 f + 0 . 5 f ) ) ; 
3335:	__m128i cb_const1 = _mm_set1_epi16 ( ( short ) ( 1 . 77200 f * 4096 . 0 f + 0 . 5 f ) ) ; 
3336:	__m128i y_bias = _mm_set1_epi8 ( ( char ) ( unsigned char ) 128 ) ; 
3337:	__m128i xw = _mm_set1_epi16 ( 255 ) ; 
3339:	for ( ; i + 7 < count ; i += 8 ) { 
3341:	__m128i y_bytes = _mm_loadl_epi64 ( ( __m128i * ) ( y + i ) ) ; 
3342:	__m128i cr_bytes = _mm_loadl_epi64 ( ( __m128i * ) ( pcr + i ) ) ; 
3343:	__m128i cb_bytes = _mm_loadl_epi64 ( ( __m128i * ) ( pcb + i ) ) ; 
3344:	__m128i cr_biased = _mm_xor_si128 ( cr_bytes , signflip ) ; 
3345:	__m128i cb_biased = _mm_xor_si128 ( cb_bytes , signflip ) ; 
3348:	__m128i yw = _mm_unpacklo_epi8 ( y_bias , y_bytes ) ; 
3349:	__m128i crw = _mm_unpacklo_epi8 ( _mm_setzero_si128 ( ) , cr_biased ) ; 
3350:	__m128i cbw = _mm_unpacklo_epi8 ( _mm_setzero_si128 ( ) , cb_biased ) ; 
3353:	__m128i yws = _mm_srli_epi16 ( yw , 4 ) ; 
3354:	__m128i cr0 = _mm_mulhi_epi16 ( cr_const0 , crw ) ; 
3355:	__m128i cb0 = _mm_mulhi_epi16 ( cb_const0 , cbw ) ; 
3356:	__m128i cb1 = _mm_mulhi_epi16 ( cbw , cb_const1 ) ; 
3357:	__m128i cr1 = _mm_mulhi_epi16 ( crw , cr_const1 ) ; 
3358:	__m128i rws = _mm_add_epi16 ( cr0 , yws ) ; 
3359:	__m128i gwt = _mm_add_epi16 ( cb0 , yws ) ; 
3360:	__m128i bws = _mm_add_epi16 ( yws , cb1 ) ; 
3361:	__m128i gws = _mm_add_epi16 ( gwt , cr1 ) ; 
3364:	__m128i rw = _mm_srai_epi16 ( rws , 4 ) ; 
3365:	__m128i bw = _mm_srai_epi16 ( bws , 4 ) ; 
3366:	__m128i gw = _mm_srai_epi16 ( gws , 4 ) ; 
3369:	__m128i brb = _mm_packus_epi16 ( rw , bw ) ; 
3370:	__m128i gxb = _mm_packus_epi16 ( gw , xw ) ; 
3373:	__m128i t0 = _mm_unpacklo_epi8 ( brb , gxb ) ; 
3374:	__m128i t1 = _mm_unpackhi_epi8 ( brb , gxb ) ; 
3375:	__m128i o0 = _mm_unpacklo_epi16 ( t0 , t1 ) ; 
3376:	__m128i o1 = _mm_unpackhi_epi16 ( t0 , t1 ) ; 
3379:	_mm_storeu_si128 ( ( __m128i * ) ( out + 0 ) , o0 ) ; 
3380:	_mm_storeu_si128 ( ( __m128i * ) ( out + 16 ) , o1 ) ; 
3381:	out += 32 ; 
3382:	} 
3383:	} 
3432:	for ( ; i < count ; ++ i ) { 
3433:	int y_fixed = ( y [ i ] << 20 ) + ( 1 << 19 ) ; 
3434:	int r , g , b ; 
3435:	int cr = pcr [ i ] - 128 ; 
3436:	int cb = pcb [ i ] - 128 ; 
3437:	r = y_fixed + cr * ( ( ( int ) ( ( 1 . 40200 f ) * 4096 . 0 f + 0 . 5 f ) ) << 8 ) ; 
3438:	g = y_fixed + cr * - ( ( ( int ) ( ( 0 . 71414 f ) * 4096 . 0 f + 0 . 5 f ) ) << 8 ) + ( ( cb * - ( ( ( int ) ( ( 0 . 34414 f ) * 4096 . 0 f + 0 . 5 f ) ) << 8 ) ) & 0xffff0000 ) ; 
3439:	b = y_fixed + cb * ( ( ( int ) ( ( 1 . 77200 f ) * 4096 . 0 f + 0 . 5 f ) ) << 8 ) ; 
3440:	r >>= 20 ; 
3441:	g >>= 20 ; 
3442:	b >>= 20 ; 
3443:	if ( ( unsigned ) r > 255 ) { if ( r < 0 ) r = 0 ; else r = 255 ; } 
3444:	if ( ( unsigned ) g > 255 ) { if ( g < 0 ) g = 0 ; else g = 255 ; } 
3445:	if ( ( unsigned ) b > 255 ) { if ( b < 0 ) b = 0 ; else b = 255 ; } 
3446:	out [ 0 ] = ( stbi_uc ) r ; 
3447:	out [ 1 ] = ( stbi_uc ) g ; 
3448:	out [ 2 ] = ( stbi_uc ) b ; 
3449:	out [ 3 ] = 255 ; 
3450:	out += step ; 
3451:	} 
3452:	} 
3456:	static void stbi__setup_jpeg ( stbi__jpeg * j ) 
3457:	{ 
3458:	j -> idct_block_kernel = stbi__idct_block ; 
3459:	j -> YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row ; 
3460:	j -> resample_row_hv_2_kernel = stbi__resample_row_hv_2 ; 
3463:	if ( stbi__sse2_available ( ) ) { 
3464:	j -> idct_block_kernel = stbi__idct_simd ; 
3465:	j -> YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd ; 
3466:	j -> resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd ; 
3467:	} 
3475:	} 
3478:	static void stbi__cleanup_jpeg ( stbi__jpeg * j ) 
3479:	{ 
3480:	stbi__free_jpeg_components ( j , j -> s -> img_n , 0 ) ; 
3481:	} 
3483:	typedef struct 
3484:	{ 
3485:	resample_row_func resample ; 
3486:	stbi_uc * line0 , * line1 ; 
3487:	int hs , vs ; 
3488:	int w_lores ; 
3489:	int ystep ; 
3490:	int ypos ; 
3491:	} stbi__resample ; 
3494:	static stbi_uc stbi__blinn_8x8 ( stbi_uc x , stbi_uc y ) 
3495:	{ 
3496:	unsigned int t = x * y + 128 ; 
3497:	return ( stbi_uc ) ( ( t + ( t >> 8 ) ) >> 8 ) ; 
3498:	} 
3500:	static stbi_uc * load_jpeg_image ( stbi__jpeg * z , int * out_x , int * out_y , int * comp , int req_comp ) 
3501:	{ 
3502:	int n , decode_n , is_rgb ; 
3503:	z -> s -> img_n = 0 ; 
3506:	if ( req_comp < 0 || req_comp > 4 ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad req_comp" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
3509:	if ( ! stbi__decode_jpeg_image ( z ) ) { stbi__cleanup_jpeg ( z ) ; return ( ( void * ) 0 ) ; } 
3512:	n = req_comp ? req_comp : z -> s -> img_n >= 3 ? 3 : 1 ; 
3514:	is_rgb = z -> s -> img_n == 3 && ( z -> rgb == 3 || ( z -> app14_color_transform == 0 && ! z -> jfif ) ) ; 
3516:	if ( z -> s -> img_n == 3 && n < 3 && ! is_rgb ) 
3517:	decode_n = 1 ; 
3518:	else 
3519:	decode_n = z -> s -> img_n ; 
3522:	{ 
3523:	int k ; 
3524:	unsigned int i , j ; 
3525:	stbi_uc * output ; 
3526:	stbi_uc * coutput [ 4 ] = { ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) } ; 
3528:	stbi__resample res_comp [ 4 ] ; 
3530:	for ( k = 0 ; k < decode_n ; ++ k ) { 
3531:	stbi__resample * r = & res_comp [ k ] ; 
3535:	z -> img_comp [ k ] . linebuf = ( stbi_uc * ) stbi__malloc ( z -> s -> img_x + 3 ) ; 
3536:	if ( ! z -> img_comp [ k ] . linebuf ) { stbi__cleanup_jpeg ( z ) ; return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; } 
3538:	r -> hs = z -> img_h_max / z -> img_comp [ k ] . h ; 
3539:	r -> vs = z -> img_v_max / z -> img_comp [ k ] . v ; 
3540:	r -> ystep = r -> vs >> 1 ; 
3541:	r -> w_lores = ( z -> s -> img_x + r -> hs - 1 ) / r -> hs ; 
3542:	r -> ypos = 0 ; 
3543:	r -> line0 = r -> line1 = z -> img_comp [ k ] . data ; 
3545:	if ( r -> hs == 1 && r -> vs == 1 ) r -> resample = resample_row_1 ; 
3546:	else if ( r -> hs == 1 && r -> vs == 2 ) r -> resample = stbi__resample_row_v_2 ; 
3547:	else if ( r -> hs == 2 && r -> vs == 1 ) r -> resample = stbi__resample_row_h_2 ; 
3548:	else if ( r -> hs == 2 && r -> vs == 2 ) r -> resample = z -> resample_row_hv_2_kernel ; 
3549:	else r -> resample = stbi__resample_row_generic ; 
3550:	} 
3553:	output = ( stbi_uc * ) stbi__malloc_mad3 ( n , z -> s -> img_x , z -> s -> img_y , 1 ) ; 
3554:	if ( ! output ) { stbi__cleanup_jpeg ( z ) ; return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; } 
3557:	for ( j = 0 ; j < z -> s -> img_y ; ++ j ) { 
3558:	stbi_uc * out = output + n * z -> s -> img_x * j ; 
3559:	for ( k = 0 ; k < decode_n ; ++ k ) { 
3560:	stbi__resample * r = & res_comp [ k ] ; 
3561:	int y_bot = r -> ystep >= ( r -> vs >> 1 ) ; 
3562:	coutput [ k ] = r -> resample ( z -> img_comp [ k ] . linebuf , 
3563:	y_bot ? r -> line1 : r -> line0 , 
3564:	y_bot ? r -> line0 : r -> line1 , 
3565:	r -> w_lores , r -> hs ) ; 
3566:	if ( ++ r -> ystep >= r -> vs ) { 
3567:	r -> ystep = 0 ; 
3568:	r -> line0 = r -> line1 ; 
3569:	if ( ++ r -> ypos < z -> img_comp [ k ] . y ) 
3570:	r -> line1 += z -> img_comp [ k ] . w2 ; 
3571:	} 
3572:	} 
3573:	if ( n >= 3 ) { 
3574:	stbi_uc * y = coutput [ 0 ] ; 
3575:	if ( z -> s -> img_n == 3 ) { 
3576:	if ( is_rgb ) { 
3577:	for ( i = 0 ; i < z -> s -> img_x ; ++ i ) { 
3578:	out [ 0 ] = y [ i ] ; 
3579:	out [ 1 ] = coutput [ 1 ] [ i ] ; 
3580:	out [ 2 ] = coutput [ 2 ] [ i ] ; 
3581:	out [ 3 ] = 255 ; 
3582:	out += n ; 
3583:	} 
3584:	} else { 
3585:	z -> YCbCr_to_RGB_kernel ( out , y , coutput [ 1 ] , coutput [ 2 ] , z -> s -> img_x , n ) ; 
3586:	} 
3587:	} else if ( z -> s -> img_n == 4 ) { 
3588:	if ( z -> app14_color_transform == 0 ) { 
3589:	for ( i = 0 ; i < z -> s -> img_x ; ++ i ) { 
3590:	stbi_uc m = coutput [ 3 ] [ i ] ; 
3591:	out [ 0 ] = stbi__blinn_8x8 ( coutput [ 0 ] [ i ] , m ) ; 
3592:	out [ 1 ] = stbi__blinn_8x8 ( coutput [ 1 ] [ i ] , m ) ; 
3593:	out [ 2 ] = stbi__blinn_8x8 ( coutput [ 2 ] [ i ] , m ) ; 
3594:	out [ 3 ] = 255 ; 
3595:	out += n ; 
3596:	} 
3597:	} else if ( z -> app14_color_transform == 2 ) { 
3598:	z -> YCbCr_to_RGB_kernel ( out , y , coutput [ 1 ] , coutput [ 2 ] , z -> s -> img_x , n ) ; 
3599:	for ( i = 0 ; i < z -> s -> img_x ; ++ i ) { 
3600:	stbi_uc m = coutput [ 3 ] [ i ] ; 
3601:	out [ 0 ] = stbi__blinn_8x8 ( 255 - out [ 0 ] , m ) ; 
3602:	out [ 1 ] = stbi__blinn_8x8 ( 255 - out [ 1 ] , m ) ; 
3603:	out [ 2 ] = stbi__blinn_8x8 ( 255 - out [ 2 ] , m ) ; 
3604:	out += n ; 
3605:	} 
3606:	} else { 
3607:	z -> YCbCr_to_RGB_kernel ( out , y , coutput [ 1 ] , coutput [ 2 ] , z -> s -> img_x , n ) ; 
3608:	} 
3609:	} else 
3610:	for ( i = 0 ; i < z -> s -> img_x ; ++ i ) { 
3611:	out [ 0 ] = out [ 1 ] = out [ 2 ] = y [ i ] ; 
3612:	out [ 3 ] = 255 ; 
3613:	out += n ; 
3614:	} 
3615:	} else { 
3616:	if ( is_rgb ) { 
3617:	if ( n == 1 ) 
3618:	for ( i = 0 ; i < z -> s -> img_x ; ++ i ) 
3619:	* out ++ = stbi__compute_y ( coutput [ 0 ] [ i ] , coutput [ 1 ] [ i ] , coutput [ 2 ] [ i ] ) ; 
3620:	else { 
3621:	for ( i = 0 ; i < z -> s -> img_x ; ++ i , out += 2 ) { 
3622:	out [ 0 ] = stbi__compute_y ( coutput [ 0 ] [ i ] , coutput [ 1 ] [ i ] , coutput [ 2 ] [ i ] ) ; 
3623:	out [ 1 ] = 255 ; 
3624:	} 
3625:	} 
3626:	} else if ( z -> s -> img_n == 4 && z -> app14_color_transform == 0 ) { 
3627:	for ( i = 0 ; i < z -> s -> img_x ; ++ i ) { 
3628:	stbi_uc m = coutput [ 3 ] [ i ] ; 
3629:	stbi_uc r = stbi__blinn_8x8 ( coutput [ 0 ] [ i ] , m ) ; 
3630:	stbi_uc g = stbi__blinn_8x8 ( coutput [ 1 ] [ i ] , m ) ; 
3631:	stbi_uc b = stbi__blinn_8x8 ( coutput [ 2 ] [ i ] , m ) ; 
3632:	out [ 0 ] = stbi__compute_y ( r , g , b ) ; 
3633:	out [ 1 ] = 255 ; 
3634:	out += n ; 
3635:	} 
3636:	} else if ( z -> s -> img_n == 4 && z -> app14_color_transform == 2 ) { 
3637:	for ( i = 0 ; i < z -> s -> img_x ; ++ i ) { 
3638:	out [ 0 ] = stbi__blinn_8x8 ( 255 - coutput [ 0 ] [ i ] , coutput [ 3 ] [ i ] ) ; 
3639:	out [ 1 ] = 255 ; 
3640:	out += n ; 
3641:	} 
3642:	} else { 
3643:	stbi_uc * y = coutput [ 0 ] ; 
3644:	if ( n == 1 ) 
3645:	for ( i = 0 ; i < z -> s -> img_x ; ++ i ) out [ i ] = y [ i ] ; 
3646:	else 
3647:	for ( i = 0 ; i < z -> s -> img_x ; ++ i ) { * out ++ = y [ i ] ; * out ++ = 255 ; } 
3648:	} 
3649:	} 
3650:	} 
3651:	stbi__cleanup_jpeg ( z ) ; 
3652:	* out_x = z -> s -> img_x ; 
3653:	* out_y = z -> s -> img_y ; 
3654:	if ( comp ) * comp = z -> s -> img_n >= 3 ? 3 : 1 ; 
3655:	return output ; 
3656:	} 
3657:	} 
3659:	static void * stbi__jpeg_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri ) 
3660:	{ 
3661:	unsigned char * result ; 
3662:	stbi__jpeg * j = ( stbi__jpeg * ) stbi__malloc ( sizeof ( stbi__jpeg ) ) ; 
3663:	( void ) sizeof ( ri ) ; 
3664:	j -> s = s ; 
3665:	stbi__setup_jpeg ( j ) ; 
3666:	result = load_jpeg_image ( j , x , y , comp , req_comp ) ; 
3667:	free ( j ) ; 
3668:	return result ; 
3669:	} 
3671:	static int stbi__jpeg_test ( stbi__context * s ) 
3672:	{ 
3673:	int r ; 
3674:	stbi__jpeg * j = ( stbi__jpeg * ) stbi__malloc ( sizeof ( stbi__jpeg ) ) ; 
3675:	j -> s = s ; 
3676:	stbi__setup_jpeg ( j ) ; 
3677:	r = stbi__decode_jpeg_header ( j , STBI__SCAN_type ) ; 
3678:	stbi__rewind ( s ) ; 
3679:	free ( j ) ; 
3680:	return r ; 
3681:	} 
3683:	static int stbi__jpeg_info_raw ( stbi__jpeg * j , int * x , int * y , int * comp ) 
3684:	{ 
3685:	if ( ! stbi__decode_jpeg_header ( j , STBI__SCAN_header ) ) { 
3686:	stbi__rewind ( j -> s ) ; 
3687:	return 0 ; 
3688:	} 
3689:	if ( x ) * x = j -> s -> img_x ; 
3690:	if ( y ) * y = j -> s -> img_y ; 
3691:	if ( comp ) * comp = j -> s -> img_n >= 3 ? 3 : 1 ; 
3692:	return 1 ; 
3693:	} 
3695:	static int stbi__jpeg_info ( stbi__context * s , int * x , int * y , int * comp ) 
3696:	{ 
3697:	int result ; 
3698:	stbi__jpeg * j = ( stbi__jpeg * ) ( stbi__malloc ( sizeof ( stbi__jpeg ) ) ) ; 
3699:	j -> s = s ; 
3700:	result = stbi__jpeg_info_raw ( j , x , y , comp ) ; 
3701:	free ( j ) ; 
3702:	return result ; 
3703:	} 
3721:	typedef struct 
3722:	{ 
3723:	stbi__uint16 fast [ 1 << 9 ] ; 
3724:	stbi__uint16 firstcode [ 16 ] ; 
3725:	int maxcode [ 17 ] ; 
3726:	stbi__uint16 firstsymbol [ 16 ] ; 
3727:	stbi_uc size [ 288 ] ; 
3728:	stbi__uint16 value [ 288 ] ; 
3729:	} stbi__zhuffman ; 
3731:	static int stbi__bitreverse16 ( int n ) 
3732:	{ 
3733:	n = ( ( n & 0xAAAA ) >> 1 ) | ( ( n & 0x5555 ) << 1 ) ; 
3734:	n = ( ( n & 0xCCCC ) >> 2 ) | ( ( n & 0x3333 ) << 2 ) ; 
3735:	n = ( ( n & 0xF0F0 ) >> 4 ) | ( ( n & 0x0F0F ) << 4 ) ; 
3736:	n = ( ( n & 0xFF00 ) >> 8 ) | ( ( n & 0x00FF ) << 8 ) ; 
3737:	return n ; 
3738:	} 
3740:	static int stbi__bit_reverse ( int v , int bits ) 
3741:	{ 
3742:	( void ) ( ( !! ( bits <= 16 ) ) || ( _wassert ( L "bits <= 16 " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
3745:	return stbi__bitreverse16 ( v ) >> ( 16 - bits ) ; 
3746:	} 
3748:	static int stbi__zbuild_huffman ( stbi__zhuffman * z , const stbi_uc * sizelist , int num ) 
3749:	{ 
3750:	int i , k = 0 ; 
3751:	int code , next_code [ 16 ] , sizes [ 17 ] ; 
3754:	memset ( sizes , 0 , sizeof ( sizes ) ) ; 
3755:	memset ( z -> fast , 0 , sizeof ( z -> fast ) ) ; 
3756:	for ( i = 0 ; i < num ; ++ i ) 
3757:	++ sizes [ sizelist [ i ] ] ; 
3758:	sizes [ 0 ] = 0 ; 
3759:	for ( i = 1 ; i < 16 ; ++ i ) 
3760:	if ( sizes [ i ] > ( 1 << i ) ) 
3761:	return stbi__err ( "bad sizes" ) ; 
3762:	code = 0 ; 
3763:	for ( i = 1 ; i < 16 ; ++ i ) { 
3764:	next_code [ i ] = code ; 
3765:	z -> firstcode [ i ] = ( stbi__uint16 ) code ; 
3766:	z -> firstsymbol [ i ] = ( stbi__uint16 ) k ; 
3767:	code = ( code + sizes [ i ] ) ; 
3768:	if ( sizes [ i ] ) 
3769:	if ( code - 1 >= ( 1 << i ) ) return stbi__err ( "bad codelengths" ) ; 
3770:	z -> maxcode [ i ] = code << ( 16 - i ) ; 
3771:	code <<= 1 ; 
3772:	k += sizes [ i ] ; 
3773:	} 
3774:	z -> maxcode [ 16 ] = 0x10000 ; 
3775:	for ( i = 0 ; i < num ; ++ i ) { 
3776:	int s = sizelist [ i ] ; 
3777:	if ( s ) { 
3778:	int c = next_code [ s ] - z -> firstcode [ s ] + z -> firstsymbol [ s ] ; 
3779:	stbi__uint16 fastv = ( stbi__uint16 ) ( ( s << 9 ) | i ) ; 
3780:	z -> size [ c ] = ( stbi_uc ) s ; 
3781:	z -> value [ c ] = ( stbi__uint16 ) i ; 
3782:	if ( s <= 9 ) { 
3783:	int j = stbi__bit_reverse ( next_code [ s ] , s ) ; 
3784:	while ( j < ( 1 << 9 ) ) { 
3785:	z -> fast [ j ] = fastv ; 
3786:	j += ( 1 << s ) ; 
3787:	} 
3788:	} 
3789:	++ next_code [ s ] ; 
3790:	} 
3791:	} 
3792:	return 1 ; 
3793:	} 
3801:	typedef struct 
3802:	{ 
3803:	stbi_uc * zbuffer , * zbuffer_end ; 
3804:	int num_bits ; 
3805:	stbi__uint32 code_buffer ; 
3807:	char * zout ; 
3808:	char * zout_start ; 
3809:	char * zout_end ; 
3810:	int z_expandable ; 
3812:	stbi__zhuffman z_length , z_distance ; 
3813:	} stbi__zbuf ; 
3815:	static int stbi__zeof ( stbi__zbuf * z ) 
3816:	{ 
3817:	return ( z -> zbuffer >= z -> zbuffer_end ) ; 
3818:	} 
3820:	static stbi_uc stbi__zget8 ( stbi__zbuf * z ) 
3821:	{ 
3822:	return stbi__zeof ( z ) ? 0 : * z -> zbuffer ++ ; 
3823:	} 
3825:	static void stbi__fill_bits ( stbi__zbuf * z ) 
3826:	{ 
3827:	do { 
3828:	if ( z -> code_buffer >= ( 1 U << z -> num_bits ) ) { 
3829:	z -> zbuffer = z -> zbuffer_end ; 
3830:	return ; 
3831:	} 
3832:	z -> code_buffer |= ( unsigned int ) stbi__zget8 ( z ) << z -> num_bits ; 
3833:	z -> num_bits += 8 ; 
3834:	} while ( z -> num_bits <= 24 ) ; 
3835:	} 
3837:	static unsigned int stbi__zreceive ( stbi__zbuf * z , int n ) 
3838:	{ 
3839:	unsigned int k ; 
3840:	if ( z -> num_bits < n ) stbi__fill_bits ( z ) ; 
3841:	k = z -> code_buffer & ( ( 1 << n ) - 1 ) ; 
3842:	z -> code_buffer >>= n ; 
3843:	z -> num_bits -= n ; 
3844:	return k ; 
3845:	} 
3847:	static int stbi__zhuffman_decode_slowpath ( stbi__zbuf * a , stbi__zhuffman * z ) 
3848:	{ 
3849:	int b , s , k ; 
3852:	k = stbi__bit_reverse ( a -> code_buffer , 16 ) ; 
3853:	for ( s = 9 + 1 ; ; ++ s ) 
3854:	if ( k < z -> maxcode [ s ] ) 
3855:	break ; 
3856:	if ( s >= 16 ) return - 1 ; 
3858:	b = ( k >> ( 16 - s ) ) - z -> firstcode [ s ] + z -> firstsymbol [ s ] ; 
3859:	if ( b >= sizeof ( z -> size ) ) return - 1 ; 
3860:	if ( z -> size [ b ] != s ) return - 1 ; 
3861:	a -> code_buffer >>= s ; 
3862:	a -> num_bits -= s ; 
3863:	return z -> value [ b ] ; 
3864:	} 
3866:	static int stbi__zhuffman_decode ( stbi__zbuf * a , stbi__zhuffman * z ) 
3867:	{ 
3868:	int b , s ; 
3869:	if ( a -> num_bits < 16 ) { 
3870:	if ( stbi__zeof ( a ) ) { 
3871:	return - 1 ; 
3872:	} 
3873:	stbi__fill_bits ( a ) ; 
3874:	} 
3875:	b = z -> fast [ a -> code_buffer & ( ( 1 << 9 ) - 1 ) ] ; 
3876:	if ( b ) { 
3877:	s = b >> 9 ; 
3878:	a -> code_buffer >>= s ; 
3879:	a -> num_bits -= s ; 
3880:	return b & 511 ; 
3881:	} 
3882:	return stbi__zhuffman_decode_slowpath ( a , z ) ; 
3883:	} 
3885:	static int stbi__zexpand ( stbi__zbuf * z , char * zout , int n ) 
3886:	{ 
3887:	char * q ; 
3888:	unsigned int cur , limit , old_limit ; 
3889:	z -> zout = zout ; 
3890:	if ( ! z -> z_expandable ) return stbi__err ( "output buffer limit" ) ; 
3891:	cur = ( unsigned int ) ( z -> zout - z -> zout_start ) ; 
3892:	limit = old_limit = ( unsigned ) ( z -> zout_end - z -> zout_start ) ; 
3893:	if ( 0xffffffff - cur < ( unsigned ) n ) return stbi__err ( "outofmem" ) ; 
3894:	while ( cur + n > limit ) { 
3895:	if ( limit > 0xffffffff / 2 ) return stbi__err ( "outofmem" ) ; 
3896:	limit *= 2 ; 
3897:	} 
3898:	q = ( char * ) realloc ( z -> zout_start , limit ) ; 
3899:	( void ) sizeof ( old_limit ) ; 
3900:	if ( q == ( ( void * ) 0 ) ) return stbi__err ( "outofmem" ) ; 
3901:	z -> zout_start = q ; 
3902:	z -> zout = q + cur ; 
3903:	z -> zout_end = q + limit ; 
3904:	return 1 ; 
3905:	} 
3907:	static const int stbi__zlength_base [ 31 ] = { 
3908:	3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 13 , 
3909:	15 , 17 , 19 , 23 , 27 , 31 , 35 , 43 , 51 , 59 , 
3910:	67 , 83 , 99 , 115 , 131 , 163 , 195 , 227 , 258 , 0 , 0 } ; 
3912:	static const int stbi__zlength_extra [ 31 ] = 
3913:	{ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 0 , 0 , 0 } ; 
3915:	static const int stbi__zdist_base [ 32 ] = { 1 , 2 , 3 , 4 , 5 , 7 , 9 , 13 , 17 , 25 , 33 , 49 , 65 , 97 , 129 , 193 , 
3916:	257 , 385 , 513 , 769 , 1025 , 1537 , 2049 , 3073 , 4097 , 6145 , 8193 , 12289 , 16385 , 24577 , 0 , 0 } ; 
3918:	static const int stbi__zdist_extra [ 32 ] = 
3919:	{ 0 , 0 , 0 , 0 , 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 , 6 , 7 , 7 , 8 , 8 , 9 , 9 , 10 , 10 , 11 , 11 , 12 , 12 , 13 , 13 } ; 
3921:	static int stbi__parse_huffman_block ( stbi__zbuf * a ) 
3922:	{ 
3923:	char * zout = a -> zout ; 
3924:	for ( ; ; ) { 
3925:	int z = stbi__zhuffman_decode ( a , & a -> z_length ) ; 
3926:	if ( z < 256 ) { 
3927:	if ( z < 0 ) return stbi__err ( "bad huffman code" ) ; 
3928:	if ( zout >= a -> zout_end ) { 
3929:	if ( ! stbi__zexpand ( a , zout , 1 ) ) return 0 ; 
3930:	zout = a -> zout ; 
3931:	} 
3932:	* zout ++ = ( char ) z ; 
3933:	} else { 
3934:	stbi_uc * p ; 
3935:	int len , dist ; 
3936:	if ( z == 256 ) { 
3937:	a -> zout = zout ; 
3938:	return 1 ; 
3939:	} 
3940:	z -= 257 ; 
3941:	len = stbi__zlength_base [ z ] ; 
3942:	if ( stbi__zlength_extra [ z ] ) len += stbi__zreceive ( a , stbi__zlength_extra [ z ] ) ; 
3943:	z = stbi__zhuffman_decode ( a , & a -> z_distance ) ; 
3944:	if ( z < 0 ) return stbi__err ( "bad huffman code" ) ; 
3945:	dist = stbi__zdist_base [ z ] ; 
3946:	if ( stbi__zdist_extra [ z ] ) dist += stbi__zreceive ( a , stbi__zdist_extra [ z ] ) ; 
3947:	if ( zout - a -> zout_start < dist ) return stbi__err ( "bad dist" ) ; 
3948:	if ( zout + len > a -> zout_end ) { 
3949:	if ( ! stbi__zexpand ( a , zout , len ) ) return 0 ; 
3950:	zout = a -> zout ; 
3951:	} 
3952:	p = ( stbi_uc * ) ( zout - dist ) ; 
3953:	if ( dist == 1 ) { 
3954:	stbi_uc v = * p ; 
3955:	if ( len ) { do * zout ++ = v ; while ( -- len ) ; } 
3956:	} else { 
3957:	if ( len ) { do * zout ++ = * p ++ ; while ( -- len ) ; } 
3958:	} 
3959:	} 
3960:	} 
3961:	} 
3963:	static int stbi__compute_huffman_codes ( stbi__zbuf * a ) 
3964:	{ 
3965:	static const stbi_uc length_dezigzag [ 19 ] = { 16 , 17 , 18 , 0 , 8 , 7 , 9 , 6 , 10 , 5 , 11 , 4 , 12 , 3 , 13 , 2 , 14 , 1 , 15 } ; 
3966:	stbi__zhuffman z_codelength ; 
3967:	stbi_uc lencodes [ 286 + 32 + 137 ] ; 
3968:	stbi_uc codelength_sizes [ 19 ] ; 
3969:	int i , n ; 
3971:	int hlit = stbi__zreceive ( a , 5 ) + 257 ; 
3972:	int hdist = stbi__zreceive ( a , 5 ) + 1 ; 
3973:	int hclen = stbi__zreceive ( a , 4 ) + 4 ; 
3974:	int ntot = hlit + hdist ; 
3976:	memset ( codelength_sizes , 0 , sizeof ( codelength_sizes ) ) ; 
3977:	for ( i = 0 ; i < hclen ; ++ i ) { 
3978:	int s = stbi__zreceive ( a , 3 ) ; 
3979:	codelength_sizes [ length_dezigzag [ i ] ] = ( stbi_uc ) s ; 
3980:	} 
3981:	if ( ! stbi__zbuild_huffman ( & z_codelength , codelength_sizes , 19 ) ) return 0 ; 
3983:	n = 0 ; 
3984:	while ( n < ntot ) { 
3985:	int c = stbi__zhuffman_decode ( a , & z_codelength ) ; 
3986:	if ( c < 0 || c >= 19 ) return stbi__err ( "bad codelengths" ) ; 
3987:	if ( c < 16 ) 
3988:	lencodes [ n ++ ] = ( stbi_uc ) c ; 
3989:	else { 
3990:	stbi_uc fill = 0 ; 
3991:	if ( c == 16 ) { 
3992:	c = stbi__zreceive ( a , 2 ) + 3 ; 
3993:	if ( n == 0 ) return stbi__err ( "bad codelengths" ) ; 
3994:	fill = lencodes [ n - 1 ] ; 
3995:	} else if ( c == 17 ) { 
3996:	c = stbi__zreceive ( a , 3 ) + 3 ; 
3997:	} else if ( c == 18 ) { 
3998:	c = stbi__zreceive ( a , 7 ) + 11 ; 
3999:	} else { 
4000:	return stbi__err ( "bad codelengths" ) ; 
4001:	} 
4002:	if ( ntot - n < c ) return stbi__err ( "bad codelengths" ) ; 
4003:	memset ( lencodes + n , fill , c ) ; 
4004:	n += c ; 
4005:	} 
4006:	} 
4007:	if ( n != ntot ) return stbi__err ( "bad codelengths" ) ; 
4008:	if ( ! stbi__zbuild_huffman ( & a -> z_length , lencodes , hlit ) ) return 0 ; 
4009:	if ( ! stbi__zbuild_huffman ( & a -> z_distance , lencodes + hlit , hdist ) ) return 0 ; 
4010:	return 1 ; 
4011:	} 
4013:	static int stbi__parse_uncompressed_block ( stbi__zbuf * a ) 
4014:	{ 
4015:	stbi_uc header [ 4 ] ; 
4016:	int len , nlen , k ; 
4017:	if ( a -> num_bits & 7 ) 
4018:	stbi__zreceive ( a , a -> num_bits & 7 ) ; 
4020:	k = 0 ; 
4021:	while ( a -> num_bits > 0 ) { 
4022:	header [ k ++ ] = ( stbi_uc ) ( a -> code_buffer & 255 ) ; 
4023:	a -> code_buffer >>= 8 ; 
4024:	a -> num_bits -= 8 ; 
4025:	} 
4026:	if ( a -> num_bits < 0 ) return stbi__err ( "zlib corrupt" ) ; 
4028:	while ( k < 4 ) 
4029:	header [ k ++ ] = stbi__zget8 ( a ) ; 
4030:	len = header [ 1 ] * 256 + header [ 0 ] ; 
4031:	nlen = header [ 3 ] * 256 + header [ 2 ] ; 
4032:	if ( nlen != ( len ^ 0xffff ) ) return stbi__err ( "zlib corrupt" ) ; 
4033:	if ( a -> zbuffer + len > a -> zbuffer_end ) return stbi__err ( "read past buffer" ) ; 
4034:	if ( a -> zout + len > a -> zout_end ) 
4035:	if ( ! stbi__zexpand ( a , a -> zout , len ) ) return 0 ; 
4036:	memcpy ( a -> zout , a -> zbuffer , len ) ; 
4037:	a -> zbuffer += len ; 
4038:	a -> zout += len ; 
4039:	return 1 ; 
4040:	} 
4042:	static int stbi__parse_zlib_header ( stbi__zbuf * a ) 
4043:	{ 
4044:	int cmf = stbi__zget8 ( a ) ; 
4045:	int cm = cmf & 15 ; 
4047:	int flg = stbi__zget8 ( a ) ; 
4048:	if ( stbi__zeof ( a ) ) return stbi__err ( "bad zlib header" ) ; 
4049:	if ( ( cmf * 256 + flg ) % 31 != 0 ) return stbi__err ( "bad zlib header" ) ; 
4050:	if ( flg & 32 ) return stbi__err ( "no preset dict" ) ; 
4051:	if ( cm != 8 ) return stbi__err ( "bad compression" ) ; 
4053:	return 1 ; 
4054:	} 
4056:	static const stbi_uc stbi__zdefault_length [ 288 ] = 
4057:	{ 
4058:	8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 
4059:	8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 
4060:	8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 
4061:	8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 
4062:	8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 
4063:	9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 
4064:	9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 
4065:	9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 
4066:	7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 
4067:	} ; 
4068:	static const stbi_uc stbi__zdefault_distance [ 32 ] = 
4069:	{ 
4070:	5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 
4071:	} ; 
4074:	static int stbi__parse_zlib ( stbi__zbuf * a , int parse_header ) 
4075:	{ 
4076:	int final , type ; 
4077:	if ( parse_header ) 
4078:	if ( ! stbi__parse_zlib_header ( a ) ) return 0 ; 
4079:	a -> num_bits = 0 ; 
4080:	a -> code_buffer = 0 ; 
4081:	do { 
4082:	final = stbi__zreceive ( a , 1 ) ; 
4083:	type = stbi__zreceive ( a , 2 ) ; 
4084:	if ( type == 0 ) { 
4085:	if ( ! stbi__parse_uncompressed_block ( a ) ) return 0 ; 
4086:	} else if ( type == 3 ) { 
4087:	return 0 ; 
4088:	} else { 
4089:	if ( type == 1 ) { 
4091:	if ( ! stbi__zbuild_huffman ( & a -> z_length , stbi__zdefault_length , 288 ) ) return 0 ; 
4092:	if ( ! stbi__zbuild_huffman ( & a -> z_distance , stbi__zdefault_distance , 32 ) ) return 0 ; 
4093:	} else { 
4094:	if ( ! stbi__compute_huffman_codes ( a ) ) return 0 ; 
4095:	} 
4096:	if ( ! stbi__parse_huffman_block ( a ) ) return 0 ; 
4097:	} 
4098:	} while ( ! final ) ; 
4099:	return 1 ; 
4100:	} 
4102:	static int stbi__do_zlib ( stbi__zbuf * a , char * obuf , int olen , int exp , int parse_header ) 
4103:	{ 
4104:	a -> zout_start = obuf ; 
4105:	a -> zout = obuf ; 
4106:	a -> zout_end = obuf + olen ; 
4107:	a -> z_expandable = exp ; 
4109:	return stbi__parse_zlib ( a , parse_header ) ; 
4110:	} 
4112:	extern char * stbi_zlib_decode_malloc_guesssize ( const char * buffer , int len , int initial_size , int * outlen ) 
4113:	{ 
4114:	stbi__zbuf a ; 
4115:	char * p = ( char * ) stbi__malloc ( initial_size ) ; 
4116:	if ( p == ( ( void * ) 0 ) ) return ( ( void * ) 0 ) ; 
4117:	a . zbuffer = ( stbi_uc * ) buffer ; 
4118:	a . zbuffer_end = ( stbi_uc * ) buffer + len ; 
4119:	if ( stbi__do_zlib ( & a , p , initial_size , 1 , 1 ) ) { 
4120:	if ( outlen ) * outlen = ( int ) ( a . zout - a . zout_start ) ; 
4121:	return a . zout_start ; 
4122:	} else { 
4123:	free ( a . zout_start ) ; 
4124:	return ( ( void * ) 0 ) ; 
4125:	} 
4126:	} 
4128:	extern char * stbi_zlib_decode_malloc ( char const * buffer , int len , int * outlen ) 
4129:	{ 
4130:	return stbi_zlib_decode_malloc_guesssize ( buffer , len , 16384 , outlen ) ; 
4131:	} 
4133:	extern char * stbi_zlib_decode_malloc_guesssize_headerflag ( const char * buffer , int len , int initial_size , int * outlen , int parse_header ) 
4134:	{ 
4135:	stbi__zbuf a ; 
4136:	char * p = ( char * ) stbi__malloc ( initial_size ) ; 
4137:	if ( p == ( ( void * ) 0 ) ) return ( ( void * ) 0 ) ; 
4138:	a . zbuffer = ( stbi_uc * ) buffer ; 
4139:	a . zbuffer_end = ( stbi_uc * ) buffer + len ; 
4140:	if ( stbi__do_zlib ( & a , p , initial_size , 1 , parse_header ) ) { 
4141:	if ( outlen ) * outlen = ( int ) ( a . zout - a . zout_start ) ; 
4142:	return a . zout_start ; 
4143:	} else { 
4144:	free ( a . zout_start ) ; 
4145:	return ( ( void * ) 0 ) ; 
4146:	} 
4147:	} 
4149:	extern int stbi_zlib_decode_buffer ( char * obuffer , int olen , char const * ibuffer , int ilen ) 
4150:	{ 
4151:	stbi__zbuf a ; 
4152:	a . zbuffer = ( stbi_uc * ) ibuffer ; 
4153:	a . zbuffer_end = ( stbi_uc * ) ibuffer + ilen ; 
4154:	if ( stbi__do_zlib ( & a , obuffer , olen , 0 , 1 ) ) 
4155:	return ( int ) ( a . zout - a . zout_start ) ; 
4156:	else 
4157:	return - 1 ; 
4158:	} 
4160:	extern char * stbi_zlib_decode_noheader_malloc ( char const * buffer , int len , int * outlen ) 
4161:	{ 
4162:	stbi__zbuf a ; 
4163:	char * p = ( char * ) stbi__malloc ( 16384 ) ; 
4164:	if ( p == ( ( void * ) 0 ) ) return ( ( void * ) 0 ) ; 
4165:	a . zbuffer = ( stbi_uc * ) buffer ; 
4166:	a . zbuffer_end = ( stbi_uc * ) buffer + len ; 
4167:	if ( stbi__do_zlib ( & a , p , 16384 , 1 , 0 ) ) { 
4168:	if ( outlen ) * outlen = ( int ) ( a . zout - a . zout_start ) ; 
4169:	return a . zout_start ; 
4170:	} else { 
4171:	free ( a . zout_start ) ; 
4172:	return ( ( void * ) 0 ) ; 
4173:	} 
4174:	} 
4176:	extern int stbi_zlib_decode_noheader_buffer ( char * obuffer , int olen , const char * ibuffer , int ilen ) 
4177:	{ 
4178:	stbi__zbuf a ; 
4179:	a . zbuffer = ( stbi_uc * ) ibuffer ; 
4180:	a . zbuffer_end = ( stbi_uc * ) ibuffer + ilen ; 
4181:	if ( stbi__do_zlib ( & a , obuffer , olen , 0 , 0 ) ) 
4182:	return ( int ) ( a . zout - a . zout_start ) ; 
4183:	else 
4184:	return - 1 ; 
4185:	} 
4199:	typedef struct 
4200:	{ 
4201:	stbi__uint32 length ; 
4202:	stbi__uint32 type ; 
4203:	} stbi__pngchunk ; 
4205:	static stbi__pngchunk stbi__get_chunk_header ( stbi__context * s ) 
4206:	{ 
4207:	stbi__pngchunk c ; 
4208:	c . length = stbi__get32be ( s ) ; 
4209:	c . type = stbi__get32be ( s ) ; 
4210:	return c ; 
4211:	} 
4213:	static int stbi__check_png_header ( stbi__context * s ) 
4214:	{ 
4215:	static const stbi_uc png_sig [ 8 ] = { 137 , 80 , 78 , 71 , 13 , 10 , 26 , 10 } ; 
4216:	int i ; 
4217:	for ( i = 0 ; i < 8 ; ++ i ) 
4218:	if ( stbi__get8 ( s ) != png_sig [ i ] ) return stbi__err ( "bad png sig" ) ; 
4219:	return 1 ; 
4220:	} 
4222:	typedef struct 
4223:	{ 
4224:	stbi__context * s ; 
4225:	stbi_uc * idata , * expanded , * out ; 
4226:	int depth ; 
4227:	} stbi__png ; 
4230:	enum { 
4231:	STBI__F_none = 0 , 
4232:	STBI__F_sub = 1 , 
4233:	STBI__F_up = 2 , 
4234:	STBI__F_avg = 3 , 
4235:	STBI__F_paeth = 4 , 
4237:	STBI__F_avg_first , 
4238:	STBI__F_paeth_first 
4239:	} ; 
4241:	static stbi_uc first_row_filter [ 5 ] = 
4242:	{ 
4243:	STBI__F_none , 
4244:	STBI__F_sub , 
4245:	STBI__F_none , 
4246:	STBI__F_avg_first , 
4247:	STBI__F_paeth_first 
4248:	} ; 
4250:	static int stbi__paeth ( int a , int b , int c ) 
4251:	{ 
4252:	int p = a + b - c ; 
4253:	int pa = abs ( p - a ) ; 
4254:	int pb = abs ( p - b ) ; 
4255:	int pc = abs ( p - c ) ; 
4256:	if ( pa <= pb && pa <= pc ) return a ; 
4257:	if ( pb <= pc ) return b ; 
4258:	return c ; 
4259:	} 
4261:	static const stbi_uc stbi__depth_scale_table [ 9 ] = { 0 , 0xff , 0x55 , 0 , 0x11 , 0 , 0 , 0 , 0x01 } ; 
4264:	static int stbi__create_png_image_raw ( stbi__png * a , stbi_uc * raw , stbi__uint32 raw_len , int out_n , stbi__uint32 x , stbi__uint32 y , int depth , int color ) 
4265:	{ 
4266:	int bytes = ( depth == 16 ? 2 : 1 ) ; 
4267:	stbi__context * s = a -> s ; 
4268:	stbi__uint32 i , j , stride = x * out_n * bytes ; 
4269:	stbi__uint32 img_len , img_width_bytes ; 
4270:	int k ; 
4271:	int img_n = s -> img_n ; 
4273:	int output_bytes = out_n * bytes ; 
4274:	int filter_bytes = img_n * bytes ; 
4275:	int width = x ; 
4277:	( void ) ( ( !! ( out_n == s -> img_n || out_n == s -> img_n + 1 ) ) || ( _wassert ( L "out_n == s->img_n || out_n == s->img_n+1 " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
4278:	a -> out = ( stbi_uc * ) stbi__malloc_mad3 ( x , y , output_bytes , 0 ) ; 
4279:	if ( ! a -> out ) return stbi__err ( "outofmem" ) ; 
4281:	if ( ! stbi__mad3sizes_valid ( img_n , x , depth , 7 ) ) return stbi__err ( "too large" ) ; 
4282:	img_width_bytes = ( ( ( img_n * x * depth ) + 7 ) >> 3 ) ; 
4283:	img_len = ( img_width_bytes + 1 ) * y ; 
4288:	if ( raw_len < img_len ) return stbi__err ( "not enough pixels" ) ; 
4290:	for ( j = 0 ; j < y ; ++ j ) { 
4291:	stbi_uc * cur = a -> out + stride * j ; 
4292:	stbi_uc * prior ; 
4293:	int filter = * raw ++ ; 
4295:	if ( filter > 4 ) 
4296:	return stbi__err ( "invalid filter" ) ; 
4298:	if ( depth < 8 ) { 
4299:	if ( img_width_bytes > x ) return stbi__err ( "invalid width" ) ; 
4300:	cur += x * out_n - img_width_bytes ; 
4301:	filter_bytes = 1 ; 
4302:	width = img_width_bytes ; 
4303:	} 
4304:	prior = cur - stride ; 
4307:	if ( j == 0 ) filter = first_row_filter [ filter ] ; 
4310:	for ( k = 0 ; k < filter_bytes ; ++ k ) { 
4311:	switch ( filter ) { 
4312:	case STBI__F_none : cur [ k ] = raw [ k ] ; break ; 
4313:	case STBI__F_sub : cur [ k ] = raw [ k ] ; break ; 
4314:	case STBI__F_up : cur [ k ] = ( ( stbi_uc ) ( ( raw [ k ] + prior [ k ] ) & 255 ) ) ; break ; 
4315:	case STBI__F_avg : cur [ k ] = ( ( stbi_uc ) ( ( raw [ k ] + ( prior [ k ] >> 1 ) ) & 255 ) ) ; break ; 
4316:	case STBI__F_paeth : cur [ k ] = ( ( stbi_uc ) ( ( raw [ k ] + stbi__paeth ( 0 , prior [ k ] , 0 ) ) & 255 ) ) ; break ; 
4317:	case STBI__F_avg_first : cur [ k ] = raw [ k ] ; break ; 
4318:	case STBI__F_paeth_first : cur [ k ] = raw [ k ] ; break ; 
4319:	} 
4320:	} 
4322:	if ( depth == 8 ) { 
4323:	if ( img_n != out_n ) 
4324:	cur [ img_n ] = 255 ; 
4325:	raw += img_n ; 
4326:	cur += out_n ; 
4327:	prior += out_n ; 
4328:	} else if ( depth == 16 ) { 
4329:	if ( img_n != out_n ) { 
4330:	cur [ filter_bytes ] = 255 ; 
4331:	cur [ filter_bytes + 1 ] = 255 ; 
4332:	} 
4333:	raw += filter_bytes ; 
4334:	cur += output_bytes ; 
4335:	prior += output_bytes ; 
4336:	} else { 
4337:	raw += 1 ; 
4338:	cur += 1 ; 
4339:	prior += 1 ; 
4340:	} 
4343:	if ( depth < 8 || img_n == out_n ) { 
4344:	int nk = ( width - 1 ) * filter_bytes ; 
4346:	switch ( filter ) { 
4348:	case STBI__F_none : memcpy ( cur , raw , nk ) ; break ; 
4349:	case STBI__F_sub : for ( k = 0 ; k < nk ; ++ k ) { cur [ k ] = ( ( stbi_uc ) ( ( raw [ k ] + cur [ k - filter_bytes ] ) & 255 ) ) ; } break ; 
4350:	case STBI__F_up : for ( k = 0 ; k < nk ; ++ k ) { cur [ k ] = ( ( stbi_uc ) ( ( raw [ k ] + prior [ k ] ) & 255 ) ) ; } break ; 
4351:	case STBI__F_avg : for ( k = 0 ; k < nk ; ++ k ) { cur [ k ] = ( ( stbi_uc ) ( ( raw [ k ] + ( ( prior [ k ] + cur [ k - filter_bytes ] ) >> 1 ) ) & 255 ) ) ; } break ; 
4352:	case STBI__F_paeth : for ( k = 0 ; k < nk ; ++ k ) { cur [ k ] = ( ( stbi_uc ) ( ( raw [ k ] + stbi__paeth ( cur [ k - filter_bytes ] , prior [ k ] , prior [ k - filter_bytes ] ) ) & 255 ) ) ; } break ; 
4353:	case STBI__F_avg_first : for ( k = 0 ; k < nk ; ++ k ) { cur [ k ] = ( ( stbi_uc ) ( ( raw [ k ] + ( cur [ k - filter_bytes ] >> 1 ) ) & 255 ) ) ; } break ; 
4354:	case STBI__F_paeth_first : for ( k = 0 ; k < nk ; ++ k ) { cur [ k ] = ( ( stbi_uc ) ( ( raw [ k ] + stbi__paeth ( cur [ k - filter_bytes ] , 0 , 0 ) ) & 255 ) ) ; } break ; 
4355:	} 
4357:	raw += nk ; 
4358:	} else { 
4359:	( void ) ( ( !! ( img_n + 1 == out_n ) ) || ( _wassert ( L "img_n+1 == out_n " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
4361:	switch ( filter ) { 
4362:	case STBI__F_none : for ( i = x - 1 ; i >= 1 ; -- i , cur [ filter_bytes ] = 255 , raw += filter_bytes , cur += output_bytes , prior += output_bytes ) for ( k = 0 ; k < filter_bytes ; ++ k ) { cur [ k ] = raw [ k ] ; } break ; 
4363:	case STBI__F_sub : for ( i = x - 1 ; i >= 1 ; -- i , cur [ filter_bytes ] = 255 , raw += filter_bytes , cur += output_bytes , prior += output_bytes ) for ( k = 0 ; k < filter_bytes ; ++ k ) { cur [ k ] = ( ( stbi_uc ) ( ( raw [ k ] + cur [ k - output_bytes ] ) & 255 ) ) ; } break ; 
4364:	case STBI__F_up : for ( i = x - 1 ; i >= 1 ; -- i , cur [ filter_bytes ] = 255 , raw += filter_bytes , cur += output_bytes , prior += output_bytes ) for ( k = 0 ; k < filter_bytes ; ++ k ) { cur [ k ] = ( ( stbi_uc ) ( ( raw [ k ] + prior [ k ] ) & 255 ) ) ; } break ; 
4365:	case STBI__F_avg : for ( i = x - 1 ; i >= 1 ; -- i , cur [ filter_bytes ] = 255 , raw += filter_bytes , cur += output_bytes , prior += output_bytes ) for ( k = 0 ; k < filter_bytes ; ++ k ) { cur [ k ] = ( ( stbi_uc ) ( ( raw [ k ] + ( ( prior [ k ] + cur [ k - output_bytes ] ) >> 1 ) ) & 255 ) ) ; } break ; 
4366:	case STBI__F_paeth : for ( i = x - 1 ; i >= 1 ; -- i , cur [ filter_bytes ] = 255 , raw += filter_bytes , cur += output_bytes , prior += output_bytes ) for ( k = 0 ; k < filter_bytes ; ++ k ) { cur [ k ] = ( ( stbi_uc ) ( ( raw [ k ] + stbi__paeth ( cur [ k - output_bytes ] , prior [ k ] , prior [ k - output_bytes ] ) ) & 255 ) ) ; } break ; 
4367:	case STBI__F_avg_first : for ( i = x - 1 ; i >= 1 ; -- i , cur [ filter_bytes ] = 255 , raw += filter_bytes , cur += output_bytes , prior += output_bytes ) for ( k = 0 ; k < filter_bytes ; ++ k ) { cur [ k ] = ( ( stbi_uc ) ( ( raw [ k ] + ( cur [ k - output_bytes ] >> 1 ) ) & 255 ) ) ; } break ; 
4368:	case STBI__F_paeth_first : for ( i = x - 1 ; i >= 1 ; -- i , cur [ filter_bytes ] = 255 , raw += filter_bytes , cur += output_bytes , prior += output_bytes ) for ( k = 0 ; k < filter_bytes ; ++ k ) { cur [ k ] = ( ( stbi_uc ) ( ( raw [ k ] + stbi__paeth ( cur [ k - output_bytes ] , 0 , 0 ) ) & 255 ) ) ; } break ; 
4369:	} 
4374:	if ( depth == 16 ) { 
4375:	cur = a -> out + stride * j ; 
4376:	for ( i = 0 ; i < x ; ++ i , cur += output_bytes ) { 
4377:	cur [ filter_bytes + 1 ] = 255 ; 
4378:	} 
4379:	} 
4380:	} 
4381:	} 
4386:	if ( depth < 8 ) { 
4387:	for ( j = 0 ; j < y ; ++ j ) { 
4388:	stbi_uc * cur = a -> out + stride * j ; 
4389:	stbi_uc * in = a -> out + stride * j + x * out_n - img_width_bytes ; 
4392:	stbi_uc scale = ( color == 0 ) ? stbi__depth_scale_table [ depth ] : 1 ; 
4400:	if ( depth == 4 ) { 
4401:	for ( k = x * img_n ; k >= 2 ; k -= 2 , ++ in ) { 
4402:	* cur ++ = scale * ( ( * in >> 4 ) ) ; 
4403:	* cur ++ = scale * ( ( * in ) & 0x0f ) ; 
4404:	} 
4405:	if ( k > 0 ) * cur ++ = scale * ( ( * in >> 4 ) ) ; 
4406:	} else if ( depth == 2 ) { 
4407:	for ( k = x * img_n ; k >= 4 ; k -= 4 , ++ in ) { 
4408:	* cur ++ = scale * ( ( * in >> 6 ) ) ; 
4409:	* cur ++ = scale * ( ( * in >> 4 ) & 0x03 ) ; 
4410:	* cur ++ = scale * ( ( * in >> 2 ) & 0x03 ) ; 
4411:	* cur ++ = scale * ( ( * in ) & 0x03 ) ; 
4412:	} 
4413:	if ( k > 0 ) * cur ++ = scale * ( ( * in >> 6 ) ) ; 
4414:	if ( k > 1 ) * cur ++ = scale * ( ( * in >> 4 ) & 0x03 ) ; 
4415:	if ( k > 2 ) * cur ++ = scale * ( ( * in >> 2 ) & 0x03 ) ; 
4416:	} else if ( depth == 1 ) { 
4417:	for ( k = x * img_n ; k >= 8 ; k -= 8 , ++ in ) { 
4418:	* cur ++ = scale * ( ( * in >> 7 ) ) ; 
4419:	* cur ++ = scale * ( ( * in >> 6 ) & 0x01 ) ; 
4420:	* cur ++ = scale * ( ( * in >> 5 ) & 0x01 ) ; 
4421:	* cur ++ = scale * ( ( * in >> 4 ) & 0x01 ) ; 
4422:	* cur ++ = scale * ( ( * in >> 3 ) & 0x01 ) ; 
4423:	* cur ++ = scale * ( ( * in >> 2 ) & 0x01 ) ; 
4424:	* cur ++ = scale * ( ( * in >> 1 ) & 0x01 ) ; 
4425:	* cur ++ = scale * ( ( * in ) & 0x01 ) ; 
4426:	} 
4427:	if ( k > 0 ) * cur ++ = scale * ( ( * in >> 7 ) ) ; 
4428:	if ( k > 1 ) * cur ++ = scale * ( ( * in >> 6 ) & 0x01 ) ; 
4429:	if ( k > 2 ) * cur ++ = scale * ( ( * in >> 5 ) & 0x01 ) ; 
4430:	if ( k > 3 ) * cur ++ = scale * ( ( * in >> 4 ) & 0x01 ) ; 
4431:	if ( k > 4 ) * cur ++ = scale * ( ( * in >> 3 ) & 0x01 ) ; 
4432:	if ( k > 5 ) * cur ++ = scale * ( ( * in >> 2 ) & 0x01 ) ; 
4433:	if ( k > 6 ) * cur ++ = scale * ( ( * in >> 1 ) & 0x01 ) ; 
4434:	} 
4435:	if ( img_n != out_n ) { 
4436:	int q ; 
4438:	cur = a -> out + stride * j ; 
4439:	if ( img_n == 1 ) { 
4440:	for ( q = x - 1 ; q >= 0 ; -- q ) { 
4441:	cur [ q * 2 + 1 ] = 255 ; 
4442:	cur [ q * 2 + 0 ] = cur [ q ] ; 
4443:	} 
4444:	} else { 
4445:	( void ) ( ( !! ( img_n == 3 ) ) || ( _wassert ( L "img_n == 3 " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
4446:	for ( q = x - 1 ; q >= 0 ; -- q ) { 
4447:	cur [ q * 4 + 3 ] = 255 ; 
4448:	cur [ q * 4 + 2 ] = cur [ q * 3 + 2 ] ; 
4449:	cur [ q * 4 + 1 ] = cur [ q * 3 + 1 ] ; 
4450:	cur [ q * 4 + 0 ] = cur [ q * 3 + 0 ] ; 
4451:	} 
4452:	} 
4453:	} 
4454:	} 
4455:	} else if ( depth == 16 ) { 
4460:	stbi_uc * cur = a -> out ; 
4461:	stbi__uint16 * cur16 = ( stbi__uint16 * ) cur ; 
4463:	for ( i = 0 ; i < x * y * out_n ; ++ i , cur16 ++ , cur += 2 ) { 
4464:	* cur16 = ( cur [ 0 ] << 8 ) | cur [ 1 ] ; 
4465:	} 
4466:	} 
4468:	return 1 ; 
4469:	} 
4471:	static int stbi__create_png_image ( stbi__png * a , stbi_uc * image_data , stbi__uint32 image_data_len , int out_n , int depth , int color , int interlaced ) 
4472:	{ 
4473:	int bytes = ( depth == 16 ? 2 : 1 ) ; 
4474:	int out_bytes = out_n * bytes ; 
4475:	stbi_uc * final ; 
4476:	int p ; 
4477:	if ( ! interlaced ) 
4478:	return stbi__create_png_image_raw ( a , image_data , image_data_len , out_n , a -> s -> img_x , a -> s -> img_y , depth , color ) ; 
4481:	final = ( stbi_uc * ) stbi__malloc_mad3 ( a -> s -> img_x , a -> s -> img_y , out_bytes , 0 ) ; 
4482:	for ( p = 0 ; p < 7 ; ++ p ) { 
4483:	int xorig [ ] = { 0 , 4 , 0 , 2 , 0 , 1 , 0 } ; 
4484:	int yorig [ ] = { 0 , 0 , 4 , 0 , 2 , 0 , 1 } ; 
4485:	int xspc [ ] = { 8 , 8 , 4 , 4 , 2 , 2 , 1 } ; 
4486:	int yspc [ ] = { 8 , 8 , 8 , 4 , 4 , 2 , 2 } ; 
4487:	int i , j , x , y ; 
4489:	x = ( a -> s -> img_x - xorig [ p ] + xspc [ p ] - 1 ) / xspc [ p ] ; 
4490:	y = ( a -> s -> img_y - yorig [ p ] + yspc [ p ] - 1 ) / yspc [ p ] ; 
4491:	if ( x && y ) { 
4492:	stbi__uint32 img_len = ( ( ( ( a -> s -> img_n * x * depth ) + 7 ) >> 3 ) + 1 ) * y ; 
4493:	if ( ! stbi__create_png_image_raw ( a , image_data , image_data_len , out_n , x , y , depth , color ) ) { 
4494:	free ( final ) ; 
4495:	return 0 ; 
4496:	} 
4497:	for ( j = 0 ; j < y ; ++ j ) { 
4498:	for ( i = 0 ; i < x ; ++ i ) { 
4499:	int out_y = j * yspc [ p ] + yorig [ p ] ; 
4500:	int out_x = i * xspc [ p ] + xorig [ p ] ; 
4501:	memcpy ( final + out_y * a -> s -> img_x * out_bytes + out_x * out_bytes , 
4502:	a -> out + ( j * x + i ) * out_bytes , out_bytes ) ; 
4503:	} 
4504:	} 
4505:	free ( a -> out ) ; 
4506:	image_data += img_len ; 
4507:	image_data_len -= img_len ; 
4508:	} 
4509:	} 
4510:	a -> out = final ; 
4512:	return 1 ; 
4513:	} 
4515:	static int stbi__compute_transparency ( stbi__png * z , stbi_uc tc [ 3 ] , int out_n ) 
4516:	{ 
4517:	stbi__context * s = z -> s ; 
4518:	stbi__uint32 i , pixel_count = s -> img_x * s -> img_y ; 
4519:	stbi_uc * p = z -> out ; 
4523:	( void ) ( ( !! ( out_n == 2 || out_n == 4 ) ) || ( _wassert ( L "out_n == 2 || out_n == 4 " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
4525:	if ( out_n == 2 ) { 
4526:	for ( i = 0 ; i < pixel_count ; ++ i ) { 
4527:	p [ 1 ] = ( p [ 0 ] == tc [ 0 ] ? 0 : 255 ) ; 
4528:	p += 2 ; 
4529:	} 
4530:	} else { 
4531:	for ( i = 0 ; i < pixel_count ; ++ i ) { 
4532:	if ( p [ 0 ] == tc [ 0 ] && p [ 1 ] == tc [ 1 ] && p [ 2 ] == tc [ 2 ] ) 
4533:	p [ 3 ] = 0 ; 
4534:	p += 4 ; 
4535:	} 
4536:	} 
4537:	return 1 ; 
4538:	} 
4540:	static int stbi__compute_transparency16 ( stbi__png * z , stbi__uint16 tc [ 3 ] , int out_n ) 
4541:	{ 
4542:	stbi__context * s = z -> s ; 
4543:	stbi__uint32 i , pixel_count = s -> img_x * s -> img_y ; 
4544:	stbi__uint16 * p = ( stbi__uint16 * ) z -> out ; 
4548:	( void ) ( ( !! ( out_n == 2 || out_n == 4 ) ) || ( _wassert ( L "out_n == 2 || out_n == 4 " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
4550:	if ( out_n == 2 ) { 
4551:	for ( i = 0 ; i < pixel_count ; ++ i ) { 
4552:	p [ 1 ] = ( p [ 0 ] == tc [ 0 ] ? 0 : 65535 ) ; 
4553:	p += 2 ; 
4554:	} 
4555:	} else { 
4556:	for ( i = 0 ; i < pixel_count ; ++ i ) { 
4557:	if ( p [ 0 ] == tc [ 0 ] && p [ 1 ] == tc [ 1 ] && p [ 2 ] == tc [ 2 ] ) 
4558:	p [ 3 ] = 0 ; 
4559:	p += 4 ; 
4560:	} 
4561:	} 
4562:	return 1 ; 
4563:	} 
4565:	static int stbi__expand_png_palette ( stbi__png * a , stbi_uc * palette , int len , int pal_img_n ) 
4566:	{ 
4567:	stbi__uint32 i , pixel_count = a -> s -> img_x * a -> s -> img_y ; 
4568:	stbi_uc * p , * temp_out , * orig = a -> out ; 
4570:	p = ( stbi_uc * ) stbi__malloc_mad2 ( pixel_count , pal_img_n , 0 ) ; 
4571:	if ( p == ( ( void * ) 0 ) ) return stbi__err ( "outofmem" ) ; 
4574:	temp_out = p ; 
4576:	if ( pal_img_n == 3 ) { 
4577:	for ( i = 0 ; i < pixel_count ; ++ i ) { 
4578:	int n = orig [ i ] * 4 ; 
4579:	p [ 0 ] = palette [ n ] ; 
4580:	p [ 1 ] = palette [ n + 1 ] ; 
4581:	p [ 2 ] = palette [ n + 2 ] ; 
4582:	p += 3 ; 
4583:	} 
4584:	} else { 
4585:	for ( i = 0 ; i < pixel_count ; ++ i ) { 
4586:	int n = orig [ i ] * 4 ; 
4587:	p [ 0 ] = palette [ n ] ; 
4588:	p [ 1 ] = palette [ n + 1 ] ; 
4589:	p [ 2 ] = palette [ n + 2 ] ; 
4590:	p [ 3 ] = palette [ n + 3 ] ; 
4591:	p += 4 ; 
4592:	} 
4593:	} 
4594:	free ( a -> out ) ; 
4595:	a -> out = temp_out ; 
4597:	( void ) sizeof ( len ) ; 
4599:	return 1 ; 
4600:	} 
4602:	static int stbi__unpremultiply_on_load = 0 ; 
4603:	static int stbi__de_iphone_flag = 0 ; 
4605:	extern void stbi_set_unpremultiply_on_load ( int flag_true_if_should_unpremultiply ) 
4606:	{ 
4607:	stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply ; 
4608:	} 
4610:	extern void stbi_convert_iphone_png_to_rgb ( int flag_true_if_should_convert ) 
4611:	{ 
4612:	stbi__de_iphone_flag = flag_true_if_should_convert ; 
4613:	} 
4615:	static void stbi__de_iphone ( stbi__png * z ) 
4616:	{ 
4617:	stbi__context * s = z -> s ; 
4618:	stbi__uint32 i , pixel_count = s -> img_x * s -> img_y ; 
4619:	stbi_uc * p = z -> out ; 
4621:	if ( s -> img_out_n == 3 ) { 
4622:	for ( i = 0 ; i < pixel_count ; ++ i ) { 
4623:	stbi_uc t = p [ 0 ] ; 
4624:	p [ 0 ] = p [ 2 ] ; 
4625:	p [ 2 ] = t ; 
4626:	p += 3 ; 
4627:	} 
4628:	} else { 
4629:	( void ) ( ( !! ( s -> img_out_n == 4 ) ) || ( _wassert ( L "s->img_out_n == 4 " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
4630:	if ( stbi__unpremultiply_on_load ) { 
4632:	for ( i = 0 ; i < pixel_count ; ++ i ) { 
4633:	stbi_uc a = p [ 3 ] ; 
4634:	stbi_uc t = p [ 0 ] ; 
4635:	if ( a ) { 
4636:	stbi_uc half = a / 2 ; 
4637:	p [ 0 ] = ( p [ 2 ] * 255 + half ) / a ; 
4638:	p [ 1 ] = ( p [ 1 ] * 255 + half ) / a ; 
4639:	p [ 2 ] = ( t * 255 + half ) / a ; 
4640:	} else { 
4641:	p [ 0 ] = p [ 2 ] ; 
4642:	p [ 2 ] = t ; 
4643:	} 
4644:	p += 4 ; 
4645:	} 
4646:	} else { 
4648:	for ( i = 0 ; i < pixel_count ; ++ i ) { 
4649:	stbi_uc t = p [ 0 ] ; 
4650:	p [ 0 ] = p [ 2 ] ; 
4651:	p [ 2 ] = t ; 
4652:	p += 4 ; 
4653:	} 
4654:	} 
4655:	} 
4656:	} 
4660:	static int stbi__parse_png_file ( stbi__png * z , int scan , int req_comp ) 
4661:	{ 
4662:	stbi_uc palette [ 1024 ] , pal_img_n = 0 ; 
4663:	stbi_uc has_trans = 0 , tc [ 3 ] = { 0 } ; 
4664:	stbi__uint16 tc16 [ 3 ] ; 
4665:	stbi__uint32 ioff = 0 , idata_limit = 0 , i , pal_len = 0 ; 
4666:	int first = 1 , k , interlace = 0 , color = 0 , is_iphone = 0 ; 
4667:	stbi__context * s = z -> s ; 
4669:	z -> expanded = ( ( void * ) 0 ) ; 
4670:	z -> idata = ( ( void * ) 0 ) ; 
4671:	z -> out = ( ( void * ) 0 ) ; 
4673:	if ( ! stbi__check_png_header ( s ) ) return 0 ; 
4675:	if ( scan == STBI__SCAN_type ) return 1 ; 
4677:	for ( ; ; ) { 
4678:	stbi__pngchunk c = stbi__get_chunk_header ( s ) ; 
4679:	switch ( c . type ) { 
4680:	case ( ( ( unsigned ) ( 'C' ) << 24 ) + ( ( unsigned ) ( 'g' ) << 16 ) + ( ( unsigned ) ( 'B' ) << 8 ) + ( unsigned ) ( 'I' ) ) : 
4681:	is_iphone = 1 ; 
4682:	stbi__skip ( s , c . length ) ; 
4683:	break ; 
4684:	case ( ( ( unsigned ) ( 'I' ) << 24 ) + ( ( unsigned ) ( 'H' ) << 16 ) + ( ( unsigned ) ( 'D' ) << 8 ) + ( unsigned ) ( 'R' ) ) : { 
4685:	int comp , filter ; 
4686:	if ( ! first ) return stbi__err ( "multiple IHDR" ) ; 
4687:	first = 0 ; 
4688:	if ( c . length != 13 ) return stbi__err ( "bad IHDR len" ) ; 
4689:	s -> img_x = stbi__get32be ( s ) ; 
4690:	s -> img_y = stbi__get32be ( s ) ; 
4691:	if ( s -> img_y > ( 1 << 24 ) ) return stbi__err ( "too large" ) ; 
4692:	if ( s -> img_x > ( 1 << 24 ) ) return stbi__err ( "too large" ) ; 
4693:	z -> depth = stbi__get8 ( s ) ; if ( z -> depth != 1 && z -> depth != 2 && z -> depth != 4 && z -> depth != 8 && z -> depth != 16 ) return stbi__err ( "1/2/4/8/16-bit only" ) ; 
4694:	color = stbi__get8 ( s ) ; if ( color > 6 ) return stbi__err ( "bad ctype" ) ; 
4695:	if ( color == 3 && z -> depth == 16 ) return stbi__err ( "bad ctype" ) ; 
4696:	if ( color == 3 ) pal_img_n = 3 ; else if ( color & 1 ) return stbi__err ( "bad ctype" ) ; 
4697:	comp = stbi__get8 ( s ) ; if ( comp ) return stbi__err ( "bad comp method" ) ; 
4698:	filter = stbi__get8 ( s ) ; if ( filter ) return stbi__err ( "bad filter method" ) ; 
4699:	interlace = stbi__get8 ( s ) ; if ( interlace > 1 ) return stbi__err ( "bad interlace method" ) ; 
4700:	if ( ! s -> img_x || ! s -> img_y ) return stbi__err ( "0-pixel image" ) ; 
4701:	if ( ! pal_img_n ) { 
4702:	s -> img_n = ( color & 2 ? 3 : 1 ) + ( color & 4 ? 1 : 0 ) ; 
4703:	if ( ( 1 << 30 ) / s -> img_x / s -> img_n < s -> img_y ) return stbi__err ( "too large" ) ; 
4704:	if ( scan == STBI__SCAN_header ) return 1 ; 
4705:	} else { 
4708:	s -> img_n = 1 ; 
4709:	if ( ( 1 << 30 ) / s -> img_x / 4 < s -> img_y ) return stbi__err ( "too large" ) ; 
4711:	} 
4712:	break ; 
4713:	} 
4715:	case ( ( ( unsigned ) ( 'P' ) << 24 ) + ( ( unsigned ) ( 'L' ) << 16 ) + ( ( unsigned ) ( 'T' ) << 8 ) + ( unsigned ) ( 'E' ) ) : { 
4716:	if ( first ) return stbi__err ( "first not IHDR" ) ; 
4717:	if ( c . length > 256 * 3 ) return stbi__err ( "invalid PLTE" ) ; 
4718:	pal_len = c . length / 3 ; 
4719:	if ( pal_len * 3 != c . length ) return stbi__err ( "invalid PLTE" ) ; 
4720:	for ( i = 0 ; i < pal_len ; ++ i ) { 
4721:	palette [ i * 4 + 0 ] = stbi__get8 ( s ) ; 
4722:	palette [ i * 4 + 1 ] = stbi__get8 ( s ) ; 
4723:	palette [ i * 4 + 2 ] = stbi__get8 ( s ) ; 
4724:	palette [ i * 4 + 3 ] = 255 ; 
4725:	} 
4726:	break ; 
4727:	} 
4729:	case ( ( ( unsigned ) ( 't' ) << 24 ) + ( ( unsigned ) ( 'R' ) << 16 ) + ( ( unsigned ) ( 'N' ) << 8 ) + ( unsigned ) ( 'S' ) ) : { 
4730:	if ( first ) return stbi__err ( "first not IHDR" ) ; 
4731:	if ( z -> idata ) return stbi__err ( "tRNS after IDAT" ) ; 
4732:	if ( pal_img_n ) { 
4733:	if ( scan == STBI__SCAN_header ) { s -> img_n = 4 ; return 1 ; } 
4734:	if ( pal_len == 0 ) return stbi__err ( "tRNS before PLTE" ) ; 
4735:	if ( c . length > pal_len ) return stbi__err ( "bad tRNS len" ) ; 
4736:	pal_img_n = 4 ; 
4737:	for ( i = 0 ; i < c . length ; ++ i ) 
4738:	palette [ i * 4 + 3 ] = stbi__get8 ( s ) ; 
4739:	} else { 
4740:	if ( ! ( s -> img_n & 1 ) ) return stbi__err ( "tRNS with alpha" ) ; 
4741:	if ( c . length != ( stbi__uint32 ) s -> img_n * 2 ) return stbi__err ( "bad tRNS len" ) ; 
4742:	has_trans = 1 ; 
4743:	if ( z -> depth == 16 ) { 
4744:	for ( k = 0 ; k < s -> img_n ; ++ k ) tc16 [ k ] = ( stbi__uint16 ) stbi__get16be ( s ) ; 
4745:	} else { 
4746:	for ( k = 0 ; k < s -> img_n ; ++ k ) tc [ k ] = ( stbi_uc ) ( stbi__get16be ( s ) & 255 ) * stbi__depth_scale_table [ z -> depth ] ; 
4747:	} 
4748:	} 
4749:	break ; 
4750:	} 
4752:	case ( ( ( unsigned ) ( 'I' ) << 24 ) + ( ( unsigned ) ( 'D' ) << 16 ) + ( ( unsigned ) ( 'A' ) << 8 ) + ( unsigned ) ( 'T' ) ) : { 
4753:	if ( first ) return stbi__err ( "first not IHDR" ) ; 
4754:	if ( pal_img_n && ! pal_len ) return stbi__err ( "no PLTE" ) ; 
4755:	if ( scan == STBI__SCAN_header ) { s -> img_n = pal_img_n ; return 1 ; } 
4756:	if ( ( int ) ( ioff + c . length ) < ( int ) ioff ) return 0 ; 
4757:	if ( ioff + c . length > idata_limit ) { 
4758:	stbi__uint32 idata_limit_old = idata_limit ; 
4759:	stbi_uc * p ; 
4760:	if ( idata_limit == 0 ) idata_limit = c . length > 4096 ? c . length : 4096 ; 
4761:	while ( ioff + c . length > idata_limit ) 
4762:	idata_limit *= 2 ; 
4763:	( void ) sizeof ( idata_limit_old ) ; 
4764:	p = ( stbi_uc * ) realloc ( z -> idata , idata_limit ) ; if ( p == ( ( void * ) 0 ) ) return stbi__err ( "outofmem" ) ; 
4765:	z -> idata = p ; 
4766:	} 
4767:	if ( ! stbi__getn ( s , z -> idata + ioff , c . length ) ) return stbi__err ( "outofdata" ) ; 
4768:	ioff += c . length ; 
4769:	break ; 
4770:	} 
4772:	case ( ( ( unsigned ) ( 'I' ) << 24 ) + ( ( unsigned ) ( 'E' ) << 16 ) + ( ( unsigned ) ( 'N' ) << 8 ) + ( unsigned ) ( 'D' ) ) : { 
4773:	stbi__uint32 raw_len , bpl ; 
4774:	if ( first ) return stbi__err ( "first not IHDR" ) ; 
4775:	if ( scan != STBI__SCAN_load ) return 1 ; 
4776:	if ( z -> idata == ( ( void * ) 0 ) ) return stbi__err ( "no IDAT" ) ; 
4778:	bpl = ( s -> img_x * z -> depth + 7 ) / 8 ; 
4779:	raw_len = bpl * s -> img_y * s -> img_n + s -> img_y ; 
4780:	z -> expanded = ( stbi_uc * ) stbi_zlib_decode_malloc_guesssize_headerflag ( ( char * ) z -> idata , ioff , raw_len , ( int * ) & raw_len , ! is_iphone ) ; 
4781:	if ( z -> expanded == ( ( void * ) 0 ) ) return 0 ; 
4782:	free ( z -> idata ) ; z -> idata = ( ( void * ) 0 ) ; 
4783:	if ( ( req_comp == s -> img_n + 1 && req_comp != 3 && ! pal_img_n ) || has_trans ) 
4784:	s -> img_out_n = s -> img_n + 1 ; 
4785:	else 
4786:	s -> img_out_n = s -> img_n ; 
4787:	if ( ! stbi__create_png_image ( z , z -> expanded , raw_len , s -> img_out_n , z -> depth , color , interlace ) ) return 0 ; 
4788:	if ( has_trans ) { 
4789:	if ( z -> depth == 16 ) { 
4790:	if ( ! stbi__compute_transparency16 ( z , tc16 , s -> img_out_n ) ) return 0 ; 
4791:	} else { 
4792:	if ( ! stbi__compute_transparency ( z , tc , s -> img_out_n ) ) return 0 ; 
4793:	} 
4794:	} 
4795:	if ( is_iphone && stbi__de_iphone_flag && s -> img_out_n > 2 ) 
4796:	stbi__de_iphone ( z ) ; 
4797:	if ( pal_img_n ) { 
4799:	s -> img_n = pal_img_n ; 
4800:	s -> img_out_n = pal_img_n ; 
4801:	if ( req_comp >= 3 ) s -> img_out_n = req_comp ; 
4802:	if ( ! stbi__expand_png_palette ( z , palette , pal_len , s -> img_out_n ) ) 
4803:	return 0 ; 
4804:	} else if ( has_trans ) { 
4806:	++ s -> img_n ; 
4807:	} 
4808:	free ( z -> expanded ) ; z -> expanded = ( ( void * ) 0 ) ; 
4810:	stbi__get32be ( s ) ; 
4811:	return 1 ; 
4812:	} 
4814:	default : 
4816:	if ( first ) return stbi__err ( "first not IHDR" ) ; 
4817:	if ( ( c . type & ( 1 << 29 ) ) == 0 ) { 
4820:	static char invalid_chunk [ ] = "XXXX PNG chunk not known" ; 
4821:	invalid_chunk [ 0 ] = ( ( stbi_uc ) ( ( c . type >> 24 ) & 255 ) ) ; 
4822:	invalid_chunk [ 1 ] = ( ( stbi_uc ) ( ( c . type >> 16 ) & 255 ) ) ; 
4823:	invalid_chunk [ 2 ] = ( ( stbi_uc ) ( ( c . type >> 8 ) & 255 ) ) ; 
4824:	invalid_chunk [ 3 ] = ( ( stbi_uc ) ( ( c . type >> 0 ) & 255 ) ) ; 
4826:	return stbi__err ( invalid_chunk ) ; 
4827:	} 
4828:	stbi__skip ( s , c . length ) ; 
4829:	break ; 
4830:	} 
4832:	stbi__get32be ( s ) ; 
4833:	} 
4834:	} 
4836:	static void * stbi__do_png ( stbi__png * p , int * x , int * y , int * n , int req_comp , stbi__result_info * ri ) 
4837:	{ 
4838:	void * result = ( ( void * ) 0 ) ; 
4839:	if ( req_comp < 0 || req_comp > 4 ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad req_comp" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
4840:	if ( stbi__parse_png_file ( p , STBI__SCAN_load , req_comp ) ) { 
4841:	if ( p -> depth <= 8 ) 
4842:	ri -> bits_per_channel = 8 ; 
4843:	else if ( p -> depth == 16 ) 
4844:	ri -> bits_per_channel = 16 ; 
4845:	else 
4846:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad bits_per_channel" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
4847:	result = p -> out ; 
4848:	p -> out = ( ( void * ) 0 ) ; 
4849:	if ( req_comp && req_comp != p -> s -> img_out_n ) { 
4850:	if ( ri -> bits_per_channel == 8 ) 
4851:	result = stbi__convert_format ( ( unsigned char * ) result , p -> s -> img_out_n , req_comp , p -> s -> img_x , p -> s -> img_y ) ; 
4852:	else 
4853:	result = stbi__convert_format16 ( ( stbi__uint16 * ) result , p -> s -> img_out_n , req_comp , p -> s -> img_x , p -> s -> img_y ) ; 
4854:	p -> s -> img_out_n = req_comp ; 
4855:	if ( result == ( ( void * ) 0 ) ) return result ; 
4856:	} 
4857:	* x = p -> s -> img_x ; 
4858:	* y = p -> s -> img_y ; 
4859:	if ( n ) * n = p -> s -> img_n ; 
4860:	} 
4861:	free ( p -> out ) ; p -> out = ( ( void * ) 0 ) ; 
4862:	free ( p -> expanded ) ; p -> expanded = ( ( void * ) 0 ) ; 
4863:	free ( p -> idata ) ; p -> idata = ( ( void * ) 0 ) ; 
4865:	return result ; 
4866:	} 
4868:	static void * stbi__png_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri ) 
4869:	{ 
4870:	stbi__png p ; 
4871:	p . s = s ; 
4872:	return stbi__do_png ( & p , x , y , comp , req_comp , ri ) ; 
4873:	} 
4875:	static int stbi__png_test ( stbi__context * s ) 
4876:	{ 
4877:	int r ; 
4878:	r = stbi__check_png_header ( s ) ; 
4879:	stbi__rewind ( s ) ; 
4880:	return r ; 
4881:	} 
4883:	static int stbi__png_info_raw ( stbi__png * p , int * x , int * y , int * comp ) 
4884:	{ 
4885:	if ( ! stbi__parse_png_file ( p , STBI__SCAN_header , 0 ) ) { 
4886:	stbi__rewind ( p -> s ) ; 
4887:	return 0 ; 
4888:	} 
4889:	if ( x ) * x = p -> s -> img_x ; 
4890:	if ( y ) * y = p -> s -> img_y ; 
4891:	if ( comp ) * comp = p -> s -> img_n ; 
4892:	return 1 ; 
4893:	} 
4895:	static int stbi__png_info ( stbi__context * s , int * x , int * y , int * comp ) 
4896:	{ 
4897:	stbi__png p ; 
4898:	p . s = s ; 
4899:	return stbi__png_info_raw ( & p , x , y , comp ) ; 
4900:	} 
4902:	static int stbi__png_is16 ( stbi__context * s ) 
4903:	{ 
4904:	stbi__png p ; 
4905:	p . s = s ; 
4906:	if ( ! stbi__png_info_raw ( & p , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) ) 
4907:	return 0 ; 
4908:	if ( p . depth != 16 ) { 
4909:	stbi__rewind ( p . s ) ; 
4910:	return 0 ; 
4911:	} 
4912:	return 1 ; 
4913:	} 
4919:	static int stbi__bmp_test_raw ( stbi__context * s ) 
4920:	{ 
4921:	int r ; 
4922:	int sz ; 
4923:	if ( stbi__get8 ( s ) != 'B' ) return 0 ; 
4924:	if ( stbi__get8 ( s ) != 'M' ) return 0 ; 
4925:	stbi__get32le ( s ) ; 
4926:	stbi__get16le ( s ) ; 
4927:	stbi__get16le ( s ) ; 
4928:	stbi__get32le ( s ) ; 
4929:	sz = stbi__get32le ( s ) ; 
4930:	r = ( sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124 ) ; 
4931:	return r ; 
4932:	} 
4934:	static int stbi__bmp_test ( stbi__context * s ) 
4935:	{ 
4936:	int r = stbi__bmp_test_raw ( s ) ; 
4937:	stbi__rewind ( s ) ; 
4938:	return r ; 
4939:	} 
4943:	static int stbi__high_bit ( unsigned int z ) 
4944:	{ 
4945:	int n = 0 ; 
4946:	if ( z == 0 ) return - 1 ; 
4947:	if ( z >= 0x10000 ) { n += 16 ; z >>= 16 ; } 
4948:	if ( z >= 0x00100 ) { n += 8 ; z >>= 8 ; } 
4949:	if ( z >= 0x00010 ) { n += 4 ; z >>= 4 ; } 
4950:	if ( z >= 0x00004 ) { n += 2 ; z >>= 2 ; } 
4951:	if ( z >= 0x00002 ) { n += 1 ; } 
4952:	return n ; 
4953:	} 
4955:	static int stbi__bitcount ( unsigned int a ) 
4956:	{ 
4957:	a = ( a & 0x55555555 ) + ( ( a >> 1 ) & 0x55555555 ) ; 
4958:	a = ( a & 0x33333333 ) + ( ( a >> 2 ) & 0x33333333 ) ; 
4959:	a = ( a + ( a >> 4 ) ) & 0x0f0f0f0f ; 
4960:	a = ( a + ( a >> 8 ) ) ; 
4961:	a = ( a + ( a >> 16 ) ) ; 
4962:	return a & 0xff ; 
4963:	} 
4968:	static int stbi__shiftsigned ( unsigned int v , int shift , int bits ) 
4969:	{ 
4970:	static unsigned int mul_table [ 9 ] = { 
4971:	0 , 
4972:	0xff , 0x55 , 0x49 , 0x11 , 
4973:	0x21 , 0x41 , 0x81 , 0x01 , 
4974:	} ; 
4975:	static unsigned int shift_table [ 9 ] = { 
4976:	0 , 0 , 0 , 1 , 0 , 2 , 4 , 6 , 0 , 
4977:	} ; 
4978:	if ( shift < 0 ) 
4979:	v <<= - shift ; 
4980:	else 
4981:	v >>= shift ; 
4982:	( void ) ( ( !! ( v < 256 ) ) || ( _wassert ( L "v < 256 " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
4983:	v >>= ( 8 - bits ) ; 
4984:	( void ) ( ( !! ( bits >= 0 && bits <= 8 ) ) || ( _wassert ( L "bits >= 0 && bits <= 8 " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
4985:	return ( int ) ( ( unsigned ) v * mul_table [ bits ] ) >> shift_table [ bits ] ; 
4986:	} 
4988:	typedef struct 
4989:	{ 
4990:	int bpp , offset , hsz ; 
4991:	unsigned int mr , mg , mb , ma , all_a ; 
4992:	int extra_read ; 
4993:	} stbi__bmp_data ; 
4995:	static void * stbi__bmp_parse_header ( stbi__context * s , stbi__bmp_data * info ) 
4996:	{ 
4997:	int hsz ; 
4998:	if ( stbi__get8 ( s ) != 'B' || stbi__get8 ( s ) != 'M' ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "not BMP" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
4999:	stbi__get32le ( s ) ; 
5000:	stbi__get16le ( s ) ; 
5001:	stbi__get16le ( s ) ; 
5002:	info -> offset = stbi__get32le ( s ) ; 
5003:	info -> hsz = hsz = stbi__get32le ( s ) ; 
5004:	info -> mr = info -> mg = info -> mb = info -> ma = 0 ; 
5005:	info -> extra_read = 14 ; 
5007:	if ( info -> offset < 0 ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad BMP" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5009:	if ( hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124 ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "unknown BMP" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5010:	if ( hsz == 12 ) { 
5011:	s -> img_x = stbi__get16le ( s ) ; 
5012:	s -> img_y = stbi__get16le ( s ) ; 
5013:	} else { 
5014:	s -> img_x = stbi__get32le ( s ) ; 
5015:	s -> img_y = stbi__get32le ( s ) ; 
5016:	} 
5017:	if ( stbi__get16le ( s ) != 1 ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad BMP" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5018:	info -> bpp = stbi__get16le ( s ) ; 
5019:	if ( hsz != 12 ) { 
5020:	int compress = stbi__get32le ( s ) ; 
5021:	if ( compress == 1 || compress == 2 ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "BMP RLE" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5022:	stbi__get32le ( s ) ; 
5023:	stbi__get32le ( s ) ; 
5024:	stbi__get32le ( s ) ; 
5025:	stbi__get32le ( s ) ; 
5026:	stbi__get32le ( s ) ; 
5027:	if ( hsz == 40 || hsz == 56 ) { 
5028:	if ( hsz == 56 ) { 
5029:	stbi__get32le ( s ) ; 
5030:	stbi__get32le ( s ) ; 
5031:	stbi__get32le ( s ) ; 
5032:	stbi__get32le ( s ) ; 
5033:	} 
5034:	if ( info -> bpp == 16 || info -> bpp == 32 ) { 
5035:	if ( compress == 0 ) { 
5036:	if ( info -> bpp == 32 ) { 
5037:	info -> mr = 0xff u << 16 ; 
5038:	info -> mg = 0xff u << 8 ; 
5039:	info -> mb = 0xff u << 0 ; 
5040:	info -> ma = 0xff u << 24 ; 
5041:	info -> all_a = 0 ; 
5042:	} else { 
5043:	info -> mr = 31 u << 10 ; 
5044:	info -> mg = 31 u << 5 ; 
5045:	info -> mb = 31 u << 0 ; 
5046:	} 
5047:	} else if ( compress == 3 ) { 
5048:	info -> mr = stbi__get32le ( s ) ; 
5049:	info -> mg = stbi__get32le ( s ) ; 
5050:	info -> mb = stbi__get32le ( s ) ; 
5051:	info -> extra_read += 12 ; 
5053:	if ( info -> mr == info -> mg && info -> mg == info -> mb ) { 
5055:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad BMP" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5056:	} 
5057:	} else 
5058:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad BMP" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5059:	} 
5060:	} else { 
5061:	int i ; 
5062:	if ( hsz != 108 && hsz != 124 ) 
5063:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad BMP" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5064:	info -> mr = stbi__get32le ( s ) ; 
5065:	info -> mg = stbi__get32le ( s ) ; 
5066:	info -> mb = stbi__get32le ( s ) ; 
5067:	info -> ma = stbi__get32le ( s ) ; 
5068:	stbi__get32le ( s ) ; 
5069:	for ( i = 0 ; i < 12 ; ++ i ) 
5070:	stbi__get32le ( s ) ; 
5071:	if ( hsz == 124 ) { 
5072:	stbi__get32le ( s ) ; 
5073:	stbi__get32le ( s ) ; 
5074:	stbi__get32le ( s ) ; 
5075:	stbi__get32le ( s ) ; 
5076:	} 
5077:	} 
5078:	} 
5079:	return ( void * ) 1 ; 
5080:	} 
5083:	static void * stbi__bmp_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri ) 
5084:	{ 
5085:	stbi_uc * out ; 
5086:	unsigned int mr = 0 , mg = 0 , mb = 0 , ma = 0 , all_a ; 
5087:	stbi_uc pal [ 256 ] [ 4 ] ; 
5088:	int psize = 0 , i , j , width ; 
5089:	int flip_vertically , pad , target ; 
5090:	stbi__bmp_data info ; 
5091:	( void ) sizeof ( ri ) ; 
5093:	info . all_a = 255 ; 
5094:	if ( stbi__bmp_parse_header ( s , & info ) == ( ( void * ) 0 ) ) 
5095:	return ( ( void * ) 0 ) ; 
5097:	flip_vertically = ( ( int ) s -> img_y ) > 0 ; 
5098:	s -> img_y = abs ( ( int ) s -> img_y ) ; 
5100:	if ( s -> img_y > ( 1 << 24 ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5101:	if ( s -> img_x > ( 1 << 24 ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5103:	mr = info . mr ; 
5104:	mg = info . mg ; 
5105:	mb = info . mb ; 
5106:	ma = info . ma ; 
5107:	all_a = info . all_a ; 
5109:	if ( info . hsz == 12 ) { 
5110:	if ( info . bpp < 24 ) 
5111:	psize = ( info . offset - info . extra_read - 24 ) / 3 ; 
5112:	} else { 
5113:	if ( info . bpp < 16 ) 
5114:	psize = ( info . offset - info . extra_read - info . hsz ) >> 2 ; 
5115:	} 
5116:	if ( psize == 0 ) { 
5117:	( void ) ( ( !! ( info . offset == s -> callback_already_read + ( int ) ( s -> img_buffer - s -> img_buffer_original ) ) ) || ( _wassert ( L "info.offset == s->callback_already_read + (int) (s->img_buffer - s->img_buffer_original) " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
5118:	if ( info . offset != s -> callback_already_read + ( s -> img_buffer - s -> buffer_start ) ) { 
5119:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad offset" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5120:	} 
5121:	} 
5123:	if ( info . bpp == 24 && ma == 0xff000000 ) 
5124:	s -> img_n = 3 ; 
5125:	else 
5126:	s -> img_n = ma ? 4 : 3 ; 
5127:	if ( req_comp && req_comp >= 3 ) 
5128:	target = req_comp ; 
5129:	else 
5130:	target = s -> img_n ; 
5133:	if ( ! stbi__mad3sizes_valid ( target , s -> img_x , s -> img_y , 0 ) ) 
5134:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5136:	out = ( stbi_uc * ) stbi__malloc_mad3 ( target , s -> img_x , s -> img_y , 0 ) ; 
5137:	if ( ! out ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5138:	if ( info . bpp < 16 ) { 
5139:	int z = 0 ; 
5140:	if ( psize == 0 || psize > 256 ) { free ( out ) ; return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "invalid" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; } 
5141:	for ( i = 0 ; i < psize ; ++ i ) { 
5142:	pal [ i ] [ 2 ] = stbi__get8 ( s ) ; 
5143:	pal [ i ] [ 1 ] = stbi__get8 ( s ) ; 
5144:	pal [ i ] [ 0 ] = stbi__get8 ( s ) ; 
5145:	if ( info . hsz != 12 ) stbi__get8 ( s ) ; 
5146:	pal [ i ] [ 3 ] = 255 ; 
5147:	} 
5148:	stbi__skip ( s , info . offset - info . extra_read - info . hsz - psize * ( info . hsz == 12 ? 3 : 4 ) ) ; 
5149:	if ( info . bpp == 1 ) width = ( s -> img_x + 7 ) >> 3 ; 
5150:	else if ( info . bpp == 4 ) width = ( s -> img_x + 1 ) >> 1 ; 
5151:	else if ( info . bpp == 8 ) width = s -> img_x ; 
5152:	else { free ( out ) ; return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad bpp" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; } 
5153:	pad = ( - width ) & 3 ; 
5154:	if ( info . bpp == 1 ) { 
5155:	for ( j = 0 ; j < ( int ) s -> img_y ; ++ j ) { 
5156:	int bit_offset = 7 , v = stbi__get8 ( s ) ; 
5157:	for ( i = 0 ; i < ( int ) s -> img_x ; ++ i ) { 
5158:	int color = ( v >> bit_offset ) & 0x1 ; 
5159:	out [ z ++ ] = pal [ color ] [ 0 ] ; 
5160:	out [ z ++ ] = pal [ color ] [ 1 ] ; 
5161:	out [ z ++ ] = pal [ color ] [ 2 ] ; 
5162:	if ( target == 4 ) out [ z ++ ] = 255 ; 
5163:	if ( i + 1 == ( int ) s -> img_x ) break ; 
5164:	if ( ( -- bit_offset ) < 0 ) { 
5165:	bit_offset = 7 ; 
5166:	v = stbi__get8 ( s ) ; 
5167:	} 
5168:	} 
5169:	stbi__skip ( s , pad ) ; 
5170:	} 
5171:	} else { 
5172:	for ( j = 0 ; j < ( int ) s -> img_y ; ++ j ) { 
5173:	for ( i = 0 ; i < ( int ) s -> img_x ; i += 2 ) { 
5174:	int v = stbi__get8 ( s ) , v2 = 0 ; 
5175:	if ( info . bpp == 4 ) { 
5176:	v2 = v & 15 ; 
5177:	v >>= 4 ; 
5178:	} 
5179:	out [ z ++ ] = pal [ v ] [ 0 ] ; 
5180:	out [ z ++ ] = pal [ v ] [ 1 ] ; 
5181:	out [ z ++ ] = pal [ v ] [ 2 ] ; 
5182:	if ( target == 4 ) out [ z ++ ] = 255 ; 
5183:	if ( i + 1 == ( int ) s -> img_x ) break ; 
5184:	v = ( info . bpp == 8 ) ? stbi__get8 ( s ) : v2 ; 
5185:	out [ z ++ ] = pal [ v ] [ 0 ] ; 
5186:	out [ z ++ ] = pal [ v ] [ 1 ] ; 
5187:	out [ z ++ ] = pal [ v ] [ 2 ] ; 
5188:	if ( target == 4 ) out [ z ++ ] = 255 ; 
5189:	} 
5190:	stbi__skip ( s , pad ) ; 
5191:	} 
5192:	} 
5193:	} else { 
5194:	int rshift = 0 , gshift = 0 , bshift = 0 , ashift = 0 , rcount = 0 , gcount = 0 , bcount = 0 , acount = 0 ; 
5195:	int z = 0 ; 
5196:	int easy = 0 ; 
5197:	stbi__skip ( s , info . offset - info . extra_read - info . hsz ) ; 
5198:	if ( info . bpp == 24 ) width = 3 * s -> img_x ; 
5199:	else if ( info . bpp == 16 ) width = 2 * s -> img_x ; 
5200:	else width = 0 ; 
5201:	pad = ( - width ) & 3 ; 
5202:	if ( info . bpp == 24 ) { 
5203:	easy = 1 ; 
5204:	} else if ( info . bpp == 32 ) { 
5205:	if ( mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000 ) 
5206:	easy = 2 ; 
5207:	} 
5208:	if ( ! easy ) { 
5209:	if ( ! mr || ! mg || ! mb ) { free ( out ) ; return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad masks" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; } 
5211:	rshift = stbi__high_bit ( mr ) - 7 ; rcount = stbi__bitcount ( mr ) ; 
5212:	gshift = stbi__high_bit ( mg ) - 7 ; gcount = stbi__bitcount ( mg ) ; 
5213:	bshift = stbi__high_bit ( mb ) - 7 ; bcount = stbi__bitcount ( mb ) ; 
5214:	ashift = stbi__high_bit ( ma ) - 7 ; acount = stbi__bitcount ( ma ) ; 
5215:	if ( rcount > 8 || gcount > 8 || bcount > 8 || acount > 8 ) { free ( out ) ; return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad masks" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; } 
5216:	} 
5217:	for ( j = 0 ; j < ( int ) s -> img_y ; ++ j ) { 
5218:	if ( easy ) { 
5219:	for ( i = 0 ; i < ( int ) s -> img_x ; ++ i ) { 
5220:	unsigned char a ; 
5221:	out [ z + 2 ] = stbi__get8 ( s ) ; 
5222:	out [ z + 1 ] = stbi__get8 ( s ) ; 
5223:	out [ z + 0 ] = stbi__get8 ( s ) ; 
5224:	z += 3 ; 
5225:	a = ( easy == 2 ? stbi__get8 ( s ) : 255 ) ; 
5226:	all_a |= a ; 
5227:	if ( target == 4 ) out [ z ++ ] = a ; 
5228:	} 
5229:	} else { 
5230:	int bpp = info . bpp ; 
5231:	for ( i = 0 ; i < ( int ) s -> img_x ; ++ i ) { 
5232:	stbi__uint32 v = ( bpp == 16 ? ( stbi__uint32 ) stbi__get16le ( s ) : stbi__get32le ( s ) ) ; 
5233:	unsigned int a ; 
5234:	out [ z ++ ] = ( ( stbi_uc ) ( ( stbi__shiftsigned ( v & mr , rshift , rcount ) ) & 255 ) ) ; 
5235:	out [ z ++ ] = ( ( stbi_uc ) ( ( stbi__shiftsigned ( v & mg , gshift , gcount ) ) & 255 ) ) ; 
5236:	out [ z ++ ] = ( ( stbi_uc ) ( ( stbi__shiftsigned ( v & mb , bshift , bcount ) ) & 255 ) ) ; 
5237:	a = ( ma ? stbi__shiftsigned ( v & ma , ashift , acount ) : 255 ) ; 
5238:	all_a |= a ; 
5239:	if ( target == 4 ) out [ z ++ ] = ( ( stbi_uc ) ( ( a ) & 255 ) ) ; 
5240:	} 
5241:	} 
5242:	stbi__skip ( s , pad ) ; 
5243:	} 
5244:	} 
5247:	if ( target == 4 && all_a == 0 ) 
5248:	for ( i = 4 * s -> img_x * s -> img_y - 1 ; i >= 0 ; i -= 4 ) 
5249:	out [ i ] = 255 ; 
5251:	if ( flip_vertically ) { 
5252:	stbi_uc t ; 
5253:	for ( j = 0 ; j < ( int ) s -> img_y >> 1 ; ++ j ) { 
5254:	stbi_uc * p1 = out + j * s -> img_x * target ; 
5255:	stbi_uc * p2 = out + ( s -> img_y - 1 - j ) * s -> img_x * target ; 
5256:	for ( i = 0 ; i < ( int ) s -> img_x * target ; ++ i ) { 
5257:	t = p1 [ i ] ; p1 [ i ] = p2 [ i ] ; p2 [ i ] = t ; 
5258:	} 
5259:	} 
5260:	} 
5262:	if ( req_comp && req_comp != target ) { 
5263:	out = stbi__convert_format ( out , target , req_comp , s -> img_x , s -> img_y ) ; 
5264:	if ( out == ( ( void * ) 0 ) ) return out ; 
5265:	} 
5267:	* x = s -> img_x ; 
5268:	* y = s -> img_y ; 
5269:	if ( comp ) * comp = s -> img_n ; 
5270:	return out ; 
5271:	} 
5278:	static int stbi__tga_get_comp ( int bits_per_pixel , int is_grey , int * is_rgb16 ) 
5279:	{ 
5281:	if ( is_rgb16 ) * is_rgb16 = 0 ; 
5282:	switch ( bits_per_pixel ) { 
5283:	case 8 : return STBI_grey ; 
5284:	case 16 : if ( is_grey ) return STBI_grey_alpha ; 
5286:	case 15 : if ( is_rgb16 ) * is_rgb16 = 1 ; 
5287:	return STBI_rgb ; 
5288:	case 24 : 
5289:	case 32 : return bits_per_pixel / 8 ; 
5290:	default : return 0 ; 
5291:	} 
5292:	} 
5294:	static int stbi__tga_info ( stbi__context * s , int * x , int * y , int * comp ) 
5295:	{ 
5296:	int tga_w , tga_h , tga_comp , tga_image_type , tga_bits_per_pixel , tga_colormap_bpp ; 
5297:	int sz , tga_colormap_type ; 
5298:	stbi__get8 ( s ) ; 
5299:	tga_colormap_type = stbi__get8 ( s ) ; 
5300:	if ( tga_colormap_type > 1 ) { 
5301:	stbi__rewind ( s ) ; 
5302:	return 0 ; 
5303:	} 
5304:	tga_image_type = stbi__get8 ( s ) ; 
5305:	if ( tga_colormap_type == 1 ) { 
5306:	if ( tga_image_type != 1 && tga_image_type != 9 ) { 
5307:	stbi__rewind ( s ) ; 
5308:	return 0 ; 
5309:	} 
5310:	stbi__skip ( s , 4 ) ; 
5311:	sz = stbi__get8 ( s ) ; 
5312:	if ( ( sz != 8 ) && ( sz != 15 ) && ( sz != 16 ) && ( sz != 24 ) && ( sz != 32 ) ) { 
5313:	stbi__rewind ( s ) ; 
5314:	return 0 ; 
5315:	} 
5316:	stbi__skip ( s , 4 ) ; 
5317:	tga_colormap_bpp = sz ; 
5318:	} else { 
5319:	if ( ( tga_image_type != 2 ) && ( tga_image_type != 3 ) && ( tga_image_type != 10 ) && ( tga_image_type != 11 ) ) { 
5320:	stbi__rewind ( s ) ; 
5321:	return 0 ; 
5322:	} 
5323:	stbi__skip ( s , 9 ) ; 
5324:	tga_colormap_bpp = 0 ; 
5325:	} 
5326:	tga_w = stbi__get16le ( s ) ; 
5327:	if ( tga_w < 1 ) { 
5328:	stbi__rewind ( s ) ; 
5329:	return 0 ; 
5330:	} 
5331:	tga_h = stbi__get16le ( s ) ; 
5332:	if ( tga_h < 1 ) { 
5333:	stbi__rewind ( s ) ; 
5334:	return 0 ; 
5335:	} 
5336:	tga_bits_per_pixel = stbi__get8 ( s ) ; 
5337:	stbi__get8 ( s ) ; 
5338:	if ( tga_colormap_bpp != 0 ) { 
5339:	if ( ( tga_bits_per_pixel != 8 ) && ( tga_bits_per_pixel != 16 ) ) { 
5342:	stbi__rewind ( s ) ; 
5343:	return 0 ; 
5344:	} 
5345:	tga_comp = stbi__tga_get_comp ( tga_colormap_bpp , 0 , ( ( void * ) 0 ) ) ; 
5346:	} else { 
5347:	tga_comp = stbi__tga_get_comp ( tga_bits_per_pixel , ( tga_image_type == 3 ) || ( tga_image_type == 11 ) , ( ( void * ) 0 ) ) ; 
5348:	} 
5349:	if ( ! tga_comp ) { 
5350:	stbi__rewind ( s ) ; 
5351:	return 0 ; 
5352:	} 
5353:	if ( x ) * x = tga_w ; 
5354:	if ( y ) * y = tga_h ; 
5355:	if ( comp ) * comp = tga_comp ; 
5356:	return 1 ; 
5357:	} 
5359:	static int stbi__tga_test ( stbi__context * s ) 
5360:	{ 
5361:	int res = 0 ; 
5362:	int sz , tga_color_type ; 
5363:	stbi__get8 ( s ) ; 
5364:	tga_color_type = stbi__get8 ( s ) ; 
5365:	if ( tga_color_type > 1 ) goto errorEnd ; 
5366:	sz = stbi__get8 ( s ) ; 
5367:	if ( tga_color_type == 1 ) { 
5368:	if ( sz != 1 && sz != 9 ) goto errorEnd ; 
5369:	stbi__skip ( s , 4 ) ; 
5370:	sz = stbi__get8 ( s ) ; 
5371:	if ( ( sz != 8 ) && ( sz != 15 ) && ( sz != 16 ) && ( sz != 24 ) && ( sz != 32 ) ) goto errorEnd ; 
5372:	stbi__skip ( s , 4 ) ; 
5373:	} else { 
5374:	if ( ( sz != 2 ) && ( sz != 3 ) && ( sz != 10 ) && ( sz != 11 ) ) goto errorEnd ; 
5375:	stbi__skip ( s , 9 ) ; 
5376:	} 
5377:	if ( stbi__get16le ( s ) < 1 ) goto errorEnd ; 
5378:	if ( stbi__get16le ( s ) < 1 ) goto errorEnd ; 
5379:	sz = stbi__get8 ( s ) ; 
5380:	if ( ( tga_color_type == 1 ) && ( sz != 8 ) && ( sz != 16 ) ) goto errorEnd ; 
5381:	if ( ( sz != 8 ) && ( sz != 15 ) && ( sz != 16 ) && ( sz != 24 ) && ( sz != 32 ) ) goto errorEnd ; 
5383:	res = 1 ; 
5385:	errorEnd : 
5386:	stbi__rewind ( s ) ; 
5387:	return res ; 
5388:	} 
5391:	static void stbi__tga_read_rgb16 ( stbi__context * s , stbi_uc * out ) 
5392:	{ 
5393:	stbi__uint16 px = ( stbi__uint16 ) stbi__get16le ( s ) ; 
5394:	stbi__uint16 fiveBitMask = 31 ; 
5396:	int r = ( px >> 10 ) & fiveBitMask ; 
5397:	int g = ( px >> 5 ) & fiveBitMask ; 
5398:	int b = px & fiveBitMask ; 
5400:	out [ 0 ] = ( stbi_uc ) ( ( r * 255 ) / 31 ) ; 
5401:	out [ 1 ] = ( stbi_uc ) ( ( g * 255 ) / 31 ) ; 
5402:	out [ 2 ] = ( stbi_uc ) ( ( b * 255 ) / 31 ) ; 
5408:	} 
5410:	static void * stbi__tga_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri ) 
5411:	{ 
5413:	int tga_offset = stbi__get8 ( s ) ; 
5414:	int tga_indexed = stbi__get8 ( s ) ; 
5415:	int tga_image_type = stbi__get8 ( s ) ; 
5416:	int tga_is_RLE = 0 ; 
5417:	int tga_palette_start = stbi__get16le ( s ) ; 
5418:	int tga_palette_len = stbi__get16le ( s ) ; 
5419:	int tga_palette_bits = stbi__get8 ( s ) ; 
5420:	int tga_x_origin = stbi__get16le ( s ) ; 
5421:	int tga_y_origin = stbi__get16le ( s ) ; 
5422:	int tga_width = stbi__get16le ( s ) ; 
5423:	int tga_height = stbi__get16le ( s ) ; 
5424:	int tga_bits_per_pixel = stbi__get8 ( s ) ; 
5425:	int tga_comp , tga_rgb16 = 0 ; 
5426:	int tga_inverted = stbi__get8 ( s ) ; 
5429:	unsigned char * tga_data ; 
5430:	unsigned char * tga_palette = ( ( void * ) 0 ) ; 
5431:	int i , j ; 
5432:	unsigned char raw_data [ 4 ] = { 0 } ; 
5433:	int RLE_count = 0 ; 
5434:	int RLE_repeating = 0 ; 
5435:	int read_next_pixel = 1 ; 
5436:	( void ) sizeof ( ri ) ; 
5437:	( void ) sizeof ( tga_x_origin ) ; 
5438:	( void ) sizeof ( tga_y_origin ) ; 
5440:	if ( tga_height > ( 1 << 24 ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5441:	if ( tga_width > ( 1 << 24 ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5444:	if ( tga_image_type >= 8 ) 
5445:	{ 
5446:	tga_image_type -= 8 ; 
5447:	tga_is_RLE = 1 ; 
5448:	} 
5449:	tga_inverted = 1 - ( ( tga_inverted >> 5 ) & 1 ) ; 
5452:	if ( tga_indexed ) tga_comp = stbi__tga_get_comp ( tga_palette_bits , 0 , & tga_rgb16 ) ; 
5453:	else tga_comp = stbi__tga_get_comp ( tga_bits_per_pixel , ( tga_image_type == 3 ) , & tga_rgb16 ) ; 
5455:	if ( ! tga_comp ) 
5456:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad format" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5459:	* x = tga_width ; 
5460:	* y = tga_height ; 
5461:	if ( comp ) * comp = tga_comp ; 
5463:	if ( ! stbi__mad3sizes_valid ( tga_width , tga_height , tga_comp , 0 ) ) 
5464:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5466:	tga_data = ( unsigned char * ) stbi__malloc_mad3 ( tga_width , tga_height , tga_comp , 0 ) ; 
5467:	if ( ! tga_data ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5470:	stbi__skip ( s , tga_offset ) ; 
5472:	if ( ! tga_indexed && ! tga_is_RLE && ! tga_rgb16 ) { 
5473:	for ( i = 0 ; i < tga_height ; ++ i ) { 
5474:	int row = tga_inverted ? tga_height - i - 1 : i ; 
5475:	stbi_uc * tga_row = tga_data + row * tga_width * tga_comp ; 
5476:	stbi__getn ( s , tga_row , tga_width * tga_comp ) ; 
5477:	} 
5478:	} else { 
5480:	if ( tga_indexed ) 
5481:	{ 
5482:	if ( tga_palette_len == 0 ) { 
5483:	free ( tga_data ) ; 
5484:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad palette" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5485:	} 
5488:	stbi__skip ( s , tga_palette_start ) ; 
5490:	tga_palette = ( unsigned char * ) stbi__malloc_mad2 ( tga_palette_len , tga_comp , 0 ) ; 
5491:	if ( ! tga_palette ) { 
5492:	free ( tga_data ) ; 
5493:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5494:	} 
5495:	if ( tga_rgb16 ) { 
5496:	stbi_uc * pal_entry = tga_palette ; 
5497:	( void ) ( ( !! ( tga_comp == STBI_rgb ) ) || ( _wassert ( L "tga_comp == STBI_rgb " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
5498:	for ( i = 0 ; i < tga_palette_len ; ++ i ) { 
5499:	stbi__tga_read_rgb16 ( s , pal_entry ) ; 
5500:	pal_entry += tga_comp ; 
5501:	} 
5502:	} else if ( ! stbi__getn ( s , tga_palette , tga_palette_len * tga_comp ) ) { 
5503:	free ( tga_data ) ; 
5504:	free ( tga_palette ) ; 
5505:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad palette" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5506:	} 
5507:	} 
5509:	for ( i = 0 ; i < tga_width * tga_height ; ++ i ) 
5510:	{ 
5512:	if ( tga_is_RLE ) 
5513:	{ 
5514:	if ( RLE_count == 0 ) 
5515:	{ 
5517:	int RLE_cmd = stbi__get8 ( s ) ; 
5518:	RLE_count = 1 + ( RLE_cmd & 127 ) ; 
5519:	RLE_repeating = RLE_cmd >> 7 ; 
5520:	read_next_pixel = 1 ; 
5521:	} else if ( ! RLE_repeating ) 
5522:	{ 
5523:	read_next_pixel = 1 ; 
5524:	} 
5525:	} else 
5526:	{ 
5527:	read_next_pixel = 1 ; 
5528:	} 
5530:	if ( read_next_pixel ) 
5531:	{ 
5533:	if ( tga_indexed ) 
5534:	{ 
5536:	int pal_idx = ( tga_bits_per_pixel == 8 ) ? stbi__get8 ( s ) : stbi__get16le ( s ) ; 
5537:	if ( pal_idx >= tga_palette_len ) { 
5539:	pal_idx = 0 ; 
5540:	} 
5541:	pal_idx *= tga_comp ; 
5542:	for ( j = 0 ; j < tga_comp ; ++ j ) { 
5543:	raw_data [ j ] = tga_palette [ pal_idx + j ] ; 
5544:	} 
5545:	} else if ( tga_rgb16 ) { 
5546:	( void ) ( ( !! ( tga_comp == STBI_rgb ) ) || ( _wassert ( L "tga_comp == STBI_rgb " , L__FILE__ , ( unsigned ) ( __LINE__ ) ) , 0 ) ) ; 
5547:	stbi__tga_read_rgb16 ( s , raw_data ) ; 
5548:	} else { 
5550:	for ( j = 0 ; j < tga_comp ; ++ j ) { 
5551:	raw_data [ j ] = stbi__get8 ( s ) ; 
5552:	} 
5553:	} 
5555:	read_next_pixel = 0 ; 
5556:	} 
5559:	for ( j = 0 ; j < tga_comp ; ++ j ) 
5560:	tga_data [ i * tga_comp + j ] = raw_data [ j ] ; 
5563:	-- RLE_count ; 
5564:	} 
5566:	if ( tga_inverted ) 
5567:	{ 
5568:	for ( j = 0 ; j * 2 < tga_height ; ++ j ) 
5569:	{ 
5570:	int index1 = j * tga_width * tga_comp ; 
5571:	int index2 = ( tga_height - 1 - j ) * tga_width * tga_comp ; 
5572:	for ( i = tga_width * tga_comp ; i > 0 ; -- i ) 
5573:	{ 
5574:	unsigned char temp = tga_data [ index1 ] ; 
5575:	tga_data [ index1 ] = tga_data [ index2 ] ; 
5576:	tga_data [ index2 ] = temp ; 
5577:	++ index1 ; 
5578:	++ index2 ; 
5579:	} 
5580:	} 
5581:	} 
5583:	if ( tga_palette != ( ( void * ) 0 ) ) 
5584:	{ 
5585:	free ( tga_palette ) ; 
5586:	} 
5587:	} 
5590:	if ( tga_comp >= 3 && ! tga_rgb16 ) 
5591:	{ 
5592:	unsigned char * tga_pixel = tga_data ; 
5593:	for ( i = 0 ; i < tga_width * tga_height ; ++ i ) 
5594:	{ 
5595:	unsigned char temp = tga_pixel [ 0 ] ; 
5596:	tga_pixel [ 0 ] = tga_pixel [ 2 ] ; 
5597:	tga_pixel [ 2 ] = temp ; 
5598:	tga_pixel += tga_comp ; 
5599:	} 
5600:	} 
5603:	if ( req_comp && req_comp != tga_comp ) 
5604:	tga_data = stbi__convert_format ( tga_data , tga_comp , req_comp , tga_width , tga_height ) ; 
5608:	tga_palette_start = tga_palette_len = tga_palette_bits = 
5609:	tga_x_origin = tga_y_origin = 0 ; 
5610:	( void ) sizeof ( tga_palette_start ) ; 
5612:	return tga_data ; 
5613:	} 
5620:	static int stbi__psd_test ( stbi__context * s ) 
5621:	{ 
5622:	int r = ( stbi__get32be ( s ) == 0x38425053 ) ; 
5623:	stbi__rewind ( s ) ; 
5624:	return r ; 
5625:	} 
5627:	static int stbi__psd_decode_rle ( stbi__context * s , stbi_uc * p , int pixelCount ) 
5628:	{ 
5629:	int count , nleft , len ; 
5631:	count = 0 ; 
5632:	while ( ( nleft = pixelCount - count ) > 0 ) { 
5633:	len = stbi__get8 ( s ) ; 
5634:	if ( len == 128 ) { 
5636:	} else if ( len < 128 ) { 
5638:	len ++ ; 
5639:	if ( len > nleft ) return 0 ; 
5640:	count += len ; 
5641:	while ( len ) { 
5642:	* p = stbi__get8 ( s ) ; 
5643:	p += 4 ; 
5644:	len -- ; 
5645:	} 
5646:	} else if ( len > 128 ) { 
5647:	stbi_uc val ; 
5650:	len = 257 - len ; 
5651:	if ( len > nleft ) return 0 ; 
5652:	val = stbi__get8 ( s ) ; 
5653:	count += len ; 
5654:	while ( len ) { 
5655:	* p = val ; 
5656:	p += 4 ; 
5657:	len -- ; 
5658:	} 
5659:	} 
5660:	} 
5662:	return 1 ; 
5663:	} 
5665:	static void * stbi__psd_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri , int bpc ) 
5666:	{ 
5667:	int pixelCount ; 
5668:	int channelCount , compression ; 
5669:	int channel , i ; 
5670:	int bitdepth ; 
5671:	int w , h ; 
5672:	stbi_uc * out ; 
5673:	( void ) sizeof ( ri ) ; 
5676:	if ( stbi__get32be ( s ) != 0x38425053 ) 
5677:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "not PSD" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5680:	if ( stbi__get16be ( s ) != 1 ) 
5681:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "wrong version" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5684:	stbi__skip ( s , 6 ) ; 
5687:	channelCount = stbi__get16be ( s ) ; 
5688:	if ( channelCount < 0 || channelCount > 16 ) 
5689:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "wrong channel count" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5692:	h = stbi__get32be ( s ) ; 
5693:	w = stbi__get32be ( s ) ; 
5695:	if ( h > ( 1 << 24 ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5696:	if ( w > ( 1 << 24 ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5699:	bitdepth = stbi__get16be ( s ) ; 
5700:	if ( bitdepth != 8 && bitdepth != 16 ) 
5701:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "unsupported bit depth" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5713:	if ( stbi__get16be ( s ) != 3 ) 
5714:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "wrong color format" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5717:	stbi__skip ( s , stbi__get32be ( s ) ) ; 
5720:	stbi__skip ( s , stbi__get32be ( s ) ) ; 
5723:	stbi__skip ( s , stbi__get32be ( s ) ) ; 
5729:	compression = stbi__get16be ( s ) ; 
5730:	if ( compression > 1 ) 
5731:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad compression" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5734:	if ( ! stbi__mad3sizes_valid ( 4 , w , h , 0 ) ) 
5735:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5739:	if ( ! compression && bitdepth == 16 && bpc == 16 ) { 
5740:	out = ( stbi_uc * ) stbi__malloc_mad3 ( 8 , w , h , 0 ) ; 
5741:	ri -> bits_per_channel = 16 ; 
5742:	} else 
5743:	out = ( stbi_uc * ) stbi__malloc ( 4 * w * h ) ; 
5745:	if ( ! out ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5746:	pixelCount = w * h ; 
5752:	if ( compression ) { 
5763:	stbi__skip ( s , h * channelCount * 2 ) ; 
5766:	for ( channel = 0 ; channel < 4 ; channel ++ ) { 
5767:	stbi_uc * p ; 
5769:	p = out + channel ; 
5770:	if ( channel >= channelCount ) { 
5772:	for ( i = 0 ; i < pixelCount ; i ++ , p += 4 ) 
5773:	* p = ( channel == 3 ? 255 : 0 ) ; 
5774:	} else { 
5776:	if ( ! stbi__psd_decode_rle ( s , p , pixelCount ) ) { 
5777:	free ( out ) ; 
5778:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "corrupt" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5779:	} 
5780:	} 
5781:	} 
5783:	} else { 
5788:	for ( channel = 0 ; channel < 4 ; channel ++ ) { 
5789:	if ( channel >= channelCount ) { 
5791:	if ( bitdepth == 16 && bpc == 16 ) { 
5792:	stbi__uint16 * q = ( ( stbi__uint16 * ) out ) + channel ; 
5793:	stbi__uint16 val = channel == 3 ? 65535 : 0 ; 
5794:	for ( i = 0 ; i < pixelCount ; i ++ , q += 4 ) 
5795:	* q = val ; 
5796:	} else { 
5797:	stbi_uc * p = out + channel ; 
5798:	stbi_uc val = channel == 3 ? 255 : 0 ; 
5799:	for ( i = 0 ; i < pixelCount ; i ++ , p += 4 ) 
5800:	* p = val ; 
5801:	} 
5802:	} else { 
5803:	if ( ri -> bits_per_channel == 16 ) { 
5804:	stbi__uint16 * q = ( ( stbi__uint16 * ) out ) + channel ; 
5805:	for ( i = 0 ; i < pixelCount ; i ++ , q += 4 ) 
5806:	* q = ( stbi__uint16 ) stbi__get16be ( s ) ; 
5807:	} else { 
5808:	stbi_uc * p = out + channel ; 
5809:	if ( bitdepth == 16 ) { 
5810:	for ( i = 0 ; i < pixelCount ; i ++ , p += 4 ) 
5811:	* p = ( stbi_uc ) ( stbi__get16be ( s ) >> 8 ) ; 
5812:	} else { 
5813:	for ( i = 0 ; i < pixelCount ; i ++ , p += 4 ) 
5814:	* p = stbi__get8 ( s ) ; 
5815:	} 
5816:	} 
5817:	} 
5818:	} 
5819:	} 
5822:	if ( channelCount >= 4 ) { 
5823:	if ( ri -> bits_per_channel == 16 ) { 
5824:	for ( i = 0 ; i < w * h ; ++ i ) { 
5825:	stbi__uint16 * pixel = ( stbi__uint16 * ) out + 4 * i ; 
5826:	if ( pixel [ 3 ] != 0 && pixel [ 3 ] != 65535 ) { 
5827:	float a = pixel [ 3 ] / 65535 . 0 f ; 
5828:	float ra = 1 . 0 f / a ; 
5829:	float inv_a = 65535 . 0 f * ( 1 - ra ) ; 
5830:	pixel [ 0 ] = ( stbi__uint16 ) ( pixel [ 0 ] * ra + inv_a ) ; 
5831:	pixel [ 1 ] = ( stbi__uint16 ) ( pixel [ 1 ] * ra + inv_a ) ; 
5832:	pixel [ 2 ] = ( stbi__uint16 ) ( pixel [ 2 ] * ra + inv_a ) ; 
5833:	} 
5834:	} 
5835:	} else { 
5836:	for ( i = 0 ; i < w * h ; ++ i ) { 
5837:	unsigned char * pixel = out + 4 * i ; 
5838:	if ( pixel [ 3 ] != 0 && pixel [ 3 ] != 255 ) { 
5839:	float a = pixel [ 3 ] / 255 . 0 f ; 
5840:	float ra = 1 . 0 f / a ; 
5841:	float inv_a = 255 . 0 f * ( 1 - ra ) ; 
5842:	pixel [ 0 ] = ( unsigned char ) ( pixel [ 0 ] * ra + inv_a ) ; 
5843:	pixel [ 1 ] = ( unsigned char ) ( pixel [ 1 ] * ra + inv_a ) ; 
5844:	pixel [ 2 ] = ( unsigned char ) ( pixel [ 2 ] * ra + inv_a ) ; 
5845:	} 
5846:	} 
5847:	} 
5848:	} 
5851:	if ( req_comp && req_comp != 4 ) { 
5852:	if ( ri -> bits_per_channel == 16 ) 
5853:	out = ( stbi_uc * ) stbi__convert_format16 ( ( stbi__uint16 * ) out , 4 , req_comp , w , h ) ; 
5854:	else 
5855:	out = stbi__convert_format ( out , 4 , req_comp , w , h ) ; 
5856:	if ( out == ( ( void * ) 0 ) ) return out ; 
5857:	} 
5859:	if ( comp ) * comp = 4 ; 
5860:	* y = h ; 
5861:	* x = w ; 
5863:	return out ; 
5864:	} 
5875:	static int stbi__pic_is4 ( stbi__context * s , const char * str ) 
5876:	{ 
5877:	int i ; 
5878:	for ( i = 0 ; i < 4 ; ++ i ) 
5879:	if ( stbi__get8 ( s ) != ( stbi_uc ) str [ i ] ) 
5880:	return 0 ; 
5882:	return 1 ; 
5883:	} 
5885:	static int stbi__pic_test_core ( stbi__context * s ) 
5886:	{ 
5887:	int i ; 
5889:	if ( ! stbi__pic_is4 ( s , "\x53\x80\xF6\x34" ) ) 
5890:	return 0 ; 
5892:	for ( i = 0 ; i < 84 ; ++ i ) 
5893:	stbi__get8 ( s ) ; 
5895:	if ( ! stbi__pic_is4 ( s , "PICT" ) ) 
5896:	return 0 ; 
5898:	return 1 ; 
5899:	} 
5901:	typedef struct 
5902:	{ 
5903:	stbi_uc size , type , channel ; 
5904:	} stbi__pic_packet ; 
5906:	static stbi_uc * stbi__readval ( stbi__context * s , int channel , stbi_uc * dest ) 
5907:	{ 
5908:	int mask = 0x80 , i ; 
5910:	for ( i = 0 ; i < 4 ; ++ i , mask >>= 1 ) { 
5911:	if ( channel & mask ) { 
5912:	if ( stbi__at_eof ( s ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad file" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5913:	dest [ i ] = stbi__get8 ( s ) ; 
5914:	} 
5915:	} 
5917:	return dest ; 
5918:	} 
5920:	static void stbi__copyval ( int channel , stbi_uc * dest , const stbi_uc * src ) 
5921:	{ 
5922:	int mask = 0x80 , i ; 
5924:	for ( i = 0 ; i < 4 ; ++ i , mask >>= 1 ) 
5925:	if ( channel & mask ) 
5926:	dest [ i ] = src [ i ] ; 
5927:	} 
5929:	static stbi_uc * stbi__pic_load_core ( stbi__context * s , int width , int height , int * comp , stbi_uc * result ) 
5930:	{ 
5931:	int act_comp = 0 , num_packets = 0 , y , chained ; 
5932:	stbi__pic_packet packets [ 10 ] ; 
5936:	do { 
5937:	stbi__pic_packet * packet ; 
5939:	if ( num_packets == sizeof ( packets ) / sizeof ( packets [ 0 ] ) ) 
5940:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad format" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5942:	packet = & packets [ num_packets ++ ] ; 
5944:	chained = stbi__get8 ( s ) ; 
5945:	packet -> size = stbi__get8 ( s ) ; 
5946:	packet -> type = stbi__get8 ( s ) ; 
5947:	packet -> channel = stbi__get8 ( s ) ; 
5949:	act_comp |= packet -> channel ; 
5951:	if ( stbi__at_eof ( s ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad file" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5952:	if ( packet -> size != 8 ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad format" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5953:	} while ( chained ) ; 
5955:	* comp = ( act_comp & 0x10 ? 4 : 3 ) ; 
5957:	for ( y = 0 ; y < height ; ++ y ) { 
5958:	int packet_idx ; 
5960:	for ( packet_idx = 0 ; packet_idx < num_packets ; ++ packet_idx ) { 
5961:	stbi__pic_packet * packet = & packets [ packet_idx ] ; 
5962:	stbi_uc * dest = result + y * width * 4 ; 
5964:	switch ( packet -> type ) { 
5965:	default : 
5966:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad format" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5968:	case 0 : { 
5969:	int x ; 
5971:	for ( x = 0 ; x < width ; ++ x , dest += 4 ) 
5972:	if ( ! stbi__readval ( s , packet -> channel , dest ) ) 
5973:	return 0 ; 
5974:	break ; 
5975:	} 
5977:	case 1 : 
5978:	{ 
5979:	int left = width , i ; 
5981:	while ( left > 0 ) { 
5982:	stbi_uc count , value [ 4 ] ; 
5984:	count = stbi__get8 ( s ) ; 
5985:	if ( stbi__at_eof ( s ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad file" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
5987:	if ( count > left ) 
5988:	count = ( stbi_uc ) left ; 
5990:	if ( ! stbi__readval ( s , packet -> channel , value ) ) return 0 ; 
5992:	for ( i = 0 ; i < count ; ++ i , dest += 4 ) 
5993:	stbi__copyval ( packet -> channel , dest , value ) ; 
5994:	left -= count ; 
5995:	} 
5996:	} 
5997:	break ; 
5999:	case 2 : { 
6000:	int left = width ; 
6001:	while ( left > 0 ) { 
6002:	int count = stbi__get8 ( s ) , i ; 
6003:	if ( stbi__at_eof ( s ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad file" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6005:	if ( count >= 128 ) { 
6006:	stbi_uc value [ 4 ] ; 
6008:	if ( count == 128 ) 
6009:	count = stbi__get16be ( s ) ; 
6010:	else 
6011:	count -= 127 ; 
6012:	if ( count > left ) 
6013:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad file" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6015:	if ( ! stbi__readval ( s , packet -> channel , value ) ) 
6016:	return 0 ; 
6018:	for ( i = 0 ; i < count ; ++ i , dest += 4 ) 
6019:	stbi__copyval ( packet -> channel , dest , value ) ; 
6020:	} else { 
6021:	++ count ; 
6022:	if ( count > left ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad file" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6024:	for ( i = 0 ; i < count ; ++ i , dest += 4 ) 
6025:	if ( ! stbi__readval ( s , packet -> channel , dest ) ) 
6026:	return 0 ; 
6027:	} 
6028:	left -= count ; 
6029:	} 
6030:	break ; 
6031:	} 
6032:	} 
6033:	} 
6034:	} 
6036:	return result ; 
6037:	} 
6039:	static void * stbi__pic_load ( stbi__context * s , int * px , int * py , int * comp , int req_comp , stbi__result_info * ri ) 
6040:	{ 
6041:	stbi_uc * result ; 
6042:	int i , x , y , internal_comp ; 
6043:	( void ) sizeof ( ri ) ; 
6045:	if ( ! comp ) comp = & internal_comp ; 
6047:	for ( i = 0 ; i < 92 ; ++ i ) 
6048:	stbi__get8 ( s ) ; 
6050:	x = stbi__get16be ( s ) ; 
6051:	y = stbi__get16be ( s ) ; 
6053:	if ( y > ( 1 << 24 ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6054:	if ( x > ( 1 << 24 ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6056:	if ( stbi__at_eof ( s ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad file" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6057:	if ( ! stbi__mad3sizes_valid ( x , y , 4 , 0 ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6059:	stbi__get32be ( s ) ; 
6060:	stbi__get16be ( s ) ; 
6061:	stbi__get16be ( s ) ; 
6064:	result = ( stbi_uc * ) stbi__malloc_mad3 ( x , y , 4 , 0 ) ; 
6065:	memset ( result , 0xff , x * y * 4 ) ; 
6067:	if ( ! stbi__pic_load_core ( s , x , y , comp , result ) ) { 
6068:	free ( result ) ; 
6069:	result = 0 ; 
6070:	} 
6071:	* px = x ; 
6072:	* py = y ; 
6073:	if ( req_comp == 0 ) req_comp = * comp ; 
6074:	result = stbi__convert_format ( result , 4 , req_comp , x , y ) ; 
6076:	return result ; 
6077:	} 
6079:	static int stbi__pic_test ( stbi__context * s ) 
6080:	{ 
6081:	int r = stbi__pic_test_core ( s ) ; 
6082:	stbi__rewind ( s ) ; 
6083:	return r ; 
6084:	} 
6091:	typedef struct 
6092:	{ 
6093:	stbi__int16 prefix ; 
6094:	stbi_uc first ; 
6095:	stbi_uc suffix ; 
6096:	} stbi__gif_lzw ; 
6098:	typedef struct 
6099:	{ 
6100:	int w , h ; 
6101:	stbi_uc * out ; 
6102:	stbi_uc * background ; 
6103:	stbi_uc * history ; 
6104:	int flags , bgindex , ratio , transparent , eflags ; 
6105:	stbi_uc pal [ 256 ] [ 4 ] ; 
6106:	stbi_uc lpal [ 256 ] [ 4 ] ; 
6107:	stbi__gif_lzw codes [ 8192 ] ; 
6108:	stbi_uc * color_table ; 
6109:	int parse , step ; 
6110:	int lflags ; 
6111:	int start_x , start_y ; 
6112:	int max_x , max_y ; 
6113:	int cur_x , cur_y ; 
6114:	int line_size ; 
6115:	int delay ; 
6116:	} stbi__gif ; 
6118:	static int stbi__gif_test_raw ( stbi__context * s ) 
6119:	{ 
6120:	int sz ; 
6121:	if ( stbi__get8 ( s ) != 'G' || stbi__get8 ( s ) != 'I' || stbi__get8 ( s ) != 'F' || stbi__get8 ( s ) != '8' ) return 0 ; 
6122:	sz = stbi__get8 ( s ) ; 
6123:	if ( sz != '9' && sz != '7' ) return 0 ; 
6124:	if ( stbi__get8 ( s ) != 'a' ) return 0 ; 
6125:	return 1 ; 
6126:	} 
6128:	static int stbi__gif_test ( stbi__context * s ) 
6129:	{ 
6130:	int r = stbi__gif_test_raw ( s ) ; 
6131:	stbi__rewind ( s ) ; 
6132:	return r ; 
6133:	} 
6135:	static void stbi__gif_parse_colortable ( stbi__context * s , stbi_uc pal [ 256 ] [ 4 ] , int num_entries , int transp ) 
6136:	{ 
6137:	int i ; 
6138:	for ( i = 0 ; i < num_entries ; ++ i ) { 
6139:	pal [ i ] [ 2 ] = stbi__get8 ( s ) ; 
6140:	pal [ i ] [ 1 ] = stbi__get8 ( s ) ; 
6141:	pal [ i ] [ 0 ] = stbi__get8 ( s ) ; 
6142:	pal [ i ] [ 3 ] = transp == i ? 0 : 255 ; 
6143:	} 
6144:	} 
6146:	static int stbi__gif_header ( stbi__context * s , stbi__gif * g , int * comp , int is_info ) 
6147:	{ 
6148:	stbi_uc version ; 
6149:	if ( stbi__get8 ( s ) != 'G' || stbi__get8 ( s ) != 'I' || stbi__get8 ( s ) != 'F' || stbi__get8 ( s ) != '8' ) 
6150:	return stbi__err ( "not GIF" ) ; 
6152:	version = stbi__get8 ( s ) ; 
6153:	if ( version != '7' && version != '9' ) return stbi__err ( "not GIF" ) ; 
6154:	if ( stbi__get8 ( s ) != 'a' ) return stbi__err ( "not GIF" ) ; 
6156:	stbi__g_failure_reason = "" ; 
6157:	g -> w = stbi__get16le ( s ) ; 
6158:	g -> h = stbi__get16le ( s ) ; 
6159:	g -> flags = stbi__get8 ( s ) ; 
6160:	g -> bgindex = stbi__get8 ( s ) ; 
6161:	g -> ratio = stbi__get8 ( s ) ; 
6162:	g -> transparent = - 1 ; 
6164:	if ( g -> w > ( 1 << 24 ) ) return stbi__err ( "too large" ) ; 
6165:	if ( g -> h > ( 1 << 24 ) ) return stbi__err ( "too large" ) ; 
6167:	if ( comp != 0 ) * comp = 4 ; 
6169:	if ( is_info ) return 1 ; 
6171:	if ( g -> flags & 0x80 ) 
6172:	stbi__gif_parse_colortable ( s , g -> pal , 2 << ( g -> flags & 7 ) , - 1 ) ; 
6174:	return 1 ; 
6175:	} 
6177:	static int stbi__gif_info_raw ( stbi__context * s , int * x , int * y , int * comp ) 
6178:	{ 
6179:	stbi__gif * g = ( stbi__gif * ) stbi__malloc ( sizeof ( stbi__gif ) ) ; 
6180:	if ( ! stbi__gif_header ( s , g , comp , 1 ) ) { 
6181:	free ( g ) ; 
6182:	stbi__rewind ( s ) ; 
6183:	return 0 ; 
6184:	} 
6185:	if ( x ) * x = g -> w ; 
6186:	if ( y ) * y = g -> h ; 
6187:	free ( g ) ; 
6188:	return 1 ; 
6189:	} 
6191:	static void stbi__out_gif_code ( stbi__gif * g , stbi__uint16 code ) 
6192:	{ 
6193:	stbi_uc * p , * c ; 
6194:	int idx ; 
6198:	if ( g -> codes [ code ] . prefix >= 0 ) 
6199:	stbi__out_gif_code ( g , g -> codes [ code ] . prefix ) ; 
6201:	if ( g -> cur_y >= g -> max_y ) return ; 
6203:	idx = g -> cur_x + g -> cur_y ; 
6204:	p = & g -> out [ idx ] ; 
6205:	g -> history [ idx / 4 ] = 1 ; 
6207:	c = & g -> color_table [ g -> codes [ code ] . suffix * 4 ] ; 
6208:	if ( c [ 3 ] > 128 ) { 
6209:	p [ 0 ] = c [ 2 ] ; 
6210:	p [ 1 ] = c [ 1 ] ; 
6211:	p [ 2 ] = c [ 0 ] ; 
6212:	p [ 3 ] = c [ 3 ] ; 
6213:	} 
6214:	g -> cur_x += 4 ; 
6216:	if ( g -> cur_x >= g -> max_x ) { 
6217:	g -> cur_x = g -> start_x ; 
6218:	g -> cur_y += g -> step ; 
6220:	while ( g -> cur_y >= g -> max_y && g -> parse > 0 ) { 
6221:	g -> step = ( 1 << g -> parse ) * g -> line_size ; 
6222:	g -> cur_y = g -> start_y + ( g -> step >> 1 ) ; 
6223:	-- g -> parse ; 
6224:	} 
6225:	} 
6226:	} 
6228:	static stbi_uc * stbi__process_gif_raster ( stbi__context * s , stbi__gif * g ) 
6229:	{ 
6230:	stbi_uc lzw_cs ; 
6231:	stbi__int32 len , init_code ; 
6232:	stbi__uint32 first ; 
6233:	stbi__int32 codesize , codemask , avail , oldcode , bits , valid_bits , clear ; 
6234:	stbi__gif_lzw * p ; 
6236:	lzw_cs = stbi__get8 ( s ) ; 
6237:	if ( lzw_cs > 12 ) return ( ( void * ) 0 ) ; 
6238:	clear = 1 << lzw_cs ; 
6239:	first = 1 ; 
6240:	codesize = lzw_cs + 1 ; 
6241:	codemask = ( 1 << codesize ) - 1 ; 
6242:	bits = 0 ; 
6243:	valid_bits = 0 ; 
6244:	for ( init_code = 0 ; init_code < clear ; init_code ++ ) { 
6245:	g -> codes [ init_code ] . prefix = - 1 ; 
6246:	g -> codes [ init_code ] . first = ( stbi_uc ) init_code ; 
6247:	g -> codes [ init_code ] . suffix = ( stbi_uc ) init_code ; 
6248:	} 
6251:	avail = clear + 2 ; 
6252:	oldcode = - 1 ; 
6254:	len = 0 ; 
6255:	for ( ; ; ) { 
6256:	if ( valid_bits < codesize ) { 
6257:	if ( len == 0 ) { 
6258:	len = stbi__get8 ( s ) ; 
6259:	if ( len == 0 ) 
6260:	return g -> out ; 
6261:	} 
6262:	-- len ; 
6263:	bits |= ( stbi__int32 ) stbi__get8 ( s ) << valid_bits ; 
6264:	valid_bits += 8 ; 
6265:	} else { 
6266:	stbi__int32 code = bits & codemask ; 
6267:	bits >>= codesize ; 
6268:	valid_bits -= codesize ; 
6270:	if ( code == clear ) { 
6271:	codesize = lzw_cs + 1 ; 
6272:	codemask = ( 1 << codesize ) - 1 ; 
6273:	avail = clear + 2 ; 
6274:	oldcode = - 1 ; 
6275:	first = 0 ; 
6276:	} else if ( code == clear + 1 ) { 
6277:	stbi__skip ( s , len ) ; 
6278:	while ( ( len = stbi__get8 ( s ) ) > 0 ) 
6279:	stbi__skip ( s , len ) ; 
6280:	return g -> out ; 
6281:	} else if ( code <= avail ) { 
6282:	if ( first ) { 
6283:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "no clear code" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6284:	} 
6286:	if ( oldcode >= 0 ) { 
6287:	p = & g -> codes [ avail ++ ] ; 
6288:	if ( avail > 8192 ) { 
6289:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too many codes" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6290:	} 
6292:	p -> prefix = ( stbi__int16 ) oldcode ; 
6293:	p -> first = g -> codes [ oldcode ] . first ; 
6294:	p -> suffix = ( code == avail ) ? p -> first : g -> codes [ code ] . first ; 
6295:	} else if ( code == avail ) 
6296:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "illegal code in raster" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6298:	stbi__out_gif_code ( g , ( stbi__uint16 ) code ) ; 
6300:	if ( ( avail & codemask ) == 0 && avail <= 0x0FFF ) { 
6301:	codesize ++ ; 
6302:	codemask = ( 1 << codesize ) - 1 ; 
6303:	} 
6305:	oldcode = code ; 
6306:	} else { 
6307:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "illegal code in raster" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6308:	} 
6309:	} 
6310:	} 
6311:	} 
6315:	static stbi_uc * stbi__gif_load_next ( stbi__context * s , stbi__gif * g , int * comp , int req_comp , stbi_uc * two_back ) 
6316:	{ 
6317:	int dispose ; 
6318:	int first_frame ; 
6319:	int pi ; 
6320:	int pcount ; 
6321:	( void ) sizeof ( req_comp ) ; 
6324:	first_frame = 0 ; 
6325:	if ( g -> out == 0 ) { 
6326:	if ( ! stbi__gif_header ( s , g , comp , 0 ) ) return 0 ; 
6327:	if ( ! stbi__mad3sizes_valid ( 4 , g -> w , g -> h , 0 ) ) 
6328:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6329:	pcount = g -> w * g -> h ; 
6330:	g -> out = ( stbi_uc * ) stbi__malloc ( 4 * pcount ) ; 
6331:	g -> background = ( stbi_uc * ) stbi__malloc ( 4 * pcount ) ; 
6332:	g -> history = ( stbi_uc * ) stbi__malloc ( pcount ) ; 
6333:	if ( ! g -> out || ! g -> background || ! g -> history ) 
6334:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6339:	memset ( g -> out , 0x00 , 4 * pcount ) ; 
6340:	memset ( g -> background , 0x00 , 4 * pcount ) ; 
6341:	memset ( g -> history , 0x00 , pcount ) ; 
6342:	first_frame = 1 ; 
6343:	} else { 
6345:	dispose = ( g -> eflags & 0x1C ) >> 2 ; 
6346:	pcount = g -> w * g -> h ; 
6348:	if ( ( dispose == 3 ) && ( two_back == 0 ) ) { 
6349:	dispose = 2 ; 
6350:	} 
6352:	if ( dispose == 3 ) { 
6353:	for ( pi = 0 ; pi < pcount ; ++ pi ) { 
6354:	if ( g -> history [ pi ] ) { 
6355:	memcpy ( & g -> out [ pi * 4 ] , & two_back [ pi * 4 ] , 4 ) ; 
6356:	} 
6357:	} 
6358:	} else if ( dispose == 2 ) { 
6360:	for ( pi = 0 ; pi < pcount ; ++ pi ) { 
6361:	if ( g -> history [ pi ] ) { 
6362:	memcpy ( & g -> out [ pi * 4 ] , & g -> background [ pi * 4 ] , 4 ) ; 
6363:	} 
6364:	} 
6365:	} else { 
6370:	} 
6373:	memcpy ( g -> background , g -> out , 4 * g -> w * g -> h ) ; 
6374:	} 
6377:	memset ( g -> history , 0x00 , g -> w * g -> h ) ; 
6379:	for ( ; ; ) { 
6380:	int tag = stbi__get8 ( s ) ; 
6381:	switch ( tag ) { 
6382:	case 0x2C : 
6383:	{ 
6384:	stbi__int32 x , y , w , h ; 
6385:	stbi_uc * o ; 
6387:	x = stbi__get16le ( s ) ; 
6388:	y = stbi__get16le ( s ) ; 
6389:	w = stbi__get16le ( s ) ; 
6390:	h = stbi__get16le ( s ) ; 
6391:	if ( ( ( x + w ) > ( g -> w ) ) || ( ( y + h ) > ( g -> h ) ) ) 
6392:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "bad Image Descriptor" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6394:	g -> line_size = g -> w * 4 ; 
6395:	g -> start_x = x * 4 ; 
6396:	g -> start_y = y * g -> line_size ; 
6397:	g -> max_x = g -> start_x + w * 4 ; 
6398:	g -> max_y = g -> start_y + h * g -> line_size ; 
6399:	g -> cur_x = g -> start_x ; 
6400:	g -> cur_y = g -> start_y ; 
6406:	if ( w == 0 ) 
6407:	g -> cur_y = g -> max_y ; 
6409:	g -> lflags = stbi__get8 ( s ) ; 
6411:	if ( g -> lflags & 0x40 ) { 
6412:	g -> step = 8 * g -> line_size ; 
6413:	g -> parse = 3 ; 
6414:	} else { 
6415:	g -> step = g -> line_size ; 
6416:	g -> parse = 0 ; 
6417:	} 
6419:	if ( g -> lflags & 0x80 ) { 
6420:	stbi__gif_parse_colortable ( s , g -> lpal , 2 << ( g -> lflags & 7 ) , g -> eflags & 0x01 ? g -> transparent : - 1 ) ; 
6421:	g -> color_table = ( stbi_uc * ) g -> lpal ; 
6422:	} else if ( g -> flags & 0x80 ) { 
6423:	g -> color_table = ( stbi_uc * ) g -> pal ; 
6424:	} else 
6425:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "missing color table" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6427:	o = stbi__process_gif_raster ( s , g ) ; 
6428:	if ( ! o ) return ( ( void * ) 0 ) ; 
6431:	pcount = g -> w * g -> h ; 
6432:	if ( first_frame && ( g -> bgindex > 0 ) ) { 
6434:	for ( pi = 0 ; pi < pcount ; ++ pi ) { 
6435:	if ( g -> history [ pi ] == 0 ) { 
6436:	g -> pal [ g -> bgindex ] [ 3 ] = 255 ; 
6437:	memcpy ( & g -> out [ pi * 4 ] , & g -> pal [ g -> bgindex ] , 4 ) ; 
6438:	} 
6439:	} 
6440:	} 
6442:	return o ; 
6443:	} 
6445:	case 0x21 : 
6446:	{ 
6447:	int len ; 
6448:	int ext = stbi__get8 ( s ) ; 
6449:	if ( ext == 0xF9 ) { 
6450:	len = stbi__get8 ( s ) ; 
6451:	if ( len == 4 ) { 
6452:	g -> eflags = stbi__get8 ( s ) ; 
6453:	g -> delay = 10 * stbi__get16le ( s ) ; 
6456:	if ( g -> transparent >= 0 ) { 
6457:	g -> pal [ g -> transparent ] [ 3 ] = 255 ; 
6458:	} 
6459:	if ( g -> eflags & 0x01 ) { 
6460:	g -> transparent = stbi__get8 ( s ) ; 
6461:	if ( g -> transparent >= 0 ) { 
6462:	g -> pal [ g -> transparent ] [ 3 ] = 0 ; 
6463:	} 
6464:	} else { 
6466:	stbi__skip ( s , 1 ) ; 
6467:	g -> transparent = - 1 ; 
6468:	} 
6469:	} else { 
6470:	stbi__skip ( s , len ) ; 
6471:	break ; 
6472:	} 
6473:	} 
6474:	while ( ( len = stbi__get8 ( s ) ) != 0 ) { 
6475:	stbi__skip ( s , len ) ; 
6476:	} 
6477:	break ; 
6478:	} 
6480:	case 0x3B : 
6481:	return ( stbi_uc * ) s ; 
6483:	default : 
6484:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "unknown code" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6485:	} 
6486:	} 
6487:	} 
6489:	static void * stbi__load_gif_main ( stbi__context * s , int * * delays , int * x , int * y , int * z , int * comp , int req_comp ) 
6490:	{ 
6491:	if ( stbi__gif_test ( s ) ) { 
6492:	int layers = 0 ; 
6493:	stbi_uc * u = 0 ; 
6494:	stbi_uc * out = 0 ; 
6495:	stbi_uc * two_back = 0 ; 
6496:	stbi__gif g ; 
6497:	int stride ; 
6498:	int out_size = 0 ; 
6499:	int delays_size = 0 ; 
6500:	memset ( & g , 0 , sizeof ( g ) ) ; 
6501:	if ( delays ) { 
6502:	* delays = 0 ; 
6503:	} 
6505:	do { 
6506:	u = stbi__gif_load_next ( s , & g , comp , req_comp , two_back ) ; 
6507:	if ( u == ( stbi_uc * ) s ) u = 0 ; 
6509:	if ( u ) { 
6510:	* x = g . w ; 
6511:	* y = g . h ; 
6512:	++ layers ; 
6513:	stride = g . w * g . h * 4 ; 
6515:	if ( out ) { 
6516:	void * tmp = ( stbi_uc * ) realloc ( out , layers * stride ) ; 
6517:	if ( ( ( void * ) 0 ) == tmp ) { 
6518:	free ( g . out ) ; 
6519:	free ( g . history ) ; 
6520:	free ( g . background ) ; 
6521:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6522:	} 
6523:	else { 
6524:	out = ( stbi_uc * ) tmp ; 
6525:	out_size = layers * stride ; 
6526:	} 
6528:	if ( delays ) { 
6529:	* delays = ( int * ) realloc ( * delays , sizeof ( int ) * layers ) ; 
6530:	delays_size = layers * sizeof ( int ) ; 
6531:	} 
6532:	} else { 
6533:	out = ( stbi_uc * ) stbi__malloc ( layers * stride ) ; 
6534:	out_size = layers * stride ; 
6535:	if ( delays ) { 
6536:	* delays = ( int * ) stbi__malloc ( layers * sizeof ( int ) ) ; 
6537:	delays_size = layers * sizeof ( int ) ; 
6538:	} 
6539:	} 
6540:	memcpy ( out + ( ( layers - 1 ) * stride ) , u , stride ) ; 
6541:	if ( layers >= 2 ) { 
6542:	two_back = out - 2 * stride ; 
6543:	} 
6545:	if ( delays ) { 
6546:	( * delays ) [ layers - 1 U ] = g . delay ; 
6547:	} 
6548:	} 
6549:	} while ( u != 0 ) ; 
6552:	free ( g . out ) ; 
6553:	free ( g . history ) ; 
6554:	free ( g . background ) ; 
6557:	if ( req_comp && req_comp != 4 ) 
6558:	out = stbi__convert_format ( out , 4 , req_comp , layers * g . w , g . h ) ; 
6560:	* z = layers ; 
6561:	return out ; 
6562:	} else { 
6563:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "not GIF" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6564:	} 
6565:	} 
6567:	static void * stbi__gif_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri ) 
6568:	{ 
6569:	stbi_uc * u = 0 ; 
6570:	stbi__gif g ; 
6571:	memset ( & g , 0 , sizeof ( g ) ) ; 
6572:	( void ) sizeof ( ri ) ; 
6574:	u = stbi__gif_load_next ( s , & g , comp , req_comp , 0 ) ; 
6575:	if ( u == ( stbi_uc * ) s ) u = 0 ; 
6576:	if ( u ) { 
6577:	* x = g . w ; 
6578:	* y = g . h ; 
6582:	if ( req_comp && req_comp != 4 ) 
6583:	u = stbi__convert_format ( u , 4 , req_comp , g . w , g . h ) ; 
6584:	} else if ( g . out ) { 
6586:	free ( g . out ) ; 
6587:	} 
6590:	free ( g . history ) ; 
6591:	free ( g . background ) ; 
6593:	return u ; 
6594:	} 
6596:	static int stbi__gif_info ( stbi__context * s , int * x , int * y , int * comp ) 
6597:	{ 
6598:	return stbi__gif_info_raw ( s , x , y , comp ) ; 
6599:	} 
6606:	static int stbi__hdr_test_core ( stbi__context * s , const char * signature ) 
6607:	{ 
6608:	int i ; 
6609:	for ( i = 0 ; signature [ i ] ; ++ i ) 
6610:	if ( stbi__get8 ( s ) != signature [ i ] ) 
6611:	return 0 ; 
6612:	stbi__rewind ( s ) ; 
6613:	return 1 ; 
6614:	} 
6616:	static int stbi__hdr_test ( stbi__context * s ) 
6617:	{ 
6618:	int r = stbi__hdr_test_core ( s , "#?RADIANCE\n" ) ; 
6619:	stbi__rewind ( s ) ; 
6620:	if ( ! r ) { 
6621:	r = stbi__hdr_test_core ( s , "#?RGBE\n" ) ; 
6622:	stbi__rewind ( s ) ; 
6623:	} 
6624:	return r ; 
6625:	} 
6628:	static char * stbi__hdr_gettoken ( stbi__context * z , char * buffer ) 
6629:	{ 
6630:	int len = 0 ; 
6631:	char c = '\0' ; 
6633:	c = ( char ) stbi__get8 ( z ) ; 
6635:	while ( ! stbi__at_eof ( z ) && c != '\n' ) { 
6636:	buffer [ len ++ ] = c ; 
6637:	if ( len == 1024 - 1 ) { 
6639:	while ( ! stbi__at_eof ( z ) && stbi__get8 ( z ) != '\n' ) 
6640:	; 
6641:	break ; 
6642:	} 
6643:	c = ( char ) stbi__get8 ( z ) ; 
6644:	} 
6646:	buffer [ len ] = 0 ; 
6647:	return buffer ; 
6648:	} 
6650:	static void stbi__hdr_convert ( float * output , stbi_uc * input , int req_comp ) 
6651:	{ 
6652:	if ( input [ 3 ] != 0 ) { 
6653:	float f1 ; 
6655:	f1 = ( float ) ldexp ( 1 . 0 f , input [ 3 ] - ( int ) ( 128 + 8 ) ) ; 
6656:	if ( req_comp <= 2 ) 
6657:	output [ 0 ] = ( input [ 0 ] + input [ 1 ] + input [ 2 ] ) * f1 / 3 ; 
6658:	else { 
6659:	output [ 0 ] = input [ 0 ] * f1 ; 
6660:	output [ 1 ] = input [ 1 ] * f1 ; 
6661:	output [ 2 ] = input [ 2 ] * f1 ; 
6662:	} 
6663:	if ( req_comp == 2 ) output [ 1 ] = 1 ; 
6664:	if ( req_comp == 4 ) output [ 3 ] = 1 ; 
6665:	} else { 
6666:	switch ( req_comp ) { 
6667:	case 4 : output [ 3 ] = 1 ; 
6668:	case 3 : output [ 0 ] = output [ 1 ] = output [ 2 ] = 0 ; 
6669:	break ; 
6670:	case 2 : output [ 1 ] = 1 ; 
6671:	case 1 : output [ 0 ] = 0 ; 
6672:	break ; 
6673:	} 
6674:	} 
6675:	} 
6677:	static float * stbi__hdr_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri ) 
6678:	{ 
6679:	char buffer [ 1024 ] ; 
6680:	char * token ; 
6681:	int valid = 0 ; 
6682:	int width , height ; 
6683:	stbi_uc * scanline ; 
6684:	float * hdr_data ; 
6685:	int len ; 
6686:	unsigned char count , value ; 
6687:	int i , j , k , c1 , c2 , z ; 
6688:	const char * headerToken ; 
6689:	( void ) sizeof ( ri ) ; 
6692:	headerToken = stbi__hdr_gettoken ( s , buffer ) ; 
6693:	if ( strcmp ( headerToken , "#?RADIANCE" ) != 0 && strcmp ( headerToken , "#?RGBE" ) != 0 ) 
6694:	return ( ( float * ) ( size_t ) ( stbi__err ( "not HDR" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6697:	for ( ; ; ) { 
6698:	token = stbi__hdr_gettoken ( s , buffer ) ; 
6699:	if ( token [ 0 ] == 0 ) break ; 
6700:	if ( strcmp ( token , "FORMAT=32-bit_rle_rgbe" ) == 0 ) valid = 1 ; 
6701:	} 
6703:	if ( ! valid ) return ( ( float * ) ( size_t ) ( stbi__err ( "unsupported format" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6707:	token = stbi__hdr_gettoken ( s , buffer ) ; 
6708:	if ( strncmp ( token , "-Y " , 3 ) ) return ( ( float * ) ( size_t ) ( stbi__err ( "unsupported data layout" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6709:	token += 3 ; 
6710:	height = ( int ) strtol ( token , & token , 10 ) ; 
6711:	while ( * token == ' ' ) ++ token ; 
6712:	if ( strncmp ( token , "+X " , 3 ) ) return ( ( float * ) ( size_t ) ( stbi__err ( "unsupported data layout" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6713:	token += 3 ; 
6714:	width = ( int ) strtol ( token , ( ( void * ) 0 ) , 10 ) ; 
6716:	if ( height > ( 1 << 24 ) ) return ( ( float * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6717:	if ( width > ( 1 << 24 ) ) return ( ( float * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6719:	* x = width ; 
6720:	* y = height ; 
6722:	if ( comp ) * comp = 3 ; 
6723:	if ( req_comp == 0 ) req_comp = 3 ; 
6725:	if ( ! stbi__mad4sizes_valid ( width , height , req_comp , sizeof ( float ) , 0 ) ) 
6726:	return ( ( float * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6729:	hdr_data = ( float * ) stbi__malloc_mad4 ( width , height , req_comp , sizeof ( float ) , 0 ) ; 
6730:	if ( ! hdr_data ) 
6731:	return ( ( float * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6735:	if ( width < 8 || width >= 32768 ) { 
6737:	for ( j = 0 ; j < height ; ++ j ) { 
6738:	for ( i = 0 ; i < width ; ++ i ) { 
6739:	stbi_uc rgbe [ 4 ] ; 
6740:	main_decode_loop : 
6741:	stbi__getn ( s , rgbe , 4 ) ; 
6742:	stbi__hdr_convert ( hdr_data + j * width * req_comp + i * req_comp , rgbe , req_comp ) ; 
6743:	} 
6744:	} 
6745:	} else { 
6747:	scanline = ( ( void * ) 0 ) ; 
6749:	for ( j = 0 ; j < height ; ++ j ) { 
6750:	c1 = stbi__get8 ( s ) ; 
6751:	c2 = stbi__get8 ( s ) ; 
6752:	len = stbi__get8 ( s ) ; 
6753:	if ( c1 != 2 || c2 != 2 || ( len & 0x80 ) ) { 
6756:	stbi_uc rgbe [ 4 ] ; 
6757:	rgbe [ 0 ] = ( stbi_uc ) c1 ; 
6758:	rgbe [ 1 ] = ( stbi_uc ) c2 ; 
6759:	rgbe [ 2 ] = ( stbi_uc ) len ; 
6760:	rgbe [ 3 ] = ( stbi_uc ) stbi__get8 ( s ) ; 
6761:	stbi__hdr_convert ( hdr_data , rgbe , req_comp ) ; 
6762:	i = 1 ; 
6763:	j = 0 ; 
6764:	free ( scanline ) ; 
6765:	goto main_decode_loop ; 
6766:	} 
6767:	len <<= 8 ; 
6768:	len |= stbi__get8 ( s ) ; 
6769:	if ( len != width ) { free ( hdr_data ) ; free ( scanline ) ; return ( ( float * ) ( size_t ) ( stbi__err ( "invalid decoded scanline length" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; } 
6770:	if ( scanline == ( ( void * ) 0 ) ) { 
6771:	scanline = ( stbi_uc * ) stbi__malloc_mad2 ( width , 4 , 0 ) ; 
6772:	if ( ! scanline ) { 
6773:	free ( hdr_data ) ; 
6774:	return ( ( float * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
6775:	} 
6776:	} 
6778:	for ( k = 0 ; k < 4 ; ++ k ) { 
6779:	int nleft ; 
6780:	i = 0 ; 
6781:	while ( ( nleft = width - i ) > 0 ) { 
6782:	count = stbi__get8 ( s ) ; 
6783:	if ( count > 128 ) { 
6785:	value = stbi__get8 ( s ) ; 
6786:	count -= 128 ; 
6787:	if ( count > nleft ) { free ( hdr_data ) ; free ( scanline ) ; return ( ( float * ) ( size_t ) ( stbi__err ( "corrupt" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; } 
6788:	for ( z = 0 ; z < count ; ++ z ) 
6789:	scanline [ i ++ * 4 + k ] = value ; 
6790:	} else { 
6792:	if ( count > nleft ) { free ( hdr_data ) ; free ( scanline ) ; return ( ( float * ) ( size_t ) ( stbi__err ( "corrupt" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; } 
6793:	for ( z = 0 ; z < count ; ++ z ) 
6794:	scanline [ i ++ * 4 + k ] = stbi__get8 ( s ) ; 
6795:	} 
6796:	} 
6797:	} 
6798:	for ( i = 0 ; i < width ; ++ i ) 
6799:	stbi__hdr_convert ( hdr_data + ( j * width + i ) * req_comp , scanline + i * 4 , req_comp ) ; 
6800:	} 
6801:	if ( scanline ) 
6802:	free ( scanline ) ; 
6803:	} 
6805:	return hdr_data ; 
6806:	} 
6808:	static int stbi__hdr_info ( stbi__context * s , int * x , int * y , int * comp ) 
6809:	{ 
6810:	char buffer [ 1024 ] ; 
6811:	char * token ; 
6812:	int valid = 0 ; 
6813:	int dummy ; 
6815:	if ( ! x ) x = & dummy ; 
6816:	if ( ! y ) y = & dummy ; 
6817:	if ( ! comp ) comp = & dummy ; 
6819:	if ( stbi__hdr_test ( s ) == 0 ) { 
6820:	stbi__rewind ( s ) ; 
6821:	return 0 ; 
6822:	} 
6824:	for ( ; ; ) { 
6825:	token = stbi__hdr_gettoken ( s , buffer ) ; 
6826:	if ( token [ 0 ] == 0 ) break ; 
6827:	if ( strcmp ( token , "FORMAT=32-bit_rle_rgbe" ) == 0 ) valid = 1 ; 
6828:	} 
6830:	if ( ! valid ) { 
6831:	stbi__rewind ( s ) ; 
6832:	return 0 ; 
6833:	} 
6834:	token = stbi__hdr_gettoken ( s , buffer ) ; 
6835:	if ( strncmp ( token , "-Y " , 3 ) ) { 
6836:	stbi__rewind ( s ) ; 
6837:	return 0 ; 
6838:	} 
6839:	token += 3 ; 
6840:	* y = ( int ) strtol ( token , & token , 10 ) ; 
6841:	while ( * token == ' ' ) ++ token ; 
6842:	if ( strncmp ( token , "+X " , 3 ) ) { 
6843:	stbi__rewind ( s ) ; 
6844:	return 0 ; 
6845:	} 
6846:	token += 3 ; 
6847:	* x = ( int ) strtol ( token , ( ( void * ) 0 ) , 10 ) ; 
6848:	* comp = 3 ; 
6849:	return 1 ; 
6850:	} 
6854:	static int stbi__bmp_info ( stbi__context * s , int * x , int * y , int * comp ) 
6855:	{ 
6856:	void * p ; 
6857:	stbi__bmp_data info ; 
6859:	info . all_a = 255 ; 
6860:	p = stbi__bmp_parse_header ( s , & info ) ; 
6861:	stbi__rewind ( s ) ; 
6862:	if ( p == ( ( void * ) 0 ) ) 
6863:	return 0 ; 
6864:	if ( x ) * x = s -> img_x ; 
6865:	if ( y ) * y = s -> img_y ; 
6866:	if ( comp ) { 
6867:	if ( info . bpp == 24 && info . ma == 0xff000000 ) 
6868:	* comp = 3 ; 
6869:	else 
6870:	* comp = info . ma ? 4 : 3 ; 
6871:	} 
6872:	return 1 ; 
6873:	} 
6877:	static int stbi__psd_info ( stbi__context * s , int * x , int * y , int * comp ) 
6878:	{ 
6879:	int channelCount , dummy , depth ; 
6880:	if ( ! x ) x = & dummy ; 
6881:	if ( ! y ) y = & dummy ; 
6882:	if ( ! comp ) comp = & dummy ; 
6883:	if ( stbi__get32be ( s ) != 0x38425053 ) { 
6884:	stbi__rewind ( s ) ; 
6885:	return 0 ; 
6886:	} 
6887:	if ( stbi__get16be ( s ) != 1 ) { 
6888:	stbi__rewind ( s ) ; 
6889:	return 0 ; 
6890:	} 
6891:	stbi__skip ( s , 6 ) ; 
6892:	channelCount = stbi__get16be ( s ) ; 
6893:	if ( channelCount < 0 || channelCount > 16 ) { 
6894:	stbi__rewind ( s ) ; 
6895:	return 0 ; 
6896:	} 
6897:	* y = stbi__get32be ( s ) ; 
6898:	* x = stbi__get32be ( s ) ; 
6899:	depth = stbi__get16be ( s ) ; 
6900:	if ( depth != 8 && depth != 16 ) { 
6901:	stbi__rewind ( s ) ; 
6902:	return 0 ; 
6903:	} 
6904:	if ( stbi__get16be ( s ) != 3 ) { 
6905:	stbi__rewind ( s ) ; 
6906:	return 0 ; 
6907:	} 
6908:	* comp = 4 ; 
6909:	return 1 ; 
6910:	} 
6912:	static int stbi__psd_is16 ( stbi__context * s ) 
6913:	{ 
6914:	int channelCount , depth ; 
6915:	if ( stbi__get32be ( s ) != 0x38425053 ) { 
6916:	stbi__rewind ( s ) ; 
6917:	return 0 ; 
6918:	} 
6919:	if ( stbi__get16be ( s ) != 1 ) { 
6920:	stbi__rewind ( s ) ; 
6921:	return 0 ; 
6922:	} 
6923:	stbi__skip ( s , 6 ) ; 
6924:	channelCount = stbi__get16be ( s ) ; 
6925:	if ( channelCount < 0 || channelCount > 16 ) { 
6926:	stbi__rewind ( s ) ; 
6927:	return 0 ; 
6928:	} 
6929:	( void ) stbi__get32be ( s ) ; 
6930:	( void ) stbi__get32be ( s ) ; 
6931:	depth = stbi__get16be ( s ) ; 
6932:	if ( depth != 16 ) { 
6933:	stbi__rewind ( s ) ; 
6934:	return 0 ; 
6935:	} 
6936:	return 1 ; 
6937:	} 
6941:	static int stbi__pic_info ( stbi__context * s , int * x , int * y , int * comp ) 
6942:	{ 
6943:	int act_comp = 0 , num_packets = 0 , chained , dummy ; 
6944:	stbi__pic_packet packets [ 10 ] ; 
6946:	if ( ! x ) x = & dummy ; 
6947:	if ( ! y ) y = & dummy ; 
6948:	if ( ! comp ) comp = & dummy ; 
6950:	if ( ! stbi__pic_is4 ( s , "\x53\x80\xF6\x34" ) ) { 
6951:	stbi__rewind ( s ) ; 
6952:	return 0 ; 
6953:	} 
6955:	stbi__skip ( s , 88 ) ; 
6957:	* x = stbi__get16be ( s ) ; 
6958:	* y = stbi__get16be ( s ) ; 
6959:	if ( stbi__at_eof ( s ) ) { 
6960:	stbi__rewind ( s ) ; 
6961:	return 0 ; 
6962:	} 
6963:	if ( ( * x ) != 0 && ( 1 << 28 ) / ( * x ) < ( * y ) ) { 
6964:	stbi__rewind ( s ) ; 
6965:	return 0 ; 
6966:	} 
6968:	stbi__skip ( s , 8 ) ; 
6970:	do { 
6971:	stbi__pic_packet * packet ; 
6973:	if ( num_packets == sizeof ( packets ) / sizeof ( packets [ 0 ] ) ) 
6974:	return 0 ; 
6976:	packet = & packets [ num_packets ++ ] ; 
6977:	chained = stbi__get8 ( s ) ; 
6978:	packet -> size = stbi__get8 ( s ) ; 
6979:	packet -> type = stbi__get8 ( s ) ; 
6980:	packet -> channel = stbi__get8 ( s ) ; 
6981:	act_comp |= packet -> channel ; 
6983:	if ( stbi__at_eof ( s ) ) { 
6984:	stbi__rewind ( s ) ; 
6985:	return 0 ; 
6986:	} 
6987:	if ( packet -> size != 8 ) { 
6988:	stbi__rewind ( s ) ; 
6989:	return 0 ; 
6990:	} 
6991:	} while ( chained ) ; 
6993:	* comp = ( act_comp & 0x10 ? 4 : 3 ) ; 
6995:	return 1 ; 
6996:	} 
7013:	static int stbi__pnm_test ( stbi__context * s ) 
7014:	{ 
7015:	char p , t ; 
7016:	p = ( char ) stbi__get8 ( s ) ; 
7017:	t = ( char ) stbi__get8 ( s ) ; 
7018:	if ( p != 'P' || ( t != '5' && t != '6' ) ) { 
7019:	stbi__rewind ( s ) ; 
7020:	return 0 ; 
7021:	} 
7022:	return 1 ; 
7023:	} 
7025:	static void * stbi__pnm_load ( stbi__context * s , int * x , int * y , int * comp , int req_comp , stbi__result_info * ri ) 
7026:	{ 
7027:	stbi_uc * out ; 
7028:	( void ) sizeof ( ri ) ; 
7030:	if ( ! stbi__pnm_info ( s , ( int * ) & s -> img_x , ( int * ) & s -> img_y , ( int * ) & s -> img_n ) ) 
7031:	return 0 ; 
7033:	if ( s -> img_y > ( 1 << 24 ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
7034:	if ( s -> img_x > ( 1 << 24 ) ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
7036:	* x = s -> img_x ; 
7037:	* y = s -> img_y ; 
7038:	if ( comp ) * comp = s -> img_n ; 
7040:	if ( ! stbi__mad3sizes_valid ( s -> img_n , s -> img_x , s -> img_y , 0 ) ) 
7041:	return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "too large" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
7043:	out = ( stbi_uc * ) stbi__malloc_mad3 ( s -> img_n , s -> img_x , s -> img_y , 0 ) ; 
7044:	if ( ! out ) return ( ( unsigned char * ) ( size_t ) ( stbi__err ( "outofmem" ) ? ( ( void * ) 0 ) : ( ( void * ) 0 ) ) ) ; 
7045:	stbi__getn ( s , out , s -> img_n * s -> img_x * s -> img_y ) ; 
7047:	if ( req_comp && req_comp != s -> img_n ) { 
7048:	out = stbi__convert_format ( out , s -> img_n , req_comp , s -> img_x , s -> img_y ) ; 
7049:	if ( out == ( ( void * ) 0 ) ) return out ; 
7050:	} 
7051:	return out ; 
7052:	} 
7054:	static int stbi__pnm_isspace ( char c ) 
7055:	{ 
7056:	return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r' ; 
7057:	} 
7059:	static void stbi__pnm_skip_whitespace ( stbi__context * s , char * c ) 
7060:	{ 
7061:	for ( ; ; ) { 
7062:	while ( ! stbi__at_eof ( s ) && stbi__pnm_isspace ( * c ) ) 
7063:	* c = ( char ) stbi__get8 ( s ) ; 
7065:	if ( stbi__at_eof ( s ) || * c != '#' ) 
7066:	break ; 
7068:	while ( ! stbi__at_eof ( s ) && * c != '\n' && * c != '\r' ) 
7069:	* c = ( char ) stbi__get8 ( s ) ; 
7070:	} 
7071:	} 
7073:	static int stbi__pnm_isdigit ( char c ) 
7074:	{ 
7075:	return c >= '0' && c <= '9' ; 
7076:	} 
7078:	static int stbi__pnm_getinteger ( stbi__context * s , char * c ) 
7079:	{ 
7080:	int value = 0 ; 
7082:	while ( ! stbi__at_eof ( s ) && stbi__pnm_isdigit ( * c ) ) { 
7083:	value = value * 10 + ( * c - '0' ) ; 
7084:	* c = ( char ) stbi__get8 ( s ) ; 
7085:	} 
7087:	return value ; 
7088:	} 
7090:	static int stbi__pnm_info ( stbi__context * s , int * x , int * y , int * comp ) 
7091:	{ 
7092:	int maxv , dummy ; 
7093:	char c , p , t ; 
7095:	if ( ! x ) x = & dummy ; 
7096:	if ( ! y ) y = & dummy ; 
7097:	if ( ! comp ) comp = & dummy ; 
7099:	stbi__rewind ( s ) ; 
7102:	p = ( char ) stbi__get8 ( s ) ; 
7103:	t = ( char ) stbi__get8 ( s ) ; 
7104:	if ( p != 'P' || ( t != '5' && t != '6' ) ) { 
7105:	stbi__rewind ( s ) ; 
7106:	return 0 ; 
7107:	} 
7109:	* comp = ( t == '6' ) ? 3 : 1 ; 
7111:	c = ( char ) stbi__get8 ( s ) ; 
7112:	stbi__pnm_skip_whitespace ( s , & c ) ; 
7114:	* x = stbi__pnm_getinteger ( s , & c ) ; 
7115:	stbi__pnm_skip_whitespace ( s , & c ) ; 
7117:	* y = stbi__pnm_getinteger ( s , & c ) ; 
7118:	stbi__pnm_skip_whitespace ( s , & c ) ; 
7120:	maxv = stbi__pnm_getinteger ( s , & c ) ; 
7122:	if ( maxv > 255 ) 
7123:	return stbi__err ( "max value > 255" ) ; 
7124:	else 
7125:	return 1 ; 
7126:	} 
7129:	static int stbi__info_main ( stbi__context * s , int * x , int * y , int * comp ) 
7130:	{ 
7132:	if ( stbi__jpeg_info ( s , x , y , comp ) ) return 1 ; 
7136:	if ( stbi__png_info ( s , x , y , comp ) ) return 1 ; 
7140:	if ( stbi__gif_info ( s , x , y , comp ) ) return 1 ; 
7144:	if ( stbi__bmp_info ( s , x , y , comp ) ) return 1 ; 
7148:	if ( stbi__psd_info ( s , x , y , comp ) ) return 1 ; 
7152:	if ( stbi__pic_info ( s , x , y , comp ) ) return 1 ; 
7156:	if ( stbi__pnm_info ( s , x , y , comp ) ) return 1 ; 
7160:	if ( stbi__hdr_info ( s , x , y , comp ) ) return 1 ; 
7165:	if ( stbi__tga_info ( s , x , y , comp ) ) 
7166:	return 1 ; 
7168:	return stbi__err ( "unknown image type" ) ; 
7169:	} 
7171:	static int stbi__is_16_main ( stbi__context * s ) 
7172:	{ 
7174:	if ( stbi__png_is16 ( s ) ) return 1 ; 
7178:	if ( stbi__psd_is16 ( s ) ) return 1 ; 
7181:	return 0 ; 
7182:	} 
7185:	extern int stbi_info ( char const * filename , int * x , int * y , int * comp ) 
7186:	{ 
7187:	FILE * f = stbi__fopen ( filename , "rb" ) ; 
7188:	int result ; 
7189:	if ( ! f ) return stbi__err ( "can't fopen" ) ; 
7190:	result = stbi_info_from_file ( f , x , y , comp ) ; 
7191:	fclose ( f ) ; 
7192:	return result ; 
7193:	} 
7195:	extern int stbi_info_from_file ( FILE * f , int * x , int * y , int * comp ) 
7196:	{ 
7197:	int r ; 
7198:	stbi__context s ; 
7199:	long pos = ftell ( f ) ; 
7200:	stbi__start_file ( & s , f ) ; 
7201:	r = stbi__info_main ( & s , x , y , comp ) ; 
7202:	fseek ( f , pos , 0 ) ; 
7203:	return r ; 
7204:	} 
7206:	extern int stbi_is_16_bit ( char const * filename ) 
7207:	{ 
7208:	FILE * f = stbi__fopen ( filename , "rb" ) ; 
7209:	int result ; 
7210:	if ( ! f ) return stbi__err ( "can't fopen" ) ; 
7211:	result = stbi_is_16_bit_from_file ( f ) ; 
7212:	fclose ( f ) ; 
7213:	return result ; 
7214:	} 
7216:	extern int stbi_is_16_bit_from_file ( FILE * f ) 
7217:	{ 
7218:	int r ; 
7219:	stbi__context s ; 
7220:	long pos = ftell ( f ) ; 
7221:	stbi__start_file ( & s , f ) ; 
7222:	r = stbi__is_16_main ( & s ) ; 
7223:	fseek ( f , pos , 0 ) ; 
7224:	return r ; 
7225:	} 
7228:	extern int stbi_info_from_memory ( stbi_uc const * buffer , int len , int * x , int * y , int * comp ) 
7229:	{ 
7230:	stbi__context s ; 
7231:	stbi__start_mem ( & s , buffer , len ) ; 
7232:	return stbi__info_main ( & s , x , y , comp ) ; 
7233:	} 
7235:	extern int stbi_info_from_callbacks ( stbi_io_callbacks const * c , void * user , int * x , int * y , int * comp ) 
7236:	{ 
7237:	stbi__context s ; 
7238:	stbi__start_callbacks ( & s , ( stbi_io_callbacks * ) c , user ) ; 
7239:	return stbi__info_main ( & s , x , y , comp ) ; 
7240:	} 
7242:	extern int stbi_is_16_bit_from_memory ( stbi_uc const * buffer , int len ) 
7243:	{ 
7244:	stbi__context s ; 
7245:	stbi__start_mem ( & s , buffer , len ) ; 
7246:	return stbi__is_16_main ( & s ) ; 
7247:	} 
7249:	extern int stbi_is_16_bit_from_callbacks ( stbi_io_callbacks const * c , void * user ) 
7250:	{ 
7251:	stbi__context s ; 
7252:	stbi__start_callbacks ( & s , ( stbi_io_callbacks * ) c , user ) ; 
7253:	return stbi__is_16_main ( & s ) ; 
7254:	} 
  0:	 